<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Thực hành tối ưu những ứng dụng React · Learn and Share</title><meta name="description" content="Thực hành tối ưu những ứng dụng React - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Thực hành tối ưu những ứng dụng React"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*DWqrndqrZxYXqHT789XK1g.jpeg"><meta property="og:description" content="React có thể chậm. Ý tôi là, bất kỳ ứng dụng React với kích thước trung bình có thể có vẻ chậm. Nhưng trước khi bạn bắt đầu tìm kiếm các phương án thay thế, bạn nên biết rằng bất kỳ ứng dụng Angular hay Ember cỡ trung bình nào cũng chậm.
Tin vui là: Nếu bạn quan tâm đến hiệu suất, nó khá dễ dàng để làm bất kỳ ứng dụng React trở nên siêu nhanh ⚡.️ Đây là cách."></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Thực hành tối ưu những ứng dụng React</h1><h2 class="post-subtitle"></h2><header class="post-info">Aug 21, 2017<div class="tags"><a href="/tags/react" class="tag-link">#react</a></div><div class="fb-ir-time"><time datetime="2017-08-21T12:21:55.000Z" class="op-modified"></time><time datetime="2017-08-21T12:21:55.000Z" class="op-published"></time></div></header></div><div class="post-banner"><img src="https://cdn-images-1.medium.com/max/2000/1*DWqrndqrZxYXqHT789XK1g.jpeg"></div><div class="wrap"><div class="post-content"><p>React có thể chậm. Ý tôi là, bất kỳ ứng dụng React với kích thước trung bình có thể có vẻ chậm. Nhưng trước khi bạn bắt đầu tìm kiếm các phương án thay thế, bạn nên biết rằng bất kỳ ứng dụng Angular hay Ember cỡ trung bình nào cũng chậm.</p>
<p>Tin vui là: Nếu bạn quan tâm đến hiệu suất, <strong>nó khá dễ dàng để làm bất kỳ ứng dụng React trở nên siêu nhanh</strong> ⚡.️ <em>Đây là cách.</em><br><a id="more"></a></p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*WK96fqAKMrDMBjXB9yNAhg.jpeg" alt=""></p>
<h3 id="Measuring-React-Performance"><a href="#Measuring-React-Performance" class="headerlink" title="Measuring React Performance"></a>Measuring React Performance</h3><p>What do I mean by “slow”? Let’s take an example:</p>
<p>I’m working on an open-source project called <a href="https://github.com/marmelab/admin-on-rest" target="_blank" rel="noopener">admin-on-rest</a>, which leverages <a href="http://www.material-ui.com/#/" target="_blank" rel="noopener">material-ui</a> and <a href="http://redux.js.org/" target="_blank" rel="noopener">Redux</a> to provide an admin GUI for any REST API. This application has a datagrid page, displaying a list of records in a table. When the user changes the sort order, or goes to the next page, or filters the result, the interface isn’t as responsive as I would expect.</p>
<p>The following screencast shows the refresh slowed down five times:</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*k1biR4XU_ckJzO-ywq2KHQ.gif" alt=""></p>
<p>To see what’s happening, I append a <code>?react_perf</code> to the URL. This enables <a href="https://facebook.github.io/react/blog/2016/11/16/react-v15.4.0.html#profiling-components-with-chrome-timeline" target="_blank" rel="noopener">Component Profiling</a> since React 15.4. I wait for the initial datagrid to load. Then I open the Chrome Developer Tools on the Timeline tab, hit the “Record” button, and click on a table header to update the sort order.</p>
<p>Once the data refreshes, I hit the “Record” button again to stop recording, and Chrome displays a yellow flamegraph with a “User Timing” label.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*ebhLMlVC1rSBdkmMdqnRmw.png" alt=""></p>
<p>If you’ve never seen a flamegraph, it can look intimidating, but it’s actually very easy to use. This “User Timing” graph shows the time passed in each of your components. It hides the time spend inside React internals (you can’t optimize this time anyway), so it lets you focus on optimizing your app.</p>
<p>The Timeline displays screenshots of the window at various stages, this lets me zoom in to the moment I clicked on the table header:</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*TgP1MXMp-ArO8axt8hPT0Q.png" alt=""></p>
<p>It seems that my app rerenders the <code>&lt;List&gt;</code> component just after clicking on the sort button, <em>before</em> even fetching the REST data. And this takes more than 500ms. The app just updates the sort icon in the table header, and displays a grey overlay on the datagrid to show that the data is being fetched.</p>
<p>To put it otherwise, the app takes half a second to provide visual feedback to a click. Half a second is definitely perceivable — UI experts say that <a href="https://www.nngroup.com/articles/website-response-times/" target="_blank" rel="noopener">users perceive an interface change as instantaneous when it’s below 100ms</a>. A change slower than that is what I mean by “slow”.</p>
<h3 id="Why-Did-You-Update"><a href="#Why-Did-You-Update" class="headerlink" title="Why Did You Update?"></a>Why Did You Update?</h3><p>In the flamegraph above, you can see many tiny pits. That’s not a good sign. It means that many components are rerendered. The flamegraph shows that the <code>&lt;Datagrid&gt;</code> update takes the most time. Why did the app rerender the entire datagrid before fetching new data? <em>Let’s dig down.</em></p>
<p>Understanding the causes of a rerender often implies adding <code>console.log()</code> statements in <code>render()</code> functions. For functional components, you can use the following one-liner Higher-Order Component (HOC):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/log.js</span></span><br><span class="line"><span class="keyword">const</span> log = <span class="function"><span class="params">BaseComponent</span> =&gt;</span> props =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">`Rendering <span class="subst">$&#123;BaseComponent.name&#125;</span>`</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">BaseComponent</span> &#123;…<span class="attr">props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">export default log;// in src/MyComponent.js</span></span><br><span class="line"><span class="xml">import log from ‘./log’;</span></span><br><span class="line"><span class="xml">export default log(MyComponent);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tip</strong>: Another React performance tool worth mentioning is <a href="https://github.com/garbles/why-did-you-update" target="_blank" rel="noopener">why-did-you-update</a>. This npm package patches React to emit console warnings whenever a component rerenders with identical props. Caveats: The output is verbose, and it doesn’t work on functional components.</p>
</blockquote>
<p>In the example, when the user clicks on a header column, the app emits an action, which changes the state: the list sort order (<code>currentSort</code>) is updated. This state change triggers the rerendering of the <code>&lt;List&gt;</code> page, which in turn rerenders the entire <code>&lt;Datagrid&gt;</code> component. We want the datagrid header to be immediately rendered to show the sort icon change as a feedback to user action.</p>
<p>What makes a React app slow is usually not a single slow component (that would translate in the flamegraph as one large pit). <strong>What makes a React app slow is, most of the time, useless rerenders of many components.</strong></p>
<p>You may have read that the React VirtualDom is super fast. That’s true, but in a medium size app, a full redraw can easily render hundreds of components. Even the fastest VirtualDom templating engine can’t make that in less than 16ms.</p>
<h3 id="Cutting-Components-To-Optimize-Them"><a href="#Cutting-Components-To-Optimize-Them" class="headerlink" title="Cutting Components To Optimize Them"></a>Cutting Components To Optimize Them</h3><p>Here is the <code>&lt;Datagrid&gt;</code> component <code>render()</code> method:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in Datagrid.js</span></span><br><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; </span><br><span class="line">        resource,</span><br><span class="line">        children,</span><br><span class="line">        ids,</span><br><span class="line">        data,</span><br><span class="line">        currentSort</span><br><span class="line">    &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;thead&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &#123;Children.map(children, (field, index) =&gt;</span><br><span class="line">                        &lt;DatagridHeaderCell</span><br><span class="line">                            key=&#123;index&#125;</span><br><span class="line">                            field=&#123;field&#125;</span><br><span class="line">                            currentSort=&#123;currentSort&#125;</span><br><span class="line">                            updateSort=&#123;<span class="keyword">this</span>.updateSort&#125;</span><br><span class="line">                        /&gt;</span><br><span class="line">                    )&#125;</span><br><span class="line">                &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>thead&gt;</span><br><span class="line">            &lt;tbody&gt;</span><br><span class="line">                &#123;ids.map(<span class="function"><span class="params">id</span> =&gt;</span> (</span><br><span class="line">                    &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                        &#123;Children.map(children, (field, index) =&gt;</span><br><span class="line">                            &lt;DatagridCell</span><br><span class="line">                                record=&#123;data[id]&#125;</span><br><span class="line">                                key=&#123;<span class="string">`<span class="subst">$&#123;id&#125;</span>-<span class="subst">$&#123;index&#125;</span>`</span>&#125;</span><br><span class="line">                                field=&#123;field&#125;</span><br><span class="line">                                resource=&#123;resource&#125;</span><br><span class="line">                            /&gt;</span><br><span class="line">                        )&#125;</span><br><span class="line">                    &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">                ))&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>tbody&gt;</span><br><span class="line">        &lt;<span class="regexp">/table&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>This seems like a very simple implementation of a datagrid, yet it is <em>very inefficient</em>. Each <code>&lt;DatagridCell&gt;</code> call renders at least two or three components. As you can see in the initial interface screencast, the list has 7 columns, 11 rows, that means 7<em>11</em>3 = 231 components rerended. When only the <code>currentSort</code> changes, it’s a waste of time. Even though React doesn’t update the real DOM if the rerendered VirtualDom is unchanged, it takes about 500ms to process all the components.</p>
<p>In order to avoid a useless rendering of the table body, I must first <em><em>extract</em></em> it:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in Datagrid.js</span></span><br><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; </span><br><span class="line">        resource,</span><br><span class="line">        children,</span><br><span class="line">        ids,</span><br><span class="line">        data,</span><br><span class="line">        currentSort</span><br><span class="line">    &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;thead&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &#123;React.Children.map(children, (field, index) =&gt;</span><br><span class="line">                        &lt;DatagridHeaderCell</span><br><span class="line">                            key=&#123;index&#125;</span><br><span class="line">                            field=&#123;field&#125;</span><br><span class="line">                            currentSort=&#123;currentSort&#125;</span><br><span class="line">                            updateSort=&#123;<span class="keyword">this</span>.updateSort&#125;</span><br><span class="line">                        /&gt;</span><br><span class="line">                    )&#125;</span><br><span class="line">                &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>thead&gt;</span><br><span class="line">            &lt;DatagridBody resource=&#123;resource&#125; ids=&#123;ids&#125; data=&#123;data&#125;&gt;</span><br><span class="line">                &#123;children&#125;</span><br><span class="line">            &lt;<span class="regexp">/DatagridBody&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>table&gt;</span><br><span class="line">        );</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I created a new <code>&lt;DatagridBody&gt;</code> component by extracting the table body logic:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in DatagridBody.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Children &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> DatagridBody = <span class="function">(<span class="params">&#123; resource, ids, data, children &#125;</span>) =&gt;</span> (</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">        &#123;ids.map(<span class="function"><span class="params">id</span> =&gt;</span> (</span><br><span class="line">            &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                &#123;Children.map(children, (field, index) =&gt;</span><br><span class="line">                    &lt;DatagridCell</span><br><span class="line">                        record=&#123;data[id]&#125;</span><br><span class="line">                        key=&#123;<span class="string">`<span class="subst">$&#123;id&#125;</span>-<span class="subst">$&#123;index&#125;</span>`</span>&#125;</span><br><span class="line">                        field=&#123;field&#125;</span><br><span class="line">                        resource=&#123;resource&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">            &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>tbody&gt;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> DatagridBody;</span><br></pre></td></tr></table></figure>
<p>Extracting the table body has no effect on performance, but it reveals the path to optimization. Large, general purpose components are hard to optimize. Small, single-responsibility components are much easier to deal with.</p>
<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a><code>shouldComponentUpdate</code></h3><p>The <a href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="noopener">React documentation</a> is very clear about the way to avoid useless rerenders: <code>shouldComponentUpdate()</code>. By default, React <em>always renders</em> a component to the virtual DOM. In other terms, it’s your job as a developer to check that the props of a component didn’t change and skip rendering altogether in that case.</p>
<p>In the case of the <code>&lt;DatagridBody&gt;</code> component above, there should be no rerender of the body unless the props have changed.</p>
<p>So the component should be completed as follows:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Children, Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatagridBody</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">        <span class="keyword">return</span> (nextProps.ids !== <span class="keyword">this</span>.props.ids</span><br><span class="line">             || nextProps.data !== <span class="keyword">this</span>.props.data);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; resource, ids, data, children &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;tbody&gt;</span><br><span class="line">                &#123;ids.map(<span class="function"><span class="params">id</span> =&gt;</span> (</span><br><span class="line">                    &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                        &#123;Children.map(children, (field, index) =&gt;</span><br><span class="line">                            &lt;DatagridCell</span><br><span class="line">                                record=&#123;data[id]&#125;</span><br><span class="line">                                key=&#123;<span class="string">`<span class="subst">$&#123;id&#125;</span>-<span class="subst">$&#123;index&#125;</span>`</span>&#125;</span><br><span class="line">                                field=&#123;field&#125;</span><br><span class="line">                                resource=&#123;resource&#125;</span><br><span class="line">                             /&gt;</span><br><span class="line">                        )&#125;</span><br><span class="line">                    &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">                ))&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>tbody&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> DatagridBody;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tip</strong>: As an alternative to implementing <code>shouldComponentUpdate()</code> manually, I could inherit from React’s <code>PureComponent</code> instead of <code>Component</code>. This would compare all props using strict equality (<code>===</code>) and rerender only if <em>any</em> of the props change. But I know that <code>resource</code> and <code>children</code> cannot change in that context, so I don’t need to check for their equality.</p>
</blockquote>
<p>With this optimization, the rerendering of the <code>&lt;Datagrid&gt;</code> component after clicking on a table header skips the table body and its 231 components entirely. This reduces the update time from 500ms to 60ms. That’s a net performance improvement of more than 400ms!</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*RN8utWqsOiVZlZeMK09-5Q.png" alt=""></p>
<blockquote>
<p><strong>Tip</strong>: Don’t get fooled by the flamegraph width, it’s zoomed even more than the previous flamegraph. This one is definitely better!</p>
</blockquote>
<p>The <code>shouldComponentUpdate</code> optimization has removed a lot of pits in the graph, and reduced the overall rendering time. I can use the same trick to avoid even more rerenders (e.g. to avoid rendering the sidebar, the action buttons, the table headers that didn’t change, the pagination). After about an hour of work, the entire page renders just 100ms after clicking on a header column. That’s fast enough — even if there is still room for optimization.</p>
<p>Adding a <code>shouldComponentUpdate</code> method may seem cumbersome, but if you care about performance, most of the components you write should end up with one.</p>
<p>Don’t do it everywhere — executing <code>shouldComponentUpdate</code> on simple components is sometimes slower than just rendering the component. Don’t do that too early in the life of an application either — this would be premature optimization. But as your apps grow, and you can detect performance bottlenecks in your components, add <code>shouldComponentUpdate</code> logic to remain fast.</p>
<h3 id="Recompose"><a href="#Recompose" class="headerlink" title="Recompose"></a>Recompose</h3><p>I’m not very happy with the previous change on <code>&lt;DatagridBody&gt;</code>: because of <code>shouldComponentUpdate</code>, I had to transform a simple, functional component to a class-based component. This adds more lines of code, and every line of code has a cost — to write, to debug, and to maintain.</p>
<p>Fortunately, you can implement the <code>shouldComponentUpdate</code> logic in a higher-order component (HOC) thanks to <a href="https://github.com/acdlite/recompose" target="_blank" rel="noopener">recompose</a>. It’s a functional utility belt for React, providing for instance the <code>pure()</code> HOC:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in DatagridBody.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Children &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> pure <span class="keyword">from</span> <span class="string">'recompose/pure'</span>;</span><br><span class="line"><span class="keyword">const</span> DatagridBody = <span class="function">(<span class="params">&#123; resource, ids, data, children &#125;</span>) =&gt;</span> (</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">        &#123;ids.map(<span class="function"><span class="params">id</span> =&gt;</span> (</span><br><span class="line">            &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                &#123;Children.map(children, (field, index) =&gt;</span><br><span class="line">                    &lt;DatagridCell</span><br><span class="line">                        record=&#123;data[id]&#125;</span><br><span class="line">                        key=&#123;<span class="string">`<span class="subst">$&#123;id&#125;</span>-<span class="subst">$&#123;index&#125;</span>`</span>&#125;</span><br><span class="line">                        field=&#123;field&#125;</span><br><span class="line">                        resource=&#123;resource&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">            &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>tbody&gt;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> pure(DatagridBody);</span><br></pre></td></tr></table></figure>
<p>The only difference between this code and the initial implementation is the last line: I export <code>pure(DatagridBody)</code> instead of <code>DatagridBody</code>. <code>pure</code> is like <code>PureComponent</code>, but without the extra class boilerplate.</p>
<p>I can even be more specific and target only the props that I know may change, using recompose’s <code>shouldUpdate()</code> instead of <code>pure()</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in DatagridBody.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Children &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> shouldUpdate <span class="keyword">from</span> ‘recompose/shouldUpdate’;</span><br><span class="line"><span class="keyword">const</span> DatagridBody = <span class="function">(<span class="params">&#123; resource, ids, data, children &#125;</span>) =&gt;</span> (</span><br><span class="line">    ...</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> checkPropsChange = <span class="function">(<span class="params">props, nextProps</span>) =&gt;</span></span><br><span class="line"> (nextProps.ids !== props.ids ||</span><br><span class="line">  nextProps.data !== props.data);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> shouldUpdate(checkPropsChange)(DatagridBody);</span><br></pre></td></tr></table></figure>
<p>The <code>checkPropsChange</code> function is pure, and I can even export it for unit tests.</p>
<p>The recompose library offers more performance HOCs, like <code>onlyUpdateForKeys()</code>, which does exactly the type of check I did in my own <code>checkPropsChange</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in DatagridBody.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Children &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> onlyUpdateForKeys <span class="keyword">from</span> ‘recompose/onlyUpdateForKeys’;</span><br><span class="line"><span class="keyword">const</span> DatagridBody = <span class="function">(<span class="params">&#123; resource, ids, data, children &#125;</span>) =&gt;</span> (</span><br><span class="line">    ...</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> onlyUpdateForKeys([‘ids’, ‘data’])(DatagridBody);</span><br></pre></td></tr></table></figure>
<p>I warmly recommend recompose. Beyond performance optimization, it helps you extract data fetching logic, HOC composition, and props manipulation in a functional and testable way.</p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>If you’re using <a href="http://redux.js.org/" target="_blank" rel="noopener">Redux</a> to manage application state <em>(which I also recommend)</em>, then connected components are already pure. No need to add another HOC.</p>
<p>Just remember that if only one of the props change, then the connected component rerenders — this includes all its children, too. So even if you use Redux for page components, you should use <code>pure()</code> or <code>shouldUpdate()</code> for components further down in the render tree.</p>
<p>Also, beware that Redux does the props comparison using strict equality. Since Redux connects the state to a component’s props, if you mutate an object in the state, Redux props comparison will miss it. That’s why you must use <strong>immutability</strong> in your reducers.</p>
<p>For instance, in admin-on-rest, clicking on a table header dispatches a <code>SET_SORT</code> action. The reducer listening to that action must pay attention to <em>replace</em> objects in the state, not <em>update</em> them:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in listReducer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SORT_ASC = <span class="string">'ASC'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SORT_DESC = <span class="string">'DESC'</span>;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">    sort: <span class="string">'id'</span>,</span><br><span class="line">    order: SORT_DESC,</span><br><span class="line">    page: <span class="number">1</span>,</span><br><span class="line">    perPage: <span class="number">25</span>,</span><br><span class="line">    filter: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (previousState = initialState, &#123; type, payload &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_SORT:</span><br><span class="line">        <span class="keyword">if</span> (payload === previousState.sort) &#123;</span><br><span class="line">            <span class="comment">// inverse sort order</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...previousState,</span><br><span class="line">                order: oppositeOrder(previousState.order),</span><br><span class="line">                page: <span class="number">1</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// replace sort field_</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...previousState,</span><br><span class="line">            sort: payload,</span><br><span class="line">            order: SORT_ASC,</span><br><span class="line">            page: <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> previousState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>With this reducer, when Redux checks for changes using triple equal, it finds that the state object is different, and rerenders the datagrid. But had we mutated the state, Redux would have missed the state change, and skipped rerendering by mistake:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// don't do this at home</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (previousState = initialState, &#123; type, payload &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_SORT:</span><br><span class="line">        <span class="keyword">if</span> (payload === previousState.sort) &#123;</span><br><span class="line">            <span class="comment">// never do this</span></span><br><span class="line">            previousState.order = oppositeOrder(previousState.order);</span><br><span class="line">            <span class="keyword">return</span> previousState;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// never do that either</span></span><br><span class="line">        previousState.sort = payload;</span><br><span class="line">        previousState.order = SORT_ASC;</span><br><span class="line">        previousState.page = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> previousState;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> previousState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>To write immutable reducers, other developers like to use <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">immutable.js</a>, also from Facebook. I find it unnecessary, since ES6 destructuring makes it easy to selectively replace a component properties. Besides, Immutable is heavy (60kB), so think twice before you add it to your project dependencies.</p>
<h3 id="Reselect"><a href="#Reselect" class="headerlink" title="Reselect"></a>Reselect</h3><p>To prevent useless renders in (Redux) connected components, you must also make sure that the <code>mapStateToProps</code> function doesn’t return new objects each time it is called.</p>
<p>Take for instance the <code>&lt;List&gt;</code> component in admin-on-rest. It grabs the list of records for the current resource (e.g. posts, comments, etc) from the state using the following code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in List.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">const</span> List = <span class="function">(<span class="params">props</span>) =&gt;</span> ...</span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> resourceState = state.admin[props.resource];</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ids: resourceState.list.ids,</span><br><span class="line">        data: <span class="built_in">Object</span>.keys(resourceState.data)</span><br><span class="line">            .filter(<span class="function"><span class="params">id</span> =&gt;</span> resourceState.list.ids.includes(id))</span><br><span class="line">            .map(<span class="function"><span class="params">id</span> =&gt;</span> resourceState.data[id])</span><br><span class="line">            .reduce(<span class="function">(<span class="params">data, record</span>) =&gt;</span> &#123;</span><br><span class="line">                data[record.id] = record;</span><br><span class="line">                <span class="keyword">return</span> data;</span><br><span class="line">            &#125;, &#123;&#125;),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(List);</span><br></pre></td></tr></table></figure>
<p>The state contains an array of all the previously fetched records, indexed by resource. For instance, <code>state.admin.posts.data</code> contains the list of posts:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="number">23</span>: &#123; <span class="attr">id</span>: <span class="number">23</span>, <span class="attr">title</span>: “Hello, World”, <span class="comment">/* … */</span> &#125;,</span><br><span class="line">   <span class="number">45</span>: &#123; <span class="attr">id</span>: <span class="number">45</span>, <span class="attr">title</span>: “Lorem Ipsum”, <span class="comment">/* … */</span> &#125;,</span><br><span class="line">   <span class="number">67</span>: &#123; <span class="attr">id</span>: <span class="number">67</span>, <span class="attr">title</span>: “Sic dolor amet”, <span class="comment">/* … */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>mapStateToProps</code> function filters this state object to return only the records actually displayed in the list. Something like:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">23</span>: &#123; <span class="attr">id</span>: <span class="number">23</span>, <span class="attr">title</span>: “Hello, World”, <span class="comment">/* … */</span> &#125;,</span><br><span class="line">    <span class="number">67</span>: &#123; <span class="attr">id</span>: <span class="number">67</span>, <span class="attr">title</span>: “Sic dolor amet”, <span class="comment">/* … */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The problem is that each time <code>mapStateToProps</code> runs, it returns a new object, even if the underlying objects didn’t change. As a consequence, the <code>&lt;List&gt;</code> component rerenders every time something in the state changes — while id should only change if the date or ids change.</p>
<p><a href="https://github.com/reactjs/reselect" target="_blank" rel="noopener">Reselect</a> solves this problem by using memoization. Instead of computing the props directly in <code>mapStateToProps</code>, you use a <em>selector</em> from reselect, which returns the same output if the input didn’t change.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></span><br><span class="line"><span class="keyword">const</span> List = <span class="function">(<span class="params">props</span>) =&gt;</span> ...</span><br><span class="line"><span class="keyword">const</span> idsSelector = <span class="function">(<span class="params">state, props</span>) =&gt;</span></span><br><span class="line">    state.admin[props.resource].ids</span><br><span class="line"><span class="keyword">const</span> dataSelector = <span class="function">(<span class="params">state, props</span>) =&gt;</span></span><br><span class="line">    state.admin[props.resource].data</span><br><span class="line"><span class="keyword">const</span> filteredDataSelector = createSelector(</span><br><span class="line">  idsSelector,</span><br><span class="line">  dataSelector</span><br><span class="line">  (ids, data) =&gt; <span class="built_in">Object</span>.keys(data)</span><br><span class="line">      .filter(<span class="function"><span class="params">id</span> =&gt;</span> ids.includes(id))</span><br><span class="line">      .map(<span class="function"><span class="params">id</span> =&gt;</span> data[id])</span><br><span class="line">      .reduce(<span class="function">(<span class="params">data, record</span>) =&gt;</span> &#123;</span><br><span class="line">          data[record.id] = record;</span><br><span class="line">          <span class="keyword">return</span> data;</span><br><span class="line">      &#125;, &#123;&#125;)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> resourceState = state.admin[props.resource];</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ids: idsSelector(state, props),</span><br><span class="line">        data: filteredDataSelector(state, props),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(List);</span><br></pre></td></tr></table></figure>
<p>Now the <code>&lt;List&gt;</code> component will only rerender if a subset of the state changes.</p>
<p>As for recompose, reselect selectors are pure functions, easy to test and compose. It’s a great way to code your selectors for Redux connected components.</p>
<h3 id="Beware-of-Object-Literals-in-JSX"><a href="#Beware-of-Object-Literals-in-JSX" class="headerlink" title="Beware of Object Literals in JSX"></a>Beware of Object Literals in JSX</h3><p>Once your components become more “pure”, you start detecting bad patterns that lead to useless rerenders. The most common is the usage of object literals in JSX, which I like to call “<strong>The infamous</strong> <code>\{\{</code>”. Let me give you an example:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> MyTableComponent <span class="keyword">from</span> <span class="string">'./MyTableComponent'</span>;</span><br><span class="line"><span class="keyword">const</span> Datagrid = <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">    &lt;MyTableComponent style=&#123;&#123; <span class="attr">marginTop</span>: <span class="number">10</span> &#125;&#125;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;<span class="regexp">/MyTableComponent&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
<p>The <code>style</code> prop of the <code>&lt;MyTableComponent&gt;</code> component gets a new value every time the <code>&lt;Datagrid&gt;</code> component is rendered. So even if <code>&lt;MyTableComponent&gt;</code> is pure, it will be rendered every time <code>&lt;Datagrid&gt;</code> is rendered. In fact, each time you pass an object literal as prop to a child component, you break purity. The solution is simple:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> MyTableComponent <span class="keyword">from</span> <span class="string">'./MyTableComponent'</span>;</span><br><span class="line"><span class="keyword">const</span> tableStyle = &#123; <span class="attr">marginTop</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> Datagrid = <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">    &lt;MyTableComponent style=&#123;tableStyle&#125;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;<span class="regexp">/MyTableComponent&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
<p>This looks very basic, but I’ve seen this mistake so many times that I’ve developed a sense for detecting the infamous <code>\{\{</code> in JSX. I routinely replace it with constants.</p>
<p>Another usual suspect for hijacking pure components is <code>React.cloneElement()</code>. If you pass a prop by value as second parameter, the cloned element will receive new props at every render.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">props</span>) =&gt;</span></span><br><span class="line">    &lt;div&gt;&#123;React.cloneElement(Foo, &#123; <span class="attr">bar</span>: <span class="number">1</span> &#125;)&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ good</span></span><br><span class="line"><span class="regexp">const additionalProps = &#123; bar: 1 &#125;;</span></span><br><span class="line"><span class="regexp">const MyComponent = (props) =&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;&#123;React.cloneElement(Foo, additionalProps)&#125;&lt;/</span>div&gt;;</span><br></pre></td></tr></table></figure>
<p>This has bitten me a couple times with <a href="http://www.material-ui.com/#/" target="_blank" rel="noopener">material-ui</a>, for instance with the following code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CardActions &#125; <span class="keyword">from</span> <span class="string">'material-ui/Card'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateButton, RefreshButton &#125; <span class="keyword">from</span> <span class="string">'admin-on-rest'</span>;</span><br><span class="line"><span class="keyword">const</span> Toolbar = <span class="function">(<span class="params">&#123; basePath, refresh &#125;</span>) =&gt;</span> (</span><br><span class="line">    &lt;CardActions&gt;</span><br><span class="line">        &lt;CreateButton basePath=&#123;basePath&#125; /&gt;</span><br><span class="line">        &lt;RefreshButton refresh=&#123;refresh&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/CardActions&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">export default Toolbar;</span></span><br></pre></td></tr></table></figure>
<p>Although <code>&lt;CreateButton&gt;</code> is pure, it was rendered every time <code>&lt;Toolbar&gt;</code> was rendered. That’s because material-ui’s <code>&lt;CardActions&gt;</code> adds a special style to its first child to accommodate for margins — and it does so with an object literal. So <code>&lt;CreateButton&gt;</code> received a different <code>style</code> prop every time. I solved it using recompose’s <code>onlyUpdateForKeys()</code> HOC.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in Toolbar.js</span></span><br><span class="line"><span class="keyword">import</span> onlyUpdateForKeys <span class="keyword">from</span> <span class="string">'recompose/onlyUpdateForKeys'</span>;</span><br><span class="line"><span class="keyword">const</span> Toolbar = <span class="function">(<span class="params">&#123; basePath, refresh &#125;</span>) =&gt;</span> (</span><br><span class="line">    ...</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> onlyUpdateForKeys([<span class="string">'basePath'</span>, <span class="string">'refresh'</span>])(Toolbar);</span><br></pre></td></tr></table></figure>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>There are many other things you should do to keep your React app fast (using keys, lazy loading heavy routes, the <code>react-addons-perf</code> package, using ServiceWorkers to cache app state, going isomorphic, etc), but implementing <code>shouldComponentUpdate</code> correctly is the first step — and the most rewarding.</p>
<p>React isn’t fast by default, but it offers all the tools to be fast whatever the size of the application.</p>
<p>This may seem counterintuitive, especially since many frameworks offering an alternative to React claim themselves as n times faster. But React puts developer experience before performance. That’s the reason why developing large apps with React is such a pleasant experience, without bad surprises, and a constant implementation rate.</p>
<p>Just remember to profile your app every once in a while, and dedicate some time to add a few <code>pure()</code> calls where it’s needed. Don’t do it first, or spend too much time to over optimize each and every component — except if you’re on mobile. And remember to test on various devices to get a good impression of your app’s responsiveness from a user’s point of view.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*WK96fqAKMrDMBjXB9yNAhg.jpeg" alt=""></p>
<p><strong>If you want to read more about React performance optimization, here is a list of great articles on the subject:</strong></p>
<ul>
<li><a href="https://speakerdeck.com/vjeux/react-rally-animated-react-performance-toolbox" target="_blank" rel="noopener">React Rally: Animated — React Performance Toolbox</a>: A fabulous slide deck by Christopher Chedeau (Vjeux), one of the React Native developers. He’s French, by the way.</li>
<li><a href="https://medium.com/@addyosmani/progressive-web-apps-with-react-js-part-2-page-load-performance-33b932d97cf2#.zhzfe1iuc" target="_blank" rel="noopener">Progressive Web Apps with React.js: Part 2 — Page Load Performance</a> by Addy Osmany, who works at Google and writes a lot of blog posts about web performance</li>
<li><a href="https://auth0.com/blog/optimizing-react/" target="_blank" rel="noopener">Optimizing the Performance of Your React Application</a> focuses on the <code>react-addons-perf</code> package to profile React apps precisely</li>
<li><a href="https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e#.km5882wi8" target="_blank" rel="noopener">React Higher Order Components in depth</a>, interesting for the introduction of Render Hijacking</li>
<li><a href="http://benchling.engineering/deep-dive-react-perf-debugging/" target="_blank" rel="noopener">A Deep Dive into React Perf Debugging</a> describes a step-by-step debugging session with Chrome dev Tools</li>
<li><a href="https://www.mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/" target="_blank" rel="noopener">Making React reactive: the pursuit of high performing, easily maintainable React apps</a> on using Observables to avoid rerenders</li>
</ul>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*WK96fqAKMrDMBjXB9yNAhg.jpeg" alt=""></p>
<span>Source: </span><a href="http://marmelab.com/blog/2017/02/06/react-is-slow-react-is-fast.html" target="_blank" title="http://marmelab.com/blog/2017/02/06/react-is-slow-react-is-fast.html" class="post-from">http://marmelab.com/blog/2017/02/06/react-is-slow-react-is-fast.html</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2017/08/Explaining-Value-vs-Reference-in-Javascript.html" class="prev">NEXT</a><a href="/2017/08/Use-const-Until-You-Have-to-Use-let.html" class="next">PREV</a></div><div class="copyright"><p>© 2017 - 2019 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>