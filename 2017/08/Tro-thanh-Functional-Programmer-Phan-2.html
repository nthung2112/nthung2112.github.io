<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Trở thành Functional Programmer - Phần 2 · Learn and Share</title><meta name="description" content="Trở thành Functional Programmer - Phần 2 - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Trở thành Functional Programmer - Phần 2"><meta property="og:image" content="https://viblo.asia/uploads/e85b8079-5076-40ca-af63-f1a136d06516.png"><meta property="og:description" content="Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP."></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Trở thành Functional Programmer - Phần 2</h1><h2 class="post-subtitle"></h2><header class="post-info">Aug 23, 2017<div class="tags"></div><div class="fb-ir-time"><time datetime="2017-08-23T16:22:32.000Z" class="op-modified"></time><time datetime="2017-08-23T16:22:32.000Z" class="op-published"></time></div></header></div><div class="post-banner"><img src="https://viblo.asia/uploads/e85b8079-5076-40ca-af63-f1a136d06516.png"></div><div class="wrap"><div class="post-content"><p>Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP.</p>
<a id="more"></a>
<h2 id="Mot-chut-luu-y"><a href="#Mot-chut-luu-y" class="headerlink" title="Một chút lưu ý"></a>Một chút lưu ý</h2><p><img src="https://viblo.asia/uploads/a0316185-f724-4980-b7d9-3bbb1fc98a0b.png" alt=""></p>
<p>Tôi mong các bạn sẽ đọc các dòng code một cách từ tốn. Và hãy đảm bảo rằng bạn đã hoàn toàn hiểu rõ, nắm vững các nội dung vừa đọc được trước khi tiếp tục. Các phần tiếp theo được phát triển từ các phần trước đó, nên nếu bạn vội vã, bạn có thể bỏ qua một vài kiến thức quan trọng, cần thiết cho các phần sau này.</p>
<h2 id="Tai-cau-truc-Refactoring"><a href="#Tai-cau-truc-Refactoring" class="headerlink" title="Tái cấu trúc - Refactoring"></a>Tái cấu trúc - Refactoring</h2><p><img src="https://viblo.asia/uploads/4e819b21-0572-4135-a423-456f9469a1bc.png" alt=""></p>
<p>Phần này sẽ nói về Tái cấu trúc - một kỹ thuật khá quen thuộc đối với các lập trình viên. Sau đây mời các bạn xem một đoạn code Javascript:</p>
<blockquote>
<p>function validateSsn(<strong>ssn</strong>) {<br>if (<strong>/^\d{3}-\d{2}-\d{4}</strong>/.exec(<strong>ssn</strong>))         console.log(‘Valid <strong>SSN</strong>‘);     else         console.log(‘Invalid <strong>SSN</strong>‘); } function validatePhone(<strong>phone</strong>) {     if (/<strong>^(\d{3})\d{3}-\d{4}</strong>/.exec(<strong>phone</strong>))<br>        console.log(‘Valid <strong>Phone Number</strong>‘);<br>    else<br>        console.log(‘Invalid <strong>Phone Number</strong>‘);<br>}</p>
</blockquote>
<p>Hẳn là bạn đã từng viết những dòng code kiểu như thế này, và theo thời gian, bạn sẽ dần nhận ra rằng 2 hàm phía trên khá là giống nhau, chỉ có đôi chút khác biệt (phần được bôi đậm).</p>
<p>Vì thế, thay vì copy lại hàm <code>validateSSn</code> và thay đổi để tạo ra hàm <code>validatePhone</code> mới, chúng ta có thể chỉ tạo một hàm và biến các phần khác nhau thành tham số.</p>
<p>Trong ví dụ này, chúng ta nên tham số hóa phần <code>value</code>, phần <code>regulare expression</code> và phần <code>message</code> được in ra (là những phần bôi đậm ở trên).</p>
<p>Đây là code sau khi refactor:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function validateValue(value, regex, type) &#123;</span><br><span class="line">    if (regex.exec(value))</span><br><span class="line">        console.log(&apos;Invalid &apos; + type);</span><br><span class="line">    else</span><br><span class="line">        console.log(&apos;Valid &apos; + type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Các tham số <code>ssn</code> và <code>phone</code> ở trong phần code cũ đã được thay thế bằng biến <code>value</code>.</p>
<p>2 biểu thức chính quy (regulare expression) <code>/^\d{3}-\d{2}-\d{4}$/</code> và <code>/^\(\d{3}\)\d{3}-\d{4}$/</code> được thay thế bằng biến <code>regex</code>.</p>
<p>Và phần sau của message gồm <code>SNS</code> và <code>Phone Number</code> sẽ được thay thế bằng biến <code>type</code>.</p>
<p>Việc chỉ có một hàm như thế này sẽ tốt hơn rất nhiều so với việc có 2, hoặc xấu hơn là 3, 4 hay 10 hàm. Việc này sẽ giúp code của bạn sạch sẽ và dễ bảo trì hơn.</p>
<p>Ví dụ, nếu có lỗi xảy ra, bạn sẽ chỉ phải fix ở một chỗ thay vì tìm kiếm trong tất cả source code để tìm các chỗ mà hàm này <em>CÓ THỂ</em> đã được copy/paste và thay đổi.</p>
<p>Tiếp theo chúng ta cùng xem xét trường hợp phức tạp hơn một chút :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function validateAddress(address) &#123;</span><br><span class="line">    if (parseAddress(address))</span><br><span class="line">        console.log(&apos;Valid Address&apos;);</span><br><span class="line">    else</span><br><span class="line">        console.log(&apos;Invalid Address&apos;);</span><br><span class="line">&#125;</span><br><span class="line">function validateName(name) &#123;</span><br><span class="line">    if (parseFullName(name))</span><br><span class="line">        console.log(&apos;Valid Name&apos;);</span><br><span class="line">    else</span><br><span class="line">        console.log(&apos;Invalid Name&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ở đây <code>parseAddress</code> và <code>parseFullName</code> là 2 hàm đều nhận vào một chuỗi và trả về <code>true</code> nếu parse thành công.</p>
<p>Bạn sẽ refactor code trong trường hợp này như thế nào đây?</p>
<p>Giống như trường hợp trước đó, ta có thể sử dụng biến <code>value</code> cho <code>address</code> và <code>name</code>, <code>type</code> cho <code>Address</code> và <code>Name</code> giống như đã làm trước đó, nhưng ở vị trí của biểu thức chính quy lúc trước giờ lại là 2 hàm khác nhau.</p>
<p>Nếu như chúng ta có thể đưa hàm vào tham số thì …</p>
<h2 id="Concept-3-Higher-Order-Functions"><a href="#Concept-3-Higher-Order-Functions" class="headerlink" title="Concept 3: Higher-Order Functions"></a>Concept 3: Higher-Order Functions</h2><p>(Chú thích của người dịch: High-order Function mình đã tìm hiểu nhưng khó có từ tiếng Việt tương đương, bạn có thể hiểu Higher-Order Functions có nghĩa là Hàm có cấp bậc cao hơn - với ý nghĩa là hàm có nhiều khả năng và linh hoạt hơn so với các ngôn ngữ Imperative Programming thông thường như Java, C, C++)</p>
<p><img src="https://viblo.asia/uploads/1bdda083-b23c-40c8-844c-f26d1a080b56.png" alt=""></p>
<p>Rất nhiều ngôn ngữ lập trình không hỗ trợ việc đưa hàm vào thành tham số. Một số ngôn ngữ thì có thể nhưng cách thực hiện thì không hề dễ dàng chút nào.</p>
<blockquote>
<p>Trong Functional Programming, một hàm sẽ được coi như là một công dân hạng nhất trong ngôn ngữ đó. Hay nói cách khác, hàm sẽ giống như các loại giá trị (số, text, object,…) khác.</p>
</blockquote>
<p>Bởi vì hàm sẽ được coi như các loại giá trị khác, nên <strong>hàm có thể được truyền dưới dạng tham số</strong>.</p>
<p>Mặc dù không phải là ngôn ngữ hỗ trợ FP chính thống, nhưng một vài concept trong FP có thể được thực hiện bởi Javascript. Và đây là cách thu gọn hai hàm ở trên thành một bằng việc đưa hàm thực hiện việc parse dữ liệu thành tham số của hàm mới có tên là <code>parseFunc</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function validateValueWithFunc(value, parseFunc, type) &#123;</span><br><span class="line">    if (parseFunc(value))</span><br><span class="line">        console.log(&apos;Invalid &apos; + type);</span><br><span class="line">    else</span><br><span class="line">        console.log(&apos;Valid &apos; + type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Và hàm mới của chúng ta được gọi là <code>Higher-order Function</code>.</p>
<blockquote>
<p>Higher-order Functions là các hàm hoặc nhận hàm làm tham số, hoặc trả về hàm, hoặc vừa nhận hàm làm tham số vừa trả về hàm.</p>
</blockquote>
<p>Và giờ chúng ta có thể viết lại cả 4 hàm trên bằng cách sử dụng hàm <code>validateValueWithFunc</code> như sau ( lưu ý rằng hàm <code>Regex.exec</code> sẽ trả về <code>true</code> nếu chuỗi ký tự match với biểu thức chính quy ):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">validateValueWithFunc(&apos;123-45-6789&apos;, /^\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;$/.exec, &apos;SSN&apos;);</span><br><span class="line">validateValueWithFunc(&apos;(123)456-7890&apos;, /^\(\d&#123;3&#125;\)\d&#123;3&#125;-\d&#123;4&#125;$/.exec, &apos;Phone&apos;);</span><br><span class="line">validateValueWithFunc(&apos;123 Main St.&apos;, parseAddress, &apos;Address&apos;);</span><br><span class="line">validateValueWithFunc(&apos;Joe Mama&apos;, parseName, &apos;Name&apos;);</span><br></pre></td></tr></table></figure>
<p>Code được viết lại như trên nhìn ngon hơn hẳn so với việc có 4 hàm từa tựa nhau nhỉ? :D</p>
<p>Để ý kĩ hơn một chút, 2 hàm sử dụng biểu thức chính quy nhìn có vẻ khá là rườm rà, nhất là khi sau này biểu thức chính quy có thể trở nên dài và phức tạp hơn. Chúng ta có thể làm cho nó gọn hơn bằng cách đưa phần gọi biểu thức chính quy ra ngoài như sau :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var parseSsn = /^\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;$/.exec;</span><br><span class="line">var parsePhone = /^\(\d&#123;3&#125;\)\d&#123;3&#125;-\d&#123;4&#125;$/.exec;</span><br><span class="line"></span><br><span class="line">validateValueWithFunc(&apos;123-45-6789&apos;, parseSsn, &apos;SSN&apos;);</span><br><span class="line">validateValueWithFunc(&apos;(123)456-7890&apos;, parsePhone, &apos;Phone&apos;);</span><br><span class="line">validateValueWithFunc(&apos;123 Main St.&apos;, parseAddress, &apos;Address&apos;);</span><br><span class="line">validateValueWithFunc(&apos;Joe Mama&apos;, parseName, &apos;Name&apos;);</span><br></pre></td></tr></table></figure>
<p>Mọi thứ tốt hơn rồi nhỉ. Sau này nếu muốn kiểm tra một số điện thoại khác, thay vì phải copy lại biểu thức chính quy, ta có thể sử dụng hàm <code>parsePhone</code> và <code>validateValueWithFunc</code>.</p>
<p>Tuy nhiên, hãy thử tưởng tượng nếu chúng ta có nhiều biểu thức chính quy cần thực hiện, ngoài 2 hàm <code>parseSsn</code> và <code>parsePhone</code> thì sẽ ra sao nhỉ? Để ý rằng mỗi khi gọi hàm xử lý biểu thức chính quy, ta đều phải gọi thêm <code>.exec</code> vào cuối, và nếu số lượng biểu thức chính quy tăng lên thì sẽ khá là phiền phức, và tin tôi đi, sẽ có lúc bạn sẽ quên mất không thêm <code>.exec</code> vào đó.</p>
<p>Để tránh mắc phải lỗi này, chúng ta có thể tạo ra một hàm dạng <code>high-order function</code> được dùng để <strong>trả về hàm exec từ biểu thức chính quy truyền vào</strong> như sau :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function makeRegexParser(regex) &#123;</span><br><span class="line">    return regex.exec;</span><br><span class="line">&#125;</span><br><span class="line">var parseSsn = makeRegexParser(/^\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;$/);</span><br><span class="line">var parsePhone = makeRegexParser(/^\(\d&#123;3&#125;\)\d&#123;3&#125;-\d&#123;4&#125;$/);</span><br><span class="line">validateValueWithFunc(&apos;123-45-6789&apos;, parseSsn, &apos;SSN&apos;);</span><br><span class="line">validateValueWithFunc(&apos;(123)456-7890&apos;, parsePhone, &apos;Phone&apos;);</span><br><span class="line">validateValueWithFunc(&apos;123 Main St.&apos;, parseAddress, &apos;Address&apos;);</span><br><span class="line">validateValueWithFunc(&apos;Joe Mama&apos;, parseName, &apos;Name&apos;);</span><br></pre></td></tr></table></figure>
<p>Ở đây, hàm <code>makeRegexParser</code> nhận tham số là một biểu thức chính quy, và trả về <strong>hàm exec của biểu thức chính quy đó</strong>, với tham số là một chuỗi string. Lúc này, hàm <code>validateValueWithFunc</code> sẽ nhận chuỗi string từ biến <code>value</code>, sau đó truyền sang hàm <code>parseSsn</code> hoặc <code>parsePhone</code>, đối ví dụ trên thực chất sẽ là hàm <em>exec được trả về từ hàm parseSsn hoặc parsePhone</em>.</p>
<p>Như các bạn đã thấy, đây tuy chỉ là một quá trình tái cấu trúc code nho nhỏ, nhưng nó đã thể hiện khả năng và sự tiện lợi của <code>High-order function</code> khi hỗ trợ việc trả về <strong>hàm</strong>.</p>
<p>Lợi ích của việc thay đổi này sẽ thể hiện một cách rõ ràng hơn khi hàm <code>makeRegexParser</code> trở nên phức tạp hơn.</p>
<p>Dưới đây là một ví dụ khác về một <code>High-order function</code> có kết quả trả về là một hàm :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function makeAdder(constantValue) &#123;</span><br><span class="line">    return function adder(value) &#123;</span><br><span class="line">        return constantValue + value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Chúng ta có một hàm <code>makeAdder</code> nhận vào tham số là <code>constantValue</code> (giá trị cố định), và trả về một hàm tên là <code>adder</code>, với khả năng cộng thêm giá trị <code>constantValue</code> vào tham số truyền vào.</p>
<p>Đây là cách hàm <code>adder</code> có thể sử dụng :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var add10 = makeAdder(10);</span><br><span class="line">console.log(add10(20)); // prints 30</span><br><span class="line">console.log(add10(30)); // prints 40</span><br><span class="line">console.log(add10(40)); // prints 50</span><br></pre></td></tr></table></figure>
<p>Chúng ta đã tạo ra một hàm có tên là <code>add10</code> bằng việc truyền giá trị <code>10</code> vào hàm <code>makeAdder</code>, mà hàm <code>add10</code> sẽ hoạt động đúng như tên của nó, cộng thêm 10 vào bất kỳ biến nào truyueenf vào.</p>
<p>Để ý rằng hàm <code>adder</code> có thể truy cập đến biến <code>constantValue</code> ngay cả khi hàm <code>makeAddr</code> đã hoàn thành. Lý do là bởi vì biến <code>constantValue</code> đã ở trong cùng một <code>scope</code> (phạm vi) khi hàm <code>adder</code> được tạo.</p>
<p>Khả năng này rất quan trọng bởi vì nếu thiếu nó, việc hàm trả về hàm sẽ không còn nhiều lợi ích nữa. Vì thế việc hiểu cách hoạt động và tên gọi của khả năng này cũng là điều mà chúng ta cần tìm hiểu, và nó có tên là <strong>Closure</strong>.</p>
<h2 id="Concept-4-Closures-Bao-dong"><a href="#Concept-4-Closures-Bao-dong" class="headerlink" title="Concept 4: Closures - Bao đóng"></a>Concept 4: Closures - Bao đóng</h2><p><img src="https://viblo.asia/uploads/3a139baa-3e92-4adf-86cc-1d8e0a33db27.png" alt=""></p>
<p>Dưới đây là một ví dụ giả tưởng nhằm minh họa việc hàm sử dụng <strong>closures</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function grandParent(g1, g2) &#123;</span><br><span class="line">    var g3 = 3;</span><br><span class="line">    return function parent(p1, p2) &#123;</span><br><span class="line">        var p3 = 33;</span><br><span class="line">        return function child(c1, c2) &#123;</span><br><span class="line">            var c3 = 333;</span><br><span class="line">            return g1 + g2 + g3 + p1 + p2 + p3 + c1 + c2 + c3;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Trong ví dụ này, hàm <code>child</code> có thể truy cập các biến của chính nó, các biến của hàm <code>parent</code> và cả các biến của hàm <code>grandParent</code> nữa.<br>(đủ g1, g2, g3, p1, p2, p3, c1, c2, c3)</p>
<p>Hàm <code>parent</code> có thể truy cập các biến của chính nó và của hàm <code>grandParent</code>. (bao gồm g1, g2, g3, p1, p2, p3)</p>
<p>Hàm <code>grandParent</code> chỉ có thể truy cập các biến của chính nó. (bao gồm g1, g2, g3).</p>
<p>(Mọi người có thể tham khảo hình vẽ kim tự tháp phía bên trên để hiểu rõ hơn).</p>
<p>Sau đây là 1 ví dụ sử dụng hàm 3 đời ở trên :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var parentFunc = grandParent(1, 2); // returns parent() - trả về hàm parent() với g1 = 1, g2 = 2, g3 = 3</span><br><span class="line">var childFunc = parentFunc(11, 22); // returns child() - trả về hàm child() với g1 = 1, g2 = 2, g3 = 3, p1 = 11, p2 = 22, p3 = 33</span><br><span class="line">console.log(childFunc(111, 222)); // prints 738 - in ra 738 vì :</span><br><span class="line">// 1 + 2 + 3 + 11 + 22 + 33 + 111 + 222 + 333 == 738</span><br></pre></td></tr></table></figure>
<p>Ở đây, biến <code>parentFunc</code> sẽ giữ cho scope của hàm <code>parent</code> tồn tại sau khi thực hiện hàm <code>grandParent</code>, lúc này hàm <code>parent</code> sẽ trả về và tham chiếu thông qua biến <code>parentFunc</code> (scope của <code>parent</code> ở đây sẽ bao gồm các giá trị được hàm parent tham chiếu đến, tức là sẽ lưu giữ các giá trị g1, g2, g3, p1, p2, p3).</p>
<p>Tương tự như vậy, biến <code>childFunc</code> sẽ giữ scope của hàm <code>child</code> tồn tại sau khi thực hiện gọi hàm <code>parent</code> thông qua biến <code>parentFunc</code>, lúc này hàm <code>child</code> được trả về và tồn tại vì có biến <code>childFunc</code> tham chiếu đến.</p>
<p>Mỗi khi một hàm được tạo ra, tất cả các giá trị nằm trong scope của nó <em>ở thời điểm hàm được tạo</em> sẽ được lưu trữ và có thể truy cập trong suốt vòng đời của hàm đó. Và hàm sẽ còn tồn tại chừng nào còn có tham chiếu (reference) đến nó. Ví dụ, scope của hàm <code>child</code> sẽ còn tồn tại cho đến khi nào biến <code>childFunc</code> vẫn tham chiếu đến nó.</p>
<blockquote>
<p>Một closure (bao đóng) là một scope của một hàm mà sẽ tồn tại chừng nào còn có tham chiếu đến hàm đó.</p>
</blockquote>
<p>Lưu ý rằng, trong Javascript, closures sẽ gây ra nhiều rắc rối bởi vì các biến có thể thay đổi (mutable), và vì thế các biến đó có thể bị/được thay đổi giá trị từ lúc chúng được <em>đóng lại</em> cho đến lúc hàm trả về được gọi.</p>
<p>(Ở đây <em>đóng lại</em> ý nói lúc dùng <em>High-order function</em> để trả về một hàm, lúc này các biến trong scope của hàm đó vẫn có thể truy cập và thay đổi giá trị, do đó đến lúc thực thi hàm này, các biến này giá trị có thể khác so với lúc được trả về, gây ra các kết quả không mong muốn)</p>
<p>Thật may mắn là các biến trong FP sẽ là bất biến (immutable - đã nói đến ở phần 1), nên các lỗi có thể xảy ra do <em>Closure</em> như trong JS sẽ không gặp phải nữa.</p>
<h2 id="Dau-cua-toi"><a href="#Dau-cua-toi" class="headerlink" title="Đầu của tôi!!!!"></a>Đầu của tôi!!!!</h2><p><img src="https://viblo.asia/uploads/3cb3a723-1140-4d4c-abc8-9da098acc7d6.png" alt=""></p>
<p>Hôm nay đến đây thôi là đủ.</p>
<p>Trong các phần sau của bài viết này, tôi sẽ nói về các vấn đề như là <em>Functional Composition, Currying, các functional functions cơ bản (như là map, filter, fold,… ), và một vài thứ nữa</em></p>
<p>Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: <a href="https://www.facebook.com/groups/learnelm/" target="_blank" rel="noopener">Learn Elm Programming</a></p>
<p>Và đây là Twitter của tác giả : <a href="https://twitter.com/cscalfani" target="_blank" rel="noopener">@cscalfani</a></p>
<span>Source: </span><a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a#.eqo0af4ak" target="_blank" title="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a#.eqo0af4ak" class="post-from">https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a#.eqo0af4ak</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2017/08/Tro-thanh-Functional-Programmer-Phan-3.html" class="prev">NEXT</a><a href="/2017/08/Tro-thanh-Functional-Programmer-Phan-1.html" class="next">PREV</a></div><div class="copyright"><p>© 2017 - 2019 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>