<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Giải thích về Value và Reference trong Javascript · Learn and Share</title><meta name="description" content="Giải thích về Value và Reference trong Javascript - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Giải thích về Value và Reference trong Javascript"><meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/1*fSH4tDeqmv5VfE9aDOlndg.jpeg"><meta property="og:description" content="Dùng một cái nhìn đơn giản của bộ nhớ máy tính giải thích điều này
Javascript có 5 kiểu dữ liệu được thông qua value: Boolean, null, undefined, String, và Number. Chúng ta sẽ gọi chung là primitive types.
Javascript có 5 kiểu dữ liệu được thông qua reference: Array, Function, và Object. Về mặt kỹ thuật đó là  Objects, vì vậy chúng ta sẽ đề cập đến chúng chung chung như Objects."></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Giải thích về Value và Reference trong Javascript</h1><h2 class="post-subtitle"></h2><header class="post-info">Aug 21, 2017<div class="tags"><a href="/tags/javascript" class="tag-link">#javascript</a></div><div class="fb-ir-time"><time dateTime="2017-08-21T12:32:28.000Z" class="op-modified"></time><time dateTime="2017-08-21T12:32:28.000Z" class="op-published"></time></div></header></div><div class="post-banner"><img src="https://cdn-images-1.medium.com/max/1600/1*fSH4tDeqmv5VfE9aDOlndg.jpeg"></div><div class="wrap"><div class="post-content"><p>Dùng một cái nhìn đơn giản của bộ nhớ máy tính giải thích điều này</p>
<p>Javascript có 5 kiểu dữ liệu được thông qua <strong><em>value</em></strong>: <code>Boolean</code>, <code>null</code>, <code>undefined</code>, <code>String</code>, và <code>Number</code>. Chúng ta sẽ gọi chung là <strong>primitive types</strong>.</p>
<p>Javascript có 5 kiểu dữ liệu được thông qua <strong><em>reference</em></strong>: <code>Array</code>, <code>Function</code>, và <code>Object</code>. Về mặt kỹ thuật đó là  Objects, vì vậy chúng ta sẽ đề cập đến chúng chung chung như <strong>Objects</strong>.</p>
<a id="more"></a>
<h3 id="Primitives-Nguyen-thuy"><a href="#Primitives-Nguyen-thuy" class="headerlink" title="Primitives (Nguyên thủy)"></a>Primitives (Nguyên thủy)</h3><p>Nếu một kiểu nguyên thủy được gán cho một biến, chúng ta có thể nghĩ rằng biến đó <em>chứa đựng</em> giá trị nguyên thủy.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> z = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p><code>x</code> <em>chứa đựng</em> <code>10</code>. <code>y</code> <em>chứa đựng</em> <code>&#39;abc&#39;</code>. Để củng cố ý tưởng này, chúng tôi sẽ cung cấp một hình ảnh về những gì các biến này và các giá trị tương ứng giống như trong bộ nhớ.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*PdKLlT7zUrmDBZUOBsZh7w.png" alt=""></p>
<p>Khi chúng ta gán các biến này cho các biến khác sử dụng dấu <code>=</code>, Chúng ta <strong>copy</strong> giá trị cho biến mới. Chúng được sao chép theo giá trị.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> a = x;</span><br><span class="line"><span class="keyword">var</span> b = y;</span><br><span class="line"><span class="built_in">console</span>.log(x, y, a, b); <span class="comment">// -&gt; 10, 'abc', 10, 'abc'</span></span><br></pre></td></tr></table></figure>
<p>Cả <code>a</code> và <code>x</code> bây giờ chứa <code>10</code>. Cả <code>b</code> và <code>y</code> bây giờ chứa <code>&#39;abc&#39;</code>. Chúng là tách biệt, vì các giá trị được sao chép.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*MZ3AcwELYZ2ONYFg3LiTXQ.png" alt=""></p>
<p>Khi thay đổi một biến nó không thay đổi cái khác. Hãy suy nghĩ là các biến như không có mối quan hệ với nhau.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> a = x;</span><br><span class="line"><span class="keyword">var</span> b = y;</span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span>;</span><br><span class="line">b = <span class="string">'def'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x, y, a, b); <span class="comment">// -&gt; 10, 'abc', 5, 'def'</span></span><br></pre></td></tr></table></figure>
<h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><p>This will feel confusing, but bear with me and read through it. Once you get through it, it’ll seem easy.</p>
<p>Variables that are assigned a non-primitive value are given a <em>reference</em> to that value. That reference points to the object’s location in memory. The variables don’t actually contain the value.</p>
<p>Objects are created at some location in your computer’s memory. When we write <code>arr = []</code>, we’ve created an array in memory. What the variable <code>arr</code> receives is the address, the location, of that array.</p>
<p>Let’s pretend that <code>address</code> is a new data type that is passed by value, just like <code>number</code> or <code>string</code>. An <code>address</code> points to the location, in memory, of a value that is passed by reference. Just like a string is denoted by quotation marks (<code>&#39;&#39;</code> or <code>&quot;&quot;</code>), an <code>address</code> will be denoted by arrow brackets, <code>&lt;&gt;</code>.</p>
<p>When we assign and use a reference-type variable, what we write and see is:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="number">2</span>) arr.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>A representation of lines 1 and 2 above in memory is:</p>
<p>1.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*h1aXuPwCyhu6GKwgeFMLDw.png" alt=""></p>
<p>2.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*HaemMnuU05EW1b3BZPubIg.png" alt=""></p>
<p>Notice that the value, the address, contained by the variable <code>arr</code> is static. The array in memory is what changes. When we use <code>arr</code> to do something, such as pushing a value, the Javascript engine goes to the location of <code>arr</code> in memory and works with the information stored there.</p>
<h4 id="Assigning-by-Reference"><a href="#Assigning-by-Reference" class="headerlink" title="Assigning by Reference"></a>Assigning by Reference</h4><p>When a reference type value, an object, is copied to another variable using <code>=</code>, the address of that value is what’s actually copied over as if it were a primitive. <strong>Objects are copied by reference</strong> instead of by value.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reference = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> refCopy = reference;</span><br></pre></td></tr></table></figure>
<p>The code above looks like this in memory.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*d2W3ulHbHRGrFQ-c1SG5gA.png" alt=""></p>
<p>Each variable now contains a reference to the <em>same array</em>. That means that if we alter <code>reference</code>, <code>refCopy</code> will see those changes:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(reference, refCopy); <span class="comment">// -&gt; [1, 2], [1, 2]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*RFrFRXIperg0yTwXauc97w.png" alt=""></p>
<p>We’ve pushed <code>2</code> into the array in memory. When we use <code>reference</code> and <code>refCopy</code>, we’re pointing to that same array.</p>
<h4 id="Reassigning-a-Reference"><a href="#Reassigning-a-Reference" class="headerlink" title="Reassigning a Reference"></a>Reassigning a Reference</h4><p>Reassigning a reference variable replaces the old reference.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">first</span>: <span class="string">'reference'</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>In memory:</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*PWGp9d2zZ_QGg18HXBSq9Q.png" alt=""></p>
<p>When we have a second line:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">first</span>: <span class="string">'reference'</span> &#125;;</span><br><span class="line">obj = &#123; <span class="attr">second</span>: <span class="string">'ref2'</span> &#125;</span><br></pre></td></tr></table></figure>
<p>The address stored in <code>obj</code> changes. The first object is still present in memory, and so is the next object:</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*1h73Wn9IyaiXbhxhmJZmYA.png" alt=""></p>
<p>When there are no references to an object remaining, as we see for the address <code>#234</code> above, the Javascript engine can perform garbage collection. This just means that the programmer has lost all references to the object and can’t use the object any more, so the engine can go ahead and safely delete it from memory. In this case, the object <code>{ first: &#39;reference&#39; }</code> is no longer accessible and is available to the engine for garbage collection.</p>
<h3 id="and"><a href="#and" class="headerlink" title="== and ==="></a>== and ===</h3><p>When the equality operators, <code>==</code> and <code>===</code>, are used on reference-type variables, they check the reference. If the variables contain a reference to the same item, the comparison will result in <code>true</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrRef = [’Hi!’];</span><br><span class="line"><span class="keyword">var</span> arrRef2 = arrRef;<span class="built_in">console</span>.log(arrRef === arrRef2); <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>
<p>If they’re distinct objects, even if they contain identical properties, the comparison will result in <code>false</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">'Hi!'</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">'Hi!'</span>];<span class="built_in">console</span>.log(arr1 === arr2); <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>
<p>If we have two distinct objects and want to see if their properties are the same, the easiest way to do so is to turn them both into strings and then compare the strings. When the equality operators are comparing primitives, they simply check if the values are the same.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1str = <span class="built_in">JSON</span>.stringify(arr1);</span><br><span class="line"><span class="keyword">var</span> arr2str = <span class="built_in">JSON</span>.stringify(arr2);<span class="built_in">console</span>.log(arr1str === arr2str); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Another option would be to recursively loop through the objects and make sure each of the properties are the same.</p>
<h3 id="Passing-Parameters-through-Functions"><a href="#Passing-Parameters-through-Functions" class="headerlink" title="Passing Parameters through Functions"></a>Passing Parameters through Functions</h3><p>When we pass primitive values into a function, the function copies the values into its parameters. It’s effectively the same as using <code>=</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hundred = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> two = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// PAUSE</span></span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> twoHundred = multiply(hundred, two);</span><br></pre></td></tr></table></figure>
<p>In the example above, we give <code>hundred</code> the value <code>100</code>. When we pass it into <code>multiply</code>, the variable <code>x</code> gets that value, <code>100</code>. The value is copied over as if we used an <code>=</code> assignment. Again, the value of <code>hundred</code> is not affected. Here is a snapshot of what the memory looks like right at the PAUSE comment line in <code>multiply</code>.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*3AYcflNTwTTGTgCul0DgBw.png" alt=""></p>
<h4 id="Pure-Functions"><a href="#Pure-Functions" class="headerlink" title="Pure Functions"></a>Pure Functions</h4><p>We refer to functions that don’t affect anything in the outside scope as <em>pure functions</em>. As long as a function only takes primitive values as parameters and doesn’t use any variables in its surrounding scope, it is automatically pure, as it can’t affect anything in the outside scope. All variables created inside are garbage-collected as soon as the function returns.</p>
<p>A function that takes in an Object, however, can mutate the state of its surrounding scope. If a function takes in an array reference and alters the array that it points to, perhaps by pushing to it, variables in the surrounding scope that reference that array see that change. After the function returns, the changes it makes persist in the outer scope. This can cause undesired side effects that can be difficult to track down.</p>
<p>Many native array functions, including <code>Array.map</code> and <code>Array.filter</code>, are therefore written as pure functions. They take in an array reference and internally, they copy the array and work with the copy instead of the original. This makes it so the original is untouched, the outer scope is unaffected, and we’re returned a reference to a brand new array.</p>
<p>Let’s go into an example of a pure vs. impure function.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeAgeImpure</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    person.age = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> alex = &#123;</span><br><span class="line">    name: <span class="string">'Alex'</span>,</span><br><span class="line">    age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> changedAlex = changeAgeImpure(alex);</span><br><span class="line"><span class="built_in">console</span>.log(alex); <span class="comment">// -&gt; &#123; name: 'Alex', age: 25 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(changedAlex); <span class="comment">// -&gt; &#123; name: 'Alex', age: 25 &#125;</span></span><br></pre></td></tr></table></figure>
<p>This impure function takes in an object and changes the property <code>age</code> on that object to be 25. Because it acts on the reference it was given, it directly changes the object <code>alex</code>. Note that when it returns the <code>person</code> object, it is returning the exact same object that was passed in. <code>alex</code> and <code>alexChanged</code> contain the same reference. It’s redundant to return the <code>person</code> variable and to store the reference in a new variable.</p>
<p>Let’s look at a pure function.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeAgePure</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newPersonObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(person));</span><br><span class="line">    newPersonObj.age = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">return</span> newPersonObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> alex = &#123;</span><br><span class="line">    name: <span class="string">'Alex'</span>,</span><br><span class="line">    age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> alexChanged = changeAgePure(alex);</span><br><span class="line"><span class="built_in">console</span>.log(alex); <span class="comment">// -&gt; &#123; name: 'Alex', age: 30 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(alexChanged); <span class="comment">// -&gt; &#123; name: 'Alex', age: 25 &#125;</span></span><br></pre></td></tr></table></figure>
<p>In this function, we use <code>JSON.stringify</code> to transform the object we’re passed into a string, and then parse it back into an object with <code>JSON.parse</code>. By performing this transformation and storing the result in a new variable, we’ve created a new object. There are other ways to do the same thing such as looping through the original object and assigning each of its properties to a new object, but this way is simplest. The new object has the same properties as the original but it is a distinctly separate object in memory.</p>
<p>When we change the <code>age</code> property on this new object, the original is unaffected. This function is now pure. It can’t affect any object outside its own scope, not even the object that was passed in. The new object needs to be returned and stored in a new variable or else it gets garbage collected once the function completes, as the object is no longer in scope.</p>
<h4 id="Test-Yourself"><a href="#Test-Yourself" class="headerlink" title="Test Yourself"></a>Test Yourself</h4><p>Value vs. reference is a concept often tested in coding interviews. Try to figure out for yourself what’s logged here.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeAgeAndReference</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    person.age = <span class="number">25</span>;</span><br><span class="line">    person = &#123;</span><br><span class="line">        name: <span class="string">'John'</span>,</span><br><span class="line">        age: <span class="number">50</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> personObj1 = &#123;</span><br><span class="line">    name: <span class="string">'Alex'</span>,</span><br><span class="line">    age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> personObj2 = changeAgeAndReference(personObj1);</span><br><span class="line"><span class="built_in">console</span>.log(personObj1); <span class="comment">// -&gt; ?</span></span><br><span class="line"><span class="built_in">console</span>.log(personObj2); <span class="comment">// -&gt; ?</span></span><br></pre></td></tr></table></figure>
<p>The function first changes the property <code>age</code> on the original object it was passed in. It then reassigns the variable to a brand new object and returns that object. Here’s what the two objects are logged out.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(personObj1); <span class="comment">// -&gt; &#123; name: 'Alex', age: 25 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(personObj2); <span class="comment">// -&gt; &#123; name: 'John', age: 50 &#125;</span></span><br></pre></td></tr></table></figure>
<p>Remember that assignment through function parameters is essentially the same as assignment with <code>=</code>. The variable <code>person</code> in the function contains a reference to the <code>personObj1</code> object, so initially it acts directly on that object. Once we reassign <code>person</code> to a new object, it stops affecting the original.</p>
<p>This reassignment does not change the object that <code>personObj1</code> points to in the outer scope. <code>person</code> has a new reference because it was reassigned but this reassignment doesn’t change <code>personObj1</code>.</p>
<p>An equivalent piece of code to the above block would be:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> personObj1 = &#123;</span><br><span class="line">    name: <span class="string">'Alex'</span>,</span><br><span class="line">    age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = personObj1;</span><br><span class="line">person.age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">  name: <span class="string">'john'</span>,</span><br><span class="line">  age: <span class="number">50</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> personObj2 = person;</span><br><span class="line"><span class="built_in">console</span>.log(personObj1); <span class="comment">// -&gt; &#123; name: 'Alex', age: 25 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(personObj2); <span class="comment">// -&gt; &#123; name: 'John', age: '50' &#125;</span></span><br></pre></td></tr></table></figure>
<p>The only difference is that when we use the function, <code>person</code> is no longer in scope once the function ends.</p>
<h4 id="Ket-thuc-Bat-dau-viet-code-nao"><a href="#Ket-thuc-Bat-dau-viet-code-nao" class="headerlink" title="Kết thúc. Bắt đầu viết code nào."></a>Kết thúc. Bắt đầu viết code nào.</h4><span>Source: </span><a href="https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0" target="_blank" title="https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0" class="post-from">https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2017/08/Tro-thanh-Functional-Programmer-Phan-1.html" class="prev">NEXT</a><a href="/2017/08/Optimizing-React-Apps-in-Practice.html" class="next">PREV</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'nthung2112';
var disqus_identifier = '2017/08/Explaining-Value-vs-Reference-in-Javascript.html';
var disqus_title = 'Giải thích về Value và Reference trong Javascript';
var disqus_url = 'http://nth-blogs.herokuapp.com/2017/08/Explaining-Value-vs-Reference-in-Javascript.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//nthung2112.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2018 <a href="http://nth-blogs.herokuapp.com">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>