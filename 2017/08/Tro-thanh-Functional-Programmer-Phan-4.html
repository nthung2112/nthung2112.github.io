<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Trở thành Functional Programmer - Phần 4 · Learn and Share</title><meta name="description" content="Trở thành Functional Programmer - Phần 4 - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Trở thành Functional Programmer - Phần 4"><meta property="og:image" content="https://viblo.asia/uploads/e85b8079-5076-40ca-af63-f1a136d06516.png"><meta property="og:description" content="Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP."></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Trở thành Functional Programmer - Phần 4</h1><h2 class="post-subtitle"></h2><header class="post-info">Aug 23, 2017<div class="tags"></div><div class="fb-ir-time"><time datetime="2017-08-23T16:26:54.000Z" class="op-modified"></time><time datetime="2017-08-23T16:26:54.000Z" class="op-published"></time></div></header></div><div class="post-banner"><img src="https://viblo.asia/uploads/e85b8079-5076-40ca-af63-f1a136d06516.png"></div><div class="wrap"><div class="post-content"><p>Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP.</p>
<a id="more"></a>
<h2 id="Concept-7-Currying"><a href="#Concept-7-Currying" class="headerlink" title="Concept 7 : Currying"></a>Concept 7 : Currying</h2><p><img src="https://viblo.asia/uploads/75b303cf-5fdd-4e50-bfc9-a3a847bbff55.png" alt=""></p>
<p>Tiếp tục câu chuyện ở cuối <a href="https://viblo.asia/ta.duy.anh/posts/JdAGJgkgRgk" target="_blank" rel="noopener">Phần 3</a> , lý do khiến chúng ta gặp phải vấn đề trong việc kết hợp hai hàm <code>mul5</code> và <code>add</code> là bởi vì hàm <code>mult5</code> có 1 tham số, trong khi hàm <code>add</code> lại có 2.</p>
<p>Chúng ta có thể giải quyết vấn đề này bằng cách giới hạn lại mỗi hàm chỉ lấy một tham số.</p>
<p>Nghe có vẻ hơi kỳ kỳ, nhưng tin tôi đi, ý tưởng này không tệ một chút nào đâu.</p>
<p>Chúng ta sẽ chỉ đơn giản là viết một hàm <code>add</code> vẫn có hai tham số, nhưng có khả năng nhận giá trị cho <strong>một</strong> tham số trong một thời điểm. Và hàm hỗ trợ khả năng này được biết đến với cái tên là <em>Curried Function</em>.</p>
<blockquote>
<p>Một Curried Fuction là một hàm chỉ nhận một tham số trong một thời điểm.</p>
</blockquote>
<p>Điều này sẽ cho phép chúng ta gán giá trị tham số đầu tiên của hàm <code>add</code> <em>trước khi</em> kết hợp với hàm <code>mult5</code>. Và sau đó khi hàm <code>mult5AfterAdd10</code> được gọi, hàm <code>add</code> sẽ nhận giá trị tham số thứ hai.</p>
<p>Trong Javascript, chúng ta có thể đạt được điều này bằng cách viết lại hàm <code>add</code> như sau:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var add = x =&gt; y =&gt; x + y</span><br></pre></td></tr></table></figure>
<p>Phiên bản này của hàm <code>add</code> sẽ nhận hai tham số gồm <code>x</code> và <code>y</code>, nhưng <em>một tham số (x) sẽ được set khi gọi hàm lần đầu tiên</em> và <em>tham số còn lại (y) sẽ được set khi gọi hàm lần thứ 2</em>.</p>
<p>Cụ thể hơn, đầu tiên, hàm <code>add</code> sẽ nhận giá trị cho tham số <code>x</code>, và trả về một <strong>hàm</strong> mới với một tham số có tên là <code>y</code>, với giá trị kết quả trả về là <strong>tổng của hai tham số x và y</strong>.</p>
<p>Và bây giờ chúng ta có thể sử dụng phiên bản trên của hàm <code>add</code> để tạo ra hàm <code>mult5AfterAdd10</code> như mong muốn :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var compose = (f, g) =&gt; x =&gt; f(g(x));</span><br><span class="line">var mult5AfterAdd10 = compose(mult5, add(10));</span><br></pre></td></tr></table></figure>
<p>Hàm <code>compose</code> sẽ nhận 2 tham số là <code>f</code> và <code>g</code>, và trả về một hàm nhận 1 tham số <code>x</code>, mà khi được gọi sẽ thực hiện lần lượt 2 hàm <code>g</code> và <code>f</code> lên với tham số nhận được (gọi hàm <code>g(x)</code>, kết quả nhận được truyền vào hàm <code>f</code>, tương đương với việc gọi <code>f(g(x))</code>).</p>
<p>Vậy chính xác ta đã làm gì? Theo lý thuyết thì ta đã tạo ra một phiên bản <code>curried function</code> của hàm <code>add</code> truyền thống. Việc này làm hàm <code>add</code> trở nên linh động hơn, bởi vì 2 tham số có thể được set ở 2 thời điểm khác nhau. Tham số đầu tiên, 10 được truyền vào để <em>tạo ra hàm mult5AfterAdd10</em>, và tham số thứ 2 được truyền vào khi <em>thực hiện hàm mul5AfterAdd10 với một tham số bất kỳ</em>.</p>
<p>Đến đây, bạn có thể nghĩ rằng làm thế nào để viết lại hàm <code>add</code> theo phong cách trên bằng ngôn ngữ Elm. Tôi xin giải đáp luôn là bạn không cần phải làm thế đâu. Trong Elm và các ngôn ngữ FP khác, <strong>tất cả các hàm đều là curried function</strong>.</p>
<p>Vậy là hàm <code>add</code> trong Elm vẫn giữ nguyên cách khai báo :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add x y =</span><br><span class="line">    x + y</span><br></pre></td></tr></table></figure>
<p>Và đây là cách mà hàm <code>mult5AfterAdd10</code> <em>nên</em> được viết:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mult5AfterAdd10 =</span><br><span class="line">    (mult5 &lt;&lt; add 10)</span><br></pre></td></tr></table></figure>
<p>Về mặt cú pháp, có thể nói rằng Elm đã đánh bại hoàn toàn Javascript cũng như các ngôn ngữ Imperative khác bởi vì nó đã được tối ưu cho những concept cơ bản của FP như là <strong>Currying</strong> hay <strong>Composition</strong>.</p>
<h2 id="Currying-va-Tai-cau-truc-code"><a href="#Currying-va-Tai-cau-truc-code" class="headerlink" title="Currying và Tái cấu trúc code"></a>Currying và Tái cấu trúc code</h2><p><img src="https://viblo.asia/uploads/02af022c-a568-4f90-9cbe-3b8f2354afa1.png" alt=""></p>
<p>Ngoài khả năng dùng để tạo ra các hàm hợp như đã mô tả ở trên, Currying còn rất hữu ích khi chúng ta thực hiện tái cấu trúc code. Đó là khi ta muốn tạo một hàm tổng với rất nhiều tham số, và sau đó sử dụng nó để tạo ra các hàm cụ thể phù hợp với từng ngữ cảnh sử dụng, mà yêu cầu ít tham số hơn.</p>
<p>Lấy ví dụ, khi chúng ta có 2 hàm sau đây dùng để thêm 1 hoặc 2 dấu ngoặc nhọn vào trước và sau 1 String:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bracket str =</span><br><span class="line">    &quot;&#123;&quot; ++ str ++ &quot;&#125;&quot;</span><br><span class="line">doubleBracket str =</span><br><span class="line">    &quot;&#123;&#123;&quot; ++ str ++ &quot;&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>Và đây là một số ngữ cảnh chúng ta sẽ sử dụng 2 hàm đó :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bracketedJoe =</span><br><span class="line">    bracket &quot;Joe&quot;</span><br><span class="line">doubleBracketedJoe =</span><br><span class="line">    doubleBracket &quot;Joe&quot;</span><br></pre></td></tr></table></figure>
<p>Chúng ta có thể tổng quát hóa 2 hàm <code>bracket</code> và <code>doubleBracket</code> thành 1 hàm như sau :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">generalBracket prefix str suffix =</span><br><span class="line">    prefix ++ str ++ suffix</span><br></pre></td></tr></table></figure>
<p>Nhưng như vậy thì mỗi khi sử dụng hàm <code>generalBracket</code>, chúng ta sẽ phải truyền thêm giá trị dấu đóng/mở ngoặc :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bracketedJoe =</span><br><span class="line">    generalBracket &quot;&#123;&quot; &quot;Joe&quot; &quot;&#125;&quot;</span><br><span class="line">doubleBracketedJoe =</span><br><span class="line">    generalBracket &quot;&#123;&#123;&quot; &quot;Joe&quot; &quot;&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>Cái chúng ta <strong>thực sự muốn</strong> là tập hợp các lợi ích của cả 2 cách: sử dụng đơn giản (truyền mỗi String vào hàm), nhưng không được lặp code.</p>
<p>Nếu chúng ta sắp xếp lại thứ tự các tham số của hàm <code>generateBracket</code>, chúng ta có thể tạo ra 2 hàm <code>bracket</code> và <code>doubleBracket</code> vì hàm <code>generateBracket</code> vốn đã hỗ trợ <strong>Currying</strong> rồi:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">generalBracket prefix suffix str =</span><br><span class="line">    prefix ++ str ++ suffix</span><br><span class="line">bracket =</span><br><span class="line">    generalBracket &quot;&#123;&quot; &quot;&#125;&quot;</span><br><span class="line">doubleBracket =</span><br><span class="line">    generalBracket &quot;&#123;&#123;&quot; &quot;&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>Để ý rằng bằng việc đưa các tham số có vẻ như sẽ được set cố định trước lên đầu tiên, trong ví dụ này là <code>prefix</code> và <code>suffix</code>, và đưa các tham số sẽ được set sau cùng vào phía sau, chúng ta có thể tạo ra các phiên bản cụ thể và phù hợp với nhu cầu sử dụng từ hàm <code>generalBracket</code>.</p>
<blockquote>
<p>Thứ tự các tham số là rất quan trọng trong việc tận dụng khả năng Currying.</p>
</blockquote>
<p>Đồng thời, ta cũng có thể nhận thấy là các hàm <code>bracket</code> và <code>doubleBracket</code> đều được viết dưới dạng <code>Point-free Notation</code>, cụ thể trong trường hợp này tham số <code>str</code> được loại bỏ. Cả 2 hàm <code>bracket</code> và <code>doubleBracket</code> đều là những hàm đang chờ đợi tham số cuối cùng.</p>
<p>Và giờ chúng ta có thể sử dụng 2 hàm đó như trước khi tái cấu trúc code :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bracketedJoe =</span><br><span class="line">    bracket &quot;Joe&quot;</span><br><span class="line">doubleBracketedJoe =</span><br><span class="line">    doubleBracket &quot;Joe&quot;</span><br></pre></td></tr></table></figure>
<p>Nhưng lần này chúng ta đã sử dụng một hàm tổng quát hỗ trợ Currying có tên <code>generalBracket</code>.</p>
<h2 id="Mot-so-ham-functional-co-ban"><a href="#Mot-so-ham-functional-co-ban" class="headerlink" title="Một số hàm functional cơ bản"></a>Một số hàm functional cơ bản</h2><p><img src="https://viblo.asia/uploads/a46820f6-9392-4205-9ad8-47a1b3830305.png" alt=""></p>
<p>Giờ chúng ta sẽ đến với 3 hàm cơ bản thường được sử dụng trong Functional Programming.</p>
<p>Nhưng trước tiên, tôi muốn mời bạn xem đoạn code sau trong Javascript:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; something.length; ++i) &#123;</span><br><span class="line">    // do stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Có một vấn đề khá điển hình với đoạn code trên. Mặc dù không phải là bug, nhưng đoạn code trên sẽ được chúng ta viết hoặc copy paste mỗi lần muốn sử dụng vòng lặp (boilerplate code - code khuôn mẫu), nên sẽ khiến việc viết đọc code trở nên mệt mỏi dần theo thời gian.</p>
<p>Nếu làm việc với các ngôn ngữ Imperative như là Java, C#, Javascript, PHP, Python,… bạn sẽ dễ dàng nhận thấy mình phải liên tục viết đi viết lại các dòng code tương tự như trên nhiều hơn bất cứ thứ gì khác.</p>
<p>Và đó chính là vấn đề mà tôi muốn nói đến.</p>
<p>Vì vậy tiếp theo đây chúng ta sẽ bàn về việc khử các đoạn code nhàm chán đó. Hãy đưa chúng và một hàm (hoặc một vài hàm) và ta sẽ <em>không bao giờ</em> phải viết một vòng lặp <em>for</em> một lần nào nữa. Thực tế thì điều đó khá là bất khả thi, nếu như chúng ta không biết đến FP.</p>
<p>Trước hết, hãy bắt đầu bằng việc thay đổi một mảng có tên là <code>things</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var things = [1, 2, 3, 4];</span><br><span class="line">for (var i = 0; i &lt; things.length; ++i) &#123;</span><br><span class="line">    things[i] = things[i] * 10; // MUTATION ALERT !!!!</span><br><span class="line">&#125;</span><br><span class="line">console.log(things); // [10, 20, 30, 40]</span><br></pre></td></tr></table></figure>
<p>Bạn có nhận thấy điều gì ở đây ko? Đó chính là <strong>Mutability - biến things đã bị thay đổi giá trị</strong></p>
<p>Chúng ta sẽ thử lại, lần này sẽ không thay đổi giá trị biến <em>things</em> nữa:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var things = [1, 2, 3, 4];</span><br><span class="line">var newThings = [];</span><br><span class="line">for (var i = 0; i &lt; things.length; ++i) &#123;</span><br><span class="line">    newThings[i] = things[i] * 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(newThings); // [10, 20, 30, 40]</span><br></pre></td></tr></table></figure>
<p>Lần này thì chúng ta không thay đổi giá trị của biến <em>things</em>, nhưng về mặt kỹ thuật thì chúng ta <em>vẫn thay đổi giá trị của biến newThings</em>, nhưng chúng ta sẽ bỏ qua và chấp nhận điều đó, vì hiện tại ta vẫn đang sử dụng Javascript. Khi chuyển sang các ngôn ngữ FP, bạn sẽ không thay đổi biến được nữa đâu.</p>
<p>Mục đích mà tôi muốn nói ở đây là giải thích rõ ràng hơn cách hoạt động của những hàm cơ bản trong FP (map, reduce, filter,… ), cũng như tác dụng của chúng trong việc giảm bớt những phiền phức không đáng có trong code của mình. Do đó code JS có thể không mô tả đúng hoàn toàn cách các hàm đó thực hiện, nhưng về concept thì các bạn cứ yên tâm mà theo dõi nhé.</p>
<p>Giờ với đoạn code ở trên (không thay đổi biến <code>things</code>), chúng ta sẽ đưa nó vào một hàm cơ bản đầu tiên có tên là <code>map</code>, với nhiện vụ là ánh xạ (map) từng giá trị của mảng cũ đến một mảng mới, thông qua một hàm biến đổi <code>f</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var map = (f, array) =&gt; &#123;</span><br><span class="line">    var newArray = [];</span><br><span class="line">    for (var i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">        newArray[i] = f(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return newArray;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Ta có thể thấy hàm map ngoài tham số là một mảng cần biến đổi, sẽ nhận thêm một tham số là <code>f</code>, đại diện cho việc mà chúng ta muốn xử lý với từng phần tử trong mảng cũ trước khi đưa vào mảng mới. (VD : nhân đôi từng phần tử thì hàm <code>f</code> sẽ là <code>var f = x =&gt; x *2</code>, hoặc cộng mỗi phần tử thêm 1 thì hàm <code>f</code> sẽ là <code>var f = x =&gt; x+1</code>, …)</p>
<p>Và với code ban đầu, chúng ta có thể viết lại bằng cách sử dụng hàm <code>map</code> như sau :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var things = [1, 2, 3, 4];</span><br><span class="line">var newThings = map(v =&gt; v * 10, things);</span><br></pre></td></tr></table></figure>
<p>Bạn có thể thấy là chúng ta đã không còn sử dụng vòng lặp <code>for</code> nữa, đồng thời code cũng trở nên dễ hiểu hơn (chúng ta có thể hiểu đoạn code trên là tạo ra một <code>newThings</code> là một mảng gồm các phần tử như mảng <code>things</code>, nhưng mỗi phần tử có giá trị <em>được nhân lên 10 lần</em>).</p>
<p>Về mặt kỹ thuật thì vẫn có vòng lặp <code>for</code> ở trong hàm <code>map</code>. Nhưng ít ra thì chúng ta sẽ không phải copy paste hoặc gõ lại cái đoạn code mẫu đó thêm một lần nữa.</p>
<p>Giờ thì chúng ta sẽ viết thêm một hàm có <code>filter</code> để lọc các phần tử của một mảng theo điều kiện bất kỳ:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var filter = (pred, array) =&gt; &#123;</span><br><span class="line">    var newArray = [];</span><br><span class="line">for (var i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">        if (pred(array[i]))</span><br><span class="line">            newArray[newArray.length] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return newArray;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Lưu ý hàm dùng để xác định có lấy phần tử đó hay không được truyền thông qua biến <code>pred</code>, chỉ trả về giá trị <code>Boolean</code> thôi nhé. Hàm này sẽ trả về TRUE khi chúng ta muốn giữ lại phần tử, và FALSE nếu chúng ta muốn loại nó ra.</p>
<p>Và đây là cách sử dụng hàm <code>filter</code> để lấy ra các phần tử là số lẻ trong một mảng :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var isOdd = x =&gt; x % 2 !== 0;</span><br><span class="line">var numbers = [1, 2, 3, 4, 5];</span><br><span class="line">var oddNumbers = filter(isOdd, numbers);</span><br><span class="line">console.log(oddNumbers); // [1, 3, 5]</span><br></pre></td></tr></table></figure>
<p>Sử dụng hàm <code>filter</code> vừa viết ở trên sẽ đơn giản và dễ dàng hơn rất nhiều với việc phải đóng mở vòng <code>for</code>, set các biến lưu giá trị,… những công việc nhàm chán lại hay sai.</p>
<p>Hàm thường xuyên được sử dụng trong FP tôi muốn giới thiệu cuối cùng có tên là <code>reduce</code>. Về cơ bản, nó được dùng với giá trị đầu vào là một danh sách, và kết quả trả ra là một giá trị đơn lẻ (nên mới được gọi là reduce - rút gọn), nhưng thực tế thì có rất nhiều cách để áp dụng.</p>
<p>Hàm <code>reduce</code> thường được biết đến với cái tên là <code>fold</code> trong FP:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var reduce = (f, start, array) =&gt; &#123;</span><br><span class="line">    var acc = start;</span><br><span class="line">    for (var i = 0; i &lt; array.length; ++i)</span><br><span class="line">        acc = f(array[i], acc); // f() takes 2 parameters</span><br><span class="line">    return acc;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Hàm <code>reduce</code> sẽ gồm 3 tham số, bao gồm một hàm <code>f</code> dùng để thực hiện rút gọn (reduce), một giá trị khởi đầu <code>start</code> và một mảng để thao tác <code>array</code>.</p>
<p>Để ý rằng hàm dùng cho việc rút gọn là <code>f</code> sẽ nhận 2 tham số, một là giá trị hiện tại của mảng <code>array</code>, một là giá trị tích lũy <code>acc</code> đang được tính toán và thay đổi khi duyệt qua từng phần tử trong mảng. Giá trị <code>acc</code> ở bước cuối cùng sẽ được trả về và cũng là kết quả của hàm <code>reduce</code>.</p>
<p>Ví dụ dưới đây sẽ giúp chúng ta hiểu rõ hơn cách hoạt động của hàm này :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var add = (x, y) =&gt; x + y;</span><br><span class="line">var values = [1, 2, 3, 4, 5];</span><br><span class="line">var sumOfValues = reduce(add, 0, values);</span><br><span class="line">console.log(sumOfValues); // 15</span><br></pre></td></tr></table></figure>
<p>Hàm <code>add</code> sẽ nhận vào 2 tham số và trả về tổng của chúng. Hàm <code>reduce</code> của chúng ta chấp nhận các hàm cho việc rút gọn với 2 tham số, nên trong trường hợp này hàm <code>add</code> là hoàn toàn hợp lý.</p>
<p>Chúng ta bắt đầu với giá trị <code>start</code> là 0 và truyền vào một mảng <code>values</code>, do đó kết quả nhận lại của hàm <code>reduce</code> sẽ là tổng các phần tử trong mảng <code>values</code>. Trong hàm <code>reduce</code>, giá trị tổng các phần tử sẽ được tích lũy, cộng dồn sau mỗi lần duyệt từng phần tử của mảng.</p>
<ul>
<li>Bắt đầu <code>acc = start = 0</code>, giá trị đầu tiên của mảng là <code>1</code>, lần thực hiện đầu tiên của hàm <code>add</code> sẽ là <code>add(1,0)</code> và <code>acc</code> mang giá trị 1</li>
<li>giá trị thứ 2 của mảng là <code>2</code>, <code>acc = 1</code>, hàm <code>add</code> lúc này sẽ được gọi với giá trị <code>add(2, 1)</code>,và <code>acc = 3</code></li>
</ul>
<p>Tiếp tục như vậy đến cuối cùng, giá trị <code>acc = 15</code> sau lần duyệt phần tử cuối cùng (5) của mảng value và được trả về bởi hàm <code>reduce</code>.</p>
<p>Có thể thấy rằng, mỗi hàm <code>map, filter, reduce</code> sẽ cho phép chúng ta thực hiện các biến đổi thông thường với một mảng mà không phải viết những đoạn code sử dụng vòng lặp dài dòng và khó hiểu nữa.</p>
<p>Nhưng trong FP, khi mà chúng ta chỉ có đệ quy, còn vòng lặp thì không tồn tại, thì các hàm duyệt và biến đổi mảng ở trên sẽ trở nên cực kì hữu ích và cần thiết.</p>
<h2 id="Dau-cua-toi"><a href="#Dau-cua-toi" class="headerlink" title="Đầu của tôi!!!!"></a>Đầu của tôi!!!!</h2><p><img src="https://viblo.asia/uploads/3cb3a723-1140-4d4c-abc8-9da098acc7d6.png" alt=""></p>
<p>Hôm nay đến đây thôi là đủ.</p>
<p>Trong các phần sau của bài viết này, tôi sẽ nói về các vấn đề như là <em>Referential Integrity, Execution Order, Types và một vài thứ nữa</em></p>
<p>Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: <a href="https://www.facebook.com/groups/learnelm/" target="_blank" rel="noopener">Learn Elm Programming</a></p>
<p>Và đây là Twitter của tác giả : <a href="https://twitter.com/cscalfani" target="_blank" rel="noopener">@cscalfani</a></p>
<span>Source: </span><a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49#.31qt9bfj5" target="_blank" title="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49#.31qt9bfj5" class="post-from">https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49#.31qt9bfj5</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2017/08/Tro-thanh-Functional-Programmer-Phan-5.html" class="prev">NEXT</a><a href="/2017/08/Tro-thanh-Functional-Programmer-Phan-3.html" class="next">PREV</a></div><div class="copyright"><p>© 2017 - 2019 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>