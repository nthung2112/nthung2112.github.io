<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> 3 Reasons why I stopped using React.setState · Learn and Share</title><meta name="description" content="3 Reasons why I stopped using React.setState - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="3 Reasons why I stopped using React.setState"><meta property="og:image"><meta property="og:description" content="Since a few months I’ve stopped using React’s setState on all my new React components. Don’t get me wrong, I didn’t stop having local component state, I just stopped using React to manage it. And it’s been delightful!
Using setState is tricky for beginners. Even experienced React programmers easily introduce subtle bugs when using React’s own state mechanism, like this:
Bug introduced by forgetting that React state is asynchronous; the log is always one item behind"></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">3 Reasons why I stopped using React.setState</h1><h2 class="post-subtitle"></h2><header class="post-info">Aug 21, 2017<div class="tags"><a href="/tags/react" class="tag-link">#react</a><a href="/tags/mobx" class="tag-link">#mobx</a></div><div class="fb-ir-time"><time dateTime="2017-08-21T07:43:25.000Z" class="op-modified"></time><time dateTime="2017-08-21T07:43:25.000Z" class="op-published"></time></div></header></div><div class="wrap"><div class="post-content"><p>Since a few months I’ve stopped using React’s <em>setState</em> on all my new React components. Don’t get me wrong, I didn’t stop having local component state, I just stopped using React to manage it. And it’s been delightful!</p>
<p>Using <em>setState</em> is tricky for beginners. Even experienced React programmers easily introduce subtle bugs when using React’s own state mechanism, like this:</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*v2qbGqdV8wM1G4ixs7woEw.gif" alt="">Bug introduced by forgetting that React state is asynchronous; the log is always one item behind<br><a id="more"></a></p>
<p>The excellent Reacts <a href="https://facebook.github.io/react/docs/component-api.html" target="_blank" rel="noopener">docs</a> sum up everything that could go wrong when using <em>setState</em>:</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*OtKvlJDJPjbSVM6o-yjL_Q.png" alt=""></p>
<p>To summarize, there are 3 issues when using <em>setState:</em></p>
<h4 id="1-setState-is-asynchronous"><a href="#1-setState-is-asynchronous" class="headerlink" title="1. setState is asynchronous"></a>1. setState is asynchronous</h4><p>Many devs don’t realize this initially, but setState is <em>asynchronous.</em> If you set some state, than take a look at it, you will still see the old state.This is the most tricky part of setState. setState calls don’t look asynchronous, and naively calling setState introduces very subtle bugs. The next gist demonstrates that nicely:</p>
<script src="//gist.github.com/bd5bdff6c3488d6abcb3a1a90f9bcce1.js"></script>
<p>At first glance this might look fine. Two event handlers and a utility function that fire the <em>onSelect</em> event if provided. However, this <em>Select</em> component has a bug that is nicely demonstrated in the GIF above. <em>onSelect</em> is always fired with the previous value of <em>state.selection</em>, because <em>setState</em> hasn’t done it’s job <em>yet</em> when the <em>fireOnSelect</em> helperis invoked. I think the least React could do here is rename the method to <em>scheduleState</em> or make the callback required.</p>
<blockquote>
<p>This bug is easily fixed, the tricky part is realizing it’s there.</p>
</blockquote>
<h4 id="2-setState-causes-unnecessary-renders"><a href="#2-setState-causes-unnecessary-renders" class="headerlink" title="2. setState causes unnecessary renders"></a>2. setState causes unnecessary renders</h4><p>The second issue with <em>setState</em> is that it always triggers a re-render. Often those re-renders are unnecessary. You can use the <a href="https://facebook.github.io/react/docs/perf.html#perf.printwastedmeasurements" target="_blank" rel="noopener"><em>printWasted</em></a> method from the React performance tools to find out when this happens. But roughly speaking there are several reasons why a re-render may be unnecessary:</p>
<ul>
<li>The new state is actually the same as the previous one. This can often be addressed by implementing <em>shouldComponentUpdate</em>. You may already be using a (pure render) library to solve this for you.</li>
<li>Sometimes the changed state is relevant for the rendering, but not under all circumstances. For example when some data is only conditionally visible.</li>
<li>Thirdly, as pointed out in Aria Buckles’ <a href="https://youtu.be/2Qu-Ulrsfl8?t=12m09s" target="_blank" rel="noopener">talk at React Europe 2015</a>, sometimes instance state is not relevant for the rendering at all! This is often householding state related to managing event listeners, timer ID’s etc.</li>
</ul>
<h4 id="3-setState-is-not-sufficient-to-capture-all-component-state"><a href="#3-setState-is-not-sufficient-to-capture-all-component-state" class="headerlink" title="3. setState is not sufficient to capture all component state"></a>3. setState is not sufficient to capture all component state</h4><p>Following the last point above, not all component state should be stored and updated using <em>setState</em>. More complex components often have administration that is needed by lifecycle hooks to manage timers, network requests, events etc. Managing those with <em>setState</em> not only causes unnecessary renders, but also causes related lifecycle hooks to be triggered again, leading to weird situations.</p>
<h3 id="Managing-local-component-state-with-MobX"><a href="#Managing-local-component-state-with-MobX" class="headerlink" title="Managing local component state with MobX"></a>Managing local component state with MobX</h3><p>(Surprise, surprise) At <a href="http://www.mendix.com" target="_blank" rel="noopener">Mendix</a> we already rely on MobX to manage all our stores. However, we were still using React’s own state mechanism for local component state. Recently, we switched to managing local component state with MobX as well. That looks like this:</p>
<script src="//gist.github.com/67ab0a5ac4ee3df577d394273e71bc33.js"></script>
<p>For completeness sake:</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*LPl8MGfkPyWGtRERQdw_3w.gif" alt="">No unexpected bugs when using a state mechanism that is synchronous</p>
<p>The above code snippet is not only more concise, MobX also addresses all of the setState related issues:</p>
<p>Changes to the state are immediately reflected in the local component state. This makes our logic simpler and code reuse easier. You don’t have to compensate for the fact that the state might not have been updated yet.</p>
<p>MobX determines at runtime which observables are relevant for rendering. So observables that are temporarily irrelevant for the rendering, won’t cause a re-rendering. Until they are relevant again. For this reason, there are also no rendering penalties (or lifecycle issues) when marking fields as <em>@observable</em> that are not relevant for rendering at all.</p>
<p>So renderable and non-renderable state is treated uniformly. In addition, state stored in our components now works the same as state stored in any of our stores. This makes it trivial to refactor components, and move local component state into a separate store or vice versa. Which is demonstrated in this <a href="https://egghead.io/lessons/javascript-mobx-and-react-intro-syncing-the-ui-with-the-app-state-using-observable-and-observer" target="_blank" rel="noopener">egghead</a> tutorial.</p>
<blockquote>
<p>MobX effectively turns your components into small stores</p>
</blockquote>
<p>Furthermore, rookie mistakes like assigning values directly to the <em>state</em> object cannot be made anymore when using observables for state. Oh, and don’t worry about implementing <em>shouldComponentUpdate</em> or <em>PureRenderMixin,</em> MobX already takes care of that as well. Finally, you might be wondering, what if I want to wait until <em>setState</em> has finished? Well, you can still use the _compentDidUpdate l_ifecycle hook for that.</p>
<h4 id="Sounds-cool-How-do-I-get-started-with-MobX"><a href="#Sounds-cool-How-do-I-get-started-with-MobX" class="headerlink" title="Sounds cool! How do I get started with MobX?"></a>Sounds cool! How do I get started with MobX?</h4><p>Pretty simple, follow the <a href="https://mobxjs.github.io/mobx/getting-started.html" target="_blank" rel="noopener">10 minute interactive introduction</a> or watch the aforementioned video. You can simply take a single component from your code base, slap <em>@observer</em> on it and introduce some <em>@observable</em> properties. You don’t even have to replace your existing <em>setState</em> calls, they continue to work while using MobX. Although, within a few minutes you might find them so convoluted that you will replace them anyway :). (Oh, and if you don’t like decorators, no worries, it works with <a href="https://github.com/mobxjs/mobx/blob/gh-pages/docs/best/syntax.md#react-components" target="_blank" rel="noopener">good ol’ ES5 as well</a>).</p>
<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR:"></a>TL;DR:</h4><p>I’ve stopped using React to manage local component state. I use MobX instead. Now React is truly “just the view” :). MobX now manages both local component state and state in stores. It is concise, synchronous, efficient and uniform. From experience, I’ve learned that MobX is even easier to explain to React beginners than React’s own <em>setState.</em> It keeps our components clean and simple.</p>
<ul>
<li><a href="http://jsbin.com/yelazuvamo/edit?js,console,output" target="_blank" rel="noopener">JSBin</a> using <em>setState</em> for state management</li>
<li><a href="http://jsbin.com/sofezamavi/1/edit?js,console,output" target="_blank" rel="noopener">JSBin</a> using <em>MobX observables</em> for state management</li>
</ul>
<span>Source: </span><a href="https://medium.com/@mweststrate/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e" target="_blank" title="https://medium.com/@mweststrate/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e" class="post-from">https://medium.com/@mweststrate/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2017/08/How-to-use-Memoize-to-cache-JavaScript-function-results.html" class="prev">NEXT</a><a href="/2017/08/What-I’ve-Learned-Over-5-Years-as-a-Software-Developer.html" class="next">PREV</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'nthung2112';
var disqus_identifier = '2017/08/3-Reasons-why-I-stopped-using-React-setState.html';
var disqus_title = '3 Reasons why I stopped using React.setState';
var disqus_url = 'http://nth-blogs.herokuapp.com/2017/08/3-Reasons-why-I-stopped-using-React-setState.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//nthung2112.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2018 <a href="http://nth-blogs.herokuapp.com">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>