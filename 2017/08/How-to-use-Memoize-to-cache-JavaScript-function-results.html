<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> How to use Memoize to cache JavaScript function results and speed up your code · Learn and Share</title><meta name="description" content="How to use Memoize to cache JavaScript function results and speed up your code - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="How to use Memoize to cache JavaScript function results and speed up your code"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*UPyVG04cujAGglMNgF1bTA.jpeg"><meta property="og:description" content=""></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">How to use Memoize to cache JavaScript function results and speed up your code</h1><h2 class="post-subtitle"></h2><header class="post-info">Aug 21, 2017<div class="tags"><a href="/tags/javascript" class="tag-link">#javascript</a><a href="/tags/advanced" class="tag-link">#advanced</a></div><div class="fb-ir-time"><time dateTime="2017-08-21T07:58:54.000Z" class="op-modified"></time><time dateTime="2017-08-21T07:58:54.000Z" class="op-published"></time></div></header></div><div class="post-banner"><img src="https://cdn-images-1.medium.com/max/2000/1*UPyVG04cujAGglMNgF1bTA.jpeg"></div><div class="wrap"><div class="post-content"><p>Functions are an integral part of programming. They help add <strong>modularity</strong> and <strong>reusability</strong> to our code.</p>
<p>It’s quite common to divide our program into chunks using functions which we can call later to perform some useful action.</p>
<p>Sometimes, a function can become expensive to call multiple times (say, a function to calculate the <a href="https://en.wikipedia.org/wiki/Factorial" target="_blank" rel="noopener">factorial</a> of a number). But there’s a way we can optimize such functions and make them execute much faster: <strong>caching</strong>.</p>
<p>For example, let’s say we have a <code>function</code> to return the factorial of a number:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Calculations: n * (n-1) * (n-2) * ... (2) * (1)</span></span><br><span class="line">    <span class="keyword">return</span> factorial</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Great, now let’s find <code>factorial(50)</code>. The computer will perform calculations and return us the final answer, sweet!</p>
<p>When that’s done, let’s find <code>factorial(51)</code>. The computer again performs a number of calculations and gets us the result, but you might have noticed that we’re already repeating a number of steps that could have been avoided. An optimized way would be:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">51</span>) = factorial(<span class="number">50</span>) * <span class="number">51</span></span><br></pre></td></tr></table></figure>
<p>But our <code>function</code> performs the calculations from scratch every time it’s called:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">51</span>) = <span class="number">51</span> * <span class="number">50</span> * <span class="number">49</span> * ... * <span class="number">2</span> * <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Wouldn’t it be cool if somehow our <code>factorial</code> function could remember the values from its previous calculations and use them to speed up the execution?</p>
<p>In comes <strong>memoization</strong>, a way for our <code>function</code> to remember (cache) the results. Now that you’ve a basic understanding of what we’re trying to achieve, here’s a formal definition:</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="noopener"><strong>Memoization</strong></a> is an optimization technique used primarily to speed up computer programs by <strong>storing the results of expensive function calls</strong> and returning the cached result when the same inputs occur again</p>
</blockquote>
<p><strong>Memoizing</strong> in simple terms means <strong>memorizing</strong> or storing in memory. A memoized function is usually faster because if the function is called subsequently with the previous value(s), then instead of executing the function, we would be fetching the result from the cache.</p>
<p>Here’s what a simple memoized function might look like <em>(and here’s a</em> <a href="https://codepen.io/divyanshu013/pen/xdQPvp?editors=0011" target="_blank" rel="noopener"><em>CodePen</em></a> <em>in case you want to interact with it)</em>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a simple function to add something</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">n</span>) =&gt;</span> (n + <span class="number">10</span>);</span><br><span class="line">add(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a simple memoized function to add something</span></span><br><span class="line"><span class="keyword">const</span> memoizedAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>);</span><br><span class="line">      <span class="keyword">return</span> cache[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>);</span><br><span class="line">      <span class="keyword">let</span> result = n + <span class="number">10</span>;</span><br><span class="line">      cache[n] = result;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returned function from memoizedAdd</span></span><br><span class="line"><span class="keyword">const</span> newAdd = memoizedAdd();</span><br><span class="line"><span class="built_in">console</span>.log(newAdd(<span class="number">9</span>)); <span class="comment">// calculated</span></span><br><span class="line"><span class="built_in">console</span>.log(newAdd(<span class="number">9</span>)); <span class="comment">// cached</span></span><br></pre></td></tr></table></figure>
<h3 id="Memoization-takeaways"><a href="#Memoization-takeaways" class="headerlink" title="Memoization takeaways"></a>Memoization takeaways</h3><p>Some takeaways from the above code are:</p>
<ul>
<li><code>memoizedAdd</code> returns a <code>function</code> which is invoked later. This is possible because in JavaScript, functions are first class objects which lets us use them as <a href="http://eloquentjavascript.net/05_higher_order.html#h_xxCc98lOBK" target="_blank" rel="noopener">higher order functions</a> and return another function.</li>
<li><code>cache</code> can remember its <em>values</em> since the returned function has a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">closure</a> over it.</li>
<li>It’s essential that the memoized function is <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="noopener">pure</a>. A pure function will return the same output for a particular input no mater how many times it’s called, which makes the <code>cache</code> work as expected.</li>
</ul>
<h3 id="Writing-your-own-memoize-function"><a href="#Writing-your-own-memoize-function" class="headerlink" title="Writing your own memoize function"></a>Writing your own <code>memoize</code> function</h3><p>The previous code works fine but what if we wanted to turn any function into a memoized function?</p>
<p>Here’s how to write your own memoize function (<a href="https://codepen.io/divyanshu013/pen/zwMPdK?editors=0011#code-area" target="_blank" rel="noopener">codepen</a>):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a simple pure function to get a value adding 10</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">n</span>) =&gt;</span> (n + <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Simple call'</span>, add(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// a simple memoize function that takes in a function</span></span><br><span class="line"><span class="comment">// and returns a memoized function</span></span><br><span class="line"><span class="keyword">const</span> memoize = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> n = args[<span class="number">0</span>];  <span class="comment">// just taking one argument here</span></span><br><span class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>);</span><br><span class="line">      <span class="keyword">return</span> cache[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>);</span><br><span class="line">      <span class="keyword">let</span> result = fn(n);</span><br><span class="line">      cache[n] = result;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// creating a memoized function for the 'add' pure function</span></span><br><span class="line"><span class="keyword">const</span> memoizedAdd = memoize(add);</span><br><span class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">3</span>));  <span class="comment">// calculated</span></span><br><span class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">3</span>));  <span class="comment">// cached</span></span><br><span class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">4</span>));  <span class="comment">// calculated</span></span><br><span class="line"><span class="built_in">console</span>.log(memoizedAdd(<span class="number">4</span>));  <span class="comment">// cached</span></span><br></pre></td></tr></table></figure>
<p>Now that’s great! This simple <code>memoize</code> function will wrap any simple <code>function</code> into a memoized equivalent. The code works fine for simple functions and it can be easily tweaked to handle any number of <code>arguments</code> as per your needs. Another alternative is to make use of some de-facto libraries such as:</p>
<ul>
<li><a href="https://lodash.com/docs/4.17.4#memoize" target="_blank" rel="noopener">Lodash</a>’s <code>_.memoize(func, [resolver])</code></li>
<li>ES7 <code>@memoize</code> <a href="https://babeljs.io/docs/plugins/transform-decorators/" target="_blank" rel="noopener">decorators</a> from <a href="https://github.com/developit/decko#memoize" target="_blank" rel="noopener">decko</a></li>
</ul>
<h3 id="Memoizing-recursive-functions"><a href="#Memoizing-recursive-functions" class="headerlink" title="Memoizing recursive functions"></a>Memoizing recursive functions</h3><p>If you try passing in a recursive function to the <code>memoize</code> function above or <code>_.memoize</code> from Lodash, the results won’t be as expected since the recursive function on its subsequent calls will end up calling itself instead of the memoized function thereby making no use of the <code>cache</code>.</p>
<p>Just make sure that your recursive function is calling the memoized function. Here’s how you can tweak a textbook <a href="https://en.wikipedia.org/wiki/Factorial" target="_blank" rel="noopener">factorial</a> example (<a href="https://codepen.io/divyanshu013/pen/JNevOm" target="_blank" rel="noopener">codepen</a>):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// same memoize function from before</span></span><br><span class="line"><span class="keyword">const</span> memoize = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> n = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetching from cache'</span>, n);</span><br><span class="line">      <span class="keyword">return</span> cache[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Calculating result'</span>, n);</span><br><span class="line">      <span class="keyword">let</span> result = fn(n);</span><br><span class="line">      cache[n] = result;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = memoize(</span><br><span class="line">  (x) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x * factorial(x - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// calculated</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">6</span>)); <span class="comment">// calculated for 6 and cached for 5</span></span><br></pre></td></tr></table></figure>
<p>A few points to note from this code:</p>
<ul>
<li>The <code>factorial</code> function is recursively calling a memoized version of itself.</li>
<li>The memoized function is caching the values of previous factorials which significantly improves calculations since they can be reused <code>factorial(6) = 6 * factorial(5)</code></li>
</ul>
<h3 id="Is-memoization-same-as-caching"><a href="#Is-memoization-same-as-caching" class="headerlink" title="Is memoization same as caching?"></a>Is memoization same as caching?</h3><p>Yes, kind of. Memoization is actually a specific type of caching. While caching can refer in general to any storing technique (like <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="noopener">HTTP caching</a>) for future use, memoizing specifically involves <em>caching</em> the return values of a <code>function</code>.</p>
<h3 id="When-to-memoize-your-functions"><a href="#When-to-memoize-your-functions" class="headerlink" title="When to memoize your functions"></a>When to memoize your functions</h3><p>Although it might look like memoization can be used with all functions, it actually has limited use cases:</p>
<ul>
<li>In order to memoize a function, it should be pure so that return values are the same for same inputs every time</li>
<li>Memoizing is a trade-off between added space and added speed and thus only significant for functions having a limited input range so that cached values can be made use of more frequently</li>
<li>It might look like you should memoize your API calls however it isn’t necessary because the browser automatically caches them for you. See <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="noopener">HTTP caching</a> for more detail</li>
<li>The best use case I found for memoized functions is <strong>for heavy computational functions</strong> which can significantly improve performance (factorial and fibonacci are not really good real world examples)</li>
<li>If you’re into React/Redux you can check out <a href="https://github.com/reactjs/reselect#creating-a-memoized-selector" target="_blank" rel="noopener">reselect</a> which uses a <em>memoized selector</em> to ensure that calculations only happen when a change happens in a related part of the state tree.</li>
</ul>
<h4 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h4><p>The following links can be useful if you would like to know more about some of the topics from this article in more detail:</p>
<ul>
<li><a href="http://eloquentjavascript.net/05_higher_order.html#h_xxCc98lOBK" target="_blank" rel="noopener">Higher order functions</a> in JavaScript</li>
<li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">Closures</a> in JavaScript</li>
<li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="noopener">Pure functions</a></li>
<li>Lodash’s <code>_.memoize</code> <a href="https://lodash.com/docs/4.17.4#memoize" target="_blank" rel="noopener">docs</a> and <a href="https://github.com/lodash/lodash/blob/4.17.4/lodash.js#L10554-L10572" target="_blank" rel="noopener">source code</a></li>
<li>More memoization examples <a href="https://www.sitepoint.com/implementing-memoization-in-javascript/" target="_blank" rel="noopener">here</a> and <a href="http://inlehmansterms.net/2015/03/01/javascript-memoization/" target="_blank" rel="noopener">here</a></li>
<li><a href="https://github.com/reactjs/reselect" target="_blank" rel="noopener">reactjs/reselect</a></li>
</ul>
<p>I hope this article was useful for you, and you’ve gained a better understanding of memoization in JavaScript.</p>
<span>Source: </span><a href="https://medium.freecodecamp.org/understanding-memoize-in-javascript-51d07d19430e" target="_blank" title="https://medium.freecodecamp.org/understanding-memoize-in-javascript-51d07d19430e" class="post-from">https://medium.freecodecamp.org/understanding-memoize-in-javascript-51d07d19430e</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2017/08/Use-const-Until-You-Have-to-Use-let.html" class="prev">NEXT</a><a href="/2017/08/3-Reasons-why-I-stopped-using-React-setState.html" class="next">PREV</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'nthung2112';
var disqus_identifier = '2017/08/How-to-use-Memoize-to-cache-JavaScript-function-results.html';
var disqus_title = 'How to use Memoize to cache JavaScript function results and speed up your code';
var disqus_url = 'http://nth-blogs.herokuapp.com/2017/08/How-to-use-Memoize-to-cache-JavaScript-function-results.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//nthung2112.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2018 <a href="http://nth-blogs.herokuapp.com">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>