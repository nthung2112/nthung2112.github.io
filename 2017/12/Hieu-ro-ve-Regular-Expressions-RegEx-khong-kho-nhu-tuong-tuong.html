<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Hi·ªÉu r√µ v·ªÅ Regular Expressions: RegEx kh√¥ng kh√≥ nh∆∞ t∆∞·ªüng t∆∞·ª£ng ¬∑ Learn and Share</title><meta name="description" content="Hi·ªÉu r√µ v·ªÅ Regular Expressions: RegEx kh√¥ng kh√≥ nh∆∞ t∆∞·ªüng t∆∞·ª£ng - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Hi·ªÉu r√µ v·ªÅ Regular Expressions: RegEx kh√¥ng kh√≥ nh∆∞ t∆∞·ªüng t∆∞·ª£ng"><meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/0*kKGQn6RZmO--M8ix.jpg"><meta property="og:description" content="Are you one of those people who stays away from regular expressions because it looks like a foreign language? I was one. Not anymore.
Think of all those sounds, traffic signs and smells that you can recognize. Regular expressions are no different. It‚Äôs like a sign language to analyze strings.
We are going to get our head around regular expressions today. At least, regularly used expressions.
Much like any programming language, a regular expression is a succinct language in its own right.
We will know how to put regular expressions to good use by the end of this article. We will solve simple problems and learn loads in the process.
Are you willing to invest 30 minutes and come out enlightened in RegEx? Settle down then."></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Hi·ªÉu r√µ v·ªÅ Regular Expressions: RegEx kh√¥ng kh√≥ nh∆∞ t∆∞·ªüng t∆∞·ª£ng</h1><h2 class="post-subtitle"></h2><header class="post-info">Dec 15, 2017<div class="tags"><a href="/tags/regex" class="tag-link">#regex</a></div><div class="fb-ir-time"><time datetime="2017-12-15T15:23:22.000Z" class="op-modified"></time><time datetime="2017-12-15T15:23:22.000Z" class="op-published"></time></div></header></div><div class="post-banner"><img src="https://cdn-images-1.medium.com/max/1600/0*kKGQn6RZmO--M8ix.jpg"></div><div class="wrap"><div class="post-content"><p>Are you one of those people who stays away from regular expressions because it looks like a foreign language? I was one. Not anymore.</p>
<p>Think of all those sounds, traffic signs and smells that you can recognize. Regular expressions are no different. It‚Äôs like a sign language to analyze strings.</p>
<p>We are going to get our head around regular expressions today. At least, <strong>regularly</strong> used expressions.</p>
<p>Much like any programming language, a regular expression is a succinct language in its own right.</p>
<p>We will know how to put regular expressions to good use by the end of this article. We will solve simple problems and learn loads in the process.</p>
<p>Are you willing to invest 30 minutes and come out enlightened in RegEx? Settle down then.<br><a id="more"></a></p>
<h4 id="Why-regular-expressions"><a href="#Why-regular-expressions" class="headerlink" title="Why regular expressions?"></a>Why regular expressions?</h4><p>We each have our own ‚Äòwhy‚Äô, don‚Äôt we? One may be to test if the string is a valid hex color code. You may be writing a processor library such as <a href="https://github.com/search?l=&amp;q=regexp+repo%3Asass%2Fsass&amp;ref=advsearch&amp;type=Code&amp;utf8=%E2%9C%93" target="_blank" rel="noopener">Sass</a> that leverages RegEx.</p>
<p>I‚Äôll let the universe throw the <strong>why</strong> at you and help you cover the <strong>how</strong>.</p>
<h3 id="0-Get-Your-Playground-Ready"><a href="#0-Get-Your-Playground-Ready" class="headerlink" title="0. Get Your Playground Ready"></a>0. Get Your Playground Ready</h3><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><p>Most of the time, I find this page adequate to get going: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">Regular Expressions from MDN</a>. In fact, that page is all you need. You can stop reading this post. Right now. Close this tab. üòâ</p>
<p>Still with me? Thanks. You need a sandbox to play around in. Luckily, one is available on your browser. Just use the DevTools in your browser‚Äôs console.</p>
<h4 id="Familiarize-yourself-with-the-syntax"><a href="#Familiarize-yourself-with-the-syntax" class="headerlink" title="Familiarize yourself with the syntax"></a>Familiarize yourself with the syntax</h4><p>To start with, we are going to use the /expression/.test(‚Äòstring‚Äô) syntax.</p>
<p>An expression is any regular expression that we build. A string is the string under test. The test method returns true or false depending on the match.</p>
<p>Slashes mark the start and end of the expression. Treat them like the double quotes (‚Äú) and single quotes (‚Äò) that you use to the mark start and end of a plain string.</p>
<p>The expression between / is a literal. <strong>They are treated as literal characters.</strong> Variable names wouldn‚Äôt be resolved down to their contents.</p>
<p>To make it dynamic, we‚Äôll have to go via the constructor route, using new RegEx(variable_name) syntax. This will come to rescue towards the end of the post.</p>
<p><strong>Do it right now.</strong> Just type this into your browser console.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/a/.test(<span class="string">"a"</span>); <span class="comment">//true</span></span><br><span class="line">/a/.test(<span class="string">"b"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>If that works, you are ready. Don‚Äôt worry about what it is. That‚Äôs what we are going to breakdown into pieces in the following lines.</p>
<p>Let‚Äôs dive in‚Ä¶</p>
<h3 id="1-Start-Small-With-Letters"><a href="#1-Start-Small-With-Letters" class="headerlink" title="1. Start Small With Letters"></a>1. Start Small With Letters</h3><p>Let‚Äôs start small. We need to find if a string has a particular character. Look for the character a in a string.</p>
<p>Here is the expression in all its glory:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/a/.test(<span class="string">"abc"</span>); <span class="comment">//true </span></span><br><span class="line">/a/.test(<span class="string">"bcd"</span>); <span class="comment">//false </span></span><br><span class="line">/a/.test(<span class="string">"cba"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>The expression does what we asked for, ‚ÄúLook for a in the string under test‚Äù. In our case, abc and bca do have the character a. But bcd does not have it.</p>
<h4 id="Breakdown"><a href="#Breakdown" class="headerlink" title="Breakdown"></a>Breakdown</h4><p>Now, that‚Äôs a lot of slashes and backslashes. Let‚Äôs break them down.</p>
<p>We‚Äôve seen that /expression/ is how we build regular expressions. So no question about slash there. In fact, we can even <strong>assign it to a variable</strong> and make it look better.</p>
<p><strong>The same code:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e=<span class="regexp">/a/</span>; </span><br><span class="line">e.test(<span class="string">"abc"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"bcd"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"cba"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>The expression between slashes is just a single character a in our case. We are looking only for that one character.</p>
<h4 id="Reach-Multi-Characters"><a href="#Reach-Multi-Characters" class="headerlink" title="Reach Multi-Characters"></a>Reach Multi-Characters</h4><p>Let‚Äôs scale the solution.</p>
<p>What if you want to find more than one character?</p>
<p>Put them in sequence. Treat them as a substring.</p>
<p>Here is an example:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ab/.test(<span class="string">"abacus"</span>); <span class="comment">//true </span></span><br><span class="line">/bac/.test(<span class="string">"abacus"</span>); <span class="comment">//true  </span></span><br><span class="line">/abc/.test(<span class="string">"abacus"</span>); <span class="comment">//false </span></span><br><span class="line">/abas/.test(<span class="string">"abacus"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>The string under test should contain the exact expression within slashes. We get a match if that condition is met.</p>
<p>bac is within abacusbut abas is not in abacus as it is. Even though we have those characters scrambled, we do not get an exact match.</p>
<h4 id="Review-Ground-Covered"><a href="#Review-Ground-Covered" class="headerlink" title="Review Ground Covered"></a>Review Ground Covered</h4><p>Symbol /‚Ä¶/ . Slash (/) marks the start and end of the regular expression. Ignore the dots, that‚Äôs where we place the pattern. The /a/ character between slashes is a pattern matched on string under test. The /abc/ characters between slashes are looked up as a sub-string during the pattern matching test on string under test.</p>
<h3 id="2-Patterns-in-Numbers"><a href="#2-Patterns-in-Numbers" class="headerlink" title="2. Patterns in Numbers"></a>2. Patterns in Numbers</h3><p>Let‚Äôs spice it up a bit. Let‚Äôs say you want to find out if a string is full of numeric characters.</p>
<p>Here it is:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e=<span class="regexp">/0|1|2|3|4|5|6|7|8|9/</span>;</span><br><span class="line">e.test(<span class="string">"42"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"The answer is 42"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>First of all, the pattern looks pretty long. But the same long streak of characters <strong>can be expressed in just two characters</strong>. I reserved it towards end of this section for a dramatic closure.</p>
<p>The second case shouldn‚Äôt be true. We‚Äôll deal with it a bit later.</p>
<p>For now, the pipe symbol (|) means <strong>or</strong>. Outside of regular expressions, we‚Äôve used it as a bitwise <strong>or</strong> and conditional <strong>or</strong> with double pipes (||). That‚Äôs the same guy.</p>
<p>I could call that easy and call it a day. But you would scream for something better, right? We are developers. We spend the best part of our day thinking about better Bash and Git aliases to save few keystrokes.</p>
<p>Should I type in nine pipe symbols? Nah.</p>
<p>Here we go again:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e=<span class="regexp">/[0123456789]/</span>; </span><br><span class="line">e.test(<span class="string">"42"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"The answer is 42"</span>); <span class="comment">//still true</span></span><br></pre></td></tr></table></figure>
<p>This is better. 9 pipes were replaced with 2 square brackets. 7 characters were saved. That‚Äôs 77.7% less keystrokes.</p>
<p>By the way, anything within square brackets is considered as Either this or that. It is a character set. In our case, the string should contain either 0, or 1, or 2, or‚Ä¶bear with me, I promised myself to write 1000 words a day, or 3 or 4 or 5. All right, let‚Äôs stop. You get it.</p>
<p>What are you saying? It still looks quite lengthy? Not satisfied?</p>
<p>Okay, here we go once again:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e=<span class="regexp">/[0-9]/</span>; </span><br><span class="line">e.test(<span class="number">42</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"42"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"The answer is 42"</span>); <span class="comment">//true!</span></span><br></pre></td></tr></table></figure>
<p>How about that? Looks much cleaner, doesn‚Äôt it? Anything within square brackets [] means <strong>or</strong>. 0-9 marks a range, meaning zero to nine.</p>
<p>So the test looks for characters from zero to nine in the test string.</p>
<p>As you can see, the test takes numbers too.</p>
<h4 id="The-prefix-and-suffix-patterns"><a href="#The-prefix-and-suffix-patterns" class="headerlink" title="The prefix and suffix patterns"></a>The prefix and suffix patterns</h4><p>Let‚Äôs now address that failing second case. The answer is 42 matches our test because our pattern looks for numeric characters somewhere <strong>within</strong> the string. <strong>Not start to end</strong>.</p>
<p>Let‚Äôs bring in ^ and $ to help us.</p>
<ul>
<li>^ means the <strong>start</strong> of the string. He is a double agent and he‚Äôll trip us off. His second avatar is unmasked only in the last section.</li>
<li>$ means the <strong>end</strong> of the string.</li>
</ul>
<p>Let‚Äôs get the prefix pattern sorted out:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/^a/.test(<span class="string">"abc"</span>); <span class="comment">//true </span></span><br><span class="line">/^a/.test(<span class="string">"bca"</span>); <span class="comment">//false </span></span><br><span class="line">/^http/.test(<span class="string">"https://pineboat.in"</span>); <span class="comment">//true /^http/.test("ftp://pineboat.in"); //false</span></span><br></pre></td></tr></table></figure>
<p>Any pattern that follows ^ should be at the start of the string under test.</p>
<p>The second string starts with b while our pattern looks for a. The fourth one looks for http while the string starts with ftp. This is the reason they fail.</p>
<h4 id="The-suffix-patterns"><a href="#The-suffix-patterns" class="headerlink" title="The suffix patterns"></a>The suffix patterns</h4><p>The suffix pattern follows. $ at the end of the pattern directs the test to look for end of string.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/js$/.test(<span class="string">"regex.js"</span>); <span class="comment">//true </span></span><br><span class="line">/js$/.test(<span class="string">"regex.sj"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>That should sound in your head like, ‚ÄúLook for js and then the end of the string‚Äù. Better yet, ‚ÄúLook for a string that ends in js‚Äù.</p>
<h4 id="Pattern-match-End-to-End"><a href="#Pattern-match-End-to-End" class="headerlink" title="Pattern match End to End"></a>Pattern match End to End</h4><p>That paves the road to pattern match start to end, you might as well call it end to end.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e=<span class="regexp">/^[0-9]$/</span> </span><br><span class="line">e.test(<span class="string">"42"</span>); <span class="comment">//false - NO! </span></span><br><span class="line">e.test(<span class="string">"The answer is 42"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"7"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Surprisingly, the first one failed when we added ^ and $.</p>
<p><code>/^[0-9]$/</code> reads like, ‚ÄúGo to the start of the string. Look for a <strong>single numeral</strong> from the character set. Check if the string ends right there.‚Äù That‚Äôs the reason the last entry returned true. It is just a single number, start to end.</p>
<p>That‚Äôs not what we wanted. We wanted to test if the string had one or more numerals.</p>
<p>We are very close. One last thing we need to learn is how to instruct the pattern to look for more than one character in the set.</p>
<h4 id="Tale-of-Three-Musketeers"><a href="#Tale-of-Three-Musketeers" class="headerlink" title="Tale of Three Musketeers"></a>Tale of Three Musketeers</h4><p>A question mark (?), a plus (+) and an asterisk (*) met at a battle ground. Each is differently sighted.</p>
<p>The humble question mark (?)says, ‚ÄúI can see none or just one.‚Äù</p>
<p>Plus (+) says, ‚ÄúI need to see at least one or more.‚Äù</p>
<p>Asterisk (*) says, ‚ÄúI get you both. I can see none, one, or more.‚Äù</p>
<p><strong>One of them is cleverly hiding what he is capable of.</strong></p>
<p>The question mark gets on stage first:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/a?<span class="regexp">/.test(""); /</span><span class="regexp">/true </span></span><br><span class="line"><span class="regexp">/</span>a?<span class="regexp">/.test("a"); /</span><span class="regexp">/true </span></span><br><span class="line"><span class="regexp">/</span>a?<span class="regexp">/.test("b"); /</span><span class="regexp">/true! </span></span><br><span class="line"><span class="regexp">/</span>a?<span class="regexp">/.test("aa"); /</span><span class="regexp">/true </span></span><br><span class="line"><span class="regexp">/</span>^a?$/.test(<span class="string">"aa"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Matches empty string ‚Äú‚Äù<br>as ? stands for 0 or 1</li>
<li>Matches a<br>one match</li>
<li>Matches b matches 0 occurrence</li>
<li>Matches aa<br>one match and the second a is not part of the pattern</li>
<li><code>/^a?$/</code> does not match aa It looks for zero or one a, start to end, nothing more, nothing less</li>
</ul>
<p>The plus (+) looks at question mark and remarks, ‚ÄúI‚Äôm impressed, but your focus is so binary!‚Äù. And takes the stage to show off:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/a+<span class="regexp">/.test("a"); /</span><span class="regexp">/true </span></span><br><span class="line"><span class="regexp">/</span>a+<span class="regexp">/.test("aa"); /</span><span class="regexp">/true </span></span><br><span class="line"><span class="regexp">/</span>a+<span class="regexp">/.test("ba"); /</span><span class="regexp">/true! </span></span><br><span class="line"><span class="regexp">/</span>^a+$/.test(<span class="string">"aa"</span>); <span class="comment">//true  </span></span><br><span class="line">/a+<span class="regexp">/.test(""); /</span><span class="regexp">/false </span></span><br><span class="line"><span class="regexp">/</span>a+<span class="regexp">/.test("b"); /</span><span class="regexp">/false </span></span><br><span class="line"><span class="regexp">/</span>^a+$/.test(<span class="string">"ab"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>Remember what plus (+) said? It can match one or more occurrences of preceding pattern.</p>
<p>All those returning true have one or more a. We even managed to get a whole string comprised only of a in the last one that returned true with <code>/^a+$/</code>.</p>
<p>false should make sense now, but a word on the last one that returned false. <code>/^a+$/</code> looks for a start to end, no other characters allowed. This is why ab failed the test.</p>
<p>Finally, star (*) of the show gets on stage. He boasts that, ‚ÄúI can duel alone or duel you both at once‚Äù and says, ‚ÄúI can match zero, one or more‚Äù.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/a*<span class="regexp">/.test("a"); /</span><span class="regexp">/true </span></span><br><span class="line"><span class="regexp">/</span>a*<span class="regexp">/.test("aa"); /</span><span class="regexp">/true </span></span><br><span class="line"><span class="regexp">/</span>a*<span class="regexp">/.test("ba"); /</span><span class="regexp">/true </span></span><br><span class="line"><span class="regexp">/</span>a*<span class="regexp">/.test(""); /</span><span class="regexp">/true </span></span><br><span class="line"><span class="regexp">/</span>a*<span class="regexp">/.test("b"); /</span><span class="regexp">/true </span></span><br><span class="line"><span class="regexp">/</span>^a*$/.test(<span class="string">"aa"</span>); <span class="comment">//true </span></span><br><span class="line">/^a*$/.test(<span class="string">""</span>); <span class="comment">//true  </span></span><br><span class="line">/^a*$/.test(<span class="string">"ab"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>Except the last one, <em> was able to handle all else. /^a</em>$/ reads like, 0 or more a start to end. Which is why empty string ‚Äú‚Äù passed the test and ‚Äúab‚Äù failed.</p>
<h4 id="Back-to-the-Universal-Answer"><a href="#Back-to-the-Universal-Answer" class="headerlink" title="Back to the Universal Answer"></a>Back to the Universal Answer</h4><p>Remember where were we before we met the three musketeers? Yes, ‚ÄúThe answer is 42‚Äù.</p>
<p>Now if we need to look for only numerals, one or more, start to end, what do we do?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Let's throw in a plus </span></span><br><span class="line"><span class="keyword">let</span> e=<span class="regexp">/^[0-9]+$/</span> </span><br><span class="line">e.test(<span class="string">"4"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"42"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"The answer 42"</span>); <span class="comment">//false - Hurray</span></span><br></pre></td></tr></table></figure>
<p>The plus sign (+) in [0-9]+ comes to our rescue. Plus means more than one occurrence of the character or pattern in front of it. In our case, more than one numerals.</p>
<p>It also fails the match for our last case The answer is 42 because, there are no numerals at the start of the string.</p>
<h4 id="Practice-Patterns"><a href="#Practice-Patterns" class="headerlink" title="Practice Patterns"></a>Practice Patterns</h4><ul>
<li>Can you try to write a pattern for hexadecimal numbers (consisting of numerals 0‚Äì9 and letters a-f, with an optional # in front)?</li>
<li>How about a binary number? Can you test if a string is full of just 0 and 1?</li>
</ul>
<h4 id="That-Dramatic-End"><a href="#That-Dramatic-End" class="headerlink" title="That Dramatic End"></a>That Dramatic End</h4><p>Oh, I almost forgot. [0-9] stands for any of the numeric character set and also has a shorthand version \d.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e=<span class="regexp">/^\d+$/</span>; e.test(<span class="string">"4"</span>); <span class="comment">//true e.test("42"); //true e.test("The answer 42"); //false - Hurray</span></span><br></pre></td></tr></table></figure>
<p>Just two characters denoting numerals. And No, it doesn‚Äôt get any shorter than that.</p>
<p>There are a whole bunch of such special patterns to specify clusters such as numbers (\d), alpha numeric characters (\w), white spaces (\s).</p>
<h4 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h4><ul>
<li>[123] The expression within square brackets are a character set<br>Any one of the characters match will pass the test. Just ONE character.</li>
<li>[0-9]<br>Looks for a single numeric digit between 0 to 9</li>
<li>[0-5]<br>Looks for a single numeric digit between 0 to 5</li>
<li>[a-z]<br>Looks for a single letter between a to z</li>
<li>[A-F]<br>Looks for a single letter between A to F</li>
<li>[123]+<br>Plus (+) looks for one or more occurrence of the characters within the set This one matches a ‚Äú23132‚Äù sub-string that consists of 1, 2 and 3 within a larger string ‚Äúabc23132‚Äù.</li>
<li>| Pipe symbol stands for <strong>or</strong></li>
<li>\d<br>A shorthand for numerals<br>Matches a single numeric digit.</li>
<li>\D<br>A shorthand for non-numeric characters<br>Anything other than numerals that‚Äôll be matched by \d</li>
</ul>
<h3 id="3-Recurrence-Match-to-Find-Duplicates"><a href="#3-Recurrence-Match-to-Find-Duplicates" class="headerlink" title="3. Recurrence Match to Find Duplicates"></a>3. Recurrence Match to Find Duplicates</h3><p>This is the actual problem I was trying to solve. I dove deep into regular expressions, which eventually led to this post.</p>
<p>You‚Äôve been given a string. Find out if it has been infused with duplicate characters before sunset.</p>
<p>Here is the solution for duplicate characters appearing immediately after an occurrence:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e=<span class="regexp">/(\w)\1/</span>; </span><br><span class="line">e.test(<span class="string">"abc"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"abb"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>The expression does not match any part of the string abc as there are no duplicate characters in sequence. So it returns false.</p>
<p>But it matches bb part of the string abb and returns true.</p>
<p>Go ahead, type that on your DevTool console. Look at this!</p>
<p>Let‚Äôs break it down to understandable pieces.</p>
<h4 id="Backslash-Unleashed"><a href="#Backslash-Unleashed" class="headerlink" title="Backslash \ Unleashed"></a>Backslash <code>\</code> Unleashed</h4><p>I‚Äôve been a little quiet about the backslash that was introduced in the last section. To those who have <strong>been there</strong> and <strong>done that</strong>, it may not have been a surprise. They might have <strong>escaped</strong> the confusion. But if you are new to programming world, you need to know more about backslash.</p>
<p>In the regular expression language, backslash is special. The backslash alters the meaning of the characters that follow them. Ring a bell?</p>
<p>What do you call \n when you encounter it in a string? Yes, a new line. We‚Äôve got something similar here.</p>
<p>In fact, <code>\n</code> is what you use as a pattern if you want to look for a new line. That‚Äôs called escaping the usual meaning of n and giving it a whole new attire called new line.</p>
<ul>
<li><code>\d</code> A shorthand for numerals<br>Matches a single numeric digit</li>
<li><code>\D</code> A shorthand for non-numeric characters<br>Anything other than numerals that‚Äôll be matched by \d</li>
<li><code>\s</code><br>Shorthand for single white space character such as space, new line or tab.</li>
<li><code>\S</code> Antonym of <code>\s</code><br>anything other than white space</li>
<li><code>\w</code><br>Shorthand for alpha-numeric character<br>Matches a-z, A-Z, 0‚Äì9 and underscore _.</li>
<li><code>\W</code><br>Antonym of \w</li>
</ul>
<h4 id="Recallable-Matches"><a href="#Recallable-Matches" class="headerlink" title="Recallable Matches"></a>Recallable Matches</h4><p>We started this section with the solution for finding duplicate characters. /(\w)\1/ matched ‚Äúabb‚Äù. That shows use of memory and recall within regular expressions.</p>
<p>Consider the use of brackets in this format (expression). The resulting string that matches the expression within a bracket is remembered for later use.</p>
<p>\1 remembers and uses the match from first expression that is within brackets. Likewise, \2 from second set of brackets. And so on.</p>
<p>Let‚Äôs translate our expression (\w)\1 to plain English:</p>
<p>Match any alpha-numeric character on a given string. Remember it as \1. Check if that character appears right next to the first occurrence.</p>
<h4 id="Extension-1-‚Äî-Reverse-Pairs"><a href="#Extension-1-‚Äî-Reverse-Pairs" class="headerlink" title="Extension 1‚Ää‚Äî‚ÄäReverse Pairs"></a>Extension 1‚Ää‚Äî‚ÄäReverse Pairs</h4><p>Let‚Äôs say we want to find two characters appearing in reverse order right next to each other. That is like abba. ab is reversed as ba and is right next to each other.</p>
<p>Here is the expression:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e=<span class="regexp">/(\w)(\w)\2\1/</span>; </span><br><span class="line">e.test(<span class="string">"aabb"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"abba"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"abab"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>The first (\w) matches a and remembers it as \1. The second (\w) matches b and remembers it as \2. Then the expression expects \2 to occur first followed by \1. Hence, abba is the only string that matches the expression.</p>
<h4 id="Extension-2-‚Äî-No-duplicates"><a href="#Extension-2-‚Äî-No-duplicates" class="headerlink" title="Extension 2‚Ää‚Äî‚ÄäNo duplicates"></a>Extension 2‚Ää‚Äî‚ÄäNo duplicates</h4><p>This time, we are going to look at sequence of characters with no duplicates. No character should be followed by the same character. Plain and simple.</p>
<p>Here, take a look at the solution:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e=<span class="regexp">/^(\w)(?!\1)$/</span>; </span><br><span class="line">e.test(<span class="string">"a"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"ab"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"aa"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>Not the one we wanted, but close. The middle one shouldn‚Äôt be false. But we threw in a few more symbols that need explaining. That means confronting the most powerful musketeer once again.</p>
<h4 id="Return-of-the-Question-Mark"><a href="#Return-of-the-Question-Mark" class="headerlink" title="Return of the Question Mark"></a>Return of the Question Mark</h4><p>Remember the three musketeers we met earlier. The humble <strong>question mark is actually the most powerful manipulator</strong> that can get other symbols to do his bidding. That is, if you take the backslash for granted.</p>
<p>A combination of brackets, question mark and exclamation mark (?!), is called a <strong>look ahead</strong>. A negative look ahead to be precise. a(?!b) matches a only if it is <strong>not</strong> followed by b.</p>
<p>Across JavaScript ecosystem, the exclamation mark means <strong>not</strong>. But its cousin CSS takes a u-turn and !important means it is actually very important and should not be overridden. I almost scrolled past <a href="https://twitter.com/vijayabharathib/status/910772769964548096" target="_blank" rel="noopener">Chen‚Äôs tweet</a> thinking it is marked not important. I digress.</p>
<p>On the other hand, (?=) is a positive <strong>look ahead</strong>. a(?=b) matches a only if it is followed by b.</p>
<p>We had a solution. (\w)(?!\1) looks for a character without recurrence. <strong>But only for one character.</strong> We need to group it and look for 1 or more occurrences of characters with the use of plus (+). That‚Äôs all.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e=<span class="regexp">/^((\w)(?!\1))+$/</span>; </span><br><span class="line">e.test(<span class="string">"madam"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"maam"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>But it doesn‚Äôt seem to be working. If we group the pattern within plain brackets like ((\w)(?!\1)), the \1 does not represent(\w), it represents higher level bracket pair that groups the pattern. So it fails.</p>
<p>What we need is a <strong>forgetful</strong> grouping option. That‚Äôs where the question mark, ?, strikes back. It pairs with a colon, (?:) and wipes out any function of memory that the brackets can bring in.</p>
<p>One last time:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e=<span class="regexp">/^(?:(\w)(?!\1))+$/</span>; </span><br><span class="line">e.test(<span class="string">"madam"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"maam"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>This time, the first level of brackets are not remembered, thanks to ?:, hence, \1 remembers the match returned by \w.</p>
<p>It helps us use the plus + against the overall grouping to find similar pairs of characters start to end, which works like magic.</p>
<p>In English, ‚ÄúLook for a character. Look ahead to ensure it is not followed by the same character. Do this from start to end for all characters.‚Äù</p>
<h4 id="Review-1"><a href="#Review-1" class="headerlink" title="Review"></a>Review</h4><ul>
<li>\w represents all the alpha-numeric characters<br>If you capitalize ‚Äòw‚Äô and use \W‚Äô, that would mean all characters <strong>other than</strong> alpha-numeric</li>
<li>( )<br>The expression within a bracket is remembered for later use</li>
<li>\1 remembers and uses the match from first expression that is within brackets<br> \2 from second set of brackets. And so on.</li>
<li>a(?!b)<br>A combination of brackets, question mark and exclamation mark (?!), is called a <strong>look ahead</strong> This matches a only if it is <strong>not</strong> followed by b</li>
<li>a(?=b) The other side of the coin<br>Match a only if it is followed by b. (?:a)<br><strong>Forgetful grouping</strong> Look for a but don‚Äôt remember it<br>You can‚Äôt use \1 pattern to reuse this match</li>
</ul>
<h3 id="4-Alternating-Sequence"><a href="#4-Alternating-Sequence" class="headerlink" title="4. Alternating Sequence"></a>4. Alternating Sequence</h3><p>The usecase is simple. Match a string that uses only two characters. Those two characters should alternate throughout the length of the string. Two sample tests for ‚Äúabab‚Äù and ‚Äúxyxyx‚Äù will do.</p>
<p>It wasn‚Äôt easy. I got it wrong on several attempts. This <a href="https://stackoverflow.com/questions/45504400/regex-match-pattern-of-alternating-characters" target="_blank" rel="noopener">answer</a> directed me down the right street.</p>
<p>Here is the solution:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e=<span class="regexp">/^(\S)(?!\1)(\S)(\1\2)*$/</span>; </span><br><span class="line">e.test(<span class="string">"abab"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"$#$#"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"#$%"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"$ $ "</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"xyxyx"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>This is where you say, ‚ÄúI‚Äôve had enough!‚Äù and throw in the towel.</p>
<p>But wait for the Aha moment! You are 3 feet away from the gold ore, not the right time to stop digging.</p>
<p>Let‚Äôs first make sense out of results before we arrive at ‚Äò<strong>how?</strong>‚Äô abab matches. $#$# matches, this is no different from abab.</p>
<p>#$% fails as there is a third character. $ $ fails though they are pairs, because space is excluded in our pattern.</p>
<p>All is well except, xyxyx fails, because our pattern doesn‚Äôt know how to handle that last x. We‚Äôll get there.</p>
<p>Let‚Äôs take a look at the tools added to our belt. It‚Äôll start to make sense soon.</p>
<h4 id="One-piece-at-a-time"><a href="#One-piece-at-a-time" class="headerlink" title="One piece at a time"></a>One piece at a time</h4><p>You already know most of the pieces. <code>\S</code> is the opposite of <code>\s</code>. <code>\S</code> looks for non white space characters.</p>
<p>Now comes the plain English version of <code>/^(\S)(?!\1)(\S)(\1\2)*$/</code>.</p>
<ul>
<li>Start from the start /^</li>
<li>Look for a non-white space character (<code>\S</code>)</li>
<li>Remember it as \1</li>
<li>Look ahead and see if the first character is not followed by the same character (?!\1).<br>Remember this is a <strong>negative look ahead</strong>.</li>
<li>If we are good so far, look for another character (<code>\S</code>)</li>
<li>Remember it as \2</li>
<li>Then look for <strong>0 or more pairs of first two matches</strong> (<code>\1\2</code>)*</li>
<li>Look for such pattern until end of the string $/</li>
</ul>
<p>Apply that to our test cases. ‚Äúabab‚Äù and ‚Äú$#$#‚Äù match.</p>
<h4 id="Tail-End"><a href="#Tail-End" class="headerlink" title="Tail End"></a>Tail End</h4><p>After looking at the solution you may think this does not demand a separate section. But the simplicity of it is elegant. Let‚Äôs fix that one failing case xyxyx. As we‚Äôve seen, the last trailing x is the problem. We have a solution for xyxy. All we need is a pattern to say ‚ÄúLook for an optional occurrence of first character‚Äù.</p>
<p>As usual, let‚Äôs start with the solution.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e=<span class="regexp">/^(\S)(?!\1)(\S)(\1\2)*\1?$/</span>; e.test(<span class="string">"xyxyx"</span>); <span class="comment">//true e.test("$#$#$"); //true</span></span><br></pre></td></tr></table></figure>
<p>The question mark strikes again. There is no escaping him. It‚Äôs better we make him our ally than our enemy. A question mark ? after a character or pattern means 0 or 1 match for the preceding pattern. It is non-greedy in gobbling up characters.</p>
<p>In our case, <code>\1?</code> means, 0 or 1 match of the first character remembered through first set of brackets.</p>
<p>Easy. Relax.</p>
<h4 id="Review-2"><a href="#Review-2" class="headerlink" title="Review"></a>Review</h4><ul>
<li><code>\S</code><br>Represents all characters excluding white space such as a space and new lines<br>Note that it is capital S</li>
<li><code>a*</code><br>The asterisk or star, looks for 0 or more occurrences of the preceding character. In this case, it is 0 or more a<br>Remember plus (+) which looks for 1 or more? Yeah, these guys are cousins.</li>
<li><code>a(?!b)</code><br>This combination of brackets, question mark and exclamation mark (?!) is called a <strong>look ahead</strong>.<br>This matches a only if it is not followed by b.<br>For example, it matches a in aa, ax, a$ but does not match ab Though it uses bracket, it does not remember the matching character after a.</li>
<li><code>\s</code><br>Small caps s matches a single white space character such as a space or new line.</li>
<li><code>a(?=b)</code><br>This matches a that is followed by b.</li>
<li><code>^ab*$</code><br>You may think this translates to 0 or more occurrences of ab, but it matches a followed by 0 or more b For example: This matches abbb, aand ab, but does not match abab</li>
<li><code>^(ab)*$</code><br>This matches 0 or more pairs of ab That means it will match empty string ‚Äú‚Äù, aband abab, but not abb</li>
<li><code>a?</code><br><code>?</code> matches 0 or 1 occurrence of preceding character or pattern<br><code>\1?</code> matches 0 or 1 recurrence of first remembered match</li>
</ul>
<h3 id="5-Match-an-email-address"><a href="#5-Match-an-email-address" class="headerlink" title="5. Match an email address"></a>5. Match an email address</h3><h4 id="Warning-for-Production"><a href="#Warning-for-Production" class="headerlink" title="Warning for Production"></a>Warning for Production</h4><p>Regular expressions alone may not help validate emails. Some would even argue that regular expressions should not be used as it can never match 100% of the emails.</p>
<p>Think about all the fancy domain names popping up. Also consider inclusion of symbols within email addresses, such as dot (.) and plus (+).</p>
<p>You need to validate email twice. Once on the client side to help users avoid misspelled addresses. Start with a semantic input tag type <code>&lt;input type=&#39;email&#39;&gt;</code>. Some of the browsers automatically validate it without any extra scripting on the front end.</p>
<p>Validate it once again on the server by actually sending a confirmation email.</p>
<p>Haven‚Äôt you seen one such lately? Just try to subscribe to this <a href="https://www.pineboat.in/" target="_blank" rel="noopener">pineboat</a>. You‚Äôll get an actual email asking you to confirm that it is yours. That confirmation is a solid proof that your email is valid.</p>
<p>That was smooth sailing, wasn‚Äôt it?</p>
<h4 id="RegEx-for-Email"><a href="#RegEx-for-Email" class="headerlink" title="RegEx for Email"></a>RegEx for Email</h4><p>Now that we added the disclaimer, you‚Äôd actually want to see a pattern right? No, search for regular expression for an email address. One such result from <a href="http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html" target="_blank" rel="noopener">perl module</a> goes for more than a page.</p>
<p>So, I am not even going to attempt it. Such long regular expressions are generated by computers through pattern builders. Not for mere mortals like us.</p>
<h3 id="6-Match-a-Strong-Password"><a href="#6-Match-a-Strong-Password" class="headerlink" title="6. Match a Strong Password"></a>6. Match a Strong Password</h3><p>If you are a coffee person, this is the right time to get a strong one. Because we are at last section of this post, but the longest one so far.</p>
<p>It introduces very few new operators and patterns. But it reuses many patterns. As usual, we reserve the shortest optimized one for last.</p>
<p>The ASCII range is the best part of this post. Because, I learned it while researching for this post.</p>
<p>Now, the problem. Remember that registration form that took several attempts before you could meet their strong password requirements? Weak, good, strong, and very strong? Yeah, we are going to build that validation.</p>
<p>The password should:</p>
<ul>
<li>have a minimum of 4 characters</li>
<li>contain lowercase</li>
<li>contain uppercase</li>
<li>contain a number</li>
<li>contain a symbol</li>
</ul>
<p>This is a tricky one. Once you start consuming letters, you can‚Äôt come back to check if they meet any other condition.There in lies our clue. <strong>We can‚Äôt look back, but we can look ahead!</strong></p>
<h4 id="Length-of-the-string"><a href="#Length-of-the-string" class="headerlink" title="Length of the string"></a>Length of the string</h4><p>Let‚Äôs first test if the string password is 4 characters long. Pretty simple. Use .length on the password string. Done, right? No, who needs a simple solution? Let‚Äôs spice it up.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//expression with just lookahead</span></span><br><span class="line"><span class="comment">//wouldn't consume any character</span></span><br><span class="line">e1=<span class="regexp">/^(?=.&#123;4,&#125;)$/</span>; </span><br><span class="line">e1.test(<span class="string">"abc"</span>) <span class="comment">//false</span></span><br><span class="line">e1.test(<span class="string">"abcd"</span>) <span class="comment">//false //after lookahead, </span></span><br><span class="line"><span class="comment">//pattern to consume character is needed.</span></span><br><span class="line">e2=<span class="regexp">/^(?=.&#123;4,&#125;).*$/</span>; </span><br><span class="line">e2.test(<span class="string">"abc"</span>) <span class="comment">//false </span></span><br><span class="line">e2.test(<span class="string">"abcd"</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>You may remember (?=) from our previous work on <a href="https://www.pineboat.in/post/regular-expressions-your-ally/#extension-2-no-duplicates" target="_blank" rel="noopener">‚Äúno duplicates‚Äù</a> That‚Äôs a look ahead use<br>It does not consume any character</li>
<li>The dot (.) is an interesting character<br>It means, <strong>any character</strong>.</li>
<li>{4,}<br>Stands for at least 4 preceding characters with no maximum limit</li>
<li>\d{4}<br>Would look for exactly 4 numerals</li>
<li>\w{4,20}<br>Would look for 4 to 20 alpha-numeric characters</li>
</ul>
<p>Let‚Äôs translate /^(?=.{4,})$/. ‚ÄúStart from the beginning of the string. Look ahead for at least 4 characters. Don‚Äôt remember the match. Come back to the beginning and check if the string ends there.‚Äù</p>
<p>Doesn‚Äôt sound right. Does it? At least the last bit.</p>
<p>Which is why we brought in the variation /^(?=.{4,}).<em>$/. An extra dot and a star. It reads like this, ‚ÄúStart from the beginning. Look ahead for 4 characters. Don‚Äôt remember the match. Come back to the beginning. Consume all the characters using .</em> and see if you reach the end of the string.‚Äù</p>
<p>This makes sense now. Doesn‚Äôt it?</p>
<p>Which is why abc fails and abcd passes the pattern.</p>
<h4 id="At-least-One-Number"><a href="#At-least-One-Number" class="headerlink" title="At least One Number"></a>At least One Number</h4><p>This is going to be easy.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e=<span class="regexp">/^(?=.*\d+).*$/</span> </span><br><span class="line">e.test(<span class="string">""</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"a"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"8"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"a8b"</span>); <span class="comment">//true </span></span><br><span class="line">e.test(<span class="string">"ab890"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Start from the beginning of the string /^. Look ahead for 0 or more characters ?=.<em>. Check if 1 or more numbers follow \d+. Once it matches, come back to the beginning (because we were in look ahead). Consume all the characters in the string until end of the string .</em>$/.</p>
<h4 id="At-Least-One-Lowercase-Letter"><a href="#At-Least-One-Lowercase-Letter" class="headerlink" title="At Least One Lowercase Letter"></a>At Least One Lowercase Letter</h4><p>This one follows the same patter as above.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e=<span class="regexp">/^(?=.*[a-z]+).*$/</span>; </span><br><span class="line">e.test(<span class="string">""</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"A"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"a"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Translation? Sure. ‚ÄúStart from the‚Ä¶ okay.‚Äù Instead of \d+, we have [a-z]+ which is a character set of letters from a to z.</p>
<h4 id="At-least-One-Uppercase-Letter"><a href="#At-least-One-Uppercase-Letter" class="headerlink" title="At least One Uppercase Letter"></a>At least One Uppercase Letter</h4><p>Let‚Äôs not overkill. [A-Z] instead of [a-z] from the previous section will do.</p>
<h4 id="At-least-One-Symbol"><a href="#At-least-One-Symbol" class="headerlink" title="At least One Symbol"></a>At least One Symbol</h4><p>This is going to be challenging. One way to match symbols is to place a list of symbols in a character set. /^(?=.<em>[-+=_)(\</em>&amp;\^%\$#@!~‚Äù‚Äô:;|}]{[/?.&gt;,&lt;]+).*$/.test(‚Äú$‚Äù) That‚Äôs all the symbols in a character set. Properly escaped where necessary. It‚Äôll take months for me to write it in plain English.</p>
<p>So to save all of us from eternal pain, here is a simple one:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//considers space as symbol </span></span><br><span class="line"><span class="keyword">let</span> e1; </span><br><span class="line">e1=<span class="regexp">/^(?=.*[^a-zA-Z0-9])[ -~]+$/</span> </span><br><span class="line">e1.test(<span class="string">"_"</span>); <span class="comment">//true </span></span><br><span class="line">e1.test(<span class="string">" "</span>); <span class="comment">//true </span></span><br><span class="line"><span class="comment">//does not take space </span></span><br><span class="line"><span class="keyword">let</span> e2; </span><br><span class="line">e2=<span class="regexp">/^(?=.*[^a-zA-Z0-9])[!-~]+$/</span> </span><br><span class="line">e2.test(<span class="string">" "</span>); <span class="comment">//false </span></span><br><span class="line">e2.test(<span class="string">"_"</span>); <span class="comment">//true </span></span><br><span class="line"><span class="comment">//the underscore exception </span></span><br><span class="line"><span class="keyword">let</span> e3; </span><br><span class="line">e3=<span class="regexp">/^(?=.*[\W])[!-~]+$/</span> </span><br><span class="line">e3.test(<span class="string">"_"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>Wait, what‚Äôs that ^ coming again from the middle of no where? If you have reached this far, this is where you realize that unassuming innocent ^ that marks start of a string is a double agent. Which means, the end is not too far. He has been exposed.</p>
<p>Within a character set, ^ negates the character set. That is, [^a-z] means, any character other than a to z.</p>
<p>[^a-zA-Z0-9] then stands for any character other than lower case alphabets, upper case alphabets, and numerals.</p>
<p>We could have used \W instead of the long character set. But \W stands for all alpha-numeric characters <strong>including underscore _.</strong> As you can see in the third set of examples above, that will not accept underscore as a valid symbol.</p>
<h4 id="CharSet-Range"><a href="#CharSet-Range" class="headerlink" title="CharSet Range"></a>CharSet Range</h4><p>The curious case of [!-~]. They stand next to each other in the keyboard, but their ASCII values are diagonally opposite.</p>
<p>Remember a-z? A-Z? 0‚Äì9? These are not constants. They are actually based on the ASCII range of their values.</p>
<p>The <a href="http://www.asciitable.com/" target="_blank" rel="noopener">ASCII table</a> has 125 characters. zero (0) to 31 are not relevant to us. Space starts from 32 going all the way up to 126 which is tilda(~). The exclamation mark is 33.</p>
<p>So [!-~] covers all the symbols, letters and numbers we need. The seed for this idea came from <a href="https://stackoverflow.com/questions/8359566/regex-to-match-symbols" target="_blank" rel="noopener">another solution</a> to the symbol problem.</p>
<h4 id="Assemble-the-Troops"><a href="#Assemble-the-Troops" class="headerlink" title="Assemble the Troops"></a>Assemble the Troops</h4><p>Bringing it all together, we get this nice looking piece of regular expression /^(?=.{5,})(?=.<em>[a-z]+)(?=.</em>\d+)(?=.<em>[A-Z]+)(?=.</em>[^\w])[ -~]+$/.</p>
<p>That‚Äôs starting to haunt and intimidate us. Though we‚Äôve been studying them individually.</p>
<p>This is where the syntax for dynamically building expression object comes in handy. We are going to build each piece separately and assemble them later.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//start with prefix </span></span><br><span class="line"><span class="keyword">let</span> p = <span class="string">"^"</span>; </span><br><span class="line"><span class="comment">//look ahead  </span></span><br><span class="line"><span class="comment">// min 4 chars </span></span><br><span class="line">p += <span class="string">"(?=.&#123;4,&#125;)"</span>; </span><br><span class="line"><span class="comment">// lower case </span></span><br><span class="line">p += <span class="string">"(?=.*[a-z]+)"</span>; </span><br><span class="line"><span class="comment">// upper case </span></span><br><span class="line">p += <span class="string">"(?=.*[A-Z]+)"</span>; </span><br><span class="line"><span class="comment">// numbers </span></span><br><span class="line">p += <span class="string">"(?=.*\\d+)"</span>; </span><br><span class="line"><span class="comment">// symbols </span></span><br><span class="line">p += <span class="string">"(?=.*[^ a-zA-Z0-9]+)"</span>; </span><br><span class="line"><span class="comment">//end of lookaheads </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//final consumption </span></span><br><span class="line">p += <span class="string">"[ -~]+"</span>;  </span><br><span class="line"><span class="comment">//suffix </span></span><br><span class="line">p += <span class="string">"$"</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//Construct RegEx </span></span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> RegEx(p); </span><br><span class="line"><span class="comment">// tests </span></span><br><span class="line">e.test(<span class="string">"aB0#"</span>); <span class="comment">//true  </span></span><br><span class="line">e.test(<span class="string">""</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"aB0"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"ab0#"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"AB0#"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"aB00"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"aB!!"</span>); <span class="comment">//false </span></span><br><span class="line"><span class="comment">// space is in our control </span></span><br><span class="line">e.test(<span class="string">"aB 0"</span>); <span class="comment">//false </span></span><br><span class="line">e.test(<span class="string">"aB 0!"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>If your eyes are not tired yet, you‚Äôd have noticed two strange syntax in the above code.</p>
<ul>
<li>One, we didn‚Äôt use /^, instead we used just ^. We didn‚Äôt use $/ to end the expression either, instead just $.<br>The reason is that the RegEx constructor automatically adds starting and trailing slashes for us.</li>
<li>Two, to match numbers we used \d instead of the usual \d. This is because the variable p is just a normal string within double quotes. To insert a backslash, you need to escape the backslash itself.<br>\d resolves to \d within the RegEx constructor</li>
</ul>
<p>Apparently, there should be server side validations for passwords too. Think about SQL injection vulnerabilities if your framework or language doesn‚Äôt handle it already.</p>
<h3 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7. Conclusion"></a>7. Conclusion</h3><p>That brings us to the end of the story. But this is the beginning of a journey.</p>
<p>We just scratched the pattern matching portion of RegEx with test method. exec method builds on this foundation to return matched sub-strings based on pattern.</p>
<p>String object has methods such as match, search, replace, and split that widely uses regular expressions.</p>
<p>Hope this sets you off to explore those capabilities further with a solid understanding on composing patterns for RegEx.</p>
<h3 id="8-Call-To-Action"><a href="#8-Call-To-Action" class="headerlink" title="8. Call To Action"></a>8. Call To Action</h3><p>No, after all this difficulty we‚Äôve been through, I am not going to ask you to subscribe.</p>
<p>Just make good software.</p>
<p>If any code blocks presented here do not work, leave a comment on this <a href="https://github.com/pineboat/pineboat.github.io/issues/3" target="_blank" rel="noopener">github issue</a> I created specially for this post.</p>
<p>Hope it was useful! Share it if others would benefit.</p>
<p>You‚Äôve been wonderful. Appreciate your time. This content is far long by recent standards. Thanks for reading.</p>
<p>Originally published at <a href="https://www.pineboat.in/post/regular-expressions-your-ally/" target="_blank" rel="noopener">www.pineboat.in</a>.</p>
<span>Source: </span><a href="https://medium.freecodecamp.org/regular-expressions-demystified-regex-isnt-as-hard-as-it-looks-617b55cf787" target="_blank" title="https://medium.freecodecamp.org/regular-expressions-demystified-regex-isnt-as-hard-as-it-looks-617b55cf787" class="post-from">https://medium.freecodecamp.org/regular-expressions-demystified-regex-isnt-as-hard-as-it-looks-617b55cf787</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2017/12/JavaScript-Start-up-Performance.html" class="prev">NEXT</a><a href="/2017/12/React-Inline-Functions-and-Performance.html" class="next">PREV</a></div><div class="copyright"><p>¬© 2017 - 2018 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>