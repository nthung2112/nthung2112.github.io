<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> React, Inline Functions, and Performance ¬∑ Learn and Share</title><meta name="description" content="React, Inline Functions, and Performance - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="React, Inline Functions, and Performance"><meta property="og:image"><meta property="og:description" content="My wife and I just got through a huge remodel. We were beyond excited to show people the new digs. We showed my mother-in-law. She walked in the beautifully remodeled bedroom, looked up at the fantastically framed window and said: ‚ÄúNo blinds?‚Äù üòê
Our new bedroom; holy crap it looks like a magazine picture. Also, no blinds.
I find myself with the same emotion when I‚Äôm talking about React. I‚Äôll be getting through the first lecture of a workshop, showing off some cool new OSS, and invariably somebody says: ‚Äúinline functions? I heard those are slow.‚Äù"></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">React, Inline Functions, and Performance</h1><h2 class="post-subtitle"></h2><header class="post-info">Dec 8, 2017<div class="tags"><a href="/tags/react" class="tag-link">#react</a></div><div class="fb-ir-time"><time datetime="2017-12-08T07:43:28.000Z" class="op-modified"></time><time datetime="2017-12-08T07:43:28.000Z" class="op-published"></time></div></header></div><div class="wrap"><div class="post-content"><p>My wife and I just got through a huge remodel. We were beyond excited to show people the new digs. We showed my mother-in-law. She walked in the beautifully remodeled bedroom, looked up at the fantastically framed window and said: ‚ÄúNo blinds?‚Äù üòê</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*_WL8zajmqcczto2bjiBqpw.jpeg" alt="">Our new bedroom; holy crap it looks like a magazine picture. Also, no blinds.</p>
<p>I find myself with the same emotion when I‚Äôm talking about React. I‚Äôll be getting through the first lecture of a workshop, showing off some cool new OSS, and invariably somebody says: ‚Äúinline functions? I heard those are slow.‚Äù<br><a id="more"></a><br>It wasn‚Äôt always this way. But the last few months it comes up literally every day. As an instructor and library author, it gets exhausting. Unfortunately, I‚Äôm a dummy and I rant on twitter instead of writing something that might be insightful to others. So, this is my attempt at the better option üòÇ.</p>
<h3 id="What-is-an-‚Äúinline-function‚Äù"><a href="#What-is-an-‚Äúinline-function‚Äù" class="headerlink" title="What is an ‚Äúinline function‚Äù"></a>What is an ‚Äúinline function‚Äù</h3><p>In the context of React, an inline function is a function that is defined while React is ‚Äúrendering‚Äù. There are two meanings of ‚Äúrender‚Äù in React that people often get confused about: (1) getting the React elements from your components (calling your component‚Äôs render method) during an update and (2) actually rendering updates to the DOM. When I refer to ‚Äúrendering‚Äù in this article, I‚Äôm talking about #1.</p>
<p>Here are a few examples of inline functions:</p>
<script src="//gist.github.com/63ed1cd4ce795c83d4c7baf08320cc0c.js"></script>
<h3 id="Premature-optimization-is-the-root-of-all-evil"><a href="#Premature-optimization-is-the-root-of-all-evil" class="headerlink" title="Premature optimization is the root of all evil"></a>Premature optimization is the root of all evil</h3><p>Before we go any further, we need to talk about how to optimize a program. Ask any performance expert and they will tell you not to prematurely optimize your program. All of them. Yes, every single one of them. 100% of people with deep performance experience will tell you not to prematurely optimize your code.</p>
<blockquote>
<p>If you aren‚Äôt measuring, you can‚Äôt even know if your optimizations are better, and you certainly won‚Äôt know if they make things worse!</p>
</blockquote>
<p>I remember a talk my friend Ralph Holzmann gave about how gzip works that really solidified this idea for me. He talks about an experiment he did with LABjs, an old script loading library. You can watch from 30:02 to about 32:35 <a href="https://vimeo.com/34164210" target="_blank" rel="noopener">in this video</a> to hear about it, or just keep reading.</p>
<p>At the time, the source for <a href="https://github.com/getify/LABjs" target="_blank" rel="noopener">LABjs</a> did something a little awkward for performance. Instead of using normal object notation (obj.foo) it stored the keys in strings and used bracket notation to access the objects (obj[stringForFoo]). The idea was that after minifying and gzipping, the unnaturally written code would be smaller than the naturally written code. <a href="https://github.com/getify/LABjs/blob/b23ee3fcad12157cf8f6a291cb54fd7550ac7f3b/LAB.src.js#L7-L34" target="_blank" rel="noopener">You can see it here</a>.</p>
<p>Ralph forked the code and removed the optimizations by writing the code naturally, without thinking about how to optimize for minification and gzip.</p>
<p>Turns out, removing the ‚Äúoptimizations‚Äù shaved off 5.3% of the file size! If you aren‚Äôt measuring, you can‚Äôt even know if your optimizations are better, and you certainly won‚Äôt know if they make things worse!</p>
<p>Not only can premature optimization explode development time while hurting code cleanliness, it can even backfire and <em>cause</em> performance problems as it did for LABjs. Had the author been measuring, rather than just imagining performance issues, he would have saved development time, had cleaner code, and better performance.</p>
<p>Don‚Äôt prematurely optimize. Alright, back to React.</p>
<h3 id="Why-do-people-say-inline-functions-are-slow"><a href="#Why-do-people-say-inline-functions-are-slow" class="headerlink" title="Why do people say inline functions are slow?"></a>Why do people say inline functions are slow?</h3><p>Two reasons: Memory/garbage collection concerns, and shouldComponentUpdate.</p>
<h4 id="Memory-and-garbage-collection"><a href="#Memory-and-garbage-collection" class="headerlink" title="Memory and garbage collection"></a>Memory and garbage collection</h4><p>First, folks (and <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md" target="_blank" rel="noopener">eslint configs</a>) are concerned about memory and garbage collection costs around creating inline functions. This mostly spilled over from the days before arrow functions became ubiquitous. Lots of code would call bind inline, which has historically had poor performance. For example:</p>
<script src="//gist.github.com/15bc885c2ed7c2f10fca8b381c76f331.js"></script>
<p>Performance issues with Function.prototype.bind <a href="http://benediktmeurer.de/2015/12/25/a-new-approach-to-function-prototype-bind/" target="_blank" rel="noopener">got fixed here</a> and arrow functions are either a native thing or are transpiled by babel to plain functions; in both cases we can assume it‚Äôs not slow.</p>
<p>Remember, you don‚Äôt sit back and imagine ‚ÄúI bet that code is slow‚Äù. You write your code naturally, <em>then</em> you measure it. If there are performance problems, fix them. We don‚Äôt need to prove an inline arrow function is fast, somebody else needs to prove it‚Äôs slow. Otherwise it‚Äôs a premature optimization.</p>
<p>As far as I‚Äôve seen, nobody has presented an analysis of their app that indicates inline arrow functions are slow. Until then, it‚Äôs not even worth talking about‚Ää‚Äî‚Ääbut I‚Äôll offer one more thought anyway üòù</p>
<p>If the cost of creating an inline function is high enough to warrant an eslint rule against it, why would we want to move that expense to the hot path of initialization?</p>
<script src="//gist.github.com/b9c376506948aa6ead758860b8305f52.js"></script>
<p>By prematurely optimizing we‚Äôve slowed down the initialization of the component by 3x! If all the handlers were inline, the initial render would only have to create one function. Instead, we‚Äôve created three. We haven‚Äôt measured anything though, so we have no reason to believe any of this is a problem.</p>
<p>If you want to completely miss the point, go make an eslint rule that requires inline functions everywhere to speed up the initial render ü§¶üèæ‚Äç‚ôÄÔ∏è.</p>
<h4 id="PureComponent-and-shouldComponentUpdate"><a href="#PureComponent-and-shouldComponentUpdate" class="headerlink" title="PureComponent and shouldComponentUpdate"></a>PureComponent and shouldComponentUpdate</h4><p>This is where the real meat of the problem lives. You can see real performance improvements by understanding two things: shouldComponentUpdate and JavaScript strict equality comparisons. If you don‚Äôt understand them well, you can inadvertently make your React code harder to work with in the name of performance.</p>
<p>When you call setState, React will compare the old React elements to a new set of React elements (this is called r_econciliation_, you can <a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">read about it here</a>) and then use that information to update the real DOM elements. Sometimes that can get slow if you‚Äôve got a lot of elements to check (like a big SVG). In these cases, React provides an escape hatch called shouldComponentUpdate.</p>
<script src="//gist.github.com/1ca57cfea6f5a4a8a4b9e5ac468f9b91.js"></script>
<p>If your component has shouldComponentUpdate defined, before React compares the old and new elements, it will ask shouldComponentUpdate if anything changed. If it returns false, then React will completely skip the element diff, saving some time. If your component is large enough, this can have considerable impact on performance.</p>
<p>The most common way to optimize a component is to extend React.PureComponent instead of React.Component. A PureComponent will diff your props and state in shouldComponentUpdate so you don‚Äôt have to.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Avatar</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>Avatar will now use a ‚Äústrict equality comparison‚Äù on its props and state when being asked to update, hopefully speeding things up.</p>
<h4 id="Strict-Equality-Comparison"><a href="#Strict-Equality-Comparison" class="headerlink" title="Strict Equality Comparison"></a>Strict Equality Comparison</h4><p>There are six primitive types in JavaScript: string, number, boolean, null, undefined, and symbol. When you do a ‚Äústrict equality comparison‚Äù on two primitives that hold the same value, you‚Äôll get true. For example:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> uno = <span class="number">1</span></span><br><span class="line">one === uno <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>When PureComponent diffs props it uses a strict equality comparison. This works out great for inlined primitive values: <toggler isopen="{true}/">.</toggler></p>
<p>The prop diffing problem arises because of non-primitive types‚Ää‚Äî‚Ääerr, excuse me, <em>type</em>. There is only one other type and that‚Äôs Object. What about functions and arrays you say? <em>Well, actually</em> those are just objects.</p>
<blockquote>
<p>Functions are regular objects with the additional capability of being callable.</p>
</blockquote>
<blockquote>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures</a></li>
</ul>
</blockquote>
<p>LOL, okay JavaScript. So anyway, strict equality checks on objects, even with seemingly similar values, will evaluate to false:</p>
<script src="//gist.github.com/bbaa6a0a5fb5a24f941e7388b53f8f76.js"></script>
<p>So, if you inline an object in your JSX, it will fail the PureComponent prop diff and move on to diffing the more expensive React elements. The element diff will come up empty and now we‚Äôve wasted time on both diffs.</p>
<script src="//gist.github.com/70f9ca97de0606212424694a3629428d.js"></script>
<p>Since functions are objects and PureComponent does a strict equality check on props, an inline function will <em>always</em> fail the prop diff and move on to the element diff in the reconciler.</p>
<p>You can see this isn‚Äôt just about inline functions. The function is simply the lead singer of the object, function, array three-piece performance postulation proliferation.</p>
<p>In order to make shouldComponentUpdate happy, you have to keep referential identity of the function. For experienced JavaScript developers, it‚Äôs not too bad. But, <a href="https://medium.com/@mjackson" target="_blank" rel="noopener">Michael</a> and I have led workshops with over 3,500 people at varying levels of experience and it ain‚Äôt easy for a lot of folks. ES classes don‚Äôt offer any help either, leading us down all sorts of JavaScript paths:</p>
<script src="//gist.github.com/187e82831d36fe8fa91952b616a33527.js"></script>
<p>Learning how to keep referential identity of a function leads to surprisingly long conversations.</p>
<p>There‚Äôs usually no reason why we‚Äôre forcing people to do this other than an eslint config yelled at them. I‚Äôd like to show that you can have inline functions and performance optimizations both at the same time. But first, I have a personal performance story.</p>
<h3 id="My-own-experience-with-PureComponent"><a href="#My-own-experience-with-PureComponent" class="headerlink" title="My own experience with PureComponent"></a>My own experience with PureComponent</h3><p>When I first learned about PureRenderMixin (the thing from earlier versions of React that later became PureComponent) I put in a bunch of measurements and measured my app‚Äôs performance. I then added PureRenderMixin to every single component. When I took the optimized set of measurements I was hoping to have a cool story to tell about how much faster everything got.</p>
<p>Much to my surprise, my app got slower ü§î.</p>
<p>Why? Well, think about it. If you have a Component how many diffs are there? If you have a PureComponent how many diffs are there? The answers are ‚Äújust one‚Äù and ‚Äúat least one and sometimes two‚Äù, respectively. If a component <em>usually</em> changes when there‚Äôs an update, then a PureComponent will be doing two diffs instead of just one (props and state in shouldComponentUpdate, and then the normal element diff). Which means it‚Äôs going to be <em>slower usually</em> but <em>faster occasionally</em>. Apparently, most of my components changed most of the time, so on the whole, my app got slower. Oops.</p>
<p>There are no silver bullets when it comes to performance. You have to measure.</p>
<h3 id="The-three-scenarios"><a href="#The-three-scenarios" class="headerlink" title="The three scenarios"></a>The three scenarios</h3><p>At the start of the article I showed three types of inline functions. Now that we have some background, let‚Äôs talk about each one them. But please remember to keep PureComponent on the shelf until you have a measurement to justify it.</p>
<h4 id="DOM-component-event-handler"><a href="#DOM-component-event-handler" class="headerlink" title="DOM component event handler"></a>DOM component event handler</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">  onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(‚Ä¶)&#125;</span><br><span class="line">&gt;click&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>It‚Äôs common to do nothing more than setState inside of event handlers for buttons, inputs, and other DOM components. This often makes an inline function the cleanest approach. Instead of bouncing around the file to find the event handlers, they‚Äôre colocated. The React community generally welcomes colocation.</p>
<p>The button component (and every other DOM component) can‚Äôt even be a PureComponent, so there are no shouldComponentUpdate referential identity concerns here.</p>
<p>So, the only reason to think this is slow is if you think simply defining a function is a big enough expense to worry about. We‚Äôve discussed that there is no evidence anywhere that it is. It‚Äôs simply armchair performance postulation. These are fine until proven otherwise.</p>
<h4 id="A-‚Äúcustom-event‚Äù-or-‚Äúaction‚Äù"><a href="#A-‚Äúcustom-event‚Äù-or-‚Äúaction‚Äù" class="headerlink" title="A ‚Äúcustom event‚Äù or ‚Äúaction‚Äù"></a>A ‚Äúcustom event‚Äù or ‚Äúaction‚Äù</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Sidebar onToggle=&#123;(isOpen) =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">sidebarIsOpen</span>: isOpen &#125;)</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure>
<p>If Sidebar is a PureComponent we will be breaking the prop diff. Again, since the handler is simple, the colocation can be preferable.</p>
<p>With an event like onToggle, why is Sidebar even diffing it? There are only two reasons to include a prop in the shouldComponentUpdate diff:</p>
<ol>
<li>You use the prop to render.</li>
<li>You use the prop to perform a side-effect in componentWillReceiveProps, componentDidUpdate, or componentWillUpdate.</li>
</ol>
<p>Most on<whatever> props do not meet either of these requirements. Therefore, most PureComponent usages are over-diffing, forcing developers to maintain referential identity of the handler needlessly.</whatever></p>
<p>We should only diff the props that matter. That way people can colocate handlers and still get the performance gains you‚Äôre seeking (and since we‚Äôre concerned about performance, we‚Äôre diffing less!).</p>
<p>For most components, I‚Äôd recommend creating a PureComponentMinusHandlers class and inherit from that instead of inheriting from PureComponent. It could just skip all checks on functions. Have your cake and eat it too.</p>
<p>Well, almost.</p>
<p>If you receive a function and pass that function directly into another component, it‚Äôll get stale. Check this out:</p>
<script src="//gist.github.com/9e40e895750ec93a0fa64e15afef52fc.js"></script>
<p><a href="https://codesandbox.io/s/v38y6zk8ml" target="_blank" rel="noopener">Here‚Äôs a codesandbox running that app</a>.</p>
<p>So, if you like the idea of inheriting from a PureRenderWithoutHandlers, make sure you don‚Äôt ever pass your ignored handlers <em>directly</em> to other components‚Ää‚Äî‚Ääyou need to wrap them one way or another.</p>
<p>Now we either have to maintain referential identity, or we have to avoid referential identity! Welcome to performance optimization. At least with this approach it‚Äôs the optimized component that has to deal with it, not the code using it.</p>
<p>I‚Äôm going to be candid, that example app is an edit I made after publishing that <a href="https://medium.com/@acdlite" target="_blank" rel="noopener">Andrew Clark</a> brought to my attention. And here you thought I was smart enough to know when to manage referential identity and when not to! üòÇ</p>
<h4 id="A-render-prop"><a href="#A-render-prop" class="headerlink" title="A render prop"></a>A render prop</h4><script src="//gist.github.com/f06440f6bf807759e7b43527671ec14b.js"></script>
<p>Render props are a pattern used to create a component that exists to compose and manage shared state. (<a href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" target="_blank" rel="noopener">You can read more about them here</a>.) The contents of the render prop are unknowable to the component. For example:</p>
<script src="//gist.github.com/1e7e22cbd92ba132dbbff893f0b51d7b.js"></script>
<p>That means an inline render prop function won‚Äôt cause problems with shouldComponentUpdate: It can‚Äôt ever know enough to be a PureComponent.</p>
<p>So, the only other objection is back to believing that simply defining functions is slow. Repeating from the first example: there‚Äôs no evidence to support that. It‚Äôs simply armchair performance postulation.</p>
<h3 id="In-summary"><a href="#In-summary" class="headerlink" title="In summary"></a>In summary</h3><ol>
<li>Write your code naturally, code to the design.</li>
<li>Measure your interactions to find slow paths. <a href="https://reactjs.org/blog/2016/11/16/react-v15.4.0.html#profiling-components-with-chrome-timeline" target="_blank" rel="noopener">Here‚Äôs how</a>.</li>
<li>Use PureComponent and shouldComponentUpdate only when you need to, skipping prop functions (unless they are used in lifecycle hooks for side-effects).</li>
</ol>
<span>Source: </span><a href="https://cdb.reacttraining.com/react-inline-functions-and-performance-bdff784f5578" target="_blank" title="https://cdb.reacttraining.com/react-inline-functions-and-performance-bdff784f5578" class="post-from">https://cdb.reacttraining.com/react-inline-functions-and-performance-bdff784f5578</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2017/12/Hieu-ro-ve-Regular-Expressions-RegEx-khong-kho-nhu-tuong-tuong.html" class="prev">NEXT</a><a href="/2017/12/Cai-thien-toc-do-Web-App-voi-Pinterest.html" class="next">PREV</a></div><div class="copyright"><p>¬© 2017 - 2019 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>