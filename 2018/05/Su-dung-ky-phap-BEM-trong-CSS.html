<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Sử dụng ký pháp BEM trong CSS · Learn and Share</title><meta name="description" content="Sử dụng ký pháp BEM trong CSS - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Sử dụng ký pháp BEM trong CSS"><meta property="og:image" content="https://cdn-images-1.medium.com/max/800/1*bQLArQAfcohZ5E81z8gcHg.jpeg"><meta property="og:description" content="Ký pháp BEM là gìBEM viết tắt của Blocks, Elements, Modifiers, là một phương pháp đặt tên class cho HTML và CSS. Được phát triển tại Yandex giúp lập trình viên hiểu rõ hơn mối quan hệ giữa HTML và CSS trong dự án front end."></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Sử dụng ký pháp BEM trong CSS</h1><h2 class="post-subtitle"></h2><header class="post-info">May 20, 2018<div class="tags"><a href="/tags/css" class="tag-link">#css</a></div><div class="fb-ir-time"><time datetime="2018-05-20T09:05:00.000Z" class="op-modified"></time><time datetime="2018-05-20T09:05:00.000Z" class="op-published"></time></div></header></div><div class="post-banner"><img src="https://cdn-images-1.medium.com/max/800/1*bQLArQAfcohZ5E81z8gcHg.jpeg"></div><div class="wrap"><div class="post-content"><h2 id="Ky-phap-BEM-la-gi"><a href="#Ky-phap-BEM-la-gi" class="headerlink" title="Ký pháp BEM là gì"></a>Ký pháp BEM là gì</h2><p>BEM viết tắt của Blocks, Elements, Modifiers, là một phương pháp đặt tên class cho HTML và CSS. Được phát triển <a href="https://en.bem.info" target="_blank" rel="noopener">tại Yandex</a> giúp lập trình viên hiểu rõ hơn mối quan hệ giữa HTML và CSS trong dự án front end.<br><a id="more"></a><br>Ví dụ sau đây sẽ minh hoạ cách sử dụng ký pháp BEM:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Một Block (khối) độc lập */</span></span><br><span class="line"><span class="selector-class">.btn</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Element (phần tử) con, phụ thuộc vào Block ở trên */</span></span><br><span class="line"><span class="selector-class">.btn__price</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modifier (bộ điều chỉnh) thay đổi trạng thái của Block */</span></span><br><span class="line"><span class="selector-class">.btn--orange</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.btn--big</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Với cách đặt tên class này, ta có <strong>Block</strong> sẽ đại diện cho một component, và trong ví dụ ở đây, là một button <code>.btn</code>. Block cũng sẽ đóng vai trò là một <em>parent</em> mà trong nó sẽ có một hoặc nhiều hơn <strong>Element</strong> con liên quan. Tên class cho Element và mối quan hệ của nó với Block sẽ được diễn tả bằng tên của Block, tiếp theo là <em>hai gạch dưới</em>, và cuối cùng là tên của Element <code>.btn__price</code>. Thành phần thứ ba của BEM là các <strong>Modifier</strong> mà chúng sẽ giúp điều chỉnh các trạng thái hoặc phái sinh khác của Block / Element. Tên của Modifier sẽ được nối với tên Block / Element phía trước bởi <em>02 gạch ngang</em> <code>.btn--orange</code>.</p>
<p>Trong HTML, ký pháp BEM sẽ được dùng như sau:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn--big btn--orange"</span> <span class="attr">href</span>=<span class="string">"http://int3ractive.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__price"</span>&gt;</span>$9.99<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__text"</span>&gt;</span>Subscribe<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<iframe src="https://codepen.io/css-tricks/embed/226a65c8f7d64615aabd45048d1d3b6d" width="100%" height="300" frameborder="0" allowfullscreen></iframe>
<p>Ấn tượng đầu tiên với bạn có thể là tên class quá xấu và mất thời gian hơn so với việc tạo riêng một class mới cho một kiểu button mới. Tuy nhiên, ký pháp BEM sẽ mang lại nhiều lợi ích mà tôi sẽ phân tích tiếp theo sau đây:</p>
<h2 id="Tai-sao-su-dung-ky-phap-BEM"><a href="#Tai-sao-su-dung-ky-phap-BEM" class="headerlink" title="Tại sao sử dụng ký pháp BEM"></a>Tại sao sử dụng ký pháp BEM</h2><p>Trước tiên, ký pháp BEM giúp người mới tham gia dự án dễ dàng phát hiện ra các trạng thái và các đối tượng con của một component đã được viết sẵn. Điều này giúp tránh cho họ phải viết lại những kiểu CSS đã có sẵn và hạn chế việc viết thừa code hoặc trùng kiểu CSS, điều mà rất hay xảy ra trong dự án lớn có nhiều người tham gia.</p>
<p>Thứ hai, chỉ cần đọc HTML, bạn vẫn có thể nhanh chóng nắm được các thành phần phụ thuộc lẫn nhau. Trong ví dụ trên, bạn dễ dàng nhìn thấy <code>.btn__price</code> phụ thuộc vào <code>.btn</code> mặc dù bạn chưa biết vai trò cụ thể của nó ngay lập tức.</p>
<p>Thứ ba, với ký pháp BEM, mọi định nghĩa chỉ có một cấp class và không lồng cấp. Điều này giúp cho độ ưu tiên (specificity) chung của hệ thống CSS thấp. Đây là một lợi thế vì sau này bạn không phải “chiến đấu” với specificity của những thuộc tính đã có sẵn (VD: siêu lồng cấp <code>.a .b .c .d .e {...}</code>) cũng như vận dụng những kỹ thuật không hay để thay thế được style (chẳng hạn <code>!important</code> hay inline CSS).</p>
<p>Quy luật thác nước cascading của CSS là con dao hai lưỡi: nó giúp dễ dàng định nghĩa những thuộc tính và kiểu chung trên những selector tổng quát mà không cần phải khai báo lặp lại trên từng phần tử, nhưng nếu không nắm được tầm ảnh hưởng, lập trình viên CSS rất dễ gây ra những tác động phụ đến các đối tượng không liên quan khi chỉnh sửa trên những class có sẵn hoặc thậm chí viết mới. Với ký pháp BEM, lập trình viên sẽ tự tin hơn khi bắt tay chỉnh sửa hoặc viết thêm style vì đã biết rõ tầm ảnh hưởng của selector mà mình đang viết ra.</p>
<p>Tóm lại, ký pháp BEM, nếu áp dụng triệt để, sẽ giúp cải thiện sự phối hợp giữa các thành viên trong nhóm. Ngoài ra, nó buộc người viết CSS phải đầu tư suy nghĩ về việc xây dựng những component độc lập và tái sử dụng được (phù hợp với tiêu chí của <a href="https://github.com/stubbornella/oocss/wiki" target="_blank" rel="noopener">OOCSS</a>).</p>
<h2 id="Su-dung-BEM-voi-SASS"><a href="#Su-dung-BEM-voi-SASS" class="headerlink" title="Sử dụng BEM với SASS"></a>Sử dụng BEM với SASS</h2><p>Với phiên bản SASS mới nhất hiện nay, việc viết theo ký pháp BEM trong SCSS dễ dàng và thuận tiện hơn bao giờ hết.</p>
<p>Bạn vẫn sẽ sử dụng cách viết lồng để cô lập khối component và kết hợp với biểu tượng <em>parent</em> <code>&amp;</code> của SASS để đặt tên cho Element và Modifier mà không phải đánh lại tên của Block. VD:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line"></span><br><span class="line">    &amp;__element &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &amp;--mod &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mặc dù viết lồng cấp, khi được biên dịch thành CSS, chúng vẫn được trải phẳng thành một cấp class theo đúng tinh thần của BEM:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block__element</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block--mod</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Nếu bạn sử dụng LibSass (nhanh hơn rất nhiều lần bản gốc Ruby) để biên dịch SASS, thì hãy đảm bảo các công cụ wrapper được cập nhật các phiên bản tương đương hoặc mới hơn như sau: node-sass <a href="https://github.com/sass/node-sass/releases/tag/v3.4.0" target="_blank" rel="noopener">3.4.0</a>, gulp-sass <a href="https://github.com/dlmanning/gulp-sass/releases/tag/v2.1.0" target="_blank" rel="noopener">2.1.0</a> (nếu sử dụng <a href="https://github.com/gulpjs/gulp" target="_blank" rel="noopener">GulpJS</a>) và grunt-sass <a href="https://github.com/sindresorhus/grunt-sass/releases/tag/v1.1.0" target="_blank" rel="noopener">1.1.0</a> (nếu sử dụng <a href="https://github.com/gruntjs/grunt" target="_blank" rel="noopener">GruntJS</a>)</p>
<p>Thế còn LESS? Vì tôi không sử dụng LESS nên sẽ không đề cập ở đây. Bạn có thể giúp bổ sung hướng dẫn cho LESS nếu nó có cú pháp trợ giúp tương đương.</p>
<h2 id="Cac-y-kien-khong-dong-tinh"><a href="#Cac-y-kien-khong-dong-tinh" class="headerlink" title="Các ý kiến không đồng tình"></a>Các ý kiến không đồng tình</h2><p>Vẫn có một số ý kiến hoài nghi và không đồng tình với phương pháp đặt tên này.</p>
<h3 id="Ten-class-qua-xau"><a href="#Ten-class-qua-xau" class="headerlink" title="Tên class quá xấu"></a>Tên class quá xấu</h3><p>Đồng ý với bạn rằng BEM trông kỳ quặc, tuy nhiên khả năng mà nó đem lại vô cùng lớn và sẽ hoàn toàn xoá mờ hạn chế về mặt “ngoại hình” của nó.</p>
<p>Ngoài ra BEM đòi hỏi phải gõ nhiều chữ hơn và chiếm nhiều byte ký tự hơn, tuy nhiên với việc sử dụng SASS như trên và việc gzip file đã trở thành tiêu chuẩn như hiện nay, những điều đó không còn là vấn đề so với lợi ích mà BEM mang lại.</p>
<h3 id="Descendant-selector-van-giai-quyet-duoc-van-de-nhu-truoc-gio"><a href="#Descendant-selector-van-giai-quyet-duoc-van-de-nhu-truoc-gio" class="headerlink" title="Descendant selector vẫn giải quyết được vấn đề như trước giờ"></a>Descendant selector vẫn giải quyết được vấn đề như trước giờ</h3><p>Có một <a href="https://twitter.com/samuelfine/status/575645771334291456" target="_blank" rel="noopener">chỉ trích</a> dành cho BEM thế này: Thay vì viết</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-search</span>        &#123;&#125;</span><br><span class="line"><span class="selector-class">.site-search__field</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.site-search--full</span>  &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Họ đặt vấn đề rằng tại sao không viết như thế này:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-search</span>        &#123;&#125;</span><br><span class="line"><span class="selector-class">.site-search</span> <span class="selector-tag">input</span>  &#123;&#125;</span><br><span class="line"><span class="selector-class">.site-search</span><span class="selector-class">.full</span>   &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Rõ ràng cả hai cách viết đều có thể giúp hiện thực được component cụ thể này và cách thứ hai có vẻ “gọn gàng” hơn. Tuy nhiên khi CSS của toàn bộ dự án trở nên lớn và phức tạp hơn, thì rất khó tránh khỏi các kiểu được định nghĩa chồng chéo lên nhau ngoài tầm kiểm soát.</p>
<p>Thử tưởng tượng <code>.site-search</code> cũng nằm trong một container tên <code>.main</code> và những <code>input</code> bên trong <code>.main</code> cần được style với <code>.main input</code>. Như vậy, <code>input</code> bên trong <code>.site-search</code> sẽ bị điều chỉnh một cách không mong muốn.</p>
<p>Tương tự, nếu như <code>.full</code> trong ví dụ trên hoặc một tên phổ biến như <code>.label</code> được dùng như modifier, thì sẽ có rủi ro (rất cao) là một ngày nào đó một lập trình viên khác định nghĩa một class global trùng tên và sẽ làm hỏng style của element kia.</p>
<p>Ngoài ra, khi bạn đọc trong ngữ cảnh HTML, bạn sẽ khó thấy được quan hệ ràng buộc giữa <code>input</code> và <code>.full</code> với block <code>.site-search</code>.</p>
<h3 id="“Toi-don-gian-la-khong-thich-ky-phap-nay”"><a href="#“Toi-don-gian-la-khong-thich-ky-phap-nay”" class="headerlink" title="“Tôi đơn giản là không thích ký pháp này”"></a>“Tôi đơn giản là không thích ký pháp này”</h3><p>Một số người khi nhìn thấy cách đặt tên BEM đã ngay lập tức bác bỏ nó. Họ không thích BEM, đó là quyền của họ, tuy nhiên sẽ là vô lý nếu phản bác việc cần có một số quy tắc đặt tên để dễ dàng nắm bắt và quản lý CSS trong dự án trung và lớn.</p>
<p>Hơn nữa, bạn hoàn toàn có thể nghĩ ra cho mình một cách đặt tên khác cho hợp sở thích, nhưng vẫn dựa trên nguyên tắc của BEM đã đề ra. Là kết quả đúc kết từ những kiến trúc CSS lớn và phức tạp trước đây, đề xuất của BEM không phải vô tình lại có một số điểm chung với các phương pháp quản lý CSS khác như SMACSS hay OOCSS. Lấy ví dụ khái niệm module của SMACSS:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ví dụ một module */</span></span><br><span class="line"><span class="selector-class">.btn</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modifier của một module */</span></span><br><span class="line"><span class="selector-class">.btn-primary</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Btn Module với State */</span></span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.is-collapsed</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>Trong các phương pháp quản lý CSS vừa kể trên thì chỉ có BEM là làm rõ được mối quan hệ với các thành phần con bên trong.</p>
<p>Tóm lại, mỗi phương pháp đều có ưu nhược điểm. Quan trọng là cả team phải có phương pháp tiếp cận khoa học và áp dụng triệt để thì kiến trúc CSS của cả dự án mới vững và dễ bảo trì.</p>
<h2 id="Cau-hoi-thuong-gap"><a href="#Cau-hoi-thuong-gap" class="headerlink" title="Câu hỏi thường gặp:"></a>Câu hỏi thường gặp:</h2><p>❓<strong>Hỏi:</strong> Element có modifier hay không?<br>💬️ <strong>Đáp:</strong> Có. Element có thể có modifier riêng của nó. Ví dụ:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.accordion__copy--open</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>❓<strong>Hỏi:</strong> Có cần phải đặt tên class cho tất cả element (thẻ HTML) trong block hay không?<br>💬️ <strong>Đáp:</strong> Không cần thiết, chỉ những element cần có style riêng được viết trong CSS. Tuy nhiên cũng không nên lạm dụng những thẻ wrapper (phổ biến nhất là DIV) một cách vô tội vạ và không có chức năng vai trò cụ thể nào. Như vậy việc đặt tên element con cũng khiến bạn phải suy nghĩ một tag nào đó có thật sự cần thiết thêm vào trong block hay không.</p>
<p>❓<strong>Hỏi:</strong> Bên trong element con <code>foo</code> có một tag đóng vai trò một element con <code>bar</code> khác của block, vậy việc đặt tên class cho element <code>bar</code> này như thế nào? Có nên đặt là <code>.block__foo__bar</code>?<br>💬️ <strong>Đáp:</strong> Vẫn đặt bằng tên block và hai gạch dưới rồi đến tên element <code>.block__bar</code>, không chen giữa bằng <code>foo__</code>. Nói tóm lại, tên của element chỉ cần thể hiện quan hệ phụ thuộc với block, không cần phải chỉ rõ sự lồng bên trong nhau của các element con. (Xem thêm ví dụ trong câu hỏi tiếp theo)</p>
<p>❓<strong>Hỏi:</strong> Một thẻ HTML có thể là element của 2 block khác nhau không?<br>💬️ <strong>Đáp:</strong> Hoàn toàn có thể. Hãy xem ví dụ sau:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn--big btn--orange"</span> <span class="attr">href</span>=<span class="string">"http://int3ractive.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__price"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon icon--dollar-sign btn__icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>9.99<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__text"</span>&gt;</span>Subscribe<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Button có biểu tượng dollar-sign là một block <code>.icon</code>. Có thể trong block <code>.btn</code>, biểu tượng dollar-sign cần được style riêng, nên cần có một cái tên xác định rõ vai trò và style cho element này là <code>.btn__icon</code>. Nếu block <code>.icon.icon--dollar-sign</code> được dùng ở một ngữ cảnh khác, thì rõ ràng nó không cần class <code>.btn__icon</code> nữa vì tên class đã chỉ rõ sự ràng buộc với block <code>.btn</code> và chỉ được thêm vào khi ở bên trong nó.</p>
<p>❓<strong>Hỏi:</strong> Một element con có thể đóng vai trò là block của riêng nó không? Có thể xây dựng chuỗi component phụ thuộc nhau như <code>.a__b__c</code> không?<br>💬️ <strong>Đáp:</strong> Câu hỏi này thật sự ngoài tầm hiểu biết và kinh nghiệm của tôi. Có thể có những hoàn cảnh đặt biệt như vậy. Tuy nhiên, theo tôi, nếu có cũng không nên quá 2 cấp, tức là element con chỉ đặt đến <code>.a__b__c</code> là tối đa. Điều này là để sự phụ thuộc không quá sâu, làm giảm khả năng dùng lại của block (portability) và sự linh hoạt của các đối tượng CSS theo tinh thần OOCSS. Xem ví dụ bên dưới.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* block list */</span></span><br><span class="line"><span class="selector-class">.list</span> &#123; &#125;</span><br><span class="line"><span class="comment">/* item là con của list */</span></span><br><span class="line"><span class="selector-class">.list__item</span> &#123; &#125;</span><br><span class="line"><span class="comment">/* link là con của block list__item, để phân biệt với list__link</span></span><br><span class="line"><span class="comment">hoặc chỉ rõ mối quan hệ phụ thuộc giữa item và link*/</span></span><br><span class="line"><span class="selector-class">.list__item__link</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sai-lam-hay-mac-phai-khi-su-dung-BEM"><a href="#Sai-lam-hay-mac-phai-khi-su-dung-BEM" class="headerlink" title="Sai lầm hay mắc phải khi sử dụng BEM:"></a>Sai lầm hay mắc phải khi sử dụng BEM:</h2><p>Tôi xin hẹn lại về vấn đề này trong một bài viết khác, khi mà bản thân đã ứng dụng nhiều và quan sát được những ví dụ thực tiễn hơn để tổng hợp những sai lầm hay mắc phải do ảnh hưởng từ phương pháp cũ cũng như cách hiểu chưa đúng về phương pháp BEM này.</p>
<p>Xem thêm:</p>
<ul>
<li>Bài viết <a href="http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/" target="_blank" rel="noopener">giới thiệu BEM của CSSWizadry</a></li>
<li>Bài viết <a href="http://www.smashingmagazine.com/2012/04/a-new-front-end-methodology-bem/" target="_blank" rel="noopener">giới thiệu BEM của Smashing Magazine</a></li>
<li><a href="http://webuniverse.io/css-organization-naming-conventions-and-safe-extend-without-preprocessors/" target="_blank" rel="noopener">Sử dụng BEM và @extend của SASS</a></li>
<li>Bài viết <a href="https://medium.com/fed-or-dead/battling-bem-5-common-problems-and-how-to-avoid-them-5bbd23dee319" target="_blank" rel="noopener">5 sai lầm phổ biến với BEM</a></li>
</ul>
<span>Source: </span><a href="https://int3ractive.com/2015/12/ky-phap-bem-trong-css.html" target="_blank" title="https://int3ractive.com/2015/12/ky-phap-bem-trong-css.html" class="post-from">https://int3ractive.com/2015/12/ky-phap-bem-trong-css.html</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2018/05/Gioi-thieu-ve-Composing-Software.html" class="prev">NEXT</a><a href="/2018/05/Gioi-thieu-Progressive-Web-App.html" class="next">PREV</a></div><div class="copyright"><p>© 2017 - 2019 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>