<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Cách Javascript hoạt động P4: Event loop, lập trình bất đồng bộ & 5 mẹo cải thiện Async/Await · Learn and Share</title><meta name="description" content="Cách Javascript hoạt động P4: Event loop, lập trình bất đồng bộ &amp; 5 mẹo cải thiện Async/Await - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Cách Javascript hoạt động P4: Event loop, lập trình bất đồng bộ &amp; 5 mẹo cải thiện Async/Await"><meta property="og:image"><meta property="og:description" content="Chào các bạn đến với bài thứ 4 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.
Lần này chúng ta sẽ mở rộng những gì có trong bài đầu tiên bằng cách đánh giá những nhược điểm của môi trường đơn luồng (single thread) và làm thế nào để vượt qua chúng nhằm xây dựng những Javascript UI ấn tượng. Và vẫn như cũ, cuối bài viết tác giả sẽ chia sẻ 5 mẹo nhỏ để viết code tốt hơn với async/await."></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Cách Javascript hoạt động P4: Event loop, lập trình bất đồng bộ & 5 mẹo cải thiện Async/Await</h1><h2 class="post-subtitle"></h2><header class="post-info">Nov 13, 2018<div class="tags"><a href="/tags/javascript" class="tag-link">#javascript</a></div><div class="fb-ir-time"><time datetime="2018-11-13T16:34:00.000Z" class="op-modified"></time><time datetime="2018-11-13T16:34:00.000Z" class="op-published"></time></div></header></div><div class="wrap"><div class="post-content"><p>Chào các bạn đến với bài thứ 4 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p>
<p>Lần này chúng ta sẽ mở rộng những gì có trong bài đầu tiên bằng cách đánh giá những nhược điểm của môi trường đơn luồng (single thread) và làm thế nào để vượt qua chúng nhằm xây dựng những Javascript UI ấn tượng. Và vẫn như cũ, cuối bài viết tác giả sẽ chia sẻ 5 mẹo nhỏ để viết code tốt hơn với async/await.<br><a id="more"></a></p>
<h1 id="Tai-sao-don-luong-lai-la-gioi-han"><a href="#Tai-sao-don-luong-lai-la-gioi-han" class="headerlink" title="Tại sao đơn luồng lại là giới hạn."></a>Tại sao đơn luồng lại là giới hạn.</h1><p>Trong bài đầu tiên của series, chúng ta suy ngẫm về câu hỏi điều gì xảy ra khi chúng ta có 1 hàm trong callstack và hàm đó lại ngốn quá nhiều thời gian để thực thi.</p>
<p>Hãy tưởng tượng, ta thực hiện một thuật toán chuyển đổi hình ảnh phức tạp chạy trên browser.</p>
<p>Trong khi callstack đang thực thi các hàm, trình duyệt lại không thể làm gì cả, nó bị kẹt. Nghĩa là trình duyệt không thể vẽ, render, nó không thể chạy code khác, chỉ đơn giản là kẹt. Và vấn đề là ở đây, giao diện (UI) của app bạn sẽ hoạt động không hiệu quả.</p>
<p>App của bạn bị kẹt.</p>
<p>Trong một vài trường hợp thì đây không phải vấn đề nghiêm trọng. Tuy nhiên, có vấn đề còn lớn hơn nữa. Một khi trình duyệt của bạn xử lý quá nhiều thứ trong callstack, nó sẽ bị “đỡ” trong 1 khoảng thời gian dài. Tại thời điểm đó, đa số các browser sẽ chọn giải pháp hiện lỗi, hỏi người dùng có muốn hủy trang hiện tại không.</p>
<p>Điều này thật là xấu xí và ảnh hưởng nghiêm trọng đến trải nghiệm (UX):</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*MCt4ZC0dMVhJsgo1u6lpYw.jpeg" alt=""></p>
<h1 id="Nhung-thanh-phan-xay-dung-nen-1-chuong-trinh-JS"><a href="#Nhung-thanh-phan-xay-dung-nen-1-chuong-trinh-JS" class="headerlink" title="Những thành phần xây dựng nên 1 chương trình JS"></a>Những thành phần xây dựng nên 1 chương trình JS</h1><p>Bạn có thể viết toàn bộ code JS trong 1 file .js duy nhất nhưng chương trình của bạn chắc chắn chứa nhiều thành phần nhỏ (gọi là những block), chỉ có một số block sẽ được <strong>thực thi ngay</strong> (gọi là nhóm A) và phần còn lại thì <strong>chạy sau</strong> (nhóm B). Đơn vị block phổ biến nhất là function (hàm).</p>
<p>Vấn đề mà đa số các developer JS mới gặp phải là họ nghĩ rằng nhóm B không cần phải được thực thi một cách nghiêm ngặt ngay sau khi thực thi nhóm A. Nói cách khác, những nhiệm vụ không được hoàn thành ngay bây giờ thì theo lỹ thuyết nó sẽ được hoàn thành một cách bất đồng bộ, nghĩa là bạn sẽ không phải gặp tình huống blocking (bị chặn) như đề cập ở trên</p>
<p>Ví dụ:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Giả sử ajax(..) là một hàm Ajax thuộc thư viện nào đó</span></span><br><span class="line"><span class="keyword">var</span> response = ajax(<span class="string">'https://example.com/api'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(response);</span><br><span class="line"><span class="comment">// `response` sẽ không chứa dữ liệu trả về</span></span><br></pre></td></tr></table></figure>
<p>Chắc bạn cũng nhận thấy rằng những request Ajax như thế này không chạy đồng bộ với nhau, nghĩa là tại thời điểm code thực thi, hàm ajax(…) chưa có dữ liệu trả về để gán vào biến response</p>
<p>Một cách đơn giản cho thường gặp để “chờ” một hàm xử lý bất đồng bộ trả kết quả về đó là sử dụng callback:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'https://example.com/api'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response); <span class="comment">// "response" giờ đã có dữ liệu</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Chú ý: Bạn có thể viết những Ajax request đồng bộ, tuy nhiên đừng bao giờ làm thế. Nếu bạn viết Ajax như vậy thì UI sẽ bị block cứng đơ và người dùng sẽ không thể thực hiện các hành động như click, nhập dữ liệu, điều hướng, lăn chuột… Một trải nghiệm kinh khủng.</p>
<p>Đây là cách mà Ajax được viết đồng bộ, nhưng làm ơn, đừng bao giờ sử dụng nó trong app của bạn:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Giả sử bạn đang dùng jQuery</span></span><br><span class="line">jQuery.ajax(&#123;</span><br><span class="line">    url: <span class="string">'https://api.example.com/endpoint'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// callback ở đây.</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span>: <span class="literal">false</span> <span class="comment">// Một ý tưởng cực kỳ tồi tệ</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Chúng ta đã sử dụng Ajax request để ví dụ. Ngoài ra bạn có thể dùng bất kỳ đoạn code nào để thực hiện bất đồng bộ.</p>
<p>Dưới đây là ví dụ khác với hàm setTimeout(callback, milliseconds). Cách thức mà hàm setTimeout hoạt động là nó sẽ đặt 1 sự kiện (ở đây là sự kiện timeout) và để nó thực hiện sau:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'first'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'second'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">third</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'third'</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line">setTimeout(second, <span class="number">1000</span>); <span class="comment">// gọi hàm `second` sau 1000ms</span></span><br><span class="line">third();</span><br></pre></td></tr></table></figure>
<p>Và đây là kết quả của đoạn code trên:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">third</span><br><span class="line">second</span><br></pre></td></tr></table></figure>
<h1 id="Mo-xe-Event-Loop-vong-lap-su-kien"><a href="#Mo-xe-Event-Loop-vong-lap-su-kien" class="headerlink" title="Mổ xẻ Event Loop (vòng lặp sự kiện)"></a>Mổ xẻ Event Loop (vòng lặp sự kiện)</h1><p>Chúng ta sẽ bắt đầu với một chút “kỳ quặc” - mặc dù JS chấp nhận code chạy bất đồng bộ (như trường hợp của setTimeout) thì cho đến khi giới thiệu ES6, JS cũng không thực sự có một khái niệm trực tiếp nào về bất đồng bộ. Bộ engine JS chưa bao giờ làm gì vượt ra khỏi việc thực thi <strong>một</strong> khối lệnh trong chương trình của bạn tại 1 thời điểm cố định.</p>
<p>Bạn có thể xem chi tiết hơn về cách engine JS (cụ thể là Google V8) hoạt động như thế nào ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-2---Ben-trong-engine-V8---5-meo-de-toi-uu-hoa-code" target="_blank" rel="noopener">bài viết trước</a>.</p>
<p>Vậy thì ai là người ra lệnh cho engine JS phải thực thi những khối lệnh trong chương trình? Trên thực tế, engine JS không chạy cô lập, nó hoạt động bên trong một môi trường chủ (hosting environment), môi trường này đối với đa số các developer chính là trình duyệt web hoặc Node.js. Thực ra, ngày nay, JS đã và đang được nhúng vào rất nhiều loại thiết bị khác nhau, từ robot cho tới bóng đèn. Mỗi một thiết bị có thể xem như là 1 loại khác nhau của môi trường chủ cho engine JS.</p>
<p>Mẫu số chung của tất cả các môi trường đó là một cơ chế tích hợp sẵn được gọi là <strong>event-loop</strong> (vòng lặp sự kiện), nó xử lý quá trình thực thi của nhiều khối lệnh trong chương trình theo thời gian, mỗi lần đều gọi engine JS.</p>
<p>Điều này nghĩa là engine JS chỉ là 1 môi trường thực thi theo yêu cầu cho bất kỳ đoạn code JS tùy ý nào. Nó chỉ là môi trường bao quanh có lịch trình cho các sự kiện (quá trình thực thi code JS).</p>
<p>Ví dụ, khi code JS của bạn gọi Ajax request để lấy dữ liệu từ server, bạn cài đặt một đoạn code <em>response</em> trong một hàm (gọi là callback), và engine JS sẽ truyền đạt lại với môi trường chủ: <em>Này, tao chuẩn bị tạm ngưng quá trình thực thi ngay bây giờ, nhưng mà khi nào mày xong việc với request đó và có một vài cục dữ liệu thì nhớ gọi lại hàm này nhé.</em></p>
<p>Trình duyệt sau đó sẽ lắng nghe về response từ mạng, và khi nó có gì đó trả về cho bạn, nó sẽ lên lịch cho hàm callback được thực thi bằng cách chèn nó vào trong event loop</p>
<p>Cùng xem sơ đồ này nào:</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*FA9NGxNB6-v1oI2qGEtlRQ.png" alt=""></p>
<p>Bạn có thể xem lại phần bài viết về Memory Heap &amp; Call Stack trong <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-1---Khai-quat-ve-engine--runtime-va-callstack" target="_blank" rel="noopener">bài viết trước đây</a></p>
<p>Vậy thì những Web APIs này là gì? Về bản chất, chúng là những tiến trình mà bạn không thể truy xuất (access), bạn chỉ có thể gọi nó. Chúng là những thành phần của trình duyệt mà trong đó cách xử lý đồng bộ được bắt đầu. Nếu bạn là một Node.js developer thì chúng là những C++ APIs.</p>
<p><strong>Vậy cuối cùng thì event loop là cái éo gì ?</strong></p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*KGBiAxjeD9JT2j6KDo0zUg.png" alt=""></p>
<p><strong>Event Loop</strong> có một công việc đơn giản: theo dõi Call Stack và Callback Queue (hàng đợi các hàm callback). Nếu Call Stack đang trống, nó sẽ lấy event đầu tiên từ trong hàng đợi ra và đẩy nó vảo trong Call Stack - tức là thực thi nó.</p>
<p>Mỗi vòng lặp như thế được gọi là 1 <strong>tick</strong> trong Event Loop. Mỗi sự kiện chỉ là 1 hàm callback.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb1</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'cb1'</span>);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Bye'</span>);</span><br></pre></td></tr></table></figure>
<p>Cùng <em>thực thi</em> đoạn code trên và xem điều gì xảy ra nào:</p>
<ol>
<li>Trạng thái đang trống, console của trình duyệt đang trống, Call Stack đang trống. <img src="https://cdn-images-1.medium.com/max/1000/1*9fbOuFXJHwhqa6ToCc_v2A.png" alt=""></li>
<li>console.log(‘Hi’) được thêm vào Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*dvrghQCVQIZOfNC27Jrtlw.png" alt=""></li>
<li>console.log(‘Hi’) được thực thi. <img src="https://cdn-images-1.medium.com/max/1000/1*yn9Y4PXNP8XTz6mtCAzDZQ.png" alt=""></li>
<li>console.log(‘Hi’) bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*iBedryNbqtixYTKviPC1tA.png" alt=""></li>
<li>setTimeout(function cb1() { … }) được thêm vào Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*HIn-BxIP38X6mF_65snMKg.png" alt=""></li>
<li>setTimeout(function cb1() { … }) được thực thi. Trình duyệt tạo một timer - vốn là một phần của Web APIs. Nó sẽ thực hiện phần đếm ngược cho bạn. <img src="https://cdn-images-1.medium.com/max/1000/1*vd3X2O_qRfqaEpW4AfZM4w.png" alt=""></li>
<li>The setTimeout(function cb1() { … }) được thực hiện xong và bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*_nYLhoZPKD_HPhpJtQeErA.png" alt=""></li>
<li>console.log(‘Bye’) được thêm vào Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*1NAeDnEv6DWFewX_C-L8mg.png" alt=""></li>
<li>console.log(‘Bye’) được thực thi. <img src="https://cdn-images-1.medium.com/max/1000/1*UwtM7DmK1BmlBOUUYEopGQ.png" alt=""></li>
<li>console.log(‘Bye’) bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*-vHNuJsJVXvqq5dLHPt7cQ.png" alt=""></li>
<li>Sau ít nhất 5000ms, timer hoàn thành công việc của nó và đẩy cb1 callback vào trong Callback Queue. <img src="https://cdn-images-1.medium.com/max/1000/1*eOj6NVwGI2N78onh6CuCbA.png" alt=""></li>
<li>Event Loop lấy cb1 từ trong Callback Queue và đưa nó vào trong Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*jQMQ9BEKPycs2wFC233aNg.png" alt=""></li>
<li>cb1 được thực thi và nó thêm console.log(‘cb1’) vào trong Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*hpyVeL1zsaeHaqS7mU4Qfw.png" alt=""></li>
<li>console.log(‘cb1’) được thực thi. <img src="https://cdn-images-1.medium.com/max/1000/1*lvOtCg75ObmUTOxIS6anEQ.png" alt=""></li>
<li>console.log(‘cb1’) bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*Jyyot22aRkKMF3LN1bgE-w.png" alt=""></li>
<li>cb1 bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*t2Btfb_tBbBxTvyVgKX0Qg.png" alt=""></li>
</ol>
<p>Ảnh gif tổng hợp lại quá trình 16 bước ở trên:<br><img src="https://cdn-images-1.medium.com/max/1000/1*TozSrkk92l8ho6d8JxqF_w.gif" alt=""></p>
<p>Thật thú vị khi biết rằng ES6 có mô tả event loop hoạt động như thế nào, nghĩa là về mặt kỹ thuật, nó nằm trong phạm vi trách nghiệm của một JS engine, tức là không còn chỉ đóng vai trò môi trường chủ. Một lý do chính đáng cho sự thay đổi này chính là việc giới thiệu Promise trong ES6 bởi vì promise mới cần truy xuất trực tiếp, kiểm soát tối đa lịch trình điều hành đối với event loop queue (Sau này chúng ta sẽ thảo luận chi tiết hơn)</p>
<h1 id="setTimeout-…-hoat-dong-nhu-the-nao"><a href="#setTimeout-…-hoat-dong-nhu-the-nao" class="headerlink" title="setTimeout(…) hoạt động như thế nào?"></a>setTimeout(…) hoạt động như thế nào?</h1><p>Điều quan trọng cần phải biết là setTimeout(…) không tự động đặt callback vào trong event loop queue. Nó thiết lập một bộ đếm. Khi bộ đếm kết thúc, môi trường đặt callback vào trong event loop, vì thế những <strong>tick</strong> tiếp theo có thể lấy nó ra và thực thi:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(myCallback, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>Nó không có nghĩa là myCallback sẽ được thực thi sau 1000ms, mà đúng hơn là, trong 1000ms, myCallback sẽ được thêm vào trong queue. Tuy nhiên queue này có thể đang có event khác đã được thêm vào trước đó, và vì thế callback của bạn sẽ phải chờ.</p>
<p>Có một vài bài biết hoặc bài hướng dẫn dành cho người mới bắt đầu với bất đồng bộ trong JS hướng dẫn rằng ta nên setTimeout(callback, 0). Bây giờ bạn đã biết cách event loop làm việc và cách setTimeout hoạt động rồi: gọi setTimeout với thời gian là <strong>0</strong> chỉ vì mục đích hoãn callback lại cho tới khi Call Stack rỗng hoàn toàn.</p>
<p>Hãy xem ví dụ dưới đây:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callback'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Bye'</span>);</span><br></pre></td></tr></table></figure>
<p>Mặc dù thời gian chờ của callback là <em>0ms</em> nhưng kết quả in ra lại như thế này:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hi</span><br><span class="line">Bye</span><br><span class="line">callback</span><br></pre></td></tr></table></figure>
<h1 id="Jobs-cong-viec-trong-ES6-la-gi"><a href="#Jobs-cong-viec-trong-ES6-la-gi" class="headerlink" title="Jobs (công việc) trong ES6 là gì?"></a>Jobs (công việc) trong ES6 là gì?</h1><p>Một khái niệm mới gọi là <strong>Job Queue</strong> (Hàng đợi công việc) được giới thiệu trong ES6. Nó là lớp trên cùng của event loop queue. Nhiều khả năng bạn sẽ gặp phải nó khi xử lý vấn đề liên quan đến bất đồng bộ của Promise (Chúng ta sẽ nói về nó sau).</p>
<p>Bây giờ thì chúng ta chỉ tìm hiểu về mặt ý tưởng cơ bản để sau này khi thảo luận về bất đồng bộ với Promise, bạn có thể hiểu về những hành động đã được lên lịch và xử lý.</p>
<p>Tưởng tượng nó như thế này: Job queue là 1 queue được gắn vào cuối mỗi tick trong event loop queue. Mỗi hành động bất đồng bộ nhất định khi xảy ra trong 1 tick sẽ không làm cho toàn bộ event được thêm vào event loop queue nhưng thay vì thế sẽ thêm 1 item (tức là job) vào cuối job queue của tick hiện tại.</p>
<p>Điều này nghĩa là bạn có thể thêm những tính năng khác để có thể thực thi sau và bạn có thể chắc chắn rằng nó sẽ được thực thi ngay sau đó, trước bất kỳ đoạn code nào khác.</p>
<p>Một job có thể thêm nhiều job khác vào đoạn cuối của cùng 1 queue. Trên lý thuyết, job có thể lặp (loop) vô thời hạn (một job thực hiện thêm nhiều job khác, v..v…), do đó nó sẽ làm cho chương trình bị quá tải tài nguyên cần thiết để tiếp tục chạy. Về mặt khái niệm thì điều này tương tự như một công việc có thời gian thực thi dài hoặc là một vòng lặp vô hạn (ví dụ: while(true)).</p>
<p>Job cũng giống như trick setTimeout(callback, 0) (set thời gian bằng _0_) nhưng được triển khai theo cách có vẻ như “chính thống” hơn và có sự đảm bảo về thứ tự: thực hiện sau, nhưng phải làm ngay khi có thể.</p>
<h1 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h1><p>Như bạn đã biết, callback là cách phổ biến nhất để thể hiện &amp; quản lý sự bất đồng bộ trong JS. Rõ ràng, callback là mô hình bất đồng bộ cơ bản nhất trong JS. Vô số chương trình JS, kể cả những app tinh vi và phức tạp nhất thì cũng phải dùng tới callback.</p>
<p>Ngoại trừ việc callback không xuất hiện mà không có thiếu sót. Nhiều developer đang cố gắng tìm kiếm những mô hình bất đồng bộ tốt hơn. Tuy nhiên, chúng ta không thể sử dụng bất kỳ phương pháp thay thế nào khác nếu như bạn chưa thực sự hiểu rõ về callback.</p>
<p>Ở chương tiếp theo, chúng ta sẽ khám phá sâu hơn về vấn đề này để tìm hiểu tại sao những mô hình bất đồng bộ tinh vi khác (sẽ nói ở những bài sau) là cần thiết và được đề nghị nên sử dụng.</p>
<h1 id="Callback-long-nhau-nested-callback"><a href="#Callback-long-nhau-nested-callback" class="headerlink" title="Callback lồng nhau (nested callback)"></a>Callback lồng nhau (nested callback)</h1><p>Xem đoạn code dưới đây:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">listen(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ajax(<span class="string">'https://api.example.com/endpoint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">text</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (text == <span class="string">"hello"</span>) &#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">"world"</span>) &#123;</span><br><span class="line">            doSomethingElse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Chúng ta có 3 hàm lồng nhau, mỗi hàm thể hiện 1 bước trong chuỗi bất đồng bộ.</p>
<p>Kiểu code như thế này thường được gọi là <strong>callback hell</strong>. Nhưng <em>callback hell</em> thực sự không phải vấn đề về lồng nhau hay cách dòng, thụt lề. Câu chuyện thực sự sâu xa hơn thế nhiều.</p>
<p>Đầu tiên, chúng ta listen một event <em>click</em>, sau đó thì chờ timer hoạt động, rồi cuối cùng là chờ cho Ajax trả kết quả về và quá trình này có thể lặp lại nhiều lần mỗi khi chúng ta click.</p>
<p>Thoạt nhìn đoạn code này thể hiện sự đồng bộ một cách tự nhiên theo thứ tự các bước như sau:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>…rồi sau đó:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>…tiếp theo là:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'https://api.example.com/endpoint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>…và cuối cùng:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (text == <span class="string">"hello"</span>) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">"world"</span>) &#123;</span><br><span class="line">    doSomethingElse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Chà, đúng là một cách thể hiện code bất đồng bộ một cách rất tự nhiên, phải không nào? <em>cười</em></p>
<h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>Cùng xem đoạn code sau:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x + y);</span><br></pre></td></tr></table></figure>
<p>Rất rõ ràng rằng nó tính tổng của x và y rồi in kết quả ra console. Tuy nhiên, nếu như giá trị của x và y chưa tồn tại và vẫn còn đang chờ để được xác định thì sao? Giả sử chúng ta cần lấy giá trị của x và y từ server trước khi chúng được dùng để tính tổng.<br>Tưởng tượng rằng chúng ta có một hàm loadX và loadY để thực hiện load dữ liệu cho x và y từ server và một hàm để tính tổng 2 số sau khi chúng được load xong.<br>Đoạn code sẽ giống như thế này (xấu xí và phức tạp, phải không nào?):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">getX, getY, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x, y;</span><br><span class="line">    getX(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        x = result;</span><br><span class="line">        <span class="keyword">if</span> (y !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            callback(x + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    getY(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        y = result;</span><br><span class="line">        <span class="keyword">if</span> (x !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            callback(x + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Một hàm đồng bộ hoặc bất đồng bộ để get giá trị của "x"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Một hàm đồng bộ hoặc bất đồng bộ để get giá trị của "y"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchY</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line">sum(fetchX, fetchY, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Có một điều quan trọng cần phải nêu lên ở đây: trong đoạn code trên, chúng ta xem x và y như những giá trị tương lai và hàm sum() không quan tâm về việc x hay y hay cả 2 biến có hay không có tồn tại giá trị.</p>
<p>Dĩ nhiên là cách tiếp cận thô dựa trên callback này cho ta nhiều thứ đáng mong đợi. Đây chỉ là 1 bước tiến nhỏ để hiểu về ích lợi của <em>giá trị tương lai</em> mà không cần lo lắng về khía cạnh thời gian khi chúng sẵn có.</p>
<h1 id="Gia-tri-cua-Promise"><a href="#Gia-tri-cua-Promise" class="headerlink" title="Giá trị của Promise"></a>Giá trị của Promise</h1><p>Cùng xem ví dụ về x + y được thực hiện với Promise:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">xPromise, yPromise</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `Promise.all([ .. ])` nhận vào 1 mảng các promise,</span></span><br><span class="line">    <span class="comment">// và trả về 1 promise chờ đợi tất cả chúng hoàn thành</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([xPromise, yPromise])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// khi một promise được phân giải (resolve),</span></span><br><span class="line">    <span class="comment">// ta lấy giá trị x, y trả về và cộng chúng lại.</span></span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">values</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// `values` là mảng chứa giá trị của các object</span></span><br><span class="line">        <span class="comment">// từ những promise đã được resolve</span></span><br><span class="line">        <span class="keyword">return</span> values[<span class="number">0</span>] + values[<span class="number">1</span>];</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `fetchX()` và `fetchY()` trả về promise </span></span><br><span class="line"><span class="comment">// chứa kết quả tương ứng, có thể có </span></span><br><span class="line"><span class="comment">// luôn hoặc chờ sau mới có dữ liệu</span></span><br><span class="line">sum(fetchX(), fetchY())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ta có 1 promise cho tổng của 2 số.</span></span><br><span class="line"><span class="comment">// Giờ thì gọi mắt xích (chain-call) hàm `.then(...)` để chờ </span></span><br><span class="line"><span class="comment">// kết quả của promise trả về.</span></span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Có 2 lớp Promise trong đoạn code này.</p>
<p>fetchX() và fetchY() được gọi trực tiếp và giá trị trả về của chúng (<strong>promise!</strong>) được đẩy vào hàm sum(…). Giá trị mà những promise này thể hiện có thể sẵn sàng để dùng ngay lúc gọi hàm hoặc là sau đó 1 chút nhưng bất kể sớm hay muộn thì mỗi promise đều chuẩn hóa hành vi của nó cho giống nhau. Chúng ta suy đoán về giá trị của x và y theo hướng độc lập thời gian. Theo chu kỳ, chúng là những <em>giá trị tương lai</em>.</p>
<p>Lớp thứ 2 là promise do hàm sum(…) tạo ra (thông qua Promise.all([ … ])) và trả về, và cũng chờ nó get giá trị khi gọi .then(…). Khi hàm sum(…) hoàn tất, tổng <em>giá trị tương lai</em> đã sẵn sàng và có thể in nó ra. Chúng ta ẩn phần logic chờ <em>giá trị tương lai</em> của x và y trong hàm `sum(…).</p>
<p><strong>Lưu ý</strong>: <em>Bên trong sum(…), lời gọi đến Promise.all([ … ]) tạo một promise (cái này sẽ gọi đến xPromise và yPromise rồi phân giải chúng). Chain-call đến .then() sẽ tạo ra 1 promise khác và promise này sẽ trả về values[0] + values[1] ngay khi resolve (với giá trị kết quả của phép cộng). Do đó lời gọi .then(…) ta đặt ở cuối hàm .sum(…), tức là cuối đoạn code, thực ra là xử lý trên giá trị trả về của promise thứ 2 hơn là promise thứ nhất được tạo ra bởi Promise.all([ … ]). Mặc dù vậy thì chúng ta không chain-call vào cuối hàm .then(…) sau vì làm vậy sẽ tạo thêm 1 promise và ta lại phải xử lý nó. Phần Promise chain-call này sẽ được giải thích kỹ hơn ở các phần sau trong chương này.</em></p>
<p>Với Promise, lời gọi .then(…) có thể nhận 2 hàm param, hàm thứ nhất là để thực hiện thao tác với response hoàn thành (như trên), hàm thứ 2 là với trường hợp bị lỗi và bác bỏ (rejection).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sum(fetchX(), fetchY())</span><br><span class="line">.then(</span><br><span class="line">    <span class="comment">// Hàm xử lý hoàn thành</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( sum );</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Hàm xử lý bác bỏ</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error( err ); <span class="comment">// bummer!</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>Nếu có gì đó không đúng trong quá trình get x và y hoặc là có sai sót khác thì promise mà .sum(…) trả về sẽ bị reject, hàm callback thứ 2 xử lý lỗi đã được đẩy vào .then(…) sẽ nhận giá trị reject từ promise.</p>
<p>Bởi vì promise đóng gói trạng thái độc lập thời gian từ bên ngoài - chờ cho giá trị được xử lý hoàn thành/reject, và bản thân promise đã là độc lập thời gian, do đó nhiều promise có thể được kết hợp với nhau theo những cách có thể đoán trước được bất kể là thời gian hay kết quả.</p>
<p>Hơn nữa, một khi promise được resolve thì nó sẽ tồn tại vĩnh viễn: nó trở thành một giá trị <strong>bất biến</strong> tại thời điểm đó, và có thể được lấy ra sử dụng bao nhiêu lần cũng được</p>
<p>Thực sự là rất hữu ích khi ta nối promise thanhf 1 chuỗi:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        setTimeout(resolve, time);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"after 1000ms"</span>);</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"after another 2000ms"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"step 4 (next Job)"</span>);</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">5000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>Gọi hàm delay(2000) sẽ tạo ra 1 promise mà nó được hoàn thành trong 2000ms, sau đó trả nó về từ hàm hoàn thành trong .then() đầu tiên, điều này làm cho hàm .then(…) thứ hai sẽ chờ 2000ms</p>
<p><strong>Lưu ý</strong>: <em>Bởi vì giá promise là bất biến sau khi đã được resolve, chúng ta có thể truyền nó đi khắp nơi mà không cần lo lắng về việc nó bất ngờ bị thay đổi. Điều này đặc biệt có ích khi có nhiều đoạn code cùng sử dụng kết quả của 1 promise. Tính bất biến nghe có vẻ như là một chủ đề liên quan đến học thuật, nhưng thật ra nó là 1 phần rất cơ bản và có khía cạnh quan trọng trong thiết kế promise mà ta không nên bỏ qua.</em></p>
<h1 id="Promise-hay-khong-Promise"><a href="#Promise-hay-khong-Promise" class="headerlink" title="Promise hay không Promise ?"></a>Promise hay không Promise ?</h1><p>Một chi tiết quan trọng về promise là phải biết một giá trị thực sự là promise hay không phải. Nói cách khác, đó có phải là 1 giá trị sẽ hành xử như 1 promise?</p>
<p>Chúng ta biết rằng promise được xây dựng bằng lệnh new Promise(…), và bạn cho rằng p instanceof Promise là đủ để kiểm tra? Thực ra thì không hẳn.</p>
<p>Chủ yếu bởi vì bạn có thể nhận giá trị promise từ một cửa sổ trình duyệt khác (ví dụ: iframe), nó sẽ có promise riêng của nó, khác với promise trong cửa sổ/frame hiện tại của bạn, và câu lệnh check ở trên sẽ fail khi xác định instance của promise.</p>
<p>Hơn nữa, một thư viện hay framework có thể sử dụng promise của riêng nó mà không dùng promise mặc định của ES6. Thật ra, bạn có thể dùng promise của thư viện trên những trình duyệt cũ không hỗ trợ promise.</p>
<h1 id="Nuot-chung-ngoai-le-exception"><a href="#Nuot-chung-ngoai-le-exception" class="headerlink" title="Nuốt chửng ngoại lệ (exception)"></a>Nuốt chửng ngoại lệ (exception)</h1><p>Nếu trong quá trình tạo promise hoặc là khi tiếp nhận kết quả từ nó, một lỗi biệt lệ JS xảy ra, ví dụ như TypeError hoặc ReferenceError, exception sẽ được bắt, khi đó nó sẽ ép (force) cho promise đang chạy bị reject.</p>
<p>Ví dụ:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    foo.bar();    <span class="comment">// `foo` chưa được định nghĩa, lỗi!</span></span><br><span class="line">    resolve(<span class="number">374</span>); <span class="comment">// Code sẽ không đến được đây :(</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// không đến đây luôn :(</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// `err` sẽ là một object của exception`TypeError`</span></span><br><span class="line">    <span class="comment">// từ dòng `foo.bar()`.</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>Nhưng nếu như một promise được hoàn thành nhưng có lỗi exception JS trong quá trình tiếp nhận (ví dụ như trong callback của .then(…) )? Kể cả như thế thì nó cũng không bị mất, bạn sẽ thấy một chút ngạc nhiên khi biết cách mà chúng được xử lý. Đào sâu thêm 1 tí nào:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">374</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    foo.bar();</span><br><span class="line">    <span class="built_in">console</span>.log(message);   <span class="comment">// không đến được đây nè.</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// không đến được đây nè.</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>Có vẻ như exception từ foo.bar() thực sự đã bị nuốt trôi (swallow). Đúng là như thế. Có gì đó sâu hơn bên trong đã hoạt động sai tuy nhiên chúng ta lại không biết. Lời gọi p.then(…) cho chính nó trả về 1 promise khác và nó sẽ bị reject với ReferenceError exception.</p>
<h1 id="Xu-ly-nhung-biet-le-khong-bi-bat-Uncaught-exception"><a href="#Xu-ly-nhung-biet-le-khong-bi-bat-Uncaught-exception" class="headerlink" title="Xử lý những biệt lệ không bị bắt (Uncaught exception)"></a>Xử lý những biệt lệ không bị bắt (Uncaught exception)</h1><p>Có nhiều cách tiếp cận khác mà nhiều người cho rằng sẽ tốt hơn.</p>
<p>Một đề nghị phổ biến đó là promise nên có thêm một phương thức done(…), nó sẽ đánh dấu chuỗi promise là đã xong (done). .done(…)không tạo ra và trả về một promise vì thế callback truyền qua .done(…) rõ ràng là không liên quan đến việc báo cáo các vấn đề xảy ra với một chuỗi promise không tồn tại.</p>
<p>Nó hoạt động giống như bạn đã biết trong các điều kiện uncaught error: các exception bên trong một hàm reject trong .done(…) sẽ bị bắn ra ngoài developer console dưới dạng global uncaught error.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">374</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// Số number không có hàm của string,</span></span><br><span class="line">    <span class="comment">// nên sẽ bắn ra lỗi</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg.toLowerCase());</span><br><span class="line">&#125;)</span><br><span class="line">.done(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Nếu có uncaught exception ở đây thì nó sẽ bị bắn ra như là một global exception</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="Dieu-gi-xay-ra-trong-ES8-va-Async-await"><a href="#Dieu-gi-xay-ra-trong-ES8-va-Async-await" class="headerlink" title="Điều gì xảy ra trong ES8 và Async/await"></a>Điều gì xảy ra trong ES8 và Async/await</h1><p>Javascript ES8 giới thiệu async/await để giúp cho công việc xử lý promise dễ dàng hơn. Chúng ta sẽ lướt sơ qua những khả năng mà async/await cung cấp và xem thử làm thế nào để dùng chúng để viết code bất đồng bộ một cách phù hợp.</p>
<p>Vậy thì đầu tiên là xem thử hoạt động của async/await.</p>
<p>Bạn định nghĩa một hàm bất đồng bộ sử dụng định nghĩa hàm async. Những hàm như vậy sẽ trả về object <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank" rel="noopener">AsyncFunction</a>. Object AsyncFunction biểu diễn hàm bất đồng bộ trong đó nó thực thi code bên trong nó.</p>
<p>Khi một hàm async được gọi, nó sẽ trả về Promise. Khi hàm async trả về giá trị, nó lại không phải promise, một promise sẽ được tạo ra tự động và được phân giải (resolve) với giá trị trả về từ hàm. Khi hàm async bắn ra exception, promise sẽ reject với giá trị bắn ra.</p>
<p>Một hàm async có thể chứa thể hiện await, nó sẽ dừng quá trình thực thi của hàm và đợi cho promise giải quyết xong rồi quay lại thực thi tiếp và trả về giá trị đã được resolve.</p>
<p>Bạn có thể xem như promise trong JS tương tự với Java Future hay C# Task.</p>
<blockquote>
<p>Mục đích của async/await là làm đơn giản hóa quá trình sử dụng promise.</p>
</blockquote>
<p>Xem ví dụ sau:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hàm JS bình thường</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'374'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Giống như hàm trên</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getNumber2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">374</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tương tự, những hàm bắn ra exception tương tự với những hàm trả về promise bị reject:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'Some error'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'Some error'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Từ khóa await chỉ có thể được dùng bên trong hàm async và cho phép bạn chờ promise một cách đồng bộ. Nếu chúng ta sử dụng promise bên ngoài một hàm async thì phải dùng tới callback:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `rp` là một hàm gọi promise.</span></span><br><span class="line">    <span class="keyword">var</span> promise1 = rp(<span class="string">'https://api.example.com/endpoint1'</span>);</span><br><span class="line">    <span class="keyword">var</span> promise2 = rp(<span class="string">'https://api.example.com/endpoint2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hiện tại cả 2 request đều được gọi đồng thời và</span></span><br><span class="line">    <span class="comment">// ta phải đợi cho nó hoàn thành.</span></span><br><span class="line">    <span class="keyword">var</span> response1 = <span class="keyword">await</span> promise1;</span><br><span class="line">    <span class="keyword">var</span> response2 = <span class="keyword">await</span> promise2;</span><br><span class="line">    <span class="keyword">return</span> response1 + <span class="string">' '</span> + response2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bởi vì ta không ở trong hàm `async` </span></span><br><span class="line"><span class="comment">// nên chúng ta phải dùng `then()`.</span></span><br><span class="line">loadData().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Done'</span>));</span><br></pre></td></tr></table></figure>
<p>Bạn có thể định nghĩa hàm async bằng cách sử dụng async function expression (AFE - Thể hiện hàm async). Một AFE tương tự và gần giống như một async function statement (AFS). Điểm khác biệt chính giữa AFE và AFS là tên của hàm, trong AFE ta có thể bỏ qua tên để tạo hàm vô danh (anonymous function). Một AFE có thể sử dụng như một IIFE (<a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" target="_blank" rel="noopener">Immediately Invoked Function Expression</a>), loại hàm được thực thi ngay sau khi nó được định nghĩa.</p>
<p>Nó trông như thế này:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadData = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `rp` là một hàm gọi promise.</span></span><br><span class="line">    <span class="keyword">var</span> promise1 = rp(<span class="string">'https://api.example.com/endpoint1'</span>);</span><br><span class="line">    <span class="keyword">var</span> promise2 = rp(<span class="string">'https://api.example.com/endpoint2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hiện tại cả 2 request đều được gọi đồng thời và</span></span><br><span class="line">    <span class="comment">// ta phải đợi cho nó hoàn thành.</span></span><br><span class="line">    <span class="keyword">var</span> response1 = <span class="keyword">await</span> promise1;</span><br><span class="line">    <span class="keyword">var</span> response2 = <span class="keyword">await</span> promise2;</span><br><span class="line">    <span class="keyword">return</span> response1 + <span class="string">' '</span> + response2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Quan trọng là async/await được hỗ trợ và có thể chạy trên đa số các trình duyệt:</p>
<p> <a href="https://cdn-images-1.medium.com/max/1000/0*z-A-JIe5OWFtgyd2." target="_blank" rel="noopener"><img src="https://cdn-images-1.medium.com/max/1000/0*z-A-JIe5OWFtgyd2." alt=""></a> <a></a></p>
<p>Nếu như trình duyệt nào không hỗ trợ thì ta vẫn có thể sử dụng các JS transpiler như <a href="https://babeljs.io/docs/plugins/transform-async-to-generator/" target="_blank" rel="noopener">Babel</a> hay <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html" target="_blank" rel="noopener">TypeScript</a></p>
<p>Cuối cùng thì điều quan trọng nhất là không nên chọn lựa một cách mù quáng những cách tiếp cận “mới nhất” để viết code bất đồng bộ. Tốt hơn là bạn hiểu về cấu trúc bất đồng bộ của JS, nghiên cứu tại sao nó lại là một vấn đề nghiêm túc và hiểu một cách sâu sắc về các thành phần bên trong của giải pháp mà bạn lựa chọn. Mỗi cách tiếp cận khác nhau đều có những điểm mạnh và điểm yếu, hãy cân nhắc.</p>
<h1 id="5-meo-de-viet-code-bat-dong-bo-vua-chac-chan-vua-de-bao-tri"><a href="#5-meo-de-viet-code-bat-dong-bo-vua-chac-chan-vua-de-bao-tri" class="headerlink" title="5 mẹo để viết code bất đồng bộ vừa chắc chắn vừa dễ bảo trì"></a>5 mẹo để viết code bất đồng bộ vừa chắc chắn vừa dễ bảo trì</h1><h3 id="1-Clean-code-code-sach"><a href="#1-Clean-code-code-sach" class="headerlink" title="1. Clean code (code sạch):"></a>1. <strong>Clean code (code sạch)</strong>:</h3><p>Sử dụng async/await cho phép bạn viết code ít hơn nhiều. Mỗi lần sử dụng async/await bạn có thể bỏ qua một số bước không cần thiết, ví dụ: .then(), viết hàm anonymous để xử lý responsive, đặt tên response từ callback…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `rp` là một hàm gọi promise</span></span><br><span class="line">rp(‘https:<span class="comment">//api.example.com/endpoint1').then(function(data) &#123;</span></span><br><span class="line"> <span class="comment">// …</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>…so với</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `rp` là một hàm gọi promise</span></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> rp(‘https:<span class="comment">//api.example.com/endpoint1');</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Xu-ly-loi"><a href="#2-Xu-ly-loi" class="headerlink" title="2. Xử lý lỗi:"></a>2. <strong>Xử lý lỗi</strong>:</h3><p>Async/await giúp chúng ta có thể xử lý cả lỗi đồng bộ và bất đồng bộ với cùng một cấu trúc code: chính là try/catch nổi tiếng. Ví dụ:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// Catches synchronous errors.</span></span><br><span class="line">        getJSON().then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> parsed = <span class="built_in">JSON</span>.parse(response);</span><br><span class="line">            <span class="built_in">console</span>.log(parsed);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// Catches asynchronous errors</span></span><br><span class="line">            <span class="built_in">console</span>.log(e); </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>…so với</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">await</span> getJSON());</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Dieu-kien"><a href="#3-Dieu-kien" class="headerlink" title="3. Điều kiện:"></a>3. <strong>Điều kiện</strong>:</h3><p>Viết code điều kiện với async/await rõ ràng hơn rất nhiều:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response.needsAnotherRequest) &#123;</span><br><span class="line">        <span class="keyword">return</span> makeAnotherRequest(response)</span><br><span class="line">          .then(<span class="function"><span class="keyword">function</span>(<span class="params">anotherResponse</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(anotherResponse)</span><br><span class="line">            <span class="keyword">return</span> anotherResponse</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>…so với</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> response = <span class="keyword">await</span> getJSON();</span><br><span class="line">  <span class="keyword">if</span> (response.needsAnotherRequest) &#123;</span><br><span class="line">    <span class="keyword">var</span> anotherResponse = <span class="keyword">await</span> makeAnotherRequest(response);</span><br><span class="line">    <span class="built_in">console</span>.log(anotherResponse)</span><br><span class="line">    <span class="keyword">return</span> anotherResponse</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="keyword">return</span> response;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Stack-Frames"><a href="#4-Stack-Frames" class="headerlink" title="4. Stack Frames:"></a>4. <strong>Stack Frames</strong>:</h3><p>Không giống như async/await, stack lỗi trả về từ một chuỗi promise làm chúng ta không biết lỗi xuất phát từ đâu mà lần:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> callAPromise()</span><br><span class="line">    .then(callback1)</span><br><span class="line">    .then(callback2)</span><br><span class="line">    .then(callback3)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"boom"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">loadData()</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line"><span class="comment">// Error: boom at callAPromise.then.then.then.then (index.js:8:13)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>…so với</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> callAPromise1()</span><br><span class="line">  <span class="keyword">await</span> callAPromise2()</span><br><span class="line">  <span class="keyword">await</span> callAPromise3()</span><br><span class="line">  <span class="keyword">await</span> callAPromise4()</span><br><span class="line">  <span class="keyword">await</span> callAPromise5()</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"boom"</span>);</span><br><span class="line">&#125;</span><br><span class="line">loadData()</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="comment">// Error: boom at loadData (index.js:7:9)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="5-Qua-trinh-Debug"><a href="#5-Qua-trinh-Debug" class="headerlink" title="5. Quá trình Debug:"></a>5. <strong>Quá trình Debug</strong>:</h3><p>Nếu bạn đã từng sử dụng promise, bạn sẽ biết rằng debug với chúng thực sự là ác mộng. Giả sử bạn đặt breakpoint bên trong .then() và dùng những lệnh debug như stop-over, debugger sẽ không đi đến .then() tiếp theo bởi vì nó “lỡ chân” bước vào code bất đồng bộ.<br>Với async/await bạn có thể duyệt qua những lời gọi await chính xác như những hàm đồng bộ thông thường.</p>
<p><strong>Viết code Javascript bất đồng bộ là rất quan trọng không chỉ cho app mà cả cho những thư viện nữa</strong>.</p>
<span>Source: </span><a href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5" target="_blank" title="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5" class="post-from">https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2018/11/Cach-Javascript-hoat-dong-P5-Hieu-sau-ve-WebSocket-HTTP-2-voi-SSE.html" class="prev">NEXT</a><a href="/2018/11/Cach-Javascript-hoat-dong-P3-Quan-ly-bo-nho-4-truong-hop-memory-leaks-pho-bien.html" class="next">PREV</a></div><div class="copyright"><p>© 2017 - 2019 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>