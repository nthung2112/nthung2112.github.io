<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Cách Javascript hoạt động P10: Quan sát thay đổi trên DOM bằng MutationObserver · Learn and Share</title><meta name="description" content="Cách Javascript hoạt động P10: Quan sát thay đổi trên DOM bằng MutationObserver - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Cách Javascript hoạt động P10: Quan sát thay đổi trên DOM bằng MutationObserver"><meta property="og:image"><meta property="og:description" content="Chào các bạn đến với bài thứ 10 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.

Webapp càng ngày càng nặng hơn ở phía client bởi vì nhiều lý do đại loại như UI phải “phì nhiêu” để chứa đựng những thứ logic phức tạp bên trong bao gồm cả tính toán theo thời gian thực (real-time), và nhiều nhiều thứ khác nữa.
Sự phức tạp gia tăng làm cho chúng ta khó nắm bắt chính xác trạng thái của UI tại mỗi thời điểm trong vòng đời của webapp.
Điều này càng khó hơn nữa nếu chúng ta xây dựng một vài thứ chẳng hạn như library hay framework mà cần phải phản ứng cũng như xử lý những hành động dựa trên DOM."></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Cách Javascript hoạt động P10: Quan sát thay đổi trên DOM bằng MutationObserver</h1><h2 class="post-subtitle"></h2><header class="post-info">Nov 25, 2018<div class="tags"><a href="/tags/javascript" class="tag-link">#javascript</a></div><div class="fb-ir-time"><time datetime="2018-11-25T08:24:00.000Z" class="op-modified"></time><time datetime="2018-11-25T08:24:00.000Z" class="op-published"></time></div></header></div><div class="wrap"><div class="post-content"><p>Chào các bạn đến với bài thứ 10 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/0*mPXf5zRCdEQ42Hn0." alt=""></p>
<p>Webapp càng ngày càng nặng hơn ở phía client bởi vì nhiều lý do đại loại như UI phải “phì nhiêu” để chứa đựng những thứ logic phức tạp bên trong bao gồm cả tính toán theo thời gian thực (real-time), và nhiều nhiều thứ khác nữa.</p>
<p>Sự phức tạp gia tăng làm cho chúng ta khó nắm bắt chính xác trạng thái của UI tại mỗi thời điểm trong vòng đời của webapp.</p>
<p>Điều này càng khó hơn nữa nếu chúng ta xây dựng một vài thứ chẳng hạn như library hay framework mà cần phải phản ứng cũng như xử lý những hành động dựa trên DOM.<br><a id="more"></a></p>
<h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a> (tạm dịch: Người quan sát sự biến đổi) là một WebAPI được các trình duyệt hiện đại cung cấp để phát hiện các thay đổi trên DOM. Với API này một người có thể listen các node mới được thêm vào hoặc gỡ ra, thuộc tính thay đổi hoặc những thay đổi về nội dung văn bản trong một text node.</p>
<p>Tại sao phải cần làm thế?</p>
<p>Có một số ít trường hợp trong đó MutationObserver API thực sự hữu ích. Ví dụ:</p>
<ul>
<li>Bạn muốn thông báo cho người dùng webapp rằng một vài sự thay đổi đã xảy ra trên trang mà người đó đang sử dụng.</li>
<li>Bạn đang làm việc với 1 Javascript framework sang chảnh mới, nó cần load rất nhiều JS module một cách tự động dựa trên sự thay đổi của DOM.</li>
<li>Bạn đang làm việc với bộ soạn thảo WYSIWYG và thử triển khai tính năng undo/redo. Bằng cách tận dụng MutationObserver API, bất kỳ lúc nào bạn cũng có thể biết phần nào đã thay đổi và dễ dàng undo chúng.</li>
</ul>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*48tGIboHxgLeKEjMTGkUGg.png" alt=""></p>
<p>Trên đây chỉ là 1 số ví dụ về lợi ích của MutationObserver.</p>
<h1 id="Cach-su-dung-MutationObserver"><a href="#Cach-su-dung-MutationObserver" class="headerlink" title="Cách sử dụng MutationObserver"></a>Cách sử dụng MutationObserver</h1><p>Triển khai MutationObserver khá dễ dàng. Bạn cần tạo 1 instance MutationObserver bằng cách truyền cho nó 1 hàm và hàm này được gọi mỗi khi 1 sự thay đổi xảy ra. Đối số đầu tiên của hàm là 1 tập hợp tất cả các sự thay đổi xảy ra trên 1 khối duy nhất. Mỗi sự thay đổi cung cấp thông tin về loại của nó cũng như thay đổi nào đã xảy ra.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutationObserver = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</span><br><span class="line">  mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mutation);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Object tạo ra có 3 phương thức:</p>
<ul>
<li><strong>observe</strong>: bắt đầu lắng nghe sự thay đổi. Nó nhận 2 đối số: DOM node mà bạn muốn quan sát và một object chưa các thiết lập.</li>
<li><strong>disconnect</strong>: dừng quá trình lắng nghe thay đổi.</li>
<li><strong>takeRecords</strong>: trả về khối thay đổi cuối cùng trước khi callback được kích hoạt.</li>
</ul>
<p>Đoạn code sau thể hiện quá trình quan sát (observing) diễn ra:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bắt đầu lắng nghe thay đổi trong root HTML của trang.</span></span><br><span class="line">mutationObserver.observe(<span class="built_in">document</span>.documentElement, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span>,</span><br><span class="line">  characterData: <span class="literal">true</span>,</span><br><span class="line">  childList: <span class="literal">true</span>,</span><br><span class="line">  subtree: <span class="literal">true</span>,</span><br><span class="line">  attributeOldValue: <span class="literal">true</span>,</span><br><span class="line">  characterDataOldValue: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Giờ giả sử ta có 1 div cực kỳ đơn giản trong DOM:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"sample-div"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"test"</span>&gt; Simple div &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>Sử dụng jQuery, bạn có thể xóa thuộc tính class từ div đó:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#sample-div"</span>).removeAttr(<span class="string">"class"</span>);</span><br></pre></td></tr></table></figure>
<p>Khi đã bắt đầu quan sát, sau khi gọi hàm mutationObserver.observe(…) ta có thể xem thông tin log được in ra trong console của <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord" target="_blank" rel="noopener">MutationRecord</a>.</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*UxkSstuyCvmKkBTnjbezNw.png" alt=""></p>
<p>Đây là sự biến đổi tạo ra bởi ta đã xóa thuộc tính class.</p>
<p>Cuối cùng, để dừng sự quan sát DOM sau khi đã xong việc, ta làm như sau:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dừng MutationObserver, không lắng nghe thay đổi nữa.</span></span><br><span class="line">mutationObserver.disconnect();</span><br></pre></td></tr></table></figure>
<p>Ngày nay MutationObserver được hỗ trợ khá tốt:</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/0*nlOmrsfy-Y1XoR8B." alt=""></p>
<h1 id="Giai-phap-thay-the"><a href="#Giai-phap-thay-the" class="headerlink" title="Giải pháp thay thế"></a>Giải pháp thay thế</h1><p>Tuy nhiên, MutationObserver cũng chỉ mới xuất hiện chưa lâu. Vậy thì trước khi có nó, các developer dùng cái gì?</p>
<p>Dưới đây là 1 vài lựa chọn:</p>
<ul>
<li><strong>Polling</strong></li>
<li><strong>MutationEvents</strong></li>
<li><strong>CSS animations</strong></li>
</ul>
<h2 id="Polling"><a href="#Polling" class="headerlink" title="Polling"></a>Polling</h2><p>Giải pháp đơn giản nhất và kém tinh tế nhất là polling (bỏ phiếu bình chọn). Sử dụng WebAPI setInterval bạn có thể thiết lập 1 tác vụ kiểm tra sự thay đổi theo chu kỳ nhất định. Dĩ nhiên thì cách này làm giảm hiệu năng của webapp 1 cách đáng sợ.</p>
<h2 id="MutationEvents"><a href="#MutationEvents" class="headerlink" title="MutationEvents"></a>MutationEvents</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events" target="_blank" rel="noopener">MutationEvents API</a> được giới thiệu vào năm 2000. Mặc dù nó có ích, các sự kiện thay đổi (mutation events) được bắn ra mỗi khi có 1 sự thay đổi bất kỳ trên DOM và một lần nữa làm ảnh hưởng đến hiệu năng. Ngày nay thì MutationEvents API đã bị hủy bỏ và những trình duyệt hiện đại sẽ sớm ngừng hỗ trợ nó.</p>
<p>Danh mục trình duyệt hỗ trợ cho MutationEvents:</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/0*l-QdpBfjwNfPDTyh." alt=""></p>
<h2 id="CSS-animations"><a href="#CSS-animations" class="headerlink" title="CSS animations"></a>CSS animations</h2><p>Một giải pháp thay thế hơi kỳ cục đó là dựa trên <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations" target="_blank" rel="noopener">CSS Animations</a>. Nghe có vẻ bối rối nhỉ. Về cơ bản thì ý tưởng của nó là tạo ra 1 animation có thể được trigger khi có một element được thêm vào DOM. Khoảnh khắc animation bắt đầu, sự kiện animationstart sẽ được bắn ra: nếu bạn đã gắn 1 event handler vào sự kiện đó thì bạn sẽ biết 1 cách chính xác khi nào element được thêm vào DOM. Thời gian thực hiện của animation phải cực nhỏ để cho nó dường như vô hình trước con mắt user.</p>
<p>Đầu tiên ta cần một element cha, bên trong nó ta sẽ listen sự kiện chèn node:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=”container-element”&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>Để có thể xử lý khi có node chèn vào, ta cần thiết lập một chuỗi các <a href="https://www.w3schools.com/cssref/css3_pr_animation-keyframes.asp" target="_blank" rel="noopener">keyframe</a> animation khởi động khi node được thêm vào:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@keyframes nodeInserted &#123; </span><br><span class="line"> <span class="keyword">from</span> &#123; <span class="attr">opacity</span>: <span class="number">0.99</span>; &#125;</span><br><span class="line"> to &#123; <span class="attr">opacity</span>: <span class="number">1</span>; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Với keyframe được tạo ra đó, animation cần phải được áp dụng vào các element mà ta muốn lắng nghe. Lưu ý là thời gian duration rất nhỏ, mục đích là để kéo dãn dấu vết của animation trên trình duyệt:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#container-element * &#123;</span><br><span class="line"> animation-duration: <span class="number">0.001</span>s;</span><br><span class="line"> animation-name: nodeInserted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bước thiết lập này sẽ thêm animation vào tất cả các node con của container-element. Khi animation kết thúc (sau 0.001s như trên), sự kiện chèn node sẽ được bắn ra.</p>
<p>Ta cần một hàm event listener Javascript. Trong hàm đó ta phải gọi event.animationName để đảm bảo đó chính là animation mà ta cần.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertionListener = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Đảm bảo đây là animation mà ta cần xử lý.</span></span><br><span class="line">  <span class="keyword">if</span> (event.animationName === <span class="string">"nodeInserted"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Node has been inserted: "</span> + event.target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Giờ thì thêm event listener vào node cha:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(“animationstart”, insertionListener, <span class="literal">false</span>); <span class="comment">// standard + firefox</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(“MSAnimationStart”, insertionListener, <span class="literal">false</span>); <span class="comment">// IE</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(“webkitAnimationStart”, insertionListener, <span class="literal">false</span>); <span class="comment">// Chrome + Safari</span></span><br></pre></td></tr></table></figure>
<p>Trình duyệt hỗ trợ CSS animation:</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/0*W4wHvVAeUmc45vA2." alt=""></p>
<p>MutationObserver cung cấp một số tính năng nâng cao hơn tất cả 3 giải pháp trên. Về bản chất, nó bao phủ toàn bộ mỗi thay đổi có thể diễn ra trên DOM và nó được tối ưu hóa khi bắn ra các thay đổi trong 1 chuỗi hàng loạt. Trên hết MutationObserver được hỗ trợ bởi tất cả các trình duyệt hiện đại đi kèm với 1 số polyfills để dùng MutationEvents</p>
<p>MutationObserver chiếm giữ một vị trí trung tâm trong thư viện của <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=mutation-observer-post" target="_blank" rel="noopener">SessionStack</a>.</p>
<p>Khi bạn đã tích hợp thư viện của SessionStack vào webapp, nó bắt đầu thu thập các thông tin chẳng hạn như thay đổi trên DOM, request mạng, biệt lệ, thông báo debug, vân vân, và gửi chúng về server. SessionStack dùng chính những dữ liệu này để tái tạo lại mọi thứ đã xảy ra với user của bạn và hiển thị các vấn đề của sản phẩm trong cùng 1 tình huống mà nó diễn ra với user. Khá nhiều người nghĩ rằng SessionStack ghi lại video, nhưng không phải vậy. Ghi video rất tốn kém, mặt khác lượng dữ liệu thu thập được lại rất nhẹ và không ảnh hưởng đến UX cũng như hiệu năng của webapp của bạn.</p>
<span>Source: </span><a href="https://blog.sessionstack.com/how-javascript-works-tracking-changes-in-the-dom-using-mutationobserver-86adc7446401" target="_blank" title="https://blog.sessionstack.com/how-javascript-works-tracking-changes-in-the-dom-using-mutationobserver-86adc7446401" class="post-from">https://blog.sessionstack.com/how-javascript-works-tracking-changes-in-the-dom-using-mutationobserver-86adc7446401</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2018/11/Cach-Javascript-hoat-dong-P11-Render-engine-meo-toi-uu-hoa-hieu-nang-render.html" class="prev">NEXT</a><a href="/2018/11/Cach-Javascript-hoat-dong-P9-Cau-tao-cua-Web-Push-Notifications.html" class="next">PREV</a></div><div class="copyright"><p>© 2017 - 2019 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>