<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Cách Javascript hoạt động P5: Hiểu sâu về WebSocket & HTTP/2 với SSE · Learn and Share</title><meta name="description" content="Cách Javascript hoạt động P5: Hiểu sâu về WebSocket &amp; HTTP/2 với SSE - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Cách Javascript hoạt động P5: Hiểu sâu về WebSocket &amp; HTTP/2 với SSE"><meta property="og:image"><meta property="og:description" content="Chào các bạn đến với bài thứ 5 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.
Trong phần này chúng ta sẽ đào sâu với thế giới của những giao thức giao tiếp, ánh xạ (mapping) và thảo luận về những thuộc tính cũng như thành phần của chúng. Chúng ta sẽ đưa ra 1 so sánh nhỏ giữa WebSockets và HTTP/s. Cuối cùng, team SessionStack sẽ chia sẻ một vài ý tưởng về việc lựa chọn phương thức nào cho phù hợp với giao thức mạng."></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Cách Javascript hoạt động P5: Hiểu sâu về WebSocket & HTTP/2 với SSE</h1><h2 class="post-subtitle"></h2><header class="post-info">Nov 16, 2018<div class="tags"><a href="/tags/javascript" class="tag-link">#javascript</a></div><div class="fb-ir-time"><time datetime="2018-11-16T00:04:00.000Z" class="op-modified"></time><time datetime="2018-11-16T00:04:00.000Z" class="op-published"></time></div></header></div><div class="wrap"><div class="post-content"><p>Chào các bạn đến với bài thứ 5 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p>
<p>Trong phần này chúng ta sẽ đào sâu với thế giới của những giao thức giao tiếp, ánh xạ (mapping) và thảo luận về những thuộc tính cũng như thành phần của chúng. Chúng ta sẽ đưa ra 1 so sánh nhỏ giữa WebSockets và HTTP/s. Cuối cùng, team SessionStack sẽ chia sẻ một vài ý tưởng về việc lựa chọn phương thức nào cho phù hợp với giao thức mạng.<br><a id="more"></a></p>
<h1 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu"></a>Giới thiệu</h1><p>Ngày nay những webapp phức tạp có nhiều tính năng, UI động xuất hiện như trăm hoa đua nở. Cũng không phải bất ngờ, internet cũng đã phát triển được một quãng đường khá dài kể từ khi bắt đầu.</p>
<p>Ban đầu, internet không được xây dựng để dành cho những app động và phức tạp. Nó được hình thành như là một tập hợp của các trang HTML, kết nối với nhau để cấu thành nên khái niệm về “Web” chứa thông tin. Phần lớn mọi thứ được xây dựng xung quanh mô hình request/response nổi tiếng của HTTP. Một client tải trang và không có gì xảy ra cho đến khi user bắt đầu click và di chuyển đến trang tiếp theo.</p>
<p>Khoảng năm 2005, AJAX được giới thiệu và rất nhiều người đã khám phá khả năng tạo kết nối giữa client và server theo 2 chiều (<strong>bidirectional</strong>). Và vẫn như thế, tất cả giao tiếp HTTP được chỉ đạo bởi client yêu cầu user tương tác hoặc thực hiện theo chu kỳ để lấy dữ liệu mới từ server.</p>
<h1 id="Tao-mot-HTTP-“2-chieu”"><a href="#Tao-mot-HTTP-“2-chieu”" class="headerlink" title="Tạo một HTTP “2 chiều”"></a>Tạo một HTTP “2 chiều”</h1><p>Công nghệ cho phép server gửi dữ liệu về client một cách “chủ động” đã phát triển được 1 thời gian. Push và Comet là ví dụ.</p>
<p>Một trong số mẹo nổi tiếng để tạo ra ảo giác rằng server đang gửi dữ liệu về client được gọi là long polling. Với long polling, client mở kết nối HTTP đến server và giữ nó tiếp tục mở cho đến khi có response trả về. Mỗi khi server có dữ liệu mới cần được gửi, nó chuyển giao thông tin dưới dạng một response.</p>
<p>Cùng xem một ví dụ đơn giản về long polling:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">poll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $.ajax(&#123; </span><br><span class="line">        url: <span class="string">'https://api.example.com/endpoint'</span>, </span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// Làm gì đó với `data`</span></span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// Cài đặt poll mới theo đệ quy</span></span><br><span class="line">          poll();</span><br><span class="line">        &#125;, </span><br><span class="line">        dataType: <span class="string">'json'</span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, <span class="number">10000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>Đây là một hàm tự thực thi cơ bản chạy một cách tự động lần đầu tiên. Nó sẽ cài đặt một khoảng thời gian 10 giây và sau mỗi lời gọi Ajax bất đồng bộ đến server, callback lại gọi ajax lần nữa.</p>
<p>Vài kỹ thuật khác có thể kể đến như <a href="http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/net/Socket.html" target="_blank" rel="noopener">Flash</a>, request nhiều thành phần XHR và <a href="http://cometdaily.com/2007/12/27/a-standards-based-approach-to-comet-communication-with-rest/" target="_blank" rel="noopener">htmlfiles</a> nổi tiếng.</p>
<p>Tất cả những phương pháp này đều có chung một vấn đề: Chúng qua mặt HTTP, làm cho chúng không phù hợp với những app có độ trễ thấp. Giả sử như game bắn súng nhiều người chơi trên trình duyệt hoặc bất kỳ game onlinen nào có đối thủ thực.</p>
<h1 id="Gioi-thieu-WebSockets"><a href="#Gioi-thieu-WebSockets" class="headerlink" title="Giới thiệu WebSockets"></a>Giới thiệu WebSockets</h1><p>Thông số kỹ thuật của WebSocket định nghĩa một kết nối API dạng “socket” (ổ cắm điện!) giữa trình duyệt và server. Theo nghĩa đen thì có 1 kết nối cố định giữa client và server và cả 2 bên có thể gửi dữ liệu bất kỳ lúc nào.</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*a4lA5FYDkjA9mv53NPKtOg.png" alt=""></p>
<p>Client thiết lập một kết nối WebSocket thông qua một tiến trình được gọi là WebSocket handshake (bắt tay WebSocket). Tiến trình này bắt đầu với client gửi một request HTTP thông thường đến server. Nó kèm theo header Upgrade để thông báo cho server rằng client muốn tạo một kết nối WebSocket.</p>
<p>Cùng xem thử quá trình mở kết nối WebSocket như thế nào ở phía client:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new WebSocket with an encrypted connection.</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://websocket.example.com'</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WebSocket URL sử dụng ws scheme. Chúng ta còn có cả wss cho những kết nối WebSocket bảo mật hơn, tương tự như HTTPS.</p>
</blockquote>
<p>Scheme này bắt đầu một tiến trình mở kết nối WebSocket đến websocket.example.com.</p>
<p>Dưới đây là 1 ví dụ đơn giản của header của request khởi tạo.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET ws:<span class="comment">//websocket.example.com/ HTTP/1.1</span></span><br><span class="line">Origin: http:<span class="comment">//example.com</span></span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: websocket.example.com</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>
<p>Nếu server hỗ trợ giao thức WebSocket, nó sẽ đồng ý để nâng cấp và giao tiếp thông qua header Upgrade trong response.</p>
<p>Cùng xem phần thiết lập của nó trong Node.js như thế nào:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chúng ta sẽ dùng https://github.com/theturtle32/WebSocket-Node</span></span><br><span class="line"><span class="comment">// Triển khai WebSocket</span></span><br><span class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'websocket'</span>).server;</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// xử lý HTTP request. </span></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tạo server</span></span><br><span class="line">wsServer = <span class="keyword">new</span> WebSocketServer(&#123;</span><br><span class="line">  httpServer: server</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// WebSocket server</span></span><br><span class="line">wsServer.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> connection = request.accept(<span class="literal">null</span>, request.origin);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Đây là callback quan trọng nhất,chúng ta sẽ </span></span><br><span class="line">  <span class="comment">// xử lý thông tin của client ở đây.</span></span><br><span class="line">  connection.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Xử lý thông tin WebSocket</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  connection.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">connection</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Đóng kết nối</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Sau khi thành lập kết nối, server trả về:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="built_in">Date</span>: Wed, <span class="number">25</span> Oct <span class="number">2017</span> <span class="number">10</span>:<span class="number">07</span>:<span class="number">34</span> GMT</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: WebSocket</span><br></pre></td></tr></table></figure>
<p>Khi kết nối đã được thiết lập, sự kiện open sẽ được bắn ra cho instance WebSocket ở phía client:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://websocket.example.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hiện thông báo khi kết nối WebSocket thành công.</span></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'WebSocket is connected.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Giờ thì quá trình “bắt tay” đã hoàn tất, kết nối khởi tạo HTTP được thay thế bằng WebSocket và sử dụng cùng loại nền tảng kết nối TCP/IP. Tại thời điểm này, cả 2 bên đều có thể gửi dữ liệu.</p>
<p>Với WebSocket, bạn có thể truyền bao nhiêu thông tin tùy thích mà không cần phải gánh chịu những chi phí không đáng có liên quan đến request HTTP truyền thống. Dữ liệu được truyền đi thông qua WebSocket dưới dạng tin nhắn (message), mỗi tin nhắn bao gồm một hoặc nhiều <em>frame</em> chứa dữ liệu bạn gửi đi (gọi là <em>kiện hàng</em> - <em>payload</em>). Để đảm bảo message có thể tái cấu trúc một cách chính xác khi nó đến với client, mỗi frame được gán cứng từ 4-12 byte thông tin về payload. Sử dụng hệ thống thông tin dựa trên frame như thế này giúp giảm tải khối lượng dữ liệu dư thừa (non-payload data) phải truyền đi, có thể làm cho độ trễ giảm đi đáng kể.</p>
<p><strong>Lưu ý</strong>: <em>Đặc biệt chú ý là client chỉ được thông báo về message mới một khi tất cả frame đều được nhận và payload message gốc được tái cấu trúc đầy đủ</em></p>
<h1 id="WebSocket-URLs"><a href="#WebSocket-URLs" class="headerlink" title="WebSocket URLs"></a>WebSocket URLs</h1><p>Chúng ta có đề cập sơ qua về WebSocket URL scheme ở trên. Trong thực thế, chúng giới thiệu có 2 scheme mới là ws:// và wss://</p>
<p>URL có cấu trúc ngữ pháp cụ thể về scheme. WebSocket URL đặc biệt vì nó không hỗ trợ nhóm ký tự anchor (có dấu thăng ở trước, ví dụ: #đây_là_anchor).</p>
<p>Có những luật chung được áp dụng cho cả style của WebSocket URL và HTTP URL. ws không được mã hóa, nó có cổng mặc định là 80 trong khi đó wss yêu cầu mã hóa TLS và dùng cổng 443 mặc định.</p>
<h1 id="Framing-protocol-Giao-thuc-framing"><a href="#Framing-protocol-Giao-thuc-framing" class="headerlink" title="Framing protocol (Giao thức framing)"></a>Framing protocol (Giao thức framing)</h1><p>Cùng đào sâu một chút về framing protocol với những gì <a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC</a> cung cấp:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                     <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (<span class="number">4</span>)  |A|     (<span class="number">7</span>)     |             (<span class="number">16</span>/<span class="number">64</span>)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (<span class="keyword">if</span> payload len==<span class="number">126</span>/<span class="number">127</span>)   |</span><br><span class="line">| |<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, <span class="keyword">if</span> payload len == <span class="number">127</span>  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, <span class="keyword">if</span> MASK set to <span class="number">1</span>  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>Theo như RFC định nghĩ về WebSocket thì nó chỉ có duy nhất một header trước mỗi gói tin, và nó khá phức tạp. Chúng ta cùng tìm hiểu:</p>
<ul>
<li>fin (1 bit): biểu thị nếu frame đó là frame cuối cùng tạo nên message. Hầu hết message đều có thể chứa trong một frame duy nhất và bit này luôn có giá trị. Thực nghiệm cho thấy Firefox tạo 1 frame thứ 2 sau mỗi 32K.</li>
<li>rsv1, rsv2, rsv3 (Mỗi thứ 1 bit): phải bằng 0 trừ khi có một <a href="https://tools.ietf.org/html/rfc6066" target="_blank" rel="noopener">extension</a> (đại khái như tiện ích mở rộng) được trao đổi và nó định nghĩa ý nghĩa cho giá trị khác 0. Nếu nhận về một giá trị khác 0 và không có extension nào xác định ý nghĩa của giá trị khác 0 đó được trao đổi thì người nhận cuối sẽ bị mất kết nối.</li>
<li>opcode (4 bit): nó cho biết những gì frame đại diện. Có những giá trị sau đây được dùng:<ul>
<li>0x00: frame này tiếp tục payload từ frame trước đó.</li>
<li>0x01: frame này chứa dữ liệu chữ (text).</li>
<li>0x02: frame này chứa dữ liệu nhị phân (binary).</li>
<li>0x08: frame này hủy kết nối.</li>
<li>0x09: frame này là ping.</li>
<li>0x0a: frame này là pong.</li>
</ul>
</li>
</ul>
<p>(Bạn có thể thấy rằng có nhiều giá trị không sử dụng, chúng được dự trữ cho tương lai khi cần)</p>
<ul>
<li>mask (1 bit): biểu thị nếu kết nối đã được che đậy (mask). Rõ ràng là mỗi message từ client đến server <em>phải được che đậy</em> và về mặt kỹ thuật thì nó sẽ hủy kết nối nếu không được che đậy.</li>
<li>payload_len (7 bit): độ dài của payload. WebSocket frame có những độ dài theo các khoảng tính theo byte như sau:<ul>
<li>0-125 biểu thị độ dài của payload</li>
<li>Nếu là 126 byte thì 2 byte tiếp theo biểu thị độ dài payload dưới dạng số nguyên 16bit không dấu</li>
<li>Nếu là 127 byte thì 8 byte tiếp theo biểu thị độ dài payload dưới dạng số nguyên 64bit không dấu</li>
<li>Vậy là độ dài payload sẽ vào khoảng ~7bit, 16bit hoặc 64bit.</li>
</ul>
</li>
<li>masking-key (32 bit): tất cả frame được gửi từ client đến server sẽ được che đậy (mask) bằng một giá trị 32bit đính kèm trong frame.</li>
<li>payload: Dữ liệu thật sự cần được che đậy. Độ dài của nó chính là payload_len</li>
</ul>
<p>Tại sao WebSocket lại dựa trên frame (frame-based) mà không dựa trên dòng chảy (stream-based)? Có trời mới biết, tác giả cũng không biết vì sao nên nếu bạn có thông tin gì về điều này thì có thể nhắn tin đến tác giả. Ngoài ra thì có <a href="https://news.ycombinator.com/item?id=3377406" target="_blank" rel="noopener">một topic thảo luận rất tốt về vấn đề này trên HackerNews</a>, bạn có thể tham khảo.</p>
<h1 id="Du-lieu-tren-frame"><a href="#Du-lieu-tren-frame" class="headerlink" title="Dữ liệu trên frame"></a>Dữ liệu trên frame</h1><p>Như đã nói ở trên, dữ liệu có thể phân mảnh thành nhiều frame. Frame đầu tiên chuyển giao dữ liệu có một opcode biểu thị kiểu dữ liệu đang được truyền. Điều này cần thiết bởi vì Javascript hầu như không có hỗ trợ cho kiểu dữ liệu nhị phân (binary) khi nó được xây dựng. 0x01 biểu thị kiểu encode văn bản UTF-8, 0x02 là dữ liệu nhị phân. Đa số mọi người sẽ chuyển giao JSON trong trường hợp bạn muốn chọn opcode văn bản. Khi bạn phát tín hiệu (emit) dữ liệu nhị phân nó sẽ được thể hiện trên trình duyệt dưới dạng cụ thể là <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a>.</p>
<p>API để gửi dữ liệu thông qua WebSocket khá đơn giản:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://websocket.example.com'</span>);</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  socket.send(<span class="string">'Some message'</span>); <span class="comment">// Gửi dữ liệu đến server.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Khi WebSocket nhận dữ liệu (ở phía client), một sự kiện message được bắn ra. Sự kiện này bao gồm một thuộc tính gọi là data có thể dùng để truy cập nội dung của message.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Xử lý message gửi đi từ server.</span></span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = event.data;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Bạn có thể khám phá dữ liệu một cách dễ dàng trong mỗi frame trong kết nối WebSocket sử dụng tab Network trong Chrome DevTools:</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*Sz4wI2ukt91vRrgf8UonWw.png" alt=""></p>
<h1 id="Su-phan-manh"><a href="#Su-phan-manh" class="headerlink" title="Sự phân mảnh"></a>Sự phân mảnh</h1><p>Dữ liệu payload có thể được chia thành nhiều frame riêng. Nơi nhận có nhiệm vụ lưu đệm chúng cho đến khi bit fin được set. Thế nên bạn có thể chuyển 1 chuỗi “Hello World” trong 11 gói tin của 6 (độ dài header) + 1 byte cho mỗi gói. Sự phân mảnh không được chấp nhận cho gói tin điều khiển (control packages). Tuy nhiên, đặc điểm kỹ thuật muốn bạn có thể xử lý những frame điều khiển xen kẽ nhau. Đó là trường hợp gói tin TCP nhận được có thứ tự lộn xộn.</p>
<p>Logic để kết nối frame được mô tả sơ lược như sau:</p>
<ul>
<li>Nhận frame đầu tiên</li>
<li>Ghi nhớ opcode</li>
<li>Nối các frame payload lại với nhau cho đến khi bit fin được set.</li>
<li>Giả định rằng opcode cho mỗi gói tin là 0</li>
</ul>
<p>Mục đích chính của sự phân mảnh là cho phép gửi message khi không biết rõ kích thước ban đầu của message. Với sự phân mảnh, server có thể chọn một kích thước buffer (bộ đệm) phù hợp và khi buffer đầy thì ghi mảnh (fragment) đó vào network. Trường hợp sử dụng phụ của sự phân mảnh là truyền tin đa luồng (multiplexing), vốn dĩ không cần một message lớn trên một kênh logic để tiếp nhận toàn bộ kênh đầu ra, vì thế multiplexing cần phải giải phóng để cắt message ra thành nhiều mảnh để có thể chia sẻ đến kênh đầu ra tốt hơn.</p>
<h1 id="Heartbeating-nhip-tim-la-gi"><a href="#Heartbeating-nhip-tim-la-gi" class="headerlink" title="Heartbeating (nhịp tim) là gì ?"></a>Heartbeating (nhịp tim) là gì ?</h1><p>Tại một thời điểm sau khi “bắt tay” (handshake), cả client và server có thể lựa chọn để gửi đi một ping đến phía kia. Khi ping được nhận, người nhận phải gửi ngược lại một pong ngay khi có thể. Đó gọi là heartbeat (nhịp tim đập). Bạn có thể dùng nó để đảm bảo client vẫn đang được kết nối.</p>
<p>Một ping hay pong chỉ là frame bình thường, không phải frame điều khiển. Ping có opcode là 0x9 và opcode của pong là 0xA. Khi bạn nhận được ping, gửi ngược lại pong với chính xác cùng dữ liệu Payload như ping (với ping và pong thì độ dài payload tối đa là 125). Bạn cũng có thể nhận được pong mà chưa từng gửi ping. Nếu nó xảy ra thì bỏ qua, quên nó đi.</p>
<p>Heartbeat có thể rất có ích. Có nhiều dịch vụ (chẳng hạn như bộ cân bằng tải - load balancer) sẽ hủy những kết nối đứng yên (idle). Thêm nữa, bên nhận không thể biết nếu bên kia (bên gửi) đã bị kết thúc hay chưa. Chỉ có đến lần gửi thông tin tiếp theo ta mới nhận ra có gì đó không ổn.</p>
<h1 id="Xu-ly-loi"><a href="#Xu-ly-loi" class="headerlink" title="Xử lý lỗi"></a>Xử lý lỗi</h1><p>Bạn có thể xử lý bao nhiêu lỗi xảy ra cũng được bằng cách listen đến sự kiện error.<br>Ví dụ:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://websocket.example.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Xử lý lỗi xảy ra.</span></span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'WebSocket Error: '</span> + error);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Dong-ket-noi"><a href="#Dong-ket-noi" class="headerlink" title="Đóng kết nối"></a>Đóng kết nối</h1><p>Để đóng kết nổi thì client hoặc server phải gửi một frame điều khiển với dữ liệu chứa opcode 0x8. Ngay khi nhận được frame đó thì bên nhận sẽ gửi trả một frame đóng (close). Bên gửi sẽ đóng kết nối. Bất kỳ thông tin nào nhận được sau khi đóng kết nối đều bị vứt bỏ.</p>
<p>Đây là cách bạn khởi tạo quá trình đóng kết nối WebSocket từ client:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Đóng nếu kết nối đang được mở.</span></span><br><span class="line"><span class="keyword">if</span> (socket.readyState === WebSocket.OPEN) &#123;</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Để thực hiện dọn dẹp sau khi đóng kết nối thành công, bạn có thể thêm một event listener vào sự kiện close:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dọn dẹp những thứ cần thiết.</span></span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Disconnected from WebSocket.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Server lắng nghe sự kiện close để xử lý nếu cần:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reasonCode, description</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Kết nối đang bị đóng.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="So-sanh-WebSockets-va-HTTP-2"><a href="#So-sanh-WebSockets-va-HTTP-2" class="headerlink" title="So sánh WebSockets và HTTP/2"></a>So sánh WebSockets và HTTP/2</h1><p>Trong khi HTTP/2 cung cấp nhiều thứ, nó lại không hoàn toàn thay thế sự cần thiết cho các công nghệ push/streaming hiện có.</p>
<p>Điều quan trọng đầu tiên về HTTP/2 mà ta cần chú ý là nó không phải là một thay thế cho tất cả HTTP. Những động từ, mã status và đa số các loại header sẽ vẫn như cũ. HTTP/2 hướng đến cải thiện sự hiệu quả trong cách mà dữ liệu truyền trên đường dây.</p>
<p>Giờ nếu so sánh HTTP/2 với WebSocket thì ta có nhiều thứ tương đồng:</p>
<table>
<thead>
<tr>
<th></th>
<th>HTTP/2</th>
<th>WebSocket</th>
</tr>
</thead>
<tbody>
<tr>
<td>Headers</td>
<td>Được nén (HPACK)</td>
<td>Không nén</td>
</tr>
<tr>
<td>Binary</td>
<td>Có</td>
<td>Nhị Phân hoặc Văn Bản</td>
</tr>
<tr>
<td>Multiplexing</td>
<td>Có</td>
<td>Có</td>
</tr>
<tr>
<td>Sự ưu tiên</td>
<td>Có</td>
<td>Không</td>
</tr>
<tr>
<td>Nén</td>
<td>Có</td>
<td>Có</td>
</tr>
<tr>
<td>Đinh hướng</td>
<td>Client/Server hoặc là Server Push</td>
<td>2 chiều</td>
</tr>
<tr>
<td>Full-duplex</td>
<td>Có</td>
<td>Có</td>
</tr>
</tbody>
</table>
<p>Như đã thấy ở trên, HTTP/2 giới thiệu tính năng <a href="https://en.wikipedia.org/wiki/Push_technology?oldformat=true" target="_blank" rel="noopener">Server Push</a> để cho phép server gửi tài nguyên một cách chủ động đến bộ đệm phía client. Tuy nhiên, nó không cho phép tự ý push dữ liệu xuống client. Server push chỉ được xử lý bằng browser và không được bật trong code của ứng dụng, nghĩa là không có API cho app để get thông báo từ những sự kiện như thế này.</p>
<p>Đây là nơi Sự kiện server gửi thông tin (Server-Sent Events - SSE) trở nên rất có ích. SSE là 1 cơ chế cho phép server push dữ liệu bất đồng bộ về client một khi kết nối client-server được thiết lập. Server có thể lựa chọn để gửi dữ liệu khi nào một “cục” dữ liệu mới đã sẵn sàng. Nó có thể được cân nhắc như là mô hình đăng ký-xuất bản (<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" target="_blank" rel="noopener">publish-subscribe</a>) 1 chiều. Nó cũng cung cấp một chuẩn Javascript client API tên là EventSource được triển khai trong đa số các trình duyệt hiện đại như là 1 phần của tiêu chuẩn HTML5 bởi <a href="https://www.w3.org/TR/eventsource/" target="_blank" rel="noopener">W3C</a>. Chú ý rằng trình duyệt không hỗ trợ <a href="http://caniuse.com/#feat=eventsource" target="_blank" rel="noopener">EventSource API</a> cũng có thể dễ dàng polyfill.</p>
<p>Bởi vì SSE dựa trên HTTP, nó có thể phù hợp với HTTP/2 và có thể kết hợp để đạt được sự tốt nhất của cả 2 bên: HTTP/2 xử lý tầng giao vận (transport layer) hiệu quả dựa trên các luồng multiplex và SSE cung cấp API cho app để thực hiện push.</p>
<p>Để hiểu hoàn toàn về Stream và Multiplexing, đầu tiên ta cần biết sơ lược về định nghĩa tại IETF: <em>một “stream” là chuỗi tuần tự 2 chiều và độc lập của nhiều frame được trao đổi giữa client và server trong một kết nối HTTP/2. Mộ trong số những đặc tính chính của nó là một kết nối HTTP/2 có thể chứa đồng thời nhiều stream đang mở với frame endpoint xen kẽ từ nhiều stream.</em></p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*pSh7IORJoUXbwCjyJ7fM9A.png" alt=""></p>
<p>Phải nhớ rằng SSE là dựa trên HTTP. Nghĩa là với HTTP/2, không chỉ nhiều stream SSE được xen kẽ trên một kết nối TCP mà cũng cơ chế đó có thể thực hiện với sự kết hợp của nhiều stream SSE (push từ server đến client) và nhiều client request (client đến server). Nhờ ơn HTTP/2 và SSE mà giờ đây chúng ta đã có một kết nối HTTP 2 chiều thuần túy với API đơn giản để code ứng dụng có thể đăng ký cho server push. Thiếu đi khả năng giao tiếp 2 chiều thường được xem như là một bước cải lùi khi so sánh SSE với WebSocket. Cảm ơn HTTP/2, nhờ nó mà điều này không còn là vần đề nữa. Thêm nữa là nó mở ra cơ hội để bỏ qua WebSocket và tập trung vào những công nghệ thay thế dựa trên HTTP.</p>
<h1 id="Lam-the-nao-de-chon-giua-WebSocket-amp-HTTP-2"><a href="#Lam-the-nao-de-chon-giua-WebSocket-amp-HTTP-2" class="headerlink" title="Làm thế nào để chọn giữa WebSocket &amp; HTTP/2?"></a>Làm thế nào để chọn giữa WebSocket &amp; HTTP/2?</h1><p>WebSocket chắc chắn sẽ tồn tại trong sự thống trị của HTTP/2 + SSE, chủ yếu bởi vì nó là công nghệ đã được đón nhận và trong nhiều trường hợp cụ thể nó có sự vượt trội so với HTTP/2 như cách nó được xây dựng cho khả năng giao tiếp 2 chiều với ít chi phí tốn kém (ví dụ: headers).</p>
<p>Giả sử bạn muốn xây dựng game MMO (Massive Multiplayer Online: Game nhiều người chơi trực tuyến) cần một lượng khổng lồ message từ cả 2 đầu kết nối. Trong những trường hợp như thế thì WebSocket thể hiện rất rất tốt.</p>
<p>Tổng quát thì sử dụng WebSocket khi nào bạn cần một kết nối với độ trễ rất thấp, gần như là realtime giữa client &amp; server. Nhớ kỹ rằng việc này có thể yêu cầu bạn cân nhắc lại cách xây dựng ứng dụng server-side của bạn, cũng như chuyển sang tập trung vào những công nghệ như event queue.</p>
<p>Nếu trường hợp của bạn cần hiển thị tin tức thị trường, dữ liệu thị trường, ứng dụng chat… theo thời gian thực, sử dụng HTTP/2 + SSE sẽ cung cấp cho bạn kênh giao tiếp 2 chiều hiệu quả trong khi gặt hái nhiều lợi ích khi hoạt động trong thế giới của HTTP:</p>
<ul>
<li>WebSocket thường gây ra khó khăn khi cân nhắc sự tương thích với hạ tầng web hiện tại cũng như nó nâng cấp kết nối HTTP đến một giao thức hoàn toàn khác mà không có gì dính dáng tới HTTP.</li>
<li>Mở rộng và bảo mật: những thành phần của web (firewall, phát hiện xâm nhập, cân bằng tải) được xây dựng, bảo trì và thiết đặt với tư tưởng của HTTP, một môi trường cho ứng dụng lớn và nghiêm ngặt sẽ ưu tiên khả năng phục hồi, bảo vật và khả năng mở rộng.</li>
</ul>
<p>Bạn cũng cần phải cân nhắc về vấn đề hỗ trợ của trình duyệt:</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*YFr59cEF2qxzjjleebvbcQ.png" alt=""></p>
<p>Khá tốt phải không nào?</p>
<p>Nhưng với HTTP/2 thì không hẳn:</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*C1VWSKOx89vqdiSiflDRJw.png" alt=""></p>
<ul>
<li>Chỉ có TLS (Cũng không tệ lắm)</li>
<li>Hỗ trợ một phần cho IE11 nhưng chỉ trên Windows 10</li>
<li>Chỉ hỗ trợ OSX 10.11 trở lên trên Safari</li>
<li>Chỉ hỗ trợ HTTP/2 nếu bạn có thể điều hướng nó qua APLN (server của bạn cũng cần phải hỗ trợ nó rõ ràng)</li>
</ul>
<p>Hỗ trợ SSE thì tốt hơn một chút:</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*9ryMUEZhtbTg7lECHVz0fw.png" alt=""></p>
<p>Chỉ có IE/Edge là không hỗ trợ (Opera Mini cũng thế). Vẫn có những polyfill khá tốt để giúp chúng ta làm viêc với SSE trên IE/Edge.</p>
<h1 id="SessionStack-lua-chon-nhu-the-nao"><a href="#SessionStack-lua-chon-nhu-the-nao" class="headerlink" title="SessionStack lựa chọn như thế nào?"></a>SessionStack lựa chọn như thế nào?</h1><p>Team SessionStack sử dụng cả 2 WebSocket và HTTP, tùy thuộc vào từng trường hợp. Một khi bạn đã tích hợp SessionStack vào web app của bạn, nó sẽ ghi lại mọi thứ diễn ra trên app/website: những thay đổi trên DOM, tương tác của người dùng, JS exception, stack trace, những request bị fail và cả thông báo debug, cho phép bạn chạy lại (replay) những issue đã xảy ra dưới dạng video và xem chúng diễn ra như thế nào với người dùng. Tất cả đều hoạt động theo thời gian thực (real-time) và không ảnh hưởng đến hiệu năng của webapp.</p>
<p>Điều đó nghĩa là bạn có thể tham gia vào một phiên làm việc của user, trong khi user đang hoạt động trên trình duyệt. Trong trường hợp này, team tác giả chọn sử dụng HTTP bởi vì không cần giao tiếp 2 chiều (server chỉ cần stream dữ liệu đến trình duyệt). Nếu dùng WebSocket ở đây thì sẽ rất tệ, càng khó để bảo trì và mở rộng.</p>
<p>Tuy nhiên, thư viện SessionStack tích hợp vào trong webapp của bạn sử dụng WebSocket (nếu có thể, còn không thì HTTP). Nó sắp xếp và gửi dữ liệu về server và cũng là giao tiếp 1 chiều. Team tác giả chọn WebSocket vì trong trường hợp này vài tính năng cần thiết sử dụng giao tiếp 2 chiều.</p>
<span>Source: </span><a href="https://blog.sessionstack.com/how-javascript-works-deep-dive-into-websockets-and-http-2-with-sse-how-to-pick-the-right-path-584e6b8e3bf7" target="_blank" title="https://blog.sessionstack.com/how-javascript-works-deep-dive-into-websockets-and-http-2-with-sse-how-to-pick-the-right-path-584e6b8e3bf7" class="post-from">https://blog.sessionstack.com/how-javascript-works-deep-dive-into-websockets-and-http-2-with-sse-how-to-pick-the-right-path-584e6b8e3bf7</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2018/11/Cach-Javascript-hoat-dong-P6-So-sanh-voi-WebAssembly-Mot-so-truong-hop-tot-hon-nen-su-dung.html" class="prev">NEXT</a><a href="/2018/11/Cach-Javascript-hoat-dong-P4-Event-loop-lap-trinh-bat-dong-bo-5-meo-cai-thien-Async-Await.html" class="next">PREV</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>