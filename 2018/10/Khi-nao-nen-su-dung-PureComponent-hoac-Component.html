<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Khi nào nên sử dụng PureComponent hoặc Component · Learn and Share</title><meta name="description" content="Khi nào nên sử dụng PureComponent hoặc Component - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Khi nào nên sử dụng PureComponent hoặc Component"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*tkTyHS3bla2rVXEh5YjCng.jpeg"><meta property="og:description" content="PureComponent tiền đề của nó là một phiên bản có hiệu suất cao hơn của Component. Điều này là đúng, nhưng hiệu suất đạt được đi cùng với một vài thứ đi kèm. Chúng ta hãy tìm hiểu về PureComponent và hiểu tại sao chúng ta nên sử dụng nó nhé."></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Khi nào nên sử dụng PureComponent hoặc Component</h1><h2 class="post-subtitle"></h2><header class="post-info">Oct 17, 2018<div class="tags"><a href="/tags/react" class="tag-link">#react</a></div><div class="fb-ir-time"><time datetime="2018-10-17T00:57:00.000Z" class="op-modified"></time><time datetime="2018-10-17T00:57:00.000Z" class="op-published"></time></div></header></div><div class="post-banner"><img src="https://cdn-images-1.medium.com/max/2000/1*tkTyHS3bla2rVXEh5YjCng.jpeg"></div><div class="wrap"><div class="post-content"><p>PureComponent tiền đề của nó là một phiên bản có hiệu suất cao hơn của Component. Điều này là đúng, nhưng hiệu suất đạt được đi cùng với một vài thứ đi kèm. Chúng ta hãy tìm hiểu về PureComponent và hiểu tại sao chúng ta nên sử dụng nó nhé.<br><a id="more"></a></p>
<h2 id="Component-va-PureComponent-co-mot-su-khac-biet"><a href="#Component-va-PureComponent-co-mot-su-khac-biet" class="headerlink" title="Component và PureComponent có một sự khác biệt"></a>Component và PureComponent có một sự khác biệt</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PureComponent chính xác giống như Component ngoại trừ việc đó là nó xử lý shouldComponentUpdate cho bạn.</span><br></pre></td></tr></table></figure>
<p>Khi props hoặc state thay đổi, PureComponent sẽ làm một <em>shallow comparison</em> (so sánh nông) trên cảm props và state. Component trên mặt khác sẽ không so sánh props và state của hiện tại với tương lai. Như vậy, component sẽ re-render bởi mặc định bất cứ khi nào shouldComponentUpdate gọi.</p>
<h2 id="Shallow-Comparison-101"><a href="#Shallow-Comparison-101" class="headerlink" title="Shallow Comparison 101"></a>Shallow Comparison 101</h2><p>Khi so sánh props và state trước và sau, một <em>shallow comparison</em> sẽ kiểm tra những giá trị nguyên thuỷ đó có cùng giá trị(ví dụ 1 bằng 1 hoặc <em>true</em> bằng với <em>true</em>) và rằng các <em>references value</em> là giống nhau giữa các giá trị javascript phức tạp như objects và arrays.</p>
<h2 id="Never-MUTATE"><a href="#Never-MUTATE" class="headerlink" title="Never MUTATE"></a>Never MUTATE</h2><p>Bạn có lẽ đã nghe không thay đổi objects và arrays trong props và state. Nếu bạn thay đổi object trong một component cha, component “pure” con của bạn sẽ không update. Mặc dù giá trị đã thay đổi ở component cha, component con sẽ so sánh <em>reference</em> tới props trước đó và không phát hiện ra sự khác biệt chúng vân cùng reference tới cùng một object.</p>
<p>Thay vào đó trả về một objects mới khi bạn làm một sự thay đổi bằng cách tận dụng es6 cho object và array <em>spreading</em> hoặc sử dụng một thư viện để thi hành <em>immutability</em>.</p>
<h2 id="Co-van-de-voi-hieu-nang-khong"><a href="#Co-van-de-voi-hieu-nang-khong" class="headerlink" title="Có vấn đề với hiệu năng không?"></a>Có vấn đề với hiệu năng không?</h2><p>So sánh primitives và object references là một hoặt động <strong>vô cùng rẻ tiền</strong>. Nếu bạn có một danh sách của object con và một trong đó update, làm một kiểm tra trên props và state của chúng là so sánh nhanh như ánh sáng so với chi phí của việc re-render từng cái một.</p>
<h1 id="Nhung-cach-khac-ban-co-the-lam-de-tang-hieu-nang"><a href="#Nhung-cach-khac-ban-co-the-lam-de-tang-hieu-nang" class="headerlink" title="Những cách khác bạn có thể làm để tăng hiệu năng"></a>Những cách khác bạn có thể làm để tăng hiệu năng</h1><h3 id="Dung-bind-gia-tri-vao-fuction-trong-render"><a href="#Dung-bind-gia-tri-vao-fuction-trong-render" class="headerlink" title="Đừng bind giá trị vào fuction trong render"></a>Đừng bind giá trị vào fuction trong render</h3><p>Bạn có một danh sách các items, mỗi lần chuyền một tham số độc nhất tới phương thức cha. Theo thứ tự bind parameter bạn có lẽ sẽ hoàn thành như thê này:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CommentItem likeComment=&#123;() =&gt; <span class="keyword">this</span>.likeComment(user.id)&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>vấn đề đó là mỗi lần component cha render method sẽ gọi, một function mới (với một reference mới) được tạo ra và chuyền xuống <strong>LikeComnent</strong>. Điều này có side effect của thay đổi props trên mỗi component con mà lần lượt sẽ là nguyên nhân tât cả chúng re-render, thậm chí tất cả dữ liệu là giống nhau.</p>
<p>Để giải quyết vấn đề này, chỉ cần chuyền function nguyên mẫu từ component cha tới con. prop của <strong>LikeComent</strong> sẽ luôn luôn có cùng reference và không bao giờ gây ra re-render không cần thiết.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CommentItem likeComment=&#123;<span class="keyword">this</span>.likeComment&#125; userID=&#123;user.id&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>Sau đó trong component con tạo ra một class method sẽ reference props của nó:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentItem</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  handleLike() &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.likeComment(<span class="keyword">this</span>.props.userID)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dung-lay-du-lieu-trong-render"><a href="#Dung-lay-du-lieu-trong-render" class="headerlink" title="Đừng lấy dữ liệu trong render"></a>Đừng lấy dữ liệu trong render</h3><p>Xem xét một danh sách của các bài viết từ đó component hồ sơ của bạn sẽ hiển thị 10 người dùng bạn thích nhất.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; posts &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="keyword">const</span> topTen = [...posts].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> </span><br><span class="line">    b.likes - a.likes).slice(<span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TopTen</strong> sẽ có một <em>new reference</em> mỗi lần component re-render, mặc dù <strong>posts</strong> không có sự thay đổi và dữ liệu có cùng nguồn gốc. Điều này sau đó sẽ re-render list một cách không cần thiết.</p>
<p>Bạn có thể giải quyết điều này bởi <em>caching</em> dữ liệu gốc. Cho ví dụ, đặt dữ liệu gốc trong state của component và update chỉ khi <strong>posts</strong> có updated.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setTopTenPosts(<span class="keyword">this</span>.props.posts)</span><br><span class="line">&#125;</span><br><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.posts !== nextProps.posts) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setTopTenPosts(nextProps.posts)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTopTenPosts(posts) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    topTen: [...posts].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.likes - a.likes).slice(<span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Nếu bạn sử dụng Redux, xem xét sử dụng <a href="https://github.com/reduxjs/reselect" target="_blank" rel="noopener">reselect</a> để tạo “selectors” để soạn và cache dữ liệu gốc.</p>
<h1 id="Tong-ket"><a href="#Tong-ket" class="headerlink" title="Tổng kết"></a>Tổng kết</h1><p>An toàn khi sử dụng pureComponent thay thế Component miễn là bạn theo hai quy tắc đơn giản sau:</p>
<ol>
<li>Thay đổi đột ngột <strong>reference value</strong> nhìn chung là không tốt. Nhưng vấn đề là phức tạp khi sử dụng PureComponent.</li>
<li>Nếu bạn tạo ra một function, object, array mới trong render bạn (có lẽ) làm nó sai.</li>
</ol>
<span>Source: </span><a href="https://codeburst.io/when-to-use-component-or-purecomponent-a60cfad01a81" target="_blank" title="https://codeburst.io/when-to-use-component-or-purecomponent-a60cfad01a81" class="post-from">https://codeburst.io/when-to-use-component-or-purecomponent-a60cfad01a81</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2018/11/Mot-so-nguyen-tac-dinh-luat-trong-lap-trinh.html" class="prev">NEXT</a><a href="/2018/09/Redux-hay-MobX-Ly-giai-su-nham-lan.html" class="next">PREV</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>