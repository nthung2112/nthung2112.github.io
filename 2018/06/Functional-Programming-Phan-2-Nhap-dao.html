<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Functional Programming - Phần 2 - Nhập đạo · Learn and Share</title><meta name="description" content="Functional Programming - Phần 2 - Nhập đạo - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Functional Programming - Phần 2 - Nhập đạo"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*KPy3bUBCUFy6zqNFZys9lQ.png"><meta property="og:description" content="Như vậy, Functional Programming là nghệ thuật lập trình trong đó ta:

sử dụng functions để điều khiển workflow
tuân thủ 2 nguyên tắc immutability và purity

Nói cách khác, chư vị tin hữu muốn tu luyện Functional Programming thì phải giữ đạo tâm trong sáng, ý chí kiên định, hàng ngày chiêm nghiệm, suy diễn, cảm ngộ function, tu vi theo đó sẽ không ngừng thăng tiến.
Nhưng làm thế nào để cảm ngộ “phân sần ý cảnh”? Ta phải nắm bắt, quan sát, tư duy, suy tưởng về function ra sao? Sau đây là những pháp quyết nhập môn."></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Functional Programming - Phần 2 - Nhập đạo</h1><h2 class="post-subtitle"></h2><header class="post-info">Jun 16, 2018<div class="tags"><a href="/tags/functional programming" class="tag-link">#functional programming</a></div><div class="fb-ir-time"><time datetime="2018-06-16T08:43:00.000Z" class="op-modified"></time><time datetime="2018-06-16T08:43:00.000Z" class="op-published"></time></div></header></div><div class="post-banner"><img src="https://cdn-images-1.medium.com/max/2000/1*KPy3bUBCUFy6zqNFZys9lQ.png"></div><div class="wrap"><div class="post-content"><p>Như vậy, Functional Programming là nghệ thuật lập trình trong đó ta:</p>
<ul>
<li>sử dụng functions để điều khiển workflow</li>
<li>tuân thủ 2 nguyên tắc immutability và purity</li>
</ul>
<p>Nói cách khác, chư vị tin hữu muốn tu luyện Functional Programming thì phải giữ đạo tâm trong sáng, ý chí kiên định, hàng ngày chiêm nghiệm, suy diễn, cảm ngộ function, tu vi theo đó sẽ không ngừng thăng tiến.</p>
<p>Nhưng làm thế nào để cảm ngộ “phân sần ý cảnh”? Ta phải nắm bắt, quan sát, tư duy, suy tưởng về function ra sao? Sau đây là những pháp quyết nhập môn.<br><a id="more"></a></p>
<h3 id="Higher-order-function"><a href="#Higher-order-function" class="headerlink" title="Higher-order function"></a>Higher-order function</h3><p>Higher-order function là một khái niệm đến từ Toán học. Bất cứ hàm nào tiếp nhận 1 function như tham số, hoặc trả về 1 function như kết quả, thì đều được coi là higher-order function.</p>
<p>Dưới đây là 1 ví dụ, hàm getItem nhận vào hàm by mô tả điều kiện, lại trả về 1 hàm khác. Nó thừa tiêu chuẩn để gọi là higher-order function.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getItem = <span class="function"><span class="params">by</span> =&gt;</span> arr =&gt; by;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hoặc phiên bản chi tiết</span></span><br><span class="line"><span class="keyword">const</span> getItem = <span class="function">(<span class="params">by</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> by(arr);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Lập trình phong cách Functional Programming là khiêu vũ với các functions.</p>
<p>Trong Functional Programming, hầu như mọi functions đều là higher-order function, vì chúng đều có thể nhận vào và ném ra các functions.</p>
<p>Nhưng như vậy thì có lợi ích gì? Nó đơn giản cung cấp cho ta một cách khác để lập luận và suy diễn. Chẳng hạn như với hàm getItem trên kia cho phép bạn biến hóa rất nhiều dạng, tùy vào cách bạn thao túng by.</p>
<p>Khi bạn viết getItem, bạn không cần biết sau này sẽ phải kiểm tra điều kiện ra sao, cũng không quan tâm sẽ nhận được đầu vào như thế nào.</p>
<p>Bạn có thể tạo ra hàm tìm số lớn nhất trong 1 mảng toàn số như sau:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tạo hàm engine lấy max number từ mảng</span></span><br><span class="line"><span class="keyword">const</span> maxNumber = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...arr);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rồi truyền vào getItem để được hàm cần thiết</span></span><br><span class="line"><span class="keyword">const</span> getMaxNumber = getItem(maxNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thử xem sao</span></span><br><span class="line">getMaxNumber([<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="comment">// =&gt; 8</span></span><br></pre></td></tr></table></figure>
<p>Thế sao không truyền thẳng cái mảng số kia vào maxNumber cho khỏe? Vì trong thiết kế này ta đang cư xử với maxNumber như plugin. Còn nhiều plugins khác nữa. Ta không gọi trực tiếp plugin mà gọi qua 1 giao diện tổng quát hơn.</p>
<p>Giờ ta lại có dữ liệu 1 nhóm người như sau:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> members = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Alice'</span>,</span><br><span class="line">    height: <span class="number">165</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    height: <span class="number">152</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Celina'</span>,</span><br><span class="line">    height: <span class="number">178</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Dan'</span>,</span><br><span class="line">    height: <span class="number">194</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Eric'</span>,</span><br><span class="line">    height: <span class="number">187</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>Ta muốn tìm người cao nhất trong nhóm thì sao? Hãy thêm 1 plugin khác.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bạn tạo 1 hàm engine lấy max height từ mảng</span></span><br><span class="line"><span class="keyword">const</span> maxHeight = <span class="function">(<span class="params">people</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> people.reduce(<span class="function">(<span class="params">prev, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev.height &gt; current.height ? prev : current;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rồi truyền vào getItem để được hàm cần thiết</span></span><br><span class="line"><span class="keyword">const</span> getTallestPerson = getItem(maxHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thử xem sao</span></span><br><span class="line">getTallestPerson(members);</span><br><span class="line"><span class="comment">// =&gt; &#123; name: 'Dan', height: 194 &#125;</span></span><br></pre></td></tr></table></figure>
<p>Ví dụ trên tuy tầm thường, nhưng có thể là gợi ý tốt để bạn dùng higher-order function thiết kế những chương trình linh hoạt, dễ mở rộng.</p>
<h3 id="Function-Composition"><a href="#Function-Composition" class="headerlink" title="Function Composition"></a>Function Composition</h3><p>Đây là <a href="https://www.mathsisfun.com/sets/functions-composition.html" target="_blank" rel="noopener">khái niệm Toán học</a> mà tiếng Việt ta gọi là “hàm hợp”, hay “hàm phức hợp”. Mọi thứ trong Functional Programming đều có nguồn gốc Toán học.</p>
<p>Function Composition là sự phối hợp, liên kết nhiều hàm lại với nhau, thành một hàm lớn, nhiều chức năng hơn.</p>
<p>Có 2 kỹ thuật căn bản trong Function Composition là compose và pipe.</p>
<h4 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h4><p>Hãy nhớ lại, trong không gian Functional Programming tồn tại vô số pure functions nhỏ gọn, đơn giản. Đúng triết lý “do one thing and do it well” của UNIX.</p>
<p>Vì mỗi hàm chỉ làm 1 việc, khi muốn thực hiện nhiều hành động lên cùng một input, ta chỉ việc kết hợp các hàm cần thiết lại với nhau.</p>
<p>Bây giờ chúng ta hãy tạm ngừng tu luyện, tạm quên tu vi để nhập phàm, quan sát và cảm ngộ nhân sinh.</p>
<p>Lần này, bạn hóa thành con trai thứ 4 trong gia đình một thôn dân sinh sống dưới chân núi Tản Viên bằng nghề bán thịt…</p>
<p>Một hôm bạn xin được khúc cây lớn ở chỗ ông chú làm kiểm lâm kiêm lâm tặc.</p>
<p> <img src="https://i.imgur.com/OQofkz2.jpg" alt=""></p>
<p>Từ khúc gỗ này, bạn muốn làm ra cái thớt cho nhà dùng.</p>
<p>Là tu sĩ mới nhập môn tu luyện Functional Programming, tuy không có tu vi, nhưng bạn vẫn hình dung được sẽ cần đến các pure functions sau:</p>
<ul>
<li>cưa(): nhận vào khúc gỗ, trả về từng khoanh tròn</li>
<li>sấy(): nhận khoanh gỗ tươi, trả về khoanh gỗ khô</li>
<li>bào(): nhận vào khoanh gỗ, trả về khoanh gỗ bằng phẳng</li>
<li>khoan(): nhận vào khoanh gỗ, trả về khoanh gỗ có 2 lỗ (để gắn quai treo/móc lên cho gọn)</li>
<li>chà(): nhận vào khoanh gỗ, trả về khoanh gỗ trơn láng (dùng giấy nhám, miền ngoài gọi giấy giáp, để đánh cho nhẵn bề mặt)</li>
<li>móc(): nhận thớt không quai, trả về thớt có quai</li>
</ul>
<p>Mỗi hàm chỉ làm đúng 1 việc. Không hơn. Không kém. Khi đi qua chừng đó công đoạn, ta sẽ được sản phẩm mong muốn.</p>
<p> <img src="https://i.imgur.com/qKYfPYA.jpg" alt=""></p>
<p>Dĩ nhiên chúng ta đang muốn khúc gỗ được sửa đổi nên tạm bỏ qua vấn đề immutability.</p>
<p>Đây là phiên bản mô phỏng:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cưa = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã cưa`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sấy = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã sấy`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bào = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã bào`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> khoan = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã khoan`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chà = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã chà`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> móc = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã gắn móc`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Để tạo ra 1 cái thớt, ở thời viễn cổ xa xưa, các man sĩ thường code thế này:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thớt = cưa(<span class="string">'khúc gỗ'</span>);</span><br><span class="line">thớt = sấy(thớt);</span><br><span class="line">thớt = bào(thớt);</span><br><span class="line">thớt = khoan(thớt);</span><br><span class="line">thớt = chà(thớt);</span><br><span class="line">thớt = móc(thớt);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thớt);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc</span></span><br></pre></td></tr></table></figure>
<p> <img src="https://i.imgur.com/nBLW7ye.jpg" alt=""></p>
<p>5 vạn năm sau, khi đã xuất hiện Toán học, các tộc nhân bộ lạc Giao Chỉ thời đại Hồng Bàng lại thích code như thế này:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thớt = móc(chà(khoan(bào(sấy(cưa(<span class="string">'khúc gỗ'</span>))))));</span><br><span class="line"><span class="built_in">console</span>.log(thớt);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc</span></span><br></pre></td></tr></table></figure>
<p>Đây chính là Toán học cơ bản. Với y = f(g(x)), ta tính g(x) trước, được bao nhiêu truyền vào f() là ra kết quả. Việc tính toán đi từ ngoặc trong cùng ra ngoài, mắt thường nhìn thấy là từ phải sang trái, từ g đến f.</p>
<p>Lại thêm 5 ngàn năm nữa trôi qua. Lúc này đã có ES6. Một số cường giả Functional Programming sáng tạo ra phương thức compose, như thế này:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> (x) =&gt; f(g(x)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Bạn có thể dùng <a href="https://babeljs.io/repl" target="_blank" rel="noopener">Babel</a> dịch sang ES2015 cho dễ hiểu.</p>
<p>Ý tưởng của compose là xếp cuốn chiếu các hàm lại với nhau, theo thứ tự từ trái sang phải để tạo ra một hàm mới, mà khi được thực thi, nó sẽ lần lượt gọi các hàm đã truyền vào trước đó theo thứ tự ngược lại, từ phải sang trái.</p>
<p>Tức là nếu y = compose(f, g), thì y(x) = f(g(x));<br>Nó sẽ tính g(x) trước rồi truyền kết quả cho f;<br>Giả sử g(x) = z thì y(x) = f(z);</p>
<p>Nếu bạn vẫn thấy mơ hồ thì cứ xem cái này là Đạo. Chỉ có thể cảm ngộ, không thể giảng được bằng lời!</p>
<p>Trở lại với cái thớt. Hàm compose tất nhiên là higher-order function. Ta sẽ thử xem nó làm việc ra sao:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quăng_cho_tao_cái_thớt = compose(móc, chà, khoan, bào, sấy, cưa);</span><br><span class="line"><span class="built_in">console</span>.log(quăng_cho_tao_cái_thớt.toString());</span><br><span class="line"><span class="comment">// =&gt; bạn đoán xem log ra thứ gì?</span></span><br></pre></td></tr></table></figure>
<p>Bây giờ ta có 1 hàm, gọi là quăng_cho_tao_cái_thớt(), kết quả của sự lắp ghép bằng compose tất cả các pure functions ở trên.</p>
<p>Ta biết compose sẽ gọi từ phải sang trái, nên công đoạn nào làm trước thì để bên phải.</p>
<p>Chạy thử 1 phát:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thớt = quăng_cho_tao_cái_thớt(<span class="string">'khúc gỗ'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thớt); </span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc</span></span><br></pre></td></tr></table></figure>
<p>Vậy là đủ công đoạn, khúc gỗ đã trở thành một cái thớt tốt.</p>
<p>Nhưng chưa hết. Khi bạn treo cái thớt đó ở nhà, nhiều người quen đến chơi thấy đẹp hỏi mua. Nhiều đến mức bạn quyết định kinh doanh thớt.</p>
<p>Làm thớt kinh doanh thì phải gán nhãn, vậy là bạn tạo ra một pure function mới và dùng compose để làm khuôn sản suất loại thớt commercial này.</p>
<p>Dễ ợt, không ảnh hưởng gì đến loại thớt cho nhà dùng.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nhãn = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã dán nhãn`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> làm_thớt_để_bán = compose(nhãn, móc, chà, khoan, bào, sấy, cưa);</span><br></pre></td></tr></table></figure>
<p>Hoặc tận dụng lại khuôn mẫu cũ:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> làm_thớt_để_bán = compose(nhãn, quăng_cho_tao_cái_thớt);</span><br></pre></td></tr></table></figure>
<p>Thử xem sao:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thớt_bán = làm_thớt_để_bán(<span class="string">'khúc gỗ'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thớt_bán);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã móc đã dán nhãn</span></span><br></pre></td></tr></table></figure>
<p>Để mở rộng thị phần, hướng đến phân khúc giá rẻ, bạn tạo ra dòng sản phẩm thớt tầm trung, dùng chip MediaTek, bỏ qua bước sấy khô và đánh bóng để giảm giá thành. Rất đơn giản:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> làm_thớt_loại_hai = compose(nhãn, móc, khoan, bào, cưa);</span><br></pre></td></tr></table></figure>
<p>Thử xem sao:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thớt_loại_hai = làm_thớt_loại_hai(<span class="string">'khúc gỗ'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thớt_loại_hai);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã bào đã khoan đã móc đã dán nhãn</span></span><br></pre></td></tr></table></figure>
<p>Lập trình như vậy phải nói là vô cùng tao nhã, lịch thiệp! Đôi khi tôi cảm thấy phong cách lập trình Functional Programming có sự thanh tịnh đầy chất quý tộc, vừa bình dân lại vừa hàn lâm, đẹp đến mức khó hiểu!</p>
<p>Nếu dùng OOP, có thể chúng ta còn đang loay hoay giữa một đống class Máy Cưa, Máy Bào, Máy Khoan… Hoặc 1 class Máy Làm Thớt khổng lồ có đủ methods cưa, bào, khoan… Rồi còn một mớ properties mà ta phải cân nhắc xem cái nào public, cái nào private. Rồi phải tạo instance, thừa kế qua lại mấy vòng may ra mới làm được cái thớt. Muốn thêm dòng sản phẩm lại càng khó khăn. Phải tạo class Thớt_nhà<em>dùng, extend ra Thớt</em>để<em>bán, Thớt</em>để_bán_loại_2, phiền phức không sao kể xiết!</p>
<p>Functional Programming thì chỉ cần mấy hàm đơn giản, rời rạc, dùng compose lắp ráp lại như lắp ráp dây chuyền công nghệ là chế được các kiểu thớt.</p>
<p>Function Composition tựa như một nhà máy hiện đại, mỗi chi tiết linh kiện được xử lý bằng một robot chuyên trách, kết hợp lại với nhau một cách khoa học để tạo ra sản phẩm hoàn thiện.</p>
<h4 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h4><p>Một biến thể của compose là pipe, vận hành theo chiều ngược lại. Ta có thể implement bằng cách đảo vị trí f và g thế này:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> (x) =&gt; g(f(x)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Hoặc giữ nguyên code của compose nhưng thay reduce bằng reduceRight:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduceRight(<span class="function">(<span class="params">f, g</span>) =&gt;</span> (x) =&gt; f(g(x)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Vì pipe tổ hợp các hàm theo chiều ngược lại so với compose nên ta viết:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> làm_thớt_dỏm = pipe(cưa, bào, nhãn);</span><br></pre></td></tr></table></figure>
<p>Thử xem sao:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thớt_dỏm = làm_thớt_dỏm(<span class="string">'khúc gỗ'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thớt_dỏm);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã bào đã dán nhãn</span></span><br></pre></td></tr></table></figure>
<p>Dùng pipe có vẻ thuận mắt hơn. Thứ tự các bước cưa, bào… trông khá tự nhiên. Nếu bạn quen với cách suy luận Toán học thì bạn sẽ thích compose. Còn nếu bạn muốn trực quan dễ hiểu thì cứ dùng pipe.</p>
<p>compose và pipe là những thuật pháp nhập môn dễ học, dễ dùng, nhưng không kém uy lực, thư viện Functional Programming nào cũng có. Trong Ramda.js, ngoài <a href="http://ramdajs.com/docs/#compose" target="_blank" rel="noopener">compose</a> và <a href="http://ramdajs.com/docs/#pipe" target="_blank" rel="noopener">pipe</a>, các tác giả còn bổ sung thêm pipeK, pipeP, composeK, composeP.</p>
<p>Khi đã thông thạo, bạn hoàn toàn có thể tạo ra compose theo cách của bạn. Ví dụ composeBinary liên kết các hàm từ giữa sang 2 bên thay vì từ đầu này đến đầu kia, composeRandom liên kết các hàm không theo trật tự cố định… Đó là không gian sáng tạo thuộc về riêng bạn.</p>
<h3 id="Currying-function"><a href="#Currying-function" class="headerlink" title="Currying function"></a>Currying function</h3><p>Thuật ngữ currying và các dạng curry, curried của nó trong khoa học máy tính được <a href="https://en.wikipedia.org/wiki/Christopher_Strachey" target="_blank" rel="noopener">Christopher Strachey</a> đặt ra từ năm 1967 để ghi nhớ công lao của <a href="https://en.wikipedia.org/wiki/Haskell_Curry" target="_blank" rel="noopener">Haskell Brooks Curry</a>, một nhà Toán học và Luận lý học người Mỹ.</p>
<p>Currying function là làm cho 1 function trở thành “curried function”.</p>
<p>Cái function ban đầu đó hơi ngốc nghếch, nó cần bạn truyền vào N tham số để tính toán, mà nếu thiếu 1 tham số, nó sẽ không chạy.</p>
<p>Ví dụ hàm sum thế này:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sum cần 3 tham số để cộng dồn lại, nếu thiếu, sẽ không tính toán ra được.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// có thể ra sân</span></span><br><span class="line">sum(<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">sum(<span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">sum(<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">sum(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nhưng</span></span><br><span class="line">sum(<span class="number">4</span>, <span class="number">5</span>); <span class="comment">// =&gt; NaN</span></span><br></pre></td></tr></table></figure>
<p>Đây là thiếu tiền đạo cả đội không chịu ra sân tập! Nhưng cuộc sống đâu phải lúc nào cũng thuận lợi, đầy đủ cho chúng ta? Dù cả mấy tiền đạo đều bị chấn thương, treo giò, trốn tập thì các anh còn lại vẫn phải có trách nhiệm ra sân chứ!</p>
<p>Currying chính là kỹ thuật biến hàm sum ngốc đó trở thành một function vi diệu hơn, nếu bạn gọi nó với 1 tham số, nó sẽ trả về 1 hàm tạm thời, giữ lại tham số đó, chờ khi nào đủ 3 tham số thì mới thực hiện tính toán.</p>
<p>Hình dung bạn tổ chức một buổi party, mời 3 người bạn tham gia. Lúc này đã có mặt 2 người, còn 1 người đến muộn. Bạn quyết định không cần chờ nữa. Bữa tiệc cứ bắt đầu đã, chừng nào người kia đến thì tính tiếp.</p>
<p>Đây là 1 cách implement cho hàm curry:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> totalArguments = fn.length;</span><br><span class="line">  <span class="keyword">let</span> next = <span class="function">(<span class="params">argumentLength, rest</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argumentLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next(</span><br><span class="line">          argumentLength - args.length,</span><br><span class="line">          [</span><br><span class="line">            ...rest,</span><br><span class="line">            ...args,</span><br><span class="line">          ]</span><br><span class="line">        );</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(...rest);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> next(totalArguments, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Và curry tất nhiên cũng là higher-order function.</p>
<p>Thử dùng với sum xem sao:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curriedSum = curry(sum);</span><br></pre></td></tr></table></figure>
<p>curriedSum bây giờ là phiên bản curried của hàm sum trước đó.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curriedSum(<span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">curriedSum(<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">curriedSum(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// và</span></span><br><span class="line">curriedSum(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// =&gt; [Function]</span></span><br></pre></td></tr></table></figure>
<p>curriedSum(5, 3) là 1 function. Nó đang chờ đợi tham số cuối cùng xuất hiện. Nếu bây giờ ta gọi nó với 1 tham số thì kết quả sẽ được tính toán ra:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curriedSum(<span class="number">5</span>, <span class="number">3</span>)(<span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br></pre></td></tr></table></figure>
<p>Nếu ta truyền nhiều hơn số lượng tham số còn thiếu thì sao? Ở đây là 1 tham số cuối cùng. Theo cách implement trên thì nó sẽ bỏ qua các tham số dư thừa. Các phiên bản curry của <a href="http://ramdajs.com/docs/#curry" target="_blank" rel="noopener">Ramda.js</a> và <a href="https://lodash.com/docs/4.17.10#curry" target="_blank" rel="noopener">Lodash FP</a> cũng hành xử như vậy.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curriedSum(<span class="number">5</span>, <span class="number">3</span>)(<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>); <span class="comment">// =&gt; 10</span></span><br></pre></td></tr></table></figure>
<p>Một điểm quan trọng nữa là ta có thể phân tách hàm gốc ra từ 1 đến N phần, với N là số lượng tham số của hàm gốc đó. Chẳng hạn, nếu hàm gốc có 3 tham số, ta có thể chia nó ra 1, 2 hoặc 3 phần. Những cách viết sau là tương đương:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curriedSum(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">curriedSum(<span class="number">3</span>, <span class="number">5</span>)(<span class="number">2</span>);</span><br><span class="line">curriedSum(<span class="number">3</span>)(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">curriedSum(<span class="number">3</span>)(<span class="number">5</span>)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>curry, cũng như compose và pipe là những kỹ thuật căn bản, ai cũng phải học, phải biết. Mọi ngôn ngữ được thiết kế với tư tưởng Functional Programming như Haskell, Scalla, Elm… đều có sẵn các hàm này. Chúng rất tinh tế và được dùng ở khắp nơi.</p>
<p>Chỉ cần thành thạo 3 pháp quyết này thì bạn đã được xem như đệ tử Functional Programming chân chính.</p>
<span>Source: </span><a href="https://kipalog.com/posts/Functional-Programming---Phan-2---Nhap-dao" target="_blank" title="https://kipalog.com/posts/Functional-Programming---Phan-2---Nhap-dao" class="post-from">https://kipalog.com/posts/Functional-Programming---Phan-2---Nhap-dao</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2018/06/Functional-Programming-Phan-3-Buong-bo.html" class="prev">NEXT</a><a href="/2018/06/Functional-Programming-Phan-1-Con-duong-sang.html" class="next">PREV</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>