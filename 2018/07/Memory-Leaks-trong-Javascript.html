<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Memory Leaks trong Javascript · Learn and Share</title><meta name="description" content="Memory Leaks trong Javascript - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Memory Leaks trong Javascript"><meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/0*zrLTiLtPpTx3nb9-.jpg"><meta property="og:description" content="Giới thiệuMemory leaks là vấn đề mà mọi deveploper đều sẽ gặp phải khi code. Memory leaks sẽ dấn đến việc ứng dụng sẽ chạy chậm hơn, crashes, hay có thể ảnh hưởng đến các ứng dụng khác. Vậy memory leaks là gì?"></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Memory Leaks trong Javascript</h1><h2 class="post-subtitle"></h2><header class="post-info">Jul 24, 2018<div class="tags"><a href="/tags/javascript" class="tag-link">#javascript</a></div><div class="fb-ir-time"><time datetime="2018-07-24T04:41:00.000Z" class="op-modified"></time><time datetime="2018-07-24T04:41:00.000Z" class="op-published"></time></div></header></div><div class="post-banner"><img src="https://cdn-images-1.medium.com/max/1600/0*zrLTiLtPpTx3nb9-.jpg"></div><div class="wrap"><div class="post-content"><h2 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu"></a>Giới thiệu</h2><p>Memory leaks là vấn đề mà mọi deveploper đều sẽ gặp phải khi code. Memory leaks sẽ dấn đến việc ứng dụng sẽ chạy chậm hơn, crashes, hay có thể ảnh hưởng đến các ứng dụng khác. Vậy memory leaks là gì?<br><a id="more"></a><br>Memory leaks có thể được định nghĩa là một bộ nhớ (memory) không được sử dụng trong ứng dụng nữa nhưng vì một lý do nào đó mà nó chưa được giải phóng và trả về hệ điều hành hoặc một cái pool chứa các bộ nhớ (memory) chưa sử dụng. Các ngôn ngữ lập trình khác nhau sẽ có các cách khác nhau để quản lý bộ nhớ. Những cách quản lý bộ nhớ này sẽ giúp giảm thiểu khả năng bị memory leaks của chương trình. Tuy nhiên, việc xác định một vùng bộ nhớ có còn được sử dụng hay không lại là một vấn đề khó có thể xác định. Chỉ có developer mới có khả năng quyết định xem là vùng nhớ này nên được giải phóng hay không. Một số ngôn ngữ (như javascript) cung cấp tính năng tự động giải phóng bộ nhớ cho developer, một số khác thì developer cần phải tự mình giải phóng bộ nhớ khi không sử dụng đến nó nữa.</p>
<h4 id="Quan-ly-bo-nho-trong-JS"><a href="#Quan-ly-bo-nho-trong-JS" class="headerlink" title="Quản lý bộ nhớ trong JS"></a>Quản lý bộ nhớ trong JS</h4><p>Javascript là một trong những ngôn ngữ có <em>garbage collection</em>. Những ngôn ngữ lập trình như Javascript thế này sẽ thay developer quản lý bộ nhớ bằng cách kiểm tra định kỳ các vùng nhớ được cấp phát trước đó có có thể được “với tới” bởi các phần khác trong ứng dụng. Có thể nói cách khác là những ngôn ngữ như Javascript sẽ giúp biến vấn đề từ <em>“những vùng nhớ nào vẫn còn cần trong ứng dụng”</em> thành <em>“những vùng nhớ nào có thể được ứng dụng access đến”</em>. Sự khác biệt của 2 vấn đề là không nhiều nhưng lại rất quan trọng: chỉ developer mới có thể biết được là vùng nhớ nào còn cần để chạy tuy nhiên, việc xác định xem một vùng nhớ có thể vươn tới không trong ứng dụng thì có thể làm tự động bởi thuật toán.</p>
<h2 id="Memory-leaks-trong-JS"><a href="#Memory-leaks-trong-JS" class="headerlink" title="Memory leaks trong JS"></a>Memory leaks trong JS</h2><p>Lý do chính của memory leaks trong các ngôn ngữ có garbage collection là các reference không mong muốn vào bộ nhớ (unwanted references), tức là một vùng nhớ được trỏ đến mà lại không được sử dụng trong ứng dụng. Để có thể hiểu rõ hơn về nó, trước hết ta cần tìm hiểu các hoạt động của garbage collector, cách nó xác định một vùng nhớ có thể được “với tới” (reach) bởi ứng dụng.</p>
<h4 id="Mark-and-sweep"><a href="#Mark-and-sweep" class="headerlink" title="Mark and sweep"></a>Mark and sweep</h4><p>Hầu hết các garbage collector đều sử dụng thuật toán <code>mark-and-sweep</code> để thực hiện việc giải phóng bộ nhớ. Thuật toán này bao gồm các bước sau:</p>
<ol>
<li><p>Đầu tiên, garbage collector sẽ xây dựng một danh sách các <code>roots</code>. <code>Roots</code> thực chất là các biến toàn cục mà có reference được lưu trong code. Trong Javascript, <code>window</code> chính là một biến toàn cục như vậy. <code>Window</code> sẽ luôn hiện hữu trong chương trình nên garbage collector có thể coi nó và tất cả các con của nó luôn hiện hữu.</p>
</li>
<li><p>Tất cả <code>roots</code> và con của chúng sẽ được đánh dẫu là đang hoạt động. Tất cả những vùng nhớ mà có thể được vươn tới từ <code>roots</code> thì đều được coi là đang hoạt động và không đánh dấu là rác (garbage).</p>
</li>
<li><p>Tất cả các vùng nhớ mà không được đánh dẫu là rác (garbage) thì bây giớ đều sẽ được coi là rác. Bây giờ thì các collector có thể giải phóng các vùng nhớ này.</p>
</li>
</ol>
<p>Mặc dù thuật toán này được tối ưu bởi các GC (garbage collector) hiện đại tuy nhiên cơ chế của nó vẫn không đổi: những vùng nhớ vươn tói được thì được coi là đang hoạt động, những vùng nhớ khác sẽ được coi là rác.</p>
<p>Những tham chiếu không mong muốn (Unwanted references) là những tham chiếu đến các vùng bộ nhớ mà developer biết là nó không được cần đến nữa nhưng vì lý do nào đó mà nó vẫn được giữ lại trong hệ thống. Trong JS, những tham chiếu không mong muốn này là các biến (variables) được giữ đâu đó trong code mà nó sẽ không được sử dụng đến nữa nhưng lại trỏ đến một vùng nhớ mà cần được giải phóng.</p>
<p>Để hiểu được memory leaks trong JS, ta cần biết được là khi nào thì một tham chiếu bị lãng quên.</p>
<h2 id="3-loai-memory-leaks-trong-JS"><a href="#3-loai-memory-leaks-trong-JS" class="headerlink" title="3 loại memory leaks trong JS"></a>3 loại memory leaks trong JS</h2><h3 id="1-Bien-toan-cuc"><a href="#1-Bien-toan-cuc" class="headerlink" title="1: Biến toàn cục"></a>1: Biến toàn cục</h3><p>Javascript có một cơ chế là đặt biến mà không cần khai báo. Ví dụ:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"value"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//"a"</span></span><br></pre></td></tr></table></figure>
<p>Khi một biến được khai báo như trên thì JS sẽ tự động gán nó vào <code>global</code> object (<code>window</code> trên browser). Nếu như biến này chỉ hoạt động trên phạm vi toàn cục (global scope) thì cũng không có sự khác biệt cho lắm. Tuy nhiên, nếu nó được định nghĩa trong một hàm thì đó lại là chuyện khác. Ví dụ:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  bar = <span class="string">"đây là biến toàn cục ẩn"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Đoạn code trên sẽ tương đương với đoạn code sau trên browser:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.bar = <span class="string">"đây là biến toàn cục"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Nếu khai báo <code>bar</code> trong phạm vi của hàm <code>foo</code> mà lại không sử dụng <code>var</code> để khai báo thì biến <code>bar</code> sẽ được tạo với phạm vi toàn cục, và đây là một ví dụ điển hình về memory leaks.</p>
<p>Một cách khác mà có thể vô tình tạo ra biến toàn cục đó là thông qua <code>this</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.variable = <span class="string">"có thể là biến toàn cục"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>Vì <code>this</code> trong hàm sẽ trỏ đến biến root toàn cục (<code>window</code>) nếu hàm đó được gọi trực tiếp không thông qua object nào khác nên ở ví dụ trên, biến <code>variable</code> sẽ được gắn vào phạm vi toàn cục.</p>
<p>Một cách để giảm thiểu những lỗi trên đó là thêm <code>&quot;use strict;&quot;</code> vào dòng đầu tiên của file JS. Nó sẽ giúp ngăn chặn việc khai báo biến toàn cục như trên.</p>
<p><strong>Chú ý khi làm việc với biến toàn cục</strong></p>
<p>Biến toàn cục không bao giờ được giải phóng bộ nhớ tự động theo thuật toán <code>mark-and-sweep</code> ở trên. Vì thế, biến toàn cục chỉ nên được sử dụng để lưu tạm dữ liệu để xử lý. Nếu cần lưu một lượng lớn dữ liệu vào biến toàn cục thì cần đảm bạo là nó sẽ bị gán về null hoặc gán lại dữ liệu khi mà bạn đã sử dụng xong nó.</p>
<h3 id="2-Callback-va-timer-bi-lang-quen"><a href="#2-Callback-va-timer-bi-lang-quen" class="headerlink" title="2: Callback và timer bị lãng quên"></a>2: Callback và timer bị lãng quên</h3><p>Sau đây là một ví dụ dẫn đến memory leak khi sử dụng <code>setInterval</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = getData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">"Node"</span>);</span><br><span class="line">  <span class="keyword">if</span>(node)&#123;</span><br><span class="line">	node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>Đây là một ví dụ về một timer bị treo. Timẻ bị treo tức là khi timer tham chiếu đến các node hoặc dữ liệu mà không còn được sử dụng nữa. Ở ví dụ trên, nếu như <code>node</code> bị xóa ở một lúc nào đấy thì toàn bộ đoạn code xử lý trong hàm callback của interval sẽ không cần đến nữa. Tuy nhiên, vì interval vẫn còn hoạt động nên các vùng nhớ được sử dụng trong hàm callback của interval cũng không được giải phóng (muốn giải phóng cần dừng interval lại). Tiếp đó, các object từ bên ngoài mà được hàm callback của interval tham chiếu đến cũng không thể được giải phóng vì vẫn có thể vươn tới được thông qua hàm callback kia. Theo ví dụ trên thì đó là <code>data</code>.</p>
<p>Một trường hợp có thể dẫn đến leaks đó là do các observers object (DOM và event listener của chúng). Điều này chỉ ảnh hưởng đến các trình duyệt cũ (vd: IE6) vì các trình duyệt mới sẽ tự động làm điều này cho chúng ta. Đây là một bug của GC của IE6 và dẫn đến việc tham chiếu quay vòng.</p>
<h3 id="3-Tham-chieu-toi-cac-DOM-da-bi-xoa"><a href="#3-Tham-chieu-toi-cac-DOM-da-bi-xoa" class="headerlink" title="3: Tham chiếu tới các DOM đã bị xóa"></a>3: Tham chiếu tới các DOM đã bị xóa</h3><p>Có những lúc bạn muốn lưu các DOM vào một số cấu trúc dữ liệu như mảng hoặc object trong JS code để làm một loạt các tác vụ nào đấy. Ví dụ bạn muốn update dữ liệu của một vài element nào đấy thì việc lưu các element này vào một mảng là hoàn toàn hợp lý. Khi điều này xảy ra thì sẽ có 2 tham chiếu đên DOM element này: một là từ DOM tree, hai là từ đối tượng mảng của JS. Nếu bạn muốn xóa các element này thì bạn cần phải xóa toàn bộ các tham chiếu tới chúng để có thể giải phóng bộ nhớ.</p>
<p>Ví dụ:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">  button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</span><br><span class="line">  image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>),</span><br><span class="line">  text: <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	image.src = <span class="string">'http://some.url/image'</span>;</span><br><span class="line">	button.click();</span><br><span class="line">	<span class="built_in">console</span>.log(text.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// button là con của body.</span></span><br><span class="line">	<span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ở đây thì button vẫn được tham chiểu đến bởi elements. Nói cách khác là</span></span><br><span class="line">	<span class="comment">// nó vẫn nằm trong bộ nhớ và không thể được giải phóng.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Còn một vấn đề quan trọng nữa là khi tham chiếu đến một node lá hoặc một inner node của DOM tree, ví dụ như một ô trong bảng (<code>&lt;td&gt;</code> của <code>&lt;table&gt;</code>). Nếu bạn tham chiếu đến <code>&lt;td&gt;</code> này trong JS code thì khi bạn xóa <code>&lt;table&gt;</code> chứa node này thì GC sẽ không giải phóng được cả table chứ không phải là chỉ mỗi <code>&lt;td&gt;</code> node không được giải phóng. Vì node con còn tham chiếu đến node cha nên nó sẽ được GC coi là vẫn được tham chiếu và bỏ qua nó. Vì thế nên cẩn thận khi tham chiếu đến các DOM.</p>
<h3 id="4-Closures"><a href="#4-Closures" class="headerlink" title="4: Closures"></a>4: Closures</h3><p>Closures có nghĩa đơn giản là hàm nằm trong phạm vi của một hàm khác có thể tham chiếu tới các biến của hàm bao nó. Vì sao <code>Closures</code> có thể gây ra leak, hãy xem ví dụ sau:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (originalThing)</span><br><span class="line">	  <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">	longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">	someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	  <span class="built_in">console</span>.log(someMessage);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>Ví dụ này cho ta thấy mỗi khi <code>replaceThing</code> được gọi, <code>theThing</code> sẽ tạo ra một object mới chứa một mảng và một closures (<code>someMethod</code>). Cùng lúc đó, biến <code>unused</code> cũng lưu một closures tham chiếu đên <code>originalThing</code> (là object <code>theThing</code> được tạo ra từ việc gọi <code>replaceThing</code> ở bước trước đó). Một điều quan trọng nữa là khi một scope được tạo ra cho các closures mà có cùng scope cha, chúng sẽ cùng chia sẻ scope đó. Trong ví dụ này thì <code>someMethod</code> và <code>unused</code> đều chia sẻ cùng một scope. Mặc dù <code>unused</code> không được gọi đến nhưng vì nó có tham chiếu đến <code>originalThing</code> nên nó sẽ được GC coi là vẫn đang hoạt động. Khi đoạn code này chạy thì bộ nhớ của chương trình sẽ tăng đều đặn và có thể nhìn thấy ngay được. Về bản chất, một linked-list của closures được tạo (với root là <code>theThing</code>) khi đoạn code trên được chạy và đó là lý do bộ nhớ bị tăng dần theo thời gian.</p>
<h2 id="Garbage-Collectors-bo-don-rac"><a href="#Garbage-Collectors-bo-don-rac" class="headerlink" title="Garbage Collectors (bộ dọn rác)"></a>Garbage Collectors (bộ dọn rác)</h2><p>Mặc dù GCs giúp chúng ta không phải quản lý bộ nhớ bằng tay nữa, tuy nhiên ta cũng sẽ phải đánh đổi lại một vài thứ. Một trong số đó là việc các GCs hoạt động theo một cách khó đoán biết. Thông thường rất khó có thể chắc chắn rằng một hoạt động thu thập các vùng nhớ không được sử dụng được thực thi hay không. Điều này cũng có nghĩa là trong một số trường hợp, số lượng vùng nhớ của một chương trình nhiều hơn số bộ nhớ mà chương trình đó cần. Trong một số trường hợp khác, ứng dụng sẽ bị ảnh hưởng bởi một khoảng thời gian nhỏ chương trình bị delay để thực hiện công việc thu thập bộ nhớ. Hiện nay, hầu hết GC đều hoạt động theo cách là chỉ thực hiện việc thu thập bộ nhớ khi cấp phát bộ nhớ cho chương trình. Nếu không cần cấp phát bộ nhớ, GCs sẽ không hoạt động. Chúng ta sẽ xem xét các tình huống sau:</p>
<ol>
<li><p>Chương trình đã cấp phát một số lượng nhỏ bộ nhớ.</p>
</li>
<li><p>Sau đó, hầu hết (hoặc toàn bộ) các phần tử được đánh dấu là không thể vươn tới nữa.</p>
</li>
<li><p>Chương trình không thực hiện việc cấp phát bộ nhớ nữa.</p>
</li>
</ol>
<p>Trong tình huống này, hầu như tất cả các GC sẽ không thực hiện việc thu thập bộ nhớ nữa. Nói cách khác, mặc dù có những phần tử không thể vươn tới được nữa trong chương trình, chúng sẽ không được thu hồi lại bộ nhớ. Đây không hẳn là leaks, tuy nhiên nó vẫn dẫn đến việc chương trình ngốn bộ nhớ.</p>
<h2 id="Chrome-Memory-Profiling-Tools"><a href="#Chrome-Memory-Profiling-Tools" class="headerlink" title="Chrome Memory Profiling Tools"></a>Chrome Memory Profiling Tools</h2><p><code>Chrome</code> cung cấp một tập các công cụ để kiểm tra tình trạng sử dụng bộ nhớ của code JS. Có 2 view quan trọng liên quan đến bộ nhớ đó là: <em>timeline</em> và <em>profiles</em>.</p>
<h4 id="Timeline-View"><a href="#Timeline-View" class="headerlink" title="Timeline View"></a>Timeline View</h4><p><code>Timeline View</code> có thể giúp ta biết được mô hình sử dụng bộ nhớ của chương trình. Từ đây ta có thể nhìn được việc rò rỉ bộ nhớ, việc bộ nhớ sử dụng tăng liên tục theo thời gian mà không giảm xuống sau mỗi lần GC được chạy. Ví dụ:</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/timeline.png" alt="timeline"></p>
<p>Ta có thể thấy được việc bộ nhớ rò rỉ được thể hiện thông qua việc JS heap tăng dần theo thời gian. Mặc dù sau khi được thu thập với một số lượng lớn tại đoạn cuối thì chương trình vẫn sử dụng số lượng bộ nhớ nhiều hơn so với lúc bắt đầu. Số lượng Node cũng cao hơn. Đây là dấu hiệu của việc các node DOM bị rò rỉ đâu đó trong code.o</p>
<h4 id="Profiles-view"><a href="#Profiles-view" class="headerlink" title="Profiles view"></a>Profiles view</h4><p><img src="https://cdn.auth0.com/blog/jsleaks/profiles.png" alt="profiles"></p>
<p>Đây là công cụ sẽ luôn gắn bó với bạn khi phải điều tra về rò rỉ bộ nhớ. <code>Profiles view</code> cho phép bạn lấy ảnh chụp (snapshot) về việc sử dụng bộ nhớ của một chương trình Javascript. Nó cũng cho phép bạn ghi lại những lần cấp phát bộ nhớ theo thời gian. Mỗi một loại kết quả sẽ có các danh sách liệt kê khác nhau được đưa ra, tuy nhiên những thứ mà bạn cần quan tâm đó là danh sách tổng hợp (summary list) và danh sách so sánh (comparision list).</p>
<p><code>Summary View</code> sẽ cho ta thấy được tổng quan về các loại objects được khởi tạo và cấp phát cùng với các kích thước tổng hợp (aggregated size): kich thước nông (Shallow size) là tổng kích thước của tất cả các object của một loại cụ thể nào đó và kích thước giữ lại (retained size) bao gồm <code>shallow size</code> và kích thước của các object được lưu lại bởi object này. Nó cũng cho ta một thông tin về khoảng cách giữa một object với root.</p>
<p><code>Comparision View</code> cũng cung cấp cùng một thông tin như <code>summary view</code> nhưng nó cho phép ta so sánh giữa các snapshot khác nhau.</p>
<h2 id="Vi-du-Tim-kiem-ro-ri-du-lieu-trong-Chrome"><a href="#Vi-du-Tim-kiem-ro-ri-du-lieu-trong-Chrome" class="headerlink" title="Ví dụ: Tìm kiếm rò rỉ dữ liệu trong Chrome"></a>Ví dụ: Tìm kiếm rò rỉ dữ liệu trong Chrome</h2><p>Có 2 kiểu rò rỉ dữ liệu chủ yếu là: rỏ rỉ dẫn đến việc bộ nhớ bị tăng một cách đều đặn theo thời gian và rò rỉ chỉ xảy ra một lần duy nhất và không gây ra việc bộ nhớ bị tăng trong tương lai nữa. Việc tìm rò rỉ dữ liệu mà bộ nhớ bị tăng dần theo thời gian khá là đơn giản và rõ ràng (sử dụng <code>timeline view</code>). Tuy nhiên thì đây lại là rò rỉ gây ra nhiều rắc rối nhất: nếu bộ nhớ cứ tăng dần theo thời gian, nó sẽ khiến trình duyệt chạy chậm dận và cuối cùng sẽ dẫn đến việc script bị ngừng chạy. Rò rỉ mà không dẫn đến việc bộ nhớ bị tăng theo thời gian có thể dễ dàng được tìm ra khi bộ nhớ lớn đến một mức độ nào đó. Thông thường những rò rỉ kiểu này không được chú ý quả nhiều. Nói theo một cách khác, những rò rỉ nhỏ mà chỉ xảy ra một lần thường được coi là một vấn đề để tối ưu code. Tuy nhiên, những rò rỉ mà làm bộ nhớ tăng dần theo thời gian thì được coi là bug và nó cần được fix.</p>
<p>Ở đây ta sẽ sử dụng một ví dụ từ <a href="https://developer.chrome.com/devtools/docs/demos/memory/example1" target="_blank" rel="noopener">Chrome</a>. Toàn bộ đoạn code như sau:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [];</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSomeNodes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div,</span><br><span class="line">        i = <span class="number">100</span>,</span><br><span class="line">        frag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">for</span> (;i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">        div.appendChild(<span class="built_in">document</span>.createTextNode(i + <span class="string">" - "</span>+ <span class="keyword">new</span> <span class="built_in">Date</span>().toTimeString()));</span><br><span class="line">        frag.appendChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"nodes"</span>).appendChild(frag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">grow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    x.push(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'x'</span>));</span><br><span class="line">    createSomeNodes();</span><br><span class="line">    setTimeout(grow,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Khi <code>grow</code> được gọi, nó sẽ bắt đầu tạo một <code>div</code> và gán nó vào DOM. Nó cũng sẽ khởi tạo một mảng lớn (1 triệu phần tử) và gán nó vào một mảng được tham chiếu bỏi một biến toàn cục (<code>x</code>). Việc này sẽ dẫn đến việc bộ nhớ bị tăng đều đặn và có thể nhận biết được với <code>Timeline view</code>.</p>
<h4 id="Phat-hien-viec-bo-nho-bi-tang-deu-dan-trong-Chrome"><a href="#Phat-hien-viec-bo-nho-bi-tang-deu-dan-trong-Chrome" class="headerlink" title="Phát hiện việc bộ nhớ bị tăng đều đặn trong Chrome"></a>Phát hiện việc bộ nhớ bị tăng đều đặn trong Chrome</h4><p>Ta sẽ bắt đầu với <a href="https://developer.chrome.com/devtools/docs/demos/memory/example1" target="_blank" rel="noopener">ví dụ sau của chrome</a>. Sau khi click vào ví dụ của Chrome, mở Dev Tools, click vào tab <code>timeline</code>, tích chọn <code>memory</code> và click vào nút <code>record</code>. Tiếp đó quay lại trang ví dụ và click vào <code>The Button</code> để bắt đầu việc rò rỉ bộ nhớ. Sau một khoảng thời gian thì dừng lại việc record và xem kết quả:</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-timeline.png" alt="example-timeline"></p>
<p><strong>Note</strong>: Ví dụ này sẽ khiến bộ nhớ bị tăng mỗi giây. Sau khi dừng việc record thì các bạn có thể đặt breakpoint vào <code>grow</code> để dừng việc thực thi script.</p>
<p>Có 2 dấu hiệu lớn trong bức ảnh trên cho thấy việc rò rỉ bộ nhớ: biểu đồ cho <code>nodes</code> (đường kẻ màu xanh lá) và biểu đồ cho JS heap (đường kẻ màu xanh đậm). Số lượng node luôn luôn tăng và không bao giờ giảm. Đây là dấu hiệu cảnh báo lớn.</p>
<p>JS heap cũng tăng dần theo thời gian tuy nhiên điều này khó nhìn ra hơn do hiệu ứng từ GC. Các bạn có thể thấy là bộ nhớ tăng sau lại giảm một cách liên tục. Điểm quan trọng cần chú ý ỏ đây là sau mỗi lần bộ nhớ được giảm thì kích thước của JS heap vẫn lớn hơn so với lần giảm trước đấy. Nói cách khác, mặc dù GC đã thành công thu thập được rất nhiều bộ nhớ, một vài trong số đó bị rò rỉ.</p>
<p>Bây giờ ta đã chắc chắn chương trình của mình bị rò rỉ bộ nhớ, ta cần phải tìm ra nguyên nhân của nó.</p>
<h4 id="Tao-2-snapshot"><a href="#Tao-2-snapshot" class="headerlink" title="Tạo 2 snapshot"></a>Tạo 2 snapshot</h4><p>Để tìm ra nguyên nhân rò rỉ, ta sẽ sử dụng đến công cụ <code>profiles</code> của Chrome. Cụ thể hơn, ta sẽ sử dụng tính năng <code>Take Heap Snapshot</code>.</p>
<p>Đầu tiên, reload lại trang và tạo một snapshot ngay sau khi load xong trang. Ta sẽ sử dụng snapshot này làm cơ sở. Sau đó, click vào <code>The Button</code> một lần nũa, chờ khoảng một vài giây, tạo một snapshot khác. Sau đó tạo breakpoint để dừng việc rò rỉ bộ nhớ lại.</p>
<p>Có 2 cách mà ta có thể sử dụng để kiểm tra sự khác nhau giữa 2 snapshot. Thứ nhất là sử dụng chức năng <code>Summary</code> rồi bắt đầu từ phía bên phải chọn <code>Objects allocated between Snapshot 1 and Snapshot 2</code>. Hoặc chọn <code>Comparision</code> thay cho <code>Summary</code>. Trong cả 2 trường hợp, ta sẽ thấy một danh sách các object được khởi tạo giữa 2 snapshot.</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-snapshots-1.png" alt="example-snapshots"></p>
<p>Trong trường hợp này thì việc tìm ra leaks rất đơn giản. Hãy xem <code>Size Delta</code> của <code>(string)</code>. 8MB với 58 object mới. Điều này rất đáng nghi ngờ: object mới được tạo nhưng không được giải phóng và 8MB bị chiếm mất.</p>
<p>Nếu ta mở danh sách khởi tạo của <code>(string)</code> ta sẽ thấy có một vài object lớn được khởi tạo bên cạnh các object nhỏ. Nếu ta chọn một trong số các object lớn này thì ta sẽ thấy một vài điểm thú vị trong mục <code>retainers</code>:</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-snapshots-2.png" alt="example-snapshots"></p>
<p>Ta thấy rằng object được chọn là một phần tử của mảng. Tiếp đó ta biết được mảng này được tham chiếu bởi biến <code>x</code> nằm ở trong <code>window</code>. Điều này cho ta thấy được toàn bộ con đường từ object lớn của chúng ta liên kết thế nào với root (<code>window</code>). Ta đã tìm được một nguyên nhân dẫn đến rò rỉ và nơi nó được tham chiếu.</p>
<p>Vi dụ này khá đơn giản: object lớn được khỏi tạo thế này không thường xuyên xuất hiện trong chương trinh. Tuy nhiên trong chương trình này cũng có xuất hiện việc rò rỉ DOM có kích cỡ nhỏ hơn. Những node này có thể tìm thấy đươc thông qua snapshot tuy nhiên đối với những site lớn, mọi chuyện sẽ trở nên rắc rối hơn nhiều. Các phiên bản Chrome hiên tại có cung cấp một tính năng đó là: <code>Record Heap Allocations</code></p>
<h4 id="Record-Heap-Allocations"><a href="#Record-Heap-Allocations" class="headerlink" title="Record Heap Allocations"></a>Record Heap Allocations</h4><p>Ta se bắt đầu với viêc để cho đoạn script tiếp tục được chạy và quay lại tab <code>Profiles</code> của Chrome Dev Tools. Ấn nút <code>Record Heap Allocations</code>. Khi mà tool đang chạy, các bạn sẽ thấy một vài vạch xanh trên biểu đồ ở phía trên đầu. Nó thể hiện việc khởi tạo object khi chạy chương trình.</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-recordedallocs-overview.png" alt="example-recordedallocs-overview"></p>
<p>Ta có thể thấy được tính năng của công cụ này: chọn một khoảng thời gian để xem object nào được khởi tạo trong khoảng thời gian này. Ta đặt khoảng thời gian này gần các vạch xanh đậm nhất có thể. Chỉ có 3 hàm khởi tạo được show trong danh sách: một trong số đó liên quan đến rò rỉ do <code>(string)</code> ở phía trên, tiếp theo là liên quan đến việc khởi tạo DOM và cái cuối cùng là khởi tạo <code>Text</code>.</p>
<p>Chon một trong những hàm khởi tạo của <code>HTMLDivElement</code> trong danh sách và chọn <code>Allocation stack</code>.</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-recordedallocs-selected.png" alt="example-recordedallocs-selected"></p>
<p>Từ ảnh trên ta thấy được là phần tử được khởi tạo bởi <code>grow</code> -> <code>createSomeNodes</code>. Nếu ta để ý kỹ mỗi vạch trên biểu đồ, ta sẽ thấy là hàm khởi tạo <code>HTMLDivElement</code> được gọi nhiều lần. Nếu ta quay trở lại với snapshot <code>comparision view</code>, ta sẽ thấy là nó chỉ khởi tạo object mà không xóa chúng đi. Nói cách khác là nó luôn khởi tạo object mà không cho phép GC thu thập một vài trong số chúng. Giờ khi ta đã biết objects bị rò rỉ ở đâu (<code>createSomeNodes</code>), ta có thể quay trở lại code để sửa lại nó.</p>
<h4 id="Cac-tinh-nang-huu-ich-khac"><a href="#Cac-tinh-nang-huu-ich-khac" class="headerlink" title="Các tính năng hữu ích khác"></a>Các tính năng hữu ích khác</h4><p>Thay vì sử dụng <code>Summary view</code>, ta có thể sử dụng <code>Allocation view</code>:</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-recordedallocs-list.png" alt="example-recordedallocs-list"></p>
<p>Giao diện này cho ta thấy một danh sách các hàm và bộ nhớ khởi tạo liên quan đến chúng. Ta có thể thấy ngay là <code>grow</code> và <code>createSomeNodes</code> là nổi bật hơn cả. Khi chọn <code>grow</code> ta sẽ thấy đối tượng khởi tạo liên quan được gọi đến. Ta có thể để ý thấy <code>(string)</code> <code>HTMLDivElement</code> và <code>Text</code> là những hàm khởi tạo của các đối tượng bị rò rỉ.</p>
<p><strong>Note</strong>: để sử dụng được tính năng này, vào <code>Dev Tools</code> -> Settings và enable <code>record heap allocation stack traces</code> trước khi record.</p>
<span>Source: </span><a href="https://auth0.com/blog/2016/01/26/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them" target="_blank" title="https://auth0.com/blog/2016/01/26/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them" class="post-from">https://auth0.com/blog/2016/01/26/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2018/07/Object-Function-Method-Constructor-in-JavaScript.html" class="prev">NEXT</a><a href="/2018/07/Lam-the-nao-de-thanh-thao-CSS-Grid-trong-nhay-mat.html" class="next">PREV</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>