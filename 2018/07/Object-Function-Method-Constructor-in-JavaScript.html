<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Object, Function, Method, Constructor in JavaScript · Learn and Share</title><meta name="description" content="Object, Function, Method, Constructor in JavaScript - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Object, Function, Method, Constructor in JavaScript"><meta property="og:image" content="https://cdn-images-1.medium.com/max/800/1*pWfJGrCbLcK6cy5TDT4DiA.jpeg"><meta property="og:description" content="TL;DR
Lưu ý một chút về cách trình bày:.propname tức là public property có tên là “propname” của một đối tượng
Bắt đầu với Object, Function và Method"></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Object, Function, Method, Constructor in JavaScript</h1><h2 class="post-subtitle"></h2><header class="post-info">Jul 24, 2018<div class="tags"><a href="/tags/javascript" class="tag-link">#javascript</a></div><div class="fb-ir-time"><time dateTime="2018-07-24T05:02:00.000Z" class="op-modified"></time><time dateTime="2018-07-24T05:02:00.000Z" class="op-published"></time></div></header></div><div class="post-banner"><img src="https://cdn-images-1.medium.com/max/800/1*pWfJGrCbLcK6cy5TDT4DiA.jpeg"></div><div class="wrap"><div class="post-content"><p><strong>TL;DR</strong></p>
<p>Lưu ý một chút về cách trình bày:<br><code>.propname</code> tức là public property có tên là “propname” của một đối tượng</p>
<h2 id="Bat-dau-voi-Object-Function-va-Method"><a href="#Bat-dau-voi-Object-Function-va-Method" class="headerlink" title="Bắt đầu với Object, Function và Method"></a>Bắt đầu với Object, Function và Method</h2><a id="more"></a>
<ul>
<li>JavaScript’s object giống như một cái túi (hay một vùng nhớ) chứa các property (thuộc tính) ở bên trong nó. Những property trong JavaScript đều public và được lưu trữ theo cấu trúc <strong>Mapping (tức key-value pair)</strong>.</li>
<li>Function trong JavaScript được xem là first-class object (cũng tương tự như object và ta sẽ gọi nó là <strong>functionObject</strong>).</li>
<li>Chính vì JavaScript’s function được xem như object nên ta có thể return (trả về), pass to parameter (truyền vào function khác thông qua đối số), store in variable (lưu trữ trong biến) or store in Object’s property (lưu trữ trong property của Object =&gt; lúc đó function được gọi là method),…</li>
</ul>
<h2 id="Prototypes"><a href="#Prototypes" class="headerlink" title="Prototypes"></a>Prototypes</h2><ul>
<li><p>Prototype của object là một internal property (có thể hiểu là một property nội tại ẩn bên trong), ta sẽ gọi nó là {Prototype}. JavaScript standard không cung cấp cách thức để truy xuất <strong>{Prototype}</strong> property từ một object. <strong>Lưu ý {Prototype} bản thân nó cũng là một object</strong>.</p>
</li>
<li><p>Giống như bao ngôn ngữ lập trình OOP khác, JavaScript có thể tạo object từ một function được gọi là <strong>constructor</strong>.</p>
</li>
<li><p>Vì constructor là function và là functionObject nên nó cũng có {Prototype} property.</p>
</li>
<li><p>JavaScript standard cung cấp một public property cho functionObject là <code>.prototype</code> để truy xuất prototype của function.<strong>Lưu ý đối tượng được truy xuất thông qua public property <code>.prototype</code> không phải là {Prototype} property của functionObject</strong>.</p>
</li>
</ul>
<h3 id="Properties-lookup"><a href="#Properties-lookup" class="headerlink" title="Properties lookup"></a>Properties lookup</h3><ul>
<li>JavaScript’s object có thể ủy thác một số property của nó cho {Prototype}. Và bản thân {Prototype} cũng làm tương tự; Tất cả đều hướng đến Build-in Object.prototype. <strong>Lưu ý Build-in Object.prototype bằng <em>null</em></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object --chứa--&gt; &#123;Prototype&#125;</span><br><span class="line">và bản thân &#123;Prototype&#125; cũng là object</span><br><span class="line">&#123;Prototype&#125; --chứa--&gt; &#123;Prototype&#125;&apos;s &#123;Prototype&#125;</span><br><span class="line">và bản thân &#123;Prototype&#125;&apos;s &#123;Prototype&#125; cũng là object</span><br><span class="line">&#123;Prototype&#125;&apos;s &#123;Prototype&#125; --chứa--&gt; &#123;Prototype&#125;&apos;s &#123;Prototype&#125;&apos;s &#123;Prototype&#125;</span><br><span class="line">.....</span><br><span class="line">..... --chứa--&gt; Build-in Object.prototype</span><br><span class="line">(end)</span><br></pre></td></tr></table></figure>
<ul>
<li>Hiện tượng trên người ta gọi là Inheritance (kế thừa) trong JavaScript thông qua prototype. Do đó JavaScript là một <strong>prototype-base OOP language</strong></li>
<li>Ở ví dụ trên, ta thấy xảy ra đệ quy, người ta gọi là <strong>{Prototype} chain</strong>. tức duyệt xuyên suốt các {Prototype}</li>
<li>Khi gọi một property ra từ object thì đầu tiên hệ thống sẽ kiểm tra xem property đó có nằm trong object đó không. Nếu không, chúng sẽ chuyển hướng qua tìm property đó trong object’s {Prototype}. Quá trình đệ quy cứ thế được thực hiện cho đến khi tìm đến Build-in Object.prototype thì dừng lại.</li>
</ul>
<h3 id="Setting-properties"><a href="#Setting-properties" class="headerlink" title="Setting properties"></a>Setting properties</h3><ul>
<li>Khi một property được set giá trị, property đó không có trong object thì nó sẽ được tạo mới, hệ thống tự động bỏ qua việc tìm kiếm nó trong {Prototype}. Property mới được thêm vào object sẽ làm mờ nhạt property trùng tên (nếu có) trong {Prototype} chain</li>
<li>{Prototype} của object bị ảnh hưởng khá mạnh bởi public property <code>.prototype</code> của constructor. Ta có thể quyết định {Prototype} của một object thông qua việc điều chỉnh <code>.prototype</code> property của constructor.</li>
<li>Khi constructor được gọi thực thi (hay nói cách khác function được gọi theo Constructor Format) (xem phần <strong>footnotes</strong>) thì một object mới được sinh ra. {Prototype} của object mới và public property <code>.prototype</code> của constructor sẽ tham chiếu cùng một đối tượng.</li>
</ul>
<h2 id="Tiep-theo-se-la-gi-Ta-cung-hinh-dung"><a href="#Tiep-theo-se-la-gi-Ta-cung-hinh-dung" class="headerlink" title="Tiếp theo sẽ là gì? Ta cùng hình dung"></a>Tiếp theo sẽ là gì? Ta cùng hình dung</h2><p>Trước tiên sẽ là mối liên quan giữa public property <code>.prototype</code> và {Prototype}. hình ellipse biểu diễn object, mũi tên biểu diễn property của object đó tham chiếu đến một object khác. {Prototype} chain sẽ được tô mũi tên mày xanh lá.</p>
<h3 id="1-Define-constructor"><a href="#1-Define-constructor" class="headerlink" title="1: Define constructor:"></a>1: Define constructor:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params"></span>) </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/rkuzvvigqw_1.png" alt="alt text"></p>
<p>Ta dễ dàng thấy MyConstructor được biểu diễn trong hình Ellipse, tức nó là function và là functionObject và sẽ được dùng như constructor.</p>
<p><strong>Ghi nhớ rằng</strong>: chỉ những public property <code>.prototype</code> của functionObject, là những object mặc định sở hữu public property <code>.constructor</code><br>Tức là theo ví dụ trên: MyConstructor.prototype là giá trị mặc định cho property <code>.prototype</code> của MyConstructor. Và nó mặc định sở hữu property <code>.constructor</code> trỏ ngược về MyConstructor</p>
<p>Phần còn lại trong bức ảnh minh họa rõ ràng những khái niệm đã đề cập ở phần đầu bài viết</p>
<p>Bước kế tiếp ta sẽ bỏ qua phần {Prototype} chain của MyConstructor cho gọn, vì chúng không thay đổi và cũng không liên quan đến những gì được trình kế tiếp sau đây.</p>
<h3 id="2-Assign-new-prototype-property"><a href="#2-Assign-new-prototype-property" class="headerlink" title="2: Assign new prototype property:"></a>2: Assign new prototype property:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyConstructor.prototype = &#123; &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/iafa0yzffc_2.png" alt="alt text"></p>
<p>Ta thay <code>.prototype</code> mặc định của MyConstructor bằng một đối tượng mới. Đặc biệt đối tượng này không có property <code>.constructor</code></p>
<h3 id="3-Call-constructor-to-create-new-object"><a href="#3-Call-constructor-to-create-new-object" class="headerlink" title="3: Call constructor to create new object:"></a>3: Call constructor to create new object:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myobject = <span class="keyword">new</span> MyConstructor();</span><br></pre></td></tr></table></figure>
<p><img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/1j0lr35ama_3.png" alt="alt text"></p>
<p>Như đã trình bày ở mục <strong>setting propertites</strong> của bài viết, ta dễ dàng thấy được {Prototype} của myobject và property <code>.prototype</code> của MyConstructor tham chiếu đến cùng một đối tượng.</p>
<p>Vậy bây giờ dựa theo mục <strong>properties lookup</strong>, ta thử truy xuất một property bất kì từ myobject. Ta chọn property có tên là constructor, chuyện gì sẽ xảy ra</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myobject.constructor = ?</span><br></pre></td></tr></table></figure>
<p>Đơn giản, áp dụng {Property} chain, ta sẽ có ngay đáp án. Bây giờ cùng thu gọn tất cả những đoạn code ta viết lại:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">MyConstructor.prototype = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> myobject = <span class="keyword">new</span> MyConstructor();</span><br><span class="line"></span><br><span class="line">myobject.constructor == <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">myobject.constructor.prototype == <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>Ghi chú</strong>: Nếu nhìn lại ta sẽ hiểu vì sao ngay từ bước <strong>#2</strong> ta lược bỏ đi phần {Prototype} của MyConstructor là đúng đắn</p>
<h3 id="The-neu-dung-instanceof-ket-qua-nhu-the-nao"><a href="#The-neu-dung-instanceof-ket-qua-nhu-the-nao" class="headerlink" title="Thế nếu dùng instanceof kết quả như thế nào?"></a>Thế nếu dùng instanceof kết quả như thế nào?</h3><p>Viết lại nguyên văn:<br>    “Javascript provides the instanceof operator that’s intended to check the prototype chain of the object you’re dealing with.”</p>
<p>Từ những bước ở trên, ta có thể nghĩ rằng đoạn code sau sẽ trả về false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">MyConstructor.prototype = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> myobject = <span class="keyword">new</span> MyConstructor();</span><br><span class="line"></span><br><span class="line">myobject <span class="keyword">instanceof</span> MyConstructor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>nhưng thực chất, nó chạy ổn và còn hơn thế nữa:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">MyConstructor.prototype = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> myobject = <span class="keyword">new</span> MyConstructor();</span><br><span class="line"></span><br><span class="line">myobject <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Khi instanceof được gọi, nó <strong>hoạt động dựa trên {Prototype} chain. Và nó chẳng đá động hay lệ thuộc vào property</strong> <code>.constructor</code></p>
<p>cùng nhìn lại hình ở bước <strong>#3</strong></p>
<p><img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/38d3vbr9vo_4.png" alt="alt text"></p>
<p>Cứ tới một “trạm” tức đối tượng tham chiếu bởi {Prototype}, nó check xem đối tượng này được tham chiếu thông qua <code>.prototype</code> property của ai.<br>Đầu tiên dừng tại đối tượng {}, nó check và phát hiện ra {} được tham chiếu thông qua <code>.prototype</code> property của MyConstructor, suy ra:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myobject <span class="keyword">instanceof</span> MyConstructor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Tiếp theo dừng tại đối tượng Object.prototype nó phát hiện ra Object.protoype tham chiếu thông qua <code>.prototype</code> property của build-in Object, suy ra:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myobject <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Có ổn rồi, nhưng ta vẫn có thể tìm ra những điều bất thường nếu chịu khó mò mẫm:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> myobject = <span class="keyword">new</span> MyConstructor();</span><br><span class="line">MyConstructor.prototype = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">[ myobject <span class="keyword">instanceof</span> MyConstructor,     <span class="comment">// false !</span></span><br><span class="line">  myobject.constructor == MyConstructor, <span class="comment">// true !</span></span><br><span class="line">  myobject <span class="keyword">instanceof</span> <span class="built_in">Object</span> ]           <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>ở đoạn code trên ta đổi thứ tự của hai dòng code, myobject được tạo ra trước sau đó MyConstructor mới đổi giá trị của <code>.prototype</code> property.<br>Do đó {Prototype} chain sẽ trông như vầy:</p>
<p><img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hh0v85pb9l_5.png" alt="alt text"></p>
<p>Đúng như dự đoán {Prototype} của object sẽ tham chiếu đến đối tượng cũ mà <code>.prototype</code> property của MyConstructor từng tham chiếu.</p>
<p>Điều này làm thay đổi {Prototype} chain và có thêm sự xuất hiện của <code>.constructor</code> property của old MyConstructor.prototype dẫn đến {Prototype} của object và <code>.prototype</code> property của MyConstructor không tham chiếu đến cùng một đối tượng.<br>Dừng tại {Prototype} đầu tiên là đối tượng old MyConstructor.prototype, nó không phát hiện ra đối tượng đó được tham chiếu thông qua <code>.prototype</code> property của ai cả. Tiếp tục {Prototype} thứ hai, là Object.prototype thì quá rõ ràng, suy ra:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myobject <span class="keyword">instanceof</span> MyConstructor,     <span class="comment">// false !</span></span><br><span class="line">myobject <span class="keyword">instanceof</span> <span class="built_in">Object</span>            <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Ngoài ra, thông qua {Prototype} chain (xem lại mục <strong>properties lookup</strong>), thì ta thấy <code>.constructor</code> property đầu tiên được bắt gặp trong old MyConstructor.prototype nên</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myobject.constructor == MyConstructor, <span class="comment">// true !</span></span><br></pre></td></tr></table></figure>
<p>là điều dễ hiểu.</p>
<h2 id="Mot-so-nhan-dinh"><a href="#Mot-so-nhan-dinh" class="headerlink" title="Một số nhận định"></a>Một số nhận định</h2><h4 id="Constructors-khong-phai-classes"><a href="#Constructors-khong-phai-classes" class="headerlink" title="Constructors không phải classes"></a>Constructors không phải classes</h4><p>Nhìn lại các class-based OOP language (như Java, C#,…), các classes kế thừa từ những classes khác, và object là instance của những classes đó. Các properties và methods được chia sẻ giữa các instances. Và việc chia sẻ đó bị chi phối bởi <strong>access modifier</strong> (public, private, internal, protected,……)</p>
<p>Javascript cũng có khái niệm kế thừa, chia sẻ properties và methods thông qua prototype. Nhưng thực tế {Prototype} của constructor và {Prototype} chain của object được tạo ra từ constructor đó, lại hoàn toàn khác biệt, không liên quan đến nhau.</p>
<h4 id="Constructors-khong-hoat-dong-nhu-class-based-initializer"><a href="#Constructors-khong-hoat-dong-nhu-class-based-initializer" class="headerlink" title="Constructors không hoạt động như class-based initializer"></a>Constructors không hoạt động như class-based initializer</h4><p>Để có được khái niệm kế thừa thông qua prototype, Khi constructor được gọi nó tiến hành liên kết {Prototype} property của object với <code>.prototype</code> property của chính nó. Những gì còn lại là việc constructor thêm vào một số properties, methods khác cho object</p>
<h4 id="Constructors-chi-la-functions"><a href="#Constructors-chi-la-functions" class="headerlink" title="Constructors chỉ là functions"></a>Constructors chỉ là functions</h4><p>Xem lại bước <strong>#1</strong>, ta thấy MyConstructor chẳng khác gì một function bình thường. Vì vậy bất kì user-defined function nào trong Javascript cũng tự động có <code>.prototype</code> property tham chiếu đến một đối tượng sở hữu <code>.constructor</code> property tham chiếu ngược về function đó</p>
<p>Bất cứ user-defined function nào cũng được gọi thực thi như một constructor bằng cách thêm vào từ khóa new. Cách làm đó sẽ truyền object mới được tạo bởi từ khóa new vào trong constructor function, và phần việc còn lại của constructor thì như đã nói ở bên trên</p>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><p>(tham khảo từ <a href="https://zeekat.nl/articles/constructors-considered-mildly-confusing.html" target="_blank" rel="noopener">bài viết của zeekat/articles</a> với một số chỉnh sửa theo hiểu biết của bản thân và để phù hợp với Tiếng Việt)<br>(xem thêm <a href="https://stackoverflow.com/questions/1114024/constructors-in-javascript-objects" target="_blank" rel="noopener">constructor in Javascript object</a>)<br>(xem thêm <a href="https://stackoverflow.com/questions/8093057/javascript-inheritance-and-the-constructor-property/8096017#8096017" target="_blank" rel="noopener">Javascript inheritance and the constructor property</a>)<br>(xem thêm <a href="https://tc39.github.io/ecma262/#sec-fundamental-objects" target="_blank" rel="noopener">ECMA-262 lastest version</a>)</p>
<h4 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h4><p>[1]<br>John G Harris từng viết trong comp.lang.javascript rằng những gì trình bày ở bên trên cũng tương đối chưa đúng hoàn toàn. Về mặt lý thuyết, host system có thể sẽ đổi Object.prototype property bằng một thứ gì đó khác. Một số thảo luận chấp thuận rằng Object.prototype chỉ được read-only. Nhưng ở một số browser (firefox) thì ta có thể gán giá trị mới cho Object.prototype mà không có lỗi nào xảy ra.</p>
<p>[2]<br>có 4 cách để gọi thực thi (invocation) một function trong JavaScript<br>(<em>giữ nguyên văn cho dễ hiểu</em>)</p>
<p><strong>Function form:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionObject(<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure>
<p>When a function is called in the function form, this is set to the global object.</p>
<ul>
<li>that is not very useful (fixed in ES5/Strict)</li>
<li>an inner function does not get access to the outer this</li>
</ul>
<p><strong>Method form:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thisObject.methodName(agurments);</span><br><span class="line">thisObject[<span class="string">"methodName"</span>](<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<p>When a function is called in the method form, this is set to thisObject, the object containning the function.<br>this allows method to have a reference to the object of interest</p>
<p><strong>Constructor form:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> functionObject(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>When a function is called with the new operator, a new object is created and assigned to this.</li>
<li>If there is not an explicit return value, then this will be returned.</li>
<li>Used in the Pseudoclassical style</li>
</ul>
<p><strong>Apply form:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">functionObject.apply(thisObject, [<span class="built_in">arguments</span>]);</span><br><span class="line">functionObject.call(thisObject, <span class="built_in">arguments</span>....);</span><br></pre></td></tr></table></figure>
<ul>
<li>A function’s apply or call method allows for calling the function,explicitly specifying thisObject.</li>
<li>It can also take an array of parameters or a sequence of paramenters.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the definition of call method</span></span><br><span class="line"></span><br><span class="line">Funtion.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params">thisObject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.apply(thisObject, <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>, [<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/dnry2vj88r_this.png" alt="alt text"></p>
<span>Source: </span><a href="https://kipalog.com/posts/Object--Function--Method--Constructor-in-JavaScript" target="_blank" title="https://kipalog.com/posts/Object--Function--Method--Constructor-in-JavaScript" class="post-from">https://kipalog.com/posts/Object--Function--Method--Constructor-in-JavaScript</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2018/07/Functional-trong-Javascript-voi-ES6-Recursive-Patterns.html" class="prev">NEXT</a><a href="/2018/07/Memory-Leaks-trong-Javascript.html" class="next">PREV</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>