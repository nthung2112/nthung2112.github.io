<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title> Cách Javascript hoạt động P18: WebRTC & cơ chế mạng peer-to-peer · Learn and Share</title><meta name="description" content="Cách Javascript hoạt động P18: WebRTC &amp; cơ chế mạng peer-to-peer - Hung Tan Nguyen"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#FB4D42"><meta name="google-site-verification" content="rk-Nc1c8xi1CdZ0ZQIVV-ifsndGrHanIuSHI-yTHZYE"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/zoom.css"><meta property="og:title" content="Cách Javascript hoạt động P18: WebRTC &amp; cơ chế mạng peer-to-peer"><meta property="og:image" content="https://cdn-images-1.medium.com/max/800/0*iWlF5x7BVj1vh5Lu"><meta property="og:description" content="Thêm một bài nữa mang nặng kiến thức về mạng mà mình lại không chuyên về mảng này, nếu mình dịch chỗ nào không phù hợp thì nhờ mọi người giúp đỡ nhé @@_

Peer-To-Peer hay P2P: Mạng ngang hàng
Real-time: thời gian thực

Chào các bạn đến với bài thứ 18 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định."></head><body><div class="wrap"><div class="header"><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nthung2112" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item search-form-input"><div class="search-icon"><div class="search-icon__circle"></div><div class="search-icon__rectangle"></div></div></li></ul><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" placeholder="Type something..." class="ins-search-input"><span class="ins-close ins-selectable"><div class="close-icon"><div class="close-icon__x"></div><div class="close-icon__y"></div></div></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>var rootUrl = "/";
var contentUrl = '/content.json';
(function (window) {
  var INSIGHT_CONFIG = {
  TRANSLATION: {
      POSTS:'Posts',
      PAGES: 'Pages',
      CATEGORIES: 'Categories',
      TAGS: 'Tags',
      UNTITLED: '(Untitled)'
    },
    ROOT_URL: rootUrl,
    CONTENT_URL: contentUrl,
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);</script></div></div><section class="container"><div class="post"><article class="post-block"><div class="wrap"><h1 class="post-title">Cách Javascript hoạt động P18: WebRTC & cơ chế mạng peer-to-peer</h1><h2 class="post-subtitle"></h2><header class="post-info">Jan 6, 2019<div class="tags"><a href="/tags/javascript" class="tag-link">#javascript</a></div><div class="fb-ir-time"><time datetime="2019-01-05T17:00:00.000Z" class="op-modified"></time><time datetime="2019-01-05T17:00:00.000Z" class="op-published"></time></div></header></div><div class="post-banner"><img src="https://cdn-images-1.medium.com/max/800/0*iWlF5x7BVj1vh5Lu"></div><div class="wrap"><div class="post-content"><p><strong><em>Thêm một bài nữa mang nặng kiến thức về mạng mà mình lại không chuyên về mảng này, nếu mình dịch chỗ nào không phù hợp thì nhờ mọi người giúp đỡ nhé @</em>@_</strong></p>
<ul>
<li><strong>Peer-To-Peer hay P2P</strong>: Mạng ngang hàng</li>
<li><strong>Real-time</strong>: thời gian thực</li>
</ul>
<p>Chào các bạn đến với bài thứ 18 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.<br><a id="more"></a></p>
<h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Đầu tiên thì WebRTC là cái gì vậy? Nó là viết tắt của chữ <strong>R</strong>eal <strong>T</strong>ime <strong>C</strong>ommunication (Giao tiếp thời gian thực), nghe qua chắc bạn cũng đã có cái gì sơ sơ về công nghệ này rồi nhỉ.</p>
<p>WebRTC lấp đầy 1 khoảng trống lớn trong nền tảng web. Trước đây, các công nghệ P2P chẳng hạn như những app chat trên desktop có thể làm những việc mà web không làm được. Nhưng WebRTC đã thay đổi điều đó.</p>
<p>Về cơ bản WebRTC cho phép webapp có thể thiết lập giao tiếp Peer-To-Peer, chính là nội dung trong bài viết này. Ta sẽ thảo luận về các chủ đề sau đây để có thể mang đến cho bạn 1 cái nhìn toàn cảnh về “ruột gan phèo phổi” của WebRTC:</p>
<ul>
<li>Giao tiếp Peer-To-Peer</li>
<li>Tường lửa và NAT Traversal</li>
<li>Tín hiệu (Signaling), Phiên (Session), Giao thức (Protocol)</li>
<li>Các API của WebRTC</li>
</ul>
<h1 id="Giao-tiep-Peer-To-Peer"><a href="#Giao-tiep-Peer-To-Peer" class="headerlink" title="Giao tiếp Peer-To-Peer"></a>Giao tiếp Peer-To-Peer</h1><p>Để có thể giao tiếp lẫn nhau thông qua trình duyệt web, mỗi trình duyệt của user phải thực hiện những bước sau đây:</p>
<ul>
<li>Đồng ý để bắt đầu giao tiếp</li>
<li>Biết cách xác định vị trí của đối tượng</li>
<li>Vượt qua an ninh và tưởng lửa bảo vệ</li>
<li>Chuyển giao tất cả các giao tiếp đa phương tiện theo real-time</li>
</ul>
<p>1 trong số những thách thức lớn nhất liên quan đến các giao tiếp P2P dựa trên trình duyệt là làm sao để biết vị trí &amp; thiết lập 1 kết nối socket mạng (network socket connection) với 1 trình duyệt khác để vận chuyển dữ liệu 2 chiều. Ta sẽ xem xét những khó khăn liên quan đến việc thiết lập kết nối này.</p>
<p>Khi webapp của bạn cần dữ liệu hoặc tài nguyên, nó sẽ lấy về từ các server. Tuy nhiên, nếu bạn muốn tạo ra 1 ứng dụng video chat chẳng hạn, bằng cách kết nối trực tiếp đến trình duyệt của người khác - thì đây là vấn đề, vì bạn không biết địa chỉ bởi vì trình duyệt của người kia không phải là 1 web server. Vì vậy để có thể thiết lập 1 kết nối P2P ta cần rất nhiều thứ.</p>
<h1 id="Tuong-lua-va-NAT-Traversal"><a href="#Tuong-lua-va-NAT-Traversal" class="headerlink" title="Tường lửa và NAT Traversal"></a>Tường lửa và NAT Traversal</h1><p>Thường thì máy tính của bạn không không có địa chỉ IP public tĩnh. Lý do là máy tính của bạn phải núp đằng sau tường lửa và thiết bị NAT (Network access translation - Bộ phiên dịch truy cập mạng).</p>
<p>Thiết bị NAT sẽ dịch địa chỉ IP cá nhân từ bên trong tường lửa thành địa chỉ IP công khai (public-facing IP). Ta cần các thiết bị NAT để bảo mật và giải quyết sự giới hạn của IPv4 đối với những địa chỉ IP công khai sẵn có. Đó là lý do tại sao webapp không nên giả định rằng thiết bị hiện tại có 1 địa chỉ IP public tĩnh.</p>
<p>Cùng tìm hiểu 1 chút về cách hoạt động của các thiết bị NAT. Nếu như bạn đang ở trong môi trường công cộng và kết nối vào mạng WiFi, máy tính của bạn sẽ được gán 1 địa chỉ IP mà nó chỉ tồn tại đằng sau NAT. Giả sử IP là 172.0.23.4, tuy nhiên, với thế giới bên ngoài, địa chỉ IP của bạn có thể mang giá trị khác, ví dụ 164.53.27.98. Vì vậy, thế giới bên ngoài sẽ thấy các request của bạn đến từ địa chỉ 164.53.27.98 nhưng thiết bị NAT sẽ đảm bảo các response cho những request (được gửi từ máy của bạn) sẽ trả về đúng chỗ là 172.0.23.4. Ơn trời các bảng ánh xạ (mapping table). Lưu ý rằng ngoài địa chỉ IP thì cổng (port) cũng là điều kiện cần thiết cho các giao tiếp mạng.</p>
<p>Do có sự tham gia của các thiết bị NAT, trình duyệt của bạn cần tìm được địa chỉ IP của máy tính có trình duyệt mà bạn muốn giao tiếp.</p>
<p>Đến đây thì ta lại phải nhờ đến các server <strong>STUN</strong> (<strong>S</strong>ession <strong>T</strong>raversal <strong>U</strong>tilities for <strong>N</strong>AT - Tiện ích truyền tải theo phiên cho NAT) và <strong>TURN</strong> (<strong>T</strong>raversal <strong>U</strong>sing <strong>R</strong>elays around <strong>N</strong>AT - Truyền tải sử dụng điểm chuyển tiếp vòng quanh NAT). Để các công nghệ WebRTC hoạt động được, đầu tiên thì 1 request hỏi địa chỉ IP public của bạn sẽ được gửi đến server STUN. Bạn cứ nghĩ theo hướng kiểu như máy tính đang tạo truy vấn đến 1 server từ xa để hỏi về địa chỉ IP mà server đó nhận câu truy vấn là bao nhiêu. Server từ xa sẽ trả về địa chỉ IP mà nó thấy. Nói ngắn gọn là máy tính của bạn “hỏi” 1 server từ xa địa chỉ IP của chính máy bạn là bao nhiêu.</p>
<p>Giả sử tiến trình này hoạt động bình thường và bạn nhận được địa chỉ IP public của mình cũng như số port, bạn sẽ có thể nói với những peer ngang hàng khác làm thế nào để kết nối trực tiếp đến bạn. Những peer này cũng có thể làm cùng 1 việc là sử dụng STUN &amp; server TURN và nói cho bạn biết nên liên lạc đến địa chỉ nào.</p>
<h1 id="Signaling-Sessions-Protocols"><a href="#Signaling-Sessions-Protocols" class="headerlink" title="Signaling, Sessions, Protocols"></a>Signaling, Sessions, Protocols</h1><p><strong><em>Tín hiệu, phiên, giao thức</em></strong></p>
<p>Quá trình khám phá thông tin mạng được mô tả ở trên chỉ là 1 phần của chủ đề về Signaling to bự hơn nhiều, trong trường hợp của WebRTC thì phần signaling này dựa trên 1 chuẩn JSEP (<strong>J</strong>avascript <strong>S</strong>ession <strong>E</strong>stablishment <strong>P</strong>rotocol - Giao thức thiết lập phiên của Javascript). Signaling bao gồm cả khám phá mạng (network discovery) và NAT Traversal, tạo và quản lý phiên, bảo mật giao tiếp, siêu dữ liệu (metadata) và phối hợp khả năng của media, xử lý lỗi.</p>
<p>Để kết nối có thể hoạt động, peer thu được những điều kiện về local media cho metadata (ví dụ: những khả năng về kích thước và kiểu codec) và gom góp các địa chỉ mạng có thể có cho host của ứng dụng. Cơ chế signaling dùng để truyền tới/lui những thông tin quan trọng này không được định nghĩa trong API của WebRTC.</p>
<p>Signaling không được quy định bởi chuẩn WebRTC và nó không được triển khai bằng API của nó để cho phép sử dụng một cách linh động các công nghệ và giao thức cần thiết. Các WebRTC developer sẽ đối phó với signaling và server xử lý signaling.</p>
<p>Giả sử app WebRTC dựa trên trình duyệt của bạn có thể xác định được địa chỉ IP public của nó bằng cách sử dụng STUN như đã nói ở trên, bước tiếp theo thực sự là 1 màn đàm phán &amp; thiết lập phiên kết nối đến với peer.</p>
<p>Phần đàm phán và thiết lập khởi tạo phiên xảy ra khi dùng 1 giao thức signaling/giao tiếp được đặc tả trong các giao tiếp đa phương tiện. Giao thức này cũng chịu trách nhiệm cho việc điều hành các quy định trong đó phiên được quản lý và hủy bỏ.</p>
<p>Một trong số các giao thức như vậy có tên là <strong>S</strong>ession <strong>I</strong>nitiation <strong>P</strong>rotocol (SIP - Giao thức khởi tạo phiên). Lưu ý rằng do sự linh động của WebRTC signaling, SIP không phải là giao thức signaling duy nhất có thể dùng. Giao thức signaling được chọn phải hoạt động với 1 giao thức ở tầng ứng dụng gọi là <strong>S</strong>ession <strong>D</strong>escription <strong>P</strong>rotocol (SDP - Giao thức mô tả phiên), giao thức này được sử dụng trong trường hợp của WebRTC. Tất cả các metadata đa phương tiện cụ thể được truyền đi bằng giao thức SDP này.</p>
<p>Bất kỳ peer nào (ví dụ: app tận dụng WebRTC) thử giao tiếp với 1 peer khác đều sinh ra 1 tập các ứng viên giao thức Interactive Connectivity Establishment (ICE - Thiết lập kết nối tương tác). Những ứng viên này biểu diễn 1 bộ kết hợp của địa chỉ IP, port, giao thức giao vận được dùng. Lưu ý rằng 1 máy tính có thể có nhiều giao diện mạng (không dây, có dây, vân vân), vì thế có thể được gán nhiều địa chỉ IP cho mỗi giao diện.</p>
<p>Dưới đây là sơ đồ lấy từ MDN mô tả lại sự trao đổi:<br><img src="https://cdn-images-1.medium.com/max/1000/0*SXRTlnVxy2-hE9ZX" alt=""></p>
<h1 id="Thiet-lap-ket-noi"><a href="#Thiet-lap-ket-noi" class="headerlink" title="Thiết lập kết nối"></a>Thiết lập kết nối</h1><p>Mỗi peer đầu tiên phải thiết lập địa chỉ IP public như đã nói ở trên. “Kênh” (channel) dữ liệu signaling sau đó được tự động tạo ra để xác định các peer và hỗ trợ đàm phán peer-to-peer và thiết lập phiên.</p>
<p>Thế giới bên ngoài hoàn toàn không biết hoặc không thể truy xuất đến những “kênh” này và nó cũng yêu cầu 1 định danh duy nhất nếu muốn truy cập.</p>
<p>Lưu ý rằng, do sự linh động của WebRTC và cũng bởi tiến trình signaling không được cụ thể hóa trong các tiêu chuẩn, ý tưởng và cách thực hiện của “kênh” có thể sẽ có ít nhiều khác biệt tuy vào công nghệ sử dụng. Rõ ràng, 1 vài giao thức không cần đến cơ chế “kênh” mà vãn giao tiếp được.</p>
<p>Chúng ta sẽ giả sử rằng “kênh” được dùng trong việc triển khai cho các mục đích được nhắc tới ở bài viết này.</p>
<p>Một khi 2 hoặc nhiều peer đã cùng kết nối vào 1 “kênh” thì những peer đã có thể giao tiếp và trao đổi thông tin phiên. Tiến trình này về mặt nào đó thì tương tự như <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" target="_blank" rel="noopener">mô hình publish/subscribe</a>. Về cơ bản, peer khởi tạo ban đầu sẽ gửi 1 “lời đề nghị” sử dụng 1 giao thức signaling chẳng hạn như Session Initiation Protocol (SIP - Giao thức khởi tạo phiên) và SDP. Người khởi tạo sẽ chờ để nhận được “câu trả lời” từ bất kỳ người nhận nào đã kết nối với “kênh”.</p>
<p>Khi đã nhận được câu trả lời, 1 tiến trình diễn ra để xác định và trao đổi giao thức ứng viên ICE tốt nhất (Interactive Connectivity Establishment - Thiết lập kết nối tương tác) mà mỗi peer thu thập được. Một khi chọn được ứng viên ICE tối ưu thì về cơ bản sẽ có nhiều thứ theo sau đó được chấp nhận, bao gồm: những metadata cần thiết, các định tuyến mạng (địa chỉ IP và port) và các thông tin media thường dùng để giao tiếp với mỗi peer. Phiên mạng socket mạng giữa những peer sau đó được thiết lập hoàn chỉnh và kích hoạt. Tiếp đó, các luồng dữ liệu local và các endpoint kênh dữ liệu được tạo ra bởi mỗi peer, dữ liệu đa phương tiện cuối cùng được chuyển đi theo cả 2 đường sử dụng bất kỳ công nghệ giao tiếp 2 chiều nào.</p>
<p>Nếu như tiến trình đồng ý chấp nhận ứng viên ICE tốt nhất bị thất bại, thỉnh thoảng nguyên nhân là do tường lửa hoặc kỹ thuật NAT đang dùng, thì giải pháp dự phòng sau đó là sử dụng 1 server TURN dưới dạng 1 điểm chuyển tiếp thay thế. Tiến trình này về cơ bản sẽ dùng 1 server hoạt động như người trung gian và nó chuyển tiếp bất kỳ dữ liệu nào truyền qua lại giữa các peer. Lưu ý rằng đây không phải là giao tiếp peer-to-peer thực thụ trong đó các peer truyền dữ liệu 2 chiều trực tiếp đến với nhau.</p>
<p>Khi sử dụng giải pháp dự phòng TURN để giao tiếp, mỗi peer sẽ không cần phải biết làm thế nào để liên lạc và truyền dữ liệu đến bên kia. Thay vào đó, nó cần biết server TURN public nào để gửi và nhận dữ liệu đa phương tiện theo thời gian thực xuyên suốt phiên giao tiếp.</p>
<p>Điều quan trọng cần phải hiểu rằng đây chắc chẳn là 1 dạng “kế hoạch dự phòng” và chỉ dùng khi không còn cách nào khác. Các server TURN phải khá vững chắc, có băng thông rộng, khả năng xử lý và có thể xử lý 1 lượng lớn dữ liệu tiềm tàng. Cách sử dụng server TURN vì thế rõ ràng là sẽ phát sinh thêm chi phí và sự phức tạp.</p>
<h1 id="Cac-API-cua-WebRTC"><a href="#Cac-API-cua-WebRTC" class="headerlink" title="Các API của WebRTC"></a>Các API của WebRTC</h1><p>Có 3 mục phân loại API chính trong WebRTC:</p>
<ul>
<li><strong>Media Capture and Streams</strong> (luồng media và chụp media) - cho phép bạn truy xuất vào các thiết bị đầu vào, chẳng hạn như microphone hay web camera. API cho phép bạn lấy 1 luồng media từ các thiết bị đó.</li>
<li><strong>RTCPeerConnection</strong> - dùng những API này, bạn có thể gửi theo thời gian thực 1 luồng âm thanh &amp; hình ảnh đã bắt được thông qua internet đến 1 endpoint WebRTC khác. Bạn có thể tạo ra kết nối giữa máy local và peer từ xa. Nó cũng cung cấp các phương thức để kết nối đến 1 peer từ xa, duy trì và kiểm soát kết nối &amp; đóng kết nối 1 khi ta không cần đến nó nữa.</li>
<li><strong>RTCDataChannel</strong> - API này cho phép bạn truyền dữ liệu tùy ý. Mỗi kênh dữ liệu được liên kết với 1 RTCPeerConnection.</li>
</ul>
<p>Chúng ta sẽ đi sâu vào thảo luận mỗi loại trên.</p>
<h2 id="Media-Capture-amp-Streams"><a href="#Media-Capture-amp-Streams" class="headerlink" title="Media Capture &amp; Streams"></a>Media Capture &amp; Streams</h2><p>API <strong>Media Capture &amp; Streams</strong>, thường được gọi là <em>Media Stream API</em> hoặc <em>Stream API</em>, là 1 API hỗ trợ những luồng (stream) dữ liệu âm thanh hay hình ảnh, các phương thức để làm việc với chúng, những hạn chế liên kết với từng loại dữ liệu, callback thành công/thất bại khi sử dụng dữ liệu bất đồng bộ và những sự kiện được bắn ra suốt quá trình.</p>
<p>Phương thức getUserMedia() của <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices" target="_blank" rel="noopener">MediaDevices</a> nhắc nhở người dùng cấp quyền để sử dụng đầu vào media, nó tạo ra 1 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream" target="_blank" rel="noopener">MediaStream</a> kèm với các track chứa kiểu request của media. Luồng đó có thể chứa 1 track video (được tạo ra bởi phần cứng hay nguồn video ảo chẳng hạn như camera, thiết bị ghi video, dịch vụ chia sẻ màn hình, vân vân), 1 track audio (tương tự, được tạo ra bởi nguồn ghi vật lý hoặc nguồn ghi ảo như microphone, bộ chuyển A/D…) và có thể có cả những loại track khác.</p>
<p>Nó sẽ trả về 1 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a> và resolve thành object <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream" target="_blank" rel="noopener">MediaStream</a>. Nếu người dùng từ chối cấp quyền hoặc là media phù hợp không tồn tại thì promise đó sẽ bị reject với PermissionDeniedError hoặc NotFoundError.</p>
<p>Mô hình singleton MediaDevice có thể được truy xuất thông qua object navigator như sau:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">navigator.mediaDevices.getUserMedia(constraints)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line"> <span class="comment">/* use the stream */</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"> <span class="comment">/* handle the error */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Lưu ý là bạn cần truyền object constraints để nói cho API loại stream nào để trả về. Bạn có thể cấu hình tất cả những thứ linh tinh liên quan, bao gồm cả camera mà bạn dùng (camera trước/sau), tần suất khung hình, độ phân giải, vân vân.</p>
<p>Kể từ phiên bản 25, các trình duyệt dựa trên nhân Chromium cho phép dữ liệu âm thanh từ getUserMedia() có thể được truyền đến element audio hoặc video (nhưng lưu ý rằng mặc định thì các media element bị tắt tiếng (mute))</p>
<p>getUserMedia còn có thể được dùng như 1 <a href="http://updates.html5rocks.com/2012/09/Live-Web-Audio-Input-Enabled" target="_blank" rel="noopener">node đầu vào cho Web Audio API</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gotStream</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.AudioContext = <span class="built_in">window</span>.AudioContext || <span class="built_in">window</span>.webkitAudioContext;</span><br><span class="line">    <span class="keyword">var</span> audioContext = <span class="keyword">new</span> AudioContext();</span><br><span class="line">    <span class="comment">// Tạo AudioNode từ stream</span></span><br><span class="line">    <span class="keyword">var</span> mediaStreamSource = audioContext.createMediaStreamSource(stream);</span><br><span class="line">    <span class="comment">// Kết nối nó đến điểm đích để nghe bạn </span></span><br><span class="line">    <span class="comment">// hoặc bất kỳ node nào khác đang xử lý</span></span><br><span class="line">    mediaStreamSource.connect(audioContext.destination);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">navigator.getUserMedia(&#123;<span class="attr">audio</span>:<span class="literal">true</span>&#125;, gotStream);</span><br></pre></td></tr></table></figure>
<h3 id="Gioi-han-ve-su-rieng-tu"><a href="#Gioi-han-ve-su-rieng-tu" class="headerlink" title="Giới hạn về sự riêng tư"></a>Giới hạn về sự riêng tư</h3><p>Là 1 API có thể chứa nhiều điều lo ngại đáng kể về quyền riêng tư, getUserMedia() được tổ chức bởi các đặc điểm kỹ thuật với những yêu cầu rất cụ thể về thông báo người dùng và quản lý quyền truy cập. getUserMedia() phải luôn luôn xin quyền từ người dùng trước khi mở bất kỳ thiết bị thu thập thông tin media nào chẳng hạn như webcam hay microphone. Trình duyệt có thể có tính năng cấp quyền trên mỗi domain (once-per-domain), nhưng nó phải hỏi bạn ít nhất là lần đầu tiên hoạt động và người dùng phải đặc biệt cấp quyền tiếp theo nếu họ muốn.</p>
<p>Một điều quan trọng tương đương là các quy định xung quanh thông báo (notification). Trình duyệt được yêu cầu phải hiển thị 1 thông số thể hiện camera hoặc microphone đang hoạt động, hơn hết thảy bất kỳ thông số thể hiện phần cứng nào khác. Họ cũng phải hiện 1 chỉ số cho thấy rằng quyền được được cấp để sử dụng thiết bị đầu vào, kể cả nếu như thiết bị đó chưa được kích hoạt để ghi chép tại thời điểm đó.</p>
<h1 id="RTCPeerConnection"><a href="#RTCPeerConnection" class="headerlink" title="RTCPeerConnection"></a>RTCPeerConnection</h1><p>Giao diện <strong>RTCPeerConnection</strong> thể hiện 1 kết nối WebRTC giữa máy tính local và peer từ xa. Nó cung cấp các phương thức để kết nối đến peer từ xa, duy trì, kiểm soát kết nối và ngắt kết nối một khi nó không cần dùng tới nữa.</p>
<p>Dưới đây là 1 mô hình kiến trúc của WebRTC thể hiện vai trò của RTCPeerConnection:<br><img src="https://cdn-images-1.medium.com/max/1000/0*Nm9r_NLcAhJernmo" alt=""></p>
<p>Từ góc độ của Javascript, điều cần hiểu trong mô hình trên là <strong>RTCPeerConnection</strong> trao cho các web developer một cái nhìn tinh tế từ những sự phức tạp xuất phát từ đống “nội tạng” rối rắm bên dưới. Các mã codec và giao thức được dùng bởi WebRTC thực hiện 1 lượng lớn công việc dể làm cho giao tiếp real-time hoạt động được, kể cả với các mạng không đáng tin cậy:</p>
<ul>
<li>Che dấu mất gói tin (Package loss concealment - PLC, là 1 kỹ thuật dùng để che đậy ảnh hưởng của tình trạng mất gói tin trong giao tiếp VoIP)</li>
<li>Hủy bỏ phản hồi (Echo cancellation - trong mạng máy tính thì “echo” được hiểu là quá trình gửi trả về gói tin đã gửi đi)</li>
<li>Khả năng thích ứng băng thông</li>
<li>Bộ đệm jitter động (jitter buffer - Trong kỹ thuật VoIP thì jitter buffer là vùng dữ liệu chia sẻ nơi mà các gói tin âm thanh có thể được thu thập, lưu trữ và gửi đi đến bộ xử lý âm thanh)</li>
<li>Tự động chiếm quyền kiểm soát</li>
<li>Giảm nhiễu và xóa nhiễu</li>
<li>“Dọn dẹp” hình ảnh</li>
</ul>
<h1 id="RTCDataChannel"><a href="#RTCDataChannel" class="headerlink" title="RTCDataChannel"></a>RTCDataChannel</h1><p>Cũng như hình ảnh và âm thanh, WebRTC cũng hỗ trợ giao tiếp real-time cho các loại dữ liệu khác.</p>
<p>API RTCDataChannel cho phép peer-to-peer trao đổi các dữ liệu tùy ý.</p>
<p>Có rất nhiều trường hợp sử dụng API này, ví dụ:</p>
<ul>
<li>Dùng trong các game</li>
<li>Ứng dụng chat real-time</li>
<li>Truyền file</li>
<li>Các mạng phi tập trung</li>
</ul>
<p>API cũng có nhiều tính năng để tận dụng tối đa RTCPeerConnection và kích hoạt sức mạnh cũng như sự linh động của giao tiếp peer-to-peer:</p>
<ul>
<li>Tận dụng cài đặt phiên của RTCPeerConnection</li>
<li>Đa kênh đồng thời với khả năng phân chia mức độ ưu tiên</li>
<li>Ngữ cảnh vận chuyển đáng tin cậy và không đáng tin cậy.</li>
<li>Tích hợp sẵn bảo mật (DTLS) và kiểm soát tắc nghẽn.</li>
</ul>
<p>Cú pháp tương tự như WebSocket mà ta đã biết, với phương thức send() và sự kiện message:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peerConnection = <span class="keyword">new</span> webkitRTCPeerConnection(servers,</span><br><span class="line">    &#123;<span class="attr">optional</span>: [&#123;<span class="attr">RtpDataChannels</span>: <span class="literal">true</span>&#125;]&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">peerConnection.ondatachannel = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    receiveChannel = event.channel;</span><br><span class="line">    receiveChannel.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">"#receiver"</span>).innerHTML = event.data;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sendChannel = peerConnection.createDataChannel(<span class="string">"sendDataChannel"</span>, &#123;<span class="attr">reliable</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"button#send"</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">document</span>.querySelector(<span class="string">"textarea#send"</span>).value;</span><br><span class="line">    sendChannel.send(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Sự giao tiếp diễn ra trực tiếp giữa các trình duyệt, vì thế RTCDataChannel có thể nhanh hơn nhiều so với WebSocket kể cả khi cần đến 1 server chuyển tiếp (TURN).</p>
<h1 id="WebRTC-trong-the-gioi-thuc"><a href="#WebRTC-trong-the-gioi-thuc" class="headerlink" title="WebRTC trong thế giới thực"></a>WebRTC trong thế giới thực</h1><p>Trong thế giới thực thì WebRTC cần có server, tuy nhiên thực tế lại đơn giản hơn:</p>
<ul>
<li>Các user tự khám phá ra đối tác của họ và trao đổi các chi tiết chẳng hạn như tên.</li>
<li>Các ứng dụng WebRTC phía client (các peer) trao đổi thông tin mạng.</li>
<li>Các peer trao đổi dữ liệu về media chẳng hạn như định dạng hình ảnh và độ phân giải.</li>
<li>Các ứng dụng WebRTC phía client di chuyển xuyên qua các <a href="http://en.wikipedia.org/wiki/NAT_traversal" target="_blank" rel="noopener">cổng NAT</a> và tường lửa.</li>
</ul>
<p>Nói cách khác, WebRTC cần phải có 4 tính năng ở phía server:</p>
<ul>
<li>User khám phá ra và giao tiếp.</li>
<li>Signaling</li>
<li>Di chuyển NAT/tường lửa</li>
<li>Các server chuyển tiếp trong trường hợp giao tiếp peer-to-peer thất bại.</li>
</ul>
<p>Giao thức <a href="http://en.wikipedia.org/wiki/STUN" target="_blank" rel="noopener">STUN</a> và bản mở rộng <a href="http://en.wikipedia.org/wiki/Traversal_Using_Relay_NAT" target="_blank" rel="noopener">TURN</a> của nó được dùng bởi <a href="http://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment" target="_blank" rel="noopener">ICE</a> để kích hoạt RTCPeerConnection nhằm đối phó với di chuyển NAT và các thay đổi mạng mơ hồ khác.</p>
<p>Như đã nhắc đến trước đó, ICE là 1 giao thức để kết nối các peer, chẳng hạn như 2 ứng dụng video chat client. Khi khởi tạo, ICE sẽ thử kết nối trực tiếp đến các peer với độ trễ thấp nhất có thể thông qua UDP. Trong tiến trình này, các server STUN có 1 tác vụ duy nhất: kích hoạt 1 peer phía sau NAT để tìm địa chỉ public &amp; số port. Bạn có thể kiểm tra các server STUN đang tồn tại ở danh sách này (Google cũng có 1 số server)</p>
<p>|  | # source : <a href="http://code.google.com/p/natvpn/source/browse/trunk/stun_server_list" target="_blank" rel="noopener">http://code.google.com/p/natvpn/source/browse/trunk/stun_server_list</a> |<br>|  | # A list of available STUN server. |<br>|  |  |<br>|  | stun.l.google.com:19302 |<br>|  | stun1.l.google.com:19302 |<br>|  | stun2.l.google.com:19302 |<br>|  | stun3.l.google.com:19302 |<br>|  | stun4.l.google.com:19302 |<br>|  | stun01.sipphone.com |<br>|  | stun.ekiga.net |<br>|  | stun.fwdnet.net |<br>|  | stun.ideasip.com |<br>|  | stun.iptel.org |<br>|  | stun.rixtelecom.se |<br>|  | stun.schlund.de |<br>|  | stunserver.org |<br>|  | stun.softjoys.com |<br>|  | stun.voiparound.com |<br>|  | stun.voipbuster.com |<br>|  | stun.voipstunt.com |<br>|  | stun.voxgratia.org |<br>|  | stun.xten.com |</p>
<p><a href="https://gist.github.com/zziuni/3741933/raw/212e4b6316110dc5c128d08f65ff8f174d7ae383/stuns" target="_blank" rel="noopener">view raw</a> <a href="https://gist.github.com/zziuni/3741933#file-stuns" target="_blank" rel="noopener">stuns</a> hosted with ❤ by <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>.<br><img src="https://cdn-images-1.medium.com/max/1000/1*ONNxJHqmMTXB1Nuq3qTNXQ.png" alt=""></p>
<h2 id="Tim-nhung-ung-vien-ket-noi"><a href="#Tim-nhung-ung-vien-ket-noi" class="headerlink" title="Tìm những ứng viên kết nối"></a>Tìm những ứng viên kết nối</h2><p>Nếu như UDP thất bại, ICE sẽ thử TCP: đầu tiên là HTTP, sau đó là HTTPS. Nếu kết nối trực tiếp thất bại - cụ thể là bởi vì dịch chuyển NAT &amp; tường lửa mức độ doanh nghiệp - ICE sẽ dùng 1 server TURN trung gian (điểm chuyển tiếp). Nói cách khác, ICE đầu tiên sẽ dùng STUN với UDP để kết nối trực tiếp các peer với nhau, nếu thất bại, nó sẽ đổi kế hoạch sang dùng server chuyển tiếp TURN. Cụm từ “tìm kiếm ứng viên” nhắc đến quá trình tìm kiếm các giao diện mạng &amp; port.<br><img src="https://cdn-images-1.medium.com/max/1000/1*0REL14sYPR34hY7yua6-PA.png" alt=""></p>
<h1 id="Bao-mat"><a href="#Bao-mat" class="headerlink" title="Bảo mật"></a>Bảo mật</h1><p>Có rất nhiều cách mà 1 ứng dụng hoặc plugin giao tiếp real-time có thể bị ảnh hưởng về bảo mật. Ví dụ:</p>
<ul>
<li>Dữ liệu hoặc media không được mã hóa có thể bị chặn trên đường đi giữa các trình duyệt hay giữa trình duyệt và server</li>
<li>Một ứng dụng có thể ghi chép và phân phối âm thanh, hình ảnh mà user hoàn toàn không biết</li>
<li>Malware hoặc virus máy tính có thể được cài đặt cùng với 1 ứng dụng hoặc plugin vớ vẩn.</li>
</ul>
<p>WebRTC có nhiều tính năng để tránh các vấn đề trên:</p>
<ul>
<li>WebRTC triển khai sử dụng các giao thức bảo mật chẳng hạn như <a href="http://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security" target="_blank" rel="noopener">DTLS</a> và <a href="http://en.wikipedia.org/wiki/Secure_Real-time_Transport_Protocol" target="_blank" rel="noopener">SRTP</a></li>
<li>Mã hóa là điều cần thiết đối với tất cả các component của WebRTC, bao gồm cả cơ chế signaling.</li>
<li>WebRTC không phải là 1 plugin: các component của nó chạy trong sandbox của trình duyệt và không chạy ở luồng riêng, các component không yêu cầu cài đặt riêng lẻ và được cập nhật mỗi khi trình duyệt được cập nhật.</li>
<li>Truy xuất camera và microphone phải được cấp quyền rõ ràng và khi camera hoặc microphone đang hoạt động thì phải được thể hiện ra ở phía giao diện người dùng.</li>
</ul>
<p>WebRTC là 1 công nghệ cực kỳ thú vị &amp; mạnh mẽ dành cho các sản phẩm cần làm việc với mô hình truyền tải real-time giữa các trình duyệt.</p>
<p>Ví dụ, ở SessionStack, họ cho phép user tích hợp thư viện Javascript của họ vào bên trong webapp của user. Nhiệm vụ của nó là bắt đầu thu thập các dữ liệu như sự kiện người dùng, thay đổi trên DOM, dữ liệu mạng, biệt lệ, thông báo debug, vân vân, và gửi chúng về cho server.</p>
<p>Trong khi đó, user của bạn có thể vào trong webapp của họ, mở 1 phiên làm việc bình thường và xem nó hoạt động theo thời gian thực. Sử dụng các dữ liệu thu thập được, SessionStack có thể tái tạo mọi thứ đã từng xảy ra trên trình duyệt của user, kết hợp các thông tin về hình ảnh thuần túy với 1 bộ giả lập console của trình duyệt và mọi thứ bên trong nó. Bạn cứ nghĩ nó giống như desktop từ xa nhưng không bắt người dùng cuối phải tải về bất cứ chương trình nào. Và trên hết tất cả các thông tin hình ảnh, bạn có thể thực sự thấy được các thông tin kỹ thuật lấy từ phiên.</p>
<p>Họ đã làm được tất cả điều đó thuần túy với các server, tuy nhiên sử dụng WebRTC họ có thể thật sự không cần phụ thuộc vào server nữa mà giao tiếp trực tiếp giữa các trình duyệt với nhau, giảm độ trễ và sức mạnh tính toán cần thiết.</p>
<span>Source: </span><a href="https://blog.sessionstack.com/how-javascript-works-webrtc-and-the-mechanics-of-peer-to-peer-connectivity-87cc56c1d0ab" target="_blank" title="https://blog.sessionstack.com/how-javascript-works-webrtc-and-the-mechanics-of-peer-to-peer-connectivity-87cc56c1d0ab" class="post-from">https://blog.sessionstack.com/how-javascript-works-webrtc-and-the-mechanics-of-peer-to-peer-connectivity-87cc56c1d0ab</a></div></div></article></div></section><div class="wrap"><footer><div class="paginator"><a href="/2019/01/Cach-Javascript-hoat-dong-P19-Ben-trong-custom-element-thu-thuat-xay-dung-component-toi-uu.html" class="prev">NEXT</a><a href="/2019/01/Cach-Javascript-hoat-dong-P17-Ben-trong-Shadow-DOM-xay-dung-component-khep-kin.html" class="next">PREV</a></div><div class="copyright"><p>© 2017 - 2019 <a href="http://nthung2112.github.io">Hung Tan Nguyen</a>, unless otherwise noted.</p></div></footer></div><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41935289-1",'auto');ga('send','pageview');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/js/zoom.js"></script><script src="/js/insight.js"></script></body></html>