<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Learn and Share</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nthung2112.github.io/"/>
  <updated>2018-11-25T09:44:30.253Z</updated>
  <id>http://nthung2112.github.io/</id>
  
  <author>
    <name>Hung Tan Nguyen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cách Javascript hoạt động P16: Engine lưu trữ + lựa chọn API lưu trữ nào cho phù hợp</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P16-Engine-luu-tru-lua-chon-API-luu-tru-nao-cho-phu-hop.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P16-Engine-luu-tru-lua-chon-API-luu-tru-nao-cho-phu-hop.html</id>
    <published>2018-11-25T09:42:00.000Z</published>
    <updated>2018-11-25T09:44:30.253Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 16 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Lựa chọn cơ chế lưu trữ đúng đắn cho thiết bị lưu trữ ở local rất quan trọng khi thiết kế webapp. Một engine lưu trữ tốt sẽ đảm bảo thông tin của bạn được lưu chắc chắn, giảm băng thông và cải thiện sự phản hồi. Chiến lược lưu trữ bộ nhớ đệm phù hợp là thành phần cốt lõi cho phép trải nghiệm mobile web offline, càng ngày càng có nhiều người dùng cảm thấy rằng như đó là trải nghiệm mặc định phải có.</p><p>Trong chương này, chúng ta sẽ thảo luận về những API lưu trữ có sẵn &amp; các service và cung cấp một số hướng dẫn làm thế nào để lựa chọn đúng loại cho webapp của bạn.<br><a id="more"></a></p><h1 id="Data-model-mo-hinh-du-lieu"><a href="#Data-model-mo-hinh-du-lieu" class="headerlink" title="Data model (mô hình dữ liệu)"></a>Data model (mô hình dữ liệu)</h1><p>Mô hình lưu trữ dữ liệu xác định làm thế nào để dữ liệu được tổ chức nội bộ. Điều này ảnh hưởng toàn bộ thiết kế của webapp, định nghĩa sự cân bằng để làm cho webapp hoạt động hiệu quả nhưng vẫn giải quyết được vấn đề cần giải quyết. Giống như bất cứ thứ gì liên quan đến kỹ thuật, không tồn tại phương pháp nào “tốt hơn” và cũng không có giải pháp một-cho-tất-cả nào hết. Cùng xem qua 1 chút về một số data model mà ta có thể dùng:</p><ul><li><strong>Kiểu cấu trúc</strong>: Dữ liệu được lưu trong các bảng kèm với các trường đã được định nghĩa, giống như các hệ quản trị cơ sở dữ liệu đặc trưng dựa trên SQL, chúng có tính linh hoạt và các câu truy vấn động. Một ví dụ nổi bật về kho dữ liệu kiểu cấu trúc trên trình duyệt chính là IndexedDB.</li><li><strong>key/value</strong>: kho dữ liệu key/value, và cả cơ sở dữ liệu NoSQL, cho phép lưu trữ và trích xuất dữ liệu không có cấu trúc được đánh index bằng 1 key duy nhất. Kho dữ liệu kiểu key/value giống như bảng băm (hash table) ở chỗ chúng cho phép truy cập liên tục vào các dữ liệu ẩn đã được đánh index. Một ví dụ điển hình cho kho dữ liệu key/value là Cache API trên trình duyệt và Apache Cassandra trên server.</li><li><strong>Byte Streams</strong>: mô hình đơn giản này lưu dữ liệu dưới dạng 1 biến độ dài, một chuỗi ẩn các byte, và nó để lại bất kỳ hình thức tổ chức nội bộ nào cho lớp ứng dụng. Mô hình này đặc biệt tốt cho các hệ thống tập tin (file) và các blob dữ liệu có tổ chức dạng phân cấp. Ví dụ điển hình của kho dữ liệu byte stream bao gồm những hệ thống file và các dịch vụ lưu trữ cloud.</li></ul><h1 id="Tinh-ben-vung"><a href="#Tinh-ben-vung" class="headerlink" title="Tính bền vững"></a>Tính bền vững</h1><p>Có thể phân tích các phương pháp lưu trữ cho webapp với sự mức độ ưu tiên cho timeframe hơn là dữ liệu nào cần được bền vững:</p><ul><li><strong>Session Persistence (Bền vững phiên)</strong>: dữ liệu trong mục này chỉ được giữ cố định miễn là một session của web hoặc một tab trên trình duyệt vẫn đang hoạt động. Ví dụ về cơ chế lưu trữ với phiên bền vững chính là <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener">Session Storage API</a></li><li><strong>Device Persistence (Bền vững thiết bị)</strong>: dữ liệu trong mục này được giữ cố định xuyên suốt nhiều session và nhiều tab hoặc cửa sổ trình duyệt, trên 1 thiết bị cụ thể. Ví dụ: <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage" target="_blank" rel="noopener">Cache API</a></li><li><strong>Global Persistence (Bền vững toàn cục)</strong>: dữ liệu trong mục này được giữ cố định xuyên suốt các session &amp; các thiết bị. Vì thế, đây là dạng mạnh mẽ nhất của bền vững dữ liệu. Nó không được lưu trữ trên chính thiết bị và điều đó nghĩa là bạn cần phải có 1 kiểu lưu trữ ở phía server. Chúng ta sẽ không thảo luận chi tiết về nó vì bài viết này chỉ tập trung vào lưu trữ dữ liệu trên thiết bị.</li></ul><h1 id="Ben-vung-du-lieu-tren-trinh-duyet"><a href="#Ben-vung-du-lieu-tren-trinh-duyet" class="headerlink" title="Bền vững dữ liệu trên trình duyệt"></a>Bền vững dữ liệu trên trình duyệt</h1><p>Ngày nay có rất ít các browser API cho phép bạn lưu trữ dữ liệu. Chúng ta sẽ tìm hiểu qua một vài thứ như thế và tạo 1 bản so sánh để có thể dễ dàng lựa chọn giải pháp phù hợp.</p><p>Tuy nhiên thì đầu tiên, có vài thứ bạn cần phải cân nhắc trước khi chọn làm thế nào để cố định dữ liệu. Dĩ nhiên thì thứ đầu tiên bạn cần phải hiểu kỹ chính là webapp của bạn được dùng như thế nào, sau đó còn có bảo trì và nâng cấp. Thậm chí nếu bạn có câu trả lời cho các câu hỏi đó, bạn cũng sẽ phải kết thúc với 1 số lựa chọn và chọn chúng. Vì thế nên dưới đây là 1 số thứ bạn nên xem qua:</p><ul><li><strong>Trình duyệt hỗ trợ</strong>: bạn cần phải nhớ kỹ 1 sự thật là các API được xây dựng tốt &amp; được chuẩn hóa có mức độ ưu ái cao hơn, bởi vì chúng hướng tới sự tồn tại lâu dài và được hỗ trợ rộng rãi. Những API đó cũng thường có tài liệu rộng hơn và cộng đồng developer hỗ trợ giàu kinh nghiệm hơn.</li><li><strong>Transactions (giao dịch)</strong>: đôi khi transactions rất quan trọng đối với 1 tập hợp của các hoạt động lưu trữ tự động thành công hay thất bại. Các cơ sở dữ liệu theo truyền thống luôn hỗ trợ tính năng này sử dụng 1 mô hình transaction, những cập nhật liên quan được nhóm lại thành các đơn vị chuyên biệt.</li><li><strong>Sync/Async (đồng bộ/bất đồng bộ)</strong>: một vài API lưu trữ thể hiện sự đồng bộ khi mà các request lưu trữ hoặc lấy dữ liệu sẽ chặn tiến trình đang hoạt động cho tới khi request được hoàn thành. Sử dụng API lưu trữ đồng bộ có thể chặn tiến trình chính và làm cho trải nghiệm UI trên webapp bị đông cứng không hoạt động. Nếu có thể, hãy dùng các API bất đồng bộ.</li></ul><h1 id="So-sanh"><a href="#So-sanh" class="headerlink" title="So sánh"></a>So sánh</h1><p>Trong phần này, chúng ta sẽ so sánh các API hiện có dành cho web developer và so sánh chúng với các tiêu chí đã nói ở trên</p><table><thead><tr><th>API</th><th>Mô hình dữ liệu (Data model)</th><th>Tính bền vững (persistence)</th><th>Trình duyệt hỗ trợ</th><th>Transactions</th><th>Sync/Async</th></tr></thead><tbody><tr><td>File System (hệ thống file)</td><td>Byte stream</td><td>thiết bị</td><td>52%</td><td>Không</td><td>Async</td></tr><tr><td>Local Storage</td><td>key/value</td><td>thiết bị</td><td>93%</td><td>Không</td><td>Sync</td></tr><tr><td>Session Storage</td><td>key/value</td><td>session</td><td>93%</td><td>Không</td><td>Sync</td></tr><tr><td>Cookies</td><td>cấu trúc</td><td>thiết bị</td><td>100%</td><td>Không</td><td>Sync</td></tr><tr><td>Cache</td><td>key/value</td><td>thiết bị</td><td>60%</td><td>Không</td><td>Async</td></tr><tr><td>IndexedDB</td><td>hỗn hợp (hybrid)</td><td>thiết bị</td><td>83%</td><td>Có</td><td>Async</td></tr></tbody></table><h1 id="File-System-API-he-thong-file"><a href="#File-System-API-he-thong-file" class="headerlink" title="File System API (hệ thống file)"></a>File System API (hệ thống file)</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*9KPehy4mUb8f-hSp" alt=""></p><p>Với File System API, webapp có thể tạo, đọc, điều hướng và ghi vào 1 khu vực sandbox thuộc hệ thống local file của user.</p><p>API được chia nhỏ thành nhiều chủ đề:</p><ul><li>Đọc và sửa file: File/Blob, FileList, FileReader</li><li>Tạo và ghi file: Blob(), FileWriter</li><li>Các thư mục và truy cập hệ thống file: DirectoryReader, FileEntry/DirectoryEntry, LocalFileSystem</li></ul><p>File System API không phải là 1 hệ thống API tiêu chuẩn. Bạn không nên dùng nó trên sản phẩm webapp production bởi vì nó sẽ không hoạt động với tất cả user. Có rất sự không tương thích lớn giữa các triển khai khác nhau và hành vi của chúng sẽ chắc chắn bị thay đổi trong tương lai.</p><p><strong>FileSystem</strong> - interface của File &amp; Directory Entries API được dùng để thể hiện 1 hệ thống file. Những object này có thể được lấy từ thuộc tính <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemEntry/filesystem" target="_blank" rel="noopener">filesystem</a> của bất kỳ entry thuộc hệ thống file nào. Một vài trình duyệt cung cấp thêm các API để tạo &amp; quản lý các hệ thống file.</p><p>Interface này sẽ không cấp quyền cho bạn truy cập vào hệ thống file của user. Thay vào đó, bạn sẽ có 1 “ổ đĩa ảo” (virtual drive) bên trong sandbox của trình duyệt. Nếu bạn muốn truy cập vào hệ thống file của user, bạn cần phải gọi hỏi user bằng cách ví dụ như cài 1 Chrome extension.</p><h2 id="Yeu-cau-1-he-thong-file"><a href="#Yeu-cau-1-he-thong-file" class="headerlink" title="Yêu cầu 1 hệ thống file"></a>Yêu cầu 1 hệ thống file</h2><p>Một webapp có thể yêu cầu truy cập đến một hệ thống file sandbox bằng cách gọi: window.requestFileSystem():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lưu ý: Hệ thống file đã được đánh tiền tố tính đến Google Chrome 12.</span></span><br><span class="line"><span class="built_in">window</span>.requestFileSystem = <span class="built_in">window</span>.requestFileSystem || <span class="built_in">window</span>.webkitRequestFileSystem;</span><br><span class="line"><span class="built_in">window</span>.requestFileSystem(type, size, successCallback, opt_errorCallback)</span><br></pre></td></tr></table></figure><p>Nếu bạn gọi hàm requestFileSystem() lần đầu tiên thì 1 vùng lưu trữ mới được tạo ra. Quan trọng hãy nhớ rằng hệ thống file này được gói gọn trong sandbox, nghĩa là 1 webapp không thể truy cập file của webapp khác.</p><p>Sau khi bạn có quyền truy cập vào hệ thống file, bạn có thể làm tất cả các hoạt động cơ bản với file &amp; thư mục.</p><p>FileSystem là 1 lựa chọn lưu trữ khá khác biệt với các loại khác vì nó hướng đến thỏa mãn như cầu lưu trữ ở phía client trong những tình huống không dùng được cơ sở dữ liệu. Một cách tổng quát thì đó là những ứng dụng hoạt động với những cục blob nhị phân cỡ bự và/hoặc chia sẻ dữ liệu với các ứng dụng khác bên ngoài trình duyệt.</p><p>Dưới đây là những trường hợp có thể sử dụng FileSystem API:</p><ul><li>Tải lên (upload) liên tục: khi 1 file hay thư mục được chọn để upload, nó copy các file vào trong 1 vùng local sandbox và upload từng phần, từng phần.</li><li>Video game, âm nhạc hoặc các app khác mà có nhiều tài nguyên media.</li><li>Chỉnh sửa âm thanh/hình ảnh với truy cập offline hoặc là lưu đệm local để tăng tốc độ - những cục blob dữ liệu như thế thường rất lớn khi đọc-ghi.</li><li>Xem video offline - cần phải download 1 lượng lớn file để xem sau hoặc seek + streaming hiệu quả.</li><li>Ứng dụng Web Mail offline - download các file đính kèm và lưu chúng ở local.</li></ul><p>Tình hình hỗ trợ của API:<br><img src="https://cdn-images-1.medium.com/max/1000/0*ndU4N8xQF6QEQmSY" alt=""></p><h1 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*AsoHzlowoLItnUEL" alt=""></p><p>API localstorage cho phép bạn truy cập object <a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage" target="_blank" rel="noopener">Storage</a> dành cho origin của <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document" target="_blank" rel="noopener">Document</a>. Dữ liệu lưu trữ xuyên suốt nhiều session trình duyệt. localstorage tương tự như <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window.sessionStorage" target="_blank" rel="noopener">sessionStorage</a>, ngoại trừ việc dữ liệu lưu ở trong dataStorage không bị hết hạn, dữ liệu trong sessionStorage sẽ bị dọn dẹp khi session của trang kết thúc, tức là khi đóng tab trang đó.</p><p>Để ý rằng dữ liệu lưu trong localStorage hay sessionStorage là cụ thể cho origin của từng trang, bao gồm sự kết hợp của giao thức (protocol), host và cổng (port).</p><p>Tình hình hỗ trợ sáng sủa của nó:<br><img src="https://cdn-images-1.medium.com/max/1000/0*hxC_NUPNycUBhj-L" alt=""></p><h1 id="Session-Storage"><a href="#Session-Storage" class="headerlink" title="Session Storage"></a>Session Storage</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*-IMsNws_L1g0Syla" alt=""></p><p>sessionStorage cho phép bạn truy cập vào 1 object <a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage" target="_blank" rel="noopener">Storage</a> của session cho origin hiện tại. sessionStorage tương tự như <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">localStorage</a>, như đã giải thích ngắn gọn ở trên. Điểm khác biệt duy nhất là dữ liệu lưu trong localStorage không bị hết hạn, còn trong sessionStorage thì bị xóa khi session của trang kết thúc. Một session của trang tồn tại miễn là cửa sổ trình duyệt vẫn còn mở và tồn tại khi trang reload hoặc restore. <strong>Mở trang trong 1 tab mới hoặc cửa sổ mới sẽ tạo ra session mới</strong>, khác với cách hoạt động của session cookies.</p><p>Dữ liệu lưu trong sessionStorage hay localStorage là <strong>dành riêng cho origin của trang</strong>.</p><p>Tình hình hỗ trợ của sessionStorage:<br><img src="https://cdn-images-1.medium.com/max/1000/0*PTDs1BkbMgekizit" alt=""></p><h1 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*VKQINIYfu2O7d7BH" alt=""></p><p>Một cookie (hay web cookie, cookie trình duyệt) là 1 cục dữ liệu nhỏ xíu mà server gửi đến trình duyệt của user. Trình duyệt có thể lưu nó và gửi ngược về cùng server đó trong request tiếp theo. Thông thường, nó được dùng để cho biết nếu 2 request đến từ cùng 1 trình duyệt - ví dụ: giữ cho user tiếp tục đăng nhập. Nó ghi nhớ thông tin trạng thái cho giao thức HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#HTTP_is_stateless_but_not_sessionless" target="_blank" rel="noopener">không trạng thái</a> (stateless).</p><p>Cookies có 3 trường hợp dùng chính:</p><ul><li><strong>Quản lý session</strong>: login, giỏ hàng online, lưu điểm game hay bất cứ thứ gì server cần nhớ.</li><li><strong>Cá nhân hóa (Personalization)</strong>: các thiết đặt của người dùng, chủ để và những cài đặt khác.</li><li><strong>Theo dõi</strong>: ghi lại và phân tích hành vi của người dùng.</li></ul><p>Cookies đã từng được dùng để lưu trữ tổng quát ở phía client. Như vậy vẫn hợp pháp vì lúc đó nó là giải pháp duy nhất để lưu trữ thông tin ở phía client, ngày nay thì người ta thường chọn các API lưu trữ hiện đại hơn. Cookies được gửi về với mỗi request nên có thể ảnh hưởng xấu đến hiệu năng (đặc biệt với các kết nối trên thiết bị di động).</p><p>Có 2 loại cookies:</p><ul><li><strong>Cookie phiên (session cookies</strong>: Chúng bị xóa khi client tắt. Trình duyệt web có thể dùng <strong>khôi phục session</strong> để lấy lại gần hết session cookies, giống như là trình duyệt chưa bao giờ bị tắt vậy.</li><li><strong>Cookie dài hạn (permanent cookie)</strong>: thay vì hết hạn khi người dùng tắt trình duyệt, <em>permanent cookie</em> hết hạn tại 1 ngày nhất định (Expires) hoặc là sau 1 khoảng thời gian nhất định (Max-Age).</li></ul><p>Lưu ý rằng các thông tin bí mật và nhạy cảm không nên lưu hoặc vận chuyển với HTTP Cookies bởi vì rõ ràng toàn bộ cơ chế này vốn không an toàn.</p><p>Và rõ ràng là cookies hoạt động tốt với tất cả các trình duyệt.</p><h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*XZ2U-ztABhWJOSky" alt=""></p><p>Interface <strong>Cache</strong> cung cấp cơ chế lưu trữ cho cặp object <a href="http://fetch.spec.whatwg.org/#request" target="_blank" rel="noopener">Request</a>/<a href="http://fetch.spec.whatwg.org/#response" target="_blank" rel="noopener">Response</a> được lưu đệm. Lưu ý rằng interface Cache được dùng trong phạm vi window giống như workers. Bạn không phải dùng nó cùng với service worker mặc dù nó được định nghĩa trong thông tin của service worker.</p><p>Một origin có thể có nhiều object Cache (có tên cụ thể). Bạn có trách nhiệm triển khai code (ví dụ như trong <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker" target="_blank" rel="noopener">ServiceWorker</a>) để xử lý cập nhật cho Cache. Các item trong Cache không được cập nhật trừ khi được yêu cầu tường minh; chúng không hết hạn trừ khi bị xóa. Dùng hàm <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open" target="_blank" rel="noopener">CacheStorage.open()</a> để mở 1 object Cache với tên cụ thể và gọi bất kỳ phương thức Cache nào để bảo trì Cache.</p><p>Bạn cũng có trách nhiệm dọn dẹp định kỳ các cache entry. Mỗi trình duyệt có 1 giới hạn cứng với số lượng cache lưu trữ cấp cho 1 origin. Hạn mức sử dụng Cache ước tính tồn tại trong API <a href="https://developer.mozilla.org/en-US/docs/Web/API/StorageEstimate" target="_blank" rel="noopener">StorageEstimate</a>. Trình duyệt làm công việc tốt nhất của nó để quản lý dung lượng đĩa nhớ nhưng nó có thể xóa lưu trữ Cache của 1 origin. Đại khái là trình duyệt hoặc sẽ xóa tất cả dữ liệu của 1 origin hoặc không làm gì cả. Đảm bảo đánh phiên bản của cache bằng tên và chỉ dùng phiên bản cache nào mà code của bạn có thể sử dụng an toàn. Bạn có thể xem thêm bài <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker_API/Using_Service_Workers#Deleting_old_caches" target="_blank" rel="noopener">Xóa cache cũ</a> để hiểu thêm.</p><p>Interface <strong>CacheStorage</strong> thể hiện sự lưu trữ cho các object <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">Cache</a></p><p>Interface:</p><ul><li>Cung cấp thư mục master của tất cả các cache có tên mà có thể truy xuất bởi <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker" target="_blank" rel="noopener">ServiceWorker</a> hoặc các loại worker khác hoặc phạm vi <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window" target="_blank" rel="noopener">window</a> (bạn không bị giới hạn chỉ sử dụng với service worker kể cả thông tin của <a href="https://w3c.github.io/ServiceWorker/" target="_blank" rel="noopener">Service Worker</a> có định nghĩa như vậy).</li><li>Duy trì khả năng ánh xạ (mapping) tên tương ứng với object <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">Cache</a></li></ul><p>Dùng phương thức <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open" target="_blank" rel="noopener">CacheStorage.open()</a> để lấy 1 instance của <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">Cache</a></p><p>Dùng phương thức <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/match" target="_blank" rel="noopener">CacheStorage.match()</a> để kiểm tra nếu 1 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request" target="_blank" rel="noopener">Request</a> có phải là 1 key trong bất kỳ object <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">Cache</a> nào mà object CacheStorage theo dõi.</p><p>Bạn có thể truy cập CacheStorage thông qua thuộc tính toàn cục <a href="https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/caches" target="_blank" rel="noopener">caches</a></p><h1 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*HP66Xm7oe9u8Ofk1" alt=""></p><p>IndexedDB là 1 cách để bạn lưu trữ dữ liệu một cách bền vững bên trong trình duyệt của người dùng. Bởi vì nó cho phép bạn tạo các webapp với khả năng viết câu truy vấn đa dạng bất kể tình trạng mạng. Những ứng dụng này có thể làm việc online &amp; offline. IndexedDB có ích cho các ứng dụng cần lưu trữ 1 lượng lớn dữ liệu (ví dụ: danh sách các DVD cho mượn trong thư viện) và các ứng dụng không cần sự kết nối internet ổn định để hoạt động (ví dụ: ứng dụng mail, danh sách to-do, notepad).</p><p>Trong bài này, nó là cơ sở dữ liệu lưu trữ mà chúng ta sẽ thảo luận chi tiết hơn 1 chút bởi vì các API lưu trữ khác đều được hiểu biết khá rộng. Thêm nữa, IndexedDB càng ngày càng phổ biến với các webapp phức tạp ngày càng gia tăng.</p><h2 id="Ben-trong-IndexedDB"><a href="#Ben-trong-IndexedDB" class="headerlink" title="Bên trong IndexedDB"></a>Bên trong IndexedDB</h2><p>IndexedDB cho phép bạn lưu trữ và lấy các object được lưu bằng cách dùng key. Tất cả thay đổi bạn thực hiện với cơ sở dữ liệu đều xảy ra trong phạm vi transaction. Giống như nhiều giải pháp lưu trữ web khác, IndexedDB bám sát nguyên tắc cùng origin (<a href="http://www.w3.org/Security/wiki/Same_Origin_Policy" target="_blank" rel="noopener">same-origin policy</a>). Vì thế bạn có thể truy cập dữ liệu lưu trữ trong phạm vi 1 domain nhưng không thể truy cập dữ liệu của các domain khác.</p><p>IndexedDB là API bất đồng bộ (<a href="https://developer.mozilla.org/en/IndexedDB#Asynchronous_API" target="_blank" rel="noopener">asynchronous</a>) có thể sử dụng trong hầu hết các ngữ cảnh, bao gồm cả <a href="https://developer.mozilla.org/En/DOM/Using_web_workers" target="_blank" rel="noopener">WebWorkers</a>. Nó thường bao gồm cả 1 phiên bản đồng bộ (<a href="https://developer.mozilla.org/en/IndexedDB#Synchronous_API" target="_blank" rel="noopener">synchronous</a>) nữa để dùng trong web worker nhưng đã bị xóa bỏ bởi vì cộng đồng web không có hứng thú với nó.</p><p>IndexedDB thường cạnh tranh với cơ sở dữ liệu WebSQL nhưng nó đã bị hủy bởi W3C. Trong khi cả 2 IndexedDB và WebSQL là các giải pháp lưu trữ, chúng lại không cung cấp cùng tính năng. CSDL WebSQL là 1 hệ truy cập CSDL quan hệ trong khi IndexedDB là hệ bảng đánh số (indexed table).</p><p>Đừng bắt đầu với IndexedDB nếu như bạn chỉ nghe nói hoặc giả định rằng nó tốt hơn các loại CSDL khác. Thay vì thế hãy đọc thật kỹ tài liệu của nó. Dưới đây là 1 vài ý tưởng cần thiết mà bạn cần phải biết:</p><ul><li><strong>CSDL IndexedDB lưu theo cặp key-value</strong>: giá trị có thể là object cấu trúc phức tạp và key có thể là thuộc tính của những object đó. Bạn có thể tạo index dùng bất kỳ thuộc tính nào của object để dễ tìm kiếm cũng như khi cần sắp xếp. Key cũng có thể là object nhị phân.</li><li><strong>API IndexedDB đa phần là bất đồng bộ</strong>: API không đưa dữ liệu cho bạn bằng cách trả về giá trị. Thay vì thế nó truyền vào 1 hàm callback. Bạn không “lưu” 1 giá trị vào trong CSDL hoặc “lấy” nó ra theo nghĩa đồng bộ. Thay vào đó, bạn “yêu cầu” (request) một hành động trên CSDL. Một sự kiện thông báo cho bạn khi hành động hoàn thành và kiểu sự kiện bạn nhận được nếu như có hành động thành công hay thất bại. Không khác mấy so với cách hoạt động của <a href="https://developer.mozilla.org/en/DOM/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a> (hoặc là cả tá thứ khác về Javascript)</li><li><strong>IndexedDB dùng rất nhiều request</strong>: request là object nhận các sự kiện thành công hay thất bại như đã nói ở trên. Chúng có thuộc tính onsuccess và onerror cũng như readyState, result và errorCode sẽ cho bạn biết về trạng thái của request.</li><li><strong>IndexedDB hướng đối tượng</strong>: IndexedDB không phải CSDL quan hệ với các bảng thể hiện tập hợp hàng &amp; cột. Điểm khác biệt cơ bản này ảnh hưởng đến giai đoạn thiết kế và xây dựng ứng dụng của bạn.</li><li><strong>IndexedDB không dùng ngôn ngữ truy vấn cấu trúc (SQL)</strong>: nó dùng kiểu truy vấn trên index để tạo ra con trỏ, chính con trỏ này dùng để lặp xuyên suốt tập kết quả. Nếu bạn không quen với hệ thống NoSQL thì có thể xem thêm <a href="https://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="noopener">bài này trên Wikipedia</a></li><li><strong>IndexedDB dùng nguyên tắc cùng origin</strong>: một origin là domain, giao thức tầng ứng dụng và cổng (port) của URL của văn bản là nơi mà code được thực thi. Mỗi origin có 1 tập các CSDL riêng của nó. Mỗi CSDL có 1 cái tên định danh nó trong origin.</li></ul><h2 id="Gioi-han-cua-IndexedDB"><a href="#Gioi-han-cua-IndexedDB" class="headerlink" title="Giới hạn của IndexedDB"></a>Giới hạn của IndexedDB</h2><p>IndexedDB được thiết kế để dùng với hầu hết các tình huống cần lưu trữ ở phía client. Nó không được thiết kế cho 1 vài trường hợp dưới đây:</p><ul><li><strong>Sắp xếp toàn cầu (Internationalized sorting)</strong>: không phải tất cả ngôn ngữ đều sắp xếp array theo cùng 1 cách, vì thế mà Internationalized sorting không được hỗ trợ. CSDL không thể lưu dữ liệu theo 1 thứ tự toàn cầu cụ thể, bạn có thể tự tay sắp xếp dữ liệu đọc từ CSDL ra.</li><li><strong>Đồng bộ hóa</strong>: API không được thiết kế để thực hiện đồng bộ hóa với CSDL ở phía server. Bạn phải viết code riêng để đồng bộ CSDL IndexedDB ở client với CSDL ở server.</li><li><strong>Tìm kiếm toàn văn bản (Full text searching )</strong>: API không cung cấp giải pháp tương tự như LIKE trong SQL.</li></ul><p>Thêm vào đó, hãy cẩn thận trình duyệt có thể xóa CSDL trong những trường hợp sau đây:</p><ul><li><strong>User yêu cầu xóa</strong>: nhiều trình duyệt có cài đặt cho phép user xóa tất cả dữ liệu lưu trữ cho 1 website, bao gồm cả cookies, bookmarks, mật khẩu được lưu và dữ liệu IndexedDB.</li><li><strong>Trình duyệt đang chạy chế độ riêng tư</strong>: một vài trình duyệt có chế độ riêng tư như private browsing (Firefox) hay incognito (Chrome). Tại cuối session, trình duyệt sẽ xóa toàn bộ CSDL.</li><li><strong>Ổ cứng hoặc giới hạn cho phép bị đầy</strong></li><li><strong>Dữ liệu bị hỏng</strong></li></ul><p>Các trường hợp chính xác và khả năng của trình duyệt thay đổi theo thời gian, nhưng nguyên lý chung của các nhà phát triển trình duyệt là tạo ra nỗ lực tốt nhất để lưu giữ dữ liệu khi có thể.</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*kGDQYE70_z58D7na" alt=""></p><h1 id="Lua-chon-API-luu-tru"><a href="#Lua-chon-API-luu-tru" class="headerlink" title="Lựa chọn API lưu trữ"></a>Lựa chọn API lưu trữ</h1><p>Như đã đề cập ở trên, sẽ tốt hơn nếu chọn các API được hỗ trợ rộng rãi trong nhiều trình duyệt và cung cấp mô hình gọi bất đồng bộ nhằm nâng tối đa khả năng phản hồi của UI. Như 1 cách tự nhiên, ngữ cảnh như thế này sẽ dẫn đến các lựa chọn công nghệ:</p><ul><li>Với lưu trữ offline, dùng <a href="https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/cache-api" target="_blank" rel="noopener">Cache API</a>. API này tồn tại trong các trình duyệt hỗ trợ công nghệ <a href="https://jakearchibald.github.io/isserviceworkerready/" target="_blank" rel="noopener">Service Worker</a>, cần thiết để xây dựng app offline.</li><li>Để lưu trữ trạng thái của ứng dụng và các dữ liệu do người dùng tạo ra, sử dụng IndexedDB. Nó cho phép user làm việc offline trên nhiều trình duyệt hơn so với những trình duyệt chỉ hỗ trợ Cache API.</li></ul><p><a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=classes-inheritance-transpiling-outro" target="_blank" rel="noopener">SessionStack</a> sử dụng các API lưu trữ khác nhau. Ví dụ, thư viện tích hợp vào trong webapp của khách hàng dùng cả cookies &amp; session storage. Lý do là thư viện đó cần thu thập các dữ liệu chẳng hạn như các sự kiện, thay đổi trên DOM, dữ liệu mạng, biệt lệ, thông tin debug, vân vân, rồi sau đó gửi về server. Họ thu thập dữ liệu như vậy từ session của người dùng nhưng họ cần 1 cách chính xác để xác định khi nào session của user bắt đầu và kết thúc.</p><p>Họ cân nhắc 1 session sẽ là toàn bộ chu kỳ sử dụng webapp từ lúc bắt đầu, bao gồm cả xem trang và điều hướng cho đến khi user đóng trình duyệt hay tab và không quay trở lại trong vài phút, phần này họ dùng 1 sự kết hợp của session storage &amp; logic ở phía server. Còn gì nữa nào, họ cho phép bạn xác định từng người dùng cuối để có thể cung cấp cho bạn dữ liệu người dùng trên mỗi session. Họ dựa vào cookies để làm việc này (giống như các công cụ giám sát/phân tích).</p><p>Trong ứng dụng của họ, bạn có thể xem (xem theo yêu cầu hoặc thời gian thực) những sự kiện đã thu tập dưới dạng video được tái tạo lại cách mà user gặp phải các vấn đều, họ sử dụng chủ yếu là cookies bởi vì serivce RESTful của họ về cơ bản thì cần authentication token để authenticate, authorize và xác nhận request.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 16 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;h1 id=&quot;Khai-quat&quot;&gt;&lt;a href=&quot;#Khai-quat&quot; class=&quot;headerlink&quot; title=&quot;Khái quát&quot;&gt;&lt;/a&gt;Khái quát&lt;/h1&gt;&lt;p&gt;Lựa chọn cơ chế lưu trữ đúng đắn cho thiết bị lưu trữ ở local rất quan trọng khi thiết kế webapp. Một engine lưu trữ tốt sẽ đảm bảo thông tin của bạn được lưu chắc chắn, giảm băng thông và cải thiện sự phản hồi. Chiến lược lưu trữ bộ nhớ đệm phù hợp là thành phần cốt lõi cho phép trải nghiệm mobile web offline, càng ngày càng có nhiều người dùng cảm thấy rằng như đó là trải nghiệm mặc định phải có.&lt;/p&gt;
&lt;p&gt;Trong chương này, chúng ta sẽ thảo luận về những API lưu trữ có sẵn &amp;amp; các service và cung cấp một số hướng dẫn làm thế nào để lựa chọn đúng loại cho webapp của bạn.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P15: Bên trong Class &amp; Inheritance + Transpiling với Babel &amp; Typescript</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P15-Ben-trong-Class-Inheritance-Transpiling-voi-Babel-Typescript.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P15-Ben-trong-Class-Inheritance-Transpiling-voi-Babel-Typescript.html</id>
    <published>2018-11-25T09:37:00.000Z</published>
    <updated>2018-11-25T09:40:14.437Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 15 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Ngày nay, cách phổ biến nhất để dựng cấu trúc của bất kỳ dự án phần mềm nào là sử dụng class. Trong bài viết này, chúng ta sẽ cùng khám phá các cách khác nhau để triển khai class trong Javascript và làm thế nào ta có thể xây dựng cây thứ bậc của class (class hierarchy). Chúng ta sẽ bắt đầu bằng cách đào sâu tìm hiểu cách hoạt động của prototype và phân tích những cách để giả lập kế thừa class trong các thư viện nổi tiếng. Tiếp đến ta sẽ xem làm cách nào mà transpiling có thể thêm những tính năng không được hỗ trợ chính thức cho ngôn ngữ và cách mà nó được dùng trong Babel &amp; Typescript để giới thiệu về sự hỗ trợ của class trong ECMAScript 2015. Cuối cùng, ta sẽ kết thúc với một vài ví dụ về class được triển khai native trong V8.<br><a id="more"></a></p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Trong Javascript, về bản chất không có kiểu dữ liệu nguyên thủy và mọi thứ tạo ra đều là object. Ví dụ, nếu ta tạo 1 string:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">"SessionStack"</span>;</span><br></pre></td></tr></table></figure><p>Thì chúng ta có thể gọi nhiều phương thức khác nhau trên object vừa mới được tạo ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.repeat(<span class="number">2</span>)); <span class="comment">// SessionStackSessionStack</span></span><br><span class="line"><span class="built_in">console</span>.log(a.toLowerCase()); <span class="comment">// sessionstack</span></span><br></pre></td></tr></table></figure><p>Không giống như các ngôn ngữ khác, trong Javascript, khai báo string hay number sẽ tự động tạo ra một object mà nó sẽ đóng gói giá trị đó và cung cấp nhiều phương thức khác nhau có thể thực thi được kể cả với các kiểu dữ liệu nguyên thủy.</p><p>Một sự thật thú vị khác là những kiểu dữ liệu phức tạp, chẳng hạn như array, cũng là object. Nếu bạn nhìn kỹ hơn vào typeof của một array, bạn sẽ thấy nó là object. Số index của mỗi phần tử trong danh sách chính là thuộc tính của object. Vì thế khi bạn truy xuất một phần tử bằng số index trong array, bạn thực ra chỉ truy xuất vào thuộc tính của object array và trả về giá trị của nó. Khi nói về vấn đề lưu trữ dữ liệu thì 2 định nghĩa sau là giống hệt nhau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [“SessionStack”];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = &#123;</span><br><span class="line">  “<span class="number">0</span>”: “SessionStack”,</span><br><span class="line">  “length”: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kết quả là thời gian cần để truy xuất 1 phần tử trong array và 1 thuộc tính của object là như nhau. Thật khó để nhận ra. Trước đây, trong 1 project, tác giả phải thực hiện quá trình tối ưu hóa rất lớn cho một đoạn code quan trọng. Sau khi thử tất cả các lựa chọn dễ, tác giả đã thay thế toàn bộ object được dùng trong project bằng array. Về lý thuyết, truy xuất 1 phần tử trong 1 array thì nhanh hơn truy xuất 1 key trong hash map (bản đồ băm). Tác giả đã ngạc nhiên rằng cách làm này không mang lại một chút hiệu quả hơn với hiệu năng. Trong Javascript, cả array và object đều được triển khai về việc truy xuất 1 key trong hash map và sẽ tốn cùng 1 lượng thời gian như nhau.</p><h1 id="Gia-lap-class-voi-prototype"><a href="#Gia-lap-class-voi-prototype" class="headerlink" title="Giả lập class với prototype"></a>Giả lập class với prototype</h1><p>Khi nghĩ về object, thứ đầu tiên xuất hiện chính là class. Tất cả chúng ta thông thường đều xây dựng cấu trúc của ứng dụng dựa trên class và các mối quan hệ giữa chúng với nhau. Mặc dù object trong Javascript xuất hiện khắp nơi, ngôn ngữ này lại không sử dụng kiểu kế thừa truyền thống dựa trên class. Thay vào đó nó dùng <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model" target="_blank" rel="noopener">prototype</a>.<br>[<img src="https://cdn-images-1.medium.com/max/1000/0*SufKRGfPZIDlw1OG" alt=""></p><p>Trong Javascript, mọi object được kết nối đến object khác - chính là prototype của nó. Khi bạn thử truy xuất 1 thuộc tính hoặc phương thức trên 1 object, quá trình tìm kiếm (thuộc tính/phương thức) sẽ bắt đầu với chính object đó trước. Nếu không tìm thấy thì nó sẽ tiếp tục với prototype của object đó.</p><p>Chúng ta sẽ thử với 1 ví dụ đơn giản về định nghĩa constructor cho 1 class:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Component.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ta thêm hàm render vào prototype bởi vì chúng ta muốn mỗi instance của Component đều có thể tìm thấy nó. Khi bạn gọi phương thức này trên mỗi instance của class Component, quá trình tìm kiếm đầu tiên sẽ thực hiện trên chính instance đó. Sau đó nó tiếp tục thực hiện tìm trên prototype và tại đây thì phương thức render được tìm thấy.<br><img src="https://cdn-images-1.medium.com/max/1000/0*hZbijxS0vXu8vUmz" alt=""></p><p>Giờ ta thử mở rộng class Component ra, ta sẽ thêm vào một class con:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InputField</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.content = <span class="string">`&lt;input type="text" value="<span class="subst">$&#123;value&#125;</span>" /&gt;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nếu ta muốn InputField mở rộng chức năng của class Component và có thể gọi phương thức render của nó thì ta cần phải thay đổi prototype. Khi 1 phương thức được gọi trên instance của class con, ta không muốn tìm kiếm trong prototype trống rỗng của nó. Quá trình tìm kiếm sẽ tiếp tục ở class Component.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputField.prototype = <span class="built_in">Object</span>.create(<span class="keyword">new</span> Component());</span><br></pre></td></tr></table></figure><p>Bằng cách này, phương thức render có thể được tìm thấy trong prototype của class Component. Để có thể kế thừa, ta cần kết nối prototype của InputField đến 1 instance của class Component. Nhiều thư viện sử dụng phương thức <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener">Object.setPrototypeOf</a> để làm việc này.</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*avLiOV_zXLxOgBee" alt=""></p><p>Tuy nhiên đây không phải là việc duy nhất mà ta cần làm. Mỗi khi mở rộng 1 class, ta cần chú ý:</p><ul><li>Đặt prototype của class con là 1 instance của class cha</li><li>Gọi constructor của class cha trong constructor của class con để quá trình khởi tạo logic trong constructor của class cha có thể được thực thi.</li><li>Giới thiệu cách truy xuất phương thức từ class cha. Bạn cần phải làm thế khi muốn ghi đè 1 phương thức và bạn muốn gọi đến phần triển khai gốc trong phương thức ở class cha.</li></ul><p>Như bạn thấy thì nếu muốn sử dụng tất cả tính năng của kế thừa dựa trên class thì bạn cần thực thi phần logic phức tạp này mỗi lần kế thừa. Mỗi khi bạn cần tạo ra nhiều class thì tốt nhất là đóng gói mớ logic ấy trong 1 (hoặc vài) hàm để có thể tái sử dụng. Đây là cách mà các developer trước đây giải quyết vấn đề kế thừa dựa trên class - bằng cách giả lập với nhiều thư viện khác nhau. Những giải pháp này trở nên rất phổ biến và rõ ràng là có thiếu sót trong ngôn ngữ Javascript. Đó là lý do mà cú pháp mới để tạo class và hỗ trợ kế thừa class được giới thiệu trong bản sửa đổi lớn đầu tiên của ECMAScript 2015.</p><h1 id="Transpiling-class"><a href="#Transpiling-class" class="headerlink" title="Transpiling class"></a>Transpiling class</h1><p>Khi tính năng mới của ES6 (hay ECMAScript 2015) được đề xuất, cộng đồng Javascript developer không ngồi yên chờ đợi tất cả các engine và trình duyệt bắt đầu hỗ trợ nó. Một cách tốt hơn để đạt được là thông qua transpile. Nó cho phép 1 đoạn code viết trong ECMAScript 2015 được biến đổi thành Javascript mà tất cả trình duyệt đều có thể hiểu. Bao gồm cả khả năng viết class với kế thừa dựa trên class và transpile chúng thành code hoạt động được.<br><img src="https://cdn-images-1.medium.com/max/1000/0*QhRSzkngh6Aty-nD" alt=""></p><p>Một trong số những transpiler nổi tiếng nhất cho Javascript là Babel. Giờ thì cùng xem transpile hoạt động thế nào, ta sẽ áp dụng nó cho đoạn code về Component viết ở trên nhé:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(content) &#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> component = <span class="keyword">new</span> Component(<span class="string">'SessionStack'</span>);</span><br><span class="line">component.render();</span><br></pre></td></tr></table></figure><p>Và đây là những gì Babel transpile ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Component = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Component);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.content = content;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(Component, [&#123;</span><br><span class="line">    key: <span class="string">'render'</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.content);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Component;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>Như bạn thấy, code được biến đổi thành ECMAScript 5, loại có thể được thực thi trên bất kỳ môi trường nào. Ngoài ra còn có 1 số hàm được thêm vào. Chúng là 1 phần của thư viện Babel tiêu chuẩn.</p><p>Hàm _classCallCheck và _createClass có mặt như 1 phần trong kết quả biên dịch. Hàm đầu tiên đảm bảo hàm constructor không bao giờ được gọi như 1 hàm bình thường. Điều này được thực hiện bằng việc kiểm tra có hay không ngữ cảnh mà trong đó hàm được đánh giá là 1 instance của object Component. Code sẽ kiểm tra nếu<br>nó trỏ đến instance. Hàm thứ 2 _createClass xử lý việc tạo ra các thuộc tính cho object và được truyền vào dưới dạng danh sách các object với key &amp; value.</p><p>Để khám phá về cách kế thừa hoạt động ra sao thì ta cùng phân tích class InputField được kế thừa từ Component</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputField</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">const</span> content = <span class="string">`&lt;input type="text" value="<span class="subst">$&#123;value&#125;</span>" /&gt;`</span>;</span><br><span class="line">        <span class="keyword">super</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kết quả sau khi xử lý transpile với Babel:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> InputField = <span class="function"><span class="keyword">function</span> (<span class="params">_Component</span>) </span>&#123;</span><br><span class="line">  _inherits(InputField, _Component);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">InputField</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, InputField);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> content = <span class="string">'&lt;input type="text" value="'</span> + value + <span class="string">'" /&gt;'</span>;</span><br><span class="line">    <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, (InputField.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(InputField)).call(<span class="keyword">this</span>, content));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> InputField;</span><br><span class="line">&#125;(Component);</span><br></pre></td></tr></table></figure><p>Trong ví dụ trên, logic kế thừa được đóng gói trong hàm _inherits. Nó thực hiện cùng y chang hành động mà chúng ta đã mô tả trong phần trước bằng cách cài đặt prototype của class con trở thành 1 instance của class cha.</p><p>Để transpile code, Babel thực hiện nhiều quá trình chuyển đổi. Đầu tiên code ECMAScript 2015 được parse và biến đổi thành một dạng thể hiện trung gian, gọi là <strong>Abstract Syntax Tree</strong>, chính là chủ đề ta đã thảo luận ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-14---Parsing--Abstract-Syntax-Tree---meo-giam-toi-da-thoi-gian-parse" target="_blank" rel="noopener">bài trước</a>. Sau đó cây này được biến đổi lần nữa thành 1 cây AST khác mà mỗi node của nó được biến đổi thành phần tương ứng trong ECMAScript 5. Cuối cùng cây AST được chuyển ngược lại thành code.</p><h1 id="AST-trong-Babel"><a href="#AST-trong-Babel" class="headerlink" title="AST trong Babel"></a>AST trong Babel</h1><p>Một cây AST sẽ có nhiều node, mỗi node chỉ có duy nhất 1 node cha. Trong Babel, tồn tại 1 kiểu cơ bản cho các node. Nó chưa thông tin về loại node và vị trí của chúng trong code. Có nhiều loại node khác nhau, chẳng hạn như Literals thể hiện string, number, null, vân vân. Cũng có cả node Statements dành cho các luồng kiểm soát (if) và vòng lặp (for, while). Có cả node đặc biệt dành cho class. Nó là 1 con (child) của class Node cơ bản. Nó mở rộng bằng cách thêm các trường để lưu tham chiếu đến class cơ bản và body của class như là 1 node riêng biệt.</p><p>Giờ ta sẽ biến đổi đoạn code sau thành cây AST</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(content) &#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đây là kết quả:<br><img src="https://cdn-images-1.medium.com/max/1000/0*-OqUfzpRtgDJQjXY" alt=""></p><p>Sau khi tạo ra cây AST, mỗi node được biến đổi thành node ECMAScript 5 tương đương với nó và chuyển ngược lại thành code thường theo tiêu chuẩn của ECMAScript 5. Quá trình này được thực hiện bằng 1 tiến trình tìm kiếm node nằm ở vị trí xa nhất với root node và biến đổi chúng thành code. Sau đó node cha của nó sẽ được biến đổi bằng đoạn code đã sinh ra cho các node con của nó. Quá trình này được gọi là <a href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank" rel="noopener">depth-first traversal</a></p><p>Trong ví dụ trên, đầu tiên code của 2 node MethodDefinition sẽ được sinh ra, theo sau nó là code của node ClassBody và cuối cùng là node ClassDeclaration</p><h1 id="Transpile-voi-TypeScript"><a href="#Transpile-voi-TypeScript" class="headerlink" title="Transpile với TypeScript"></a>Transpile với TypeScript</h1><p>Một framework phổ biến khác hỗ trợ khả năng transpile chính là TypeScript. Nó giới thiệu cú pháp kiểu mới để viết ứng dụng Javascript và được biến đổi thành ECMAScript 5 mà có thể chạy trên bất kỳ trình duyệt hay engine nào. Dưới đây là phần triển khai của class Component trong TypeScript:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    content: string;</span><br><span class="line">    <span class="keyword">constructor</span>(content: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Và đây là cây AST được sinh ra:<br><img src="https://cdn-images-1.medium.com/max/1000/0*j3zkSjnrL4fnCK3A" alt=""></p><p>Nó hỗ trợ kế thừa:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputField</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value: string) &#123;</span><br><span class="line">        <span class="keyword">const</span> content = <span class="string">`&lt;input type="text" value="<span class="subst">$&#123;value&#125;</span>" /&gt;`</span>;</span><br><span class="line">        <span class="keyword">super</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kết quả transpile ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> InputField = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</span><br><span class="line">    __extends(InputField, _super);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">InputField</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> content = <span class="string">"&lt;input type=\"text\" value=\""</span> + value + <span class="string">"\" /&gt;"</span>;</span><br><span class="line">        _this = _super.call(<span class="keyword">this</span>, content) || <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> _this;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> InputField;</span><br><span class="line">&#125;(Component));</span><br></pre></td></tr></table></figure><p>Kết quả cuối cùng một lần nữa lại là ECMAScript 5 với 1 số hàm thêm vào từ thư viện của TypeScript. Logic được đóng gói trong __extends là giống y hệt như những gì chúng ta đã thảo luận ở phần trước.</p><p>Với Babel và TypeScript càng ngày càng được đón nhận nồng nhiệt, class tiêu chuẩn và kế thừa dựa trên class trở thành 1 cách chuẩn của phần cấu trúc những ứng dụng Javascript. Điều này đẩy nhanh tiến độ về native support (hỗ trợ tự nhiên) cho class trên trình duyệt.</p><h1 id="Native-support-ho-tro-tu-nhien"><a href="#Native-support-ho-tro-tu-nhien" class="headerlink" title="Native support (hỗ trợ tự nhiên)"></a>Native support (hỗ trợ tự nhiên)</h1><p>Vào năm 2014, <a href="https://www.chromestatus.com/feature/4633745457938432" target="_blank" rel="noopener">native support cho class</a> được giới thiệu trong Chrome. Nó cho phép cú pháp khai báo class được thực hiện mà không cần phải dùng đến các thư viện hay transpiler.<br><img src="https://cdn-images-1.medium.com/max/1000/0*jJuHfRMipW8PPcb0" alt=""></p><p>Quá trình triển khai class một cách tự nhiên được gọi là syntax sugar (cú pháp ngọt ngào). Đây chỉ là 1 cú pháp dễ chịu có thể biên dịch xuống thành cùng loại với kiểu nguyên thủy đang được hỗ trợ mặc định trong ngôn ngữ. Bạn có thể dùng kiểu định nghĩa class mới, dễ dùng hơn, nhưng cuối cùng nó cũng quay về tạo constructor và gán prototypes</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*c2HpOiUYMimMXHv2" alt=""></p><h1 id="Su-ho-tro-cua-V8"><a href="#Su-ho-tro-cua-V8" class="headerlink" title="Sự hỗ trợ của V8"></a>Sự hỗ trợ của V8</h1><p>Cùng xem cách hoạt động của native support cho class trong ECMAScript 2015 trên V8. Như ta đã thảo luận ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-14---Parsing--Abstract-Syntax-Tree---meo-giam-toi-da-thoi-gian-parse" target="_blank" rel="noopener">bài trước</a>, đầu tiên cú pháp mới cần được parse thành code Javascript cũ và thêm vào cây AST. Vì thế kết quả của định nghĩa class là 1 node mới (loại <a href="https://github.com/v8/v8/blob/a86fa968136f0ec6237f51a0d535fbd932868d4d/src/ast/ast.h#L2421" target="_blank" rel="noopener">ClassLiteral</a>) được thêm vào cây.</p><p>Node này chứa 1 vài thứ. Đầu tiên, nó giữ constructor ở 1 hàm khác. Nó cũng chứa 1 danh sách các thuộc tính của class. Chúng có thể là phương thức, getter, setter, các trường public hay private. Node này cũng chứa luôn tham chiếu đến class cha mà chính class cha này lại nữa chứa constructor &amp; danh sách các thuộc tính và class cha khác (của nó).</p><p>Một khi ClassLiteral này được <a href="https://github.com/v8/v8/blob/be3a1df9008ee78d1101855d3044db54a203f515/src/interpreter/bytecode-generator.cc#L1818" target="_blank" rel="noopener">chuyển thành code</a>, nó được dịch 1 lần nữa thành các hàm và prototypes.</p><p>Với team tại <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=classes-inheritance-transpiling-outro" target="_blank" rel="noopener">SessionStack</a>, tối ưu hóa từng phần nhỏ của code là cực kỳ quan trọng những cũng là 1 công việc rất thách thức. Có 2 lý do cho việc cần thiết phải tối ưu hóa mức độ cao.</p><p>Đầu tiên, thư viện của họ sẽ tích hợp với trong webapp, nó thu thập dữ liệu từ phiên làm việc của user, chẳng hạn như sự kiện, thay đổi trên DOM, dữ liệu mạng, biệt lệ, thông báo lỗi, vân vân. Thu thập thông tin mà không làm ảnh hưởng đến hiệu năng của webapp là 1 thách thức khó mà team của tác giả đã giải quyết thành công.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 15 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Ngày nay, cách phổ biến nhất để dựng cấu trúc của bất kỳ dự án phần mềm nào là sử dụng class. Trong bài viết này, chúng ta sẽ cùng khám phá các cách khác nhau để triển khai class trong Javascript và làm thế nào ta có thể xây dựng cây thứ bậc của class (class hierarchy). Chúng ta sẽ bắt đầu bằng cách đào sâu tìm hiểu cách hoạt động của prototype và phân tích những cách để giả lập kế thừa class trong các thư viện nổi tiếng. Tiếp đến ta sẽ xem làm cách nào mà transpiling có thể thêm những tính năng không được hỗ trợ chính thức cho ngôn ngữ và cách mà nó được dùng trong Babel &amp;amp; Typescript để giới thiệu về sự hỗ trợ của class trong ECMAScript 2015. Cuối cùng, ta sẽ kết thúc với một vài ví dụ về class được triển khai native trong V8.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P14: Parsing, Abstract Syntax Tree &amp; mẹo giảm tối đa thời gian parse</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P14-Parsing-Abstract-Syntax-Tree-meo-giam-toi-da-thoi-gian-parse.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P14-Parsing-Abstract-Syntax-Tree-meo-giam-toi-da-thoi-gian-parse.html</id>
    <published>2018-11-25T09:32:00.000Z</published>
    <updated>2018-11-25T09:35:26.778Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 14 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Chúng ta đều biết rằng những thứ lộn xộn có thể hợp thành 1 thứ lớn hơn gọi là Javascript. Một đoạn code không chỉ có thể di chuyển qua mạng mà nó còn phải được parse, biên dịch sang bytecode và cuối cùng thực thi. Trong các bài trước, chúng ta đã thảo luận về những thứ chẳng hạn như JS engine, runtime, callstack cũng như engine V8 được dùng chủ yếu trong Chrome và NodeJS. Tất cả đều đóng vai trò quan trọng trong toàn bộ quá trình thực thi của Javascript. Chủ đề mà chúng ta sẽ tìm hiểu hôm nay cũng không kém quan trọng: chúng ta sẽ nghiên cứu xem làm thế nào mà đa số các engine JS parse văn bản thành một thứ gì đó có nghĩa đối với máy móc, những gì xảy ra sau đó và làm thế nào để web developer như chúng ta có thể tận dụng những kiến thức đó làm điểm mạnh.<br><a id="more"></a></p><h1 id="Ngon-ngu-lap-trinh-hoat-dong-nhu-the-nao"><a href="#Ngon-ngu-lap-trinh-hoat-dong-nhu-the-nao" class="headerlink" title="Ngôn ngữ lập trình hoạt động như thế nào?"></a>Ngôn ngữ lập trình hoạt động như thế nào?</h1><p>Cùng lùi lại 1 chút và xem xem ngôn ngữ lập trình hoạt động thế nào. Không cần biết là bạn đang xài ngôn ngữ gì, bạn sẽ luôn cần một phần mềm có thể đọc mã nguồn và khiến cho máy tính thực hiện một điều gì đó. Phần mềm này có thể là trình thông dịch hoặc trình biên dịch.</p><p>Không cần biết bạn đang xài ngôn ngữ thông dịch (Javascript, Python, Ruby) hay ngôn ngữ biên dịch (C#, Java, Rust), luôn luôn có 1 điểm chung giữa chúng: parse đoạn mã nguồn từ văn bản gốc thành một cấu trúc dữ liệu được gọi là Abstract Syntax Tree (AST).</p><p>Các AST không chỉ thể hiện mã nguồn dưới dạng cấu trúc mà chúng còn đóng vai trò quan trọng trong phân tích ngữ nghĩa, chính là nơi mà trình biên dịch xác nhận tính đúng đắn và cách sử dụng phù hợp của chương trình cũng như các phần tử của ngôn ngữ. Về sau, các AST được dùng để sinh ra bytecode hoặc mã máy.</p><h1 id="Cac-ung-dung-AST"><a href="#Cac-ung-dung-AST" class="headerlink" title="Các ứng dụng AST"></a>Các ứng dụng AST</h1><p>AST không chỉ được dùng trong trình thông dịch và trình biên dịch ngôn ngữ, chúng còn có nhiều ứng dụng trong thế giới máy tính. Một trong số đó là dùng chúng là phân tích code tĩnh. Các nhà phân tích tĩnh không thực thi code, họ cần hiểu cấu trúc của code. Ví dụ: bạn muốn triển khai một công cụ tìm sự giống nhau giữa các kiến trúc code để từ đó bạn có thể refactor nhằm giảm sự trùng lặp. Bạn có thể làm việc này bằng cách so sánh string bình thường nhưng cách triển khai thì khá cơ bản và giới hạn.</p><p>Một cách tự nhiên, nếu bạn có hứng thú triển khai một công cụ thì bạn không cần phải viết riêng cho nó 1 cái parser. Có rất nhiều triển khai mã nguồn mở có sẵn có khả năng tương thích toàn diện với thông số kỹ thuật của Ecmascript. Ví dụ: Esprima và Acorn. Cũng có rất nhiều công cụ có thể giúp ta với sản phẩm nhận được từ parser, hay còn gọi là AST. Các AST cũng được dùng nhiều trong phần triển khai của các code transpiler. Ví dụ: bạn cần triển khai một bộ transpiler để chuyển code Python thành Javascript. Ý tưởng cơ bản là ta cần một Python transpiler để sinh ra cây AST - thứ mà ta cần để có thể sinh ra code Javascript sau này.</p><p>Bạn có thể tự hỏi, làm sao như vậy được? Điểm mấu chốt là các AST chỉ là một điểm khác biệt về cách thể hiện một vài ngôn ngữ. Trước khi parse, nó thể hiện dưới dạng văn bản đi kèm theo một số quy luật nhất định để hình thành nên 1 ngôn ngữ. Sau khi parse, nó thể hiện dưới dạng một kiến trúc dạng cây chứa chính xác cùng 1 thông tin với văn bản đầu vào. Vì thế, bạn có thể luôn luôn có thể làm ngược lại và go back về dạng biểu diễn văn bản.</p><h1 id="Javascript-parsing"><a href="#Javascript-parsing" class="headerlink" title="Javascript parsing"></a>Javascript parsing</h1><p>Giờ thì cùng tìm hiểu cây AST được xây dựng như thế nào. Đầu tiên ta có một hàm Javascript đơn giản như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parser sẽ sản sinh ra cây AST như sau:<br><img src="https://cdn-images-1.medium.com/max/1000/0*mSOIiWpkctkD0Gfg." alt=""></p><p>Lưu ý rằng vì mục đích dễ nhìn và đẹp thì hình trên chỉ là phiên bản tối giản của sản phẩm thực sự từ parser. Cây AST thật sẽ phức tạp hơn rất nhiều. Tuy nhiên, mục đích của chúng ta là có được ý tưởng cơ bản về việc mã nguồn sẽ biến thành cái gì trước khi nó được thực thi. Nếu bạn muốn xem cây AST thứ thiệt trông như thế nào thì bạn có thể <a href="https://astexplorer.net/" target="_blank" rel="noopener">vào đây</a>. Đó là 1 công cụ online, bạn chỉ cần nhập code Javascript vào và nó sẽ sinh ra cây AST cho đoạn code đó.</p><p>Bạn sẽ tự hỏi tại sao chúng ta cần biết về cách hoạt động của Javascript parser. Sau tất cả thì nó thuộc về trách nhiệm của trình duyệt. Và về mặt nào đó thì đúng là như thế. Tuy nhiên, bạn có thể xem hình bên dưới, đó là đồ thị biểu diễn tổng thời gian phân phối cho từng bước trong quá trình thực thi code Javascript. Hãy nhìn kỹ hơn và thử xem có thấy được gì thú vị không.<br><img src="https://cdn-images-1.medium.com/max/1000/0*eEArxn147Ev8xf5n." alt=""></p><p>Bạn có thấy được không? Nhìn kỹ xem. Trung bình thì trình duyệt chiếm khoảng 15-20% tổng thời gian thực thi để parse Javascript. Những con số này không phải là bịa đặt. Chúng là số liệu thống kê từ những ứng dụng và website có thật đang bằng cách này hay cách khác sử dụng Javascript. Giờ thì 15% có vẻ như không nhiều lắm, nhưng tin tôi đi, nó có giá trị đấy. Một app SPA tiêu chuẩn sẽ load khoảng 0.4MB code Javascript và trình duyệt tiêu tốn xấp xỉ 370ms để parse nó.</p><p>Thêm một lần nữa, bạn sẽ nói rằng nó chẳng đáng bao nhiêu thời gian cả. Và rõ ràng con số đó quá nhỏ. Tuy nhiên nhớ kỹ rằng đây chỉ là thời gian cần để parse code Javascript thành cây AST. Chưa bao gồm thời gian thực thi chính nó hay bất kỳ tiến trình nào diễn ra trong khi load trang (ví dụ như <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-11---Render-engine---meo-toi-uu-hoa-hieu-nang-render" target="_blank" rel="noopener">CSS &amp; HTML rendering</a>). Và tất cả thông số này mới chỉ thể hiện cho desktop. Khi chúng ta đi sâu hơn trên mobile, mọi thứ sẽ trở nên phức tạp hơn nhiều. <strong>Thời gian dành cho việc parse trên mobile thường có thể nhiều hơn 2-5 lần so với trên desktop.</strong></p><p><img src="https://cdn-images-1.medium.com/max/1000/0*3R6-AyKY1831P10d." alt=""></p><p>Đồ thị trên thể hiện thời gian parse của 1 gói code Javascript 1MB trên rất nhiều thiết bị mobile &amp; desktop thuộc nhiều phân khúc khác nhau.</p><p>Gì nữa nào? Web app đang càng trở nên phức tạp theo từng phút cũng như càng có nhiều business logic phải xử lý ở phía client để có thể mang lại trải nghiệm giống hệt như native app. Bạn có thể dễ dàng hiểu được những điều đó ảnh hưởng như thế nào đến website/wepapp của bạn. Tất cả những gì bạn cần là mở dev tool của trình duyệt lên và để nó đo đạc lượng thời gian dành cho parsing, biên dịch và mọi thứ diễn ra trên trình duyệt cho tới khi trang web được load hoàn toàn.<br><img src="https://cdn-images-1.medium.com/max/1000/0*A5ucCHOZsxXyHMfN." alt=""></p><p>Thật không may, không có dev tool nào cho các trình duyệt mobile. Nhưng đừng lo lắng, điều này không có nghĩa rằng bạn không thể làm gì được. Đây là lý do những công cụ như <a href="https://github.com/danielmendel/DeviceTiming" target="_blank" rel="noopener">DeviceTiming</a> tồn tại. Nó có thể giúp bạn đo đạc thời gian parse và thực thi cho các đoạn code trong một môi trường kiểm soát. Nó hoạt động bằng cách gói gọn code local với đoạn code đo lường, vì thế nên mỗi lần trang web của bạn được truy cập từ các thiết bị khác nhau, bạn có thể đo đạc thời gian parse và thực thi.</p><p>Điều tốt là engine Javascript đã làm rất nhiều thứ nhằm tránh cách công việc thừa thãi và tối hưu hóa nhiều hơn. Dưới đây là 1 vài thứ mà các engine của những trình duyệt lớn đã làm.</p><p>Ví dụ với V8, nó thực hiện script streaming &amp; code caching. Script streaming nghĩa là các đoạn code bất đồng bộ &amp; bị trì hoãn sẽ được parse trong 1 tiến trình riêng ngay khi quá trình download bắt đầu. Nó giúp cho quá trình parsing gần như hoàn thành ngay lập tức sau khi đoạn code (script) được tải xong. Kết quả là các trang sẽ load nhanh hơn khoảng 10%.</p><p>Code Javascript thường được biên dịch thành bytecode mỗi khi có một lượt truy cập trang. Tuy nhiên, cục bytecode này lại bị bỏ đi khi người dùng truy cập đến trang khác. Điều này xảy ra vì code được biên dịch phụ thuộc rất nhiều vào trạng thái và ngữ cảnh của máy tại thời điểm biên dịch. Đây là lý do Chrome 42 giới thiệu bytecode caching (bộ đệm bytecode). Đây là một kỹ thuật lưu trữ code đã biên dịch ở local để khi user quay trở lại trang cũ trước đó thì tất cả mọi hoạt động như download, parse, biên dịch… có thể bỏ qua. Nó cho phép Chrome tiết kiệm 40% thời gian parse &amp; thực thi. Thêm nữa, kết quả nó tiết kiệm pin nhiều hơn nếu chạy trên các thiết bị mobile.</p><p>Trong Opera, engine <a href="https://dev.opera.com/blog/carakan/" target="_blank" rel="noopener">Carakan</a> có thể dùng lại kết quả biên dịch từ chương trình khác vừa mới được biên dịch gần đây. Không có các yêu cầu cụ thể nào về việc code phải đến từ cùng 1 trang hay domain. Kỹ thuật caching này thực sự rất hữu ích và có thể hoàn toàn bỏ qua bước biên dịch. Nó phụ thuộc vào hành vi tiêu chuẩn của user và ngữ cảnh lươt web: mỗi khi user thực hiện cùng chuỗi hành trình với một user khách trên app/website thì cùng 1 đoạn code Javascript sẽ được tải. Tuy nhiên, Opera đã sớm thay thế Carakan bằng Google V8.</p><p>Bộ engine <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" target="_blank" rel="noopener">SpiderMonkey</a> của Firefox không lưu cache bất kỳ thứ gì. Nó đại khái là chuyển qua dùng một thao tác giám sát để đếm xem 1 đoạn code Javascript được thực thi bao nhiêu lần. Dựa trên số đếm này nó xác định phần nào của code đang hot và cần được tối ưu hóa.</p><p>Rõ ràng có một số người lựa chọn không làm gì cả. <a href="http://en.wikipedia.org/wiki/Maciej_Stachowiak" target="_blank" rel="noopener">Maciej Stachowiak</a>, lead developer của Safari, chỉ định rằng Safari không thực hiện bất kỳ hoạt động cache nào cho bytecode đã biên dịch. Có vẻ như họ đã có cân nhắc về việc này nhưng không triển khai nó bởi vì nó chỉ nhỏ hơn 2% tổng thời gian thực thi.</p><p>Những hoạt động tối ưu hóa không trực tiếp ảnh hưởng đến chuyện parsing của code Javascript nhưng chúng chắc chắn đang làm tốt nhất có thể để bỏ qua nó một cách hoàn toàn. Còn cách tối ưu hóa nào tốt hơn là tối ưu hóa hoàn toàn?</p><p>Có nhiều thứ chúng ta có thể làm để cải thiện thời gian load app ban đầu. Ta có thể làm tối giản lượng code Javascript đang sử dụng: ít code, ít parse, ít thực hi. Để làm được điều này, ta cần đưa ra vừa đúng lượng code cần thiết cho một tính năng cụ thể thay vì load 1 cục thiệt to lớn và dùng nó vào mọi thứ. Ví dụ, pattern <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" target="_blank" rel="noopener">PRPL</a> có thuyết giảng về mô hình chuyển giao code như vậy. Nói cách khác, ta có thể kiểm tra các dependency và xem nếu như có gì đó thừa thãi không cần thiết làm chậm code của chúng ta. Về phần này thì hi vọng là sẽ có 1 topic riêng để nói về nó.</p><p>Mục đích của bài viết này là để thảo luận chúng ta - những web developer - có thể làm được gì để giúp cho Javascript parser có thể chạy nhanh hơn. Và chính là đây, các Javascript parser hiện đại sử dụng các phỏng đoán để xác định nếu một đoạn code cụ thể nào đó chuẩn bị được thực thi ngay hoặc quá trình thực thi sẽ bị tạm ngưng và dời lại trong một thời điểm khác.</p><p>Dựa trên các phỏng đoán, parser sẽ làm hoặc là eager parsing (parse nhanh) hoặc là lazy parsing (parse từ từ). Eager parsing chạy xuyên suốt các hàm nào cần được biên dịch tức thời. Nó thực hiện 3 việc chính: xây dựng cây AST, xây dựng hệ thống cấp bậc (hierarchy) cho scope và tìm tất cả các lỗi cú pháp.</p><p>Lazy parsing thì ngược lại, nó chỉ được dùng cho các hàm chưa cần được biên dịch. Nó không xây dựng cây AST và cũng không tìm lỗi cú pháp. Nó chỉ xây dựng hệ thống cấp bậc cho scope và tiết kiệm được một nửa thời gian so với eager.</p><p>Rõ ràng đây không phải là ý tưởng mới. Kể cả trình duyệt như IE9 cũng hỗ trợ tối ưu hóa mặc dù nó chạy hơi thô sơ nếu như so với cách mà parser ngày nay hoạt động.</p><p>Giờ thì cùng xem một ví dụ về cách nó hoạt động. Giả sử ta có đoạn code sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(baz(<span class="number">100</span>, <span class="number">200</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Giống như ví dụ trước, code được đưa vào parser để phân tích cú pháp và trả ra cây AST. Vậy thì đây là những gì thực hiện theo từng dòng:</p><p>Định nghĩa hàm bar nhận 1 biến x và nó có 1 câu lệnh return trả về kết quả của phép tính cộng giữa x và 10.</p><p>Định nghĩa hàm baz nhận 2 biến (x và y). Nó có 1 câu lệnh return. Hàm này trả về kết quả của phép tính cộng giữa x và y.</p><p>Gọi hàm baz với 2 đối số là 100 và 200.</p><p>Tạo ra 1 lời gọi hàm đến console.log với giá trị là kết quả của lời gọi hàm trước đó.</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*60xiqW7kPsQg5ssn." alt=""></p><p>Điều gì vừa xảy ra vậy? Parser thấy có một định nghĩa hàm foo, định nghĩa bar và 1 hàm baz, một lời gọi đến hàm baz, một lời gọi đến hàm console.log. Chờ đã… có một số thứ parser đã làm hoàn toàn không liên quan. Đó là việc parse hàm bar. Tại sao lại không liên quan? Bởi vì hàm bar chưa bao giờ được gọi (ít nhất là cho tới thời điểm này). Đây chỉ là một ví dụ đơn giản và có vẻ như không bình thường nhưng nó xuất hiện trên rất nhiều app thực, có rất nhiều hàm được định nghĩa nhưng không bao giờ dùng đến.</p><p>Thay vì parse hàm bar, chúng ta có thể đánh dấu nó đã được khai báo nhưng không chỉ ra cụ thể nó làm gì. Parsing sẽ diễn ra khi cần thiết ngay trước khi hàm được thực thi. Và dĩ nhiên là lazy parsing cũng vẫn cần thiết để tìm toàn bộ body của hàm và tạo một khai báo cho hàm đó. Nó không cần cây cú pháp bởi vì nó vẫn chưa được xử lý. Thêm nữa, bộ nhớ heap vẫn chưa được cấp phát (phần này cũng chiếm 1 lượng tương đối trong tài nguyên hệ thống). Nói ngắn gọn thì bỏ qua một số bước trên sẽ cải thiện đáng kể hiệu năng.</p><p>Vậy nên nhìn lại ví dụ trên, ta có cây AST mới sẽ như thế này:<br><img src="https://cdn-images-1.medium.com/max/1000/0*IN688nPbgu8zYETe." alt=""></p><p>Lưu ý rằng hàm bar được khai báo và chấp nhận, nhưng chỉ có thế thôi. Chúng ta không làm gì với body của hàm. Trong trường hợp này, body của hàm chỉ có 1 câu lệnh return. Tuy nhiên, trong hầu hết các ứng dụng thực tế, nó có thể lớn hơn rất nhiều, bao gồm nhiều câu lệnh return, điền kiện, vòng lặp, định nghĩa các biến và kể cả các khai báo hàm lồng nhau. Tất cả những thứ này sẽ gây tốn thời gian cũng như tài nguyên hệ thống bởi vì hàm không bao giờ được gọi.</p><p>Đây là một ý tưởng cực kỳ đơn giản nhưng trong thực tế công việc thì việc triển khai nó lại không đơn giản. Dưới đây là một ví dụ mà chắc chắn không phải là trường hợp duy nhất. Toàn bộ phương thức sử dụng các hàm, vòng lặp, điều kiện, object, vân vân. Cơ bản là toàn bộ code cần được parse.</p><p>Ví dụ một mô hình phổ biến để triển khai Javascript module:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// toàn bộ logic của module</span></span><br><span class="line">    <span class="comment">// return về module.</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>Mô hình này dễ dàng nhận ra bởi các Javascript parser hiện đại và là một dấu hiệu cho thấy code bên trong có thể dùng eager parsing.</p><p>Vậy tại sao parser không mặc định lazy parsing? Nếu có gì đó được parse lazy thì nó phải được thực thi ngay lập tức và điều này thực sự gây ra sự chậm chạp. Một lazy parse được thực hiện và ngay sau đó là eager parse. Kết quả là tốc độ chậm hơn 50% khi so sánh với chỉ dùng 1 eager parse.</p><p>Đến lúc này ta đã có kiến thức cơ bản về phía hậu trường, giờ thì thử xem chúng ta có giúp gì cho parser được không. Ta có thể viết code theo cách mà các hàm có thể được parse tại thời điểm phù hợp. Có một pattern được xài chung giữa các parser: đóng gói hàm bên trong dấu ngoặc (). Đây luôn là một dấu hiệu tích cực cho parser hiểu rằng hàm sẽ được thực thi ngay lập tức. Nếu parser bắt gặp một dấu mở ngoặc ( và ngay liền sau đó là một định nghĩa hàm, nó sẽ parse eager hàm đó. Chúng ta có thể giúp parser bằng cách khai báo hàm một cách tường minh như vậy hàm sẽ được thực thi ngay lập tức.</p><p>Giả sử ta có hàm Javascript như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bởi vì không có dấu hiệu rõ ràng rằng hàm sẽ được thực thi ngay lập tức nên trình duyệt sẽ thực hiện lazy parse. Tuy nhiên, chúng ta biết rằng như vậy là không đúng nên ta có thể làm 2 việc.</p><p>Đầu tiên, ta lưu hàm vào trong 1 biến:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Lưu ý rằng ta vẫn giữ lại tên hàm foo giữa từ khóa function và dấu mở ngoặc (. Điều này tuy không cần thiết nhưng bạn bên làm vì trong trường hợp xử lý biệt lệ, stacktrace sẽ hiện ra tên cụ thể của hàm thay vì một chữ <anonymous> khô khan.</anonymous></p><p>Parser vẫn thực hiện lazy parse. Ta có thể ngăn chặn điều này bằng cách thêm một chi tiết nhỏ: gói hàm đó lại trong dấu ngoặc.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Tại thời điểm này, khi parser thấy dấu mở ngoặc ( ngay trước từ khóa function nó sẽ ngay lập tức thực hiện eager parsing.</p><p>Sẽ hơi khó để quản lý bởi vì chúng ta sẽ cần phải biết trong trường hợp nào thì parser chọn parse lazy hay eager. Thêm nữa ta cần phải suy nghĩ và tìm hiểu một hàm cụ thể nào đó có được gọi ngay lập tức hay không. Chúng ta chắc chắn không muốn làm vậy. Ít nhất thì nó sẽ làm cho code khó đọc &amp; khó hiểu hơn. Công cụ như Optimize.js có thể giúp ta rất nhiều. Mục đích duy nhất của nó là tối ưu hóa thời gian loaing ban đầu của code Javascript. Chúng thực hiện phân tích code tĩnh và chỉnh sửa lại để đóng gói những hàm nào cần được thực thi bên trong dấu ngoặc (), trình duyệt sẽ có thể parse eager và chuẩn bị chúng sẵn sàng để thực thi.</p><p>Chúng ta có thể tiếp tục code bình thường và có đc đoạn code sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, World!'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>Mọi thứ có vẻ tốt, hoạt động đúng như mong đợi và nhanh nữa. Bởi vì có dấu mở ngoặc ( trước khi khai báo hàm. Rất tuyệt. Dĩ nhiên rồi, trước khi đưa lên production ta cần minify để tiết kiệm dung lượng. Đoạn code sau là sản phẩm cuối cùng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'Hello, World!'</span>)&#125;();</span><br></pre></td></tr></table></figure><p>Một lần nữa, chúng có vẻ tốt phải không? Code hoạt động y như cũ. Nhưng có gì đó thiếu thiếu. Trình minify đã gỡ dấu ngoặc đóng gói bên ngoài hàm và thay vào đó thêm 1 dấu chấm than ! ngay trước hàm. Điều này nghĩa là parser sẽ bỏ qua nó và thực hiện lazy parse. Trên hết thì để có thể thực thi hàm nó sẽ thực hiện eager parse ngay sau khi lazy parse. Vậy thì lại làm code chạy chậm hơn. May mắn thay, chúng ta có những công cụ như Optimize.js giúp ta trong những trường hợp này. Truyền đoạn code đã minify vào Optimize.js và đây là kết quả đầu ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'Hello, World!'</span>)&#125;)();</span><br></pre></td></tr></table></figure><p>Giờ thì ta đã có thành phẩm tốt nhất: code được minify và parser dễ dàng xác định được những hàm nào cần parse eager hàm nào cần parse lazy.</p><h1 id="Bien-dich-truoc-Pre-compilation"><a href="#Bien-dich-truoc-Pre-compilation" class="headerlink" title="Biên dịch trước (Pre-compilation)"></a>Biên dịch trước (Pre-compilation)</h1><p>Vậy tại sao ta không thực hiện toàn bộ các bước này ở phía server. Dĩ nhiên thì sẽ tốt hơn nếu chúng ta thực hiện 1 lần rồi triển khai kết quả cho tất cả client, thay vì bắt mỗi client phải thực hiện nó mỗi lần chạy. Thật ra thì có những thảo luận về việc engine nên cung cấp một cách để thực thi những đoạn code đã được biên dịch trước để đỡ tốn thời gian cho trình duyệt.</p><p>Về bản chất thì ý tưởng chính là có một công cụ ở phía server có thể sinh ra bytecode rồi truyền trực tiếp về phía client và thực thi. Nếu thực sự được như vậy thì thời gian khởi động app phía client sẽ được cải thiện đáng kể. Nghe rất hấp dẫn, nhưng mọi việc không đơn giản như vậy.</p><p>Điều này có thể gây ra hiệu ứng ngược lại, hiệu ứng lớn là đằng khác, vì hầu hết code có thể sẽ cần phải được ký &amp; xử lý vì những lý do bảo mật. Đội ngũ V8 đang làm việc nội bộ với nhau để tránh re-parsing để quá trình biên dịch trước sẽ có lợi ích như thế.</p><h1 id="Mot-vai-meo-vat-ban-co-the-thuc-hien-de-app-chay-nhanh-hon"><a href="#Mot-vai-meo-vat-ban-co-the-thuc-hien-de-app-chay-nhanh-hon" class="headerlink" title="Một vài mẹo vặt bạn có thể thực hiện để app chạy nhanh hơn"></a>Một vài mẹo vặt bạn có thể thực hiện để app chạy nhanh hơn</h1><ul><li>Kiểm tra các dependency. Loại bỏ những thứ không cần thiết.</li><li>Chia nhỏ code thành nhiều phần nhỏ hơn thay vì load nguyên 1 cục bự.</li><li>Trì hoãn quá trình load Javascript nếu có thể. Bạn chỉ cần load phần code nào cần thiết dựa trên route hiện tại mà thôi.</li><li>Dùng dev tool &amp; DeviceTiming để tìm hiểu phần nào đang bị thắt cổ chai.</li><li>Dùng công cụ như Optimize.js để giúp parser quyết định khi nào nên parse eager &amp; lazy.</li></ul><p>SessionStack là công cụ hỗ trợ tái tạo lại mọi thứ xảy ra đối với người dùng cuối tại thời điểm họ gặp phải vấn đề khi đang tương tác với webapp. Công cụ này không dựng lại phiên làm việc đó thành 1 video thật mà chỉ giả lập tất cả các sự kiện trong một môi trường sandbox trên trình duyệt. Điều này có ý nghĩa nhất định, ví dụ trong trường hợp codebase của page hiện tại lớn và phức tạp.</p><p>Những kỹ thuật trên là những thứ mà team tác giả gần đây kết hợp trong quá trình phát triển SessionStack. Những tối ưu hóa đó cho phép họ load SessionStack nhanh hơn. SessionStack chạy càng nhanh nó càng có thể giải phóng tài nguyên của trình duyệt nhanh hơn và mang lại trải nghiệm một cách liên tục &amp; tự nhiên cho người dùng khi họ load &amp; xem lại các session làm việc.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 14 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;h1 id=&quot;Khai-quat&quot;&gt;&lt;a href=&quot;#Khai-quat&quot; class=&quot;headerlink&quot; title=&quot;Khái quát&quot;&gt;&lt;/a&gt;Khái quát&lt;/h1&gt;&lt;p&gt;Chúng ta đều biết rằng những thứ lộn xộn có thể hợp thành 1 thứ lớn hơn gọi là Javascript. Một đoạn code không chỉ có thể di chuyển qua mạng mà nó còn phải được parse, biên dịch sang bytecode và cuối cùng thực thi. Trong các bài trước, chúng ta đã thảo luận về những thứ chẳng hạn như JS engine, runtime, callstack cũng như engine V8 được dùng chủ yếu trong Chrome và NodeJS. Tất cả đều đóng vai trò quan trọng trong toàn bộ quá trình thực thi của Javascript. Chủ đề mà chúng ta sẽ tìm hiểu hôm nay cũng không kém quan trọng: chúng ta sẽ nghiên cứu xem làm thế nào mà đa số các engine JS parse văn bản thành một thứ gì đó có nghĩa đối với máy móc, những gì xảy ra sau đó và làm thế nào để web developer như chúng ta có thể tận dụng những kiến thức đó làm điểm mạnh.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P13: Bên trong CSS &amp; JS animation &amp; các giải pháp tối ưu hiệu năng của nó</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P13-Ben-trong-CSS-JS-animation-cac-giai-phap-toi-uu-hieu-nang-cua-no.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P13-Ben-trong-CSS-JS-animation-cac-giai-phap-toi-uu-hieu-nang-cua-no.html</id>
    <published>2018-11-25T09:11:00.000Z</published>
    <updated>2018-11-25T09:14:13.336Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 13 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Mọi người đã biết rõ animation đóng vai trò cần thiết trong việc tạo ra các webapp hấp dẫn. Khi người dùng dần dần chuyển sự chú ý của họ sang UX và các doanh nghiệp bắt đầu nhận ra sự quan trọng của trải nghiệm người dùng thú vị &amp; hoàn hảo thì các ứng dụng web dần trở nên nặng nề hơn &amp; cần thể hiện nhiều UI động hơn. Tất cả những thứ này cần đến các animation phức tạp để tạo ra các chuyển dịch trạng thái mượt mà xuyên suốt hành trình trải nghiệm của người dùng. Giờ đây thì điều đó không còn là thứ gì đặc biệt nữa. User càng lúc càng giỏi và họ mong đợi ở những giao diện người dùng có tính tương tác và phản hồi cao.</p><p>Tuy nhiên animating giao diện không nhất thiết phải đơn giản, minh bạch. Thứ gì cần được animated, khi nào và cảm giác mà một animation mang lại, đó mới là những câu hỏi khó trả lời.<br><a id="more"></a></p><h1 id="So-sanh-Javascript-amp-CSS-animation"><a href="#So-sanh-Javascript-amp-CSS-animation" class="headerlink" title="So sánh Javascript &amp; CSS animation"></a>So sánh Javascript &amp; CSS animation</h1><p>Có 2 phương pháp chính để tạo web animation là dùng Javascript hoặc CSS. Không có lựa chọn nào đúng hay sai cả, tất cả tùy thuộc vào thứ mà bạn muốn đạt được.</p><h2 id="Animate-voi-CSS"><a href="#Animate-voi-CSS" class="headerlink" title="Animate với CSS"></a>Animate với CSS</h2><p>Animating với CSS là cách đơn giản nhất để làm một thứ gì đó chuyển động trên màn hình.</p><p>Chúng ta sẽ bắt đầu với một ví dụ nhanh về việc di chuyển một phần tử 50px theo cả 2 trục X và Y. Có thể thực hiện bằng cách đặt một CSS transition với thời gian 1000ms.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(0, 0);</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: -webkit-transform <span class="number">1000ms</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(0, 0);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1000ms</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-class">.move</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(50px, 50px);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(50px, 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Khi class move được thêm vào, giá trị transform bị thay đổi và transition bắt đầu.</p><p>Bên cạnh transition duration (thời gian dịch chuyển), có những tùy chọn cho <strong>easing</strong>, về bản chất thì đây là cảm giác của animation. Chúng ta sẽ tìm hiểu easing chi tiết hơn trong các phần sau của bài viết này.</p><p>Nếu như trong đoạn code trên, bạn tạo ra những class CSS riêng biệt để quản lý animation thì bạn có thể dùng Javascript để tắt/mở mỗi animation.</p><p>Nếu như bạn có phần tử sau:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  Sample content.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bạn có thể dùng Javascript để tắt/mở animation của nó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boxElements = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'box'</span>),</span><br><span class="line">    boxElementsLength = boxElements.length,</span><br><span class="line">    i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; boxElementsLength; i++) &#123;</span><br><span class="line">  boxElements[i].classList.add(<span class="string">'move'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đoạn code trên lấy tất cả những phần tử có class box và thêm class move vào để trigger animation.</p><p>Làm như thế này tạo sự cân bằng cho app của bạn. Bạn có thể tập trung vào quản lý trạng thái với Javascript và chỉ cần đơn giản đặt những class thích hợp vào phần tử cần phải đặt, để cho trình duyệt xử lý các animation. Nếu bạn tiếp tục tìm hiểu theo hướng này, bạn có thể listen sự kiện transitioned trên mỗi phần tử, nhưng chỉ nếu như bạn phải support cho mấy phiên bản cũ của IE:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*Qm9OFPq3siW0tCKfa03DqQ.png" alt=""></p><p>Listen sự kiện transitioned (được bắn ra tại cuối thời điểm transition) giống như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boxElement = <span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>); <span class="comment">// Lấy phần tử đầu tiên có class `box`</span></span><br><span class="line">boxElement.addEventListener(<span class="string">'transitionend'</span>, onTransitionEnd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onTransitionEnd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Xử lý sự kiện transition đã hoàn thành.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thêm nữa, khi sử dụng CSS transition, bạn có thể dùng CSS animation, nó cho phép bạn có quyền nhiều hơn để kiểm soát mỗi animation keyframe, duration và iteration.</p><blockquote><p>Keyframes được dùng để hướng dẫn chỉ định trình duyệt những giá trị của thuộc tính CSS cần phải có tại mỗi thời điểm nhất định và nó sẽ giúp xử lý phần còn lại.</p></blockquote><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Đây là phiên bản đơn giản, không có </span></span><br><span class="line"><span class="comment"> * tiền tố vendor. Nếu có thêm chúng thì </span></span><br><span class="line"><span class="comment"> * sẽ còn dài dòng hơn nữa.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.box &#123;</span><br><span class="line">  <span class="comment">/* Chọn animation */</span></span><br><span class="line">  animation-name: movingBox;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* duration của animation */</span></span><br><span class="line">  animation-duration: <span class="number">2300</span>ms;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* số lần mà ta muốn animation chạy */</span></span><br><span class="line">  animation-iteration-count: infinite;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* làm cho animation đảo ngược vào mỗi vòng lặp lẻ */</span></span><br><span class="line">  animation-direction: alternate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes movingBox &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">    transform: translate(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    opacity: <span class="number">0.4</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">25</span>% &#123;</span><br><span class="line">    opacity: <span class="number">0.9</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">50</span>% &#123;</span><br><span class="line">    transform: translate(<span class="number">150</span>px, <span class="number">200</span>px);</span><br><span class="line">    opacity: <span class="number">0.2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    transform: translate(<span class="number">40</span>px, <span class="number">30</span>px);</span><br><span class="line">    opacity: <span class="number">0.8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Animation trông như thế này đây: <a href="https://sessionstack.github.io/blog/demos/keyframes/" target="_blank" rel="noopener">https://sessionstack.github.io/blog/demos/keyframes/</a></p><p>Với CSS animation, bạn định nghĩa chính animation độc lập với phần tử đích và sử dụng thuộc tính animation-name để chọn animation được yêu cầu.</p><p>Các CSS animation phần nào được đặt sẵn tiền tố vender, với -webkit- đang được sử dụng trong Safari, Safari Mobile và Android. Chrome, Opera, Internet Explorer và Firefox tất cả đều không có sẵn tiền tố. Nhiều công cụ có thể giúp bạn thêm phiên bản tiền tố của CSS mà bạn cần, cho phép bạn viết code mà không cần phải thêm tiền tố.</p><h2 id="Animate-voi-Javascript"><a href="#Animate-voi-Javascript" class="headerlink" title="Animate với Javascript"></a>Animate với Javascript</h2><p>Tạo animation với Javascript phức tạp hơn nhiều so với sử dụng CSS transition hay animation nhưng thường thì nó cung cấp cho developer nhiều sức mạnh đáng kể.</p><p>Javascript animation được viết nội tuyến như là 1 phần của code. Bạn cũng có thể đóng gói nó bên trong các object. Bên dưới là code Javascript mà bạn cần để viết lại đoạn CSS transition ở phần trên:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boxElement = <span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>);</span><br><span class="line"><span class="keyword">var</span> animation = boxElement.animate([</span><br><span class="line">  &#123;<span class="attr">transform</span>: <span class="string">'translate(0)'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">transform</span>: <span class="string">'translate(150px, 200px)'</span>&#125;</span><br><span class="line">], <span class="number">500</span>);</span><br><span class="line">animation.addEventListener(<span class="string">'finish'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  boxElement.style.transform = <span class="string">'translate(150px, 200px)'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Mặc định thì Web Animation chỉ chỉnh sửa phần trình bày của một phần tử. Nếu như bạn muốn object của mình vẫn giữ nguyên vị trí lúc nó được di chuyển tới thì bạn nên sửa lại style của nó khi animation kết thúc. Đây là lý do tại sao chúng ta listen sự kiện finish trong code trên, đặt thuộc tính box.style.transform bằng giá trị translate(150px, 200px) thì nó sẽ thể hiện giống như trường hợp transform thứ 2 trong CSS animation ở trên.</p><p>Với Javascript animation, bạn hoàn toàn kiểm soát style của phần tử tại thời điểm bất kỳ. Nghĩa là bạn có thể làm animation chậm lại, tạm ngưng, dừng hẳn, đảo ngược và điều khiển phần tử cho tới khi phù hợp. Điều này cực kỳ hữu ích nếu bạn muốn xây dựng các ứng dụng hướng đối tượng phức tạp bởi vì bạn có thể đóng gói các hành vi của app một cách chính xác.</p><h1 id="Easing-la-gi"><a href="#Easing-la-gi" class="headerlink" title="Easing là gì?"></a>Easing là gì?</h1><p>Chuyển động tự nhiên làm cho user cảm thấy dễ chịu hơn với webapp của bạn và mang đến trải nghiệm UX tốt hơn.</p><p>Một cách tự nhiên, không có thứ gì di chuyển theo đường thẳng từ điểm này đến điểm khác. Thật ra thì mọi thứ đều có xu hướng tăng tốc và giảm tốc khi chúng di chuyển trong thế giới vật lý của chúng ta và có rất nhiều yếu tố khác nhau ảnh hưởng. Bộ não con người được thiết kế bẩm sinh để cảm nhận những chuyển động nên khi bạn thực hiện animation trên webapp hãy nhớ những kiến thức này.</p><p>Một vài thuật ngữ bạn cần hiểu:</p><ul><li><strong>ease in</strong>: là khi chuyển động bắt đầu chậm và tăng tốc dần lên.</li><li><strong>ease out</strong>: chuyển động bắt đầu nhanh và giảm tốc dần.</li></ul><p>Easing cho phép bạn tạo các animation cho cảm giác tự nhiên hơn.</p><h2 id="Cac-tu-khoa-cho-easing"><a href="#Cac-tu-khoa-cho-easing" class="headerlink" title="Các từ khóa cho easing"></a>Các từ khóa cho easing</h2><p>CSS transition và animation cho phép bạn chọn loại easing mà bạn muốn. Có nhiều từ khóa khác nhau ảnh hưởng đến easing của animation. Bạn cũng có thể tạo ra easing hoàn toàn của riêng bạn.</p><p>Dưới đây là 1 số từ khóa bạn có thể dùng trong CSS để điều khiển easing:</p><ul><li>linear</li><li>ease-in</li><li>ease-out</li><li>ease-in-out</li></ul><p>Giờ thì cùng tìm hiểu về chúng nào.</p><h2 id="Linear-animation"><a href="#Linear-animation" class="headerlink" title="Linear animation"></a>Linear animation</h2><p>Các animation không có bất cứ kiểu easing nào thì được gọi là <strong>linear</strong> (thẳng hàng, còn hàn lâm hơn thì “Tuyến tính”).<br>Đồ thị thể hiện một linear animation:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*M5htfOGgza04ISv_l-69zg.png" alt=""></p><p>Thời gian càng tăng thì giá trị cũng tăng với lượng tương ứng. Với chuyển động linear, mọi thứ có xu hướng thiếu tự nhiên. Nói chung bạn nên tránh sử dụng chuyển động linear.</p><p>Đây là cách triển khai một linear animation đơn giản:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 500<span class="selector-tag">ms</span> <span class="selector-tag">linear</span>;</span><br></pre></td></tr></table></figure><h2 id="Ease-out-animation"><a href="#Ease-out-animation" class="headerlink" title="Ease-out animation"></a>Ease-out animation</h2><p>Như đã nói ở trên, ease out làm cho animation bắt đầu nhanh hơn so với kiểu linear trong khi đó nó lại chậm dần khi kết thúc. Đồ thị trông như thế này:<br><img src="https://cdn-images-1.medium.com/max/1000/1*VDWQl67cmbyAFC5xL9Og4g.png" alt=""></p><p>Nhìn chung, ease out là sự lựa chọn tốt nhất cho UI bởi vì khởi động nhanh làm cho animation của bạn có cảm giác phản hồi tốt trong khi chậm dần khi kết thúc mang lại cảm giác tự nhiên do sự chuyển động không đồng nhất.</p><p>Có nhiều cách để triển khai hiệu ứng ease out nhưng cách đơn giản nhất là từ khóa ease-out trong CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 500<span class="selector-tag">ms</span> <span class="selector-tag">ease-out</span>;</span><br></pre></td></tr></table></figure><h2 id="Ease-in-animation"><a href="#Ease-in-animation" class="headerlink" title="Ease-in animation"></a>Ease-in animation</h2><p>Đây là kiểu đối lập lại với ease-out animation: bắt đầu chậm chạp và kết thúc nhanh. Đồ thị mô tả:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*rWh8YlBn8SypiMduLiYDhA.png" alt=""></p><p>So với ease-out animation thì ease-in có hơi không bình thường vì chúng tạo ra cảm giác thiếu sự phản hồi, bởi vì chúng khởi động chậm. Kết thúc nhanh có thể cũng tạo ra cảm giác lạ tương tự, toàn bộ animation đều tăng tốc trong khi đối tượng ở thế giới thực có xu hướng giảm tốc khi dừng lại đột ngột.</p><p>Để dùng ease-in animation thì bạn có thể dùng từ khóa tương tự như trên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 500<span class="selector-tag">ms</span> <span class="selector-tag">ease-in</span>;</span><br></pre></td></tr></table></figure><h2 id="Ease-in-out-animation"><a href="#Ease-in-out-animation" class="headerlink" title="Ease-in-out animation"></a>Ease-in-out animation</h2><p>Đây là animation kết hợp của ease-in và ease-out. Đồ thị:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*tGXhNroe8KxGN7r4UTVSHw.png" alt=""></p><p>Không nên sử dụng anmation-duration quá lâu bởi vì nó mang lại cảm giác rằng UI của bạn thiếu sự phản hồi.</p><p>Cách sử dụng ease-in-out animation:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 500<span class="selector-tag">ms</span> <span class="selector-tag">ease-in-out</span>;</span><br></pre></td></tr></table></figure><h2 id="Tuy-bien-easing"><a href="#Tuy-bien-easing" class="headerlink" title="Tùy biến easing"></a>Tùy biến easing</h2><p>Bạn có thể định nghĩa đường cung easing cho riêng bạn để có thể kiểm soát nhiều hơn những cảm giác mà animation có thể tạo ra.</p><p>Trên thực tế, các từ khóa ease-in, ease-out, liner, ease được nối với những đường cung Bezier (<a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank" rel="noopener">Bézier curves</a>) đã định nghĩa sẵn, bạn có thể xem chi tiết ở <a href="http://www.w3.org/TR/css3-transitions/" target="_blank" rel="noopener">Thông số kỹ thuật của CSS transition</a> hoặc của <a href="https://w3c.github.io/web-animations/#scaling-using-a-cubic-bezier-curve" target="_blank" rel="noopener">Web Animation</a></p><h2 id="Duong-cung-Bezier"><a href="#Duong-cung-Bezier" class="headerlink" title="Đường cung Bezier"></a>Đường cung Bezier</h2><p>Cùng tìm hiểu về cách hoạt động của đường cung Bezier nào.<br>Một cung Bezier nhận 4 giá trị, hoặc nói rõ hơn thì nó nhận vào 2 cặp số. Mỗi cặp định nghĩa tọa độ X và Y của 1 điểm kiểm soát thuộc khối cung Bezier. Điểm bắt đầu của cung Bezier có tọa độ (0, 0) và kết thúc là ở (1, 1). Bạn có thể đặt cả 2 cặp số. Giá trị X cho 2 kiểm kiểm soát phải nằm trong khoảng [0, 1] còn giá trị của Y thì có thể vượt quá giới hạn [0, 1], mặc dù thông số kỹ thuật không nói rõ là bao nhiêu.</p><p>Kể cả những thay đổi nhỏ trong giá trị X và Y của mỗi điểm kiểm soát mang đến cho bạn một cung hoàn toàn khác biệt. Ở 2 đồ thị bên dưới, cung Bezier có các điểm gần nhau nhưng khác tọa độ.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*2v7G1ZJ1C-y_mWHOYQfQKQ.png" alt=""></p><p>và</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*P5nzyldL4rg36dZmt2RViQ.png" alt=""></p><p>Như bạn thấy thì đồ thị khá là khác nhau. Điểm kiểm soát đầu tiên có vector với giá trị sai khác là (0.045, 0.183) còn điểm thứ 2 là (-0.427, -0.054)</p><p>Còn đây là phần CSS cho đường cung thứ 2:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 500<span class="selector-tag">ms</span> <span class="selector-tag">cubic-bezier</span>(0<span class="selector-class">.465</span>, 0<span class="selector-class">.183</span>, 0<span class="selector-class">.153</span>, 0<span class="selector-class">.946</span>);</span><br></pre></td></tr></table></figure><p>2 số đầu tiên là tọa độ X và Y của điểm kiểm soát thứ nhất, 2 số tiếp theo là của điểm kiểm soát thứ 2.</p><h1 id="Toi-uu-hoa-hieu-nang"><a href="#Toi-uu-hoa-hieu-nang" class="headerlink" title="Tối ưu hóa hiệu năng"></a>Tối ưu hóa hiệu năng</h1><p>Bạn cần phải duy trì 60 khung hình/giây (60 fps - game thủ hiểu cái này lắm nè :D) khi làm animation nếu không thì nó sẽ ảnh hưởng tiêu cực đến UX.</p><p>Và như 1 lẽ dĩ nhiên thì animation không hề miễn phí. Không phải là chuyện tiền nong, mà là hiệu năng. Animate một vài thuộc tính có thể không tốn kém như một số khác. Ví dụ: animate width và height của 1 phần tử sẽ thay đổi trạng thái hình học của nó và là nguyên nhân ảnh hưởng đến các phần tử khác trên trang bị thay đổi vị trí hoặc kích thước. Quá trình này được gọi là layout. Chúng ta cũng đã thảo luận chi tiết về layout và rendering trong <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-11---Render-engine---meo-toi-uu-hoa-hieu-nang-render" target="_blank" rel="noopener">bài trước rồi</a>.</p><p>Nói chung, bạn cần tránh animate những thuộc tính nào có thể trigger quá trình layout hoặc tô màu (paint). Với đa số các trình duyệt hiện đại thì điều này nghĩa là hạn chế animation với opacity và transform</p><h2 id="Will-change"><a href="#Will-change" class="headerlink" title="Will-change"></a>Will-change</h2><p>Bạn có thể dùng <a href="https://dev.w3.org/csswg/css-will-change/" target="_blank" rel="noopener">will-change</a> để thông báo cho trình duyệt biết bạn có ý định thay đổi thuộc tính của 1 phần tử. Nó cho phép trình duyệt cài đặt sẵn sàng trước những tối hưu hóa thích hợp nhất khi bạn cần thay đổi. Tuy nhiên cũng đừng lạm dụng will-change, bởi vì làm như thế có thể làm cho trình duyệt hao tốn tài nguyên và quay ngược lại gây ra nhiều vấn đề hơn về hiệu năng.</p><p>Cách để thêm will-change cho transform và opacity:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">will-change</span>: transform, opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trình duyệt hỗ trợ:<br><img src="https://cdn-images-1.medium.com/max/1000/1*eyaMLcORDVsCFIf5h_ygjA.png" alt=""></p><h2 id="Chon-Javascript-hay-CSS"><a href="#Chon-Javascript-hay-CSS" class="headerlink" title="Chọn Javascript hay CSS"></a>Chọn Javascript hay CSS</h2><p>Có lẽ bạn cũng đã thấy rằng không có câu trả lời đúng cho câu hỏi này, tùy thuộc vào nhiều yếu tố, dưới đây là những thứ bạn cần cân nhắc mỗi khi lựa chọn:</p><ul><li>Các animation dựa trên CSS và Web Animation được hỗ trợ native và được xử lý trong tiến trình gọi là “tiến trình tổng hợp” (compositor thread). Khác với “tiến trình chính” của trình duyệt, nơi mà styling, layout, painting và code Javascript được thực thi. Nghĩa là nếu như trình duyệt đang bận xử lý 1 số tác vụ nặng ký trên tiến trình chính thì những animation đó vẫn có thể tiếp tục thực hiện mà không bị can thiệp.</li><li>Trong một vài trường hợp. các thay đổi đối với transform và opacity có thể được xử lý bởi tiến trình tổng hợp.</li><li>Nếu animation trigger paint, layout hoặc cả 2 thì tiến trình chính sẽ cần phải tham gia xử lý. Trường hợp này xảy ra cho cả CSS và Javascript animation, và dĩ nhiên là việc thực hiện layout hoặc paint như vậy sẽ làm chậm bất kỳ tác vụ nào liên quan đến thực thi CSS hay Javascript</li></ul><h2 id="Chon-dung-thu-de-animate"><a href="#Chon-dung-thu-de-animate" class="headerlink" title="Chọn đúng thứ để animate"></a>Chọn đúng thứ để animate</h2><p>Những animation tuyệt vời thường tạo nên sự thích thú và gắn kết giữa project của bạn với người dùng. Bạn có thể animate bất cứ thứ gì bạn muốn, dù là width, height, position, color, background, vân vân, nhưng cần phải chú ý đến những nút thắt cổ chai tiềm tàng về hiệu năng. Những animation được chọn lựa 1 cách bất cẩn có thể ảnh hưởng tiêu cực đến UX, vì vậy animation cần phải vừa phù hợp vừa tốt cho hiệu năng. Animate càng ít càng tốt, chỉ nên animate khi bạn cần UX trở nên tự nhiên hơn nhưng đừng lạm dụng nó.</p><h2 id="Dung-animation-de-ho-tro-tuong-tac"><a href="#Dung-animation-de-ho-tro-tuong-tac" class="headerlink" title="Dùng animation để hỗ trợ tương tác"></a>Dùng animation để hỗ trợ tương tác</h2><p>Không nên animate chỉ vì bạn thích thế. Thay vì vậy, sử dụng animation tại những vị trí chiến lược để <em>củng cố</em> thêm về tương tác người dùng. Tránh animation làm ngắt quãng hoặc cản trở một cách không cần thiết các hoạt động của user</p><h2 id="Tranh-animate-nhung-thuoc-tinh-phuc-tap"><a href="#Tranh-animate-nhung-thuoc-tinh-phuc-tap" class="headerlink" title="Tránh animate những thuộc tính phức tạp"></a>Tránh animate những thuộc tính phức tạp</h2><p>Chỉ có duy nhất 1 thứ tệ hơn cả animation đặt sai chỗ chính là những animation làm cho trang web bị lag. Kiểu animation này làm cho user cảm thấy bực bội và chán nản.</p><p>Team tác giả sử dụng animation khá dễ dàng với <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=js-series-rendering-engine-outro" target="_blank" rel="noopener">SessionStack</a>. Nói chung, họ theo sát những nguyên tắc đã nêu ở trên nhưng cũng có một số trường hợp mà họ phải dùng animation vì sự phức tạp của UI. SessionStack phải tái tạo lại dưới dạng video toàn bộ những thứ xảy ra với người dùng cuối tại thời điểm họ gặp phải vấn đề khi đang lướt web hay dùng webapp. Để làm được điều này SessionStack tận dụng duy nhất những dữ liệu thu thập được xuyên suốt phiên làm việc: sự kiện từ user, thay đổi trên DOM, request mạng, biệt lệ, thông báo debug, vân vân. Trình chơi của họ được tối ưu hóa khá tốt để có thể render một cách chính xác và sử dụng toàn bộ dữ liệu thu thập được để giả lập chính xác đến từng pixel trình duyệt của người dùng và những thứ xảy ra trên nó, cả về khía cạnh nhìn thấy được và góc nhìn kỹ thuật.</p><p>Để đảm bảo quá trình tái tạo diễn ra một cách tự nhiên, đặc biệt với những phiên làm việc kéo dài và nặng dữ liệu, team tác giả sử dụng các animation để chỉ định chính xác hoạt động loading/buffering và bám sát các nguyên tắc tốt nhất để triển khai chúng, do đó họ không cần quá nhiều CPU và vẫn có thể để cho event loop được rảnh tay render các session.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 13 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;h1 id=&quot;Khai-quat&quot;&gt;&lt;a href=&quot;#Khai-quat&quot; class=&quot;headerlink&quot; title=&quot;Khái quát&quot;&gt;&lt;/a&gt;Khái quát&lt;/h1&gt;&lt;p&gt;Mọi người đã biết rõ animation đóng vai trò cần thiết trong việc tạo ra các webapp hấp dẫn. Khi người dùng dần dần chuyển sự chú ý của họ sang UX và các doanh nghiệp bắt đầu nhận ra sự quan trọng của trải nghiệm người dùng thú vị &amp;amp; hoàn hảo thì các ứng dụng web dần trở nên nặng nề hơn &amp;amp; cần thể hiện nhiều UI động hơn. Tất cả những thứ này cần đến các animation phức tạp để tạo ra các chuyển dịch trạng thái mượt mà xuyên suốt hành trình trải nghiệm của người dùng. Giờ đây thì điều đó không còn là thứ gì đặc biệt nữa. User càng lúc càng giỏi và họ mong đợi ở những giao diện người dùng có tính tương tác và phản hồi cao.&lt;/p&gt;
&lt;p&gt;Tuy nhiên animating giao diện không nhất thiết phải đơn giản, minh bạch. Thứ gì cần được animated, khi nào và cảm giác mà một animation mang lại, đó mới là những câu hỏi khó trả lời.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P12: Bên trong lớp Network + Làm sao để tối ưu hóa hiệu năng và bảo mật Javascript</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P12-Ben-trong-lop-Network-Lam-sao-de-toi-uu-hoa-hieu-nang-va-bao-mat-Javascript.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P12-Ben-trong-lop-Network-Lam-sao-de-toi-uu-hoa-hieu-nang-va-bao-mat-Javascript.html</id>
    <published>2018-11-25T09:06:00.000Z</published>
    <updated>2018-11-25T09:10:31.361Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 12 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Như đã nói trong bài trước về <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-11---Render-engine---meo-toi-uu-hoa-hieu-nang-render" target="_blank" rel="noopener">render engine</a>, tác giả bài viết tin rằng sự khác biệt giữa một Javascript developer tốt (good) và tuyệt vời (great) là dev tuyệt vời không những hiểu về các thành phần cơ bản của một ngôn ngữ mà còn cả phần cốt lõi cũng như môi trường xung quanh nó.<br><a id="more"></a></p><h1 id="Nhac-so-qua-ve-lich-su-mot-chut"><a href="#Nhac-so-qua-ve-lich-su-mot-chut" class="headerlink" title="Nhắc sơ qua về lịch sử một chút"></a>Nhắc sơ qua về lịch sử một chút</h1><p>49 năm trước, một thứ gọi là ARPAnet được tạo ra. Nó chính là một <a href="https://en.wikipedia.org/wiki/Packet_switching" target="_blank" rel="noopener">mạng chuyển đổi gói tin sớm</a> và cũng là <a href="https://en.wikipedia.org/wiki/Internet_protocol_suite" target="_blank" rel="noopener">mạng đầu tiên triển khai bộ TCP/IP</a>. Mạng này cài đặt một liên kết giữa trường đại học California và Học viện nghiên cứu Stanford. 20 năm sau, Tim Berners-Lee phát hành một lời đề nghị cho “Mesh” - thứ mà sau này được biết đến là World Wide Web. Trong 49 năm đó, internet đã đi được một quãng đường dài, bắt đầu chỉ với 2 máy tính trao đổi các gói dữ liệu và giờ đạt tới hơn 75 triệu server, 3.8 tỉ người dùng internet và 1.3 tỉ websites.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*x8P3OcgcgKrEEDpgT2IKkQ.jpeg" alt=""></p><p>Trong bài này, chúng ta sẽ thử phân tích những kỹ thuật nào trình duyệt hiện đại sử dụng để tự động đẩy mạnh hiệu năng (thậm chí bạn không biết đến điều đó), và chúng ta sẽ đặc biệt soi kỹ vào lớp networking của trình duyệt. Ở cuối bài, tác giả sẽ cung cấp một số ý tưởng làm thế nào để giúp trình duyệt đẩy mạnh hơn nữa hiệu năng của webapp của bạn.</p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Trình duyệt web hiện đại được thiết kế đặc trị cho việc truyền tải webapp/website một cách nhanh chóng, hiệu quả và an toàn bảo mật. Với hàng trăm component cùng hoạt động trên nhiều layer khác nhau, từ quản lý tiến trình và bảo mật sandbox đến các GPU pipeline, audio và video, và còn nhiều thứ khác nữa, trình duyệt trông giống như một hệ điều hành hơn là một phần mềm bình thường.</p><p>Hiệu năng tổng quát của trình duyệt được xác định bằng một cơ số các component lớn: parsing (phân giải), layout, tính toán style, quá trình thực thi Javascript &amp; WebAssembly, rendering và dĩ nhiên là cả <strong>networking stack</strong> (ngăn xếp mạng).</p><p>Các kỹ sư thường nghĩ rằng networking stack là một nút cổ chai. Điều này xảy ra thường xuyên vì tất cả các tài nguyên đều cần phải được lấy về từ internet trước khi các bước còn lại được thực hiện. Với networking layer, để hoạt động hiệu quả nó cần phải đóng vai trò nhiều hơn là một bộ quản lý socket đơn giản. Với chúng ta, nó như một thứ núp dưới dạng một cơ chế rất đơn giản để kéo tài nguyên về nhưng đó thực sự là một nền tảng (platform) đầy đủ với các tiêu chí tối ưu hóa, APIs và service của riêng nó.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*WqInzMPQGGcMX9AOONN76g.jpeg" alt=""></p><p>Là web developer, chúng ta không cần phải lo nghĩ về từng gói tin TCP hay UDP, định dạng request, caching và tất cả những thứ liên quan. Toàn bộ sự phức tạp này được trình duyệt gánh dùm nên ta chỉ cần tập trung vào ứng dụng mà chúng ta đang tạo ra. Tuy nhiên, hiểu rõ điều gì thực sự đang diễn ra bên trong có thể giúp chúng ta tạo ra app nhanh hơn và bảo mật tốt hơn.</p><p>Về bản chất thì dưới đây là những gì xảy ra khi user bắt đầu tương tác với trình duyệt:</p><ul><li>User nhập một URL vào thanh địa chỉ trên trình duyệt</li><li>Giả sử URL đó chỉ đến 1 tài nguyên trên mạng, trình duyệt sẽ bắt đầu kiểm tra local cache và cache của ứng dụng và cố thử sử dụng một phải copy có sẵn ở local để đáp ứng request.</li><li>Nếu cache không dùng được, tình duyệt sẽ lấy tên miền từ URL và yêu cầu địa chỉ IP của server từ một <a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener">DNS</a>. Nếu tên miền đã được cache sẵn thì không cần truy vấn đến DNS.</li><li>Trình duyệt tạo ra một gói tin HTTP nói rằng nó yêu cầu một trang web đang cư trú tại một server từ xa.</li><li>Gói tin được gửi đến TCP layer, layer này sẽ thêm thông tin của chính nó vào vị trí trên cùng của gói tin HTTP. Thông tin này cần thiết để duy trì phiên khởi động.</li><li>Gói tin sau đó được trao cho IP layer với công việc chính là tìm hiểu một cách để gửi gói tin từ user đến server từ xa. Thông tin này cũng được lưu vào vị trí trên cùng của gói tin.</li><li>Gói tin được gửi đến server từ xa.</li><li>Khi đã nhận gói tin, một phản hồi được gửi ngược lại theo cách thức tương tự.</li></ul><p><a href="http://www.w3.org/TR/navigation-timing/" target="_blank" rel="noopener">Đặc tính kỹ thuật của Navigation Timing</a> từ W3C cung cấp một API trình duyệt cũng như khả năng hiển thị dữ liệu về thời gian và hiệu năng đằng sau mỗi request trên trình duyệt. Giờ thì cùng quan sát các component, mỗi phần sẽ đóng một vai trò quan trọng trong việc cung cấp các trải nghiệm người dùng (UX) tối ưu:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*rjBdCBwOx5Gp_A6b6FQgfw.png" alt=""></p><p>Toàn bộ tiến trình networking rất phức tạp và có nhiều layer khác nhau có thể trở thành một nút cổ chai. Đây là lý do các trình duyệt cố gắng phấn đấu để cải thiện hiệu năng bản thân bằng cách sử dụng rất nhiều kỹ thuật đa dạng để giảm thiểu tối đa sự ảnh hưởng của toàn bộ giao tiếp network.</p><h1 id="Quan-ly-socket"><a href="#Quan-ly-socket" class="headerlink" title="Quản lý socket"></a>Quản lý socket</h1><p>Cùng khởi động với một số thuật ngữ nào:</p><ul><li><strong>Origin</strong>: một bộ 3 chứa các giao thức ứng dụng, tên miền và số port (ví dụ: https, <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a>, 443)</li><li><strong>Socket pool</strong>: một nhóm các socket thuộc về cùng origin (tất cả các trình duyệt lớn đều giới hạn pool size lớn nhất là 6 socket).</li></ul><p>Javascript và WebAssembly <strong>không cho phép</strong> chúng ta quản lý vòng đời của các network socket riêng tư, và dĩ nhiên như vậy là tốt! Điều này không những giúp chúng ta dễ dàng hơn mà còn cho phép trình duyệt tự động thực hiện rất nhiều tối ưu hóa hiệu năng, một trong số đó bao gồm: sử dụng lại socket, yêu cầu sự ưu tiên và ràng buộc muộn (late binding), giao dịch giao thức, ép buộc giới hạn kết nối, vân vân.</p><p>Thật ra các trình duyệt hiện đại đã làm tốt trong việc chia tách vòng quản lý request khỏi phần quản lý socket. Các socket được tổ chức trong các pool và được nhóm lại theo origin, mỗi pool bắt buộc phải giới hạn kết nối và các ràng buộc bảo mật. Các request chờ được xếp vào trong hàng đợi, đánh thứ tự ưu tiên và sau đó gắn kết với những socket riêng tư trong pool. Trừ khi server có ý định đóng kết nối thì cùng một socket có thể được sử dụng lại một cách tự động xuyên suốt nhiều request.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*0e8X3UTBpsiBSZKa3l1hXA.png" alt=""></p><p>Bởi vì mở mới 1 kết nối TCP thường kèm theo chi phí tốn kém cho nên tái sử dụng lại các kết nối cũ sẽ đảm bảo hiệu năng tốt hơn nhiều. Mặc định thì trình duyệt sử dụng cơ chế gọi là “keepalive” (giữ cho sống) để tiết kiệm thời gian từ việc mở mới kết nối đến server khi có request được tạo ra. Thời gian trung bình để mở 1 kết nối TCP là:</p><ul><li>Request đến máy local: 23ms</li><li>Request trong nội bộ châu lục: 120ms</li><li>Request giữa các châu lục với nhau: 225ms</li></ul><p>Kiểu kiến trúc này mở ra cánh cửa đến với rất nhiều cơ hội để tối ưu hóa. Request có thể được thực thi với những thứ tự khác nhau tùy thuộc vào độ ưu tiên của nó. Trình duyệt có thể tối ưu hóa sự phân chia băng thông giữa toàn bộ các socket hoặc là nó có thể mở socket khi dự đoán trước về một request.</p><p>Như đã nói trước đó, toàn bộ đều được quản lý bởi trình duyệt và không yêu cầu chúng ta giúp bất cứ thứ gì. Nhưng nó không nhất thiết nghĩa là chúng ta không thể làm gì. Chọn lựa đúng pattern về giao tiếp mạng, loại và tần suất transfer, lựa chọn các giao thức và tinh chỉnh/tối ưu hóa server stack có thể đóng vai trò rất lớn trong việc cải thiện hiệu năng tổng thể của ứng dụng.</p><p>Một vài trình duyệt thậm chí còn đi xa hơn. Ví dụ, Chrome có thể tự dạy cho chính nó hoạt động nhanh hơn khi bạn sử dụng nó. Nó học hỏi dựa trên những trang bạn đã ghé thăm và kiểu duyệt web điển hình cho nên nó có thể dự đoán hành vi người dùng có khả năng và thực hiện hành động trước khi user làm gì đó. Ví dụ đơn giản nhất là tự động render trước nội dung của trang khi user rê chuột lên 1 link. Nếu bạn thấy hứng thú về chủ đề tối ưu hóa của Chrome thì có thể đọc thêm chương này <a href="https://www.igvita.com/posa/high-performance-networking-in-google-chrome/" target="_blank" rel="noopener">https://www.igvita.com/posa/high-performance-networking-in-google-chrome/</a> nằm trong quyển sách <a href="https://hpbn.co/" target="_blank" rel="noopener">High-Performance Browser Networking</a></p><h1 id="Bao-mat-mang-va-dong-goi-sandbox"><a href="#Bao-mat-mang-va-dong-goi-sandbox" class="headerlink" title="Bảo mật mạng và đóng gói sandbox"></a>Bảo mật mạng và đóng gói sandbox</h1><p>Cho phép trình duyệt quản lý các socket riêng biệt có một ý nghĩa rất quan trọng: bằng cách này trình duyệt cho phép áp đặt một hệ thống đồng nhất các ràng buộc về chính sách và bảo mật lên những nguồn tài nguyên ứng dụng không đáng tin cậy. Ví dụ như trình duyệt sẽ không chấp nhận API truy xuất trực tiếp vào network socket thô vì như vậy có thể cho phép các ứng dụng độc hại tạo kết nối tùy tiện đến bất cứ host nào. Trình duyệt cũng áp đặt các giới hạn kết nối để bảo vệ server cũng như client khỏi cạn kiệt tài nguyên.</p><p>Trình duyệt định dạng tất cả các request đi ra để áp đặt sự đồng nhất và các ngữ nghĩa giao thức tốt để bảo vệ server. Tương tự, giải mã response được thực hiện một cách tự động để bảo vệ user từ những server độc hại.</p><h2 id="Trao-doi-TLS"><a href="#Trao-doi-TLS" class="headerlink" title="Trao đổi TLS"></a>Trao đổi TLS</h2><p><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">Transport Layer Security (TLS)</a> là một giao thức mật mã cung cấp giao tiếp bảo mật trong mạng máy tính. Nó được sử dụng rộng rãi trong nhiều ứng dụng, một trong số đó là trình duyệt web. Website có thể dùng TLS để bảo đảm an ninh cho tất cả các giao tiếp giữa server và trình duyệt web.</p><p>Toàn bộ quá trình bắt tay TLS bao gồm các bước sau:</p><ol><li>Client gửi một lời nhắn “Client hello” đến server, cùng với một giá trị ngẫu nhiên của client và bộ mã hóa được hỗ trợ.</li><li>Server trả lời bằng cách gửi lời nhắn “Server hello” về cho client, cùng với giá trị ngẫu nhiên của server.</li><li>Server gửi chứng chỉ xác thực của nó về cho client và có thể yêu cầu một chứng chỉ tương tự từ phía client. Server gửi lời nhắn “Server hello done”.</li><li>Nếu server đã yêu cầu một chứng chỉ từ client thì client phải gửi nó.</li><li>Client tạo ra một Pre-Master Secret ngẫu nhiên và mã hóa nó với public key từ chứng chỉ của server, gửi Pre-Master Secret đã được mã hóa về cho server.</li><li>Server nhận Pre-Master Secret. Server và client mỗi bên sẽ sinh ra Master Secret và session key (chìa khóa phiên) dựa trên Pre-Master Secret.</li><li>Client gửi thông báo “Change cipher spec” đến server để xác định rằng client sẽ bắt đầu sử dụng session key mới để băm và mã hóa message. Client cũng đồng thời gửi tin nhắn “Client finished”.</li><li>Server nhận “Change cipher spec” và chuyển đổi trạng thái bảo mật của record layer của nó sang trạng thái bảo mật mã hóa đối xứng bằng session key. Server gửi lời nhắn “server finished” về cho client.</li><li>Client và server giờ có thể trao đổi dữ liệu ứng dụng thông qua kênh bảo mật mà chúng đã thiết lập. Tất cả message được gửi từ client đến server và ngược lại đều được mã hóa bằng session key.</li></ol><p>User được cảnh báo trong trường hợp một trong số xác thực nào đó bị sai, ví dụ: server đang dùng một chứng chỉ tự cấp.</p><h2 id="Chinh-sach-cung-origin"><a href="#Chinh-sach-cung-origin" class="headerlink" title="Chính sách cùng origin"></a>Chính sách cùng origin</h2><p>Hai trang có cùng origin nếu như giao thức, cổng (nếu được chỉ định) và host đều giống nhau giữa 2 trang</p><p>Dưới đây là một vài ví dụ về các tài nguyên có thể được nhúng cross-origin (xuyên origin):</p><ul><li>Javascript với code <code>&lt;script src=&quot;…&quot;&gt;&lt;/script&gt;</code>. Thông báo lỗi cú pháp chỉ tồn tại cho những đoạn script cùng origin.</li><li>CSS với <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;…&quot;&gt;</code>. Do quy tắc cú pháp thoải mái của CSS nên CSS cross-origin cần một header Content-Type đúng loại. Sự hạn chế thì tùy thuộc vào trình duyệt.</li><li>Hình ảnh với thẻ <code>&lt;img /&gt;</code></li><li>File đa phương tiện với <code>&lt;video&gt;</code> và <code>&lt;audio&gt;</code></li><li>Plug in với <code>&lt;object&gt;</code>, <code>&lt;embed&gt;</code> and <code>&lt;applet&gt;</code></li><li>Fonts với @font-face. Vài trình duyệt cho phép các font cross-origin, một số khác thì yêu cầu fonts trong cùng origin.</li><li>Bất cứ thứ gì với <code>&lt;frame&gt;</code> và <code>&lt;iframe&gt;</code>. Một trang có thể sử dụng header X-Frame-Options để ngăn chặn trường hợp tương tác cross-origin này.</li></ul><p>Danh sách trên vẫn còn thiếu sót nhiều, mục đích của nó là làm nổi bật nguyên tắc “quyền hạn tối thiểu” (least privilege). Trình duyệt chỉ phô ra những API và tài nguyên cần thiết cho code của chương trình: ứng dụng hỗ trợ dữ liệu và URL, trình duyệt định dạng các request và xử lý toàn bộ vòng đời của mỗi kết nối.</p><p>Rất đáng để lưu tâm rằng hoàn toàn không có một concept cụ thể nào của “chính sách cùng origin” (same-origin policy). Thay vào đó, chỉ có 1 bộ cơ chế liên quan áp đặt các ràng buộc lên việc truy xuất DOM, cookie và quản lý trạng thái của session, mạng và các thành phần khác của trình duyệt.</p><h1 id="Luu-dem-tai-nguyen-va-trang-thai-cua-client"><a href="#Luu-dem-tai-nguyen-va-trang-thai-cua-client" class="headerlink" title="Lưu đệm tài nguyên và trạng thái của client"></a>Lưu đệm tài nguyên và trạng thái của client</h1><p>Request nhanh nhất và tốt nhất chính là không gọi request nào cả. Trước khi điều phối một request, trình duyệt tự động kiểm tra bộ đệm tài nguyên của nó, thực hiện các kiểm tra xác nhận cần thiết và trả về một bản copy local của tài nguyên đó nếu phù hợp với những điều kiện cụ thể. Nếu tài nguyên ở local không tồn tại trong cache thì request lên mạng được gọi và response sẽ được chèn tự động vào trong cache để cho lần truy cập tiếp theo nếu được phép.</p><ul><li>Trình duyệt tự động đánh giá các chỉ thị lưu đệm (cache directives) cho mỗi tài nguyên.</li><li>Trình duyệt tự động xác nhận lại các tài nguyên hết hạn khi nó có thể.</li><li>Trình duyệt tự động quản lý kích cỡ của bộ đệm và thu hồi tài nguyên.</li></ul><p>Quản lý bộ đệm tài nguyên một cách hiệu quả và tối ưu là rất khó. Ơn trời trình duyệt đã xử lý toàn bộ những thứ phức tạp ấy giúp chúng ta rồi, tất cả những gì ta cần làm là đảm bảo server của mình trả về cache directive phù hợp, để hiểu rõ hơn thì bạn có thể đọc bài <a href="https://hpbn.co/optimizing-application-delivery/#cache-resources-on-the-client" target="_blank" rel="noopener">Cache Resources on the Client</a>. Bạn cung cấp các response headers như Cache-Control, ETag và Last-Modified cho tất cả nguồn tài nguyên trên trang của bạn, phải không?</p><p>Cuối cùng, một chức năng thường bị bỏ quả nhưng khá quan trọng của trình duyệt chính là nhiệm vụ cung cấp xác thực, session và quản lý cookie. Trình duyệt duy trì các gói cookie (cookie jars - tác giả chơi chữ “cookie - bánh quy”) riêng biệt cho mỗi origin, cung cấp các ứng dụng cần thiết và server APIs để đọc/ghi cookie, session và dữ liệu xác thực mới, tự động nối &amp; xử lý các header HTTP phù hợp để tự động hóa toàn bộ quá trình thay cho chúng ta.</p><p>Ví dụ:<br>Một ví dụ đơn giản nhưng dễ minh họa nhất về sự tiện dụng của việc hoãn quản lý trạng thái session với trình duyệt: một session đã được xác thực có thể chia sẻ giữa nhiều tab với nhau hoặc nhiều cửa sổ trình duyệt và ngược lại; một hành động đăng xuất (sign-out) ở 1 tab sẽ vô hiệu hóa các session đang mở ở toàn bộ các cửa sổ đang mở khác.</p><h1 id="Cac-API-ung-dung-va-giao-thuc"><a href="#Cac-API-ung-dung-va-giao-thuc" class="headerlink" title="Các API ứng dụng và giao thức"></a>Các API ứng dụng và giao thức</h1><p>Càng đi sâu tìm hiểu về các dịch vụ network sẵn có thì cuối cùng chúng ta cũng đã tiến đến các API ứng dụng và giao thức (Application APIs &amp; Protocols). Như ta đã biết, những layer thấp thì cung cấp một mảng rộng các dịch vụ quan trọng: quản lý socket &amp; kết nối, xử lý request &amp; response, áp đặt nhiều chính sách bảo mật, lưu đệm &amp; còn nhiều nữa. Mỗi khi chúng ta khởi tạo HTTP hay XMLHttpRequest, sự kiện long-lived Server-Sent hay WebSocket session, hoặc mở kết nối WebRTC… chúng ta đang tương tác với một hoặc nhiều các dịch vụ đó.</p><p>Không có giao thức hay API nào tốt nhất. Mỗi ứng dụng phức tạp sẽ cần một tổ hợp các giao vận (transports) khác nhau dựa trên sự đa dạng của các yêu cầu: giao tiếp với bộ đệm trình duyệt, protocol overhead (metadata hoặc thông tin điều hướng mạng được gửi bởi ứng dụng), độ trễ của message, độ tin cậy, kiểu truyền tải dữ liệu, vân vân. Một số giao thức có thể đáp ứng với độ trễ thấp (ví dụ: Server-Sent Events, WebSocket), nhưng không yêu cầu các tiêu chí quan trọng khác, chẳng hạn như khả năng tận dụng bộ đệm trình duyệt hoặc hỗ trợ truyền tải nhị phân hiệu quả trong mọi trường hợp.</p><h1 id="Mot-vai-thu-ban-co-the-lam-de-cai-thien-hieu-nang-va-bao-mat-cua-Webapp"><a href="#Mot-vai-thu-ban-co-the-lam-de-cai-thien-hieu-nang-va-bao-mat-cua-Webapp" class="headerlink" title="Một vài thứ bạn có thể làm để cải thiện hiệu năng và bảo mật của Webapp"></a>Một vài thứ bạn có thể làm để cải thiện hiệu năng và bảo mật của Webapp</h1><ul><li>Luôn luôn sử dụng header <code>Connection: Keep-Alive</code> trong các request. Trình duyệt đã mặc định sẵn rồi. Đảm bảo server sử dụng cơ chế tương tự.</li><li>Sử dụng header Cache-Control, Etag và Last-Modified phù hợp để tiết kiệm thời gian download cho trình duyệt.</li><li>Dành thời gian để tinh chỉnh và tối ưu hóa web server, phép màu sẽ xảy ra! Nhớ rằng quá trình này rất cụ thể cho từng loại webapp và kiểu dữ liệu mà bạn trao đổi.</li><li>Luôn luôn dùng TLS! Đặc biệt nếu như bạn có bất kỳ xác thực nào trong ứng dụng của bạn.</li><li>Nghiên cứu trình duyệt cung cấp các chính sách bảo mật nào và áp đặt chúng vào trong ứng dụng của bạn.</li></ul><p>Hiệu năng và bảo mật là ưu tiên hàng đầu trong <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=js-series-networking-layer-outro" target="_blank" rel="noopener">SessionStack</a>. Lý do tại sao team tác giả không thể nghiêng về một bên nào hơn là bởi vì một khi đã tích hợp SessionStack vào webapp, nó bắt đầu giám sát mọi thứ từ thay đổi trên DOM, tương tác người dùng đến request mạng, biệt lệ và thông báo debug. Tất cả thông tin này được truyền về server theo thời gian thực và cho phép user có thể chạy lại các vấn đề đã xảy ra dưới dạng video &amp; xem mọi thứ xảy ra với người dùng của bạn. Tất cả hoạt động này được thực hiện với độ trễ tối thiểu và không ảnh hưởng tới hiệu năng của app của bạn.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 12 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Như đã nói trong bài trước về &lt;a href=&quot;https://kipalog.com/posts/Duc-khoet-Javascript--Phan-11---Render-engine---meo-toi-uu-hoa-hieu-nang-render&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;render engine&lt;/a&gt;, tác giả bài viết tin rằng sự khác biệt giữa một Javascript developer tốt (good) và tuyệt vời (great) là dev tuyệt vời không những hiểu về các thành phần cơ bản của một ngôn ngữ mà còn cả phần cốt lõi cũng như môi trường xung quanh nó.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P11: Render engine &amp; mẹo tối ưu hóa hiệu năng render</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P11-Render-engine-meo-toi-uu-hoa-hieu-nang-render.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P11-Render-engine-meo-toi-uu-hoa-hieu-nang-render.html</id>
    <published>2018-11-25T08:29:00.000Z</published>
    <updated>2018-11-25T08:33:25.317Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 11 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Trong những bài trước của series “Đục khoét Javascript”, chúng ta đã tập trung vào tìm hiểu <strong>ngôn ngữ</strong> Javascript, các tính năng của nó, cách chúng được thực thi trên trình duyệt, làm thế nào để tối ưu hóa, vân vân.</p><p>Tuy nhiên, khi bạn xây dựng webapp, bạn không chỉ viết code Javascript. Code của bạn còn tương tác với môi trường. Thấu hiểu môi trường, cách nó hoạt động cũng như các thành phần của nó sẽ cho phép bạn xây dựng app tốt hơn và có nền tảng chuẩn bị tốt để đề phòng những nguy cơ tiềm tàng có thể xảy đến bất cứ lúc nào khi lên production.<br><a id="more"></a><br><img src="https://cdn-images-1.medium.com/max/1000/1*lMBu87MtEsVFqqbfMum-kA.png" alt=""></p><p>Các thành phần chính của trình duyệt:</p><ul><li><strong>Giao diện (User interface)</strong>: phần này bao gồm thanh địa chỉ (address bar), nút back &amp; forward, menu bookmark, vân vân. Về bản chất, đây là những phần thuộc về trình duyệt hiển thị lên cho bạn thấy, ngoại trừ khung hiển thị trang web.</li><li><strong>Engine trình duyệt (Browser engine)</strong>: nó xử lý các giao tiếp giữa user interface và rendering engine</li><li><strong>Engine dựng hình (Rendering engine)</strong>: chịu trách nhiệm hiển thị trang web. Rendering engine sẽ phân giải HTML &amp; CSS và hiển thị nội dung đó lên màn hình.</li><li><strong>Mạng (Networking)</strong>: đây là những lời gọi mạng chẳng hạn như XHR request, chúng được tạo ra bằng cách sử dụng nhiều triển khai khác nhau cho nhiều nền tảng khác nhau nằm phía sau một interface độc lập nền tảng (platform-independent interface). Chúng ta sẽ thảo luận về lớp network chi tiết hơn ở bài tiếp theo (số 12) trong series này nhé.</li><li><strong>Giao diện ở backend (UI Backend)</strong>: dùng để vẽ nên các thành phần cốt lõi, ví dụ như checkbox hay cửa sổ. Phần này thể hiện một interface chung không phụ thuộc hay đặc trưng cho nền tảng. Nó sử dụng các phương thức về UI của hệ điều hành.</li><li><strong>Javascript engine</strong>: Chúng ta đã tìm hiểu về phần này trong <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-2---Ben-trong-engine-V8---5-meo-de-toi-uu-hoa-code" target="_blank" rel="noopener">bài trước</a>. Về cơ bản, đây là nơi code Javascript được thực thi.</li><li><strong>Cố định dữ liệu (Data persistence)</strong>: app của bạn có thể cần lưu trữ dữ liệu ở phía local. Các loại kiến trúc lưu trữ được hỗ trợ ở đây gồm có <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">localStorage</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">indexDB</a>, <a href="https://en.wikipedia.org/wiki/Web_SQL_Database" target="_blank" rel="noopener">WebSQL</a> và <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystem" target="_blank" rel="noopener">FileSystem</a></li></ul><p>Trong bài này, chúng ta sẽ tập trung vào rendering engine (engine dựng hình), bởi vì nó xử lý quá trình phân giải và hình ảnh hóa (visualization) code HTML &amp; CSS, là phần mà đa số app Javascript cần tương tác liên tục.</p><h1 id="Khai-quat-ve-rendering-engine"><a href="#Khai-quat-ve-rendering-engine" class="headerlink" title="Khái quát về rendering engine"></a>Khái quát về rendering engine</h1><p>Công việc chính của rendering engine là hiển thị trang được yêu cầu lên màn hình của trình duyệt.</p><p>Rendering engine có thể hiển thị HTML, văn bản XML và ảnh. Nếu bạn sử dụng thêm plugin ở ngoài thì engine có thể hiển thị các loại văn bản khác, chẳng hạn như PDF.</p><h1 id="Rendering-engines"><a href="#Rendering-engines" class="headerlink" title="Rendering engines"></a>Rendering engines</h1><p>Tương tự như Javascript engine, trình duyệt khác nhau cũng sử dụng các rendering engine khác nhau. Một vài bộ engine nổi tiếng:</p><ul><li><strong>Gecko</strong> — Firefox</li><li><strong>WebKit</strong> — Safari</li><li><strong>Blink</strong> — Chrome, Opera (từ phiên bản 15 trở đi)</li></ul><h1 id="Qua-trinh-render"><a href="#Qua-trinh-render" class="headerlink" title="Quá trình render"></a>Quá trình render</h1><p>Rendering engine nhận nội dung của văn bản được yêu cầu từ lớp networking.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*9b1uEMcZLWuGPuYcIn7ZXQ.png" alt=""></p><h1 id="Xay-dung-DOM-tree"><a href="#Xay-dung-DOM-tree" class="headerlink" title="Xây dựng DOM tree"></a>Xây dựng DOM tree</h1><p>Bước đầu tiên của công cuộc rendering là phân giải văn bản HTML và chuyển những phần tử đã phân giải thành những DOM node thực sự trong DOM tree.</p><p>Giả sử bạn có đoạn input như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"theme.css"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">  &lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt; Hello, &lt;span&gt; friend! &lt;/</span>span&gt; &lt;/p&gt;</span><br><span class="line">    &lt;div&gt; </span><br><span class="line">      &lt;img src=<span class="string">"smiley.gif"</span> alt=<span class="string">"Smiley face"</span> height=<span class="string">"42"</span> width=<span class="string">"42"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>DOM tree của đoạn HTML trên sẽ giống như sau:<br><img src="https://cdn-images-1.medium.com/max/1000/1*ezFoXqgf91umls9FqO0HsQ.png" alt=""></p><p>Về cơ bản thì mỗi phần tử được thể hiện như là một node cha của tất cả các element khác nằm trực tiếp ngay bên dưới (bên trong) nó. Nguyên tắc này được áp dụng một cách đệ quy.</p><h1 id="Xay-dung-CSSOM-tree"><a href="#Xay-dung-CSSOM-tree" class="headerlink" title="Xây dựng CSSOM tree"></a>Xây dựng CSSOM tree</h1><p>CSSOM viết tắt của <strong>CSS Object Model</strong>. Trong khi trình duyệt đang xây dựng DOM, nó bắt gặp một thẻ link trong phần head và dẫn tới một file CSS tên là theme.css ở bên ngoài. Dự đoán rằng nó có thể cần đến tài nguyên này để render trang, ngay lập tức nó điều phối 1 request đến. Giả sử file theme.css có nội dung như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">body &#123; </span><br><span class="line">  font-size: <span class="number">16</span>px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123; </span><br><span class="line">  font-weight: bold; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">span &#123; </span><br><span class="line">  color: red; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p span &#123; </span><br><span class="line">  display: none; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img &#123; </span><br><span class="line">  float: right; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tương tự HTML, engine cần chuyển tất cả CSS sang một thứ gì đó mà trình duyệt có thể xử lý, chính là CSSOM. Dưới đây là mô phỏng của CSSOM tree:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*5YU1su2mdzHEQ5iDisKUyw.png" alt=""></p><p>Bạn có tự hỏi tại sao CSSOM lại có cấu trúc dạng cây (tree)? Khi tính toán bộ style cuối cùng cho mỗi object tren trang, trình duyệt sẽ bắt đầu với rule áp dụng toàn cục nhất cho node đó (ví dụ: nếu nó là con của phần tử body thì áp dụng tất cả style của body) và tinh chỉnh một cách đệ quy những style đã được tính toán bằng cách áp dụng các rule cụ thể hơn.</p><p>Với ví dụ ở trên, bất kỳ text nào nằm bên trong thẻ span mà span nằm trong phần tử body thì đều có font-size 16 và màu đỏ. Những style này được kế thừa từ phần tử body. Nếu như span là con của phần tử p thì nội dung của nó sẽ bị ẩn bởi vì có style khác cụ thể hơn đã được áp dụng cho nó (ở đây là display: none).</p><p>Thêm nữa, lưu ý rằng tree ở trên chưa phải là CSSOM tree hoàn chỉnh và chỉ thể hiện những style mà ta đã ghi đè trong style sheet. Mỗi trình duyệt cung cấp 1 bộ style mặc định, còn được biết tới là <strong>user agent styles</strong> - đây chính những gì ta thấy nếu như không cung cấp style cụ thể. Style của chúng ta thêm vào chỉ đơn giản là ghi đè lại những phần mặc định này.</p><h1 id="Xay-dung-render-tree"><a href="#Xay-dung-render-tree" class="headerlink" title="Xây dựng render tree"></a>Xây dựng render tree</h1><p>Cùng với phần thể hiện trực quan trong HTML kết hợp với dữ liệu style từ CSSOM tree là chúng ta đã có đủ nguyên liệu để tạo ra render tree.</p><p>Bạn sẽ thắc mắc “render tree” là gì? Nó là 1 cây (tree) của các phần tử trực quan được xây dựng theo thứ tự trong đó chúng được hiển thị trên màn hình. Đó là sự thể hiện 1 cách trực quan của HTML cùng với CSS tương ứng. Mục đích của cây này là cho phép tô màu nội dung theo đúng thứ tự.</p><p>Mỗi node trong render tree được gọi là 1 renderer hoặc render object trong Webkit.</p><p>Dưới đây là cách mà render tree của DOM &amp; CSSOM ở trên thể hiện:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*WHR_08AD8APDITQ-4CFDgg.png" alt=""></p><p>Để xây dựng render tree, trình duyệt về cơ bản sẽ làm những bước sau đây:</p><ul><li>Bắt đầu từ root của DOM tree, nó sẽ đi qua mỗi <strong>node thấy được</strong>. Vài node có thể bị ẩn đi (ví dụ như tag script, meta, vân vân) hoặc bỏ qua bởi vì chúng không phản chiếu trong kết quả render đầu ra. Vài node bị ẩn bởi CSS và cũng bị bỏ qua khỏi render tree. Ví dụ như node span trong ví dụ trên thì nó sẽ không có mặt trong render tree vì đã được set style display: none rồi.</li><li>Với mỗi node thấy được, trình duyệt sẽ tìm các rule CSSOM phù hợp và khớp với nó rồi áp dụng vào.</li><li>Trình duyệt sẽ xuất ra các node thấy được với nội dung và style tương ứng.</li></ul><p>Bạn có thể xem qua source code của RenderObject (WebKit) ở đây: <a href="https://github.com/WebKit/webkit/blob/fde57e46b1f8d7dde4b2006aaf7ebe5a09a6984b/Source/WebCore/rendering/RenderObject.h" target="_blank" rel="noopener">https://github.com/WebKit/webkit/blob/fde57e46b1f8d7dde4b2006aaf7ebe5a09a6984b/Source/WebCore/rendering/RenderObject.h</a></p><p>Cùng nghía qua một vài dòng cốt lõi trong class này nhé:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class RenderObject : public CachedImageClient &#123;</span><br><span class="line">  <span class="comment">// Tô màu lại toàn bộ object. Nó sẽ được gọi khi border color thay đổi hoặc</span></span><br><span class="line">  <span class="comment">// border style thay đổi.</span></span><br><span class="line"></span><br><span class="line">  Node* node() <span class="keyword">const</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  RenderStyle* style;  <span class="comment">// the computed style</span></span><br><span class="line">  <span class="keyword">const</span> RenderStyle&amp; style() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mỗi renderer thể hiện một khu vực hình chữ nhật tương ứng với CSS box của một node. Nó bao gồm cả thông tin hình học như độ rộng (width), chiều cao (height) hay vị trí (position).</p><h1 id="Cach-bo-tri-cua-render-tree"><a href="#Cach-bo-tri-cua-render-tree" class="headerlink" title="Cách bố trí của render tree"></a>Cách bố trí của render tree</h1><p>Khi renderer được tạo ra và thêm vào tree, nó không có thông tin vị trí hay kích thước, phần tính toán các giá trị này được gọi là layout.</p><p>HTML sử dụng mô hình layout theo dòng (flow-based layout), nghĩa là hầu như toàn bộ thời gian nó có thể tính toán thông số hình học chỉ trong 1 lần duyệt. Hệ thống tọa độ có liên quan đến root renderer. Thông số tọa độ top và left được sử dụng.</p><p>Layout là 1 quá trình đệ quy, nó bắt đầu ở root renderer, chính là thứ tương ứng với phần tử <html> trong văn bản HTML. Layout tiếp tục duyệt đệ quy qua một hoặc toàn bộ cây cấp bậc(hierarchy) renderer, tính toán các thông tin hình học cần thiết cho mỗi renderer.</html></p><p>Vị trí của root renderer là 0,0 và kích thước của nó bằng phần nhìn thấy được của cửa sổ hiển thị trên trình duyệt (còn gọi là viewport).</p><p>Bắt đầu quá trình tạo layout chính là truyền đạt lại cho mỗi node tọa độ chính xác mà nó cần phải xuất hiện trên màn hình là ở đâu.</p><h1 id="To-mau-cho-render-tree"><a href="#To-mau-cho-render-tree" class="headerlink" title="Tô màu cho render tree"></a>Tô màu cho render tree</h1><p>Trong giai đoạn này, renderer tree đã được duyệt qua và phương thức paint() của renderer được gọi để hiển thị nội dung lên màn hình.</p><p>Tô màu có thể theo cách global hoặc incremantal tương tự như layout):</p><ul><li><strong>Global (toàn cục)</strong>: toàn bộ tree được lên màu.</li><li><strong>Incremental (gia tăng)</strong>: chỉ có một vài renderer thay đổi theo cách không ảnh hưởng đến toàn bộ tree. Renderer vô hiệu hóa khung chữ nhật của chính nó trên màn hình. Điều này làm cho OS (hệ điều thành) hiểu rằng vùng đó cần phải được tô màu lại và sinh ra một paint event. OS thực hiện điều đó một cách thông minh bằng cách gộp nhiều vùng thành một.</li></ul><p>Về tổng quát thì quan trọng là cần phải hiểu rằng tô màu là quá trình diễn ra từ từ. Để có UX tốt hơn, render engine sẽ cố hiển thị nội dung trên màn hình ngay khi có thể. Nó sẽ không ngồi yên đợi cho tới khi toàn bộ HTML được parse để bắt đầu xây dựng và bố trí render tree. Từng phần của nội dung sẽ được parse và hiển thị lên trong khi tiến trình tiếp tục với những item nội dung tiếp theo đang được truyền về trên mạng.</p><h1 id="Thu-tu-xu-ly-script-va-style"><a href="#Thu-tu-xu-ly-script-va-style" class="headerlink" title="Thứ tự xử lý script và style"></a>Thứ tự xử lý script và style</h1><p>Các script được parse và thực thi ngay lập tức khi parser vừa gặp thẻ <code>&lt;script&gt;</code>. Quá trình parse của toàn bộ văn bản sẽ tạm dừng cho đến khi script thực thi xong. Nghĩa là tiến trình này diễn ra đồng bộ.</p><p>Nếu như script là file ở ngoài thì việc đầu tiên nó cần phải được lấy về từ mạng (bất đồng bộ). Tất cả công việc parse sẽ dừng lại cho đến khi lấy xong file.</p><p>HTML5 có thêm 1 tùy chọn để đánh dấu script là bất đồng bộ, do đó nó có thể được parse và thực thi trong 1 tiến trình khác.</p><h1 id="Toi-uu-hoa-hieu-suat-render"><a href="#Toi-uu-hoa-hieu-suat-render" class="headerlink" title="Tối ưu hóa hiệu suất render"></a>Tối ưu hóa hiệu suất render</h1><p>Nếu bạn muốn tối ưu hóa app thì có 5 điểm chính mà bạn cần tập trung vào dưới đây:</p><ol><li><strong>Javascript</strong> - trong các bài trước chúng ta đã nghiên cứu về chủ đề viết code tối ưu và có hiệu quả bộ nhớ cao mà không làm ảnh hưởng đến UI. Với trường hợp của render, chúng ta cần phải suy nghĩ về cách mà code Javascript sẽ tương tác với các phần tử DOM trên trang. Javascript có thể tạo ra rất nhiều thay đổi với UI, đặc biệt là các app SPA.</li><li><strong>Tính toán Style</strong> - đây là tiến trình xác định CSS rule nào sẽ áp dụng vào phần tử nào dựa trên các selector. Một khi các rule đã được định nghĩa, chúng sẽ được áp dụng và tính toán style cuối cùng cho mỗi phần tử.</li><li><strong>Layout</strong> - khi trình duyệt biết rule nào áp dụng cho phần tử nào, nó có thể bắt đầu tính toán bao nhiêu không gian một phần tử sẽ chiếm dụng và vị trí của nó sẽ nằm ở đâu trên màn hình của trình duyệt. Mô hình layout của trang web xác định một phần tử có thể gây ảnh hưởng đến phần tử khác. Ví dụ, độ rộng của <body> có thể ảnh hưởng độ rộng của phần tử con của nó. Điều này nghĩa là quá trình layout sẽ là quá trình nặng về tính toán số học. Phần “vẽ” được thực hiện trong nhiều layer khác nhau.</body></li><li><strong>Tô màu</strong> - đây là lúc mà các pixel thực sự được lên màu. Tiến trình bao gồm cả phần vẽ các câu chữ, màu sắc, hình ảnh, viền, đổ bóng, vấn vân, từng phần nhìn thấy được của từng phần tử.</li><li><strong>Kết hợp (Compositing)</strong> - Bởi vì các phần nhỏ của webpage được vẽ vào trong nhiều lớp khác nhau, chúng cần được kết hợp vào một màn hình theo đúng thứ tự để page có thể render một cách chính xác. Điều này rất quan trọng, đặc biệt là với các phần tử chồng nhau.</li></ol><h1 id="Toi-uu-hoa-JavaScript"><a href="#Toi-uu-hoa-JavaScript" class="headerlink" title="Tối ưu hóa JavaScript"></a>Tối ưu hóa JavaScript</h1><p>Javascript thường trigger những thay đổi nhìn thấy được trên trình duyệt. Và những tác vụ đó nhân lên nhiều lần khi xây dựng ứng dụng SPA.</p><p>Dưới đây là 1 số mẹo nhỏ để bạn biết nên tối ưu phần nào của code Javascript nhằm cải thiện render:</p><ul><li>Tránh sử dụng setTimeout và setInterval đối với những cập nhật nhìn thấy được. Hai hàm này sẽ gọi callback tại 1 thời điểm nào đó trong frame, có thể là cuối frame. Thứ chúng ta cần là trigger thay đổi ngay khi bắt đầu frame để tránh bị sót.</li><li>Đưa những tính toán Javascript phức tạp và tốn thời gian vào trong Web Workers như chúng ta đã thảo luận ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-7---Thanh-phan-cua-WebWorker---5-truong-hop-su-dung" target="_blank" rel="noopener">bài trước</a>.</li><li>Sử dụng các tác vụ siêu nhỏ (micro-tasks) để thông báo sự thay đổi của DOM với nhiều frame. Dùng trong trường hợp các tác vụ cần truy xuất vào DOM, điều này Web Workers không làm được. Về cơ bản thì nó nghĩa là bạn cần chia nhỏ 1 tác vụ lớn thành nhiều phần nhỏ hơn và chạy chúng bên trong các hàm requestAnimationFrame, setTimeout, setInterval tùy thuộc vào đặc tính của mỗi tác vụ.</li></ul><h1 id="Toi-uu-hoa-CSS"><a href="#Toi-uu-hoa-CSS" class="headerlink" title="Tối ưu hóa CSS"></a>Tối ưu hóa CSS</h1><p>Chỉnh sửa DOM bằng cách thêm bớt các phần tử, thay đổi các thuộc tính… sẽ làm cho trình duyệt phải tính toán lại style của phần tử và trong nhiều trường hợp, là phải tính lại layout của toàn bộ trang hoặc 1 phần của trang.</p><p>Để tối ưu quá trình render, bạn cần cân nhắc những điều sau:</p><ul><li>Giảm thiểu sự phức tạp trong các selector. Sự phức tạp của selector có thể chiếm đến hơn 50% thời gian cần thiết để tính toán style cho 1 phần tử (phần còn lại là thời gian để xây dựng style).</li><li>Giảm số lượng phần tử cần được tính toán style. Về bản chất thì thay đổi style trực tiếp cho 1 vài phần tử thì tốt hơn là vô hiệu toàn bộ page.</li></ul><h1 id="Toi-uu-hoa-layout"><a href="#Toi-uu-hoa-layout" class="headerlink" title="Tối ưu hóa layout"></a>Tối ưu hóa layout</h1><p>Tính toán lại layout có thể ngốn nhiều tài nguyên của trình duyệt nên bạn cần cân nhắc những điều sau:</p><ul><li>Giảm số lượng layout bất cứ khi nào có thể. Khi bạn thay đổi style thì trình duyệt kiểm tra để xem thử có thay đổi nào cần layout phải được tính toán lại không. Các thay đổi về property như width, height, left, top và trên hết là những property nào liên quan đến hình học, cần có layout. Vì thế tránh thay đổi chúng hết mức có thể.</li><li>Dùng flexbox bất cứ khi nào có thể dùng. Nó chạy nhanh hơn và có thể cải thiện hiệu năng một cách đáng kể.</li><li>Tránh ép buộc layout đồng bộ. Nhớ rằng khi Javascript chạy, tất cả giá trị của layout cũ từ frame trước đó được xác định và sẵn sàng cho bạn truy vấn. Không vấn đề gì nếu như bạn muốn truy xuất box.offsetHeight. Tuy nhiên, nếu bạn thay đổi style của box trước khi nó được truy xuất (ví dụ: cố tình thêm CSS class vào 1 phần tử), trình duyệt đầu tiên sẽ áp dụng thay đổi của style rồi sau đó mới chạy đến phần layout. Điều có có thể gây tốn thời gian và làm ảnh hưởng nặng đến tài nguyên máy tính, vì thế nên tránh càng xa nó càng tốt.</li></ul><h1 id="Toi-uu-hoa-to-mau"><a href="#Toi-uu-hoa-to-mau" class="headerlink" title="Tối ưu hóa tô màu"></a>Tối ưu hóa tô màu</h1><p>Đây thường là tác vụ chạy lâu nhất trong số các tác vụ nên quan trọng là tránh mặt nó càng xa càng tốt. Những gì bạn có thể làm:</p><ul><li>Thay đổi bất kỳ property nào khác ngoài transform hay opacity sẽ trigger tác vụ tô màu. Nhớ sử dụng tiết kiệm nhé.</li><li>Nếu bạn trigger một layout, bạn cũng sẽ trigger luôn tác vụ tô màu bởi vì thay đổi về kích thước hình học cũng sẽ thay đổi phần nhìn thấy được của phần tử.</li><li>Giảm diện tích tô màu thông qua thăng cấp layer và dàn dựng các animation.</li></ul><p>Render là một khía cạnh quan trọng trong cách thức hoạt động của <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=js-series-rendering-engine-outro" target="_blank" rel="noopener">SessionStack</a>. SessionStack phải tái tạo lại một video về mọi thứ đã diễn ra với user tại thời điểm họ trải nghiệm qua một vấn đề khi đang lướt webapp của bạn. Để làm được điều này, SessionStack chỉ xử lý duy nhất những dữ liệu mà thư viện của nó thu thập được: các sự kiện từ user, thay đổi trên DOM, request lên mạng, biệt lệ, thông báo debug, vân vân. Trình phát video được tối ưu hóa tối đa để có thể render một cách chính xác và sử dụng toàn bộ những dữ liệu thu thập được để có thể đưa ra một bản giả lập trình duyệt của user hoàn-hảo-đến-từng-pixel cũng như những gì đã xảy ra trên đó, cả về mặt kỹ thuật lẫn quan sát.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 11 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Trong những bài trước của series “Đục khoét Javascript”, chúng ta đã tập trung vào tìm hiểu &lt;strong&gt;ngôn ngữ&lt;/strong&gt; Javascript, các tính năng của nó, cách chúng được thực thi trên trình duyệt, làm thế nào để tối ưu hóa, vân vân.&lt;/p&gt;
&lt;p&gt;Tuy nhiên, khi bạn xây dựng webapp, bạn không chỉ viết code Javascript. Code của bạn còn tương tác với môi trường. Thấu hiểu môi trường, cách nó hoạt động cũng như các thành phần của nó sẽ cho phép bạn xây dựng app tốt hơn và có nền tảng chuẩn bị tốt để đề phòng những nguy cơ tiềm tàng có thể xảy đến bất cứ lúc nào khi lên production.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P10: Quan sát thay đổi trên DOM bằng MutationObserver</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P10-Quan-sat-thay-doi-tren-DOM-bang-MutationObserver.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P10-Quan-sat-thay-doi-tren-DOM-bang-MutationObserver.html</id>
    <published>2018-11-25T08:24:00.000Z</published>
    <updated>2018-11-25T08:29:18.823Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 10 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*mPXf5zRCdEQ42Hn0." alt=""></p><p>Webapp càng ngày càng nặng hơn ở phía client bởi vì nhiều lý do đại loại như UI phải “phì nhiêu” để chứa đựng những thứ logic phức tạp bên trong bao gồm cả tính toán theo thời gian thực (real-time), và nhiều nhiều thứ khác nữa.</p><p>Sự phức tạp gia tăng làm cho chúng ta khó nắm bắt chính xác trạng thái của UI tại mỗi thời điểm trong vòng đời của webapp.</p><p>Điều này càng khó hơn nữa nếu chúng ta xây dựng một vài thứ chẳng hạn như library hay framework mà cần phải phản ứng cũng như xử lý những hành động dựa trên DOM.<br><a id="more"></a></p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a> (tạm dịch: Người quan sát sự biến đổi) là một WebAPI được các trình duyệt hiện đại cung cấp để phát hiện các thay đổi trên DOM. Với API này một người có thể listen các node mới được thêm vào hoặc gỡ ra, thuộc tính thay đổi hoặc những thay đổi về nội dung văn bản trong một text node.</p><p>Tại sao phải cần làm thế?</p><p>Có một số ít trường hợp trong đó MutationObserver API thực sự hữu ích. Ví dụ:</p><ul><li>Bạn muốn thông báo cho người dùng webapp rằng một vài sự thay đổi đã xảy ra trên trang mà người đó đang sử dụng.</li><li>Bạn đang làm việc với 1 Javascript framework sang chảnh mới, nó cần load rất nhiều JS module một cách tự động dựa trên sự thay đổi của DOM.</li><li>Bạn đang làm việc với bộ soạn thảo WYSIWYG và thử triển khai tính năng undo/redo. Bằng cách tận dụng MutationObserver API, bất kỳ lúc nào bạn cũng có thể biết phần nào đã thay đổi và dễ dàng undo chúng.</li></ul><p><img src="https://cdn-images-1.medium.com/max/1000/1*48tGIboHxgLeKEjMTGkUGg.png" alt=""></p><p>Trên đây chỉ là 1 số ví dụ về lợi ích của MutationObserver.</p><h1 id="Cach-su-dung-MutationObserver"><a href="#Cach-su-dung-MutationObserver" class="headerlink" title="Cách sử dụng MutationObserver"></a>Cách sử dụng MutationObserver</h1><p>Triển khai MutationObserver khá dễ dàng. Bạn cần tạo 1 instance MutationObserver bằng cách truyền cho nó 1 hàm và hàm này được gọi mỗi khi 1 sự thay đổi xảy ra. Đối số đầu tiên của hàm là 1 tập hợp tất cả các sự thay đổi xảy ra trên 1 khối duy nhất. Mỗi sự thay đổi cung cấp thông tin về loại của nó cũng như thay đổi nào đã xảy ra.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutationObserver = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</span><br><span class="line">  mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mutation);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Object tạo ra có 3 phương thức:</p><ul><li><strong>observe</strong>: bắt đầu lắng nghe sự thay đổi. Nó nhận 2 đối số: DOM node mà bạn muốn quan sát và một object chưa các thiết lập.</li><li><strong>disconnect</strong>: dừng quá trình lắng nghe thay đổi.</li><li><strong>takeRecords</strong>: trả về khối thay đổi cuối cùng trước khi callback được kích hoạt.</li></ul><p>Đoạn code sau thể hiện quá trình quan sát (observing) diễn ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bắt đầu lắng nghe thay đổi trong root HTML của trang.</span></span><br><span class="line">mutationObserver.observe(<span class="built_in">document</span>.documentElement, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span>,</span><br><span class="line">  characterData: <span class="literal">true</span>,</span><br><span class="line">  childList: <span class="literal">true</span>,</span><br><span class="line">  subtree: <span class="literal">true</span>,</span><br><span class="line">  attributeOldValue: <span class="literal">true</span>,</span><br><span class="line">  characterDataOldValue: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Giờ giả sử ta có 1 div cực kỳ đơn giản trong DOM:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"sample-div"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"test"</span>&gt; Simple div &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>Sử dụng jQuery, bạn có thể xóa thuộc tính class từ div đó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#sample-div"</span>).removeAttr(<span class="string">"class"</span>);</span><br></pre></td></tr></table></figure><p>Khi đã bắt đầu quan sát, sau khi gọi hàm mutationObserver.observe(…) ta có thể xem thông tin log được in ra trong console của <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord" target="_blank" rel="noopener">MutationRecord</a>.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*UxkSstuyCvmKkBTnjbezNw.png" alt=""></p><p>Đây là sự biến đổi tạo ra bởi ta đã xóa thuộc tính class.</p><p>Cuối cùng, để dừng sự quan sát DOM sau khi đã xong việc, ta làm như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dừng MutationObserver, không lắng nghe thay đổi nữa.</span></span><br><span class="line">mutationObserver.disconnect();</span><br></pre></td></tr></table></figure><p>Ngày nay MutationObserver được hỗ trợ khá tốt:</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*nlOmrsfy-Y1XoR8B." alt=""></p><h1 id="Giai-phap-thay-the"><a href="#Giai-phap-thay-the" class="headerlink" title="Giải pháp thay thế"></a>Giải pháp thay thế</h1><p>Tuy nhiên, MutationObserver cũng chỉ mới xuất hiện chưa lâu. Vậy thì trước khi có nó, các developer dùng cái gì?</p><p>Dưới đây là 1 vài lựa chọn:</p><ul><li><strong>Polling</strong></li><li><strong>MutationEvents</strong></li><li><strong>CSS animations</strong></li></ul><h2 id="Polling"><a href="#Polling" class="headerlink" title="Polling"></a>Polling</h2><p>Giải pháp đơn giản nhất và kém tinh tế nhất là polling (bỏ phiếu bình chọn). Sử dụng WebAPI setInterval bạn có thể thiết lập 1 tác vụ kiểm tra sự thay đổi theo chu kỳ nhất định. Dĩ nhiên thì cách này làm giảm hiệu năng của webapp 1 cách đáng sợ.</p><h2 id="MutationEvents"><a href="#MutationEvents" class="headerlink" title="MutationEvents"></a>MutationEvents</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events" target="_blank" rel="noopener">MutationEvents API</a> được giới thiệu vào năm 2000. Mặc dù nó có ích, các sự kiện thay đổi (mutation events) được bắn ra mỗi khi có 1 sự thay đổi bất kỳ trên DOM và một lần nữa làm ảnh hưởng đến hiệu năng. Ngày nay thì MutationEvents API đã bị hủy bỏ và những trình duyệt hiện đại sẽ sớm ngừng hỗ trợ nó.</p><p>Danh mục trình duyệt hỗ trợ cho MutationEvents:</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*l-QdpBfjwNfPDTyh." alt=""></p><h2 id="CSS-animations"><a href="#CSS-animations" class="headerlink" title="CSS animations"></a>CSS animations</h2><p>Một giải pháp thay thế hơi kỳ cục đó là dựa trên <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations" target="_blank" rel="noopener">CSS Animations</a>. Nghe có vẻ bối rối nhỉ. Về cơ bản thì ý tưởng của nó là tạo ra 1 animation có thể được trigger khi có một element được thêm vào DOM. Khoảnh khắc animation bắt đầu, sự kiện animationstart sẽ được bắn ra: nếu bạn đã gắn 1 event handler vào sự kiện đó thì bạn sẽ biết 1 cách chính xác khi nào element được thêm vào DOM. Thời gian thực hiện của animation phải cực nhỏ để cho nó dường như vô hình trước con mắt user.</p><p>Đầu tiên ta cần một element cha, bên trong nó ta sẽ listen sự kiện chèn node:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=”container-element”&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>Để có thể xử lý khi có node chèn vào, ta cần thiết lập một chuỗi các <a href="https://www.w3schools.com/cssref/css3_pr_animation-keyframes.asp" target="_blank" rel="noopener">keyframe</a> animation khởi động khi node được thêm vào:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@keyframes nodeInserted &#123; </span><br><span class="line"> <span class="keyword">from</span> &#123; <span class="attr">opacity</span>: <span class="number">0.99</span>; &#125;</span><br><span class="line"> to &#123; <span class="attr">opacity</span>: <span class="number">1</span>; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Với keyframe được tạo ra đó, animation cần phải được áp dụng vào các element mà ta muốn lắng nghe. Lưu ý là thời gian duration rất nhỏ, mục đích là để kéo dãn dấu vết của animation trên trình duyệt:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#container-element * &#123;</span><br><span class="line"> animation-duration: <span class="number">0.001</span>s;</span><br><span class="line"> animation-name: nodeInserted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bước thiết lập này sẽ thêm animation vào tất cả các node con của container-element. Khi animation kết thúc (sau 0.001s như trên), sự kiện chèn node sẽ được bắn ra.</p><p>Ta cần một hàm event listener Javascript. Trong hàm đó ta phải gọi event.animationName để đảm bảo đó chính là animation mà ta cần.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertionListener = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Đảm bảo đây là animation mà ta cần xử lý.</span></span><br><span class="line">  <span class="keyword">if</span> (event.animationName === <span class="string">"nodeInserted"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Node has been inserted: "</span> + event.target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Giờ thì thêm event listener vào node cha:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(“animationstart”, insertionListener, <span class="literal">false</span>); <span class="comment">// standard + firefox</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(“MSAnimationStart”, insertionListener, <span class="literal">false</span>); <span class="comment">// IE</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(“webkitAnimationStart”, insertionListener, <span class="literal">false</span>); <span class="comment">// Chrome + Safari</span></span><br></pre></td></tr></table></figure><p>Trình duyệt hỗ trợ CSS animation:</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*W4wHvVAeUmc45vA2." alt=""></p><p>MutationObserver cung cấp một số tính năng nâng cao hơn tất cả 3 giải pháp trên. Về bản chất, nó bao phủ toàn bộ mỗi thay đổi có thể diễn ra trên DOM và nó được tối ưu hóa khi bắn ra các thay đổi trong 1 chuỗi hàng loạt. Trên hết MutationObserver được hỗ trợ bởi tất cả các trình duyệt hiện đại đi kèm với 1 số polyfills để dùng MutationEvents</p><p>MutationObserver chiếm giữ một vị trí trung tâm trong thư viện của <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=mutation-observer-post" target="_blank" rel="noopener">SessionStack</a>.</p><p>Khi bạn đã tích hợp thư viện của SessionStack vào webapp, nó bắt đầu thu thập các thông tin chẳng hạn như thay đổi trên DOM, request mạng, biệt lệ, thông báo debug, vân vân, và gửi chúng về server. SessionStack dùng chính những dữ liệu này để tái tạo lại mọi thứ đã xảy ra với user của bạn và hiển thị các vấn đề của sản phẩm trong cùng 1 tình huống mà nó diễn ra với user. Khá nhiều người nghĩ rằng SessionStack ghi lại video, nhưng không phải vậy. Ghi video rất tốn kém, mặt khác lượng dữ liệu thu thập được lại rất nhẹ và không ảnh hưởng đến UX cũng như hiệu năng của webapp của bạn.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 10 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1000/0*mPXf5zRCdEQ42Hn0.&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Webapp càng ngày càng nặng hơn ở phía client bởi vì nhiều lý do đại loại như UI phải “phì nhiêu” để chứa đựng những thứ logic phức tạp bên trong bao gồm cả tính toán theo thời gian thực (real-time), và nhiều nhiều thứ khác nữa.&lt;/p&gt;
&lt;p&gt;Sự phức tạp gia tăng làm cho chúng ta khó nắm bắt chính xác trạng thái của UI tại mỗi thời điểm trong vòng đời của webapp.&lt;/p&gt;
&lt;p&gt;Điều này càng khó hơn nữa nếu chúng ta xây dựng một vài thứ chẳng hạn như library hay framework mà cần phải phản ứng cũng như xử lý những hành động dựa trên DOM.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P9: Cấu tạo của Web Push Notifications</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P9-Cau-tao-cua-Web-Push-Notifications.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P9-Cau-tao-cua-Web-Push-Notifications.html</id>
    <published>2018-11-24T15:51:00.000Z</published>
    <updated>2018-11-24T15:53:39.773Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 9 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Hôm nay chúng ta sẽ chuyển hướng sự chú ý qua <strong>web push notifications</strong> (tạm dịch: thông báo đẩy trên trang web): chúng ta sẽ tìm hiểu về thành phần của nó, khám phá các quy trình gửi/nhận thông báo phía sau và cuối bài sẽ cùng tìm hiểu làm sao SessionStack sử dụng chúng để xây dựng chức năng của sản phẩm.</p><p>Push Notifications rất phổ biến trong thế giới của điện thoại. Vì lý do này hay lý do khác, chúng bước chân vào thế giới web lại khá muộn mặc dù nó là tính năng rất được các developer ưa chuộng và đề xuất.<br><a id="more"></a></p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Web Push Notifications cho phép user tham gia vào các cập nhật theo thời gian từ webapp nhằm mục đích thu hút người dùng dựa trên nội dung thú vị, quan trọng và đúng lúc đối với họ.</p><p>Push dựa trên Service Workers - chính là chủ đề mà chúng ta đã <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-8---Service-Workers--vong-doi-va-cac-truong-hop-su-dung" target="_blank" rel="noopener">thảo luận ở bài trước</a>.</p><p>Lý do lựa chọn dùng Service Workers trong trường hợp này là vì chúng hoạt động trong background. Rất phù hợp cho Push Notifications vì như vậy nghĩa là code chỉ được thực thi khi user tương tác với chính notification đó.</p><h1 id="Push-amp-notification"><a href="#Push-amp-notification" class="headerlink" title="Push &amp; notification"></a>Push &amp; notification</h1><p>Push và notification là 2 API khác nhau.</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API" target="_blank" rel="noopener">Push</a>: được gọi khi server cung cấp thông tin cho Server Worker</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API" target="_blank" rel="noopener">Notification</a>: hành động của Service Worker hoặc một đoạn script trên webapp nhằm hiển thị thông tin đến user.</li></ul><h1 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h1><p>Có 3 bước cơ bản để triển khai 1 push:</p><ul><li><strong>Giao diện (UI)</strong>: thêm vào những logic cần thiết ở phía client để đăng ký user với push. Đây là phần logic Javascript mà UI của webapp cần để cho phép user đăng ký vào push message.</li><li><strong>Gửi push message</strong>: triển khai lời gọi API trên server để trigger một push message tới thiết bị của user.</li><li><strong>Nhận push message</strong>: xử lý push message một khi nó về tới trình duyệt.</li></ul><p>Giờ thì chúng ta sẽ tìm hiểu toàn bộ quá trình một cách chi tiết hơn.</p><h1 id="Xac-nhan-ho-tro-tu-trinh-duyet"><a href="#Xac-nhan-ho-tro-tu-trinh-duyet" class="headerlink" title="Xác nhận hỗ trợ từ trình duyệt"></a>Xác nhận hỗ trợ từ trình duyệt</h1><p>Đầu tiên là cần phải kiểm tra xem trình duyệt bạn đang dùng có hỗ trợ cho push message hay không. Chúng ta có 2 bài check đơn giản:</p><ul><li>Kiểm tra serviceWorker trong object navigator</li><li>Kiểm tra PushManager trong object window</li></ul><p>Code kiểm tra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator)) &#123; </span><br><span class="line">  <span class="comment">// Service Worker không được hỗ trợ, vô hiệu hóa hoặc ẩn UI đi. </span></span><br><span class="line">  <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(<span class="string">'PushManager'</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123; </span><br><span class="line">  <span class="comment">// Push không được hỗ trợ, vô hiệu hóa hoặc ẩn UI đi. </span></span><br><span class="line">  <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dang-ky-mot-Service-Worker"><a href="#Dang-ky-mot-Service-Worker" class="headerlink" title="Đăng ký một Service Worker"></a>Đăng ký một Service Worker</h1><p>Tại thời điểm này, ta đã biết các chức năng đều được hỗ trợ. Bước tiếp theo sẽ là đăng ký Service Worker.</p><p>Đăng ký một Service Worker như thế nào thì bạn cũng đã quen với những diễn giải từ <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-8---Service-Workers--vong-doi-va-cac-truong-hop-su-dung" target="_blank" rel="noopener">bài trước</a> rồi.</p><h1 id="Yeu-cau-duoc-cap-quyen"><a href="#Yeu-cau-duoc-cap-quyen" class="headerlink" title="Yêu cầu được cấp quyền"></a>Yêu cầu được cấp quyền</h1><p>Xong phần với Service Worker thì ta có thể đi tiếp đến phần đăng ký user. Bạn cần phải có quyền của user thì mới gửi push message đến họ được.</p><p>API dùng để lấy quyền (permission) cũng tương đổi đơn giản, tuy nhiên điểm bất lợi là API đã thay đổi từ việc dùng callback sang trả về Promise. Nó sinh ra vấn đề khác: chúng ta không thể biết version của API đã được triển khai trên trình duyệt hiện tại, vì thế chúng ta phải xử lý cả 2 trường hợp.</p><p>Nó trông như thế này đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestPermission</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> permissionResult = Notification.requestPermission(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Xử lý phiên bản cũ với callback.</span></span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (permissionResult) &#123;</span><br><span class="line">      permissionResult.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">permissionResult</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permissionResult !== <span class="string">'granted'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Permission not granted.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lời gọi đến Notification.requestPermission() sẽ hiển thị 1 bảng thông báo nhỏ:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*xhB8ceUNM6vb8s0ZQKMHNg.png" alt=""></p><p>Một khi quyền đã được cấp, được đóng hoặc block thì chúng ta cũng nhận được những kết quả tương tự dưới dạng string: granted, default, denied.</p><p>Nhớ rằng nếu user click chuột vào nút Block thì webapp của bạn sẽ không thể hỏi user về chuyện cấp quyền một lần nữa, cho tới khi user tự “unblock” app của bạn bằng cách thay đổi trạng thái của quyền. Tùy chọn này được giấu trong bảng cài đặt.</p><h1 id="Dang-ky-mot-user-voi-PushManager"><a href="#Dang-ky-mot-user-voi-PushManager" class="headerlink" title="Đăng ký một user với PushManager"></a>Đăng ký một user với PushManager</h1><p>Khi Service Worker đã được đăng ký và chúng ta được user cấp quyền, ta có thể subscribe 1 user bằng cách gọi registration.pushManager.subscribe() khi đăng ký Service Worker của bạn.</p><p>Toàn bộ đoạn code như sau (bao gồm cả phần đăng ký Service Worker):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribeUserToPush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> navigator.serviceWorker.register(<span class="string">'service-worker.js'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> subscribeOptions = &#123;</span><br><span class="line">      userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">      applicationServerKey: btoa(</span><br><span class="line">        <span class="string">'BEl62iUYgUivxIkv69yViEuiBIa-Ib9-SkvMeAtA3LFgDzkrxZJjSgSnfckjBJuBkr3qBUYIHBQFLXYp5Nksh8U'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> registration.pushManager.subscribe(subscribeOptions);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">pushSubscription</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'PushSubscription: '</span>, <span class="built_in">JSON</span>.stringify(pushSubscription));</span><br><span class="line">    <span class="keyword">return</span> pushSubscription;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registration.pushManager.subscribe(options) nhận một object options gồm 1 param bắt buộc và 1 param tùy chọn:</p><ul><li><strong>userVisibleOnly</strong>: một boolean chỉ định push subscription trả về sẽ chỉ được dùng cho message mà hiệu ứng của message đó user có thể nhìn thấy được. Nó phải được gán bằng true nếu không thì sẽ lỗi (Có cả 1 quá khứ lịch sử về nó).</li><li><strong>applicationServerKey</strong>: một DOMString hoặc ArrayBufffer chứa public key được mã hóa thành Base64 mà server push sẽ dùng để xác thực server của app.</li></ul><p>Server của bạn cần sinh ra một cặp server key cho app, chúng còn được biết đến là key VAPID duy nhất cho server. Đây là 1 cặp public-private key. Private key thì được giữ một cách bí mật ở phía bạn trong khi public key được trao đổi với client. Những key này cho phép push service biết app server nào đã đăng ký user và đảm bảo đó chính là server trigger các push message đến người dùng cụ thể.</p><p>Bạn chỉ cần tạo ra cặp private/public key 1 lần duy nhất cho ứng dụng. Có 1 cách làm nhanh đó là dùng trang này <a href="https://web-push-codelab.glitch.me/" target="_blank" rel="noopener">https://web-push-codelab.glitch.me/</a></p><p>Trình duyệt truyền applicationServerKey (public key) lên một push server khi đăng ký user, nghĩa là push server có thể liên kết public key của app bạn với PushSubscription của user.</p><p>Đây là những gì diễn ra:</p><ul><li>Webapp của bạn được load xong và bạn gọi subscribe(), truyền server key vào.</li><li>Trình duyệt tạo 1 request lên mạng đến một push service để sinh ra một endpoint, sau đó liên kết endpoint này với key và trả về cho trình duyệt.</li><li>Trình duyệt sẽ thêm endpoint này vào trong object PushSubscription, chính là object được trả về từ subscribe() promise.</li></ul><p>Về sau, cứ mỗi khi bạn muốn gửi 1 push message, bạn chỉ cần tạo một <strong>Authorization header</strong> có chưa thông tin đã ký (signed) với private key từ server ứng dụng của bạn. Khi push service nhận request để gửi một push message, nó sẽ xác minh header bằng cách tìm public key đã liên kết với endpoint cụ thể đó (ở bước thứ 2)</p><h1 id="Object-PushSubscription"><a href="#Object-PushSubscription" class="headerlink" title="Object PushSubscription"></a>Object PushSubscription</h1><p>Một PushSubscription chứa những thông tin cần thiết để gửi push message đến thiết bị của user:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"endpoint"</span>: <span class="string">"https://domain.pushservice.com/some-id"</span>,</span><br><span class="line">  <span class="string">"keys"</span>: &#123;</span><br><span class="line">    <span class="string">"p256dh"</span>:</span><br><span class="line"><span class="string">"BIPUL12DLfytvTajnryr3PJdAgXS3HGMlLqndGcJGabyhHheJYlNGCeXl1dn18gSJ1WArAPIxr4gK0_dQds4yiI="</span>,</span><br><span class="line">    <span class="string">"auth"</span>:<span class="string">"FPssMOQPmLmXWmdSTdbKVw=="</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>endpoint ở đây là URL của push service. Để trigger một push mesage ta cần tạo request POST đến URL này.<br>Object keys chứa giá trị dùng để mã hóa dữ liệu thông tin được gửi đi với push message.<br>Một khi user đã được đăng ký và bạn có PushSubscription thì bạn cần gửi nó về cho server. Tại đây (trên server) bạn sẽ lưu thông tin tham gia của user vào database và kể từ bây giờ sẽ dùng nó để gửi push message về cho user đó.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*hTMGxzZrOmxxIfaQU7nKig.png" alt=""></p><h1 id="Gui-push-message"><a href="#Gui-push-message" class="headerlink" title="Gửi push message"></a>Gửi push message</h1><p>Khi bạn cần gửi một push message cho nhiều user, điều đầu tiên bạn cần là push service. Bạn đang chỉ bảo cho push service (thông qua API) dữ liệu để gửi, gửi đến ai và các tình huống về việc làm thế nào để gửi message. Thông thường, lời gọi API này sẽ được thực hiện trên server.</p><h1 id="Push-Services"><a href="#Push-Services" class="headerlink" title="Push Services"></a>Push Services</h1><p>Push service là thứ dùng để nhận các request, xác nhận chúng và chuyển giao push message cho trình duyệt phù hợp.</p><p>Lưu ý rằng bạn không quản lý push service, nó là 1 dịch vụ của bên thứ 3. Server của bạn giao tiếp với push service thông qua API. Một ví dụ về push service chính là <a href="https://firebase.google.com/docs/cloud-messaging/" target="_blank" rel="noopener">Google’s FCM</a></p><p>Push service xử lý tất cả những việc nặng nhọc. Ví dụ: Nếu như trình duyệt đang offline, push service sẽ xếp message vào hàng đợi và chờ cho đến khi trình duyệt online lại trước khi gửi message đi 1 cách tuần tự.</p><p>Mỗi tình duyệt có thể dùng bất kỳ push service nào và điều này vượt ngoài khả năng kiểm soát của developer.</p><p>Tuy nhiên tất cả các push service có chung API nên việc này không làm cho quá trình triển khai trở nên khó khăn.</p><p>Để lấy được URL xử lý các request cho push message, bạn cần phải kiểm tra giá trị của endpoint trong object PushSubscription.</p><h1 id="Push-Service-API"><a href="#Push-Service-API" class="headerlink" title="Push Service API"></a>Push Service API</h1><p>Push Service API cung cấp 1 cách để gửi message đến cho user. API là 1 <a href="https://tools.ietf.org/html/draft-ietf-webpush-protocol-12" target="_blank" rel="noopener">Web Push Protocol</a> theo tiêu chuẩn IETF định nghĩa cách ta gọi API đến một push service</p><p>Dữ liệu bạn gửi với push message phải được mã hóa. Bằng cách này, bạn ngăn chặn push service đọc dữ liệu gửi đi. Điều này rất quan trọng vì trình duyệt chính là người quyết định nên dùng push service nào (có thể đó là push service không đáng tin cậy và bảo mật kém)</p><p>Với mỗi push message, bạn có thể đưa ra hướng dẫn như sau:</p><ul><li><strong>TTL</strong>: định nghĩa một message nên chờ bao lâu trong hàng đợi trước khi nó bị gỡ ra và không được chuyển đi.</li><li><strong>Mức độ ưu tiên (priority)</strong>: định nghĩa mức độ ưu tiên của mỗi message, cách này giúp cho push service chỉ gửi những thông tin có mức độ ưu tiên cao, ví dụ trong trường hợp pin thiết bị của người dùng sắp cạn.</li><li><strong>Chủ đề (topic)</strong>: cung cấp cho push message một tên chủ đề sẽ thay thế message đang chờ xử lý (pending) có cùng chủ đề để khi thiết bị đang hoạt động, user sẽ không nhận thông tin cũ, lỗi thời.</li></ul><p><img src="https://cdn-images-1.medium.com/max/1000/1*PgclyCPqxWc1rENfAOesag.png" alt=""></p><h1 id="Su-kien-Push-tren-trinh-duyet"><a href="#Su-kien-Push-tren-trinh-duyet" class="headerlink" title="Sự kiện Push trên trình duyệt"></a>Sự kiện Push trên trình duyệt</h1><p>Một khi bạn gửi message đến push service như giải thích ở trên, message sẽ chuyển sang trạng thái chờ (pending) cho đến khi 1 trong số những điều sau đây xảy ra:</p><ul><li>Thiết bị online</li><li>Message hết hạn trên hàng đợi do TTL.</li></ul><p>Khi push service truyền một message, trình duyệt sẽ nhận nó, giải mã và điều phối một sự kiện push trong Service Worker của bạn.</p><p>Điều tuyệt vời là trình duyệt thực thi code Service Worker của bạn thậm chí cả khi web page chưa mở lên:</p><ul><li>Push message được gửi tới trình duyệt và được giải mã.</li><li>Trình duyệt đánh thức Service Worker</li><li>Một sự kiện push được phân phối đến Service Worker</li></ul><p>Code để cài đặt một listener cho push even cũng khá tương đồng với các loại event listener khác trong Javascript:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.data) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'This push event has data: '</span>, event.data.text());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'This push event has no data.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Một điều cần phải hiểu về Service Worker là bạn có ít quyền kiểm soát về thời gian chạy của code Service Worker. Trình duyệt quyết định khi nào thì đánh thức nó dậy và khi nào thì hủy nó.</p><p>Trong Service Worker, event.waitUntil(promise) cho trình duyệt biết công việc vẫn đang thực hiện cho tới khi promise được giải quyết xong và trình duyệt sẽ không hủy service worker nếu nó cần quá trình đó hoàn thành.</p><p>Dưới đây là 1 ví dụ về xử lý sự kiện push:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = self.registration.showNotification(<span class="string">'Push notification!'</span>);</span><br><span class="line"></span><br><span class="line">  event.waitUntil(promise);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Gọi self.registration.showNotification() hiển thị một thông báo đến user và nó trả về promise, promise này được resolve khi thông báo đã được hiển thị lên.</p><p>Phương thức showNotification(title, options) có thể được chỉnh sửa để phù hợp với nhu cầu. Param title là 1 string, còn options là object như dưới đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"//"</span>: <span class="string">"Visual Options"</span>,</span><br><span class="line">  <span class="string">"body"</span>: <span class="string">"&lt;String&gt;"</span>,</span><br><span class="line">  <span class="string">"icon"</span>: <span class="string">"&lt;URL String&gt;"</span>,</span><br><span class="line">  <span class="string">"image"</span>: <span class="string">"&lt;URL String&gt;"</span>,</span><br><span class="line">  <span class="string">"badge"</span>: <span class="string">"&lt;URL String&gt;"</span>,</span><br><span class="line">  <span class="string">"vibrate"</span>: <span class="string">"&lt;Array of Integers&gt;"</span>,</span><br><span class="line">  <span class="string">"sound"</span>: <span class="string">"&lt;URL String&gt;"</span>,</span><br><span class="line">  <span class="string">"dir"</span>: <span class="string">"&lt;String of 'auto' | 'ltr' | 'rtl'&gt;"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">"//"</span>: <span class="string">"Behavioural Options"</span>,</span><br><span class="line">  <span class="string">"tag"</span>: <span class="string">"&lt;String&gt;"</span>,</span><br><span class="line">  <span class="string">"data"</span>: <span class="string">"&lt;Anything&gt;"</span>,</span><br><span class="line">  <span class="string">"requireInteraction"</span>: <span class="string">"&lt;boolean&gt;"</span>,</span><br><span class="line">  <span class="string">"renotify"</span>: <span class="string">"&lt;Boolean&gt;"</span>,</span><br><span class="line">  <span class="string">"silent"</span>: <span class="string">"&lt;Boolean&gt;"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">"//"</span>: <span class="string">"Both Visual &amp; Behavioural Options"</span>,</span><br><span class="line">  <span class="string">"actions"</span>: <span class="string">"&lt;Array of Strings&gt;"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">"//"</span>: <span class="string">"Information Option. No visual affect."</span>,</span><br><span class="line">  <span class="string">"timestamp"</span>: <span class="string">"&lt;Long&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bạn có thể tìm hiểu chi tiết về mỗi options ở đây: <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification</a></p><p>Push Notification là một cách tuyệt vời để thu thập sự chú ý của user những khi có thông tin gấp, quan trọng hoặc cần thời điểm nhạy cảm mà bạn muốn chia sẻ với họ.</p><p>Team SessionStack thực hiện push notifications để báo cho user biết khi có crash, vấn đề hoặc điều gì đó bất thường trong sản phẩm của họ. Việc này giúp cho user biết ngay lập tức nếu có gì không đúng đang xảy ra. Sau đó họ có thể replay lại issue đó dưới dạng video và xem mọi thứ diễn ra với người dùng cuối của họ bằng cách tận dụng dữ liệu được thu thập với thư viện của SessionStack, chẳng hạn như thay đổi trên DOM, tương tác người dùng, request mạng, biệt lệ không được xử lý và các thông báo lỗi.</p><p>Tính năng này không chỉ sẽ giúp user sử dụng SessionStack hiểu và tái hiện lại bất kỳ vấn đề nào mà nó còn cho phép họ nhận được thông báo ngay khi nó xuất hiện.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 9 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Hôm nay chúng ta sẽ chuyển hướng sự chú ý qua &lt;strong&gt;web push notifications&lt;/strong&gt; (tạm dịch: thông báo đẩy trên trang web): chúng ta sẽ tìm hiểu về thành phần của nó, khám phá các quy trình gửi/nhận thông báo phía sau và cuối bài sẽ cùng tìm hiểu làm sao SessionStack sử dụng chúng để xây dựng chức năng của sản phẩm.&lt;/p&gt;
&lt;p&gt;Push Notifications rất phổ biến trong thế giới của điện thoại. Vì lý do này hay lý do khác, chúng bước chân vào thế giới web lại khá muộn mặc dù nó là tính năng rất được các developer ưa chuộng và đề xuất.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P8: Service Workers, vòng đời và các trường hợp sử dụng</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P8-Service-Workers-vong-doi-va-cac-truong-hop-su-dung.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P8-Service-Workers-vong-doi-va-cac-truong-hop-su-dung.html</id>
    <published>2018-11-24T15:04:00.000Z</published>
    <updated>2018-11-24T15:16:23.564Z</updated>
    
    <content type="html"><![CDATA[<p>Bạn có lẽ đã biết rằng <a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener">Progressive Web Apps</a> chỉ có thể phổ biến hơn khi chúng hướng tới trải nghiệm người dùng (UX) mượt mà hơn, giống như là tạo 1 native app hơn là một trải nghiệm mang phong cách trình duyệt.</p><p>Một trong số những yêu cầu khi xây dựng PWA là làm nó cực kỳ đáng tin cậy ở khoản loading: nó có thể chạy kể cả trong tình trạng internet không ổn định hoặc rớt mạng.</p><p>Trong bài này, chúng ta sẽ đào sâu vào Service Workers: cách chúng hoạt động và chúng ta nên quan tâm đến đâu. Cuối bài, team tác giả có một số lợi ích độc đáo của Service Workers mà chúng ta nên dùng đồng thời chia sẻ kinh nghiệm của họ tại <a href="https://www.sessionstack.com/" target="_blank" rel="noopener">SessionStack</a>.<br><a id="more"></a></p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Nếu bạn muốn hiểu rõ mọi thứ về Service Workers, bạn cần phải bắt đầu với bài viết trước về <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-7---Thanh-phan-cua-WebWorker---5-truong-hop-su-dung" target="_blank" rel="noopener">Web Workers</a>.</p><p>Về cơ bản, Service Worker chỉ là 1 loại của Web Worker và cụ thể hơn là nó giống như 1 <a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" target="_blank" rel="noopener">Shared Worker</a>:</p><ul><li>Service Worker chạy trong global context của chính nó</li><li>Nó không thể gắn kết với 1 trang cụ thể</li><li>Không thể truy cập vào DOM</li></ul><p>Một trong những lý do tại sao Service Worker API rất tuyệt vời là chúng cho phép webapp hỗ trợ trải nghiệm khi offline, cho phép developer hoàn toàn điều khiển luồng sử dụng.</p><h1 id="Vong-doi-cua-Service-Worker"><a href="#Vong-doi-cua-Service-Worker" class="headerlink" title="Vòng đời của Service Worker"></a>Vòng đời của Service Worker</h1><p>Vòng đời của một service worker là hoàn toàn tách biệt với web page. Nó bao gồm các giai đoạn sau:</p><ul><li>Tải về (Download)</li><li>Cài đặt (Installation)</li><li>Kích hoạt (Activation)</li></ul><h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p>Đây là khi trình duyệt tải file .js chứa Service Worker</p><h2 id="Cai-dat"><a href="#Cai-dat" class="headerlink" title="Cài đặt"></a>Cài đặt</h2><p>Để cài đặt một Service Worker cho webapp của bạn thì bạn cần phải đăng ký nó trước trong code Javascript. Khi Service Worker đã đăng ký xong, nó sẽ nhắc nhở tình duyệt khởi động một bước cài đặt chạy nền Service Worker.</p><p>Bằng cách đăng ký Service Worker, bạn đã thông báo cho trình duyệt file Javascript của worker nằm ở đâu. Cùng xem ví dụ bên dưới:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/sw.js'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Đăng ký thành công</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration successful'</span>);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Đăng ký thất bại</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration failed: '</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Code sẽ kiểm tra nếu môi trường hiện tại có support Service Worker hay không. Nếu như có thì file /sw.js sẽ được đăng ký.</p><p>Bạn có thể gọi phương thức register() mỗi khi một trang load lên mà không phải lo lắng gì, trình duyệt sẽ sẽ tự kiểm tra nếu service worker đã được đăng ký hay chưa và tự xử lý một cách phù hợp.</p><p>Một điểm quan trọng ở phương thức register() là vị trí của file service worker. Trong trường hợp này bạn có thể thấy rằng file service worker đang ở root của domain. Nghĩa là phạm vi (scope) của service worker sẽ bao hàm toàn bộ origin. Nói cách khác, service worker này sẽ nhận các sự kiện fetch (mà chúng ta sẽ thảo luận sau) cho mọi thứ trên domain này. Nếu ta đăng ký file service worker ở /example/sw.js thì service worker chỉ có thể thấy các sự kiện fetch cho trang có URL bắt đầu với /example/ (ví dụ: /example/page/1, /example/page/2)</p><p>Trong giai đoạn cài đặt, tốt nhất ta nên load và cache những tài nguyên dạng tĩnh (static asset). Một khi các tài nguyên đã được cache thành công thì quá trình cài đặt Service Worker cũng hoàn thành. Nếu không (load fail), Service Worker sẽ thử lại (retry). Một khi đã thành công, bạn sẽ biết các static asset đang nằm trong cache.</p><p>Bạn sẽ tự hỏi nếu như quá tình đăng ký diễn ra sau sự kiện load thì được không. Điều này không bắt buộc, nhưng đó là cách tốt nhất và được đề nghị làm theo.</p><p>Tại sao? Giả sử một user lần đầu tiên ghé thăm webapp của bạn. Không có service worker nào cả và trình duyệt không có cách nào để biết trước có hay không một service worker cần được cài đặt. Nếu như Service Worker đã được cài đặt, trình duyệt sẽ dành ra 1 lượng CPU và bộ nhớ cho tiến trình đó, ngược lại thì trình duyệt sẽ dành toàn bộ cho quá trình render web page.</p><p>Điểm mấu chốt là nếu bạn chỉ cài đặt Service Worker trên trang của bạn thì bạn đang mạo hiểm về độ delay của quá trình loading &amp; render chứ không phải đang làm cho trang có thể sẵn sàng cho người dùng một cách nhanh nhất có thể.</p><p>Lưu ý rằng điều này chỉ quan trọng cho lần đầu tiên ghé thăm trang. Những lần ghé thăm sau thì không bị ảnh hưởng với quá trình cài đặt Service Worker. Một khi Service Worker đã được kích hoạt trong lần đầu ghé thăm trang, nó có thể xử lý các sự kiện loading/caching cho những lần ghé thăm kế tiếp. Điều này rất có ý nghĩa bởi vì nó cần phải sẵn sàng để xử lý trường hợp kết nối mạng bị hạn chế.</p><h2 id="Kich-hoat"><a href="#Kich-hoat" class="headerlink" title="Kích hoạt"></a>Kích hoạt</h2><p>Sau khi Service Worker cài đặt, bước tiếp theo là kích hoạt nó. Bước này là cơ hội tuyệt vời để quản lý cache trước đó.</p><p>Một khi đã kích hoạt, Service Worker sẽ bắt đầu kiểm soát toàn trang nằm trong phạm vi của nó. Một sự thật rất thú vị: page nào đăng ký Service Worker lần đầu tiên sẽ không bị điều khiển cho đến khi nó load lại. Một khi Service Worker kiểm soát, nó sẽ có những trạng thái sau:</p><ul><li>Nó sẽ xử lý các sự kiện fetch &amp; message diễn ra khi một request mạng hoặc message được tạo ra từ page.</li><li>Nó sẽ bị hủy bỏ để giải phóng bộ nhớ.</li></ul><p>Dưới đây là vòng đời của nó:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*mVOrpKC9pFTMg4EXPozoog.png" alt=""></p><h1 id="Xu-ly-qua-trinh-cai-dat-ben-trong-Service-Worker"><a href="#Xu-ly-qua-trinh-cai-dat-ben-trong-Service-Worker" class="headerlink" title="Xử lý quá trình cài đặt bên trong Service Worker"></a>Xử lý quá trình cài đặt bên trong Service Worker</h1><p>Sau khi page xoay vòng quá trình đăng ký, ta cùng tìm hiểu điều gì diễn ra bên trong script của Service Worker, code này xử lý sự kiện cài đặt bằng cách thêm một event listener vào instance của Service Worker.</p><p>Đây là những bước cần thiết khi xử lý sự kiện cài đặt</p><ul><li>Mở cache</li><li>Cache các file</li><li>Xác nhận tất cả các asset cần thiết đều đã được cache.</li></ul><p>Dưới đây là quá trình cài đặt đơn giản bên trong Service Worker:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CACHE_NAME = <span class="string">'my-web-app-cache'</span>;</span><br><span class="line"><span class="keyword">var</span> urlsToCache = [</span><br><span class="line">  <span class="string">'/'</span>,</span><br><span class="line">  <span class="string">'/styles/main.css'</span>,</span><br><span class="line">  <span class="string">'/scripts/app.js'</span>,</span><br><span class="line">  <span class="string">'/scripts/lib.js'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// event.waitUntil nhận một promise để biết quá trình</span></span><br><span class="line">  <span class="comment">// cài đặt mất bao lâu và có thành công hay không.</span></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(CACHE_NAME)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Opened cache'</span>);</span><br><span class="line">        <span class="keyword">return</span> cache.addAll(urlsToCache);</span><br><span class="line">      &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Nếu tất cả các file đều đã được lưu cache thành công thì service worker sẽ được cài đặt. Nếu một file nào đó không download được thì bước cài đặt sẽ bị fail. Vì thế hãy cẩn thận với những file bạn truyền vào.</p><p>Xử lý sự kiện cài đặt hoàn toàn không bắt buộc và bạn có thể bỏ qua, trong trường hợp đó bạn không cần phải thực hiện thêm bước nào nữa.</p><h1 id="Cache-request-trong-qua-trinh-thuc-thi-runtime"><a href="#Cache-request-trong-qua-trinh-thuc-thi-runtime" class="headerlink" title="Cache request trong quá trình thực thi (runtime)"></a>Cache request trong quá trình thực thi (runtime)</h1><p>Phần này thực sự thú vị một cách xuất sắc. Đây là nơi bạn sẽ biết làm thế nào để can thiệp request và trả về cache đã được tạo (và tạo mới).</p><p>Sau khi Service Worker cài đặt xong và user điều hướng đến page khác hoặc refresh lại page hiện tại, Service Worker sẽ nhận được sự kiện fetch. Đây là một ví dụ thể hiện làm thế nào để trả về những asset đã cache hoặc thực hiện một request mới và cache kết quả:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    <span class="comment">// Phương thức này xem xét request và tìm xem có</span></span><br><span class="line">    <span class="comment">// kết quả nào đã được cache từ tất cả các cache</span></span><br><span class="line">    <span class="comment">// mà Service Worker đã tạo.</span></span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Nếu tìm thấy cache thì trả về response.</span></span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Nhân bản request. Một request là 1 stream và chỉ có thể sử dụng 1 lần. </span></span><br><span class="line">        <span class="comment">// Bởi vì chúng ta đang xài 1 cái cho cache và 1 cái cho trình duyệt để fetch,</span></span><br><span class="line">        <span class="comment">// nến ta cần phải nhân bản request.</span></span><br><span class="line">        <span class="keyword">var</span> fetchRequest = event.request.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache không tìm thấy nên ta cần thực hiện fetch</span></span><br><span class="line">        <span class="comment">// để tạo request tới mạng và trả về dữ liệu nếu tìm thấy</span></span><br><span class="line">        <span class="comment">// thứ gì đó.</span></span><br><span class="line">        <span class="keyword">return</span> fetch(fetchRequest).then(</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// Kiểm tra nếu ta nhận được response hợp lệ.</span></span><br><span class="line">            <span class="keyword">if</span>(!response || response.status !== <span class="number">200</span> || response.type !== <span class="string">'basic'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Nhân bản response bởi vì nó cũng không phải là 1 stream.</span></span><br><span class="line">            <span class="comment">// Bởi vì chúng ta muốn trình duyệt sử dụng response cũng như</span></span><br><span class="line">            <span class="comment">// cache sử dụng response, ta cần nhân bản nó thành 2 stream.</span></span><br><span class="line">            <span class="keyword">var</span> responseToCache = response.clone();</span><br><span class="line"></span><br><span class="line">            caches.open(CACHE_NAME)</span><br><span class="line">              .then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// Thêm request vào cache phục vụ sau này</span></span><br><span class="line">                cache.put(event.request, responseToCache);</span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Tóm gọn lại thì đây là những điều đã diễn ra:</p><ul><li>event.respondWith() sẽ xác định làm thế nào chúng ta phản hồi với sự kiện fetch. Ta truyền một promise từ caches.match(), hàm đang kiểm tra request và tìm kiếm nếu có bất kỳ kết quả đã được cache sẵn nào từ những cache đã được tạo trước đó.</li><li>Nếu có cache, response được lấy ra.</li><li>Ngược lại, fetch được thực thi.</li><li>Kiểm tra nếu trạng thái là 200. Chúng ta sẽ kiểm tra kiểu response là cơ bản, nghĩa là nó sẽ chỉ ra request từ origin của chúng ta. Request đến các asset của bên thứ 3 không thể cache được trong trường hợp này.</li><li>Response được thêm vào cache.</li></ul><p>Request và response phải được nhân bản (clone) vì chúng là <a href="https://streams.spec.whatwg.org/" target="_blank" rel="noopener">stream</a>. Thân (body) của một stream chỉ có thể sử dụng 1 lần. Và khi ta cần dùng nó, ta phải nhân bản nó bởi vì trình duyệt cũng cần sử dụng nó nữa.</p><h1 id="Cap-nhat-Service-Worker"><a href="#Cap-nhat-Service-Worker" class="headerlink" title="Cập nhật Service Worker"></a>Cập nhật Service Worker</h1><p>Khi một user ghé thăm webapp của bạn, trình duyệt sẽ thử download lại file .js chứa code Service Worker. Tác vụ này sẽ được chạy nền.</p><p>Nếu có một chút khác biệt dù chỉ một byte giữa file Service Worker mới download về và file cũ thì trình duyệt cũng sẽ giả định rằng có sự thay đổi và Service Worker mới phải khởi tạo lại.</p><p>Service Worker mới sẽ bắt đầu khởi tạo và cài đặt. Tuy nhiên vào thời điểm này, Service Worker cũ vẫn đang kiểm soát page trên webapp của bạn, nghĩa là Service Worker mới sẽ nằm trong trạng thái chờ đợi.</p><p>Một khi trang đang mở được đóng lại, Service Worker cũ sẽ bị hủy bởi trình duyệt và Service Worker mới cài đặt sẽ chiếm quyền kiểm soát toàn bộ. Đây là khi sự kiện kích hoạt của nó được kích hoạt.</p><p>Tại sao lại cần phải làm tất cả điều này? Là để tránh vấn đề khi có 2 phiên bản webapp chạy đồng thời trong các tab khác nhau. Việc này diễn ra một cách rất phổ biến và có thể tạo ra những lỗi tồi tệ (ví dụ: bạn có schema khác nhau trong khi lưu trữ dữ liệu local trên trình duyệt).</p><h1 id="Xoa-du-lieu-trong-cache"><a href="#Xoa-du-lieu-trong-cache" class="headerlink" title="Xóa dữ liệu trong cache"></a>Xóa dữ liệu trong cache</h1><p>Bước phổ biến nhất trong callback kích hoạt là quản lý cache. Bạn sẽ cần phải làm điều này ngay bởi vì nếu bạn dọn dẹp cache cũ trong bước cài đặt, Service Worker cũ sẽ dừng lại một cách đột ngột và không thể phân phối các file từ cache đó nữa.</p><p>Dưới đây là ví dụ cách bạn có thể xóa vài file không nằm trong danh sách an toàn trong cache (trong trương hợp này là có chữ page-1 và page-2 trong tên của nó)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">'page-1'</span>, <span class="string">'page-2'</span>];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="comment">// Lấy tất cả key từ cache.</span></span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">cacheNames</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">        <span class="comment">// Lặp qua mảng các file.</span></span><br><span class="line">        cacheNames.map(<span class="function"><span class="keyword">function</span>(<span class="params">cacheName</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// Nếu file trong cache không nằm trong danh sách an toàn</span></span><br><span class="line">          <span class="comment">// thì nó sẽ bị xóa.</span></span><br><span class="line">          <span class="keyword">if</span> (cacheWhitelist.indexOf(cacheName) === <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Yeu-cau-HTTPS"><a href="#Yeu-cau-HTTPS" class="headerlink" title="Yêu cầu HTTPS"></a>Yêu cầu HTTPS</h1><p>Khi xây dựng webapp, bạn có thể sử dụng Service Worker qua localhost nhưng một khi đã deploy nó lên production, bạn cần chuẩn bị HTTPS (và đó cũng là lý do cuối cùng bạn cần đến HTTPS).</p><p>Sử dụng Service Worker, bạn có thể chiếm quyền kết nối và ngụy tạo response. Nếu không dùng HTTPS, webapp của bạn trở thành đối tượng của cách tấn công <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener">kẻ-trung-gian</a> (man-in-the-middle).</p><p>Để an toàn hơn, bạn cần phải đăng ký Service Worker với page được phân phối qua HTTPS để bạn biết được Service Worker nào trình duyệt nhận về mà không bị thay đổi khi lưu thông qua mạng.</p><h1 id="Cac-trinh-duyet-ho-tro"><a href="#Cac-trinh-duyet-ho-tro" class="headerlink" title="Các trình duyệt hỗ trợ"></a>Các trình duyệt hỗ trợ</h1><p>Sự hỗ trợ cho Service Worker ngày càng được cải thiện:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*6o2TRDmrJlS97vh1wEjLYw.png" alt=""></p><p>Bạn có thể theo dõi tiến độ cho tất cả các trình duyệt tại đây: <a href="https://jakearchibald.github.io/isserviceworkerready/" target="_blank" rel="noopener">https://jakearchibald.github.io/isserviceworkerready/</a></p><h1 id="Service-Workers-mo-ra-chan-troi-moi"><a href="#Service-Workers-mo-ra-chan-troi-moi" class="headerlink" title="Service Workers mở ra chân trời mới"></a>Service Workers mở ra chân trời mới</h1><p>Một số tính năng độc đáo mà Service Worker cung cấp:</p><ul><li><strong>Push notifications </strong>: cho phép user tham gia vào lắng nghe cập nhật theo thời gian</li><li><strong>Đồng bộ dưới nền (background sync)</strong>: cho phép bạn tạm hoãn các hành động cho tới khi user có kết nối ổn định. Bằng cách này bạn có thể đảm bảo rằng bất kỳ thứ gì mà user cần gửi thì chắc chắn nó sẽ được gửi đi.</li><li><strong>Đồng bộ định kỳ (periodic sync - tương lai)</strong>: API cung cấp khả năng quản lý đồng bộ dưới nền theo chu kỳ.</li><li><strong>Ranh giới ảo (Geofencing - tương lai)</strong>: bạn có thể định nghĩa params, còn gọi là những geofence bao quanh một khu vực. Webapp sẽ nhận thông báo khi có một thiết bị vượt qua geofence, điều này cho phép bạn cung cấp trả nghiệm có ích dựa trên vị trí địa lý của user.</li></ul><p>Mỗi mục này sẽ được thảo luận chi tiết hơn trong các bài viết khác.</p><p>Team tác giả đang nỗ lực không ngừng để mang lại trải nghiệm UX mượt mà nhất có thể cho SessionStack, tối ưu hóa thời gian tải trang và thời gian phản hồi.</p><p>Khi bạn replay lại 1 session của user trên <a href="https://www.sessionstack.com/" target="_blank" rel="noopener">SessionStack</a> (hoặc xem nó trong thời gian thực), phần SessionStack front-end sẽ không ngừng lấy dữ liệu từ server về để tạo ra một trải nghiệm liền mạch như lưu trong buffer. Một khi bạn đã tích hợp thư viện của SessionStack vào trong webapp, nó sẽ bắt đầu thu thập dữ liệu liên tục về thay đổi trên DOM, tương tác người dùng, request mạng, biệt lệ không được xử lý và thông báo lỗi.</p><p>Khi một phiên làm việc được replay hoặc stream theo thời gian thực thì SessionStack phục vụ tất cả dữ liệu cho phép bạn thấy mọi thứ về trải nghiệm người dùng ở góc độ trình duyệt của user (cả về mặt kỹ thuật lẫn hình ảnh). Những công việc này cần phải được thực hiện cực nhanh để không làm cho user phải chờ đợi.</p><p>Bởi vì dữ liệu được front-end kéo về nên đây là một sàn diễn tuyệt vời cho Service Worker có thể “tỏa sáng” mà xử lý những trường hợp như reload player và stream mọi thứ thêm vài lần nữa. Xử lý kết nối mạng bị chậm cũng cực kỳ quan trọng.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Bạn có lẽ đã biết rằng &lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Progressive Web Apps&lt;/a&gt; chỉ có thể phổ biến hơn khi chúng hướng tới trải nghiệm người dùng (UX) mượt mà hơn, giống như là tạo 1 native app hơn là một trải nghiệm mang phong cách trình duyệt.&lt;/p&gt;
&lt;p&gt;Một trong số những yêu cầu khi xây dựng PWA là làm nó cực kỳ đáng tin cậy ở khoản loading: nó có thể chạy kể cả trong tình trạng internet không ổn định hoặc rớt mạng.&lt;/p&gt;
&lt;p&gt;Trong bài này, chúng ta sẽ đào sâu vào Service Workers: cách chúng hoạt động và chúng ta nên quan tâm đến đâu. Cuối bài, team tác giả có một số lợi ích độc đáo của Service Workers mà chúng ta nên dùng đồng thời chia sẻ kinh nghiệm của họ tại &lt;a href=&quot;https://www.sessionstack.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SessionStack&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P7: Thành phần của WebWorker + 5 trường hợp sử dụng</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P7-Thanh-phan-cua-WebWorker-5-truong-hop-su-dung.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P7-Thanh-phan-cua-WebWorker-5-truong-hop-su-dung.html</id>
    <published>2018-11-16T00:27:00.000Z</published>
    <updated>2018-11-16T00:30:02.825Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 7 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Trong bài này chúng ta sẽ tìm hiểu về Web Workers: một cái nhìn tổng quan, thảo luận về các loại worker khách nhau, các thành phần của nó hoạt động với nhau như thế nào và những điểm mạnh cũng như điểm yếu của nó trong các ngữ cảnh khác nhau. Cuối cùng, team tác giả sẽ cung cấp 5 trường hợp mà trong đó Web Worker là sự lựa chọn đúng đắn.</p><p>Bạn đã quen với sự thật rằng Javascript chạy đơn luồng như chúng ta đã <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-1---Khai-quat-ve-engine--runtime-va-callstack" target="_blank" rel="noopener">thảo luận chi tiết ở bài trước</a>. JS cũng giúp các developer viết code bất đồng bộ.<br><a id="more"></a></p><h1 id="Nhung-han-che-cua-lap-trinh-bat-dong-bo"><a href="#Nhung-han-che-cua-lap-trinh-bat-dong-bo" class="headerlink" title="Những hạn chế của lập trình bất đồng bộ"></a>Những hạn chế của lập trình bất đồng bộ</h1><p>Chúng ta đã thảo luận ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-4---Event-loop--lap-trinh-bat-dong-bo---5-meo-cai-thien-Async-Await" target="_blank" rel="noopener">bài trước</a> về lập trình bất đồng bộ và khi nào thì nên dùng.</p><p>Lập trình bất đồng bộ cho phép UI của app trở nên mượt mà, bằng cách “lên lịch” cho từng phần của code được thực thi ở thời gian phù hợp trong event loop, do đó nó cho phép render UI được thực hiện trước.</p><p>Một trường hợp tốt để dùng lập trình bất đồng bộ là khi ta gọi Ajax request. Bởi vì request có thể tốn nhiều thời gian nên có thể để cho nó chạy bất đồng bộ và trong khi client chờ kết quả trả về, những code khác vẫn được thực thi.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Giả sử bạn dùng jQuery</span></span><br><span class="line">jQuery.ajax(&#123;</span><br><span class="line">    url: <span class="string">'https://api.example.com/endpoint'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// code được thực thi khi response trả về</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Nhưng điều này lại gây ra vấn đề khác: request được xử lý bởi Web API của trình duyệt, nhưng làm thế nào mà code khác có thể chạy bất đồng bộ? Ví dụ nếu như code bên trong một success callback lại chạy ngốn rất nhiều CPU:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = performCPUIntensiveCalculation();</span><br></pre></td></tr></table></figure><p>Nếu như performCPUIntensiveCalculation không phải là một request HTTP nhưng lại block code xử lý (ví dụ: 1 vòng lặp rất lớn), không có cách nào để giải phóng event loop và unblock cho UI trình duyệt, nó sẽ đóng băng và không phản hồi lại với user.</p><p>Nghĩa là trong Javascript, những hàm bất đồng bộ chỉ giải quyết vấn đề nhỏ của hạn chế ở đơn luồng.</p><p>Trong những trường hợp đó, bạn có thể làm cho unblock UI khỏi quá trình tính toán quá lâu bằng cách sử dụng setTimeout. Ví dụ, tách một chuỗi xử lý tính toán phức tạp vào trong nhiều lời gọi setTimeout, bằng cách đó bạn có thể đặt chúng vào những “vị trí” khác nhau trong event loop và cách này có thể giúp cho render UI được tốt hơn.</p><p>Cùng xem một ví dụ đơn giản về tính toán số trung bình của 1 mảng số nguyên:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = numbers.length,</span><br><span class="line">        sum = <span class="number">0</span>,</span><br><span class="line">        i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        sum += numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum / len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dưới đây là cách ta viết lại code trên và “giả lập” trường hợp bất đồng bộ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">averageAsync</span>(<span class="params">numbers, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = numbers.length,</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calculateSumAsync</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="comment">// Đưa hàm tiếp theo vào event loop</span></span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                sum += numbers[i];</span><br><span class="line">                calculateSumAsync(i + <span class="number">1</span>);</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// hết mảng, gọi callback</span></span><br><span class="line">            callback(sum / len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    calculateSumAsync(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cách này sẽ dùng setTimeout để thêm mỗi bước thực hiện tính toán vào trong event loop. Giữa mỗi lần tính toán sẽ có đủ thời gian cho các tính toán được thêm vào và giải phóng trình duyệt khỏi bị đóng băng.</p><h1 id="Web-Workers-den-giai-cuu"><a href="#Web-Workers-den-giai-cuu" class="headerlink" title="Web Workers đến giải cứu"></a>Web Workers đến giải cứu</h1><p>HTML5 mang đến cho chúng ta rất nhiều thứ tuyệt vời:</p><ul><li>SSE (đã thảo luận và so sánh với WebSocket ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-5---Dao-sau-WebSocket---HTTP-2-voi-SSE---Hay-chon-gia-dung" target="_blank" rel="noopener">bài trước</a>)</li><li>Geolocation</li><li>Application cache</li><li>Local Storage</li><li>Drag and Drop</li><li><strong>Web Workers</strong></li></ul><p>Web Workers là tiến trình trong trình duyệt nhưng có thể được dùng để thực thi Javascript code mà không cản trở event loop</p><p>Điều này thực sự kỳ diệu. Toàn bộ mô hình của Javascript dựa trên ý tưởng về môi trường đơn luồng nhưng giờ đây là có Web Workers và nó gỡ bỏ (1 phần nào) sự hạn chế đó.</p><p>Web Workers cho phép developer đặt những công việc có thời gian chạy dài và những công việc nặng về xử lý tính toán trong background mà không gây trở ngại đến UI, làm app của bạn mượt mà hơn. Ngoài ra, không cần phải xài trick với setTimeout để đánh lừa event loop nữa.</p><p><a href="http://afshinm.github.io/50k/" target="_blank" rel="noopener">Ở đây</a> có một demo mẫu thể hiện sự khác nhau khi thực hiện sắp xếp mảng dùng và không dùng Web Workers.</p><h1 id="Khai-quat-ve-Web-Workers"><a href="#Khai-quat-ve-Web-Workers" class="headerlink" title="Khái quát về Web Workers"></a>Khái quát về Web Workers</h1><p>Web Workers cho phép bạn làm những việc như thực thi các đoạn code xử lý tốn thời gian để tính toán các phép tính hao tổn nheiefu CPU nhưng không làm cản trở UI. Thực ra, nó sẽ chạy song song. Web Workers là đa luồng.</p><p>Bạn sẽ thắc mắc: “Chứ không phải Javascript là ngôn ngữ đơn luồng à?”</p><p>Đây là lúc mà bạn sẽ thốt lên <em>aha</em> ngạc nhiên khi nhận ra Javascript là một ngôn ngữ không định nghĩa mô hình tiến trình. <strong>Web Workers không phải là một phần của Javascript, nó là tính năng của trình duyệt mà có thể truy xuất thông qua Javascript</strong>. Đa số các trình duyệt có lịch sử về đơn tiến trình (giờ thì thay đổi rồi), và đa số các triển khai của Javascript đều diễn ra trên trình duyệt. Web Workers không được triển khai trên Node.js, nó có khái niệm hơi khác một chút về cluster hay child_process.</p><p>Có 3 loại Web Workers được đề cập đến trong <a href="http://www.whatwg.org/specs/web-workers/current-work/" target="_blank" rel="noopener">thông số kỹ thuật</a>:</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">Dedicated Workers</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" target="_blank" rel="noopener">Shared Workers</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker_API" target="_blank" rel="noopener">Service workers</a></li></ul><h1 id="Dedicated-Workers-Worker-chuyen-dung"><a href="#Dedicated-Workers-Worker-chuyen-dung" class="headerlink" title="Dedicated Workers (Worker chuyên dụng)"></a>Dedicated Workers (Worker chuyên dụng)</h1><p>Dedicated Web Workers được khởi tạo bởi tiến trình chính và chỉ có thể giao tiếp với tiến trình đó.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*ya4zMDfbNUflXhzKz9EBIw.png" alt=""></p><h1 id="Shared-Workers-Worker-chia-se"><a href="#Shared-Workers-Worker-chia-se" class="headerlink" title="Shared Workers (Worker chia sẻ)"></a>Shared Workers (Worker chia sẻ)</h1><p>Shared Workers có thể được truy cập bởi tất cả các tiến trình chạy trên cùng origin (khác tab trình duyệt, iframe hoặc là các shared worker khác)</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*lzOIevUBVy5eWyf2kHf--w.png" alt=""></p><p>Nếu bạn muốn dùng thử SessionStack để hiểu và khám phá lại những vấn đề kỹ thuật cũng như UX trên webapp của bạn, team SessionStack đang có bản dùng thử miễn phí, <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=Post-5-websockets-getStarted" target="_blank" rel="noopener">ở đây nhé</a>.</p><h1 id="Service-Workers-Worker-dich-vu"><a href="#Service-Workers-Worker-dich-vu" class="headerlink" title="Service Workers (Worker dịch vụ)"></a>Service Workers (Worker dịch vụ)</h1><p>Một Service Worker là worker hướng sự kiện (event-driven) được đăng ký với origin và path. Nó có thể điều khiển web page/site mà nó liên kết, can thiệp và chỉnh sửa sự điều hướng và các yêu cầu tài nguyên, lưu đệm tài nguyên với phong cách rất chi tiết để cho phép bạn có toàn quyền điều khiển về việc app của bạn xử lý như thế nào trong từng trường hợp cụ thể (ví dụ như khi rớt mạng)</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*6o2TRDmrJlS97vh1wEjLYw.png" alt=""></p><p>Trong bài này chúng ta sẽ tập trung vào <strong>Dedicated Worker</strong> và chỉ gọi nó dưới cái tên <strong>Web Workers</strong> hoặc <strong>Worker</strong></p><h1 id="Web-Workers-hoat-dong-nhu-the-nao"><a href="#Web-Workers-hoat-dong-nhu-the-nao" class="headerlink" title="Web Workers hoạt động như thế nào?"></a>Web Workers hoạt động như thế nào?</h1><p>Web Workers được triển khai dưới dạng đuôi .js và được đính kèm theo request HTTP bất đồng bộ trong web của bạn. Những request này được ẩn hoàn toàn bởi <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener">Web Worker API</a></p><p>Workers sử dụng message kiểu tiến trình để thực hiện quá trình hoạt động song song. Chúng có thể giữ cho UI được cập nhật mới nhất, có thể tương tác và mượt mà với người dùng một cách hoàn hảo.</p><p>Web Workers chạy trong một tiến trình cô lập trong trình duyệt. <strong>Do đó là code chúng thực thi cần phải đặt trong 1 file riêng biệt</strong>. Điều này rất quan trọng nhé.</p><p>Cách tạo worker cơ bản</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'task.js'</span>);</span><br></pre></td></tr></table></figure><p>Nếu task.js tồn tại và có thể truy cập được, trình duyệt sẽ thiết lập một tiến trình mới để tải file bất đồng bộ. Sau khi quá trình tải file hoàn tất, nó sẽ thực thi code trong đó và worker bắt đầu làm việc.</p><p>Trong trường hợp file lỗi không load được thì trả về 404 và worker sẽ dừng lại một cách yên lặng như chưa có gì xảy ra.</p><p>Để bắt đầu tạo worker, bạn cần gọi phương thức postMessage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage();</span><br></pre></td></tr></table></figure><h1 id="Giao-tiep-cua-Web-Worker"><a href="#Giao-tiep-cua-Web-Worker" class="headerlink" title="Giao tiếp của Web Worker"></a>Giao tiếp của Web Worker</h1><p>Để giao tiếp giữa một Web Worker và trang của bạn thì bạn cần phải sử dụng phương thức postMessage hoặc <a href="https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel" target="_blank" rel="noopener">kênh phát sóng</a> (Broadcast channel).</p><h1 id="Phuong-thuc-postMessage"><a href="#Phuong-thuc-postMessage" class="headerlink" title="Phương thức postMessage"></a>Phương thức postMessage</h1><p>Các trình duyệt mới hỗ trợ object JSON như là param đầu tiên của phương thức trong khi các trình duyệt cũ hơn thì chọn string</p><p>Dưới đây là ví dụ về một page có worker có thể giao tiếp qua lại với nó như thế nào bằng cách truyền một object JSON. Truyền string cũng tương tự:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"startComputation()"</span>&gt;Start computation&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  function startComputation() &#123;</span></span><br><span class="line"><span class="regexp">    worker.postMessage(&#123;'cmd': 'average', 'data': [1, 2, 3, 4]&#125;);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  var worker = new Worker('doWork.js');</span></span><br><span class="line"><span class="regexp">  worker.addEventListener('message', function(e) &#123;</span></span><br><span class="line"><span class="regexp">    console.log(e.data);</span></span><br><span class="line"><span class="regexp">  &#125;, false);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>Và đoạn code của worker:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = e.data;</span><br><span class="line">  <span class="keyword">switch</span> (data.cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'average'</span>:</span><br><span class="line">      <span class="keyword">var</span> result = calculateAverage(data); <span class="comment">// Tính trung bình cộng từ một array</span></span><br><span class="line">      self.postMessage(result);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      self.postMessage(<span class="string">'Unknown command'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>Khi click vào button, trang chính sẽ gọi tới postMessage. Dòng worker.postMessage truyền một object JSON vào worker, object chứa thông tin là cmd và data. Worker sẽ xử lý message thông qua một message handler đã được định nghĩa.</p><p>Khi message đến, các thao tác tính toán thực sự sẽ được thực hiện trong worker mà không cản trở event loop. Worker kiểm tra event e được truyền vào và thực thi giống như một hàm Javascript bình thường. Khi xong việc kết quả sẽ được trả ngược lại cho trang chính.</p><p>Trong ngữ cảnh của worker, cả self và this đều đang tham chiếu đến global scope.</p><blockquote><p>Có 2 cách để dừng worker: gọi hàm worker.terminate() từ ngoài trang chính hoặc gọi self.close() bên trong worker.</p></blockquote><h1 id="Kenh-phat-song-Broadcast-Channel"><a href="#Kenh-phat-song-Broadcast-Channel" class="headerlink" title="Kênh phát sóng (Broadcast Channel)"></a>Kênh phát sóng (Broadcast Channel)</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel" target="_blank" rel="noopener">Broadcast Channel</a> giống như một API giao tiếp tổng quát. Nó cho phép chúng ta broadcast message tới tất cả các ngữ cảnh cùng chia sẻ chung origin. Tất cả các tab trình duyệt, iframe hoặc worker phục vụ chung origin có thể phát và nhận message.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kết nối đến một broadcast channel</span></span><br><span class="line"><span class="keyword">var</span> bc = <span class="keyword">new</span> BroadcastChannel(<span class="string">'test_channel'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ví dụ gửi một message đơn giản</span></span><br><span class="line">bc.postMessage(<span class="string">'This is a test message.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ví dụ về một event handler có chức</span></span><br><span class="line"><span class="comment">// năng in message ra console</span></span><br><span class="line">bc.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(e.data); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ngắt kết nối</span></span><br><span class="line">bc.close()</span><br></pre></td></tr></table></figure><p>Xem hình minh họa thì bạn sẽ hiểu cách hoạt động của Broadcast Channel rõ ràng hơn:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*NVT6WbNrH_mQL64--b-l1Q.png" alt=""></p><p>Broadcast Channel bị hạn chế hỗ trợ từ các trình duyệt:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*81mCsOzyJj-HfQ1lP_033w.png" alt=""></p><h1 id="Kich-thuoc-message"><a href="#Kich-thuoc-message" class="headerlink" title="Kích thước message"></a>Kích thước message</h1><p>Có 2 cách để gửi message trong Web Workers:</p><ul><li><p><strong>Sao chép message</strong>: message được serialized, sao chép, gửi đi và được de-serialized ở đầu kia. Trang web và worker không dùng chung instance, vì thế cuối cùng là kết quả sẽ bị trùng lặp ở cả 2 phía. Đa số các trình duyệt triển khai tính năng này bằng cách encoding/decoding giá trị ở cả 2 phía thành JSON một cách tự động. Đúng như dự đoán thì các hoạt động dữ liệu như thế này bổ sung thêm chi phí đáng kể vào việc truyền tải message. Message càng lớn thì thời gian gửi càng lâu.</p></li><li><p><strong>Truyền tải message</strong>: điều này nghĩa là bên gửi sẽ không thể sử dụng nó một khi đã gửi đi. Truyền tải dữ liệu gần như tức thời. Hạn chế là chỉ duy nhất <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a> là có thể gửi được.</p></li></ul><h1 id="Tinh-nang-co-san-cua-Web-Workers"><a href="#Tinh-nang-co-san-cua-Web-Workers" class="headerlink" title="Tính năng có sẵn của Web Workers"></a>Tính năng có sẵn của Web Workers</h1><p>Web Workder chỉ có truy xuất tới một tập hợp nhỏ các tính năng của Javascript bởi vì bản chất đa luồng của nó, dưới đây là danh sách các tính năng:</p><ul><li>Object navigator</li><li>Object location (chỉ đọc - read only)</li><li>XMLHttpRequest</li><li>setTimeout()/clearTimeout() và setInterval()/clearInterval()</li><li>Bộ đệm ứng dụng (<a href="https://www.html5rocks.com/tutorials/appcache/beginner/" target="_blank" rel="noopener">Application Cache</a>)</li><li>Import script bên ngoài thông qua importScripts()</li><li><a href="https://www.html5rocks.com/en/tutorials/workers/basics/#toc-enviornment-subworkers" target="_blank" rel="noopener">Tạo các web worker khác</a></li></ul><h1 id="Han-che-cua-Web-Workers"><a href="#Han-che-cua-Web-Workers" class="headerlink" title="Hạn chế của Web Workers"></a>Hạn chế của Web Workers</h1><p>Hơi buồn là Web Worker không có quyền truy cập đến một số tính năng quan trọng của Javascript:</p><ul><li>DOM (not thread-safe)</li><li>Object window</li><li>Object document</li><li>Object parent</li></ul><p>Điều này nghĩa là Web Worker không thể thay đổi DOM (và UI). Nó có thể hơi khó khăn, nhưng nếu bạn đã quen với viêc sử dụng Web Worker đúng cách thì bạn sẽ bắt đầu sử dụng khả năng “tính toán độc lập” của nó trong khi các code thay đổi UI đang được xử lý và hoạt động. Worker sẽ chăm sóc tất cả những phần nặng nhọc cho bạn và khi đã xong viêc thì bạn chỉ cần gửi kết quả ra màn hình để cập nhật UI cho phù hợp.</p><h1 id="Xu-ly-loi"><a href="#Xu-ly-loi" class="headerlink" title="Xử lý lỗi"></a>Xử lý lỗi</h1><p>Giống như code Javascript khác, bạn sẽ cần xử lý lỗi khi Web Worker bắn ra. Nếu có lỗi xảy ra trong quá trình worker thực thi, ErrorEvent sẽ được bắn. Interface này sẽ bao gồm 3 thuộc tính hữu ích cho việc tìm ra bạn đang sai chỗ nào:</p><ul><li><strong>filename</strong>: tên của worker script gây ra lỗi</li><li><strong>lineno</strong>: số của dòng gây ra lỗi</li><li><strong>message</strong>: mô tả lỗi</li></ul><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Line: '</span> + e.lineno);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'In: '</span> + e.filename);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Message: '</span> + e.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'workerWithError.js'</span>);</span><br><span class="line">worker.addEventListener(<span class="string">'error'</span>, onError, <span class="literal">false</span>);</span><br><span class="line">worker.postMessage(); <span class="comment">// Khởi tạo worker mà không truyền messageself.addEventListener('message', function(e) &#123;</span></span><br><span class="line">  postMessage(x * <span class="number">2</span>); <span class="comment">// Intentional error. 'x' is not defined.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Ở đây bạn thấy rằng chúng ta tạo worker và bắt đầu listen sự kiện error.</p><p>Bên trong worker (file workerWithError.js) chúng ta cố tình tạo một exception bằng cách nhân x với 2 trong khi x không hề tồn tại trong scope đó. Exception được bắn ra khi khởi tạo script và hàm onError được gọi với thông tin về lỗi.</p><h1 id="Truong-hop-nen-su-dung-Web-Workers"><a href="#Truong-hop-nen-su-dung-Web-Workers" class="headerlink" title="Trường hợp nên sử dụng Web Workers"></a>Trường hợp nên sử dụng Web Workers</h1><p>Cho đến bây giờ thì chúng ta đã nghiên cứu về điểm mạnh và hạn chế của Web Workers. Cùng xem những trường hơp nào thì dùng chúng là tốt nhất:</p><ul><li><strong>Dò tia (Ray tracing)</strong>: ray tracing là một kỹ thuật <a href="https://en.wikipedia.org/wiki/Rendering_%28computer_graphics%29" target="_blank" rel="noopener">render</a> để sinh ra những hình ảnh bằng cách dò theo vết đường đi của ánh sáng theo dạng pixel. Ray traycing sử dụng rất nhiều phép tính toán học có ảnh hướng lớn đến CPU để giả lập đường đi của ánh sáng. Ý tưởng về giả lập những hiệu ứng như phản chiếu (reflection), khúc xạ (refraction), vật liệu, vân vân. Tất cả các logic tính toán như vậy đều có thể đưa vào Web Worker để tránh gây trở ngại với UI thread. Thậm chí có thể tốt hơn nếu bạn có thể chia nhỏ quá trình render hình ảnh ra nhiều worker (và chia ra nhiều CPU). Đây là 1 minh họa đơn giản của ray tracing sử dụng Web Workers:  <a href="https://nerget.com/rayjs-mt/rayjs.html" target="_blank" rel="noopener">https://nerget.com/rayjs-mt/rayjs.html</a></li><li><strong>Mã hóa (Encryption)</strong>: Mã hóa end-to-end (E2EE) càng ngày càng phổ biến do sự gia tăng khắt khe về các quy định của dữ liệu nhạy cảm &amp; cá nhân. Mã hóa có thể khá tốn thời gian, đặc biệt nếu có rất nhiều dữ liệu cần được mã hóa thường xuyên (trước khi gửi về server chẳng hạn). Đây là một trường hợp trong đó Web Worker là lựa chọn rất tốt vì nó không yêu cầu truy xuất đến DOM hay các thứ khác, chỉ thuần túy là thuật toán mã hóa. Một khi đã được đẩy vào worker xử lý, nó sẽ hoạt động rất trơn tru và không ảnh hưởng đến trải nghiệm của người dùng.</li><li><strong>Tải trước dữ liệu</strong>: Để tối ưu website hoặc webapp và cải thiện thời gian loading, bạn có thể nhờ vả Web Workers để load và lưu dữ liệu trước và sử dụng chúng về sau khi cần đến. Web Workers rất tốt trong trường hợp này vì nó không ảnh hướng đến UI, không giống như khi ta dùng mà không có workers.</li><li><strong>Progressive Web Apps</strong>: Chúng cần được load thật nhanh kể cả khi kết nối mạng không ổn định. Nghĩa là dữ liệu cần phải được lưu trên trình duyệt. IndexDB hoặc những API tương tự hỗ trợ tốt khoản này. Về cơ bản thì lưu trữ ở phía client là cần thiết. Để có thể sử dụng mà không gây cản trở đến UI, công việc cần phải được hoàn thành trong Web Workers. Trong trường hợp của IndexDB, có một API bất đồng bộ cho phép bạn làm việc này mà không dùng workers, tuy nhiên cũng có một API đồng bộ trước đây (có thể sẽ được giới thiệu lại) chỉ được phép chạy bên trong workers.</li><li><strong>Kiểm tra chính tả (Spell checking)</strong>: một bộ spell checker cơ bản hoạt động như sau: chương trình sẽ đọc một file từ điển với danh sách các từ đúng chính tả. Từ điển sẽ được parse thành cây tìm kiếm (search tree) để có thể tìm kiếm văn bản hiệu quả. Khi một từ được đưa vào checker, chương trình sẽ kiểm tra nếu nó tồn tại trong cây tìm kiếm. Nếu từ đó không tồn tại, chương trình sẽ cung cấp từ thay thế bằng cách thay đổi ký tự thay thế và kiểm tra nếu đó là 1 từ hợp lệ nếu nó là từ mà user muốn viết ra. Tất cả quá trình này có thể dễ dàng giảm tải cho hệ thống bằng Web Workers và user có thể gõ chữ, viết câu mà không gây cản trở với UI trong khi worker thực thi tất cả các phần tìm kiếm và đưa ra đề xuất.</li></ul><p>Hiệu năng và độ tin cậy là rất quan trọng đối với team SessionStack. Lý do là vì một khi đã tích hợp SessionStack vào web app của bạn, chương trình sẽ bắt đầu ghi lại mọi thứ từ thay đổi trên DOM và tương tác người dùng đến các request mạng, exception không được xử lý và các thông báo lỗi. Tất cả dữ liệu được truyền về cho server của chương trình trong <strong>thời gian thực</strong> để có thể cho phép bạn chạy lại những issue từ webapp dưới dạng video và xem thử điều gì đang diễn ra với user. Tất cả điều này được thực hiện với độ trễ tối thiểu và không có ảnh hưởng đến hiệu năng của app của bạn.</p><p>Đây là lý do mà team tác giả đã đưa toàn bộ logic (phần nào có thể) từ cả thư viện điều hành &amp; phần player vào Web Worker để xử lý các công viêc nặng tải với CPU như băm để xác nhận tính toàn vẹn dữ liệu, render, vân vân.</p><p>Công nghệ web liên tục thay đổi và phát triển vì thế team tác giả đã đi thêm 1 chặng đường dài để đảm bảo SessionStack thật nhẹ và không gây ảnh hưởng đến hiệu năng của người dùng.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 7 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Trong bài này chúng ta sẽ tìm hiểu về Web Workers: một cái nhìn tổng quan, thảo luận về các loại worker khách nhau, các thành phần của nó hoạt động với nhau như thế nào và những điểm mạnh cũng như điểm yếu của nó trong các ngữ cảnh khác nhau. Cuối cùng, team tác giả sẽ cung cấp 5 trường hợp mà trong đó Web Worker là sự lựa chọn đúng đắn.&lt;/p&gt;
&lt;p&gt;Bạn đã quen với sự thật rằng Javascript chạy đơn luồng như chúng ta đã &lt;a href=&quot;https://kipalog.com/posts/Duc-khoet-Javascript--Phan-1---Khai-quat-ve-engine--runtime-va-callstack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;thảo luận chi tiết ở bài trước&lt;/a&gt;. JS cũng giúp các developer viết code bất đồng bộ.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P6: So sánh với WebAssembly + Một số trường hợp tốt hơn nên sử dụng</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P6-So-sanh-voi-WebAssembly-Mot-so-truong-hop-tot-hon-nen-su-dung.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P6-So-sanh-voi-WebAssembly-Mot-so-truong-hop-tot-hon-nen-su-dung.html</id>
    <published>2018-11-16T00:19:00.000Z</published>
    <updated>2018-11-16T00:21:12.978Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 6 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Lần này chúng ta sẽ khám phá về WebAssembly và phân tích cách hoạt động của nó, quan trọng hơn là những điểm vượt trội hơn so với Javascript về mặt hiệu năng: thời gian tải, tốc độ thực thi, dọn rác (GC), sử dụng bộ nhớ, truy cập API, debugging, đa luồng và tính di động (portability).</p><p>Cách chúng ta xây dựng web app trên bờ vực cách mạng - vẫn đang trong những ngày đầu nhưng cách chúng ta suy nghĩ về web app đang dần thay đổi.<br><a id="more"></a></p><h1 id="Cung-xem-WebAssembly-co-the-lam-gi"><a href="#Cung-xem-WebAssembly-co-the-lam-gi" class="headerlink" title="Cùng xem WebAssembly có thể làm gì"></a>Cùng xem WebAssembly có thể làm gì</h1><p>WebAssembly (gọi tắt <strong>wasm</strong>) là một loại bytecode cấp độ thấp và hiệu quả cho web.</p><p>WASM cho phép bạn sử dụng ngôn ngữ khác Javascript (như C, C++, Rust…), viết chương trình với những ngôn ngữ đó, và biên dịch trước (ahead of time) sang WebAssembly.</p><p>Kết quả là webapp sẽ load và thực thi rất nhanh.</p><h1 id="Thoi-gian-tai-loading-time"><a href="#Thoi-gian-tai-loading-time" class="headerlink" title="Thời gian tải (loading time)"></a>Thời gian tải (loading time)</h1><p>Để load Javascript, trình duyệt phải load tất cả file .js đúng nguyên văn bản.</p><p>WebAssembly load nhanh hơn trong trình duyệt bởi vì chỉ có những file wasm <strong>đã được biên dịch</strong> là được truyền tải qua internet. Và bởi vì wasm là ngôn ngữ bậc thấp gần giống assembly có format nhị phân rất nhỏ gọn.</p><h1 id="Thuc-thi-execution"><a href="#Thuc-thi-execution" class="headerlink" title="Thực thi (execution)"></a>Thực thi (execution)</h1><p>Wasm chạy chậm hơn 20% <strong>so với native code</strong>. Dù gì đi nữa thì đây là một kết quả đáng kinh ngạc. Nó là một định dạng được biên dịch sang môi trường sandbox và chạy cùng rất nhiều ràng buộc để đảm bảo nó không có những điểm yếu bảo mật hoặc rất khó để chống lại. Tốc độ chậm là không đáng kể khi so với native code. Hơn nữa, nó sẽ được cải thiện chạy nhanh hơn trong tương lai.</p><p>Ngoài ra, khả năng tương thích rất tốt với trình duyệt là điểm mạnh, tất cả những engine lớn đều có hỗ trợ WebAssembly và đều đưa ra thời gian thực thi tương đương nhau.</p><p>Để hiểu WebAssembly thực thi nhanh như thế nào so với Javascript, bạn nên <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-2---Ben-trong-engine-V8---5-meo-de-toi-uu-hoa-code" target="_blank" rel="noopener">đọc bài trước trong series Đục khoét Javascript</a></p><p>Cùng xem điều gì xảy ra trong V8:<br><img src="https://cdn-images-1.medium.com/max/1000/0*bN9YVBLw_tT1Xvte." alt=""></p><p>Cách tiếp cận của V8: biên dịch chậm</p><p>Ở bên trái, chúng ta có Javascript source, bao gồm các hàm. Đầu tiên thì nó cần phải được parse (phân tích cú pháp) để chuyển tất cả string sang token và sinh ra <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">Abstract Syntax Tree</a> (AST - Cây cú pháp trừu tượng, chúng ta sẽ có một bài viết về nó sau). Cây AST là đại diện biểu thị logic của chương trình JS trong bộ nhớ. Một khi nó được sinh ra, V8 sẽ đi thẳng đến mã máy. Về cơ bản thì bạn sẽ duyệt qua cây đó, tạo ra mã máy và hàm của bạn đã được biên dịch. Không có tiến trình nào cố gắng tăng tốc nó.</p><p>Giờ thì lướt qua xem V8 pipeline làm gì tiếp theo:</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*wzuQ9LYv7CAUICOC." alt=""></p><p>Chúng ta có <a href="https://github.com/v8/v8/wiki/TurboFan" target="_blank" rel="noopener">TurboFan</a>, 1 trong những trình biên dịch tối ưu hóa của V8. Trong khi app Javascript đang chạy thì còn có rất nhiều code khác chạy trong V8. TurboFan thực hiện điều hành, nếu có gì chạy chậm bất kể là đang nghẽn cổ chai (bottleneck) hay những điểm nóng (hot spots), thì sẽ được tối ưu hóa. Nó đẩy phần code đang ngốn tài nguyên CPU đó qua một bộ <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener">JIT</a> tối ưu để tạo ra code nhanh hơn nhiều.</p><p>Nó giải quyết vấn đề, nhưng bên cạnh đó quá trình phân tích code và quyết định nên tối ưu như thế nào cũng làm tốn tài nguyên CPU. Điều này, làm hao tổn thời lượng pin nhiều hơn, đặc biệt là trên các thiết bị di động.</p><p>Chà, wasm thì không cần. Nó đi thẳng vào quá trình làm việc như dưới đây:</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*GDU4GguTzk8cSAYk." alt=""></p><p>Wasm đã duyệt qua quá trình tối ưu hóa ngay trong giai đoạn biên dịch. Trên hết thì parsing đã không còn cần thiết nữa. Bạn có mã nhị phân tối ưu có thể gắn trực tiếp vào bộ phận backend để sinh ra mã máy. Tất cả các sự tối ưu hóa đã được hoàn thành bởi trình biên dịch ở frontend.</p><p>Điều này làm cho quá trình thực thi wasm trở nên hiệu quả hơn rất nhiều bởi vì ta có thể bỏ qua 1 số bước trong khi xử lý.</p><h1 id="Mo-hinh-bo-nho"><a href="#Mo-hinh-bo-nho" class="headerlink" title="Mô hình bộ nhớ"></a>Mô hình bộ nhớ</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*QphcOVaiVC2YL7Jd." alt=""></p><p>Bộ nhớ của 1 chương trình C++ là chuỗi liền kề các block nhớ không có “lỗ”. Một trong số các tính năng của wasm giúp đẩy mạnh sự bảo mật là ý tưởng về stack thực thi đặt riêng biệt với bộ nhớ thẳng hàng (linear). Trong C++ ta có heap, cấp phát từ đáy của heap và phát triển stack ở đỉnh heap. Ta có thể lấy con trỏ và tìm kiếm trong bộ nhớ stack để chơi đùa với những biến mà chúng ta còn không đụng tới.</p><p>Đây là một điểm cạm bẫy mà rất nhiều malware khai thác.</p><p>WebAssembly sử dụng một mô hình hoàn toàn khác. Stack thực thi tách biệt với chương trình chính WebAssembly nên không có cách nào bạn có thể chỉnh sửa và thay đổi những biến bên trong nó. Thêm nữa là các hàm có offset là số nguyên chứ ko dùng contror. Hàm trỏ vào một bảng chức năng vô hướng. Sau đó, các con số được tính toán trực tiếp này được đưa vào bên trong module. Nó được xây dựng theo cách này để có thể load nhiều wasm cùng lần, đánh offset tất cả các index và nó sẽ chạy tốt.</p><p>Để tìm hiểu sâu hơn về mô hình bộ nhớ và các cách quản lý trong Javascript, bạn có thể <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-3---Quan-ly-bo-nho---4-truong-hop-ro-ri-pho-bien" target="_blank" rel="noopener">xem lại bài trước</a>.</p><h1 id="Don-rac-GC"><a href="#Don-rac-GC" class="headerlink" title="Dọn rác (GC)"></a>Dọn rác (GC)</h1><p>Chúng ta đã biết quản lý bộ nhớ của Javascript có bao gồm cả xử lý dọn rác Garbage Collector.</p><p>Đối với WebAssembly thì hơi khác một chút. Nó hỗ trợ những ngôn ngữ quản lý bộ nhớ thủ công. Bạn có thể sử dụng GC của chính bạn với các wasm module, nhưng công việc đó hơi phức tạp.</p><p>Hiện tại, WebAssembly được thiết kế xoay quanh các trường hợp sử dụng của C++ và RUST. Bởi vì wasm là ngôn ngữ thấp nên sẽ dễ hiểu hơn nếu sử dụng những ngôn ngữ lập trình gần gũi &amp; dễ biên dịch ra ngôn ngữ assembly. C có thể sử dụng malloc thường, C++ có thể dùng con trỏ thông minh. Rust dùng một mô hình khác hoàn toàn (nhưng là 1 chủ đề khác nhé). Những ngôn ngữ này không dùng GC, do đó chúng không cần các tác vụ runtime để theo dõi bộ nhớ. WebAssembly phù hợp với chúng.</p><p>Thêm nữa, những ngôn ngữ này không phải được thiết kế 100% cho việc truy vấn những thứ phức tạp thuộc về Javascript, ví dụ như thay đổi DOM. Nó khá vô nghĩa khi phải viết toàn bộ app HTML trên nền C++ bởi vì C++ không được thiết kế với mục đích làm webapp. Đa số các trường hợp các kỹ sư dùng C++ hoặc Rust, họ hướng tới WebGL hoặc những thư viện có tính tối ưu hóa cao. (Ví dụ: phép tính toán học khó và phức tạp)</p><p>Tuy nhiên, trong tương lai WebAssembly sẽ hỗ trợ những ngôn ngữ có sẵn GC.</p><h1 id="Truy-xuat-Platform-API"><a href="#Truy-xuat-Platform-API" class="headerlink" title="Truy xuất Platform API"></a>Truy xuất Platform API</h1><p>Tùy thuộc vào môi trường runtime thực thi Javascript, quyền truy xuất vào những API đang tồn tại đặc trưng cho platform có thể được truy cập trực tiếp thông qua app JS của bạn. Ví dụ: bạn chạy JS code trên trình duyệt, bạn có 1 cục các Web API mà webapp có thể gọi và điều khiển trình duyệt hoặc chức năng thiết bị và có quyền truy xuất vào DOM, CSSOM, WebGL, IndexedDB, Web Audio API, vân vân.</p><p>WebAssembly module không có quyền truy cập vào platform API. Mọi thứ đều trung gian qua Javascript. Nếu bạn muốn truy xuất vào một số API đặc trưng cho platform bên trong module WebAssembly thì bạn phải gọi nó thông qua Javascript.</p><p>Ví dụ, nếu muốn dùng console.log, bạn gọi nó thông qua JS thay vì C++. Và dĩ nhiên là sẽ có những hạn chế về JS mà ta phải chấp nhận.</p><p>Nhưng trường hợp này sẽ sớm được khắc phục khi mà đặc điểm kỹ thuật sẽ cung cấp các platform API cho wasm trong tương lai, bạn sẽ có thể sớm phát triển app mà không cần Javascript.</p><h1 id="Anh-xa-ma-nguon-Source-map"><a href="#Anh-xa-ma-nguon-Source-map" class="headerlink" title="Ánh xạ mã nguồn (Source map)"></a>Ánh xạ mã nguồn (Source map)</h1><p>Khi bạn làm tối giản code JS, bạn cần đảm bảo có thể debug nó. Đó là khi mà ta cần đến <a href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" target="_blank" rel="noopener">Source Map</a>.</p><p>Về cơ bản, Source Map là 1 cách để map một file tối giản về với trạng thái ban đầu của nó. Khi bạn build sản phẩm cho môi trường production, cùng với file JS đã kết hợp &amp; tối gian, bạn sẽ sinh ra 1 file source map chứa thông tin về file JS gốc. Khi bạn query một dòng cụ thể với số cột nào đó file JS, bạn có thể tra cứu trong source map để tìm ra vị trí gốc ban đầu của nó.</p><p>WebAssembly không hỗ trợ source map vì nó chưa có mô tả kỹ thuật cho phần này nhưng hi vọng là tương lai gần sẽ hỗ trợ.</p><p>Khi bạn đặt breakpoint trong code C++, bạn sẽ thấy code C++ thay vì WebAssembly, ít nhất là vẫn còn có ích.</p><h1 id="Da-luong-Multithreading"><a href="#Da-luong-Multithreading" class="headerlink" title="Đa luồng (Multithreading)"></a>Đa luồng (Multithreading)</h1><p>Ai cũng biết Javascript là đơn luồng. Có nhiều cách để cải thiện Event Loop và nâng cấp phần lập trình bất đồng bộ mà chúng tôi đã <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-4---Event-loop--lap-trinh-bat-dong-bo---5-meo-cai-thien-Async-Await" target="_blank" rel="noopener">giới thiệu trong bài trước</a>.</p><p>Javascript có thể dùng Web Workers nhưng nó rất hạn chế trường hợp. Về cơ bản, bất kỳ tính toán nào ảnh hưởng nặng đến CPU và block luồng xử UI đều có thể được đẩy ra load riêng với WebWorker. Tuy nhiên, WebWorker lại không truy xuất được vào DOM.</p><p>WebAssembly hiện tại không hỗ trợ đa luồng. Tuy nhiên, điều này chắc chắn sẽ được thay đổi. Wasm đang tiến gần tới những tiến trình native (ví dụ: luồng kiểu C++). Có những luồng “thực” sẽ tạo ra rất nhiều cơ hội mới trên trình duyệt. Và lẽ dĩ nhiên, nó cũng sẽ bị lạm dụng nhiều hơn.</p><h1 id="Tinh-di-dong-Portability"><a href="#Tinh-di-dong-Portability" class="headerlink" title="Tính di động (Portability)"></a>Tính di động (Portability)</h1><p>Ngày nay Javascript có thể chạy ở bất kỳ đâu, từ trình duyệt đến server, kể cả trong các hệ thống nhúng.</p><p>WebAssembly được thiết kế để an toàn và linh động. Như Javascript, nó chạy trên nhiều môi trường hỗ trợ wasm (ví dụ: mọi trình duyệt)</p><p>WebAssembly có cùng mục tiêu di động như cách mà Java đang cố thực hiện trong những ngày đầu với Applets.</p><h1 id="Khi-nao-thi-dung-WebAssembly-tot-hon-JavaScript"><a href="#Khi-nao-thi-dung-WebAssembly-tot-hon-JavaScript" class="headerlink" title="Khi nào thì dùng WebAssembly tốt hơn JavaScript?"></a>Khi nào thì dùng WebAssembly tốt hơn JavaScript?</h1><p>Trong các phiên bản đầu của WebAssembly, chức năng chính chỉ tập trung vào các phép tính nặng tải trên CPU (các bài toán phức tạp chẳng hạn). Ứng dụng chủ yếu nhất khi nghĩ đến là games - có cả hàng tấn pixel cần thao tác xử lý trên màn hình. Bạn có thể viết app bằng ngôn ngữ mà bạn quen thuộc như C++/Rust bằng OpenGL sao đó biên dịch sang wasm và nó sẽ chạy trên trình duyệt.</p><p>Bạn có thể xem ví dụ sau (tốt nhất là dùng Firefox): <a href="http://s3.amazonaws.com/mozilla-games/tmp/2017-02-21-SunTemple/SunTemple.html" target="_blank" rel="noopener">http://s3.amazonaws.com/mozilla-games/tmp/2017-02-21-SunTemple/SunTemple.html</a>. Nó chạy trên nền <a href="https://www.unrealengine.com/en-US/what-is-unreal-engine-4" target="_blank" rel="noopener">Unreal engine</a>.</p><p>Một trường hợp khác tiêu biểu cho viêc sử dụng WebAssembly (về mặt hiệu năng) là triển khai một số thư viện chạy các tác vụ nặng với CPU, ví dụ như xử lý ảnh.</p><p>Như đã nói ở trước, wasm có thể giảm khá nhiều lượng tiêu thụ pin trên các thiết bị di động (phụ thuộc vào engine), bởi vì đa số các bước xử lý đều đã được hoàn thành trước trong khi biên dịch.</p><p>Trong tương lai, bạn sẽ có thể sử dụng code WASM nhị phân kể cả khi bạn không thực sự viết code có thể biên dịch ra nó. Bạn có thể tìm vài projects trên NPM đang bắt đầu triển khai theo hướng này.</p><p>Với trường hợp thay đổi DOM và sử dụng nhiều platform API thì tốt nhất vẫn là dùng Javascript, bởi vì rõ ràng nó hỗ trợ tốt với các API đó.</p><p>Ở <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=Post-6-webassembly-outro" target="_blank" rel="noopener">SessionStack</a>, tác giả liên tục mở rộng biên giới hiệu năng của Javascript nhằm viết được nhiều code tối ưu và hiệu quả cao. Giải pháp của họ cần cung cấp hiệu năng nhanh chóng mặt vì không thể gây ảnh hưởng lên hiệu năng của app của khách hàng.</p><p>Một khi bạn đã tích hợp SessionStack vào web app của bạn, nó sẽ ghi lại mọi thứ diễn ra trên app/website: những thay đổi trên DOM, tương tác của người dùng, JS exception, stack trace, những request bị fail và cả thông báo debug, cho phép bạn chạy lại (replay) những issue đã xảy ra dưới dạng video và xem chúng diễn ra như thế nào với người dùng. Tất cả đều hoạt động theo thời gian thực (real-time) và không ảnh hưởng đến hiệu năng của webapp. SessionStack phải tối ưu hóa code một cách tối đa và làm cho quá trình này bất đồng bộ nhất có thể.</p><p>Không chỉ là một thư viện! Khi bạn chạy lại một session của người dùng trong SessionStack thì nó phải render lại toàn bộ những gì mà trình duyệt của user thực hiện tại thời điểm vấn đề xảy ra và team tác giả phải xây dựng lại toàn bộ trạng thái, cho phép bạn có thể nhảy tới nhảy lui trong timeline session. Để đạt được điều đó, team tác giả đã tận dụng tối đa khả năng bất đồng bộ mà Javascript cung cấp trong khi thiếu sót những giải pháp tốt hơn.</p><p>Với WebAssembly, team tác giả có thể đẩy những tiến trình xử lý và render nặng nhất vào một ngôn ngữ phù hợp hơn với công việc này và để phần thu thập dữ liệu, thay đổi DOM cho Javascript làm.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 6 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Lần này chúng ta sẽ khám phá về WebAssembly và phân tích cách hoạt động của nó, quan trọng hơn là những điểm vượt trội hơn so với Javascript về mặt hiệu năng: thời gian tải, tốc độ thực thi, dọn rác (GC), sử dụng bộ nhớ, truy cập API, debugging, đa luồng và tính di động (portability).&lt;/p&gt;
&lt;p&gt;Cách chúng ta xây dựng web app trên bờ vực cách mạng - vẫn đang trong những ngày đầu nhưng cách chúng ta suy nghĩ về web app đang dần thay đổi.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P5: Hiểu sâu về WebSocket &amp; HTTP/2 với SSE</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P5-Hieu-sau-ve-WebSocket-HTTP-2-voi-SSE.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P5-Hieu-sau-ve-WebSocket-HTTP-2-voi-SSE.html</id>
    <published>2018-11-16T00:04:00.000Z</published>
    <updated>2018-11-16T00:16:38.066Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 5 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Trong phần này chúng ta sẽ đào sâu với thế giới của những giao thức giao tiếp, ánh xạ (mapping) và thảo luận về những thuộc tính cũng như thành phần của chúng. Chúng ta sẽ đưa ra 1 so sánh nhỏ giữa WebSockets và HTTP/s. Cuối cùng, team SessionStack sẽ chia sẻ một vài ý tưởng về việc lựa chọn phương thức nào cho phù hợp với giao thức mạng.<br><a id="more"></a></p><h1 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu"></a>Giới thiệu</h1><p>Ngày nay những webapp phức tạp có nhiều tính năng, UI động xuất hiện như trăm hoa đua nở. Cũng không phải bất ngờ, internet cũng đã phát triển được một quãng đường khá dài kể từ khi bắt đầu.</p><p>Ban đầu, internet không được xây dựng để dành cho những app động và phức tạp. Nó được hình thành như là một tập hợp của các trang HTML, kết nối với nhau để cấu thành nên khái niệm về “Web” chứa thông tin. Phần lớn mọi thứ được xây dựng xung quanh mô hình request/response nổi tiếng của HTTP. Một client tải trang và không có gì xảy ra cho đến khi user bắt đầu click và di chuyển đến trang tiếp theo.</p><p>Khoảng năm 2005, AJAX được giới thiệu và rất nhiều người đã khám phá khả năng tạo kết nối giữa client và server theo 2 chiều (<strong>bidirectional</strong>). Và vẫn như thế, tất cả giao tiếp HTTP được chỉ đạo bởi client yêu cầu user tương tác hoặc thực hiện theo chu kỳ để lấy dữ liệu mới từ server.</p><h1 id="Tao-mot-HTTP-“2-chieu”"><a href="#Tao-mot-HTTP-“2-chieu”" class="headerlink" title="Tạo một HTTP “2 chiều”"></a>Tạo một HTTP “2 chiều”</h1><p>Công nghệ cho phép server gửi dữ liệu về client một cách “chủ động” đã phát triển được 1 thời gian. Push và Comet là ví dụ.</p><p>Một trong số mẹo nổi tiếng để tạo ra ảo giác rằng server đang gửi dữ liệu về client được gọi là long polling. Với long polling, client mở kết nối HTTP đến server và giữ nó tiếp tục mở cho đến khi có response trả về. Mỗi khi server có dữ liệu mới cần được gửi, nó chuyển giao thông tin dưới dạng một response.</p><p>Cùng xem một ví dụ đơn giản về long polling:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">poll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $.ajax(&#123; </span><br><span class="line">        url: <span class="string">'https://api.example.com/endpoint'</span>, </span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// Làm gì đó với `data`</span></span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// Cài đặt poll mới theo đệ quy</span></span><br><span class="line">          poll();</span><br><span class="line">        &#125;, </span><br><span class="line">        dataType: <span class="string">'json'</span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, <span class="number">10000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>Đây là một hàm tự thực thi cơ bản chạy một cách tự động lần đầu tiên. Nó sẽ cài đặt một khoảng thời gian 10 giây và sau mỗi lời gọi Ajax bất đồng bộ đến server, callback lại gọi ajax lần nữa.</p><p>Vài kỹ thuật khác có thể kể đến như <a href="http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/net/Socket.html" target="_blank" rel="noopener">Flash</a>, request nhiều thành phần XHR và <a href="http://cometdaily.com/2007/12/27/a-standards-based-approach-to-comet-communication-with-rest/" target="_blank" rel="noopener">htmlfiles</a> nổi tiếng.</p><p>Tất cả những phương pháp này đều có chung một vấn đề: Chúng qua mặt HTTP, làm cho chúng không phù hợp với những app có độ trễ thấp. Giả sử như game bắn súng nhiều người chơi trên trình duyệt hoặc bất kỳ game onlinen nào có đối thủ thực.</p><h1 id="Gioi-thieu-WebSockets"><a href="#Gioi-thieu-WebSockets" class="headerlink" title="Giới thiệu WebSockets"></a>Giới thiệu WebSockets</h1><p>Thông số kỹ thuật của WebSocket định nghĩa một kết nối API dạng “socket” (ổ cắm điện!) giữa trình duyệt và server. Theo nghĩa đen thì có 1 kết nối cố định giữa client và server và cả 2 bên có thể gửi dữ liệu bất kỳ lúc nào.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*a4lA5FYDkjA9mv53NPKtOg.png" alt=""></p><p>Client thiết lập một kết nối WebSocket thông qua một tiến trình được gọi là WebSocket handshake (bắt tay WebSocket). Tiến trình này bắt đầu với client gửi một request HTTP thông thường đến server. Nó kèm theo header Upgrade để thông báo cho server rằng client muốn tạo một kết nối WebSocket.</p><p>Cùng xem thử quá trình mở kết nối WebSocket như thế nào ở phía client:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new WebSocket with an encrypted connection.</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://websocket.example.com'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>WebSocket URL sử dụng ws scheme. Chúng ta còn có cả wss cho những kết nối WebSocket bảo mật hơn, tương tự như HTTPS.</p></blockquote><p>Scheme này bắt đầu một tiến trình mở kết nối WebSocket đến websocket.example.com.</p><p>Dưới đây là 1 ví dụ đơn giản của header của request khởi tạo.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET ws:<span class="comment">//websocket.example.com/ HTTP/1.1</span></span><br><span class="line">Origin: http:<span class="comment">//example.com</span></span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: websocket.example.com</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure><p>Nếu server hỗ trợ giao thức WebSocket, nó sẽ đồng ý để nâng cấp và giao tiếp thông qua header Upgrade trong response.</p><p>Cùng xem phần thiết lập của nó trong Node.js như thế nào:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chúng ta sẽ dùng https://github.com/theturtle32/WebSocket-Node</span></span><br><span class="line"><span class="comment">// Triển khai WebSocket</span></span><br><span class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'websocket'</span>).server;</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// xử lý HTTP request. </span></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tạo server</span></span><br><span class="line">wsServer = <span class="keyword">new</span> WebSocketServer(&#123;</span><br><span class="line">  httpServer: server</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// WebSocket server</span></span><br><span class="line">wsServer.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> connection = request.accept(<span class="literal">null</span>, request.origin);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Đây là callback quan trọng nhất,chúng ta sẽ </span></span><br><span class="line">  <span class="comment">// xử lý thông tin của client ở đây.</span></span><br><span class="line">  connection.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Xử lý thông tin WebSocket</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  connection.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">connection</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Đóng kết nối</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Sau khi thành lập kết nối, server trả về:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="built_in">Date</span>: Wed, <span class="number">25</span> Oct <span class="number">2017</span> <span class="number">10</span>:<span class="number">07</span>:<span class="number">34</span> GMT</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: WebSocket</span><br></pre></td></tr></table></figure><p>Khi kết nối đã được thiết lập, sự kiện open sẽ được bắn ra cho instance WebSocket ở phía client:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://websocket.example.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hiện thông báo khi kết nối WebSocket thành công.</span></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'WebSocket is connected.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Giờ thì quá trình “bắt tay” đã hoàn tất, kết nối khởi tạo HTTP được thay thế bằng WebSocket và sử dụng cùng loại nền tảng kết nối TCP/IP. Tại thời điểm này, cả 2 bên đều có thể gửi dữ liệu.</p><p>Với WebSocket, bạn có thể truyền bao nhiêu thông tin tùy thích mà không cần phải gánh chịu những chi phí không đáng có liên quan đến request HTTP truyền thống. Dữ liệu được truyền đi thông qua WebSocket dưới dạng tin nhắn (message), mỗi tin nhắn bao gồm một hoặc nhiều <em>frame</em> chứa dữ liệu bạn gửi đi (gọi là <em>kiện hàng</em> - <em>payload</em>). Để đảm bảo message có thể tái cấu trúc một cách chính xác khi nó đến với client, mỗi frame được gán cứng từ 4-12 byte thông tin về payload. Sử dụng hệ thống thông tin dựa trên frame như thế này giúp giảm tải khối lượng dữ liệu dư thừa (non-payload data) phải truyền đi, có thể làm cho độ trễ giảm đi đáng kể.</p><p><strong>Lưu ý</strong>: <em>Đặc biệt chú ý là client chỉ được thông báo về message mới một khi tất cả frame đều được nhận và payload message gốc được tái cấu trúc đầy đủ</em></p><h1 id="WebSocket-URLs"><a href="#WebSocket-URLs" class="headerlink" title="WebSocket URLs"></a>WebSocket URLs</h1><p>Chúng ta có đề cập sơ qua về WebSocket URL scheme ở trên. Trong thực thế, chúng giới thiệu có 2 scheme mới là ws:// và wss://</p><p>URL có cấu trúc ngữ pháp cụ thể về scheme. WebSocket URL đặc biệt vì nó không hỗ trợ nhóm ký tự anchor (có dấu thăng ở trước, ví dụ: #đây_là_anchor).</p><p>Có những luật chung được áp dụng cho cả style của WebSocket URL và HTTP URL. ws không được mã hóa, nó có cổng mặc định là 80 trong khi đó wss yêu cầu mã hóa TLS và dùng cổng 443 mặc định.</p><h1 id="Framing-protocol-Giao-thuc-framing"><a href="#Framing-protocol-Giao-thuc-framing" class="headerlink" title="Framing protocol (Giao thức framing)"></a>Framing protocol (Giao thức framing)</h1><p>Cùng đào sâu một chút về framing protocol với những gì <a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC</a> cung cấp:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                     <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (<span class="number">4</span>)  |A|     (<span class="number">7</span>)     |             (<span class="number">16</span>/<span class="number">64</span>)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (<span class="keyword">if</span> payload len==<span class="number">126</span>/<span class="number">127</span>)   |</span><br><span class="line">| |<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, <span class="keyword">if</span> payload len == <span class="number">127</span>  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, <span class="keyword">if</span> MASK set to <span class="number">1</span>  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>Theo như RFC định nghĩ về WebSocket thì nó chỉ có duy nhất một header trước mỗi gói tin, và nó khá phức tạp. Chúng ta cùng tìm hiểu:</p><ul><li>fin (1 bit): biểu thị nếu frame đó là frame cuối cùng tạo nên message. Hầu hết message đều có thể chứa trong một frame duy nhất và bit này luôn có giá trị. Thực nghiệm cho thấy Firefox tạo 1 frame thứ 2 sau mỗi 32K.</li><li>rsv1, rsv2, rsv3 (Mỗi thứ 1 bit): phải bằng 0 trừ khi có một <a href="https://tools.ietf.org/html/rfc6066" target="_blank" rel="noopener">extension</a> (đại khái như tiện ích mở rộng) được trao đổi và nó định nghĩa ý nghĩa cho giá trị khác 0. Nếu nhận về một giá trị khác 0 và không có extension nào xác định ý nghĩa của giá trị khác 0 đó được trao đổi thì người nhận cuối sẽ bị mất kết nối.</li><li>opcode (4 bit): nó cho biết những gì frame đại diện. Có những giá trị sau đây được dùng:<ul><li>0x00: frame này tiếp tục payload từ frame trước đó.</li><li>0x01: frame này chứa dữ liệu chữ (text).</li><li>0x02: frame này chứa dữ liệu nhị phân (binary).</li><li>0x08: frame này hủy kết nối.</li><li>0x09: frame này là ping.</li><li>0x0a: frame này là pong.</li></ul></li></ul><p>(Bạn có thể thấy rằng có nhiều giá trị không sử dụng, chúng được dự trữ cho tương lai khi cần)</p><ul><li>mask (1 bit): biểu thị nếu kết nối đã được che đậy (mask). Rõ ràng là mỗi message từ client đến server <em>phải được che đậy</em> và về mặt kỹ thuật thì nó sẽ hủy kết nối nếu không được che đậy.</li><li>payload_len (7 bit): độ dài của payload. WebSocket frame có những độ dài theo các khoảng tính theo byte như sau:<ul><li>0-125 biểu thị độ dài của payload</li><li>Nếu là 126 byte thì 2 byte tiếp theo biểu thị độ dài payload dưới dạng số nguyên 16bit không dấu</li><li>Nếu là 127 byte thì 8 byte tiếp theo biểu thị độ dài payload dưới dạng số nguyên 64bit không dấu</li><li>Vậy là độ dài payload sẽ vào khoảng ~7bit, 16bit hoặc 64bit.</li></ul></li><li>masking-key (32 bit): tất cả frame được gửi từ client đến server sẽ được che đậy (mask) bằng một giá trị 32bit đính kèm trong frame.</li><li>payload: Dữ liệu thật sự cần được che đậy. Độ dài của nó chính là payload_len</li></ul><p>Tại sao WebSocket lại dựa trên frame (frame-based) mà không dựa trên dòng chảy (stream-based)? Có trời mới biết, tác giả cũng không biết vì sao nên nếu bạn có thông tin gì về điều này thì có thể nhắn tin đến tác giả. Ngoài ra thì có <a href="https://news.ycombinator.com/item?id=3377406" target="_blank" rel="noopener">một topic thảo luận rất tốt về vấn đề này trên HackerNews</a>, bạn có thể tham khảo.</p><h1 id="Du-lieu-tren-frame"><a href="#Du-lieu-tren-frame" class="headerlink" title="Dữ liệu trên frame"></a>Dữ liệu trên frame</h1><p>Như đã nói ở trên, dữ liệu có thể phân mảnh thành nhiều frame. Frame đầu tiên chuyển giao dữ liệu có một opcode biểu thị kiểu dữ liệu đang được truyền. Điều này cần thiết bởi vì Javascript hầu như không có hỗ trợ cho kiểu dữ liệu nhị phân (binary) khi nó được xây dựng. 0x01 biểu thị kiểu encode văn bản UTF-8, 0x02 là dữ liệu nhị phân. Đa số mọi người sẽ chuyển giao JSON trong trường hợp bạn muốn chọn opcode văn bản. Khi bạn phát tín hiệu (emit) dữ liệu nhị phân nó sẽ được thể hiện trên trình duyệt dưới dạng cụ thể là <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a>.</p><p>API để gửi dữ liệu thông qua WebSocket khá đơn giản:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://websocket.example.com'</span>);</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  socket.send(<span class="string">'Some message'</span>); <span class="comment">// Gửi dữ liệu đến server.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Khi WebSocket nhận dữ liệu (ở phía client), một sự kiện message được bắn ra. Sự kiện này bao gồm một thuộc tính gọi là data có thể dùng để truy cập nội dung của message.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Xử lý message gửi đi từ server.</span></span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = event.data;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Bạn có thể khám phá dữ liệu một cách dễ dàng trong mỗi frame trong kết nối WebSocket sử dụng tab Network trong Chrome DevTools:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*Sz4wI2ukt91vRrgf8UonWw.png" alt=""></p><h1 id="Su-phan-manh"><a href="#Su-phan-manh" class="headerlink" title="Sự phân mảnh"></a>Sự phân mảnh</h1><p>Dữ liệu payload có thể được chia thành nhiều frame riêng. Nơi nhận có nhiệm vụ lưu đệm chúng cho đến khi bit fin được set. Thế nên bạn có thể chuyển 1 chuỗi “Hello World” trong 11 gói tin của 6 (độ dài header) + 1 byte cho mỗi gói. Sự phân mảnh không được chấp nhận cho gói tin điều khiển (control packages). Tuy nhiên, đặc điểm kỹ thuật muốn bạn có thể xử lý những frame điều khiển xen kẽ nhau. Đó là trường hợp gói tin TCP nhận được có thứ tự lộn xộn.</p><p>Logic để kết nối frame được mô tả sơ lược như sau:</p><ul><li>Nhận frame đầu tiên</li><li>Ghi nhớ opcode</li><li>Nối các frame payload lại với nhau cho đến khi bit fin được set.</li><li>Giả định rằng opcode cho mỗi gói tin là 0</li></ul><p>Mục đích chính của sự phân mảnh là cho phép gửi message khi không biết rõ kích thước ban đầu của message. Với sự phân mảnh, server có thể chọn một kích thước buffer (bộ đệm) phù hợp và khi buffer đầy thì ghi mảnh (fragment) đó vào network. Trường hợp sử dụng phụ của sự phân mảnh là truyền tin đa luồng (multiplexing), vốn dĩ không cần một message lớn trên một kênh logic để tiếp nhận toàn bộ kênh đầu ra, vì thế multiplexing cần phải giải phóng để cắt message ra thành nhiều mảnh để có thể chia sẻ đến kênh đầu ra tốt hơn.</p><h1 id="Heartbeating-nhip-tim-la-gi"><a href="#Heartbeating-nhip-tim-la-gi" class="headerlink" title="Heartbeating (nhịp tim) là gì ?"></a>Heartbeating (nhịp tim) là gì ?</h1><p>Tại một thời điểm sau khi “bắt tay” (handshake), cả client và server có thể lựa chọn để gửi đi một ping đến phía kia. Khi ping được nhận, người nhận phải gửi ngược lại một pong ngay khi có thể. Đó gọi là heartbeat (nhịp tim đập). Bạn có thể dùng nó để đảm bảo client vẫn đang được kết nối.</p><p>Một ping hay pong chỉ là frame bình thường, không phải frame điều khiển. Ping có opcode là 0x9 và opcode của pong là 0xA. Khi bạn nhận được ping, gửi ngược lại pong với chính xác cùng dữ liệu Payload như ping (với ping và pong thì độ dài payload tối đa là 125). Bạn cũng có thể nhận được pong mà chưa từng gửi ping. Nếu nó xảy ra thì bỏ qua, quên nó đi.</p><p>Heartbeat có thể rất có ích. Có nhiều dịch vụ (chẳng hạn như bộ cân bằng tải - load balancer) sẽ hủy những kết nối đứng yên (idle). Thêm nữa, bên nhận không thể biết nếu bên kia (bên gửi) đã bị kết thúc hay chưa. Chỉ có đến lần gửi thông tin tiếp theo ta mới nhận ra có gì đó không ổn.</p><h1 id="Xu-ly-loi"><a href="#Xu-ly-loi" class="headerlink" title="Xử lý lỗi"></a>Xử lý lỗi</h1><p>Bạn có thể xử lý bao nhiêu lỗi xảy ra cũng được bằng cách listen đến sự kiện error.<br>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://websocket.example.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Xử lý lỗi xảy ra.</span></span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'WebSocket Error: '</span> + error);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Dong-ket-noi"><a href="#Dong-ket-noi" class="headerlink" title="Đóng kết nối"></a>Đóng kết nối</h1><p>Để đóng kết nổi thì client hoặc server phải gửi một frame điều khiển với dữ liệu chứa opcode 0x8. Ngay khi nhận được frame đó thì bên nhận sẽ gửi trả một frame đóng (close). Bên gửi sẽ đóng kết nối. Bất kỳ thông tin nào nhận được sau khi đóng kết nối đều bị vứt bỏ.</p><p>Đây là cách bạn khởi tạo quá trình đóng kết nối WebSocket từ client:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Đóng nếu kết nối đang được mở.</span></span><br><span class="line"><span class="keyword">if</span> (socket.readyState === WebSocket.OPEN) &#123;</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Để thực hiện dọn dẹp sau khi đóng kết nối thành công, bạn có thể thêm một event listener vào sự kiện close:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dọn dẹp những thứ cần thiết.</span></span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Disconnected from WebSocket.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Server lắng nghe sự kiện close để xử lý nếu cần:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reasonCode, description</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Kết nối đang bị đóng.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="So-sanh-WebSockets-va-HTTP-2"><a href="#So-sanh-WebSockets-va-HTTP-2" class="headerlink" title="So sánh WebSockets và HTTP/2"></a>So sánh WebSockets và HTTP/2</h1><p>Trong khi HTTP/2 cung cấp nhiều thứ, nó lại không hoàn toàn thay thế sự cần thiết cho các công nghệ push/streaming hiện có.</p><p>Điều quan trọng đầu tiên về HTTP/2 mà ta cần chú ý là nó không phải là một thay thế cho tất cả HTTP. Những động từ, mã status và đa số các loại header sẽ vẫn như cũ. HTTP/2 hướng đến cải thiện sự hiệu quả trong cách mà dữ liệu truyền trên đường dây.</p><p>Giờ nếu so sánh HTTP/2 với WebSocket thì ta có nhiều thứ tương đồng:</p><table><thead><tr><th></th><th>HTTP/2</th><th>WebSocket</th></tr></thead><tbody><tr><td>Headers</td><td>Được nén (HPACK)</td><td>Không nén</td></tr><tr><td>Binary</td><td>Có</td><td>Nhị Phân hoặc Văn Bản</td></tr><tr><td>Multiplexing</td><td>Có</td><td>Có</td></tr><tr><td>Sự ưu tiên</td><td>Có</td><td>Không</td></tr><tr><td>Nén</td><td>Có</td><td>Có</td></tr><tr><td>Đinh hướng</td><td>Client/Server hoặc là Server Push</td><td>2 chiều</td></tr><tr><td>Full-duplex</td><td>Có</td><td>Có</td></tr></tbody></table><p>Như đã thấy ở trên, HTTP/2 giới thiệu tính năng <a href="https://en.wikipedia.org/wiki/Push_technology?oldformat=true" target="_blank" rel="noopener">Server Push</a> để cho phép server gửi tài nguyên một cách chủ động đến bộ đệm phía client. Tuy nhiên, nó không cho phép tự ý push dữ liệu xuống client. Server push chỉ được xử lý bằng browser và không được bật trong code của ứng dụng, nghĩa là không có API cho app để get thông báo từ những sự kiện như thế này.</p><p>Đây là nơi Sự kiện server gửi thông tin (Server-Sent Events - SSE) trở nên rất có ích. SSE là 1 cơ chế cho phép server push dữ liệu bất đồng bộ về client một khi kết nối client-server được thiết lập. Server có thể lựa chọn để gửi dữ liệu khi nào một “cục” dữ liệu mới đã sẵn sàng. Nó có thể được cân nhắc như là mô hình đăng ký-xuất bản (<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" target="_blank" rel="noopener">publish-subscribe</a>) 1 chiều. Nó cũng cung cấp một chuẩn Javascript client API tên là EventSource được triển khai trong đa số các trình duyệt hiện đại như là 1 phần của tiêu chuẩn HTML5 bởi <a href="https://www.w3.org/TR/eventsource/" target="_blank" rel="noopener">W3C</a>. Chú ý rằng trình duyệt không hỗ trợ <a href="http://caniuse.com/#feat=eventsource" target="_blank" rel="noopener">EventSource API</a> cũng có thể dễ dàng polyfill.</p><p>Bởi vì SSE dựa trên HTTP, nó có thể phù hợp với HTTP/2 và có thể kết hợp để đạt được sự tốt nhất của cả 2 bên: HTTP/2 xử lý tầng giao vận (transport layer) hiệu quả dựa trên các luồng multiplex và SSE cung cấp API cho app để thực hiện push.</p><p>Để hiểu hoàn toàn về Stream và Multiplexing, đầu tiên ta cần biết sơ lược về định nghĩa tại IETF: <em>một “stream” là chuỗi tuần tự 2 chiều và độc lập của nhiều frame được trao đổi giữa client và server trong một kết nối HTTP/2. Mộ trong số những đặc tính chính của nó là một kết nối HTTP/2 có thể chứa đồng thời nhiều stream đang mở với frame endpoint xen kẽ từ nhiều stream.</em></p><p><img src="https://cdn-images-1.medium.com/max/1000/1*pSh7IORJoUXbwCjyJ7fM9A.png" alt=""></p><p>Phải nhớ rằng SSE là dựa trên HTTP. Nghĩa là với HTTP/2, không chỉ nhiều stream SSE được xen kẽ trên một kết nối TCP mà cũng cơ chế đó có thể thực hiện với sự kết hợp của nhiều stream SSE (push từ server đến client) và nhiều client request (client đến server). Nhờ ơn HTTP/2 và SSE mà giờ đây chúng ta đã có một kết nối HTTP 2 chiều thuần túy với API đơn giản để code ứng dụng có thể đăng ký cho server push. Thiếu đi khả năng giao tiếp 2 chiều thường được xem như là một bước cải lùi khi so sánh SSE với WebSocket. Cảm ơn HTTP/2, nhờ nó mà điều này không còn là vần đề nữa. Thêm nữa là nó mở ra cơ hội để bỏ qua WebSocket và tập trung vào những công nghệ thay thế dựa trên HTTP.</p><h1 id="Lam-the-nao-de-chon-giua-WebSocket-amp-HTTP-2"><a href="#Lam-the-nao-de-chon-giua-WebSocket-amp-HTTP-2" class="headerlink" title="Làm thế nào để chọn giữa WebSocket &amp; HTTP/2?"></a>Làm thế nào để chọn giữa WebSocket &amp; HTTP/2?</h1><p>WebSocket chắc chắn sẽ tồn tại trong sự thống trị của HTTP/2 + SSE, chủ yếu bởi vì nó là công nghệ đã được đón nhận và trong nhiều trường hợp cụ thể nó có sự vượt trội so với HTTP/2 như cách nó được xây dựng cho khả năng giao tiếp 2 chiều với ít chi phí tốn kém (ví dụ: headers).</p><p>Giả sử bạn muốn xây dựng game MMO (Massive Multiplayer Online: Game nhiều người chơi trực tuyến) cần một lượng khổng lồ message từ cả 2 đầu kết nối. Trong những trường hợp như thế thì WebSocket thể hiện rất rất tốt.</p><p>Tổng quát thì sử dụng WebSocket khi nào bạn cần một kết nối với độ trễ rất thấp, gần như là realtime giữa client &amp; server. Nhớ kỹ rằng việc này có thể yêu cầu bạn cân nhắc lại cách xây dựng ứng dụng server-side của bạn, cũng như chuyển sang tập trung vào những công nghệ như event queue.</p><p>Nếu trường hợp của bạn cần hiển thị tin tức thị trường, dữ liệu thị trường, ứng dụng chat… theo thời gian thực, sử dụng HTTP/2 + SSE sẽ cung cấp cho bạn kênh giao tiếp 2 chiều hiệu quả trong khi gặt hái nhiều lợi ích khi hoạt động trong thế giới của HTTP:</p><ul><li>WebSocket thường gây ra khó khăn khi cân nhắc sự tương thích với hạ tầng web hiện tại cũng như nó nâng cấp kết nối HTTP đến một giao thức hoàn toàn khác mà không có gì dính dáng tới HTTP.</li><li>Mở rộng và bảo mật: những thành phần của web (firewall, phát hiện xâm nhập, cân bằng tải) được xây dựng, bảo trì và thiết đặt với tư tưởng của HTTP, một môi trường cho ứng dụng lớn và nghiêm ngặt sẽ ưu tiên khả năng phục hồi, bảo vật và khả năng mở rộng.</li></ul><p>Bạn cũng cần phải cân nhắc về vấn đề hỗ trợ của trình duyệt:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*YFr59cEF2qxzjjleebvbcQ.png" alt=""></p><p>Khá tốt phải không nào?</p><p>Nhưng với HTTP/2 thì không hẳn:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*C1VWSKOx89vqdiSiflDRJw.png" alt=""></p><ul><li>Chỉ có TLS (Cũng không tệ lắm)</li><li>Hỗ trợ một phần cho IE11 nhưng chỉ trên Windows 10</li><li>Chỉ hỗ trợ OSX 10.11 trở lên trên Safari</li><li>Chỉ hỗ trợ HTTP/2 nếu bạn có thể điều hướng nó qua APLN (server của bạn cũng cần phải hỗ trợ nó rõ ràng)</li></ul><p>Hỗ trợ SSE thì tốt hơn một chút:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*9ryMUEZhtbTg7lECHVz0fw.png" alt=""></p><p>Chỉ có IE/Edge là không hỗ trợ (Opera Mini cũng thế). Vẫn có những polyfill khá tốt để giúp chúng ta làm viêc với SSE trên IE/Edge.</p><h1 id="SessionStack-lua-chon-nhu-the-nao"><a href="#SessionStack-lua-chon-nhu-the-nao" class="headerlink" title="SessionStack lựa chọn như thế nào?"></a>SessionStack lựa chọn như thế nào?</h1><p>Team SessionStack sử dụng cả 2 WebSocket và HTTP, tùy thuộc vào từng trường hợp. Một khi bạn đã tích hợp SessionStack vào web app của bạn, nó sẽ ghi lại mọi thứ diễn ra trên app/website: những thay đổi trên DOM, tương tác của người dùng, JS exception, stack trace, những request bị fail và cả thông báo debug, cho phép bạn chạy lại (replay) những issue đã xảy ra dưới dạng video và xem chúng diễn ra như thế nào với người dùng. Tất cả đều hoạt động theo thời gian thực (real-time) và không ảnh hưởng đến hiệu năng của webapp.</p><p>Điều đó nghĩa là bạn có thể tham gia vào một phiên làm việc của user, trong khi user đang hoạt động trên trình duyệt. Trong trường hợp này, team tác giả chọn sử dụng HTTP bởi vì không cần giao tiếp 2 chiều (server chỉ cần stream dữ liệu đến trình duyệt). Nếu dùng WebSocket ở đây thì sẽ rất tệ, càng khó để bảo trì và mở rộng.</p><p>Tuy nhiên, thư viện SessionStack tích hợp vào trong webapp của bạn sử dụng WebSocket (nếu có thể, còn không thì HTTP). Nó sắp xếp và gửi dữ liệu về server và cũng là giao tiếp 1 chiều. Team tác giả chọn WebSocket vì trong trường hợp này vài tính năng cần thiết sử dụng giao tiếp 2 chiều.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 5 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Trong phần này chúng ta sẽ đào sâu với thế giới của những giao thức giao tiếp, ánh xạ (mapping) và thảo luận về những thuộc tính cũng như thành phần của chúng. Chúng ta sẽ đưa ra 1 so sánh nhỏ giữa WebSockets và HTTP/s. Cuối cùng, team SessionStack sẽ chia sẻ một vài ý tưởng về việc lựa chọn phương thức nào cho phù hợp với giao thức mạng.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P4: Event loop, lập trình bất đồng bộ &amp; 5 mẹo cải thiện Async/Await</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P4-Event-loop-lap-trinh-bat-dong-bo-5-meo-cai-thien-Async-Await.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P4-Event-loop-lap-trinh-bat-dong-bo-5-meo-cai-thien-Async-Await.html</id>
    <published>2018-11-13T16:34:00.000Z</published>
    <updated>2018-11-13T16:39:26.827Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 4 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Lần này chúng ta sẽ mở rộng những gì có trong bài đầu tiên bằng cách đánh giá những nhược điểm của môi trường đơn luồng (single thread) và làm thế nào để vượt qua chúng nhằm xây dựng những Javascript UI ấn tượng. Và vẫn như cũ, cuối bài viết tác giả sẽ chia sẻ 5 mẹo nhỏ để viết code tốt hơn với async/await.<br><a id="more"></a></p><h1 id="Tai-sao-don-luong-lai-la-gioi-han"><a href="#Tai-sao-don-luong-lai-la-gioi-han" class="headerlink" title="Tại sao đơn luồng lại là giới hạn."></a>Tại sao đơn luồng lại là giới hạn.</h1><p>Trong bài đầu tiên của series, chúng ta suy ngẫm về câu hỏi điều gì xảy ra khi chúng ta có 1 hàm trong callstack và hàm đó lại ngốn quá nhiều thời gian để thực thi.</p><p>Hãy tưởng tượng, ta thực hiện một thuật toán chuyển đổi hình ảnh phức tạp chạy trên browser.</p><p>Trong khi callstack đang thực thi các hàm, trình duyệt lại không thể làm gì cả, nó bị kẹt. Nghĩa là trình duyệt không thể vẽ, render, nó không thể chạy code khác, chỉ đơn giản là kẹt. Và vấn đề là ở đây, giao diện (UI) của app bạn sẽ hoạt động không hiệu quả.</p><p>App của bạn bị kẹt.</p><p>Trong một vài trường hợp thì đây không phải vấn đề nghiêm trọng. Tuy nhiên, có vấn đề còn lớn hơn nữa. Một khi trình duyệt của bạn xử lý quá nhiều thứ trong callstack, nó sẽ bị “đỡ” trong 1 khoảng thời gian dài. Tại thời điểm đó, đa số các browser sẽ chọn giải pháp hiện lỗi, hỏi người dùng có muốn hủy trang hiện tại không.</p><p>Điều này thật là xấu xí và ảnh hưởng nghiêm trọng đến trải nghiệm (UX):</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*MCt4ZC0dMVhJsgo1u6lpYw.jpeg" alt=""></p><h1 id="Nhung-thanh-phan-xay-dung-nen-1-chuong-trinh-JS"><a href="#Nhung-thanh-phan-xay-dung-nen-1-chuong-trinh-JS" class="headerlink" title="Những thành phần xây dựng nên 1 chương trình JS"></a>Những thành phần xây dựng nên 1 chương trình JS</h1><p>Bạn có thể viết toàn bộ code JS trong 1 file .js duy nhất nhưng chương trình của bạn chắc chắn chứa nhiều thành phần nhỏ (gọi là những block), chỉ có một số block sẽ được <strong>thực thi ngay</strong> (gọi là nhóm A) và phần còn lại thì <strong>chạy sau</strong> (nhóm B). Đơn vị block phổ biến nhất là function (hàm).</p><p>Vấn đề mà đa số các developer JS mới gặp phải là họ nghĩ rằng nhóm B không cần phải được thực thi một cách nghiêm ngặt ngay sau khi thực thi nhóm A. Nói cách khác, những nhiệm vụ không được hoàn thành ngay bây giờ thì theo lỹ thuyết nó sẽ được hoàn thành một cách bất đồng bộ, nghĩa là bạn sẽ không phải gặp tình huống blocking (bị chặn) như đề cập ở trên</p><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Giả sử ajax(..) là một hàm Ajax thuộc thư viện nào đó</span></span><br><span class="line"><span class="keyword">var</span> response = ajax(<span class="string">'https://example.com/api'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(response);</span><br><span class="line"><span class="comment">// `response` sẽ không chứa dữ liệu trả về</span></span><br></pre></td></tr></table></figure><p>Chắc bạn cũng nhận thấy rằng những request Ajax như thế này không chạy đồng bộ với nhau, nghĩa là tại thời điểm code thực thi, hàm ajax(…) chưa có dữ liệu trả về để gán vào biến response</p><p>Một cách đơn giản cho thường gặp để “chờ” một hàm xử lý bất đồng bộ trả kết quả về đó là sử dụng callback:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'https://example.com/api'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response); <span class="comment">// "response" giờ đã có dữ liệu</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Chú ý: Bạn có thể viết những Ajax request đồng bộ, tuy nhiên đừng bao giờ làm thế. Nếu bạn viết Ajax như vậy thì UI sẽ bị block cứng đơ và người dùng sẽ không thể thực hiện các hành động như click, nhập dữ liệu, điều hướng, lăn chuột… Một trải nghiệm kinh khủng.</p><p>Đây là cách mà Ajax được viết đồng bộ, nhưng làm ơn, đừng bao giờ sử dụng nó trong app của bạn:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Giả sử bạn đang dùng jQuery</span></span><br><span class="line">jQuery.ajax(&#123;</span><br><span class="line">    url: <span class="string">'https://api.example.com/endpoint'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// callback ở đây.</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span>: <span class="literal">false</span> <span class="comment">// Một ý tưởng cực kỳ tồi tệ</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Chúng ta đã sử dụng Ajax request để ví dụ. Ngoài ra bạn có thể dùng bất kỳ đoạn code nào để thực hiện bất đồng bộ.</p><p>Dưới đây là ví dụ khác với hàm setTimeout(callback, milliseconds). Cách thức mà hàm setTimeout hoạt động là nó sẽ đặt 1 sự kiện (ở đây là sự kiện timeout) và để nó thực hiện sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'first'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'second'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">third</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'third'</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line">setTimeout(second, <span class="number">1000</span>); <span class="comment">// gọi hàm `second` sau 1000ms</span></span><br><span class="line">third();</span><br></pre></td></tr></table></figure><p>Và đây là kết quả của đoạn code trên:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">third</span><br><span class="line">second</span><br></pre></td></tr></table></figure><h1 id="Mo-xe-Event-Loop-vong-lap-su-kien"><a href="#Mo-xe-Event-Loop-vong-lap-su-kien" class="headerlink" title="Mổ xẻ Event Loop (vòng lặp sự kiện)"></a>Mổ xẻ Event Loop (vòng lặp sự kiện)</h1><p>Chúng ta sẽ bắt đầu với một chút “kỳ quặc” - mặc dù JS chấp nhận code chạy bất đồng bộ (như trường hợp của setTimeout) thì cho đến khi giới thiệu ES6, JS cũng không thực sự có một khái niệm trực tiếp nào về bất đồng bộ. Bộ engine JS chưa bao giờ làm gì vượt ra khỏi việc thực thi <strong>một</strong> khối lệnh trong chương trình của bạn tại 1 thời điểm cố định.</p><p>Bạn có thể xem chi tiết hơn về cách engine JS (cụ thể là Google V8) hoạt động như thế nào ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-2---Ben-trong-engine-V8---5-meo-de-toi-uu-hoa-code" target="_blank" rel="noopener">bài viết trước</a>.</p><p>Vậy thì ai là người ra lệnh cho engine JS phải thực thi những khối lệnh trong chương trình? Trên thực tế, engine JS không chạy cô lập, nó hoạt động bên trong một môi trường chủ (hosting environment), môi trường này đối với đa số các developer chính là trình duyệt web hoặc Node.js. Thực ra, ngày nay, JS đã và đang được nhúng vào rất nhiều loại thiết bị khác nhau, từ robot cho tới bóng đèn. Mỗi một thiết bị có thể xem như là 1 loại khác nhau của môi trường chủ cho engine JS.</p><p>Mẫu số chung của tất cả các môi trường đó là một cơ chế tích hợp sẵn được gọi là <strong>event-loop</strong> (vòng lặp sự kiện), nó xử lý quá trình thực thi của nhiều khối lệnh trong chương trình theo thời gian, mỗi lần đều gọi engine JS.</p><p>Điều này nghĩa là engine JS chỉ là 1 môi trường thực thi theo yêu cầu cho bất kỳ đoạn code JS tùy ý nào. Nó chỉ là môi trường bao quanh có lịch trình cho các sự kiện (quá trình thực thi code JS).</p><p>Ví dụ, khi code JS của bạn gọi Ajax request để lấy dữ liệu từ server, bạn cài đặt một đoạn code <em>response</em> trong một hàm (gọi là callback), và engine JS sẽ truyền đạt lại với môi trường chủ: <em>Này, tao chuẩn bị tạm ngưng quá trình thực thi ngay bây giờ, nhưng mà khi nào mày xong việc với request đó và có một vài cục dữ liệu thì nhớ gọi lại hàm này nhé.</em></p><p>Trình duyệt sau đó sẽ lắng nghe về response từ mạng, và khi nó có gì đó trả về cho bạn, nó sẽ lên lịch cho hàm callback được thực thi bằng cách chèn nó vào trong event loop</p><p>Cùng xem sơ đồ này nào:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*FA9NGxNB6-v1oI2qGEtlRQ.png" alt=""></p><p>Bạn có thể xem lại phần bài viết về Memory Heap &amp; Call Stack trong <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-1---Khai-quat-ve-engine--runtime-va-callstack" target="_blank" rel="noopener">bài viết trước đây</a></p><p>Vậy thì những Web APIs này là gì? Về bản chất, chúng là những tiến trình mà bạn không thể truy xuất (access), bạn chỉ có thể gọi nó. Chúng là những thành phần của trình duyệt mà trong đó cách xử lý đồng bộ được bắt đầu. Nếu bạn là một Node.js developer thì chúng là những C++ APIs.</p><p><strong>Vậy cuối cùng thì event loop là cái éo gì ?</strong></p><p><img src="https://cdn-images-1.medium.com/max/1000/1*KGBiAxjeD9JT2j6KDo0zUg.png" alt=""></p><p><strong>Event Loop</strong> có một công việc đơn giản: theo dõi Call Stack và Callback Queue (hàng đợi các hàm callback). Nếu Call Stack đang trống, nó sẽ lấy event đầu tiên từ trong hàng đợi ra và đẩy nó vảo trong Call Stack - tức là thực thi nó.</p><p>Mỗi vòng lặp như thế được gọi là 1 <strong>tick</strong> trong Event Loop. Mỗi sự kiện chỉ là 1 hàm callback.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb1</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'cb1'</span>);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Bye'</span>);</span><br></pre></td></tr></table></figure><p>Cùng <em>thực thi</em> đoạn code trên và xem điều gì xảy ra nào:</p><ol><li>Trạng thái đang trống, console của trình duyệt đang trống, Call Stack đang trống. <img src="https://cdn-images-1.medium.com/max/1000/1*9fbOuFXJHwhqa6ToCc_v2A.png" alt=""></li><li>console.log(‘Hi’) được thêm vào Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*dvrghQCVQIZOfNC27Jrtlw.png" alt=""></li><li>console.log(‘Hi’) được thực thi. <img src="https://cdn-images-1.medium.com/max/1000/1*yn9Y4PXNP8XTz6mtCAzDZQ.png" alt=""></li><li>console.log(‘Hi’) bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*iBedryNbqtixYTKviPC1tA.png" alt=""></li><li>setTimeout(function cb1() { … }) được thêm vào Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*HIn-BxIP38X6mF_65snMKg.png" alt=""></li><li>setTimeout(function cb1() { … }) được thực thi. Trình duyệt tạo một timer - vốn là một phần của Web APIs. Nó sẽ thực hiện phần đếm ngược cho bạn. <img src="https://cdn-images-1.medium.com/max/1000/1*vd3X2O_qRfqaEpW4AfZM4w.png" alt=""></li><li>The setTimeout(function cb1() { … }) được thực hiện xong và bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*_nYLhoZPKD_HPhpJtQeErA.png" alt=""></li><li>console.log(‘Bye’) được thêm vào Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*1NAeDnEv6DWFewX_C-L8mg.png" alt=""></li><li>console.log(‘Bye’) được thực thi. <img src="https://cdn-images-1.medium.com/max/1000/1*UwtM7DmK1BmlBOUUYEopGQ.png" alt=""></li><li>console.log(‘Bye’) bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*-vHNuJsJVXvqq5dLHPt7cQ.png" alt=""></li><li>Sau ít nhất 5000ms, timer hoàn thành công việc của nó và đẩy cb1 callback vào trong Callback Queue. <img src="https://cdn-images-1.medium.com/max/1000/1*eOj6NVwGI2N78onh6CuCbA.png" alt=""></li><li>Event Loop lấy cb1 từ trong Callback Queue và đưa nó vào trong Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*jQMQ9BEKPycs2wFC233aNg.png" alt=""></li><li>cb1 được thực thi và nó thêm console.log(‘cb1’) vào trong Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*hpyVeL1zsaeHaqS7mU4Qfw.png" alt=""></li><li>console.log(‘cb1’) được thực thi. <img src="https://cdn-images-1.medium.com/max/1000/1*lvOtCg75ObmUTOxIS6anEQ.png" alt=""></li><li>console.log(‘cb1’) bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*Jyyot22aRkKMF3LN1bgE-w.png" alt=""></li><li>cb1 bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*t2Btfb_tBbBxTvyVgKX0Qg.png" alt=""></li></ol><p>Ảnh gif tổng hợp lại quá trình 16 bước ở trên:<br><img src="https://cdn-images-1.medium.com/max/1000/1*TozSrkk92l8ho6d8JxqF_w.gif" alt=""></p><p>Thật thú vị khi biết rằng ES6 có mô tả event loop hoạt động như thế nào, nghĩa là về mặt kỹ thuật, nó nằm trong phạm vi trách nghiệm của một JS engine, tức là không còn chỉ đóng vai trò môi trường chủ. Một lý do chính đáng cho sự thay đổi này chính là việc giới thiệu Promise trong ES6 bởi vì promise mới cần truy xuất trực tiếp, kiểm soát tối đa lịch trình điều hành đối với event loop queue (Sau này chúng ta sẽ thảo luận chi tiết hơn)</p><h1 id="setTimeout-…-hoat-dong-nhu-the-nao"><a href="#setTimeout-…-hoat-dong-nhu-the-nao" class="headerlink" title="setTimeout(…) hoạt động như thế nào?"></a>setTimeout(…) hoạt động như thế nào?</h1><p>Điều quan trọng cần phải biết là setTimeout(…) không tự động đặt callback vào trong event loop queue. Nó thiết lập một bộ đếm. Khi bộ đếm kết thúc, môi trường đặt callback vào trong event loop, vì thế những <strong>tick</strong> tiếp theo có thể lấy nó ra và thực thi:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(myCallback, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>Nó không có nghĩa là myCallback sẽ được thực thi sau 1000ms, mà đúng hơn là, trong 1000ms, myCallback sẽ được thêm vào trong queue. Tuy nhiên queue này có thể đang có event khác đã được thêm vào trước đó, và vì thế callback của bạn sẽ phải chờ.</p><p>Có một vài bài biết hoặc bài hướng dẫn dành cho người mới bắt đầu với bất đồng bộ trong JS hướng dẫn rằng ta nên setTimeout(callback, 0). Bây giờ bạn đã biết cách event loop làm việc và cách setTimeout hoạt động rồi: gọi setTimeout với thời gian là <strong>0</strong> chỉ vì mục đích hoãn callback lại cho tới khi Call Stack rỗng hoàn toàn.</p><p>Hãy xem ví dụ dưới đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callback'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Bye'</span>);</span><br></pre></td></tr></table></figure><p>Mặc dù thời gian chờ của callback là <em>0ms</em> nhưng kết quả in ra lại như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hi</span><br><span class="line">Bye</span><br><span class="line">callback</span><br></pre></td></tr></table></figure><h1 id="Jobs-cong-viec-trong-ES6-la-gi"><a href="#Jobs-cong-viec-trong-ES6-la-gi" class="headerlink" title="Jobs (công việc) trong ES6 là gì?"></a>Jobs (công việc) trong ES6 là gì?</h1><p>Một khái niệm mới gọi là <strong>Job Queue</strong> (Hàng đợi công việc) được giới thiệu trong ES6. Nó là lớp trên cùng của event loop queue. Nhiều khả năng bạn sẽ gặp phải nó khi xử lý vấn đề liên quan đến bất đồng bộ của Promise (Chúng ta sẽ nói về nó sau).</p><p>Bây giờ thì chúng ta chỉ tìm hiểu về mặt ý tưởng cơ bản để sau này khi thảo luận về bất đồng bộ với Promise, bạn có thể hiểu về những hành động đã được lên lịch và xử lý.</p><p>Tưởng tượng nó như thế này: Job queue là 1 queue được gắn vào cuối mỗi tick trong event loop queue. Mỗi hành động bất đồng bộ nhất định khi xảy ra trong 1 tick sẽ không làm cho toàn bộ event được thêm vào event loop queue nhưng thay vì thế sẽ thêm 1 item (tức là job) vào cuối job queue của tick hiện tại.</p><p>Điều này nghĩa là bạn có thể thêm những tính năng khác để có thể thực thi sau và bạn có thể chắc chắn rằng nó sẽ được thực thi ngay sau đó, trước bất kỳ đoạn code nào khác.</p><p>Một job có thể thêm nhiều job khác vào đoạn cuối của cùng 1 queue. Trên lý thuyết, job có thể lặp (loop) vô thời hạn (một job thực hiện thêm nhiều job khác, v..v…), do đó nó sẽ làm cho chương trình bị quá tải tài nguyên cần thiết để tiếp tục chạy. Về mặt khái niệm thì điều này tương tự như một công việc có thời gian thực thi dài hoặc là một vòng lặp vô hạn (ví dụ: while(true)).</p><p>Job cũng giống như trick setTimeout(callback, 0) (set thời gian bằng _0_) nhưng được triển khai theo cách có vẻ như “chính thống” hơn và có sự đảm bảo về thứ tự: thực hiện sau, nhưng phải làm ngay khi có thể.</p><h1 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h1><p>Như bạn đã biết, callback là cách phổ biến nhất để thể hiện &amp; quản lý sự bất đồng bộ trong JS. Rõ ràng, callback là mô hình bất đồng bộ cơ bản nhất trong JS. Vô số chương trình JS, kể cả những app tinh vi và phức tạp nhất thì cũng phải dùng tới callback.</p><p>Ngoại trừ việc callback không xuất hiện mà không có thiếu sót. Nhiều developer đang cố gắng tìm kiếm những mô hình bất đồng bộ tốt hơn. Tuy nhiên, chúng ta không thể sử dụng bất kỳ phương pháp thay thế nào khác nếu như bạn chưa thực sự hiểu rõ về callback.</p><p>Ở chương tiếp theo, chúng ta sẽ khám phá sâu hơn về vấn đề này để tìm hiểu tại sao những mô hình bất đồng bộ tinh vi khác (sẽ nói ở những bài sau) là cần thiết và được đề nghị nên sử dụng.</p><h1 id="Callback-long-nhau-nested-callback"><a href="#Callback-long-nhau-nested-callback" class="headerlink" title="Callback lồng nhau (nested callback)"></a>Callback lồng nhau (nested callback)</h1><p>Xem đoạn code dưới đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">listen(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ajax(<span class="string">'https://api.example.com/endpoint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">text</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (text == <span class="string">"hello"</span>) &#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">"world"</span>) &#123;</span><br><span class="line">            doSomethingElse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Chúng ta có 3 hàm lồng nhau, mỗi hàm thể hiện 1 bước trong chuỗi bất đồng bộ.</p><p>Kiểu code như thế này thường được gọi là <strong>callback hell</strong>. Nhưng <em>callback hell</em> thực sự không phải vấn đề về lồng nhau hay cách dòng, thụt lề. Câu chuyện thực sự sâu xa hơn thế nhiều.</p><p>Đầu tiên, chúng ta listen một event <em>click</em>, sau đó thì chờ timer hoạt động, rồi cuối cùng là chờ cho Ajax trả kết quả về và quá trình này có thể lặp lại nhiều lần mỗi khi chúng ta click.</p><p>Thoạt nhìn đoạn code này thể hiện sự đồng bộ một cách tự nhiên theo thứ tự các bước như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>…rồi sau đó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>…tiếp theo là:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'https://api.example.com/endpoint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>…và cuối cùng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (text == <span class="string">"hello"</span>) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">"world"</span>) &#123;</span><br><span class="line">    doSomethingElse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chà, đúng là một cách thể hiện code bất đồng bộ một cách rất tự nhiên, phải không nào? <em>cười</em></p><h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>Cùng xem đoạn code sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x + y);</span><br></pre></td></tr></table></figure><p>Rất rõ ràng rằng nó tính tổng của x và y rồi in kết quả ra console. Tuy nhiên, nếu như giá trị của x và y chưa tồn tại và vẫn còn đang chờ để được xác định thì sao? Giả sử chúng ta cần lấy giá trị của x và y từ server trước khi chúng được dùng để tính tổng.<br>Tưởng tượng rằng chúng ta có một hàm loadX và loadY để thực hiện load dữ liệu cho x và y từ server và một hàm để tính tổng 2 số sau khi chúng được load xong.<br>Đoạn code sẽ giống như thế này (xấu xí và phức tạp, phải không nào?):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">getX, getY, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x, y;</span><br><span class="line">    getX(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        x = result;</span><br><span class="line">        <span class="keyword">if</span> (y !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            callback(x + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    getY(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        y = result;</span><br><span class="line">        <span class="keyword">if</span> (x !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            callback(x + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Một hàm đồng bộ hoặc bất đồng bộ để get giá trị của "x"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Một hàm đồng bộ hoặc bất đồng bộ để get giá trị của "y"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchY</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line">sum(fetchX, fetchY, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Có một điều quan trọng cần phải nêu lên ở đây: trong đoạn code trên, chúng ta xem x và y như những giá trị tương lai và hàm sum() không quan tâm về việc x hay y hay cả 2 biến có hay không có tồn tại giá trị.</p><p>Dĩ nhiên là cách tiếp cận thô dựa trên callback này cho ta nhiều thứ đáng mong đợi. Đây chỉ là 1 bước tiến nhỏ để hiểu về ích lợi của <em>giá trị tương lai</em> mà không cần lo lắng về khía cạnh thời gian khi chúng sẵn có.</p><h1 id="Gia-tri-cua-Promise"><a href="#Gia-tri-cua-Promise" class="headerlink" title="Giá trị của Promise"></a>Giá trị của Promise</h1><p>Cùng xem ví dụ về x + y được thực hiện với Promise:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">xPromise, yPromise</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `Promise.all([ .. ])` nhận vào 1 mảng các promise,</span></span><br><span class="line">    <span class="comment">// và trả về 1 promise chờ đợi tất cả chúng hoàn thành</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([xPromise, yPromise])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// khi một promise được phân giải (resolve),</span></span><br><span class="line">    <span class="comment">// ta lấy giá trị x, y trả về và cộng chúng lại.</span></span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">values</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// `values` là mảng chứa giá trị của các object</span></span><br><span class="line">        <span class="comment">// từ những promise đã được resolve</span></span><br><span class="line">        <span class="keyword">return</span> values[<span class="number">0</span>] + values[<span class="number">1</span>];</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `fetchX()` và `fetchY()` trả về promise </span></span><br><span class="line"><span class="comment">// chứa kết quả tương ứng, có thể có </span></span><br><span class="line"><span class="comment">// luôn hoặc chờ sau mới có dữ liệu</span></span><br><span class="line">sum(fetchX(), fetchY())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ta có 1 promise cho tổng của 2 số.</span></span><br><span class="line"><span class="comment">// Giờ thì gọi mắt xích (chain-call) hàm `.then(...)` để chờ </span></span><br><span class="line"><span class="comment">// kết quả của promise trả về.</span></span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Có 2 lớp Promise trong đoạn code này.</p><p>fetchX() và fetchY() được gọi trực tiếp và giá trị trả về của chúng (<strong>promise!</strong>) được đẩy vào hàm sum(…). Giá trị mà những promise này thể hiện có thể sẵn sàng để dùng ngay lúc gọi hàm hoặc là sau đó 1 chút nhưng bất kể sớm hay muộn thì mỗi promise đều chuẩn hóa hành vi của nó cho giống nhau. Chúng ta suy đoán về giá trị của x và y theo hướng độc lập thời gian. Theo chu kỳ, chúng là những <em>giá trị tương lai</em>.</p><p>Lớp thứ 2 là promise do hàm sum(…) tạo ra (thông qua Promise.all([ … ])) và trả về, và cũng chờ nó get giá trị khi gọi .then(…). Khi hàm sum(…) hoàn tất, tổng <em>giá trị tương lai</em> đã sẵn sàng và có thể in nó ra. Chúng ta ẩn phần logic chờ <em>giá trị tương lai</em> của x và y trong hàm `sum(…).</p><p><strong>Lưu ý</strong>: <em>Bên trong sum(…), lời gọi đến Promise.all([ … ]) tạo một promise (cái này sẽ gọi đến xPromise và yPromise rồi phân giải chúng). Chain-call đến .then() sẽ tạo ra 1 promise khác và promise này sẽ trả về values[0] + values[1] ngay khi resolve (với giá trị kết quả của phép cộng). Do đó lời gọi .then(…) ta đặt ở cuối hàm .sum(…), tức là cuối đoạn code, thực ra là xử lý trên giá trị trả về của promise thứ 2 hơn là promise thứ nhất được tạo ra bởi Promise.all([ … ]). Mặc dù vậy thì chúng ta không chain-call vào cuối hàm .then(…) sau vì làm vậy sẽ tạo thêm 1 promise và ta lại phải xử lý nó. Phần Promise chain-call này sẽ được giải thích kỹ hơn ở các phần sau trong chương này.</em></p><p>Với Promise, lời gọi .then(…) có thể nhận 2 hàm param, hàm thứ nhất là để thực hiện thao tác với response hoàn thành (như trên), hàm thứ 2 là với trường hợp bị lỗi và bác bỏ (rejection).</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sum(fetchX(), fetchY())</span><br><span class="line">.then(</span><br><span class="line">    <span class="comment">// Hàm xử lý hoàn thành</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( sum );</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Hàm xử lý bác bỏ</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error( err ); <span class="comment">// bummer!</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Nếu có gì đó không đúng trong quá trình get x và y hoặc là có sai sót khác thì promise mà .sum(…) trả về sẽ bị reject, hàm callback thứ 2 xử lý lỗi đã được đẩy vào .then(…) sẽ nhận giá trị reject từ promise.</p><p>Bởi vì promise đóng gói trạng thái độc lập thời gian từ bên ngoài - chờ cho giá trị được xử lý hoàn thành/reject, và bản thân promise đã là độc lập thời gian, do đó nhiều promise có thể được kết hợp với nhau theo những cách có thể đoán trước được bất kể là thời gian hay kết quả.</p><p>Hơn nữa, một khi promise được resolve thì nó sẽ tồn tại vĩnh viễn: nó trở thành một giá trị <strong>bất biến</strong> tại thời điểm đó, và có thể được lấy ra sử dụng bao nhiêu lần cũng được</p><p>Thực sự là rất hữu ích khi ta nối promise thanhf 1 chuỗi:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        setTimeout(resolve, time);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"after 1000ms"</span>);</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"after another 2000ms"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"step 4 (next Job)"</span>);</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">5000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>Gọi hàm delay(2000) sẽ tạo ra 1 promise mà nó được hoàn thành trong 2000ms, sau đó trả nó về từ hàm hoàn thành trong .then() đầu tiên, điều này làm cho hàm .then(…) thứ hai sẽ chờ 2000ms</p><p><strong>Lưu ý</strong>: <em>Bởi vì giá promise là bất biến sau khi đã được resolve, chúng ta có thể truyền nó đi khắp nơi mà không cần lo lắng về việc nó bất ngờ bị thay đổi. Điều này đặc biệt có ích khi có nhiều đoạn code cùng sử dụng kết quả của 1 promise. Tính bất biến nghe có vẻ như là một chủ đề liên quan đến học thuật, nhưng thật ra nó là 1 phần rất cơ bản và có khía cạnh quan trọng trong thiết kế promise mà ta không nên bỏ qua.</em></p><h1 id="Promise-hay-khong-Promise"><a href="#Promise-hay-khong-Promise" class="headerlink" title="Promise hay không Promise ?"></a>Promise hay không Promise ?</h1><p>Một chi tiết quan trọng về promise là phải biết một giá trị thực sự là promise hay không phải. Nói cách khác, đó có phải là 1 giá trị sẽ hành xử như 1 promise?</p><p>Chúng ta biết rằng promise được xây dựng bằng lệnh new Promise(…), và bạn cho rằng p instanceof Promise là đủ để kiểm tra? Thực ra thì không hẳn.</p><p>Chủ yếu bởi vì bạn có thể nhận giá trị promise từ một cửa sổ trình duyệt khác (ví dụ: iframe), nó sẽ có promise riêng của nó, khác với promise trong cửa sổ/frame hiện tại của bạn, và câu lệnh check ở trên sẽ fail khi xác định instance của promise.</p><p>Hơn nữa, một thư viện hay framework có thể sử dụng promise của riêng nó mà không dùng promise mặc định của ES6. Thật ra, bạn có thể dùng promise của thư viện trên những trình duyệt cũ không hỗ trợ promise.</p><h1 id="Nuot-chung-ngoai-le-exception"><a href="#Nuot-chung-ngoai-le-exception" class="headerlink" title="Nuốt chửng ngoại lệ (exception)"></a>Nuốt chửng ngoại lệ (exception)</h1><p>Nếu trong quá trình tạo promise hoặc là khi tiếp nhận kết quả từ nó, một lỗi biệt lệ JS xảy ra, ví dụ như TypeError hoặc ReferenceError, exception sẽ được bắt, khi đó nó sẽ ép (force) cho promise đang chạy bị reject.</p><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    foo.bar();    <span class="comment">// `foo` chưa được định nghĩa, lỗi!</span></span><br><span class="line">    resolve(<span class="number">374</span>); <span class="comment">// Code sẽ không đến được đây :(</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// không đến đây luôn :(</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// `err` sẽ là một object của exception`TypeError`</span></span><br><span class="line">    <span class="comment">// từ dòng `foo.bar()`.</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Nhưng nếu như một promise được hoàn thành nhưng có lỗi exception JS trong quá trình tiếp nhận (ví dụ như trong callback của .then(…) )? Kể cả như thế thì nó cũng không bị mất, bạn sẽ thấy một chút ngạc nhiên khi biết cách mà chúng được xử lý. Đào sâu thêm 1 tí nào:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">374</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    foo.bar();</span><br><span class="line">    <span class="built_in">console</span>.log(message);   <span class="comment">// không đến được đây nè.</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// không đến được đây nè.</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Có vẻ như exception từ foo.bar() thực sự đã bị nuốt trôi (swallow). Đúng là như thế. Có gì đó sâu hơn bên trong đã hoạt động sai tuy nhiên chúng ta lại không biết. Lời gọi p.then(…) cho chính nó trả về 1 promise khác và nó sẽ bị reject với ReferenceError exception.</p><h1 id="Xu-ly-nhung-biet-le-khong-bi-bat-Uncaught-exception"><a href="#Xu-ly-nhung-biet-le-khong-bi-bat-Uncaught-exception" class="headerlink" title="Xử lý những biệt lệ không bị bắt (Uncaught exception)"></a>Xử lý những biệt lệ không bị bắt (Uncaught exception)</h1><p>Có nhiều cách tiếp cận khác mà nhiều người cho rằng sẽ tốt hơn.</p><p>Một đề nghị phổ biến đó là promise nên có thêm một phương thức done(…), nó sẽ đánh dấu chuỗi promise là đã xong (done). .done(…)không tạo ra và trả về một promise vì thế callback truyền qua .done(…) rõ ràng là không liên quan đến việc báo cáo các vấn đề xảy ra với một chuỗi promise không tồn tại.</p><p>Nó hoạt động giống như bạn đã biết trong các điều kiện uncaught error: các exception bên trong một hàm reject trong .done(…) sẽ bị bắn ra ngoài developer console dưới dạng global uncaught error.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">374</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// Số number không có hàm của string,</span></span><br><span class="line">    <span class="comment">// nên sẽ bắn ra lỗi</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg.toLowerCase());</span><br><span class="line">&#125;)</span><br><span class="line">.done(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Nếu có uncaught exception ở đây thì nó sẽ bị bắn ra như là một global exception</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Dieu-gi-xay-ra-trong-ES8-va-Async-await"><a href="#Dieu-gi-xay-ra-trong-ES8-va-Async-await" class="headerlink" title="Điều gì xảy ra trong ES8 và Async/await"></a>Điều gì xảy ra trong ES8 và Async/await</h1><p>Javascript ES8 giới thiệu async/await để giúp cho công việc xử lý promise dễ dàng hơn. Chúng ta sẽ lướt sơ qua những khả năng mà async/await cung cấp và xem thử làm thế nào để dùng chúng để viết code bất đồng bộ một cách phù hợp.</p><p>Vậy thì đầu tiên là xem thử hoạt động của async/await.</p><p>Bạn định nghĩa một hàm bất đồng bộ sử dụng định nghĩa hàm async. Những hàm như vậy sẽ trả về object <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank" rel="noopener">AsyncFunction</a>. Object AsyncFunction biểu diễn hàm bất đồng bộ trong đó nó thực thi code bên trong nó.</p><p>Khi một hàm async được gọi, nó sẽ trả về Promise. Khi hàm async trả về giá trị, nó lại không phải promise, một promise sẽ được tạo ra tự động và được phân giải (resolve) với giá trị trả về từ hàm. Khi hàm async bắn ra exception, promise sẽ reject với giá trị bắn ra.</p><p>Một hàm async có thể chứa thể hiện await, nó sẽ dừng quá trình thực thi của hàm và đợi cho promise giải quyết xong rồi quay lại thực thi tiếp và trả về giá trị đã được resolve.</p><p>Bạn có thể xem như promise trong JS tương tự với Java Future hay C# Task.</p><blockquote><p>Mục đích của async/await là làm đơn giản hóa quá trình sử dụng promise.</p></blockquote><p>Xem ví dụ sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hàm JS bình thường</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'374'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Giống như hàm trên</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getNumber2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">374</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tương tự, những hàm bắn ra exception tương tự với những hàm trả về promise bị reject:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'Some error'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'Some error'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Từ khóa await chỉ có thể được dùng bên trong hàm async và cho phép bạn chờ promise một cách đồng bộ. Nếu chúng ta sử dụng promise bên ngoài một hàm async thì phải dùng tới callback:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `rp` là một hàm gọi promise.</span></span><br><span class="line">    <span class="keyword">var</span> promise1 = rp(<span class="string">'https://api.example.com/endpoint1'</span>);</span><br><span class="line">    <span class="keyword">var</span> promise2 = rp(<span class="string">'https://api.example.com/endpoint2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hiện tại cả 2 request đều được gọi đồng thời và</span></span><br><span class="line">    <span class="comment">// ta phải đợi cho nó hoàn thành.</span></span><br><span class="line">    <span class="keyword">var</span> response1 = <span class="keyword">await</span> promise1;</span><br><span class="line">    <span class="keyword">var</span> response2 = <span class="keyword">await</span> promise2;</span><br><span class="line">    <span class="keyword">return</span> response1 + <span class="string">' '</span> + response2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bởi vì ta không ở trong hàm `async` </span></span><br><span class="line"><span class="comment">// nên chúng ta phải dùng `then()`.</span></span><br><span class="line">loadData().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Done'</span>));</span><br></pre></td></tr></table></figure><p>Bạn có thể định nghĩa hàm async bằng cách sử dụng async function expression (AFE - Thể hiện hàm async). Một AFE tương tự và gần giống như một async function statement (AFS). Điểm khác biệt chính giữa AFE và AFS là tên của hàm, trong AFE ta có thể bỏ qua tên để tạo hàm vô danh (anonymous function). Một AFE có thể sử dụng như một IIFE (<a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" target="_blank" rel="noopener">Immediately Invoked Function Expression</a>), loại hàm được thực thi ngay sau khi nó được định nghĩa.</p><p>Nó trông như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadData = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `rp` là một hàm gọi promise.</span></span><br><span class="line">    <span class="keyword">var</span> promise1 = rp(<span class="string">'https://api.example.com/endpoint1'</span>);</span><br><span class="line">    <span class="keyword">var</span> promise2 = rp(<span class="string">'https://api.example.com/endpoint2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hiện tại cả 2 request đều được gọi đồng thời và</span></span><br><span class="line">    <span class="comment">// ta phải đợi cho nó hoàn thành.</span></span><br><span class="line">    <span class="keyword">var</span> response1 = <span class="keyword">await</span> promise1;</span><br><span class="line">    <span class="keyword">var</span> response2 = <span class="keyword">await</span> promise2;</span><br><span class="line">    <span class="keyword">return</span> response1 + <span class="string">' '</span> + response2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Quan trọng là async/await được hỗ trợ và có thể chạy trên đa số các trình duyệt:</p><p> <a href="https://cdn-images-1.medium.com/max/1000/0*z-A-JIe5OWFtgyd2." target="_blank" rel="noopener"><img src="https://cdn-images-1.medium.com/max/1000/0*z-A-JIe5OWFtgyd2." alt=""></a> <a></a></p><p>Nếu như trình duyệt nào không hỗ trợ thì ta vẫn có thể sử dụng các JS transpiler như <a href="https://babeljs.io/docs/plugins/transform-async-to-generator/" target="_blank" rel="noopener">Babel</a> hay <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html" target="_blank" rel="noopener">TypeScript</a></p><p>Cuối cùng thì điều quan trọng nhất là không nên chọn lựa một cách mù quáng những cách tiếp cận “mới nhất” để viết code bất đồng bộ. Tốt hơn là bạn hiểu về cấu trúc bất đồng bộ của JS, nghiên cứu tại sao nó lại là một vấn đề nghiêm túc và hiểu một cách sâu sắc về các thành phần bên trong của giải pháp mà bạn lựa chọn. Mỗi cách tiếp cận khác nhau đều có những điểm mạnh và điểm yếu, hãy cân nhắc.</p><h1 id="5-meo-de-viet-code-bat-dong-bo-vua-chac-chan-vua-de-bao-tri"><a href="#5-meo-de-viet-code-bat-dong-bo-vua-chac-chan-vua-de-bao-tri" class="headerlink" title="5 mẹo để viết code bất đồng bộ vừa chắc chắn vừa dễ bảo trì"></a>5 mẹo để viết code bất đồng bộ vừa chắc chắn vừa dễ bảo trì</h1><h3 id="1-Clean-code-code-sach"><a href="#1-Clean-code-code-sach" class="headerlink" title="1. Clean code (code sạch):"></a>1. <strong>Clean code (code sạch)</strong>:</h3><p>Sử dụng async/await cho phép bạn viết code ít hơn nhiều. Mỗi lần sử dụng async/await bạn có thể bỏ qua một số bước không cần thiết, ví dụ: .then(), viết hàm anonymous để xử lý responsive, đặt tên response từ callback…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `rp` là một hàm gọi promise</span></span><br><span class="line">rp(‘https:<span class="comment">//api.example.com/endpoint1').then(function(data) &#123;</span></span><br><span class="line"> <span class="comment">// …</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>…so với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `rp` là một hàm gọi promise</span></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> rp(‘https:<span class="comment">//api.example.com/endpoint1');</span></span><br></pre></td></tr></table></figure><h3 id="2-Xu-ly-loi"><a href="#2-Xu-ly-loi" class="headerlink" title="2. Xử lý lỗi:"></a>2. <strong>Xử lý lỗi</strong>:</h3><p>Async/await giúp chúng ta có thể xử lý cả lỗi đồng bộ và bất đồng bộ với cùng một cấu trúc code: chính là try/catch nổi tiếng. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// Catches synchronous errors.</span></span><br><span class="line">        getJSON().then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> parsed = <span class="built_in">JSON</span>.parse(response);</span><br><span class="line">            <span class="built_in">console</span>.log(parsed);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// Catches asynchronous errors</span></span><br><span class="line">            <span class="built_in">console</span>.log(e); </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…so với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">await</span> getJSON());</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Dieu-kien"><a href="#3-Dieu-kien" class="headerlink" title="3. Điều kiện:"></a>3. <strong>Điều kiện</strong>:</h3><p>Viết code điều kiện với async/await rõ ràng hơn rất nhiều:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response.needsAnotherRequest) &#123;</span><br><span class="line">        <span class="keyword">return</span> makeAnotherRequest(response)</span><br><span class="line">          .then(<span class="function"><span class="keyword">function</span>(<span class="params">anotherResponse</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(anotherResponse)</span><br><span class="line">            <span class="keyword">return</span> anotherResponse</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…so với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> response = <span class="keyword">await</span> getJSON();</span><br><span class="line">  <span class="keyword">if</span> (response.needsAnotherRequest) &#123;</span><br><span class="line">    <span class="keyword">var</span> anotherResponse = <span class="keyword">await</span> makeAnotherRequest(response);</span><br><span class="line">    <span class="built_in">console</span>.log(anotherResponse)</span><br><span class="line">    <span class="keyword">return</span> anotherResponse</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="keyword">return</span> response;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Stack-Frames"><a href="#4-Stack-Frames" class="headerlink" title="4. Stack Frames:"></a>4. <strong>Stack Frames</strong>:</h3><p>Không giống như async/await, stack lỗi trả về từ một chuỗi promise làm chúng ta không biết lỗi xuất phát từ đâu mà lần:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> callAPromise()</span><br><span class="line">    .then(callback1)</span><br><span class="line">    .then(callback2)</span><br><span class="line">    .then(callback3)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"boom"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">loadData()</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line"><span class="comment">// Error: boom at callAPromise.then.then.then.then (index.js:8:13)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>…so với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> callAPromise1()</span><br><span class="line">  <span class="keyword">await</span> callAPromise2()</span><br><span class="line">  <span class="keyword">await</span> callAPromise3()</span><br><span class="line">  <span class="keyword">await</span> callAPromise4()</span><br><span class="line">  <span class="keyword">await</span> callAPromise5()</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"boom"</span>);</span><br><span class="line">&#125;</span><br><span class="line">loadData()</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="comment">// Error: boom at loadData (index.js:7:9)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-Qua-trinh-Debug"><a href="#5-Qua-trinh-Debug" class="headerlink" title="5. Quá trình Debug:"></a>5. <strong>Quá trình Debug</strong>:</h3><p>Nếu bạn đã từng sử dụng promise, bạn sẽ biết rằng debug với chúng thực sự là ác mộng. Giả sử bạn đặt breakpoint bên trong .then() và dùng những lệnh debug như stop-over, debugger sẽ không đi đến .then() tiếp theo bởi vì nó “lỡ chân” bước vào code bất đồng bộ.<br>Với async/await bạn có thể duyệt qua những lời gọi await chính xác như những hàm đồng bộ thông thường.</p><p><strong>Viết code Javascript bất đồng bộ là rất quan trọng không chỉ cho app mà cả cho những thư viện nữa</strong>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 4 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Lần này chúng ta sẽ mở rộng những gì có trong bài đầu tiên bằng cách đánh giá những nhược điểm của môi trường đơn luồng (single thread) và làm thế nào để vượt qua chúng nhằm xây dựng những Javascript UI ấn tượng. Và vẫn như cũ, cuối bài viết tác giả sẽ chia sẻ 5 mẹo nhỏ để viết code tốt hơn với async/await.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P3: Quản lý bộ nhớ &amp; 4 trường hợp memory leaks phổ biến</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P3-Quan-ly-bo-nho-4-truong-hop-memory-leaks-pho-bien.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P3-Quan-ly-bo-nho-4-truong-hop-memory-leaks-pho-bien.html</id>
    <published>2018-11-13T16:03:00.000Z</published>
    <updated>2018-11-13T16:05:48.137Z</updated>
    
    <content type="html"><![CDATA[<p>Mấy hôm trước chúng ta đã bắt đầu series bài viết đục khoét về Javascript và cách nó hoạt động như thế nào, bằng cách hiểu về những thành phần cơ bản và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và <em>ngon</em> hơn.</p><p>Bài đầu tiên là tổng quan về series, cung cấp cái nhìn toàn cảnh về engine, runtime &amp; callstack. Bài thứ 2 là một cái nhìn cụ thể hơn về những thành phần bên trong của bộ engine V8 của Google và một số mẹo vặt để tối ưu Javascript code.</p><p>Ở bài thứ 3 này, chúng ta sẽ thảo luận về một vấn đề không kém phần quan trọng nhưng lại thường bị các dev bỏ qua do sự phức tạp ngày càng gia tăng của các ngôn ngữ lập trình thường dùng: quản lý bộ nhớ. Chúng ta cũng sẽ tìm hiểu một số mẹo để có thể xử lý những trường hợp rò rì bộ nhớ của Javascript mà team SesstionStack đã áp dụng để tránh bị rò rỉ và không làm tốn bộ nhớ của webapp.<br><a id="more"></a></p><h1 id="Tong-quan"><a href="#Tong-quan" class="headerlink" title="Tổng quan"></a>Tổng quan</h1><p>Những ngôn ngữ như C có bộ quản lý bộ nhớ level thấp khá cơ bản là malloc() và free(). Những phương thức này được sử dụng để cấp phát một cách tường minh và giải phóng bộ nhớ trên hệ điều hành.</p><p>Một cách tương tự, Javascript cấp phát bộ nhớ khi object, string, … được tạo ra và <em>tự động</em> giải phóng nó mỗi khi không được sử dụng nữa bởi một tiến trình dọn rác (garbage collection). Quá trình giải phóng tài nguyên một cách <em>tự động hóa</em> như thế này gây ra sự nhầm lẫn và làm cho Javascript (và những ngôn ngữ bậc cao khác) developer cảm thấy “ấn tượng” nên họ thường bỏ qua vấn đề quản lý bộ nhớ. <strong>Đây là một sai lầm lớn.</strong></p><p>Kể cả khi làm việc với ngôn ngữ bậc cao, developer cũng nên hiểu về vấn đề quản lý bộ nhớ (ít nhất là những thứ cơ bản). Thỉnh thoảng có những vấn đề xảy ra với quản lý bộ nhớ tự động (bug hay sự giới hạn thực hiện trong GC…) mà developer cần phần hiểu để có thể xử lý một cách đúng đắn (hoặc tìm cách “đi đường vòng” vượt qua nó với ít thiệt hại nhất).</p><h1 id="Vong-doi-cua-bo-nho"><a href="#Vong-doi-cua-bo-nho" class="headerlink" title="Vòng đời của bộ nhớ"></a>Vòng đời của bộ nhớ</h1><p>Dù cho bạn đang dùng ngôn ngữ lập trình nào đi nữa thì vòng đời bộ nhớ hầu như đều giống nhau:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*slxXgq_TO38TgtoKpWa_jQ.png" alt=""></p><p>Đây là những gì xảy ra ở mỗi bước trong vòng đời:</p><ul><li><p><strong>Cấp phát bộ nhớ</strong>: bộ nhớ được cấp phát bởi hệ điều hành và cho phép chương trình sử dụng nó. Ở ngôn ngữ bậc thấp (như C), đây là một quá trình tường minh, rõ ràng mà developer phải xử lý. Trong các ngôn ngữ bậc cao thì phần này ngôn ngữ sẽ làm giúp bạn.</p></li><li><p><strong>Sử dụng bộ nhớ</strong>: Đây là thời điểm khi chương tình của bạn sử dụng những vùng nhớ đã được cấp phát trước đó. Các thao tác Đọc và Ghi được thực hiện khi chúng ta thực thi những biến đã được khai báo trong code.</p></li><li><p><strong>Giải phóng bộ nhớ</strong>: Giờ là lúc giải phóng toàn bộ những vùng nhớ mà bạn không còn dùng đến nữa để sử dụng lại về sau. Giống như phần cấp phát, bước này được thực hiện một cách tường minh trong các ngôn ngữ bậc thấp.</p></li></ul><p>Để hiểu thêm về các khái niệm của callstack và heap thì mời bạn xem lại <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-1---Khai-quat-ve-engine--runtime-va-callstack" target="_blank" rel="noopener">Phần 1</a> của series.</p><h1 id="Bo-nho-la-gi"><a href="#Bo-nho-la-gi" class="headerlink" title="Bộ nhớ là gì?"></a>Bộ nhớ là gì?</h1><p>Trước khi đi sâu vào bộ nhớ của Javascript, chúng ta sẽ duyệt sơ qua bộ nhớ cơ bản và cách hoạt động của nó.</p><p>Ở phần cứng, bộ nhớ máy tính bao gồm một cơ số các <a href="https://vi.wikipedia.org/wiki/Flip-flop" target="_blank" rel="noopener">flip flops</a> (đại khái là 1 trạng thái đóng-mở). Mỗi flip-flop chứa một vài transistor và có thể lưu trữ 1 bit thông tin. Một flip-flop độc lập có thể được truy xuất bằng số định danh duy nhất (<strong>unique identifier</strong>), do đó chúng ta có thể đọc và ghi lên chúng. Và lẽ dĩ nhiên, về mặt ý tưởng chúng ta có thể công nhận rằng toàn bộ bộ nhớ máy tính là 1 mảng khổng lồ các bit có thể đọc &amp; ghi.</p><p>Về phần con người thì họ không giỏi làm việc với bit nên tổ chức chúng vào những nhóm lớn hơn, 8 bit thành 1 byte. Ngoài byte còn có word (16 hoặc 32 bit)</p><p>Có rất nhiều thứ được lưu trữ trong bộ nhớ:</p><ol><li>Tất cả các biến và dữ liệu được sử dụng trong các chương trình.</li><li>Code của chương trình chạy, kể cả code của hệ điều hành.</li></ol><p>Trình biên dịch và hệ điều hành làm việc với nhau để xử lý hầu như toàn bộ phần quản lý bộ nhớ nhưng chúng tôi khuyến cáo bạn nên có cái nhìn sơ lược về những gì xảy ra ở nội bộ bên trong.</p><p>Khi biên dịch code, trình biên dịch sẽ xem xét các kiểu dữ liệu nguyên thủy (string, number, boolean…) và tính toán trước bao nhiêu bộ nhớ mà chúng cần sử dụng. Lượng bộ nhớ cần thiết sau đó sẽ được cấp phát cho chương tình trong không gian callstack. Vùng không gian được cấp phát được gọi là stack space bởi vì khi gọi hàm, bộ nhớ của nó được thêm vào vị trí trên cùng của bộ nhớ hiện tại. Và khi hủy bỏ, chúng bị gỡ bỏ theo quy tắc LIFO (last-in-first-out, vào sau ra trước). Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n; <span class="comment">// 4 bytes</span></span><br><span class="line">int x[<span class="number">4</span>]; <span class="comment">// mảng 4 phần tử, mỗi phần tử 4 bytes</span></span><br><span class="line">double m; <span class="comment">// 8 bytes</span></span><br></pre></td></tr></table></figure><p>Trình biên dịch sẽ tính toán ngay lập tức đoạn code này cần 4 + 4 * 4 + 8 = 28 bytes</p><blockquote><p>Đó là cách hoạt động của kích thước vùng nhớ cho kiểu số integer và double. Khoảng 20 năm trước, integer là 2 byte và double là 4 byte. Code của bạn không phải phụ thuộc vào kích thước của các kiểu dữ liệu cơ bản.</p></blockquote><p>Trình biên dịch sẽ chèn code tương tác với hệ điều hành để yêu cầu số lượng byte cần thiết để lưu trữ các biến.</p><p>Trong ví dụ trên, trình biên dịch biết chính xác bao nhiêu bộ nhớ cần thiết cho mỗi biến. Thực tế thì mỗi khi ghi dữ liệu vào biến n, nó sẽ được dịch nội bộ thành mộ thứ đại loại như “địa chỉ vùng nhớ 4127963”</p><p>Để ý rằng nếu ta thử truy xuất x[4] thì ta sẽ truy xuất nhầm sang dữ liệu đang liên kết với m. Bởi vì chúng ta đang cố truy xuất vào một phần tử không tồn tại trong mảng: 4 byte này nằm ngoài vùng x[3] vốn là vùng nhớ được cấp phát cuối cùng của mảng (index đánh từ 0 :v), và vậy là có thể ta đọc/ghi nhầm sang các bit của biến m. Điều này có thể gây ra nhiều hậu quả không mong muốn cho toàn bộ chương trình. Xem hình cho rõ hơn nhé:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*5aBou4onl1B8xlgwoGTDOg.png" alt=""></p><p>Khi một hàm gọi một hàm khác thì mỗi hàm sẽ chiếm một phần của stack. Phần đó sẽ lưu giữ tất cả những biến cục bộ cũng như một bộ đếm để ghi nhớ vị trí mà quá trình thực thi của hàm dừng lại. Khi hàm kết thúc thì vùng bộ nhớ lại được giải phóng cho thằng khác dùng.</p><h1 id="Cap-phat-dong"><a href="#Cap-phat-dong" class="headerlink" title="Cấp phát động"></a>Cấp phát động</h1><p>Thật không may là mọi thứ dường như không dễ như ta tưởng khi mà ta không biết bao nhiêu bộ nhớ 1 biến có thể cần tại thời điểm thực thi. Giả sử chúng ta muốn làm như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n = readInput(); <span class="comment">// đọc input từ người dùng</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// tạo 1 mảng với "n" phần tử</span></span><br></pre></td></tr></table></figure><p>Tại thời điểm biên dịch, trình biên dịch không biết mảng sẽ cần bao nhiêu bộ nhớ bởi vì nó được xác định bởi dữ liệu nhập vào từ phía người dùng.</p><p>Vì thế nó không thể cấp phát vùng nhớ cho biến trên stack. Thay vì thế, chương trình của chúng ta cần hỏi hệ điều hành về kích thước bộ nhớ phù hợp trong khi thực thi (run-time). Vùng nhớ này được gán từ không gian <em>heap</em>. Sự khác biệt giữa cấp phát bộ nhớ động và tĩnh được tổng kết trong bảng sau:</p><table><thead><tr><th>Cấp phát tĩnh</th><th>Cấp phát động</th></tr></thead><tbody><tr><td>Biết kích thước tại thời điểm biên dịch.</td><td>Không biết kích thức lúc biên dịch</td></tr><tr><td>Thực hiện lúc biên dịch</td><td>Thực hiện lúc thực thi (runtime)</td></tr><tr><td>Gán vào stack</td><td>Gán vào heap</td></tr><tr><td>Gán theo thứ tự FILO (first-in-last-out)</td><td>Gán không theo thứ tự cụ thể nào cả</td></tr></tbody></table><p>Để có thể có cái nhìn sâu sắc về cấp phát bộ nhớ động, có thể chúng ta cần dành thêm thời gian tìm hiểu về <strong>con trỏ</strong>, nhưng như vậy thì hơi bị lạc đề. Nếu bạn thấy có hứng thú với chủ đề này thì xin lỗi phải hẹn bạn trong 1 bài viết khác rồi.</p><h1 id="Cap-phat-trong-Javascript"><a href="#Cap-phat-trong-Javascript" class="headerlink" title="Cấp phát trong Javascript"></a>Cấp phát trong Javascript</h1><p>Javascript giúp developer giảm bớt trách nhiệm trong việc cấp phát bộ nhớ. JS tự làm hết mọi thứ.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">374</span>; <span class="comment">// cấp phát bộ nhớ cho số</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'sessionstack'</span>; <span class="comment">// cấp phát cho string </span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// cấp phát cho object và các thuộc tính của nó</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">'str'</span>];  <span class="comment">// (giống như object) cấp phát cho</span></span><br><span class="line">                           <span class="comment">// mảng và các giá tị của nó</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">3</span>;</span><br><span class="line">&#125; <span class="comment">// cấp phát cho hàm (là 1 object có thể thực thi)</span></span><br><span class="line"><span class="comment">// function expressions cũng cấp phát object</span></span><br><span class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>Một vài lời gọi hàm cũng trả về dạng cấp phát object:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// cấp phát Date object</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">// cấp phát 1 phần tử DOM</span></span><br></pre></td></tr></table></figure><p>Phương thức có thể cấp phát giá trị hoặc object:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'sessionstack'</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substr(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 là 1 string mới</span></span><br><span class="line"><span class="comment">// Bởi vì string là bất biến, </span></span><br><span class="line"><span class="comment">// JavaScript có thể chọn không cấp phát bộ nhớ</span></span><br><span class="line"><span class="comment">// mà lưu trữ phạm vi [0, 3]</span></span><br><span class="line"><span class="keyword">var</span> a1 = [<span class="string">'str1'</span>, <span class="string">'str2'</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="string">'str3'</span>, <span class="string">'str4'</span>];</span><br><span class="line"><span class="keyword">var</span> a3 = a1.concat(a2); </span><br><span class="line"><span class="comment">// mảng mới gồm 4 phần tử là</span></span><br><span class="line"><span class="comment">// sự kết hợp của mảng a1 và a2</span></span><br></pre></td></tr></table></figure><h1 id="Su-dung-bo-nho-trong-Javascript"><a href="#Su-dung-bo-nho-trong-Javascript" class="headerlink" title="Sử dụng bộ nhớ trong Javascript"></a>Sử dụng bộ nhớ trong Javascript</h1><p>Sử dụng bộ nhớ đã được cấp phát trong Javascript có thể gói gọn một cách đơn giản trong 2 chữ <strong>đọc/ghi</strong></p><p>Việc này có thể thực hiện bằng cách đọc/ghi giá trị của biến hoặc thuộc tính của object hoặc truyền đối số (argument) vào 1 hàm.</p><h1 id="Giai-phong-khi-khong-dung-bo-nho-nua"><a href="#Giai-phong-khi-khong-dung-bo-nho-nua" class="headerlink" title="Giải phóng khi không dùng bộ nhớ nữa"></a>Giải phóng khi không dùng bộ nhớ nữa</h1><p>Đa số các phần đề về quản lý bộ nhớ xảy ra ở giai đoạn này.</p><p>Công việc khó nhất ở đây là tìm hiểu khi nào bộ nhớ đã được cấp phát có còn được sử dụng hay không. Thường thì nó yêu cầu developer xác định vùng nhớ nào trong chương trình không dùng nữa và giải phóng nó.</p><p>Ngôn ngữ bậc cao thêm vào 1 chương tình gọi là bộ dọn rác (garbage collector - GC) thực hiện công việc đi tìm những vùng nhớ đã được cấp phát và tìm hiểu xem nó còn được sử dụng hay không, nếu không dùng nữa thì sẽ tự động giải phóng nó.</p><p>Điều hơi chuối là tiến trình này chỉ tương đối đúng, bởi vì vấn đề tổng quát về việc xác định một vùng nhớ có còn được sử dụng hay không là bất khả thi (không thể thực hiện bằng thuật toán).</p><p>Đa số GC hoạt động bằng cách thu thập những vùng nhớ không còn bị truy xuất đến, ví dụ: tất cả biến đang trỏ đến nó đều đi ra khỏi phạm vi thực thi. Tuy nhiên, điều này cũng lại không hẳn là chính xác vì tại bất kỳ thời điểm nào một địa chỉ vùng nhớ đều có thể được trỏ tới bởi 1 biến, nhưng biến đó lại không bao giờ được sử dụng nữa.</p><h1 id="Qua-trinh-don-rac"><a href="#Qua-trinh-don-rac" class="headerlink" title="Quá trình dọn rác"></a>Quá trình dọn rác</h1><p>Rõ ràng cách thức để tìm được vùng nhớ “không còn dùng nữa” là bất khả thi cho nên GC thực hiện một giải pháp hạn chế cho vấn đề chung. Phần này sẽ giải thích những khái niệm cần thiết để bạn có thể hiểu được những thuật toán GC và các giới hạn của chúng.</p><h2 id="Tham-chieu-bo-nho"><a href="#Tham-chieu-bo-nho" class="headerlink" title="Tham chiếu bộ nhớ"></a>Tham chiếu bộ nhớ</h2><p>Ý tưởng chính của những thuật toán GC dựa trên <strong>tham chiếu</strong></p><p>Trong ngữ cảnh quản lý bộ nhớ, một object A tham chiếu đến object B khác nếu như A có truy xuất đến B (có thể tường minh hoặc không tường minh). Ví dụ: một Javascript object có tham chiếu đến prototype của chính nó (<strong>không tường minh</strong>) và tham chiếu đến giá trị của thuộc tính của nó (<strong>tường minh</strong>).</p><p>Trong trường hợp này, khái niệm của 1 “object” được mở rộng thành một thứ gì đó hơn là JS object thông thường và bao trùm cả function scope (hoặc là lexical scope toàn cục).</p><blockquote><p>Lexical scoping định nghĩa cách mà những tên biến được phân giải trong các hàm lồng nhau: những hàm con chưa scope của hàm cha kể cả khi hàm cha đã được return.</p></blockquote><h2 id="Bo-dem-tham-chieu"><a href="#Bo-dem-tham-chieu" class="headerlink" title="Bộ đếm tham chiếu"></a>Bộ đếm tham chiếu</h2><p>Đây là thuật toán dọn rác đơn giản nhất. Một object được đánh giá là “rác có thể dọn” nếu như không có tham chiếu nào trỏ đến nó.</p><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  o2: &#123;</span><br><span class="line">    x: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Tạo 2 object</span></span><br><span class="line"><span class="comment">// 'o1' tham chiếu đến 'o2' vì nó là 1 thuộc tính của 'o1'</span></span><br><span class="line"><span class="comment">// Hiện tại không có rác để dọn.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o3 = o1; <span class="comment">// biến 'o3' đang tham chiếu tới cùng 1 object với 'o1'</span></span><br><span class="line"></span><br><span class="line">o1 = <span class="number">1</span>;      <span class="comment">// giờ thì object được tham chiếu trước đó bởi 'o1'         </span></span><br><span class="line">            <span class="comment">// chỉ còn lại 1 tham chiếu duy nhất là 'o3'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o4 = o3.o2; <span class="comment">// tham chiếu đến thuộc tính 'o2'</span></span><br><span class="line">                <span class="comment">// object này giờ có 2 tham chiếu: </span></span><br><span class="line">                <span class="comment">// một là thuộc tính của 'o3': o3.o2</span></span><br><span class="line">                <span class="comment">// hai là biến 'o4'</span></span><br><span class="line"></span><br><span class="line">o3 = <span class="string">'374'</span>; <span class="comment">// Giờ thì object trước đây là của o1 không còn tham chiếu nữa.</span></span><br><span class="line">            <span class="comment">// Nó có thể bị dọn dẹp bởi GC </span></span><br><span class="line">            <span class="comment">// Tuy nhiên thuộc tính 'o2' của nó thì vẫn còn</span></span><br><span class="line">            <span class="comment">// được tham chiếu bởi biến 'o4' nên chưa bị dọn</span></span><br><span class="line"></span><br><span class="line">o4 = <span class="literal">null</span>; <span class="comment">// thuộc tính 'o2' trước đây trong 'o1' giờ</span></span><br><span class="line">           <span class="comment">// đã không còn gì tham chiếu đến nó</span></span><br><span class="line">           <span class="comment">// lần này thì GC có thể dọn nó được rồi.</span></span><br></pre></td></tr></table></figure><h2 id="Van-de-tu-tham-chieu-vong-tron"><a href="#Van-de-tu-tham-chieu-vong-tron" class="headerlink" title="Vấn đề từ tham chiếu vòng tròn"></a>Vấn đề từ tham chiếu vòng tròn</h2><p>Có một số giới hạn liên quan đến tham chiếu vòng tròn. Trong ví dụ sau, 2 object được tạo ra và được tham chiếu lẫn nhau, tạo thành 1 vòng tròn. Chúng sẽ được đẩy ra ngoài scope sau khi hàm kết thúc nên về mặt lý thuyết thì chúng vô dụng và có thể được giải phóng. Tuy nhiên, thuật toán đếm tham chiếu xem xét rằng mỗi object đều đang có ít nhất 1 tham chiếu đến object đó nên thuật toán sẽ bỏ qua mà không dọn dẹp.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o1.p = o2; <span class="comment">// o1 tham chiếu đến o2</span></span><br><span class="line">  o2.p = o1; <span class="comment">// o2 tham chiếu đến o1\. </span></span><br><span class="line">            <span class="comment">// 2 thanh niên này tạo thành 1 vòng tròn tham chiếu.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1000/1*GF3p99CQPZkX3UkgyVKSHw.png" alt=""></p><h2 id="Thuat-toan-Danh-dau-va-don-dep-Mark-and-sweep"><a href="#Thuat-toan-Danh-dau-va-don-dep-Mark-and-sweep" class="headerlink" title="Thuật toán Đánh dấu và dọn dẹp (Mark-and-sweep)"></a>Thuật toán Đánh dấu và dọn dẹp (Mark-and-sweep)</h2><p>Để xác định xem object có còn cần thiết không thì thuật toán này thử xem object đó có thể truy cập tới hay không.</p><p>Thuật toán <strong>Mark-and-sweep</strong> có 3 bước:</p><ol><li><strong>Roots</strong>: Nhìn chung, <em>roots</em> là những biến toàn cục (global) được tham chiếu đến trong code. Với Javascript, một biến toàn cục có vai trò như 1 <em>root</em> chính là object <strong>window</strong>. Trong Node.js thì nó gọi là <strong>global</strong>. Danh sách hoàn chỉnh các <em>roots</em> được xây dựng bởi GC.</li><li>Thuật toán sẽ điều tra tất cả các <em>roots</em> và con cháu (children) của nó rồi đánh dấu chúng là đang hoạt động (active) (nghĩa là, chúng không phải rác). Thứ gì mà không phải con cháu của root, root không truy xuất đến được thì đều bị coi là <em>rác</em>.</li><li>Cuối cùng, GC sẽ giải phóng các vùng nhớ không được đánh dấu <em>active</em> và trả bộ nhớ lại cho hệ điều hành.</li></ol><p><img src="https://cdn-images-1.medium.com/max/1000/1*WVtok3BV0NgU95mpxk9CNg.gif" alt=""></p><p>Thuật toán này tốt hơn thuật toán trước vì “đối tượng không có tham chiếu” dẫn tới trường hợp đối tượng không thể truy cập, ở hướng ngược lại thì nó giải quyết được vấn đề của tham chiếu vòng tròn.</p><p>Năm 2012, tất cả trình duyệt hiện đại đều tích hợp sẵn bộ GC Mark-and-sweep. Những cải tiến dành cho bộ Javascript GC (như GC Thế hệ (Generational)/ Gia tăng (Incremental)/ Đồng thời (Concurrent)/ Song song (Parallel)) trong những năm gần đây đều là những nâng cấp của thuật toán Mark-and-sweep, nhưng không phải là cải tiến thuật toán GC, cũng không phải quyết định xem 1 object có thể truy cập được hay là không.</p><p><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">Trong bài viết này</a>, bạn có thể tìm hiểu chi tiết hơn về quá trình truy tìm rác, nó cũng bao gồm luôn cả thuật toán Mark-and-sweep và cách tối ưu hóa của nó.</p><h2 id="Tham-chieu-vong-tron-chi-la-muoi"><a href="#Tham-chieu-vong-tron-chi-la-muoi" class="headerlink" title="Tham chiếu vòng tròn chỉ là muỗi"></a>Tham chiếu vòng tròn chỉ là muỗi</h2><p>Trong ví dụ đầu tiên, sau khi hàm được trả về, 2 object đều không được tham chiếu đến bởi một object có thể truy cập được từ đối tượng toàn cục. Một lẽ dĩ nhiên, thì chúng sẽ bị GC đánh dấu và dọn sạch sẽ.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*FbbOG9mcqWZtNajjDO6SaA.png" alt=""></p><p>Mặc dù giữa 2 object đều có tham chiếu lẫn nhau nhưng chúng không thể truy cập được từ <em>root</em></p><h2 id="Hanh-vi-phan-truc-quan-cua-GC"><a href="#Hanh-vi-phan-truc-quan-cua-GC" class="headerlink" title="Hành vi phản trực quan của GC"></a>Hành vi phản trực quan của GC</h2><p>Mặc dù GC rất tiện lợi nhưng chúng cũng đi kèm với những khuyết điểm. Một trong số đó là sự <em>không xác định được</em>. Nói cách khác, GC là không thể đoán trước được. Ta không thể biết rõ khi nào thì GC được thực thi. Có nghĩa là trong một vài trường hợp chương trình sử dụng nhiều bộ nhớ hơn số lượng mà chúng cần. Trong trường hợp khác, những thời điểm tạm dừng ngắn hạn (short-pauses) có thể đáng được chú ý trong một số ứng dụng đặc biệt nhạy cảm.<br>Mặc dù <em>không xác định được</em> nghĩa là không biết khi nào GC sẽ chạy, đa số GC đều dùng chung một mô hình thu thập trong quá trình cấp phát. Nếu như cấp phát không chạy, hầu như GC cũng không chạy. Cần cân nhắc trường hợp sau:</p><ol><li>Cấp phát một số lược bộ nhớ lớn.</li><li>Đa số các phần tử này (hoặc toàn bộ) đều được đánh dấu là không thể truy cập (Giả sử chúng ta vô hiệu hóa một tham chiếu đang trỏ đến bộ nhớ cache mà chúng ta không cần nữa.)</li><li>Không có cấp phát nào được thực thi nữa.</li></ol><p>Trong trường hợp này, đa số các GC sẽ không chạy bất kỳ một thu gom nào. Nói cách khác, mặc dù có những tham chiếu không thể truy cập được đang tồn tại nhưng chúng lại không được GC “để mắt” đến. Đây không phải là một loại rò rỉ nghiêm trọng nhưng dĩ nhiên nó vẫn sử dụng bộ nhớ nhiều hơn bình thường.</p><h1 id="Ro-ri-bo-nho-la-gi"><a href="#Ro-ri-bo-nho-la-gi" class="headerlink" title="Rò rỉ bộ nhớ là gì ?"></a>Rò rỉ bộ nhớ là gì ?</h1><p>Nếu bạn đọc hết những phần ở trên thì cũng dễ hiểu thôi, rò rỉ bộ nhớ là những vùng nhớ được cấp phát và sử dụng trong chương trình nhưng sau đó, khi không còn dùng nữa, chúng vẫn không được giải phóng và trả về cho hệ điều hành hoặc là kho chứa bộ nhớ.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg" alt=""></p><p>Các ngôn ngữ lập trình có nhiều cách khác nhau để quản lý bộ nhớ. Tuy nhiên, một vùng nhớ cụ thể được dùng hay không thực sự là <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Release_when_the_memory_is_not_needed_anymore" target="_blank" rel="noopener">vấn đề khó đoán</a>. Nói cách khác, chỉ có developer mới biết khi nào thì một vùng nhớ nên được giải phóng và trả lại cho hệ điều hành.</p><p>Những ngôn ngữ lập trình cung cấp các tính năng giúp developer làm việc này. Trong khi một số ngôn ngữ khác muốn developer hiểu tường tận về việc khi nào thì 1 vùng nhớ không được sử dụng nữa. Wikipedia có bài viết hay về việc quản lý bộ nhớ <a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" target="_blank" rel="noopener">tự động</a> và <a href="https://en.wikipedia.org/wiki/Manual_memory_management" target="_blank" rel="noopener">bằng tay</a>, bạn có thể xem qua.</p><h2 id="4-loai-ro-ri-pho-bien-trong-Javascript"><a href="#4-loai-ro-ri-pho-bien-trong-Javascript" class="headerlink" title="4 loại rò rỉ phổ biến trong Javascript"></a>4 loại rò rỉ phổ biến trong Javascript</h2><h3 id="1-Bien-toan-cuc"><a href="#1-Bien-toan-cuc" class="headerlink" title="1. Biến toàn cục"></a>1. Biến toàn cục</h3><p>Javascript xử lý những biến không được khai báo một cách khá thú vị: khi một biến không được khai báo được tham chiếu đến thì một biến mới sẽ được tạo ra trong object toàn cục (global). Trên trình duyệt thì tên của nó là <strong>window</strong>, nghĩa là đoạn này</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    bar = <span class="string">"some text"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…tương đương với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.bar = <span class="string">"some text"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Giả sử mục đích của bar chỉ để tham chiếu đến 1 biến trong hàm foo thì một biến toàn cục dư thừa lúc này đã được tạo ra bởi vì ta định nghĩa bar mà không dùng var. Ở ví dụ trên, nó không gây ra nhiều tổn hại, nhưng dĩ nhiên bạn có thể tưởng tượng ra bối cảnh đáng lo ngại hơn nhiều. Ví dụ như gán 1 object phức tạp trong bar chẳng hạn.</p><p>Thỉnh thoảng bạn cũng có thể vô tình tạo biến toàn cục bằng this:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.var1 = <span class="string">"potential accidental global"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// trong hàm foo() ở đây thì "this" đang trỏ tới biến toàn cục </span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>Bạn có thể tránh trường hợp đáng tiếc này bằng cách thêm dòng use strict vào đầu file Javascript, nó sẽ, nói nôm na, là bật chế độ “nghiêm túc” lên khi phân tích cú pháp (parse) code JS và sẽ ngăn chặn trường hợp vô tình tạo biến toàn cục.</p><p>Những biến toàn cục ngoài dự tính như trên rõ ràng là 1 vấn đề, tuy nhiên, thường thì code của bạn sẽ bị “nhiễm độc” bởi những biến toàn cục tường minh mà những biến đó lại không thể thu thập bởi GC. Đặc biệt chú ý đến các biến toàn cục thường được dùng để lưu trữ tạm thời và xử lý 1 số lượng lớn thông tin. Sử dụng biến toàn cục để lưu trữ dữ liệu nếu bạn <strong>phải</strong> làm thế, nhưng nhớ kỹ là gán nó bằng null hoặc gán lại 1 giá trị khác khi đã xong việc với nó.</p><h3 id="2-Timers-hoac-callbacks-bi-bo-quen"><a href="#2-Timers-hoac-callbacks-bi-bo-quen" class="headerlink" title="2. Timers hoặc callbacks bị bỏ quên"></a>2. Timers hoặc callbacks bị bỏ quên</h3><p>Lần này ta lấy setInterval làm ví dụ vì nó thường được dùng trong JS.</p><p>Những thư viện có dùng callback cung cấp observer và các công cụ tương tự thường đảm bảo tham chiếu đến callback sẽ không thể truy cập được một khi instance của nó không thể truy cập được. Ví dụ dưới đây không phải hiếm:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverData = loadData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> renderer = <span class="built_in">document</span>.getElementById(<span class="string">'renderer'</span>);</span><br><span class="line">    <span class="keyword">if</span>(renderer) &#123;</span><br><span class="line">        renderer.innerHTML = <span class="built_in">JSON</span>.stringify(serverData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>); <span class="comment">// hàm sẽ được thực thi sau mỗi 5 giây.</span></span><br></pre></td></tr></table></figure><p>Đoạn code trên cho thấy hậu quả của việc sử dụng timer có tham chiếu đến node hay dữ liệu cũ, không còn dùng nữa.</p><p>Object renderer có thể được thay thế hoặc gỡ bỏ ở đâu đó trong quá trình thực thi, điều này làm cho hàm callback trong setInterval trở nên thừa thãi. Nếu điều này xảy ra, dù cho callback hay những thứ bên trong có đủ điều kiện để được dọn dẹp thì trước hết cái interval đó phải dừng lại trước đã (bỏi vì nó vẫn đang hoạt động mà). Dĩ nhiên nếu như serverData đang chứa hay đang xử lý cả 1 đống dữ liệu thì cũng không thể bị thu dọn được.</p><p>Khi sử dụng observer, bạn cần đảm bảo phải có một câu lệnh tường minh để gỡ bỏ chúng mỗi khi xong việc (Dù là observer đó không cần dùng nữa hay object không thể truy cập được).</p><p>May mắn thay, đa số các trình duyệt hiện đại đều làm giúp bạn việc đó rồi: chúng sẽ tự động thu thập các observer mỗi khi object trong đó trở nên không thể truy cập được kể cả nếu như bạn quên gỡ các listener. Trước đây, một số trình duyệt không làm được điều này (IE6 chẳng hạn).</p><p>Nhưng cách tốt nhất vẫn là gỡ bỏ observer khi đã xong việc với nó. Bạn xem ví dụ dưới đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'launch-button'</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">   counter++;</span><br><span class="line">   element.innerHtml = <span class="string">'text '</span> + counter;</span><br><span class="line">&#125;</span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, onClick);</span><br><span class="line"><span class="comment">// Do stuff </span></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>, onClick);</span><br><span class="line">element.parentNode.removeChild(element);</span><br><span class="line"><span class="comment">// Giờ thì "element" đã được đưa ra khỏi phạm vi thực thi,</span></span><br><span class="line"><span class="comment">// Cả "element" và "onClick" sẽ được dọn dẹp kể cả trên các trình duyệt cũ</span></span><br></pre></td></tr></table></figure><p>Bạn không càn phải gọi hàm removeEventListener trước khi làm cho node không thể truy cập được vì các trình duyệt hiện đại hỗ trợ GC có thể tự động xác định và xử lý chúng một cách thích hợp.</p><p>Nếu bạn dùng jQuery APIs (có nhiều thư viện và frameworks khác cũng hỗ trợ), bạn cũng có thể gỡ bỏ các listener trước khi node bị đưa vào “dĩ vãng” và không dùng nữa. Những thư viện cũng đảm bảo không có rò rỉ bộ nhớ kể cả khi ứng dụng của bạn chạy trên những trình duyệt cũ.</p><h3 id="3-Closures"><a href="#3-Closures" class="headerlink" title="3. Closures"></a>3. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">Closures</a></h3><p>Một phần quan trọng của Javascript chính là closure: một hàm con có thể truy xuất đến biến của hàm bên ngoài nó. Trong quá tình triển khai chi tiết môi trường thực thi (runtime) của JS thì có thể xảy ra tình trạng rò rỉ bộ nhớ với closure như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing) <span class="comment">// một tham chiếu đến 'originalThing'</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>Một khi replaceThing được gọi, theThing sẽ trở thành một object mới chứa 1 mảng rất lớn và 1 closure someMethod. Tuy nhiên, originalThing được tham chiếu bởi 1 closure mà nó lại nằm trong biến unused (chính là biến theThing từ lời gọi đến replaceThing trước đó). Nhớ rằng ở đây một khi <strong>phạm vi (scope) của closure được tạo ra cho closure trong cùng parent scope thì scope đó được dùng chung</strong>.</p><p>Trong trường hợp này, scope tạo ra cho closure someMethod được chia sẻ với unused. unused có tham chiếu đến originalThing. Mặc dù unused không bao giờ được dùng, someMehod có thể được sử dụng thông qua theThing bên ngoài scope của replaceThing (ví dụ: ở 1 nơi toàn cục nào đó). Và khi someMethod chia sẻ closure với unused, tham chiếu đến originalThing trong unused ép nó phải ở trong trạng thái hoạt động (toàn bộ scope chia sẻ giữa 2 closure). Điều này ngăn chặn GC hoạt động.</p><p>Trong ví dụ trên, scope được tạo ra cho closure someMethod được chia sẻ với unused, trong khi unused tham chiếu tới originalThing. someMethod có thể được gọi thông qua theThing bên ngoài scope của replaceThing, mặc dù sự thật là unused không bao giờ được sử dụng. Rõ ràng unused tham chiếu đến originalThing yêu cầu nó phải giữ trạng thái đang hoạt động bởi vì someMethod chia sẻ closure scope với unused.</p><p>Tất cả những điều này có thể làm bộ nhớ bị rò rỉ đáng kể. Bạn có thể thấy biểu đồ sử dụng bộ nhớ dâng lên cao ngất khi đoạn code trên bị lặp đi lặp lại. Kích thước của nó không bị giảm đi khi GC hoạt động. Một danh sách liên kết các closure được tạo ra (root của nó là theThing) và mỗi closure scope lại chưa một tham chiếu gián tiếp tới mảng khổng lồ.</p><p>Vấn đề này được tìm thấy bởi Meteor team và họ có <a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" target="_blank" rel="noopener">1 bài viết cụ thể mô tả về nó ở đây</a>.</p><h3 id="4-Tham-chieu-ngoai-DOM"><a href="#4-Tham-chieu-ngoai-DOM" class="headerlink" title="4. Tham chiếu ngoài DOM"></a>4. Tham chiếu ngoài DOM</h3><p>Có những trường hợp mà developer lưu trữ DOM node bên trong cấu trúc dữ liệu. Giả sử bạn muốn cập nhật một cách nhanh chóng dữ liệu của nhiều row trong 1 table. Nếu bạn lưu tham chiếu đến mỗi DOM row trong 1 dictionary hay mảng, sẽ có 2 tham chiếu đến cùng 1 phần tử DOM: 1 là từ cây DOME, và 1 là từ dictionary. Nếu bạn chọn lựa xóa bỏ những row này, bạn cũng phải nhớ làm cho 2 tham chiếu trên không thể truy cập được.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">    button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</span><br><span class="line">    image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    elements.image.src = <span class="string">'http://example.com/image_name.png'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Cái ảnh là 1 node con trực tiếp của body</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'image'</span>));</span><br><span class="line">    <span class="comment">// Ở thời điểm này ta vẫn có 1 tham chiếu đến #button trong </span></span><br><span class="line">    <span class="comment">// biến toàn cục "element". Nói cách khác, "button" vẫn còn nằm</span></span><br><span class="line">    <span class="comment">// trong bộ nhớ và GC không thể dọn dẹp nó được.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cần phải xem xét kỹ lưỡng khi tham chiếu đến node con hay node lá bên trong cây DOME. Nếu bạn giữ tham chiếu đến 1 table cell (thẻ <td>) trong code và chọn xóa table khỏi DOM tuy nhiên vẫn giữ tham chiếu đến cell đó, bạn có thể sẽ phải đối mặt với 1 vụ rò rỉ lớn. Bạn nghĩ rằng GC sẽ giải phóng tất cả mọi thứ ngoại trừ cell đó. Tuy nhiên, điều này không dễ dàng như vậy. Bởi vì cell là 1 node con của table và những node con thì có tham chiếu đến parent của chúng, vì thế 1 tham chiếu đến 1 cell có thể giữ cả 1 table lớn trong bộ nhớ.</td></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mấy hôm trước chúng ta đã bắt đầu series bài viết đục khoét về Javascript và cách nó hoạt động như thế nào, bằng cách hiểu về những thành phần cơ bản và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và &lt;em&gt;ngon&lt;/em&gt; hơn.&lt;/p&gt;
&lt;p&gt;Bài đầu tiên là tổng quan về series, cung cấp cái nhìn toàn cảnh về engine, runtime &amp;amp; callstack. Bài thứ 2 là một cái nhìn cụ thể hơn về những thành phần bên trong của bộ engine V8 của Google và một số mẹo vặt để tối ưu Javascript code.&lt;/p&gt;
&lt;p&gt;Ở bài thứ 3 này, chúng ta sẽ thảo luận về một vấn đề không kém phần quan trọng nhưng lại thường bị các dev bỏ qua do sự phức tạp ngày càng gia tăng của các ngôn ngữ lập trình thường dùng: quản lý bộ nhớ. Chúng ta cũng sẽ tìm hiểu một số mẹo để có thể xử lý những trường hợp rò rì bộ nhớ của Javascript mà team SesstionStack đã áp dụng để tránh bị rò rỉ và không làm tốn bộ nhớ của webapp.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P2: Bên trong engine V8 &amp; 5 mẹo để tối ưu hóa code</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P2-Ben-trong-engine-V8-5-meo-de-toi-uu-hoa-code.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P2-Ben-trong-engine-V8-5-meo-de-toi-uu-hoa-code.html</id>
    <published>2018-11-13T15:52:00.000Z</published>
    <updated>2018-11-13T15:58:38.369Z</updated>
    
    <content type="html"><![CDATA[<p>Hôm trước chúng ta đã có bài bắt đầu một chuỗi series đào sâu nghiên cứu về Javascript và cách thức nó hoạt động: Chúng tôi nghĩ rằng, bằng cách hiểu được những thành phần của JS và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và <em>ngon</em> hơn</p><p>Bài đầu tiên của series đã cho chúng ta có một cái nhìn tổng quan về engine, runtime và callstack. Trong bài thứ 2 này, chúng ta sẽ <em>đục khoét</em> vào những thành phần bên trong của bộ engine V8 của Google. Tác giả cũng sẽ cung cấp một số mẹo vặt để có thể viết code Javascript tốt hơn - những thứ tốt nhất (best practices) mà team SessionStack đã và đang thực hiện để xây dựng những sản phẩm của họ.<br><a id="more"></a></p><h1 id="Tong-quan"><a href="#Tong-quan" class="headerlink" title="Tổng quan"></a>Tổng quan</h1><p>Javascript engine là một trình thông dịch thực thi mã Javascript. Một JS engine có thể được triển khai thực hiện như là 1 trình thông dịch độc lập, hoặc là một trình biên dịch tức thời (Just-In-Time Compiler) mà nó sẽ biên dịch code Javascript thành bytecode (chưa phải mã máy, nhưng gần như là mã máy).</p><p>Dưới đây là danh sách các dự án phổ biến đã triển khai cho Javascript engine:</p><ul><li><a href="https://en.wikipedia.org/wiki/V8_%28JavaScript_engine%29" target="_blank" rel="noopener">V8</a> - Nguồn mở, phát triển bởi Google trên nền C++</li><li><a href="https://en.wikipedia.org/wiki/Rhino_%28JavaScript_engine%29" target="_blank" rel="noopener">Rhino</a> - Được quản lý bởi quỹ Mozilla Foundation, nguồn mở, phát triển hoàn toàn bằng Java</li><li><a href="https://en.wikipedia.org/wiki/SpiderMonkey_%28JavaScript_engine%29" target="_blank" rel="noopener">SpiderMonkey</a> - Bộ JS engine đầu tiên, ngày xưa được hỗ trợ bởi Netscape Navigator, ngày nay là Firefox</li><li><a href="https://en.wikipedia.org/wiki/JavaScriptCore" target="_blank" rel="noopener">JavaScriptCore</a> - nguồn mở, còn được gọi là Nitro, được phát triển bởi Apple cho Safari</li><li><a href="https://en.wikipedia.org/wiki/KJS_%28KDE%29" target="_blank" rel="noopener">KJS</a> - Engine của KDE, phát triển bởi Harri Porten cho dự án trình duyệt Konqueror của KDE</li><li><a href="https://en.wikipedia.org/wiki/Chakra_%28JScript_engine%29" target="_blank" rel="noopener">Chakra (JScript9)</a> - Internet Explorer</li><li><a href="https://en.wikipedia.org/wiki/Chakra_%28JavaScript_engine%29" target="_blank" rel="noopener">Chakra (JavaScript)</a> -  Microsoft Edge</li><li><a href="https://en.wikipedia.org/wiki/Nashorn_%28JavaScript_engine%29" target="_blank" rel="noopener">Nashorn</a> - Nguồn mở và là 1 phần của OpenJDK, viết bằng Java bởi Oracle và Tool Group</li><li><a href="https://en.wikipedia.org/wiki/JerryScript" target="_blank" rel="noopener">JerryScript</a> - là 1 bộ engine nhẹ dành cho Vạn vật kết nối (Internet of Things)</li></ul><h1 id="Tai-sao-V8-duoc-tao-ra"><a href="#Tai-sao-V8-duoc-tao-ra" class="headerlink" title="Tại sao V8 được tạo ra?"></a>Tại sao V8 được tạo ra?</h1><p><em>Hỏi vớ vẩn</em> </p><p>V8 engine được xây dựng bởi Google bằng C++ và nó là phần mềm nguồn mở. Bộ engine này được dùng trong trình duyệt Google Chrome. Không giống như các engine khác, V8 còn được sử dụng trong môi trường runtime của Node.js</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*AKKvE3QmN_ZQmEzSj16oXg.png" alt=""></p><p>V8 đầu tiên được thiết kế nhằm gia tăng hiệu suất của tiến trình thực thi JavaScript bên trong trình duyệt. Để có thể đạt được tốc độ tốt, V8 dịch mã Javascript thành mã máy thay vì sử dụng trình thông dịch. Nó biên dịch mã JS thành mã máy ngay khi thực thi bằng bộ JIT compiler (Just-In-Time compiler) giống như đa số các JS engine hiện đại khác như SpiderMoney hay Rhino. Điểm khác biệt chính đó là V8 không sinh ra bytecode hay mã trung gian.</p><h1 id="V8-su-dung-2-trinh-bien-dich"><a href="#V8-su-dung-2-trinh-bien-dich" class="headerlink" title="V8 sử dụng 2 trình biên dịch"></a>V8 sử dụng 2 trình biên dịch</h1><p>Trước khi phát hành phiên bản 5.9 (đầu năm 2017), engine V8 sử dụng 2 trình biên dịch:</p><ul><li><strong>full-codegen</strong> - một trình biên dịch vừa đơn giản vừa cực nhanh, sinh mã máy đơn giản và tương đối chậm</li><li><strong>Crankshaft</strong> - một trình biên dịch tối ưu có hơi phức tạp (Just-In-Time) sinh mã đã được tối ưu tốt nhất.</li></ul><p>V8 engine còn sử dụng nhiều tiến trình nội bộ khác:</p><ul><li>Tiến trình chính thực hiện những gì bạn thường thấy: lấy code, biên dịch và thực thi nó.</li><li>Có một tiến trình riêng khác cho việc biên dịch, bằng cách này thì trong khi tiến trình chính biên dịch, tiến trình phụ tối ưu (optimize) code.</li><li>Một tiến trình Profiler (không biết dịch) sẽ thông báo cho runtime những phương thức nào đang chiếm dụng nhiều thời gian xử lý để cho Crankshaft có thể tối ưu chúng.</li><li>Một vài tiến trình khác để xử lý dọn rác (Garbage Collector)</li></ul><p>Khi lần đầu thực thi mã Javascript, V8 engine sẽ gọi <strong>full-codegen</strong> để dịch trực tiếp những đoạn code JS đã được phân tích thành mã máy mà không thông qua bước chuyển đổi (transformation). Điều này cho phép thực thi mã máy rất nhanh. Để ý rằng V8 không sử dụng bytecode trung gian, cho thấy rằng cách làm này loại bỏ sự không cần thiết của 1 trình thông dịch.</p><p>Khi code đã chạy được một thời gian thì tiến trình profiler đã thu thập đủ dữ liệu để có thể xác định phương thức nào cần được tối ưu hóa.</p><p>Ở bước tiếp theo, <strong>Crankshaft</strong> sẽ bắt đầu 1 tiến trình khác. Nó dịch cây cú pháp trừu tượng (Abstract Syntax Tree - AST, sẽ có 1 bài riêng để nói về cái này nhé) của Javascript thành một dạng cấp độ cao của <em>static single assignment</em> (SSA - vốn ngôn ngữ có hạn nên không biết dịch), còn được gọi là <em>Hydrogen</em>, và cố gắng tối ưu đồ thị Hydrogen đó. Đa số sự tối ưu hóa được hoàn thành là giai đoạn này.</p><h1 id="Inlining-Noi-tuyen"><a href="#Inlining-Noi-tuyen" class="headerlink" title="Inlining (Nội tuyến)"></a>Inlining (Nội tuyến)</h1><p>Bước tối ưu hóa đầu tiên là triển khai nội tuyến (<a href="https://vi.wikipedia.org/wiki/H%C3%A0m_n%E1%BB%99i_tuy%E1%BA%BFn" target="_blank" rel="noopener">Inlining</a>) nhiều code nhất có thể. Inlining là tiến trình thay thế một vị trí gọi (call site - dòng code nơi hàm được gọi) với thân (body) của hàm được gọi. Bước thực hiện đơn giản này cho phép những tối ưu hóa sau này được ý nghĩa hơn.</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*RRgTDdRfLGEhuR7U.png" alt=""></p><h1 id="Lop-an-Hidden-class"><a href="#Lop-an-Hidden-class" class="headerlink" title="Lớp ẩn (Hidden class)"></a>Lớp ẩn (Hidden class)</h1><p>Javascript là ngôn ngữ dựa trên các nguyên mẫu (prototype-based): không có các lớp (class) hay đối tượng (object) nào được tạo ra bằng tiến trình nhân bản (cloning process). Javascript cũng là ngôn ngữ động (dynamic), nghĩa là những thuộc tính (property) có thể được dễ dàng thêm vào hoặc xóa đi từ object sau khi object đó được khởi tạo.</p><p>Đa số các trình thông dịch JS sử dụng cấu trúc dạng như từ điển (<a href="http://en.wikipedia.org/wiki/Hash_function" target="_blank" rel="noopener">hash function based</a>) để lưu trữ vị trí của những giá trị của thuộc tính trong object trên bộ nhớ. Cấu trúc này làm cho quá trình lấy giá trị (get) trong JS trở nên tốn kém hơn nhiều so với những ngôn ngữ lập trình non-dynamic khác như Java hay C#.<br>Trong Java, tất cả các thuộc tính của object được xác định bởi cấu trúc object cố định trước khi biên dịch và không thể thêm hay bớt thuộc tính tại thời điểm thực thi (C# cũng có kiểu dynamic, nhưng cái đó hơi lạc đề rồi nên mình không đề cập).<br>Kết quả là, giá trị của thuộc tính (hay con trỏ đến thuộc tính đó) được lưu dưới dạng bộ đệm liên tục (continuous buffer) trên vùng nhớ với một offset cố định giữa các vùng nhớ. Độ dài của 1 offset có thể dễ dàng xác định dựa trên loại thuộc tính, trong khi đó điều này là bất khả thi đối với Javascript khi mà loại thuộc tính có thể bị thay đổi trong quá trình thực thi.</p><p>Bởi vì sử dụng cấu trúc từ điển để tìm vị trí của thuộc tính của object trong vùng nhớ là không hiệu quả nên V8 sử dụng một phương pháp khác: lớp ẩn (hidden class). Lớp ẩn hoạt động tương tự như một cấu trúc object (class) cố định trong Java, ngoại trừ việc nó được tạo ra ở quá trình thực thi (runtime). Giờ thì xem ví dụ bên dưới nhé:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>Khi câu lệnh new Point(1, 2) được gọi, V8 sẽ tạo ra 1 lớp ẩn, tạm gọi là C0</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*pVnIrMZiB9iAz5sW28AixA.png" alt=""></p><p>Không có thuộc tính nào được định nghĩa trong Point, vì thế tạm thời C0 đang rỗng.</p><p>Khi câu lệnh this.x = x được thực thi (bên trong hàm Point), V8 sẽ tạo ra 1 lớp ẩn thứ hai dựa trên C0, ta tạm gọi là C1. C1 mô tả lại vị trí trên vùng nhớ (tương tự như con trỏ) nơi mà thuộc tính x được lưu.<br>Trong trường hợp này, x sẽ nằm ở offset 0, nghĩa là khi chúng ta view một object Point trên vùng nhớ dưới dạng bộ đệm liên tục (continuous buffer) thì offset đầu tiên sẽ tương ứng với thuộc tính x.<br>V8 cũng sẽ cập nhật C0 với một sự chuyển đổi lớp (class transition) và tuyên bố rằng thuộc tính x được thêm vào trong object Point, lớp ẩn lúc này sẽ chuyển từ C0 sang C1.<br>Lớp ẩn cho object Point ở hình dưới lúc này là C1</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*QsVUE3snZD9abYXccg6Sgw.png" alt=""><br><em>Mỗi khi có thuộc tính mới được thêm vào object, lớp ẩn cũ được cập nhật và sẽ chuyển tiếp (transition) sang lớp ẩn mới. Sự chuyển tiếp lớp ẩn là rất quan trọng bởi vì chúng cho phép những object được tạo ra theo những cách giống nhau có thể cùng chia sẻ các lớp ẩn. Nếu 2 object cùng dùng chung 1 lớp ẩn và 1 thuộc tính được thêm vào cả 2 object đó, sự chuyển tiếp sẽ đảm bảo rằng cả 2 object đều nhận được cùng 1 lớp ẩn mới và sẽ được tối ưu cùng nhau.</em></p><p>Quá trình này được lặp lại khi câu lệnh tiếp theo this.y = y được thực thi (bên trong hàm Point, ngay sau dòng this.x = x).</p><p>Một lớp ẩn mới, tạm gọi là C2 được tạo ra, một lớp chuyển tiếp (class transition) được thêm vào C1 biểu thị rằng nếu thuộc tính y được thêm vào object Point (object đã chứa thuộc tính x) thì lớp ẩn sẽ được thay đổi sang C2, và lớp ẩn của object Point sẽ được cập nhật thành C2</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*spJ8v7GWivxZZzTAzqVPtA.png" alt=""></p><p>Sự chuyển tiếp lớp ẩn phụ thuộc vào thứ tự mà những thuộc tính được thêm vào 1 object. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">p1.a = <span class="number">5</span>;</span><br><span class="line">p1.b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">p2.b = <span class="number">7</span>;</span><br><span class="line">p2.a = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>Nhìn vào đoạn code trên, bạn sẽ nghĩ rằng cả p1 và p2 sẽ dùng chung lớp ẩn và sự chuyển tiếp giữa các lớp. Nhưng sự thật không phải như vậy. Đối với p1, thuộc tính thứ nhất là a sẽ được thêm vào và sau đó đến b. Với p2 thì ngược lại, b trước rồi mới đến a.<br>Vì vậy, p1 và p2 sẽ sinh ra 2 lớp ẩn khác nhau và có sự chuyển tiếp lớp ẩn cũng khác nhau. Trong trường hợp này, tốt nhất là nên giữ đúng thứ tự thuộc tính mỗi khi khởi tạo dữ liệu để lớp ẩn có thể được dùng lại:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">p1.a = <span class="number">5</span>;</span><br><span class="line">p1.b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">p2.a = <span class="number">8</span>;</span><br><span class="line">p2.b = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p><em>Phần diễn giải về hidden class này khá là rối và khó hiểu, để hiểu rõ hơn thì mời bạn tham khảo thêm <a href="https://thefullsnack.com/posts/javascript-v8-notes.html" target="_blank" rel="noopener">bài viết chi tiết</a> của tác giả thefullsnack</em></p><h1 id="Inline-caching-Bo-dem-noi-tuyen"><a href="#Inline-caching-Bo-dem-noi-tuyen" class="headerlink" title="Inline caching (Bộ đệm nội tuyến)"></a>Inline caching (Bộ đệm nội tuyến)</h1><p>V8 có một điểm mạnh trong kỹ thuật tối ưu hóa dành cho các ngôn ngữ với kiểu dữ liệu động, gọi là Inline caching (bộ đệm nội tuyến). Inline caching dựa trên sự quan sát những lời gọi được lặp lại nhiều lần đến cùng 1 phương thức có xu hướng xảy ra trên cùng 1 loại object. Diễn giải chi tiết hơn về inline caching có thể xem ở <a href="https://github.com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-caches" target="_blank" rel="noopener">đây</a></p><p>Giờ chúng ta sẽ duyệt sơ qua những khái niệm chung chung của inline caching (nếu như bạn không có thời gian đọc hết bài chi tiết ở trên)</p><p>Vậy thì nó hoạt động như thế nào? V8 duy trì bộ nhớ đệm về kiểu của các object được truyền qua dưới dạng tham số (parameter) trong những lần gọi method gần đây và sử dụng thông tin này để dự đoán về kiểu object sẽ được truyền trong tương lai. Nếu như V8 có thể dự đoán tương đối tốt về kiểu object sẽ được truyền vào thì nó có thể bỏ qua bước xử lý tìm hiểu về các thuộc tính của object đó, nó sẽ dùng những thông tin có sẵn đã được lưu từ lần trước và áp dụng cho lớp ẩn của object này.</p><p>Vậy thì lớp ẩn và inline caching liên quan với nhau như thế nào? Khi một phương thức được gọi trên một object cụ thể, V8 sẽ thực hiện tìm kiếm lớp ẩn của object đó để xác định offset nhằm phục vụ cho việc truy xuất thuộc tính. Sau 2 lần gọi thành công cùng 1 phương thức đến cùng 1 lớp ẩn, V8 sẽ bỏ qua việc tìm kiếm lớp ẩn đó và đơn giản là thêm offset của thuộc tính vào trong bản thân con trỏ của object. Về sau, cứ mỗi lần gọi phương thức, V8 sẽ giả định rằng lớp ẩn không thay đổi và nhảy trực tiếp vào trong địa chỉ vùng nhớ của thuộc tính và sử dụng offset đã được lưu từ lần tìm kiếm trước đó. Cách này có thể gia tăng đáng kể tốc độ thực thi.</p><p>Inline caching cũng là lý do quan trọng cho việc cùng kiểu object sẽ dùng chung lớp ẩn. Nếu bạn tạo ra 2 object có cùng 1 kiểu nhưng khác hidden class (như chúng ta đã làm ở trên), V8 sẽ không thể sử dụng inline caching bởi vì mặc dù 2 object có cùng kiểu nhưng lớp ẩn tương ứng của nó lại gán offset khác nhau cho mỗi thuộc tính.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*iHfI6MQ-YKQvWvo51J-P0w.png" alt=""><br>2 object về cơ bản là giống nhau nhưng thuộc tính a và b lại có thứ tự khác nhau.</p><h1 id="Bien-dich-thanh-ma-may"><a href="#Bien-dich-thanh-ma-may" class="headerlink" title="Biên dịch thành mã máy"></a>Biên dịch thành mã máy</h1><p>Một khi đồ thị Hydrogen đã được tối ưu hóa, Crankshaft chuyển nó xuống một tầng thấp hơn gọi là Lithium. Hầu như toàn bộ các Lithium này là kiến trúc cụ thể (architecture-specific, mình cũng không hiểu nữa, kiến thức chuyên sâu quá). Đăng ký cấp phát xảy ra ở tầng này.</p><p>Ở bước cuối cùng, Lithium được biên dịch thành mã máy. Sau đó, quá trình thay đổi trên ngăn xếp (on-stack replacement: OSR) sẽ diễn ra. Trước khi chúng ta bắt đầu biên dịch và tối ưu hóa một phương thức ngốn nhiều thời gian, chúng ta thường chạy nó trước. V8 sẽ không vứt hết những đoạn code chậm và chạy lại từ đầu đoạn code đã tối ưu. Thay vì thế, V8 sẽ chuyển hóa toàn bộ ngữ cảnh hiện tại (ngăn xếp, các thanh ghi), do đó ta có thể chuyển đổi sang phiên bản đã được tối ưu ngay giữa quá trình thực thi. Đây là một thao tác cực kỳ phức tạp, hãy nhớ rằng V8 đã <em>inline</em> toàn bộ code giữa quá trình tối ưu hóa (Đoạn này viết khó hiểu quá, nhưng mà cũng không quan tọng lắm đâu). Ngoài ra thì V8 không phải là engine duy nhất có thể làm được điều này.</p><p>Có một giải pháp an toàn đó là đảo ngược quá trình tối ưu hóa (deoptimization - phức tạp hóa ?) để chuyển đổi toàn bộ code về với trạng thái chưa được tối ưu trong trường hợp engine gặp trục trặc.</p><h1 id="Bo-don-rac-Garbage-collection-GC"><a href="#Bo-don-rac-Garbage-collection-GC" class="headerlink" title="Bộ dọn rác (Garbage collection - GC)"></a>Bộ dọn rác (Garbage collection - GC)</h1><p>Đối với GC thì V8 sử dụng phương pháp thế hệ theo kiểu truyền thống là đánh-dấu-và-quét (mark-and-sweep) để dọn dẹp những thứ cũ. Giả sử quá tình đánh dấu có thể làm ngưng sự thực thi Javascript. Để có thể điều hành GC hiệu quả và thực hiện một cách ổn định, V8 sử dụng đánh dấu gia tăng (incremental marking), thay vì duyệt qua toàn bộ heap và cố đánh dấu nhiều object nhất có thể, nó sẽ đi qua từng heap, sau đó quay lại với những thực thi bình thường.<br>Lần tiếp theo GC chạy sẽ tiếp tục từ vị trí heap mà trước đó nó đã dừng lại. Cách này cho phép một khoảng thời gian dừng rất ngắn giữa quá trình thực thi. Và như đã đề cập ở trước, quá tình quét dọn được xử lý bằng 1 tiến trình khác.</p><h1 id="Ignition-va-TurboFan"><a href="#Ignition-va-TurboFan" class="headerlink" title="Ignition và TurboFan"></a>Ignition và TurboFan</h1><p>Cùng với sự ra mắt của V8 bản 5.9 đầu năm 2017, có 2 pipeline thực thi mới được giới thiệu, mang lại khả năng cải thiện hiệu năng tốt hơn và tiết kiệm bộ nhớ đáng kể đối với những ứng dụng Javascript.</p><p>Bộ pipeline mới này được xây dựng trên trình thông dịch của V8 là <a href="https://github.com/v8/v8/wiki/Interpreter" target="_blank" rel="noopener">Ignition</a> và trình biên dịch tối ưu hóa mới nhất là <a href="https://github.com/v8/v8/wiki/TurboFan" target="_blank" rel="noopener">TurboFan</a>.</p><p>Bạn có thể xem thêm thông tin trong bài viết trên blog của V8 tại <a href="https://v8project.blogspot.bg/2017/05/launching-ignition-and-turbofan.html" target="_blank" rel="noopener">đây</a></p><p>Kể từ phiên bản 5.9 thì <em>full-codegen</em> và <em>Crankshaft</em> (những công nghệ đã xuất hiện trong V8 từ năm 2010) đã không còn được sử dụng cho quá trình thực thi Javascript nữa khi mà nhóm phát triển V8 đã phải vất vả để có thể theo kịp với những tính năng mới và sự tối ưu hóa cần thiết cho những tính năng này.</p><p>Điều này nghĩa là xét một cách tổng quát thì V8 sẽ đơn giản hơn và có kiến trúc dễ bảo trì hơn.</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*pohqKvj9psTPRlOv.png" alt=""></p><p>Những cải tiến này chỉ là bước khởi đầu. Ignition và TurboFan sẽ lót đường cho những tối ưu hóa về sau, đẩy mạnh hiệu năng Javascript và tinh giản bớt V8 trong Chrome và Node.js trong những năm tới.</p><p>Cuối cùng, dưới đây là 1 số mẹo vặt để bạn có thể viết được bộ code Javascript một cách tối ưu. Bạn có thể dễ dàng rút ra được bài học từ những gì đã nêu ở trên, nhưng để dễ hiểu hơn thì mời bạn xẹm tổng kết:</p><h1 id="Lam-the-nao-de-toi-uu-hoa-Javascript"><a href="#Lam-the-nao-de-toi-uu-hoa-Javascript" class="headerlink" title="Làm thế nào để tối ưu hóa Javascript"></a>Làm thế nào để tối ưu hóa Javascript</h1><ol><li><strong>Thứ tự các thuộc tính của object</strong>: luôn luôn khởi tạo các thuộc tính của object sao cho chúng có cùng thứ tự để lớp ẩn và những code tối ưu có thể chia sẻ dùng chung.</li><li><strong>Thuộc tính động</strong> (Dynamic properties): thêm thuộc tính vào một object sau khi khởi tạo sẽ ép lớp ẩn phải thay đổi và làm chậm những phương thức đã được tối ưu cho lớp ẩn trước đó. Thay vì thế, ta có thể gán tất cả các thuộc tính của object trong hàm khởi tạo constructor.</li><li><strong>Phương thức</strong>: code thực thi cùng 1 phương thức nhưng nhiều lần sẽ chạy nhanh hơn code thực thi nhiều phương thức khác nhau nhưng mỗi phương thức chạy một lần (xem phần inline caching)</li><li><strong>Mảng</strong>: Tránh sử dụng mảng thưa (sparse arrays) mà key không phải là số tăng liên tục. Mảng thưa mà không có phần tử nào thì lại là bảng băm (hash table). Mỗi phần tử trong mảng như vậy sẽ gây ra sự tốn kém mỗi lần truy xuất. Ngoài ra cần tránh trường hợp cấp phát bộ nhớ trước cho những mảng lớn. Cứ để cho mảng “nở ra” một cách tự nhiên. Cuối cũng thì cũng đừng xóa các phần tử trong mảng (toán tử delete()) vì nó chỉ xóa phần từ chứ không đánh index lại mảng.</li><li><strong>Tagged values</strong>: Trong V8 thì object và số (number) là 32bits. Nó sử dụng 1 bit để phân biệt object (flag = 1) và số integer (flag = 0) gọi là SMI (SMall Integer). Vì thế nếu 1 giá trị số lớn hơn 31 bit thì V8 sẽ đóng gói số đó, chuyển nó thành kiểu double và tạo 1 object mới để lưu số. Chỉ nên sử dụng số nguyên có dấu 31 bit để tránh quá trình chuyển đổi không đáng có (lại tốn công xử lý) số thành object.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hôm trước chúng ta đã có bài bắt đầu một chuỗi series đào sâu nghiên cứu về Javascript và cách thức nó hoạt động: Chúng tôi nghĩ rằng, bằng cách hiểu được những thành phần của JS và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và &lt;em&gt;ngon&lt;/em&gt; hơn&lt;/p&gt;
&lt;p&gt;Bài đầu tiên của series đã cho chúng ta có một cái nhìn tổng quan về engine, runtime và callstack. Trong bài thứ 2 này, chúng ta sẽ &lt;em&gt;đục khoét&lt;/em&gt; vào những thành phần bên trong của bộ engine V8 của Google. Tác giả cũng sẽ cung cấp một số mẹo vặt để có thể viết code Javascript tốt hơn - những thứ tốt nhất (best practices) mà team SessionStack đã và đang thực hiện để xây dựng những sản phẩm của họ.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P1: Khái quát về engine, runtime và callstack</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P1-Khai-quat-ve-engine-runtime-va-callstack.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P1-Khai-quat-ve-engine-runtime-va-callstack.html</id>
    <published>2018-11-13T15:50:00.000Z</published>
    <updated>2018-11-13T15:51:06.078Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript càng ngày càng phổ biến, có nhiều nhóm các lập trình viên đã và đang nâng cấp cũng như hỗ trợ JS ở nhiều mức độ khác nhau: từ frontend đến backend, hybrid app, thiết bị nhúng và còn nhiều nữa.</p><p>Bài viết này mở đầu cho 1 series hướng tới mục đích đào sâu (aka <em>Đục Khoét</em>) vào trong Javascript và cách mà nó hoạt động như thế nào: Bằng cách hiểu rõ các thành phần của JS và cách mà chúng tương tác với nhau thì bạn có thể viết code tốt hơn và <em>ngon</em> hơn. Bên cạnh đó team SessionStack cũng chia sẻ một vài bí kíp trong khi xây dựng SessionStack - 1 ứng dụng Javascript nhẹ nhưng có chất lượng cao và mạnh mẽ.<br><a id="more"></a><br>Như ta thấy trong <a href="https://githut.info/" target="_blank" rel="noopener">GitHut stats</a>, Javascript đang là top đứng đầu trong các repo đang hoạt động (Active Repositories) và tổng số push (Total Pushes) ở GitHub. Và nó cũng không bị tụt lùi quá nhiều ở những hạng mục khác.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*Zf4reZZJ9DCKsXf5CSXghg.png" alt=""></p><p>(<a href="https://madnight.github.io/githut/" target="_blank" rel="noopener">Xem cập nhật mới nhất về GitHut stat</a>).</p><p>Nếu dự án phụ thuộc quá lớn vào Javascript thì có nghĩa rằng các lập trình viên phải tận dụng tối đa khả năng mà ngôn ngữ này cũng như hệ sinh thái (ecosystem) của nó cung cấp và thấu hiểu một cách triệt để về bản chất của nó để có thể xây dựng được những công trình vi diệu.</p><p>Và một cách hiển nhiên là có rất nhiều lập trình viên đang sử dụng Javascript hằng ngày nhưng lại không có kiến thức hoặc không biết gì về những thứ đang thực sự diễn ra bên trong JS.</p><h1 id="Tong-quan"><a href="#Tong-quan" class="headerlink" title="Tổng quan"></a>Tổng quan</h1><p>Hầu như mọi người ai cũng từng nghe qua bộ engine V8 và đa số mọi người biết rằng JS là một ngôn ngữ đơn luồng (single-thread) hoặc là nó sử dụng hàng đợi các callback (callback queue - không biết dịch sao cho đúng<br><img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f613.png" alt=""><br>)</p><p>Trong bài này, chúng ta sẽ đi lần lượt một cách chi tiết qua các khái niệm cơ bản và giải thích cụ thể Javascript chạy như thế nào. Bằng cách đó, chúng ta có thể viết code được tốt hơn, xây dựng app có khả năng xử lý API một cách mượt mà, không bị block lẫn nhau (non-blocking apps).</p><p>Nếu bạn là người mới học Javascript thì bài viết này sẽ giúp bạn hiểu tại sao Javascript lại “quái dị” khi so sánh với các ngôn ngữ khác.</p><p>Và nếu bạn là một dev có kinh nghiệm với JS thì hi vọng bài viết này sẽ giúp ích cho bạn hiểu thêm về cách hoạt động của JS Runtime - thứ mà bạn đang sử dụng mỗi ngày.</p><h1 id="JavaScript-Engine"><a href="#JavaScript-Engine" class="headerlink" title="JavaScript Engine"></a>JavaScript Engine</h1><p><em>Engine: Cỗ máy - mình sẽ không dịch từ mà để nguyên gốc tiếng Anh</em></p><p>Một ví dụ điển hình của JS Engine chính là bộ Google V8. Bộ engine V8 này được sử dụng trong Google Chrome và Node.js. Dưới đây là một mô hình đơn giản nhất của nó:<br><img src="https://cdn-images-1.medium.com/max/1000/1*OnH_DlbNAPvB9KLxUCyMsA.png" alt=""></p><p>Engine gồm 2 thành phần chính:</p><ul><li>Vùng nhớ heap (memory heap): khu vực cấp phát bộ nhớ</li><li>Ngăn xếp (call stack): đây là nơi chứa các khung stack khi bạn thực thi code.</li></ul><h1 id="Runtime-Moi-truong-thuc-thi"><a href="#Runtime-Moi-truong-thuc-thi" class="headerlink" title="Runtime (Môi trường thực thi)"></a>Runtime (Môi trường thực thi)</h1><p>Có những API trong trình duyệt đang được sử dụng bởi đa số JS developer hiện nay (ví dụ: setTimeout). Những API này lại không được cung cấp bởi các Engine.</p><p>Vậy thì chúng từ đâu tới ?</p><p>Sự thật có đôi chút phức tạp một tí.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4lHHyfEhVB0LnQ3HlhSs8g.png" alt=""></p><p>Chúng ta có JS Engine nhưng thực ra còn nhiều thứ hơn thế. Các browser thường cung cấp một hệ thống <em>Web APIs</em> bao gồm nhiều thành phần như DOM, AJAX, setTimeout, vân vân và mây mây.</p><p>Và rồi cả những thứ nổi tiếng như event loop và callback queue nữa.</p><h1 id="Ngan-xep-Call-Stack"><a href="#Ngan-xep-Call-Stack" class="headerlink" title="Ngăn xếp (Call Stack)"></a>Ngăn xếp (Call Stack)</h1><p>Javascript là ngôn ngữ lập trình đơn luồng (single-threaded), nghĩa là nó chỉ có 1 cái call stack. Vì thế nó chỉ có thể làm 1 công việc tại 1 thời điểm nhất định.</p><p>Call Stack là một cấu trúc dữ liệu mà về cơ bản thì nó ghi nhớ vị trí của chúng ta trong chương trình đang chạy. Nếu như chúng ta thực thi một hàm (function) thì khi đó ta sẽ đặt hàm đấy vào vị trí trên cùng của ngăn xếp (stack), sau khi xử lý xong và return từ hàm đó, vị trí trên cùng sẽ bị đẩy ra khỏi stack. Đó là cách hoạt động của Call Stack.</p><p>Để dễ hiểu hơn thì mời bạn xem ví dụ bên dưới:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = multiply(x, x);</span><br><span class="line">    <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line">printSquare(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>Khi engine bắt đầu thực thi code, Call Stack còn đang rỗng. Ngay sau đó, từng bước thực hiện sẽ giống như hình bên dưới:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Yp1KOt_UJ47HChmS9y7KXw.png" alt=""></p><p>Mỗi bản ghi trong Call Stack được gọi là khung của ngăn xếp (Stack Frame).</p><p>Và đây cũng là cách chính xác mà stack traces được xây dựng và in ra mỗi khi có xử lý biệt lệ (exception handling). Về cơ bản thì nó chính là trạng thái của Call Stack ngay tại thời điểm có biệt lệ xảy ra. Hãy nhìn vào đoạn code bên dưới:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'SessionStack will help you resolve crashes :)'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure><p>Nếu như chạy đoạn code đó trên Chrome console (giả sử toàn bộ code nằm trong 1 file foo.js), thì chúng ta sẽ có stack trace như sau:</p><p> <img src="https://cdn-images-1.medium.com/max/1600/1*T-W_ihvl-9rG4dn18kP3Qw.png" alt=""></p><p>Thổi tung ngăn xếp (<strong>Blowing the stack</strong>)  - Trường hợp này xảy ra khi chương trình thực thi đạt tới kích thước giới hạn tối đa của Call Stack. Và để có thể có được tình huống này một cách dễ dàng nhất, chỉ cần <em>vô tình</em> gọi đệ quy một cách không cẩn thận là được à:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>Khi engine bắt đầu thực thi code, nó gọi hàm foo đầu tiên. Hàm này lại gọi đệ quy chính bản thân nó để rồi rơi vào 1 vòng lặp vô hạn không có điều kiện dừng. Mỗi khi gọi hàm thì 1 bản ghi sẽ được đẩy vào Call Stack, và cứ thế, cứ thể đẩy vào làm cho tràn ngăn xếp (aka stackoverflow). Giống như hình bên dưới:</p><p> <img src="https://cdn-images-1.medium.com/max/1600/1*AycFMDy9tlDmNoc5LXd9-g.png" alt=""></p><p>Tại 1 thời điểm cụ thể nào đó khi số lần gọi hàm đạt tới ngưỡng giới hạn của Call Stack (call stack size) thì trình duyệt sẽ quyết định “giải cứu” bằng cách bắn ra 1 lỗi trông như thế này đây:</p><p> <img src="https://cdn-images-1.medium.com/max/1600/1*e0nEd59RPKz9coyY8FX-uw.png" alt=""></p><p>Chạy code đơn tiến trình có thể khá là dễ dàng bởi vì chúng ta không phải mất công đối phó với những tình huống phức tạp thường gặp trong môi trường đa tiến trình (chẳng hạn như deadlocks).</p><p>Tuy nhiên đơn tiến trình cũng có những giới hạn của nó. Bởi vì Javascript chỉ có 1 Call Stack, điều gì sẽ xảy ra khi có vài xử lý chậm chạp?</p><h1 id="Xu-ly-dong-thoi-Concurrency-amp-Vong-lap-su-kien-Event-Loop"><a href="#Xu-ly-dong-thoi-Concurrency-amp-Vong-lap-su-kien-Event-Loop" class="headerlink" title="Xử lý đồng thời (Concurrency) &amp; Vòng lặp sự kiện (Event Loop)"></a>Xử lý đồng thời (Concurrency) &amp; Vòng lặp sự kiện (Event Loop)</h1><p>Điều gì sẽ xảy ra nếu như bạn có 1 hàm xử lý đang ở trong Call Stack nhưng hàm đó lại tốn kha khá thời gian để chạy? Ví dụ như bạn muốn thực hiện một vài thuật toán chuyển đổi hình ảnh phức tạp bằng Javascript ngay trên trình duyệt.</p><p>Thế thì có vấn đề gì nào? Vấn đề ở đây là trong khi Call Stack đang bận tối tăm mặt mũi để xử lý thì trình duyệt lại rảnh không, ngồi chơi xơi nước vì không có gì để làm, đúng hơn là không thể làm gì được - trình duyệt đã bị block. Có nghĩa là trình duyệt không thể render, nó cũng không chạy được các câu lệnh khác, tóm lại là bị mắc kẹt. Điều này gây ảnh hưởng lớn đến sự mượt mà của UI trên app.</p><p>Đó cũng không phải vấn đề duy nhất đâu. Một khi trình duyệt bắt đầu xử lý quá nhiều thứ trong Call Stack, nó sẽ bị “đơ”, không thể tương tác được trong 1 khoảng thời gian dài. Đa số trình duyệt sẽ bắn ra lỗi, hỏi bạn xem có muốn hủy trang đang chạy không. Đại loại là giống như hình dưới:</p><p> <a href="https://cdn-images-1.medium.com/max/1600/1*WlMXK3rs_scqKTRV41au7g.jpeg" target="_blank" rel="noopener"><img src="https://cdn-images-1.medium.com/max/1600/1*WlMXK3rs_scqKTRV41au7g.jpeg" alt=""></a> <a></a></p><p>Rõ ràng điều này không phải là 1 trải nghiệm người dùng (User experience) tối ưu phải không nào?</p><p>Vậy thì làm thế nào để xử lý code vừa nhiều vừa nặng mà lại không làm UI bị kẹt cũng như trình duyệt bị đơ? Giải pháp đó là sử dụng callback bất đồng bộ (<strong>asynchronous callbacks</strong>).</p><p>Điều này sẽ được giải thích kỹ hơn trong Phần 2 của series: <strong>Bên trong engine V8 &amp; 5 mẹo để tối ưu hóa code</strong>. Các bạn đón xem nhé.</p><p>PS: Trong các bài sau mình sẽ trình bày chi tiết và kỹ hơn về cách hoạt động của Event Loop.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript càng ngày càng phổ biến, có nhiều nhóm các lập trình viên đã và đang nâng cấp cũng như hỗ trợ JS ở nhiều mức độ khác nhau: từ frontend đến backend, hybrid app, thiết bị nhúng và còn nhiều nữa.&lt;/p&gt;
&lt;p&gt;Bài viết này mở đầu cho 1 series hướng tới mục đích đào sâu (aka &lt;em&gt;Đục Khoét&lt;/em&gt;) vào trong Javascript và cách mà nó hoạt động như thế nào: Bằng cách hiểu rõ các thành phần của JS và cách mà chúng tương tác với nhau thì bạn có thể viết code tốt hơn và &lt;em&gt;ngon&lt;/em&gt; hơn. Bên cạnh đó team SessionStack cũng chia sẻ một vài bí kíp trong khi xây dựng SessionStack - 1 ứng dụng Javascript nhẹ nhưng có chất lượng cao và mạnh mẽ.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Một số nguyên tắc, định luật trong lập trình</title>
    <link href="http://nthung2112.github.io/2018/11/Mot-so-nguyen-tac-dinh-luat-trong-lap-trinh.html"/>
    <id>http://nthung2112.github.io/2018/11/Mot-so-nguyen-tac-dinh-luat-trong-lap-trinh.html</id>
    <published>2018-11-06T00:29:00.000Z</published>
    <updated>2018-11-06T00:41:54.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nguyen-tac-Demeter"><a href="#Nguyen-tac-Demeter" class="headerlink" title="Nguyên tắc Demeter"></a>Nguyên tắc Demeter</h2><p>Còn có tên gọi khác là nguyên tắc “càng biết ít càng tốt”.</p><p>Demeter là tên gọi của Nữ thần nông nghiệp, cũng là nữ thần phân phát trong thần thoại Hi Lạp. Tên bà được dùng để đánh dấu sự ra đời của nguyên tắc này, đây có thể xem là một triết lý nền tảng của việc lập trình được sinh ra từ một aspect-oriented programming (AOP) project cùng tên.<br><a id="more"></a><br>Quan điểm cơ bản của nguyên tắc này chính là : tối giản sự hiểu biết của 1 object về cấu trúc, thuộc tính của các object khác ngoài nó (bao gồm các thành phần con).</p><p><a href="http://en.wikipedia.org/wiki/Law_of_Demeter" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Law_of_Demeter</a></p><p>Nói một cách đơn giản là không được tiếp xúc với thuộc tính, method của các object khác một cách trực tiếp.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Vi phạm nguyên tắc Demeter</span><br><span class="line"><span class="built_in">console</span>.log(aStudent.class.grade)</span><br><span class="line"></span><br><span class="line">#Không vi phạm nguyên tắc Demeter</span><br><span class="line"><span class="built_in">console</span>.log(aStudent.getGrade())</span><br></pre></td></tr></table></figure><h2 id="Dinh-luat-Wirth"><a href="#Dinh-luat-Wirth" class="headerlink" title="Định luật Wirth"></a>Định luật Wirth</h2><p>“Software gets slower faster than hardware gets faster” – “Tốc độ tiến hóa của phần cứng không bằng tốc độ thoái hóa của phần mềm.”</p><p><a href="http://en.wikipedia.org/wiki/Wirth%E2%80%99s_law" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Wirth’s_law</a></p><p>Có lẽ ý chính của nó là : lập trình ngày càng dùng nhiều tài nguyên phong phú nên framework phải luôn tiến hóa để phục vụ cho việc đó. Suy ra, tốc độ phần cứng dù có tang lên đi nữa thì tốc độ phần mềm cũng chẳng hề thay đổi gì.</p><h2 id="Dinh-luat-Brook"><a href="#Dinh-luat-Brook" class="headerlink" title="Định luật Brook"></a>Định luật Brook</h2><p>Đây là một định luật dựa trên kinh nghiệm thực tế : “Đưa thêm người vào 1 project đang chậm, sẽ chỉ khiến nó càng chậm hơn.”</p><p>Hay có thể nói theo một cách khác nữa là “Tập hợp 9 bà bầu lại cũng không thể khiến đứa trẻ ra đời sau 1 tháng.”</p><p>Luận thuyết cơ bản của định luật này là</p><ul><li>Cần thời gian để quen với project </li><li>Công sức dành cho việc communication sẽ tăng </li></ul><p><a href="http://en.wikipedia.org/wiki/Brooks%27s_law" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Brooks’s_law</a></p><h2 id="Dinh-luat-Conway"><a href="#Dinh-luat-Conway" class="headerlink" title="Định luật Conway"></a>Định luật Conway</h2><p>“Organizations which design systems … are constrained to produce designs which are copies of the communication structures of these organizations.”</p><p>“Một công ty thiết kế hệ thống thế nào cũng sẽ làm ra những thiết kế giống y hệt với thiết kế hệ thống của chính công ty họ.”</p><p><a href="http://en.wikipedia.org/wiki/Conway%27s_law" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Conway’s_law</a></p><p>Nghiên cứu gần đây chỉ ra rằng hệ thống của công ty là nhân tố ảnh hưởng lớn nhất đến vấn đề phát sinh ra bug của sản phẩm.</p><p><a href="http://research.microsoft.com/apps/pubs/default.aspx?id=70535" target="_blank" rel="noopener">http://research.microsoft.com/apps/pubs/default.aspx?id=70535</a></p><h2 id="Nguyen-tac-bat-ngo-nho-nhat-least-astonishment"><a href="#Nguyen-tac-bat-ngo-nho-nhat-least-astonishment" class="headerlink" title="Nguyên tắc bất ngờ nhỏ nhất (least astonishment)"></a>Nguyên tắc bất ngờ nhỏ nhất (least astonishment)</h2><p>Trong trường hợp trên cùng 1 interface có 2 yếu tố hành xử mâu thuẫn với nhau, hoặc cách hành xử không rõ ràng thì cần phải chọn cách hành xử nào gây bất ngờ ít nhất cho người sử dụng.</p><p><a href="http://en.wikipedia.org/wiki/Principle_of_least_astonishment" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Principle_of_least_astonishment</a></p><p>Đây là 1 nguyên tắc về giao diện người dùng.</p><p>Một ví dụ đơn giản :</p><p>Trên 1 interface có 2 chức năng :</p><ul><li>Ấn ctrl+Q để thoát chương trình. </li><li>Nhập macro (lưu 1 tổ hợp phím mang 1 chức năng nào đó để tiện cho việc sử dụng về sau). </li></ul><p>Sẽ có trường hợp user muốn dùng Ctrl+Q cho macro của mình, nên hành xử đúng với nguyên tắc bất ngờ nhỏ nhất chính là : trong khi nhập macro thì ctrl+Q được coi như là tổ hợp phím bình thường, không phải là lệnh tắt chương trình. Đây chính là điều gây bất ngờ ít nhất cho người dùng.</p><h2 id="Nguyen-tac-Boy-Scout"><a href="#Nguyen-tac-Boy-Scout" class="headerlink" title="Nguyên tắc Boy Scout"></a>Nguyên tắc Boy Scout</h2><p>Nguyên tắc của các tổ chức Boy scout chính là : lúc đi phải sạch đẹp hơn lúc đến.</p><p>Trong lĩnh vực lập trình thì nguyên tắc đó sẽ được hiểu là “Khi bạn checkin 1 module thì lúc đó nó phải đẹp hơn lúc bạn checkout.”</p><h2 id="Nguyen-tac-YAGNI"><a href="#Nguyen-tac-YAGNI" class="headerlink" title="Nguyên tắc YAGNI"></a>Nguyên tắc YAGNI</h2><p>Viết tắt của “You ain’t gonna need it” – Cái (chức năng, phần) ấy rồi sẽ không cần thiết.</p><p>Đó là một câu khẩu ngữ nhắc nhở người lập trình rằng trong quy trình Extreme Programming (lập trình cực hạn) thì : “Chưa phải lúc cần thiết thì chưa được phép làm.”</p><h2 id="Nguyen-tac-DRY"><a href="#Nguyen-tac-DRY" class="headerlink" title="Nguyên tắc DRY"></a>Nguyên tắc DRY</h2><p>Viết tắt của “Don’t repeat yourself” – với ý nghĩa là “Đừng lặp lại những gì giống nhau”.</p><p><a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Don’t_repeat_yourself</a></p><p>Khi nguyên tắc này được áp dụng tốt, dù ta có thay đổi 1 phần thì những phần không liên quan cũng sẽ không bị thay đổi theo. Hơn nữa, những phần có liên quan sẽ được thay đổi cùng 1 lượt, giúp ích rất nhiều cho cả khâu estimate và khâu thực hiện.</p><h2 id="Nguyen-tac-KISS"><a href="#Nguyen-tac-KISS" class="headerlink" title="Nguyên tắc KISS"></a>Nguyên tắc KISS</h2><p>Viết tắt của “Keep it simple, stupid” – “Cứ đơn giản thôi, đồ ngu!”. Đây là 1 triết lí của Hải quân Mỹ.</p><p><a href="http://en.wikipedia.org/wiki/KISS_principle" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/KISS_principle</a></p><p>Những triết lý tương tự có thể kể đến là :</p><p><strong>Phương châm dao cạo Okham (Okham’s razor)</strong> – “Không đưa ra nhiều giả thiết nếu không cần thiết. Cái gì cần ít giả thiết để chứng minh sẽ không thể chứng minh được bằng nhiều giả thiết.”</p><p><strong>Albert Einstein</strong> – “Làm cái gì cũng nên đơn giản nhất có thể, nhưng đơn giản quá thì không được”.</p><p><strong>Leonardo da Vinci</strong> – “Đơn giản nhất chính là điêu luyện nhất”.</p><p><strong>Antoine de Saint- Exupéry</strong> – “Hoàn hảo, không phải là không thêm vào được nữa, mà là không thể bớt đi được nữa”.</p><h2 id="Nguyen-tac-SOLID"><a href="#Nguyen-tac-SOLID" class="headerlink" title="Nguyên tắc SOLID"></a>Nguyên tắc SOLID</h2><p>Tập hợp những nguyên tắc trong lập trình hướng đối tượng. Các chữ cái đầu hợp lại thành SOLID.</p><p><a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)</a>)</p><p><strong>SRP (Single Responsibility Principle)</strong> – “Một class chỉ được có 1 nhiệm vụ” hay nói cách khác, “nếu muốn chỉnh sửa class thì chỉ được phép có 1 và chỉ 1 lý do”.</p><p><strong>OCP (Open/closed principle)</strong> – “Mở class khi cần mở rộng nó, đóng class khi cần chỉnh sửa nó”.</p><p><strong>LSP (Liskov substitution principle)</strong> – “Subtype phải luôn có thể được thay thế bằng supertype”.</p><p><strong>ISP (Interface segregation principle)</strong> – “Việc dùng nhiều interface cho các client khác nhau, tốt hơn là việc chỉ dùng 1 interface cho cùng lúc nhiều mục đích” hay nói cách khác “Không được phép hạn chế access vào những method mà client không sử dụng”.</p><p><strong>DIP (Dependency inversion principle)</strong> – “Module tầng trên không được phụ thuộc vào module tầng dưới. Bất cứ module nào cũng phải phụ thuộc vào cái trừu tượng, không phải vào cái cụ thể”.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nguyen-tac-Demeter&quot;&gt;&lt;a href=&quot;#Nguyen-tac-Demeter&quot; class=&quot;headerlink&quot; title=&quot;Nguyên tắc Demeter&quot;&gt;&lt;/a&gt;Nguyên tắc Demeter&lt;/h2&gt;&lt;p&gt;Còn có tên gọi khác là nguyên tắc “càng biết ít càng tốt”.&lt;/p&gt;
&lt;p&gt;Demeter là tên gọi của Nữ thần nông nghiệp, cũng là nữ thần phân phát trong thần thoại Hi Lạp. Tên bà được dùng để đánh dấu sự ra đời của nguyên tắc này, đây có thể xem là một triết lý nền tảng của việc lập trình được sinh ra từ một aspect-oriented programming (AOP) project cùng tên.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Khi nào nên sử dụng PureComponent hoặc Component</title>
    <link href="http://nthung2112.github.io/2018/10/Khi-nao-nen-su-dung-PureComponent-hoac-Component.html"/>
    <id>http://nthung2112.github.io/2018/10/Khi-nao-nen-su-dung-PureComponent-hoac-Component.html</id>
    <published>2018-10-17T00:57:00.000Z</published>
    <updated>2018-11-07T01:00:18.161Z</updated>
    
    <content type="html"><![CDATA[<p>PureComponent tiền đề của nó là một phiên bản có hiệu suất cao hơn của Component. Điều này là đúng, nhưng hiệu suất đạt được đi cùng với một vài thứ đi kèm. Chúng ta hãy tìm hiểu về PureComponent và hiểu tại sao chúng ta nên sử dụng nó nhé.<br><a id="more"></a></p><h2 id="Component-va-PureComponent-co-mot-su-khac-biet"><a href="#Component-va-PureComponent-co-mot-su-khac-biet" class="headerlink" title="Component và PureComponent có một sự khác biệt"></a>Component và PureComponent có một sự khác biệt</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PureComponent chính xác giống như Component ngoại trừ việc đó là nó xử lý shouldComponentUpdate cho bạn.</span><br></pre></td></tr></table></figure><p>Khi props hoặc state thay đổi, PureComponent sẽ làm một <em>shallow comparison</em> (so sánh nông) trên cảm props và state. Component trên mặt khác sẽ không so sánh props và state của hiện tại với tương lai. Như vậy, component sẽ re-render bởi mặc định bất cứ khi nào shouldComponentUpdate gọi.</p><h2 id="Shallow-Comparison-101"><a href="#Shallow-Comparison-101" class="headerlink" title="Shallow Comparison 101"></a>Shallow Comparison 101</h2><p>Khi so sánh props và state trước và sau, một <em>shallow comparison</em> sẽ kiểm tra những giá trị nguyên thuỷ đó có cùng giá trị(ví dụ 1 bằng 1 hoặc <em>true</em> bằng với <em>true</em>) và rằng các <em>references value</em> là giống nhau giữa các giá trị javascript phức tạp như objects và arrays.</p><h2 id="Never-MUTATE"><a href="#Never-MUTATE" class="headerlink" title="Never MUTATE"></a>Never MUTATE</h2><p>Bạn có lẽ đã nghe không thay đổi objects và arrays trong props và state. Nếu bạn thay đổi object trong một component cha, component “pure” con của bạn sẽ không update. Mặc dù giá trị đã thay đổi ở component cha, component con sẽ so sánh <em>reference</em> tới props trước đó và không phát hiện ra sự khác biệt chúng vân cùng reference tới cùng một object.</p><p>Thay vào đó trả về một objects mới khi bạn làm một sự thay đổi bằng cách tận dụng es6 cho object và array <em>spreading</em> hoặc sử dụng một thư viện để thi hành <em>immutability</em>.</p><h2 id="Co-van-de-voi-hieu-nang-khong"><a href="#Co-van-de-voi-hieu-nang-khong" class="headerlink" title="Có vấn đề với hiệu năng không?"></a>Có vấn đề với hiệu năng không?</h2><p>So sánh primitives và object references là một hoặt động <strong>vô cùng rẻ tiền</strong>. Nếu bạn có một danh sách của object con và một trong đó update, làm một kiểm tra trên props và state của chúng là so sánh nhanh như ánh sáng so với chi phí của việc re-render từng cái một.</p><h1 id="Nhung-cach-khac-ban-co-the-lam-de-tang-hieu-nang"><a href="#Nhung-cach-khac-ban-co-the-lam-de-tang-hieu-nang" class="headerlink" title="Những cách khác bạn có thể làm để tăng hiệu năng"></a>Những cách khác bạn có thể làm để tăng hiệu năng</h1><h3 id="Dung-bind-gia-tri-vao-fuction-trong-render"><a href="#Dung-bind-gia-tri-vao-fuction-trong-render" class="headerlink" title="Đừng bind giá trị vào fuction trong render"></a>Đừng bind giá trị vào fuction trong render</h3><p>Bạn có một danh sách các items, mỗi lần chuyền một tham số độc nhất tới phương thức cha. Theo thứ tự bind parameter bạn có lẽ sẽ hoàn thành như thê này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CommentItem likeComment=&#123;() =&gt; <span class="keyword">this</span>.likeComment(user.id)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>vấn đề đó là mỗi lần component cha render method sẽ gọi, một function mới (với một reference mới) được tạo ra và chuyền xuống <strong>LikeComnent</strong>. Điều này có side effect của thay đổi props trên mỗi component con mà lần lượt sẽ là nguyên nhân tât cả chúng re-render, thậm chí tất cả dữ liệu là giống nhau.</p><p>Để giải quyết vấn đề này, chỉ cần chuyền function nguyên mẫu từ component cha tới con. prop của <strong>LikeComent</strong> sẽ luôn luôn có cùng reference và không bao giờ gây ra re-render không cần thiết.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CommentItem likeComment=&#123;<span class="keyword">this</span>.likeComment&#125; userID=&#123;user.id&#125; /&gt;</span><br></pre></td></tr></table></figure><p>Sau đó trong component con tạo ra một class method sẽ reference props của nó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentItem</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  handleLike() &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.likeComment(<span class="keyword">this</span>.props.userID)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dung-lay-du-lieu-trong-render"><a href="#Dung-lay-du-lieu-trong-render" class="headerlink" title="Đừng lấy dữ liệu trong render"></a>Đừng lấy dữ liệu trong render</h3><p>Xem xét một danh sách của các bài viết từ đó component hồ sơ của bạn sẽ hiển thị 10 người dùng bạn thích nhất.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; posts &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="keyword">const</span> topTen = [...posts].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> </span><br><span class="line">    b.likes - a.likes).slice(<span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TopTen</strong> sẽ có một <em>new reference</em> mỗi lần component re-render, mặc dù <strong>posts</strong> không có sự thay đổi và dữ liệu có cùng nguồn gốc. Điều này sau đó sẽ re-render list một cách không cần thiết.</p><p>Bạn có thể giải quyết điều này bởi <em>caching</em> dữ liệu gốc. Cho ví dụ, đặt dữ liệu gốc trong state của component và update chỉ khi <strong>posts</strong> có updated.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setTopTenPosts(<span class="keyword">this</span>.props.posts)</span><br><span class="line">&#125;</span><br><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.posts !== nextProps.posts) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setTopTenPosts(nextProps.posts)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTopTenPosts(posts) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    topTen: [...posts].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.likes - a.likes).slice(<span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nếu bạn sử dụng Redux, xem xét sử dụng <a href="https://github.com/reduxjs/reselect" target="_blank" rel="noopener">reselect</a> để tạo “selectors” để soạn và cache dữ liệu gốc.</p><h1 id="Tong-ket"><a href="#Tong-ket" class="headerlink" title="Tổng kết"></a>Tổng kết</h1><p>An toàn khi sử dụng pureComponent thay thế Component miễn là bạn theo hai quy tắc đơn giản sau:</p><ol><li>Thay đổi đột ngột <strong>reference value</strong> nhìn chung là không tốt. Nhưng vấn đề là phức tạp khi sử dụng PureComponent.</li><li>Nếu bạn tạo ra một function, object, array mới trong render bạn (có lẽ) làm nó sai.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PureComponent tiền đề của nó là một phiên bản có hiệu suất cao hơn của Component. Điều này là đúng, nhưng hiệu suất đạt được đi cùng với một vài thứ đi kèm. Chúng ta hãy tìm hiểu về PureComponent và hiểu tại sao chúng ta nên sử dụng nó nhé.&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://nthung2112.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Redux hay MobX: Lý giải sự nhầm lẫn</title>
    <link href="http://nthung2112.github.io/2018/09/Redux-hay-MobX-Ly-giai-su-nham-lan.html"/>
    <id>http://nthung2112.github.io/2018/09/Redux-hay-MobX-Ly-giai-su-nham-lan.html</id>
    <published>2018-09-06T00:18:00.000Z</published>
    <updated>2018-11-06T00:20:35.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chung-ta-can-giai-quyet-van-de-gi"><a href="#Chung-ta-can-giai-quyet-van-de-gi" class="headerlink" title="Chúng ta cần giải quyết vấn đề gì?"></a>Chúng ta cần giải quyết vấn đề gì?</h1><p>Tất cả chúng ta đều muốn có một cách nào đó để quản lý state trong một ứng dụng. Nhưng bạn đã bao giờ tự hỏi nó giải quyết được vấn đề gì cho chúng ta chưa? Hầu hết các lập trình viên đều sử dụng một thư viện quản lý state ngay cả đối với những ứng dụng nhỏ. Hiển nhiên thôi mà, khi tất cả những người khác đều nói về chúng, tất nhiên chúng ta cũng phải bắt kịp xu thế chứ? Redux này, MobX này. Thế nhưng hầu hết các ứng dụng lại không cần đến những công cụ quản lý state phức tạp đến vậy. Nó còn nguy hiểm hơn, vì hầu hết mọi người sẽ không bao giờ gặp những vấn đề mà những thư viện như Redux hay MobX cố gắng để giải quyết.<br><a id="more"></a><br>Ngày nay, một hiện trạng mà chúng ta dễ dàng thấy là việc mọi người đều viết ra những frontend app với các component. Component thì có state nội tại. Ví dụ trong React thì state nội tại đó được xử lý bằng this.state và this.setState(). Với những app lớn, vấn đề guản lý state có thể trở nên khó khăn với state nội bộ bởi vì:</p><ul><li>Một component cần phải chia sẻ state với một component khác.</li><li>Một component cần phải thay đổi state của một component khác.</li></ul><p>Đến một lúc nào đó, vấn đề này càng ngày càng trở nên khó giải quyết khi nó trở thành một đống hỗn loạn các state object và các thay đổi diễn ra chồng chéo nhau khắp các component và rất khó để chúng ta có thể quản lý tất cả một cách hiệu quả.</p><p>Suy ra để giải quyết vấn đề này, chúng ta có thể sử dụng thư viện như MobX hay Redux. Những thư viện này cung cấp cho chúng ta công cụ để lưu giữ state, thay đổi state và nhận những thay đổi của state. Bạn có một chỗ để tìm state, một chỗ để thay đổi nó và cũng một chỗ để nhận các thay đổi. Chúng tuân theo nguyên tắc single source of truth (chỉ một nơi để lưu trữ toàn bộ state). Nó làm cho việc quản lý state trở nên dễ dàng hơn vì nó được tách rời khỏi các component của bạn.</p><p>Các thư viện quản lý state như Redux hay MobX thường có các add-on đi kèm, như với React thì chúng ta có react-redux và mobx-react, để cung cấp cho các component cách để truy cập các state. Thường thì các component đó được gọi là container component, hay chính xác hơn là, connected component. Bạn có thể truy cập hoặc thay đổi state từ bất cứ đâu trong ứng dụng của bạn bằng cách biến các component thành các connected component.</p><h1 id="Redux-va-MobX-co-gi-khac-nhau"><a href="#Redux-va-MobX-co-gi-khac-nhau" class="headerlink" title="Redux và MobX có gì khác nhau?"></a>Redux và MobX có gì khác nhau?</h1><p>Trước khi chúng ta nói về những khác biệt, tôi muốn nói về một số điểm chung giữa MobX và Redux.</p><p>Cả 2 thư viện đều được dùng để quản lý state trong các ứng dụng Javascript. Chúng không nhất thiết phải đi kèm với một thư viện như React. Chúng cũng được dùng trong những thư viện khác như AngularJs hay VueJs nữa. Nhưng chúng kết hợp rất tốt với triết lý của React.</p><p>Nếu bạn chọn dùng một thư viện để quản lý state, bạn sẽ không bị ràng buộc bởi nó. Bạn có thể chuyển qua sử dụng một thư viện khác bất kỳ lúc nào. Bạn hoàn toàn có thể chuyển từ MobX sang Redux hoặc ngược lại.</p><p>Redux bởi Dan Abramov và Andrew Clark là một biến thể của kiến trúc flux. Trái ngược với flux, nó chỉ sử dụng duy nhất một store để lưu trữ state. Hơn nữa, thay vì sử dụng một dispatcher, nó dùng các pure function để thay đổi state. Redux bị ảnh hưởng rất nhiều bởi các nguyên tắc của functional programming (FP). Chúng ta có thể có FP trong Javascript, nhưng rất nhiều người đã quen với OOP như Java, và họ gặp rất nhiều khó khăn trong việc ứng dụng các nguyên tắc này. Điều này cũng lý giải tại sao MobX có thể sẽ dễ học hơn đối với người mới.</p><p>Bởi vì Redux áp dụng các nguyên tắc của FP, nó sử dụng hàm thuần khiết. Một hàm nhận input, trả về output và không có thêm bất cứ sự phụ thuộc nào khác. Một hàm thuần khiết luôn trả về cùng một output đối với cùng một input và không hề có side effect.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(state, action) =&gt; newState</span><br></pre></td></tr></table></figure><p>Redux state là <strong>immutable</strong>. Thay vì thay đổi state, bạn luôn trả về một state mới. Bạn không bao giờ trực tiếp thay đổi object state hay phụ thuộc vào tham chiếu đến object.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Đừng làm thế này trong Redux vì nó trực tiếp thay đổi array</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAuthor</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> state.authors.push(action.author);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Luôn giữ state immutable và trả về object mới</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAuthor</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [ ...state.authors, action.author ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Điều cuối cùng nhưng ko kém phần quan trọng, state của bạn được normalize như trong một database. Các entity chỉ tham chiếu đến nhau bằng id. Đó là cách làm tốt nhất. Mặc dù không phải tất cả mọi người đều làm vậy, bạn có thể sử dụng một thư viện như normalizr để đạt được state đã chuẩn hóa. Normalized state giúp cho chúng ta có một state phẳng và lưu giữ các entity như một nguồn duy nhất.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  post: &#123;</span><br><span class="line">    id: <span class="string">'a'</span>,</span><br><span class="line">    authorId: <span class="string">'b'</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  author: &#123;</span><br><span class="line">    id: <span class="string">'b'</span>,</span><br><span class="line">    postIds: [<span class="string">'a'</span>, ...],</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trong khi đó, MobX bởi Michel Weststrate lại chịu ảnh hưởng của lập trình hướng đối tượng, nhưng cũng một phần bởi lập trình phản ứng (Reactive programming). Nó đống gói state của bạn thành những observable. Vì thế bạn có mọi khả năng của một Observable trong state của bạn. Dữ liệu có thể chỉ cần có setter và getter thôi, nhưng observable làm cho chúng ta có khả năng nhận update khi dữ liệu thay đổi.</p><p>Trong MobX, state là <strong>mutable</strong>. Nghĩa là bạn thay đổi state trực tiếp:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAuthor</span>(<span class="params">author</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.authors.push(author);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thêm nữa, các entity tồn tại dưới một cấu trúc dữ liệu lồng nhau. Bạn không cần chuẩn hóa state. State được giữ không chuẩn hóa và có thể lồng nhiều tầng.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  post: &#123;</span><br><span class="line">    id: <span class="string">'a'</span>,</span><br><span class="line">    ...</span><br><span class="line">    author: &#123;</span><br><span class="line">      id: <span class="string">'b'</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-Store-va-nhieu-Store"><a href="#1-Store-va-nhieu-Store" class="headerlink" title="1 Store và nhiều Store"></a>1 Store và nhiều Store</h3><p>Trong Redux bạn giữ mọi state trong một global store/global state. State object này là nguồn dữ liệu duy nhất của bạn. Mặt khác, chúng ta sử dụng nhiều reducer để thay đổi state này.</p><p>Trái lại, MobX lại dùng nhiều store. Tương tự như reducer của Redux, bạn có thể áp dụng chia để trị bằng cách phân bổ chúng thành nhiều tầng dữ liệu. Bạn có thể muốn có các domain entity trong một store riêng nhưng vẫn có khả năng kiểm soát state của view trong một trong các store của bạn. Sau cùng thì bạn là người quyết định và định hướng lại cấu trúc state nào có lợi cho ứng dụng của bạn nhất.</p><p>Trên lý thuyết bạn cũng có thể có nhiều store trong Redux. Không có ai bắt bạn phải dùng chỉ một store cả. Nhưng đó không phải là cách người ta khuyên dùng Redux. Nó sẽ làm trái lại những best practice nếu bạn dùng nhiều store. Trong Redux bạn chỉ cần có một store thôi và phản ứng với những thay đổi thông qua reducer và các global event.</p><h3 id="Implementation-nhin-nhu-the-nao"><a href="#Implementation-nhin-nhu-the-nao" class="headerlink" title="Implementation nhìn như thế nào?"></a>Implementation nhìn như thế nào?</h3><p>Trong Redux, bạn sẽ cần đoạn code như dưới đây để thêm một user vào global state. Bạn có thể thấy chúng ta có thể sử dụng spread operator để trả về một state object mới. Bạn cũng có thể dùng Object.assign() để tạo ra một immutable object trong ES5.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  users: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Dan'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Michel'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">users</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'USER_ADD'</span>:</span><br><span class="line">    <span class="keyword">return</span> &#123; ...state, <span class="attr">users</span>: [ ...state.users, action.user ] &#125;;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// action</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'USER_ADD'</span>, <span class="attr">user</span>: user &#125;;</span><br></pre></td></tr></table></figure><p>Bạn sẽ cần phải gọi dispatch({ type: ‘USER_ADD’, user: user }); để thêm một user mới vào global state.</p><p>Trong MobX, một store sẽ chỉ quản lý một substate (như một reducer trong Redux quản lý một substate) nhưng bạn có thể thay đổi state một cách trực tiếp. Annotation @observable giúp cho chúng ta có khả năng nhận update khi state thay đổi.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserStore</span> </span>&#123;</span><br><span class="line">  @observable users = [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Dan'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Michel'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Giờ thì chúng ta có thể gọi userStore.users.push(user); vào một instance của store. Tuy vậy best practice đó là xử lý việc thay đổi state rõ ràng hơn với các action.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserStore</span> </span>&#123;</span><br><span class="line">  @observable users = [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Dan'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Michel'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  @action addUser = <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.users.push(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bạn có thể bắt buộc việc sử dụng action bằng cách cấu hình Mobx với configure({ enforceActions: true });. Giờ thì bạn có thể thay đổi state bằng cách gọi userStore.addUser(user); với một instance của store.</p><p>Bạn đã thấy cách chúng ta cập nhật state trong cả Redux và MobX. Chúng rất khác nhau. Trong Redux state của bạn là read-only. Bạn chỉ có thể thay đổi state bằng các action rõ ràng. Ngược lại, state trong MobX lại có thể vừa read và vừa write. Bạn có thể thay đổi state trực tiếp mà không cần dùng action, nhưng bạn cũng có thể bắt buộc sử dụng action với cấu hình đã nói ở trên.</p><h1 id="Learning-curve-cua-quan-ly-state-trong-React"><a href="#Learning-curve-cua-quan-ly-state-trong-React" class="headerlink" title="Learning curve của quản lý state trong React"></a>Learning curve của quản lý state trong React</h1><p>Cả Redux và MobX đều hầu hết được sử dụng trong các ứng dụng React. Nhưng bản chất của chúng thì là những thư viện quản lý state độc lập, và có thể được dùng mà không cần đến React. Chúng còn có những thư viện hỗ trợ tương thích để làm cho việc kết hợp với React component trở nên dễ dàng hơn, đó là react-redux cho Redux + React và mobx-react cho MobX + React.</p><p>Trong những thảo luận trên các diễn đàn công nghệ thì một vấn đề mà người ta hay nói đến đó là learning curve của Redux. Thường thì nó diễn ra trong bối cảnh mọi người bắt đầu học React nhưng đã muốn tìm hiểu là làm thế nào để quản lý state với Redux. Nhiều người sẽ cho rằng React và Redux nằm riêng thì có một learning curve khá tốt, nhưng kết hợp cả 2 lại thì chúng lại khó hiểu hơn nhiều. Vì thế MobX được coi là một giải pháp thay thế vì nó phù hợp hơn với những người mới học.</p><p>Tuy vậy, tôi muốn gợi ý một cách tiếp cận khác cho các bạn mới học React về vấn đề quản lý state, đó là bắt đầu với chính những tính năng quản lý state nội bộ của component. Trong một ứng dụng React, điều đầu tiên mà bạn sẽ học đó là các hàm nằm trong vòng đời của một component và làm thế nào để quản lý state bằng setState() và this.state. Đây là một cách học mà tôi đánh giá rất cao. Nếu không theo cách này, bạn sẽ rất dễ bị choáng ngợp bởi hệ sinh thái của React. Đến một thời điểm nào đó với cách học này, bạn sẽ nhận ra rằng việc quản lý các state nội bộ của component càng ngày càng trở nên khó hơn. Đó là lúc mà chúng ta trả lời câu hỏi: Vấn đề mà MobX và Redux giải quyết cho chúng ta là gì? Cả 2 đều cung cấp một cách để quản lý state của ứng dụng độc lập với các component. State được tách biệt hoàn toàn khỏi component. Component có thể truy cập state, thay đổi nó và nhận những cập nhật với state mới. State đó chính là single source of truth.</p><h3 id="Redux-hay-MobX-cho-nguoi-moi"><a href="#Redux-hay-MobX-cho-nguoi-moi" class="headerlink" title="Redux hay MobX cho người mới?"></a>Redux hay MobX cho người mới?</h3><p>Một khi bạn đã quen với việc sử dụng component và quản lý state nội bộ, bạn có thể chọn một thư viện để giải quyết vấn đề này. Sau khi đã dùng cả 2 thư viện, tôi cho rằng MobX rất phù hợp đối với người mới. Chúng ta đều đã thấy MobX cần ít code hơn, dù cho nó sử dụng vài loại annotation mà có lẽ chúng ta chưa cần hiểu về chúng.</p><p>Với MobX bạn không cần phải làm quen với lập trình hàm hay phải hiểu những thuật ngữ như immutability. Lập trình hàm là một mô hình đang phát triển rất nhanh, nhưng lại xa lạ với hầu hết các lập trình viên Javascript. Dù thế giới lập trình đang dần được đẩy theo xu hướng này nhưng không phải ai cũng có kinh nghiệm về nó, nên các nguyên lý của MobX sẽ dễ dàng để hiểu hơn đối với những người đã biết về hướng đối tượng.</p><h3 id="Mot-ung-dung-dang-phat-trien"><a href="#Mot-ung-dung-dang-phat-trien" class="headerlink" title="Một ứng dụng đang phát triển"></a>Một ứng dụng đang phát triển</h3><p>Trong MobX, bạn thay đổi object có annotation và component của bạn sẽ tự động render lại. MobX đem đến nhiều xử lý nội bộ hơn là Redux, nên sẽ làm cho nó dễ dùng hơn lúc đầu vì bạn phải viết ít code hơn. Nếu bạn đã biết Angular thì sẽ thấy dùng MobX giống như là two-way data binding vậy. Bạn giữ một vài state ở đâu đó, theo dõi state bằng annotation và để cho component tự update một khi state thay đổi.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// component</span></span><br><span class="line">&lt;button onClick=&#123;() =&gt; store.users.push(user)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>Cách tốt hơn để làm điều này đó là sử dụng <a href="https://viblo.asia/u/action" target="_blank" rel="noopener">@action</a> trong store.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// component</span></span><br><span class="line">&lt;button onClick=&#123;() =&gt; store.addUser(user)&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store</span></span><br><span class="line">@action addUser = <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.users.push(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nó sẽ làm cho việc thay đổi state trở nên minh bạch hơn với các action. Hơn nữa chúng ta cũng có thể bắt buộc việc sử dụng action để thay đổi state bằng cách mà tôi đã nói ở trên.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root file</span></span><br><span class="line"><span class="keyword">import</span> &#123; configure &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"></span><br><span class="line">configure(&#123; <span class="attr">enforceActions</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>Việc thay đổi state trực tiếp trong store như chúng ta đã làm ở ví dụ thứ nhất sẽ không còn hoạt động nữa. Việc sử dụng action là một trong các best practice của MobX. Hơn nữa một khi bạn chỉ dùng action, bạn đã áp dụng các ràng buộc của Redux.</p><p>Tôi xin gợi ý rằng chúng ta nên sử dụng MobX để bắt đầu một dự án. Một khi ứng dụng đã bắt đầu to lên, đó cũng là điều dễ hiểu khi chúng ta bắt buộc việc sử dụng các action. Điều này cũng đi theo đường lối của Redux đó là chúng ta không bao giờ thay đổi trực tiếp state mà lúc nào cũng phải thông qua các action.</p><h3 id="Chuyen-sang-Redux"><a href="#Chuyen-sang-Redux" class="headerlink" title="Chuyển sang Redux"></a>Chuyển sang Redux</h3><p>Khi mà ứng dụng của bạn lớn dần và có thêm nhiều dev cùng làm việc, bạn nên chuyển qua dùng Redux. Bản chất của nó là việc nó bắt buộc sử dụng action để thay đổi state chứ không thông qua config như MobX. Action bao gồm kiểu và một payload và reducer có thể dùng để thay đổi state.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducer</span></span><br><span class="line">(state, action) =&gt; newState</span><br></pre></td></tr></table></figure><p>Redux cung cấp cho bạn cả một cấu trúc để quản lý state với những ràng buộc rõ ràng. Đó là <a href="https://www.youtube.com/watch?v=uvAXVMwHJXU" target="_blank" rel="noopener">lý do mà Redux rất thành công.</a></p><p>Một điểm mạnh khác của Redux đó là việc sử dụng nó ở server side. Bởi vì chúng ta đang làm việc với Javascript object, bạn có thể gửi state qua mạng được. Serialize và deserialize các state object hoạt động một cách tự động mà bạn không cần làm thêm gì cả. Bạn cũng có thể làm như thế với MobX nữa.</p><p>MobX thì không có nhiều ràng buộc nhưng bạn cũng có thể tự tạo ra chúng bằng các config. Đó là lí do tại sao tôi không nói là bạn không thể dùng MobX với những ứng dụng lớn, nhưng Redux thì giúp chúng ta có một cách làm nhất quán hơn. Doc của MobX cũng có nói là: “MobX không hướng dẫn cho bạn cách bạn cấu trúc code, lưu state ở đâu hay xử lý các event như thế nào.” Team của bạn cần phải tự cấu trúc việc quản lý state nếu sử dụng thư viện này.</p><p>Cuối cùng thì việc học quản lý state không khó như chúng ta nghĩ. Để tóm gọn lại vấn đề, một người mới học React đầu tiên sẽ học cách sử dụng setState() và this.state. Sau một thời gian thì họ sẽ thấy khó khăn với việc chỉ dùng setState() để quản lý state cho cả ứng dụng. Khi đi tìm giải pháp, họ gặp được những thư viện như MobX hay Redux. Nhưng nên chọn cái nào bây giờ? Bởi vì MobX có ít ràng buộc hơn, cần ít code hơn và dùng cũng tương tự như setState(), tôi nghĩ nó rất thích hợp với các ứng dụng vừa và nhỏ. Một khi ứng dụng đã to dần lên, bạn nên xem xét việc tạo ra thêm ràng buộc bằng config trong MobX hoặc chuyển sang dùng Redux.</p><h1 id="Loi-ket"><a href="#Loi-ket" class="headerlink" title="Lời kết"></a>Lời kết</h1><p>Mỗi khi tôi đọc comment về tranh luận giữa Redux và MobX, luôn luôn có 1 comment kiểu này: “Redux có quá nhiều code thừa, bạn nên dùng MobX đi. Tôi đã bỏ được XXX dòng code đấy.” Comment này có thể đúng, nhưng họ chưa xem xét đến những sự đánh đổi. Redux có nhiều code thừa hơn MobX, vì nó được thêm vào vì những ràng buộc cụ thể trong thiết kế. Nó cho phép bạn có cái nhìn tổng quan hơn về state của ứng dụng dù ứng dụng đó lớn thế nào. Không phải tự nhiên mà nó là một trong những thư viện phổ biến nhất đâu.</p><p>Thư viện Redux có kích thước khá là nhỏ. Hầu hết thời gian bạn sẽ dành để xử lý Javascript object và array. Nó giống với Javascript thuần hơn là MobX. Trong MobX, chúng ta gói object và array vào trong observable object và điều này giấu đi hầu hết các boilerplate code. Nó được xây dựng dựa trên tính trừu tượng ẩn. Nó sẽ thực hiện một phép thuật nào đó và code bạn tự nhiên chạy được, nhưng đồng thời cũng làm cho các cơ chế ở tầng dưới trở nên khó hiểu hơn nhiều. Với Redux thì chúng ta test và debug ứng dụng dễ hơn vì nó chỉ sử dụng Javascript thuần.</p><p>Trong khi với Redux, chúng ta có một cách nhất định để làm mọi thứ thì MobX lại ít ràng buộc hơn. Nhưng dù vậy chúng ta vẫn nên tuân theo các best practice trong MobX, vì như thế sẽ dễ dàng hơn trong việc lí giải thay đổi của state.</p><p>Cả 2 thư viện đều rất tốt. Trong khi Redux đã được chứng minh trong thế giới React, MobX đang dần trở thành một giải pháp thay thế đáng chú ý.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Chung-ta-can-giai-quyet-van-de-gi&quot;&gt;&lt;a href=&quot;#Chung-ta-can-giai-quyet-van-de-gi&quot; class=&quot;headerlink&quot; title=&quot;Chúng ta cần giải quyết vấn đề gì?&quot;&gt;&lt;/a&gt;Chúng ta cần giải quyết vấn đề gì?&lt;/h1&gt;&lt;p&gt;Tất cả chúng ta đều muốn có một cách nào đó để quản lý state trong một ứng dụng. Nhưng bạn đã bao giờ tự hỏi nó giải quyết được vấn đề gì cho chúng ta chưa? Hầu hết các lập trình viên đều sử dụng một thư viện quản lý state ngay cả đối với những ứng dụng nhỏ. Hiển nhiên thôi mà, khi tất cả những người khác đều nói về chúng, tất nhiên chúng ta cũng phải bắt kịp xu thế chứ? Redux này, MobX này. Thế nhưng hầu hết các ứng dụng lại không cần đến những công cụ quản lý state phức tạp đến vậy. Nó còn nguy hiểm hơn, vì hầu hết mọi người sẽ không bao giờ gặp những vấn đề mà những thư viện như Redux hay MobX cố gắng để giải quyết.&lt;br&gt;
    
    </summary>
    
    
      <category term="mobx" scheme="http://nthung2112.github.io/tags/mobx/"/>
    
      <category term="redux" scheme="http://nthung2112.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>Cách tối ưu trang web của bạn với nén Gzip</title>
    <link href="http://nthung2112.github.io/2018/08/Cach-toi-uu-trang-web-cua-ban-voi-nen-Gzip.html"/>
    <id>http://nthung2112.github.io/2018/08/Cach-toi-uu-trang-web-cua-ban-voi-nen-Gzip.html</id>
    <published>2018-08-07T13:45:00.000Z</published>
    <updated>2018-09-07T13:53:33.634Z</updated>
    
    <content type="html"><![CDATA[<p>Nén là một phương pháp đơn giản, hiệu quả để tiết kiệm băng thông và tăng tốc trang web của bạn. Tôi đã ngần ngại khi gợi ý sử dụng nén gzip khi <a href="https://betterexplained.com/articles/speed-up-your-javascript-load-time/" target="_blank" rel="noopener">tăng tốc tải file javascript của bạn</a> vì một vài vấn đề ở trình duyệt cũ.</p><p>Nhưng giờ là thế kỷ 21. Hầu hết các truy cập đến trang của tôi đều từ các trình duyệt hiện đại, và thẳng thắn mà nói, hầu hết người dùng của tôi đều am hiểu công nghệ. Tôi không muốn làm mọi người chậm lại vì một vài người đang bám lấy IE 4 trên Windows 95. Google và Yahoo dùng nén gzip. Một trình duyệt hiện đại cần được tận hưởng nội dung và tốc độ của web hiện đại - vậy thì sử dụng gzip mã hóa nó. Dưới đây là cách cài đặt.<br><a id="more"></a></p><h2 id="Khoan-khoan-khoan-tai-sao-chung-ta-lai-lam-dieu-nay"><a href="#Khoan-khoan-khoan-tai-sao-chung-ta-lai-lam-dieu-nay" class="headerlink" title="Khoan, khoan, khoan: tại sao chúng ta lại làm điều này?"></a>Khoan, khoan, khoan: tại sao chúng ta lại làm điều này?</h2><p>Trước khi chúng ta bắt đầu, tôi nên giải thích nội dung được mã hóa là gì. Khi bạn yêu cầu một file, ví dụ như <code>http://www.yahoo.com/index.html</code>, trình duyệt của bạn nói chuyện với một web server. Đoạn hội thoại sẽ diễn ra kiểu như sau:</p><p><img src="https://betterexplained.com/wp-content/uploads/compression/HTTP_request.png" alt=""></p><ol><li>Trình duyệt: Này, <strong>GET</strong> cho tôi /index.html</li><li>Server: Ok, để tôi tìm xem index.html có không</li><li>Server: Tìm thấy rồi! Mã phản hồi của anh đây (200 OK) và tôi đang gửi file.</li><li>Trình duyệt: 100KB? Ôi… chờ tí, chờ tí… ok, tải được rồi nhé.</li></ol><p>Dĩ nhiên, header và giao thức thực tế sẽ hình thức hơn nhiều (quan sát chúng với <a href="https://betterexplained.com/articles/how-to-debug-web-applications-with-firefox/" target="_blank" rel="noopener">Live HTTP Headers</a> nếu bạn muốn).</p><p>Nhưng nó hoạt động, và bạn nhận được file.</p><h2 id="The-van-de-la-gi"><a href="#The-van-de-la-gi" class="headerlink" title="Thế vấn đề là gì?"></a>Thế vấn đề là gì?</h2><p>Chà, hệ thống hoạt động, nhưng không hiệu quả. 100KB là <strong>một đống text</strong>, và thành thật thì, HTML khá là trùng lặp. Mỗi thẻ <html>, <table> và <div> đều có một thẻ đóng gần như tương tự. Các từ lặp đi lặp lại trong cả document. Bạn chia nó ra như thế nào thì HTML (và người anh em mạnh mẽ của nó, XML) đều không tinh gọn.</div></table></html></p><p>Và xử lý thế nào với một file quá lớn? Nén nó!</p><p>Nếu chúng ta có thể gửi một file .zip đến trình duyệt (index.html.zip) thay vì index.html thông thường, chúng ta sẽ tiết kiệm được băng thông và thời gian tải. Trình duyệt có thể tải file đã nén, giải nén nó, và sau đó hiển thị cho người dùng, người đang có tâm trạng tốt vì trang tải nhanh. Đoạn hội thoại giữa trình duyệt và server sẽ trông như sau:</p><p><img src="https://betterexplained.com/wp-content/uploads/compression/HTTP_request_compressed.png" alt=""></p><ol><li>Trình duyệt: Này, tôi có thể <strong>GET</strong> index.html không? Tôi sẽ lấy phiên bản nén của nó nếu anh có.</li><li>Server: Để tôi tìm… ừ, có đây. Và anh sẽ lấy bản nén? Tuyệt.</li><li>Server: Ok, tôi tìm thấy index.html (200 OK), và tôi đang nén và gửi nó qua cho anh.</li><li>Trình duyệt: Tuyệt! Chỉ có mỗi 10KB. Tôi sẽ giải nén và hiển thị cho người dùng.</li></ol><p>Công thức rất đơn giản: File nhỏ hơn = tải nhanh hơn = <strong>người dùng hạnh phúc</strong>.</p><p>Không tin tôi à? Phần HTML của trang chủ của Yahoo giảm từ 101KB xuống còn 15KB sau khi nén:</p><p><img src="https://betterexplained.com/wp-content/uploads/compression/yahoo.png" alt=""></p><h2 id="Chi-tiet-khong-qua-lang-nhang"><a href="#Chi-tiet-khong-qua-lang-nhang" class="headerlink" title="Chi tiết (không quá) lằng nhằng"></a>Chi tiết (không quá) lằng nhằng</h2><p>Phần khó trong quá trình trao đổi này là trình duyệt và server phải biết rằng việc gửi nhận file nén là được chấp nhận. Việc đồng ý này bao gồm 2 phần</p><ul><li><strong>Trình duyệt gửi một header</strong> nói với server rằng nó chấp nhận nội dung được nén (gzip và deflate là 2 cách nén): <code>Accept-Encoding: gzip, deflate</code></li><li><strong>Server gửi một phản hồi</strong> nếu nội dung thực sự được nén: <code>Content-Encoding: gzip</code></li></ul><p>Nếu server không gửi content-encoding trong header của phản hồi, điều đó có nghĩa là file không được nén (điều mặc định ở nhiều server). Header “Accept-Encoding” chỉ là một yêu cầu từ trình duyệt, không phải mệnh lệnh. Nếu server không muốn gửi về nội dung được nén, trình duyệt sẽ phải tải về phiên bản nặng nề thông thường.</p><h2 id="Thiet-lap-server"><a href="#Thiet-lap-server" class="headerlink" title="Thiết lập server"></a>Thiết lập server</h2><p>“Tin tốt” là chúng ta không thể kiểm soát được trình duyệt. Nó sẽ gửi header <code>Accept-Encoding: gzip, deflate</code> hoặc là không.</p><p>Công việc của chúng ta là cấu hình server để nó trả về nội dung được nén nếu trình duyệt có thể xử lý, tiết kiệm băng thông cho mọi người (và đem lại một người dùng hạnh phúc).</p><p>Đối với IIS, <a href="https://technet.microsoft.com/en-us/library/cc771003(WS.10" target="_blank" rel="noopener">bật cấu hình nén</a>.aspx) ở trong cài đặt.</p><p>Trong Apache, <a href="https://httpd.apache.org/docs/2.0/mod/mod_deflate.html" target="_blank" rel="noopener">bật cấu hình nén nội dung xuất</a> khá là đơn giản. Thêm các dòng sau vào file .htaccess:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># compress text, html, javascript, css, xml:</span><br><span class="line">AddOutputFilterByType DEFLATE text/plain</span><br><span class="line">AddOutputFilterByType DEFLATE text/html</span><br><span class="line">AddOutputFilterByType DEFLATE text/xml</span><br><span class="line">AddOutputFilterByType DEFLATE text/css</span><br><span class="line">AddOutputFilterByType DEFLATE application/xml</span><br><span class="line">AddOutputFilterByType DEFLATE application/xhtml+xml</span><br><span class="line">AddOutputFilterByType DEFLATE application/rss+xml</span><br><span class="line">AddOutputFilterByType DEFLATE application/javascript</span><br><span class="line">AddOutputFilterByType DEFLATE application/x-javascript</span><br><span class="line"></span><br><span class="line"># Or, compress certain file types by extension:</span><br><span class="line">&lt;files *.html&gt;</span><br><span class="line">SetOutputFilter DEFLATE</span><br><span class="line">&lt;<span class="regexp">/files&gt;</span></span><br></pre></td></tr></table></figure><p>Apache có 2 tùy chọn nén:</p><ul><li><strong>mod_deflate</strong> dễ dàng cài đặt và là chuẩn.</li><li><strong>mod_gzip</strong> có vẻ mạnh hơn: bạn có thể nén trước nội dung.</li></ul><p>Deflate nhanh và hoạt động được, nên tôi sử dụng nó; dùng mod_gzip nếu bạn thấy thích. Trong cả 2 trường hợp, Apache đều kiểm tra xem trình duyệt có gửi header “Accept-Encoding” không và gửi lại phiên bản nén hoặc phiên bản thường của file. tuy nhiên, một số trình duyệt cũ sẽ phát sinh vấn đề (chi tiết bên dưới) và có một số chỉ lệnh đặc biệt mà bạn có thể thêm vào để sửa.</p><p>Nếu bạn không thể thay đổi file .htaccess, bạn có thể <a href="https://perishablepress.com/press/2007/03/26/fast-effective-php-compression/" target="_blank" rel="noopener">dùng PHP</a> để trả về nội dung nén. Thêm phần mở rộng .php vào file html của bạn và thêm đoạn code này ở đầu file:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (substr_count($_SERVER[‘HTTP_ACCEPT_ENCODING’], ‘gzip’))</span><br><span class="line">   ob_start(“ob_gzhandler”);</span><br><span class="line"><span class="keyword">else</span> ob_start();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>Chúng ta kiểm tra header “Accept-Encoding” và trả về phiên bản nén gzip của file (ngược lại là phiên bản thường). Việc này gần như là tự xây dựng webserver của bạn (rất thú vị!). Nhưng thực sự thì, hãy thử sử dụng Apache để nén nội dung trả về nến bạn có thể. Bạn không muốn nghịch ngợm mấy file của mình đâu.</p><h2 id="Xac-minh-noi-dung-nen-cua-ban"><a href="#Xac-minh-noi-dung-nen-cua-ban" class="headerlink" title="Xác minh nội dung nén của bạn"></a>Xác minh nội dung nén của bạn</h2><p>Khi bạn đã cấu hình xong server của mình, hãy kiểm tra để đảm bảo rằng bạn thực sự trả về nội dung nén.</p><ul><li><strong>Online</strong>: sử dụng <a href="http://www.gidnetwork.com/tools/gzip-test.php" target="_blank" rel="noopener">công cụ kiểm tra gzip online</a> để kiểm tra liệu trang của bạn có được nén không.</li><li><strong>Trên trình duyệt</strong>: trong Chrome, mở Developer Tools &gt; Network (Firefox/IE sẽ tương tự). Tải lại trang, và nhấn vào dòng network tương ứng với trang (ví dụ <a href="http://www.google.com)" target="_blank" rel="noopener">www.google.com)</a>. Header <code>Content-Encoding: gzip</code> nghĩa là nội dung trả về đã được nén.</li></ul><p><img src="https://betterexplained.com/wp-content/uploads/2007/04/chrome-gzip-header.png" alt=""></p><p>Nhấn biểu tượng “Use large rows” để hiển thị thêm thông tin, bao gồm cả kích cỡ file nén và kích cõ thực.</p><p><img src="https://betterexplained.com/wp-content/uploads/2007/04/request-size.png" alt=""></p><p>Hãy chuẩn bị cho điều kỳ diệu ở kết quả. <a href="http://instacalc.com/" target="_blank" rel="noopener">Trang chủ của instacalc</a> thu lại từ 36k xuống còn 10k, giảm 75% kích cỡ.</p><h2 id="Thu-mot-so-vi-du"><a href="#Thu-mot-so-vi-du" class="headerlink" title="Thử một số ví dụ"></a>Thử một số ví dụ</h2><p>Tôi đã làm một số trang và một <a href="https://betterexplained.com/examples/compressed/compression-example.zip" target="_blank" rel="noopener">ví dụ cho phép tải về</a>:</p><ul><li><a href="https://betterexplained.com/examples/compressed/index.html" target="_blank" rel="noopener">index.html</a> - không nén (trên server này, tôi mặc định sử dụng nén)</li><li><a href="https://betterexplained.com/examples/compressed/index.htm" target="_blank" rel="noopener">index.htm</a> - nén với Apache .htaccess sử dụng luật *.htm</li><li><a href="https://betterexplained.com/examples/compressed/index.php" target="_blank" rel="noopener">index.php</a> - nén sử dụng PHP header</li></ul><p>Cứ thoải mái tải file, để chúng trong server của bạn và chỉnh sửa các cài đặt.</p><h2 id="Luu-y"><a href="#Luu-y" class="headerlink" title="Lưu ý"></a>Lưu ý</h2><p>Dù khá thú vị nhưng HTTP Compression cũng chứa một số vấn đề. Dưới đây là những thứ cần phải coi chừng:</p><ul><li><strong>Trình duyệt cũ</strong>: Phải, một số trình duyệt vẫn còn có rắc rối với nội dung nén (chúng nói rằng có thể chấp nhận nội dung nén, nhưng thực sự thì không thể). Nếu trang của bạn bắt buộc phải hoạt động với Netscape 1.0 trên Windows 95, bạn có lẽ sẽ không muốn dùng HTTP Compression. Apache mod_deflate có <a href="https://httpd.apache.org/docs/2.0/mod/mod_deflate.html#recommended" target="_blank" rel="noopener">một số luật</a> cho phép tránh việc nén trên một số trình duyệt cũ.</li><li><strong>Nội dung đã nén</strong>: Hầu hết ảnh, nhạc và video đều đã được nén. Đừng tốn thời gian nén chúng lần nữa. Trên thực tế, bạn sẽ chỉ muốn nén “big 3” (HTML, CSS và Javascript).</li><li><strong>CPU-load</strong>: nén nội dung khi nhận được yêu cầu sẽ tiêu tốn thời gian của CPU và tiết kiệm băng thông. Thường thì đây là sự đánh đổi tốt nếu biết tốc độ nén. Có nhiều cách để nén trước các nội dung tĩnh và gửi các bản nén này. Việc này cần được cấu hình thêm; cho dù không thể thì việc nén nội dung trả về vẫn là điều tốt. Sử dụng CPU cho người dùng có trải nghiệm nhanh hơn cũng khá là đáng, khi sự chú ý không đáng kể.</li></ul><p>Nén là một trong những cách nhanh nhất để cải thiện hiệu năng cho trang web của bạn. Hãy đi, cài đặt, và để cho người dùng của bạn thận hưởng lợi ích nó mang lại.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nén là một phương pháp đơn giản, hiệu quả để tiết kiệm băng thông và tăng tốc trang web của bạn. Tôi đã ngần ngại khi gợi ý sử dụng nén gzip khi &lt;a href=&quot;https://betterexplained.com/articles/speed-up-your-javascript-load-time/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tăng tốc tải file javascript của bạn&lt;/a&gt; vì một vài vấn đề ở trình duyệt cũ.&lt;/p&gt;
&lt;p&gt;Nhưng giờ là thế kỷ 21. Hầu hết các truy cập đến trang của tôi đều từ các trình duyệt hiện đại, và thẳng thắn mà nói, hầu hết người dùng của tôi đều am hiểu công nghệ. Tôi không muốn làm mọi người chậm lại vì một vài người đang bám lấy IE 4 trên Windows 95. Google và Yahoo dùng nén gzip. Một trình duyệt hiện đại cần được tận hưởng nội dung và tốc độ của web hiện đại - vậy thì sử dụng gzip mã hóa nó. Dưới đây là cách cài đặt.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
