<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Learn and Share</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nthung2112.github.io/"/>
  <updated>2019-01-06T16:34:26.744Z</updated>
  <id>http://nthung2112.github.io/</id>
  
  <author>
    <name>Hung Tan Nguyen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web Architecture 101</title>
    <link href="http://nthung2112.github.io/2019/01/Web-Architecture-101.html"/>
    <id>http://nthung2112.github.io/2019/01/Web-Architecture-101.html</id>
    <published>2019-01-06T16:31:00.000Z</published>
    <updated>2019-01-06T16:34:26.744Z</updated>
    
    <content type="html"><![CDATA[<p>Khái niệm kiến trúc web cơ bản mà tôi ước tôi biết khi mới trở thành developer.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*K6M-x-6e39jMq_c-2xqZIQ.png" alt=""></p><p>Biểu đổ trên trình bày khá đủ về kiến trúc của chúng tôi ở <strong><a href="https://www.storyblocks.com/" target="_blank" rel="noopener">Storyblocks</a></strong>. Nếu bạn không phải là một web developer lâu năm thì ảnh trên trông sẽ khá phức tạp. Việc mổ xẻ dưới đây chắc sẽ giúp nó dễ tiếp cận hơn trước khi chúng ta đào sâu vào chi tiết của mỗi thành phần.<br><a id="more"></a></p><blockquote><p>Người dùng search trên Google từ khóa “Strong Beautiful Fog And Sunbeams In The Forest”. Kết quả đầu tiên đến từ Storyblocks, trang stock và vector của chúng tôi. Người dùng click vào kết quả và được chuyển tiếp đến trang chi tiết về bức ảnh. Về cơ bản là trình duyệt của người dùng gửi một request đến server DNS để tìm cách liên hệ với Storyblocks, và sau đó gửi request.</p><hr><p>Request này sẽ gửi đến load balancer, và nó chọn ngẫu nhiên 1 trong số các web server chúng tôi đang chạy để xử lý request. Web server tìm thông tin về ảnh từ caching service và lấy dữ liệu còn lại từ database. Cũng lưu ý rằng “hồ sơ màu” của bức ảnh chưa được tính toán, nên chúng tôi gửi một job đến hàng đợi “job queue”, và job server sẽ xử lý đồng bộ, đồng thời cập nhật database với kết quả có được sau khi xử lý.</p><hr><p>Tiếp đó, chúng tôi thử tìm những bức ảnh tương tự bằng cách gửi một request đến service “full text search” với đầu vào là tiêu đề bức ảnh. Người dùng tình cờ đăng nhập vào Storyblocks với tư cách thành viên thì chúng tôi tìm thông tin tài khoản từ “account service”. Cuối cùng, chúng tôi bắn một sự kiện đến firehose để lưu lại trên hệ thống lưu trữ đám mây và load vào data warehouse, thứ sẽ được phân tích để trả lời những câu hỏi về business.</p><hr><p>Server render HTML view và gửi nó trở lại trình duyệt của người dùng, trước hết thông qua load balancer. Trang web chứa JavaScript và CSS được load từ hệ lưu trữ đám mấy, nó kết nối với CDN, nên trình duyệt của người dùng có thể liên hệ với CDN để nhận nội dung. Sau cùng, trình duyệt hiển thị trang web cho người dùng.</p></blockquote><p>Giờ tôi sẽ đi lần lượt từng thành phần, giới thiệu theo kiểu “101 …” nhằm cung cấp cho bạn một mô hình chuẩn để suy nghĩ về kiến trúc web (web architecture) về sau.</p><h3 id="1-DNS"><a href="#1-DNS" class="headerlink" title="1. DNS"></a>1. DNS</h3><p>DNS là viết tắt của “Domain Name Server” và nó là công nghệ xương sống để để www (world wide web) trở nên khả dĩ. Ở mức độ cơ bản thì DNS cung cấp một tham chiếu key/value từ domain name (chẳng hạn <a href="http://google.com" target="_blank" rel="noopener">google.com</a> …) đến một địa chỉ IP (chẳng hạn 85.129.83.120 …), giúp máy tính điều hướng request đến server tương ứng. Tương tự với số điện thoại, sự khác biệt giữa domain và địa chỉ IP chính là sự khác biệt giữa việc “gọi John Doe” và “gọi đến số 201-867-5309”. Bạn cần một danh bạ để tìm số của John, và tương tự, bạn cần DNS để tìm địa chỉ IP cho domain (tên miền). Thế nên bạn có thể xem DNS là một cuốn danh bạ cho internet.</p><p>Còn nhiều điều chi tiết hơn mà chúng ta có thể đề cập đến nhưng tôi sẽ bỏ qua vì nó không phải ở mức giới thiệu kiểu “101”.</p><p>P/S: 101 là gì thì đọc ở đây nhé <a href="http://www.slate.com/articles/news_and_politics/explainer/2006/09/101_101.html" target="_blank" rel="noopener">http://www.slate.com/articles/news_and_politics/explainer/2006/09/101_101.html</a></p><h3 id="2-Load-Balancer-Can-bang-tai"><a href="#2-Load-Balancer-Can-bang-tai" class="headerlink" title="2. Load Balancer (Cân bằng tải)"></a>2. Load Balancer (Cân bằng tải)</h3><p>Trước khi đi sâu vào cân bằng tải, chúng ta cần thảo luận về “<strong>horizontal scaling</strong>“ (mở rộng theo chiều ngang) và “<strong>vertical scaling</strong>“ (mở rộng theo chiều dọc). Chúng là gì và khác nhau như thế nào? Đơn giản “horizontal scaling” nghĩa là mở rộng quy mô bằng cách thêm nhiều máy tính vào nguồn tài nguyên, trong khi “vertical scaling” nghĩa là tăng cường sức mạnh cho một máy tính đã có (chẳng hạn như CPU, RAM).</p><p>Trong web development, gần như bạn luôn muốn mở rộng theo kiểu “horizontal”. Vì, server có thể bỗng dưng bị chết, mạng gặp sự cố, toàn bộ trung tâm dữ liệu thường xuyên mất mạng. Có nhiều hơn một server cho phép bạn lập kế hoạch cho các sự cố để ứng dụng vẫn tiếp tục chạy (fault tolerant). Lý do thứ hai, “horizontal scaling” sẽ cho bạn kết hợp tối thiểu các phần backend khác nhau của ứng dụng (web server, database, service X, …) bằng cách để chúng chạy trên nhiều server. Cuối cùng, bạn có thể mở rộng quy mô đến một mức mà “vertical scaling” không thể làm được. Đó là vì không có một máy tính nào trên thế giới đủ lớn để thực hiện tất cả tính toán cho ứng dụng. Hãy nghĩ nền tảng tìm kiếm của Google như một ví dụ điển hình (dù điều này ứng dụng cho các công ty ở quy mô bé hơn nhiều). <strong>Storyblocks</strong>, chạy từ 150 đến 400 AWS EC2 tại thời điểm viết bài này, để đạt được khối lượng tính toán ấy bằng “vertical scaling” là một thách thức rất lớn.</p><p>Trở lại với cân bằng tải, chúng là ma thuật để mở rộng theo kiểu “horizontal”, điều hướng <em>incoming request</em> đến một trong nhiều server và gửi phản hồi từ server về client. Bất kỳ server nào cũng phải xử lý request theo cùng một cách, do đó chỉ còn lại một vấn đề là phân bổ request qua nhiều server để chúng không bị quá tải (overload).</p><p>Vậy đó, khái niệm cân bằng tải khá đơn giản. Tất nhiên công nghệ nằm phía sau nó rất phức tạp nhưng không cần đề cập với phiên bản “101” làm chi.</p><h3 id="3-Web-Application-Servers"><a href="#3-Web-Application-Servers" class="headerlink" title="3. Web Application Servers"></a>3. Web Application Servers</h3><p>Web server là nơi thực thi business logic, xử lý request của user và gửi lại HTML đến trình duyệt của user. Để làm việc đó, chúng kết nối với nhiều infra phía back-end như database, caching layer, job queue, search service, microservice, data/logging queue, … Như đã đề cập ở trên, ít nhất 2 server thường được kết nối với cân bằng tải để xử lý request của người dùng.</p><p>Bạn nên biết rằng triển khai server yêu cầu một ngôn ngữ cụ thể (Node.js, Ruby, PHP, Scala, Java, C# .NET, …) và một web framework cho ngôn ngữ đó (Express, Ruby on Rails, Play, Laravel, …). Tuy nhiên đi sâu vào chi tiết của những ngôn ngữ này nằm ngoài phạm vi của bài viết.</p><h3 id="4-Database-Servers"><a href="#4-Database-Servers" class="headerlink" title="4. Database Servers"></a>4. Database Servers</h3><p>Mọi ứng dụng web hiện đại đều sử dụng một hoặc nhiều database để lưu trữ thông tin. Database cung cấp phương thức để định nghĩa cấu trúc dữ liệu, insert dữ liệu mới, tìm dữ liệu đã có, cập nhật hoặc xóa dữ liệu, thực hiện tính toán, …</p><p>Dù tôi tránh đào sao vào một công nghệ cụ thể cho mỗi thành phần của kiến trúc web, sẽ rất tệ nếu tôi không đề cập đến SQL và NoSQL.</p><p>SQL là viết tắt của “Structured Query Language” (ngôn ngữ truy vấn có cấu trúc) được phát minh vào thập niên 70 của thế kỷ trước, cung cấp một chuẩn để truy vấn dữ liệu. SQL database lưu trữ dữ liệu theo bảng, được liên kết với nhau thường bằng ID. Hãy lấy một ví dụ cơ bản về lưu trữ địa chỉ của người dùng. Bạn có 2 bảng, <em>users</em> và _user_addresses_, liên kết với nhau bằng id của người dùng.</p><p><img src="https://images.viblo.asia/646f6ef3-7806-4835-bc29-950c6532657b.png" alt=""></p><p>NoSQL, nghĩa là “Non-SQL”, là một công nghệ cơ sở dữ liệu mới hơn, dùng để xử lý khối lượng dữ liệu lớn được sinh ra bởi những ứng dụng web có quy mô lơn (hầu hết các biến thể của SQL không scale theo kiểu “horizontal” tốt và chỉ có thể scale theo kiểu “vertical” đến một mức độ nhất định). Nếu bạn không biết gì về NoSQL, tôi đề nghị xem những tài liệu dưới đây:</p><ul><li><a href="https://www.w3resource.com/mongodb/nosql.php" target="_blank" rel="noopener">https://www.w3resource.com/mongodb/nosql.php</a></li><li><a href="http://www.kdnuggets.com/2016/07/seven-steps-understanding-nosql-databases.html" target="_blank" rel="noopener">http://www.kdnuggets.com/2016/07/seven-steps-understanding-nosql-databases.html</a></li><li><a href="https://resources.mongodb.com/getting-started-with-mongodb/back-to-basics-1-introduction-to-nosql" target="_blank" rel="noopener">https://resources.mongodb.com/getting-started-with-mongodb/back-to-basics-1-introduction-to-nosql</a></li></ul><h3 id="5-Caching-Service"><a href="#5-Caching-Service" class="headerlink" title="5. Caching Service"></a>5. Caching Service</h3><p>Một <em>caching service</em> (dịch vụ lưu bộ nhớ đệm) cung cấp lưu trữ dữ liệu theo kiểu “key/value” đơn giản giúp nó tìm kiếm thông tin với thời gian gần như bằng 0. Các ứng dụng thường tận dụng <em>caching service</em> để lưu kết quả của những tính toán đắt đỏ để nhận kết của từ bộ nhớ đệm thay vì phải tính toán lại một lần nữa khi cần. Ứng dụng có thể cache kết quả của một truy vấn cơ sở dữ liệu, gọi đến một dịch vụ bên ngoài, cache HTML của một đường link, … Dưới đây là một vài ví dụ thực tế:</p><ul><li>Google lưu kết quả tìm kiếm cho những truy vấn thông thường như “dog” hoặc “Taylor Swift” để không phải tính toán lại mỗi lần</li><li>Facebook lưu nhiều dữ liệu bạn nhìn thấy khi đăng nhập, chẳng hạn bài viết, bạn bè… Bạn có thể đọc chi tiết về Facebook caching ở <a href="https://medium.com/@shagun/scaling-memcache-at-facebook-1ba77d71c082" target="_blank" rel="noopener">đây</a>.</li><li>Storyblocks lưu HTML output, kết quả tìm kiếm, …</li></ul><p>Hai công nghệ caching phổ biến nhất là Redis và Memcache.</p><h3 id="6-Job-Queue-amp-Servers"><a href="#6-Job-Queue-amp-Servers" class="headerlink" title="6. Job Queue &amp; Servers"></a>6. Job Queue &amp; Servers</h3><p>Hầu hết ứng dụng web đều cần làm một số công việc bất đồng bộ ở phía back-end mà không kết hợp trực tiếp vào dữ liệu trả về cho người dùng. Chẳng hạn, Google cần crawl và index toàn bộ internet để trả về kết quả tìm kiếm. Nó không được làm mỗi lần bạn tìm kiếm. Thay vào đó, nó crawl các trang web một cách bất đồng bộ, và cập nhật index theo thời gian.</p><p>Mặc dù có nhiều kiến trúc khác nhau cho các công việc bất đồng bộ, nhưng phố biến nhất là kiến trúc “job queue”. Nó chứa 2 thành phần: một hàng đợi “job” cần được chạy, và một hoặc nhiều “job server” (hay còn lại là worker) để chạy job trong hàng đợi.</p><p>Job queue chứa một danh sách job cần được chạy bất đồng bộ. Hàng đợi đơn giản nhất là FIFO (first in first out) mặc dù hầu hết ứng dụng sẽ cần một vài hàng đợi có ưu tiên. Mỗi khi ứng dụng cần chạy job thì nó chỉ cần thêm job đó vào hàng đợi.</p><p>Storyblocks, chẳng hạn, tận dụng “job queue” để hỗ trợ rất nhiều công việc phía back-end nhằm phục vụ thị trường của chúng tôi. Chúng tôi chạy job để encode video và ảnh, xử lý file CSV, thống kê người dùng, gửi mật khẩu reset email, … Lúc đầu chúng tôi sử dụng hàng đợi FIFO đơn giản, sau đó nâng cấp lên hàng đợi ưu tiên để đảm bảo rằng những hoạt động khẩn như gửi mật khẩu reset email được hoàn thành càng sớm càng tốt.</p><p>Job server xử lý job. Chúng thăm dò “job queue” để xác định có job cần làm hay không, và nếu có thì chúng sẽ đẩy job vào hàng đợi và thực thi nó.</p><h3 id="7-Full-text-Search-Service"><a href="#7-Full-text-Search-Service" class="headerlink" title="7. Full-text Search Service"></a>7. Full-text Search Service</h3><p>Hầu hết ứng dụng web hỗ trợ một vài chức năng tìm kiếm mà người dùng thường sẽ cung cấp một tham số văn bản (còn gọi là “query”) và ứng dụng trả về kết quả “liên quan”. Công nghệ hỗ trợ đặc tính này thường gọi là “full-text search”, sử dụng index để nhanh chóng tìm tài liệu chứa từ khóa cần truy vấn.</p><p><img src="https://images.viblo.asia/eba8d45b-27eb-4e56-8380-6db35a45329d.png" alt=""></p><p>Dù có thể thực hiện “full-text search” trực tiếp từ database (chẳng hạn MySQL hỗ trợ full-text search), nó thường chạy một “search service” riêng để tính toán và lưu trữ chỉ mục và cung cấp một giao diện truy vấn riêng. Nền tảng full-text search phổ biến nhất hiện nay là Eltasticsearch, bên cạnh một số lựa chọn khác như Sphinx hoặc Apache Solr.</p><h3 id="8-Services"><a href="#8-Services" class="headerlink" title="8. Services"></a>8. Services</h3><p>Khi ứng dụng đạt đến quy mô nhất định, sẽ có một số “service” được tahcs ra để chạy như một ứng dụng riêng. Chúng không được public bên ngoài nhưng ứng dụng và các service khác có thể tương tác với chúng. Storyblocks có một số service như vậy:</p><ul><li>Account service để lưu trữ dữ liệu người dùng trên tất cả các trang web của chúng tôi, cho phép chúng tôi dễ dàng cung cấp các cơ hội “cross-sell” và tạo những trải nghiệm người dùng nhất quán hơn</li><li>Content service lưu trữ metadata cho video, audio, ảnh. Nó cũng cung cấp giao diện để download nội dung và xem lịch sử download.</li><li>Payment service cung cấp giao diện thanh toán bằng thẻ tín dụng.</li><li>HTML → PDF service cung cấp giao diện đơn giản để sinh ra file PDF từ HTML.</li></ul><h3 id="9-Data"><a href="#9-Data" class="headerlink" title="9. Data"></a>9. Data</h3><p>Ngày nay, công ty muốn tồn tại thì phải dựa trên cách họ khai thác dữ liệu. Hầu hết những ứng dụng bây giờ, mỗi lần đạt đến một quy mô nhất định, hãy tận dụng kênh dữ liệu (data pipeline) để đảm bảo rằng dữ liệu được thu thập, lưu trữ và phân tích. Một kênh dữ liệu bao gồm 3 giai đoạn chính:</p><ol><li>Ứng dụng gửi dữ liệu, sự kiện về tương tác của người dùng cho “firehose” (cung cấp giao diện streaming để nhập và xử lý dữ liệu). Thông thường dữ liệu thô được xử lý sẽ được gửi đến firehose khác. AWS Kinesis và Kafka là hai công nghệ phố biến nhất cho mục đích này.</li><li>Dữ liệu thô cũng như dữ liệu đã được chuyển đổi được lưu trữ đến cloud. AWS Kinesis cung cấp một setting gọi là “firehose” sẽ lưu dữ liệu thô vào S3 để dễ cấu hình.</li><li>Dữ liệu được chuyển đổi sẽ được tải vào data warehouse để phân tích. Chúng tôi sử dụng AWS Redshift, mặc dù các công ty lớn khác thường dùng Oracle hoặc công nghệ warehouse độc quyền. Nếu bộ dữ liệu đủ lớn, công nghệ NoSQL MapReduce như Hadoop sẽ được sử dụng để phân tích.</li></ol><p>Một bước khác không được mô tả trong biểu đồ kiến trúc là: tải dữ liệu từ database của ứng dụng và service vào data warehouse. Chẳng hạn ở Storyblocks, chúng tôi tải VideoBlocks, AudioBlocks, Storyblocks, account service, … vào Redshift mỗi đêm. Điều này cung cấp cho bộ phân tích những dữ liệu tổng thể bằng cách cấp phát dữ liệu business cùng với dữ liệu tương tác của người dùng.</p><h3 id="10-Cloud-storage"><a href="#10-Cloud-storage" class="headerlink" title="10. Cloud storage"></a>10. Cloud storage</h3><p>Dịch vụ đám mây là cách đơn giản nhất để lưu trữ, truy xuất và chia sẻ dữ liệu trên internet, theo AWS. Bạn có thể dùng nó để lưu trữ và truy cập với lợi thế là tương tác với nó quả RESTful API. Amazon S3 là dịch vụ lưu trữ đám mây phổ biến nhất ngày nay, và chúng tôi dựa vào nó để lưu trữ video, ảnh, audio, CSS và JavaScript, dữ liệu sự kiện người dùng và hơn thế nữa.</p><h3 id="11-CDN"><a href="#11-CDN" class="headerlink" title="11. CDN"></a>11. CDN</h3><p>CSN là viết tắt của “Content Delivery Network” và công nghệ cung cấp một cách để phục vụ nội dung tĩnh như HTML, CSS, JavaScript và ảnh trên web nhanh hơn so với việc chỉ dùng một server. Nó hoạt động bằng cách phân tán nội dung qua nhiều “edge server” khắp thế giới để người dùng cuối có thể download nội dung từ “edge server” thay vì từ server gốc. Chẳng hạn như ảnh dưới đây, một người dùng từ Tây Ban Nha request một trang web mà có server gốc là ở New York, nhưng các tài nguyên tĩnh của trang web lại được tải về từ “edge server” của CDN từ Anh.</p><p><img src="https://images.viblo.asia/0bf32d18-11cf-496a-98b7-ccbbe31ec4b5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Khái niệm kiến trúc web cơ bản mà tôi ước tôi biết khi mới trở thành developer.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*K6M-x-6e39jMq_c-2xqZIQ.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Biểu đổ trên trình bày khá đủ về kiến trúc của chúng tôi ở &lt;strong&gt;&lt;a href=&quot;https://www.storyblocks.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Storyblocks&lt;/a&gt;&lt;/strong&gt;. Nếu bạn không phải là một web developer lâu năm thì ảnh trên trông sẽ khá phức tạp. Việc mổ xẻ dưới đây chắc sẽ giúp nó dễ tiếp cận hơn trước khi chúng ta đào sâu vào chi tiết của mỗi thành phần.&lt;br&gt;
    
    </summary>
    
    
      <category term="architecture" scheme="http://nthung2112.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>Một mô hình sử dụng Git branches hiệu quả</title>
    <link href="http://nthung2112.github.io/2019/01/Mot-mo-hinh-su-dung-Git-branches-hieu-qua.html"/>
    <id>http://nthung2112.github.io/2019/01/Mot-mo-hinh-su-dung-Git-branches-hieu-qua.html</id>
    <published>2019-01-06T16:24:00.000Z</published>
    <updated>2019-01-06T16:27:51.189Z</updated>
    
    <content type="html"><![CDATA[<p>Mới đầu mình tính viết về <a href="https://github.com/nvie/gitflow" target="_blank" rel="noopener">git-flow</a> - một tool đơn giản dùng để quản lý Git branches, xong thấy bài viết <a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">này</a> về một ví dụ sử dụng Git branches hay quá, nên quyết định dịch luôn.</p><h2 id="Mo-dau"><a href="#Mo-dau" class="headerlink" title="Mở đầu"></a>Mở đầu</h2><p>Ngay bây giờ, tôi sẽ giới thiệu với các bạn mô hình sử dụng Git mà tôi đã và đang sử dụng trong các dự án khoảng một năm trở lại đây. Đó là một mô hình thực sự thành công, nhưng mãi đến giờ tôi mới có cơ hội để có thể viết về nó và chia sẻ với các bạn. Tôi sẽ không đi vào chi tiết dự án, mà chỉ xoay quanh chiến lược quản lý các phân nhánh mà thôi.<br><a id="more"></a><br><img src="http://nvie.com/img/git-model@2x.png" alt=""></p><p>Trong bài viết dưới đây, tôi sử dụng Git để quản lý version cho toàn bộ source code. Nếu các bạn có hứng thú với việc phân tích dữ liệu thời gian thực dựa vào hoạt động trên Git, có thể tham khảo phần mềm mà <a href="http://gitprime.com/" target="_blank" rel="noopener">GitPrime</a> mà công ty tôi phát triển.</p><h2 id="Tai-sao-lai-chon-Git"><a href="#Tai-sao-lai-chon-Git" class="headerlink" title="Tại sao lại chọn Git?"></a>Tại sao lại chọn Git?</h2><p>Đã có quá nhiều cuộc chiến nổ ra khi bàn về ưu điểm nhược điểm của Git so với các công cụ quản lý source code tập trung khác (như CVS, SVN). Là một developer, tôi cảm thấy yêu thích Git hơn. Git thực sự đã thay đổi cách suy nghĩ về merging và branching. Những ai đã từng làm việc với CVS/Subversion đều hiểu merging/branching không hề đơn giản, trong <a href="http://svnbook.red-bean.com/" target="_blank" rel="noopener">tài liệu về CVS/Subversion</a> branching và merging chỉ được nhắc đến ở chapter cuối, dành cho các users có kinh nghiệm. Còn với Git, branching/merging là một phần trong workflow hàng ngày của bạn, được mô tả ở những phần đầu tiên trong <a href="http://book.git-scm.com/" target="_blank" rel="noopener">Git book</a>.</p><h2 id="Phan-tan-nhung-tap-trung"><a href="#Phan-tan-nhung-tap-trung" class="headerlink" title="Phân tán, nhưng tập trung"></a>Phân tán, nhưng tập trung</h2><p>Mô hình Git mà tôi sử dụng hoạt động xoay quanh một repo trung tâm. Nên nhớ đó “chỉ được xem như” là repo trung tâm, chứ về mặt kỹ thuật thì GIT không hề có cái gì gọi là repo trung tâm cả. Ví dụ như repo origin ở hình bên dưới.</p><p><img src="http://nvie.com/img/centr-decentr@2x.png" alt=""></p><p>Mỗi developer sẽ pull và push với origin. Bên cạnh đó, mỗi người có thể pull những thay đổi từ những người khác để tạo thành các sub teams. Điều này sẽ thực sự có ích khi phải làm việc nhóm 2-3 người trở lên để hoàn thành một feature lớn, mà không phải đẩy source code vẫn đang dở dang lên origin. Ở hình vẽ bên trên, các subteams là Alice-Bob, Alice-David, Clair-David.</p><p>Về mặt kỹ thuật, đơn giản là Alice định nghĩa một Git remote là bob, trỏ đến repo của Bob, và ngược lại.</p><h2 id="Nhung-branches-chinh"><a href="#Nhung-branches-chinh" class="headerlink" title="Những branches chính"></a>Những branches chính</h2><p>Repo trung tâm sẽ chứa hai branches chính hoạt động mãi mãi:</p><ul><li>master</li><li>develop</li></ul><p>Nhánh master tại origin là nhánh quen thuộc với tất cả các Git users. Song song là nhánh develop.</p><p><img src="http://nvie.com/img/main-branches@2x.png" alt=""></p><p>origin/master được coi là nhánh chính với HEAD phản ánh trạng thái production-ready.</p><p>origin/develop được coi là nhánh chính với HEAD phản ánh trạng thái thay đổi mới nhất trong quá trình phát triển, chuẩn bị cho release tiếp theo.</p><p>Khi source code bên develop đạt đến một mức độ ổn định nào đó và sẵn sàng để release thì sẽ được merge sang bên master và đánh dấu với release number.</p><p>Như vậy, theo định nghĩa về nhánh master, chúng ta mặc định hiểu rằng khi có thay đổi được merge vào master thì tức là sẽ có một phiên bản production mới được release. Nhờ đó chúng ta có thể sử dụng script để tự động build lên production server mỗi khi có commit ở master.</p><h2 id="Nhung-branches-phu"><a href="#Nhung-branches-phu" class="headerlink" title="Những branches phụ"></a>Những branches phụ</h2><p>Bên cạnh hai branches chính master và develop, mô hình mà tôi đang sử dụng còn có thêm rất nhiều những branches phụ để giúp các team members có thể phát triển song song, dễ dàng tracking theo features, chuẩn bị cho release hoặc fix nhanh các vấn đề production. Khác với hai branches chính kia, các branches phụ này chỉ tồn tại trong một khoảng thời gian ngắn, rồi sẽ bị xoá đi.</p><ul><li>Feature branches</li><li>Release branches</li><li>Hotfix branches</li></ul><p>Phía trên là các loại branches khác nhau tôi hay sử dụng. Mỗi loại branches lại có một nhiệm vụ riêng, và cách xử lý riêng. Tôi sẽ đi sâu vào phân tích ở đoạn sau.</p><p>Về mặt kỹ thuật, chả có branch nào là “đặc biệt” so với các branches khác cả. Tất cả chỉ là Git branches thông thường, chúng chỉ được phân loại bằng cách ta sử dụng ra sao thôi.</p><h3 id="Feature-branches"><a href="#Feature-branches" class="headerlink" title="Feature branches"></a>Feature branches</h3><ul><li>Tách từ: develop</li><li>Merge vào: develop</li><li>Naming convention: tự do, ngoại trừ master, develop, release-<em>, hotfix-</em></li></ul><p><img src="http://nvie.com/img/fb@2x.png" alt=""></p><p>Feature branches (hay còn gọi là topic branches) được sử dụng để phát triển các feature mới phục vụ cho release sau này. Khi bắt đầu phát triển một chức năng, có thể chưa rõ được thời điểm chức năng đó được tích hợp vào hệ thống và release. Feature branch sẽ tồn tại trong quá trình chức năng được phát triển, cuối cùng sẽ được merge lại vào develop (khi quyết định lần release tới bao gồm chức năng đó) hoặc bị bỏ đi (khi thấy chức năng không còn cần thiết).</p><p>Về cơ bản thì feature branches chỉ tồn tại ở repos của developers, chứ ko phải ở origin.</p><h4 id="Tao-feature-branch"><a href="#Tao-feature-branch" class="headerlink" title="Tạo feature branch"></a>Tạo feature branch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b myfeature develop</span><br></pre></td></tr></table></figure><h4 id="Merge-vao-develop"><a href="#Merge-vao-develop" class="headerlink" title="Merge vào develop"></a>Merge vào develop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">$ git merge --no--ff myfeature</span><br><span class="line">$ git branch -d myfeature</span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure><p>–no-ff giúp thao tác merge luôn tạo ra một commit mới, ngay cả khi có thể merge theo fast-forward. Flag này giúp chúng ta không bị mất thông tin liên quan đến lịch sử các commits của feature branch.</p><p><img src="http://nvie.com/img/merge-without-ff@2x.png" alt=""></p><p>Ở trường hợp bên phải, không thể nhận biết được những commits nào phát triển cùng chức năng nếu không ngồi đọc log message của từng commit. Khi dấy, nếu muốn revert lại cả feature (phải revert nhiều commits liên quan) thì thực sự là đau đầu. Và đó là lý do mà –no-ff được sử dụng.</p><p>Đương nhiên, nó sẽ tạo ra thêm vài commit, nhưng chả có vấn đề gì cả.</p><h3 id="Release-branches"><a href="#Release-branches" class="headerlink" title="Release branches"></a>Release branches</h3><ul><li>Tách từ: develop</li><li>Merge vào: develop và master</li><li>Naming convention: release-*</li></ul><p>Release branches được sử dụng để chuẩn bị cho release bản production mới. Tất cả các công việc cuối cùng trước khi release sẽ được thực hiện ở đây, ngoài ra còn để fix nốt các bugs lẻ tẻ, chuẩn bị meta-data (version number, build dates, etc..). Nhờ việc tách nhánh ra khỏi develop, chúng ta có thể tiếp tục phát triển các features cho đợt release khác một cách bình thường.</p><p>Thời điểm được lựa chọn để tách nhánh từ develop là khi develop phản ánh được trạng thái mong muốn cho việc release mới. Ít nhất lúc đó tất cả các features dành cho đợt release phải được merge vào develop rồi. Những features nhắm đến các lần release sau thì chưa được merge vào, phải đợi sau khi tách nhánh.</p><p>Chúng ta sẽ tiến hành đánh version theo rule của dự án ngay sau khi tạo release branch.</p><h4 id="Tao-release-branch"><a href="#Tao-release-branch" class="headerlink" title="Tạo release branch"></a>Tạo release branch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b release-1.2 develop</span><br><span class="line">$ ./bump-version.sh 1.2</span><br><span class="line">$ git commit -a -m &quot;Bumped version number to 1.2&quot;</span><br></pre></td></tr></table></figure><p>Ở ví dụ trên, bump-version.sh tượng trưng cho một script thay đổi một vài files trong source code để phản ánh version mới. Sau khi tạo branch mới và chuyển sang branch đó, chúng ta sẽ thực hiện nâng version, rồi commit thao tác đó.</p><p>Branch mới này sẽ tồn tại cho đến khi việc release được thực hiện gọn ghẽ. Trong khoảng thời gian đó, có thể thực hiện fix bugs ở branch này, tuy nhiên nghiêm cấm việc bổ sung feature mới lên đó. Tốt nhất nếu có features mới thì hãy merge vào develop, và đợi đợt release sau.</p><h4 id="Ket-thuc-release-branch"><a href="#Ket-thuc-release-branch" class="headerlink" title="Kết thúc release branch"></a>Kết thúc release branch</h4><p>Khi source code trên release branch sẵn sàng để release, đầu tiên, phải merge vào master, sau đó phải đc merge lại vào develop để những lần release sau cũng chứa những thay đổi ở lần này.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">$ git tag -a 1.2</span><br></pre></td></tr></table></figure><p>Vậy là source code đã được release lên master, và đã được tag để tiện sau này tham chiếu.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">$ git merge --no-ff release-1.2</span><br></pre></td></tr></table></figure><p>Ở bước này, rất có thể sẽ có confict, nên hãy fix nó rồi commit nhé.</p><p>Bây giờ thì việc release đã hoàn thành, và chúng ta ko cần đến branch này nữa.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d release-1.2</span><br></pre></td></tr></table></figure><h3 id="Hotfix-branches"><a href="#Hotfix-branches" class="headerlink" title="Hotfix branches"></a>Hotfix branches</h3><ul><li>Tách từ: master</li><li>Merge vào: develop và master</li><li>Naming convention: hotfix-*</li></ul><p><img src="http://nvie.com/img/hotfix-branches@2x.png" alt=""></p><p>Hotfix branches cũng giống release branches ở chỗ được sử dụng để chuẩn bị cho việc release production mới, chỉ khác ở chỗ là ko có plan từ trước. Khi có một bug nghiêm trọng trên bản production cần được giải quyết ngay lập tức, một hotfix branch sẽ được tách ra từ master và được đánh version để nhận biết.</p><p>Ưu điểm của việc tách nhánh này ở chỗ các team members khác có thể tiếp tục công việc ở develop trong khi những người khác có thể tập trung vào fix bug của production.</p><h4 id="Tao-hotfix-branch"><a href="#Tao-hotfix-branch" class="headerlink" title="Tạo hotfix branch"></a>Tạo hotfix branch</h4><p>Hotfix branch được tạo ra từ master. Ví dụ hiện tại version 1.2 là phiên bản production đang chạy và xuất hiện lỗi nghiêm trọng. Tuy nhiên source code trên develop vẫn chưa ổn định, vì thế chúng ta phải tách nhánh hotfix và tiến hành sửa lỗi.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix-1.2.1 master</span><br><span class="line">$ ./bump-version.sh 1.2.1</span><br><span class="line">$ git commit -a -m &quot;Bumped version number to 1.2.1&quot;</span><br></pre></td></tr></table></figure><p>Sau khi tách nhánh phải tiến hành up version luôn nhé!</p><p>Sau khi sửa lỗi, hãy thực hiện commit.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;Fixed severe production problem&quot;</span><br></pre></td></tr></table></figure><h4 id="Ket-thuc-hotfix-branch"><a href="#Ket-thuc-hotfix-branch" class="headerlink" title="Kết thúc hotfix branch"></a>Kết thúc hotfix branch</h4><p>Sau khi kết thúc sửa lỗi, những thay đổi phải được merge lại master, đồng thời cũng phải merge vào develop để ngăn lỗi xảy ra ở những lần release sau. Nghe rất giống với xử lý trên release branch phải không.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line">$ git tag -a 1.2.1</span><br><span class="line"></span><br><span class="line">$ git checkout develop</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br></pre></td></tr></table></figure><p>Tuy nhiên, có một điểm cần lưu ý rằng: <strong>khi đang tồn tại một release branch thì cần phải merge hotfix vào release branch đó, thay cho develop</strong>. Khi release branch được merge vào develop thì cuối cùng những thay đổi trong hotfix cũng được merge vào develop, nên không có vấn đề gì cả. Trừ khi thực sự công việc ở develop cần phần hotfix ngay lập tức và ko thể đợi release branch được merge, thì cần cẩn thận merge hotfix vào develop.</p><p>Cuối cùng, chúng ta cũng ko cần đến branch này nữa:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix-1.2.1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mới đầu mình tính viết về &lt;a href=&quot;https://github.com/nvie/gitflow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git-flow&lt;/a&gt; - một tool đơn giản dùng để quản lý Git branches, xong thấy bài viết &lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;này&lt;/a&gt; về một ví dụ sử dụng Git branches hay quá, nên quyết định dịch luôn.&lt;/p&gt;
&lt;h2 id=&quot;Mo-dau&quot;&gt;&lt;a href=&quot;#Mo-dau&quot; class=&quot;headerlink&quot; title=&quot;Mở đầu&quot;&gt;&lt;/a&gt;Mở đầu&lt;/h2&gt;&lt;p&gt;Ngay bây giờ, tôi sẽ giới thiệu với các bạn mô hình sử dụng Git mà tôi đã và đang sử dụng trong các dự án khoảng một năm trở lại đây. Đó là một mô hình thực sự thành công, nhưng mãi đến giờ tôi mới có cơ hội để có thể viết về nó và chia sẻ với các bạn. Tôi sẽ không đi vào chi tiết dự án, mà chỉ xoay quanh chiến lược quản lý các phân nhánh mà thôi.&lt;br&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://nthung2112.github.io/tags/git/"/>
    
      <category term="gitflow" scheme="http://nthung2112.github.io/tags/gitflow/"/>
    
  </entry>
  
  <entry>
    <title>Giới thiệu về Atomic CSS</title>
    <link href="http://nthung2112.github.io/2019/01/Gioi-thieu-ve-Atomic-CSS.html"/>
    <id>http://nthung2112.github.io/2019/01/Gioi-thieu-ve-Atomic-CSS.html</id>
    <published>2019-01-06T10:18:00.000Z</published>
    <updated>2019-01-06T10:39:27.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nhung-van-de-voi-cach-viet-CSS-hien-tai"><a href="#Nhung-van-de-voi-cach-viet-CSS-hien-tai" class="headerlink" title="Những vấn đề với cách viết CSS hiện tại"></a>Những vấn đề với cách viết CSS hiện tại</h2><h3 id="Specificity-war-tham-cung-noi-chien"><a href="#Specificity-war-tham-cung-noi-chien" class="headerlink" title="Specificity war, thâm cung nội chiến"></a>Specificity war, thâm cung nội chiến</h3><p>Bạn còn nhớ lần đầu bạn viết CSS giống như thế nào không? Có thể là khai báo style cho một thẻ HTML nào đó.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: rainbow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sau đó bạn biết thêm về ID và class:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: fabulous;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Và bạn học được cách xử lý các pseudo selectors, hoặc khai báo cho các phần tử anh chị em con cháu họ hàng, v.v…</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &gt; <span class="selector-tag">a</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: unicorn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header</span> <span class="selector-tag">p</span> &gt; <span class="selector-tag">a</span><span class="selector-class">.text</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'⛓'</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: Comic Sans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rồi khi bạn đã quen với CSS và bắt tay vào làm dự án thực tế, bạn bàng hoàng nhận ra kẻ thù không ở đâu xa, chúng đang lởn vởn quanh ta í mà. Bạn bước vào cuộc chiến gọi là <a href="https://css-tricks.com/a-specificity-battle/" target="_blank" rel="noopener">“specificity war”</a>, đánh nhau tơi bời khói lửa với class được viết bởi các chiến hữu trong team. Quả là một trận đấu kinh hoàng khi ai cũng muốn đè đầu cưỡi cổ (override) người đi trước. Kẻ nắm giữ !important trong tay cứ nghĩ đã gần với chiến thắng, nào ngờ xuất hiện tiểu nhân dùng inline style + !important. Tình anh em sứt mẻ, chiến hữu quay đầu không nhìn mặt nhau. Bạn ức chế và gào lên “đậu phộng CSS 🥜”.</p><blockquote><p><strong>Specificity là gì?</strong></p><p>Specificity là một trọng số được trình duyệt sử dụng để quyết định CSS style nào sẽ được áp dụng cho các element. Specificity được tính toán dựa vào phân loại selector và số lượng selector áp dụng lên một element. Bạn có thể đọc thêm về chủ đề này <a href="http://gockinhnghiem.com/2011/11/09/specificity-trong-css-la-gi/" target="_blank" rel="noopener">ở đây</a> hoặc trên trang <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity" target="_blank" rel="noopener">MDN</a>. <a href="http://cssspecificity.com" target="_blank" rel="noopener">http://cssspecificity.com</a> minh hoạ khá cụ thể cách tính specificity.</p></blockquote><h3 id="Block-Element–Modifier"><a href="#Block-Element–Modifier" class="headerlink" title="Block__Element–Modifier"></a>Block__Element–Modifier</h3><p>Dân tay to mặt bự đọc đến đây có lẽ đang âm thầm (hoặc công khai) cười khẩy: “Ai kêu gà, xài BEM là được rồi”. Chíp chíp 🐥</p><blockquote><p><strong>Cho những bạn chưa biết:</strong></p><p><a href="https://css-tricks.com/bem-101/" target="_blank" rel="noopener">BEM - Block Element Modifier</a> là một phương pháp đặt tên CSS class được phát triển bởi Yandex. Theo lý thuyết, BEM giúp bạn xây dựng các class theo từng block, mỗi block lại có element con, và các element này có thể sẽ có giao diện khác nhau tuỳ thuộc vào modifier của nó.</p><p>Ví dụ đây là CSS:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/* Block */</span></span><br><span class="line">&gt; .btn &#123;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/* Element */</span></span><br><span class="line">&gt; .btn__price &#123;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/* Modifier */</span></span><br><span class="line">&gt; .btn--big &#123;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; .btn--green &#123;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Áp dụng vào HTML:</p><p><code>&lt;button class=&quot;btn btn--big btn--green&quot;&gt;&lt;span class=&quot;btn__price&quot;&gt;$9.99&lt;/span&gt;&lt;/button&gt;</code></p></blockquote><p>Hoàn toàn không sai. BEM là một phương pháp hiệu quả để chia nhỏ trang thành từng component, và bạn hoàn toàn có thể tránh được cuộc thánh chiến ở trên bằng cách chỉ sử dụng class được đặt tên theo BEM. Ngoài ra, khi một component không còn được dùng nữa, bạn có thể tự tin xoá đi class của nó mà không sợ ảnh hưởng đến các component khác.</p><p>Tuy nhiên BEM cũng có những vấn đề “khó chịu” mà bạn có thể xem thêm ở bài viết <a href="https://www.smashingmagazine.com/2016/06/battling-bem-extended-edition-common-problems-and-how-to-avoid-them/" target="_blank" rel="noopener">Battling BEM CSS: 10 Common Problems And How To Avoid Them</a>. Kinh nghiệm cá nhân là khi làm việc với BEM, có thể bạn sẽ bỏ kha khá thời gian chỉ để suy nghĩ về ngữ nghĩa (semantics) của class. Bạn sẽ phải cân nhắc block này nên đặt tên là gì, những thành phần con của nó có nên là element hay là một component khác, rồi element này nên có tên chi, nên gọi nó là wrapper, container, hay body, v.v… Đừng coi thường việc đặt tên nhé, một trong những vấn đề khó nhai nhất của khoa học máy tính đấy. Ngoài ra tên class thường dính liền với cấu trúc/ nội dung HTML mà nó được sử dụng, dẫn đến việc khi refactor code lại (chuyển thành component tổng quát hơn), chúng ta phải tốn thời gian suy nghĩ tên khác cho hợp lý.</p><p>Với mình, việc suy nghĩ thêm về ngữ nghĩa cho CSS class không đem lại hiệu quả đáng kể. Vì không giống như HTML, trình duyệt và crawlers không quan tâm bạn đặt tên class có ý nghĩa hay không. Chúng chỉ có giá trị với lập trình viên, và thường thì chúng ta chỉ muốn viết HTML/CSS sao cho giống với thiết kế từ designers nhất mà thôi.</p><h3 id="Tinh-tai-su-dung-va-kich-thuoc-tap-tin-CSS"><a href="#Tinh-tai-su-dung-va-kich-thuoc-tap-tin-CSS" class="headerlink" title="Tính tái sử dụng và kích thước tập tin CSS"></a>Tính tái sử dụng và kích thước tập tin CSS</h3><p>Mỉa mai thay, tính chất “cascading” của CSS vốn được sinh ra để hỗ trợ tái sử dụng code lại là một con dao 2 lưỡi và đem đến phiền muộn cho biết bao nhiêu người. Cascading cùng với specificity làm cho CSS trở nên khó dự đoán và lời khuyên là hạn chế cascading được bao nhiêu hay bấy nhiêu. Điều này dẫn đến tập tin CSS chứa nhiều khai báo bị trùng lắp.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.ie6 #footer-content .flex-control-nav li a,</span><br><span class="line">.ie7 #footer-content .flex-control-nav li a,</span><br><span class="line">.ie8 #footer-content .flex-control-nav li a &#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#nav.challenger-a li.menu-products &#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Khi dự án của bạn phát triển, nhiều component xuất hiện đồng nghĩa với kích thước tập tin CSS ngày càng to ra. Đáng buồn là, không phải tất cả CSS được gửi xuống cho người dùng sẽ thật sự được sử dụng trong trang.</p><p><img src="https://res.cloudinary.com/duqeezi8j/image/upload/f_auto,c_scale,w_1000/v1545725390/1_qoyWe6NLqjzVRlDb5YWQAA_nhykgd.jpg" alt=""></p><p><em>Kích thước tập tin CSS của các website lớn, tính đến tháng 11 năm 2016. Nguồn: [1]</em></p><h2 id="Vay-atomic-CSS-giai-quyet-duoc-nhung-van-de-tren-a"><a href="#Vay-atomic-CSS-giai-quyet-duoc-nhung-van-de-tren-a" class="headerlink" title="Vậy atomic CSS giải quyết được những vấn đề trên à?"></a>Vậy atomic CSS giải quyết được những vấn đề trên à?</h2><p>Có thể. Nhưng trước hết hãy xem atomic CSS là gì đã.</p><p>Atomic CSS là cách khai báo các class sao cho mỗi class chỉ mô tả một tính năng duy nhất. Để xây dựng component lớn hơn, chúng ta sẽ kết hợp các class nguyên tử này lại với nhau. Chẳng hạn như:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.white</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-green</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#3d9970</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.px-10</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  Oát đờ hợi (ಠ_ಠ) */</span></span><br></pre></td></tr></table></figure><p>Trong ví dụ trên, class white chỉ làm duy nhất một việc là đổi chữ sang màu trắng, bg-green sẽ thiết lập nền sang màu xanh, trong khi px-10 chỉnh padding ở bên trái và phải (trục x/ trục hoành) thành 10px. Một component được viết theo atomic CSS sẽ giống như thế này:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"b1 b--green bg-green white br-5 ma-10 f3 ttu fw-400 padding-10"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"bg-dark o4 white padding-x-12 fw-600 br-left-5"</span>&gt;</span>$9.99<span class="tag">&lt;/<span class="name">span</span>&gt;</span> Purchase</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>See the Pen <a href="https://codepen.io/ehkoo/pen/KbmGEq/" target="_blank" rel="noopener">BEM vs atomic CSS</a> by Ehkoo (<a href="https://codepen.io/ehkoo" target="_blank" rel="noopener">@ehkoo</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p>Atomic CSS đang được sử dụng bởi các công ty như <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>, <a href="https://stackoverflow.design/product/guidelines/using-stacks#goals" target="_blank" rel="noopener">StackOverflow</a>, <a href="https://design.herokai.com/purple3" target="_blank" rel="noopener">Heroku</a>, v.v…</p><p><strong>Chuyện bên lề: Functional CSS, Atomic CSS, hay Utility-first CSS?</strong></p><p>“Functional CSS” là tên gọi đầu tiên mình bắt gặp khi tìm hiểu về cách viết CSS này. Từ “functional” ngoài nghĩa như trong “functional programming” còn có nghĩa là “hoạt động” (trích <a href="https://en.oxforddictionaries.com/definition/functional" target="_blank" rel="noopener">từ điển Oxford</a>). Do đó “functional CSS” có thể hiểu là “CSS hoạt động được”, hoàn toàn không liên quan đến ý tưởng chính: đặt CSS class thành từng hàm nhỏ.</p><p>Một tên gọi khác là “Atomic CSS”, theo nghĩa mỗi class là một “nguyên tử” độc lập. Tên gọi này rất phù hợp với tiêu chí chia nhỏ class, nhưng đáng tiếc thay khi nó “có thể” nhầm lẫn là có liên quan tới phương thức <a href="http://atomicdesign.bradfrost.com/chapter-2/" target="_blank" rel="noopener">Atomic Design</a>. Ngoài ra, có một thư viện của Yahoo! cũng tên là <a href="https://acss.io/" target="_blank" rel="noopener">Atomic CSS</a>.</p><p>Cuối cùng, “Utility-first CSS” có lẽ là tên gọi mô tả chính xác nhất. “Utility-first” mang nghĩa “tập trung xây dựng các class hỗ trợ”. Điểm trừ của thuật ngữ này là…tên dài quá.</p><p>Suy đi xét lại thiệt hơn thì trong bài viết này mình chọn “atomic CSS” (chữ “a” viết thường) vì…gõ nhanh thôi. Nhưng bạn để ý là 3 thuật ngữ này đều dùng chung cho một cách viết CSS nhé.</p><h2 id="Vay-co-gi-hay"><a href="#Vay-co-gi-hay" class="headerlink" title="Vậy có gì hay?"></a>Vậy có gì hay?</h2><h3 id="Tranh-canh-binh-dao"><a href="#Tranh-canh-binh-dao" class="headerlink" title="Tránh cảnh binh đao"></a>Tránh cảnh binh đao</h3><p>Lợi ích đầu tiên là cũng giống như BEM, atomic CSS chỉ cho phép khai báo các class nên chúng không xảy ra tranh chấp specificity. Đồng thời vì mỗi class chỉ mô tả một tính năng duy nhất, việc các thuộc tính giẫm chân lên nhau được hạn chế ở mức thấp nhất.</p><p>Còn vẫn ghét nhau quá, muốn đạp nhau cho chết thì đây:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span></span><br><span class="line">  Roses are red</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blue"</span>&gt;</span></span><br><span class="line">    Violets are blue</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"yellow"</span>&gt;</span></span><br><span class="line">      Honey is sweet</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"brown"</span>&gt;</span>But not as sweet as you<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>Credit: @huytd</em></p><h3 id="Tap-tin-CSS-nhe-hon"><a href="#Tap-tin-CSS-nhe-hon" class="headerlink" title="Tập tin CSS nhẹ hơn"></a>Tập tin CSS nhẹ hơn</h3><p>Bằng cách xây dựng component bằng những class nguyên tử, bạn không cần phải lặp đi lặp lại những khai báo đã có. Khi nhận được thiết kế cho component mới, bạn chỉ cần kết hợp những class đã có sẵn với nhau hoặc viết thêm atomic classes. Những class mới xuất hiện sẽ tiếp tục được tái sử dụng nên số lượng class bạn thêm vào sẽ ngày càng giảm đi khi tuổi thọ của dự án dài ra. Trong bài viết <a href="https://medium.com/@johnpolacek/by-the-numbers-a-year-and-half-with-atomic-css-39d75b1263b4" target="_blank" rel="noopener">By The Numbers: A Year and Half with Atomic CSS</a>, John Polacek đã thử nghiệm chuyển đổi từ CSS truyền thống sang atomic CSS và kết quả là dung lượng tập tin giảm từ 123.1KB xuống còn 72.7KB (chưa nén gzip).</p><p><img src="https://res.cloudinary.com/duqeezi8j/image/upload/c_scale,f_auto,w_1000/v1545725434/1_Tvxaigmr3ve2GrWDwHB9Pw_qtsoai.jpg" alt=""></p><p>Kết quả cuối cùng là càng ngày bạn sẽ càng viết ít CSS lại.</p><h3 id="Khong-phai-suy-nghi-chuyen-dat-ten-class"><a href="#Khong-phai-suy-nghi-chuyen-dat-ten-class" class="headerlink" title="Không phải suy nghĩ chuyện đặt tên class"></a>Không phải suy nghĩ chuyện đặt tên class</h3><p>Vì các atomic classes được đặt tên gần với thuộc tính của chúng, bạn không cần phải suy nghĩ nên đặt tên gì. Một lợi ích nữa là nhìn vào HTML bạn có thể tương đối biết được style của một element. Lấy ví dụ:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- BEM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn--big btn--green"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__price"</span>&gt;</span>$9.99<span class="tag">&lt;/<span class="name">span</span>&gt;</span> Purchase<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- atomic CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"b1 b--green bg-green white br-5 ma-10 f3 ttu fw-400 padding-10"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"bg-dark o4 white padding-x-12 fw-600 br-left-5"</span>&gt;</span>$9.99<span class="tag">&lt;/<span class="name">span</span>&gt;</span> Purchase</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Với BEM, bạn có thể sơ đoán “à cái nút này là cái nút màu xanh bự nè”, nhưng “bự” là cái gì “bự”, font size hay height, và cái gì “xanh”, chữ xanh, nền xanh hay viền xanh. Khi đi đến btn__price thì hoàn toàn không thể biết được style của nó. So sánh với atomic CSS, bạn có thể đọc ngay là “nút này có viền 1px, viền màu xanh, nền xanh, chữ trắng, bo tròn góc 5px, margin ở bốn phía 10px, font ở level 3, chữ được chuyển thành chữ hoa có font weight 400, padding bốn phía 10px”. Tương tự với thẻ SPAN, bạn có thể đọc là “nền đen có opacity 0.4, chữ trắng, padding trái phải 12px, font weight 600, bo tròn góc bên trái 5px”.</p><p>Liệu việc đọc style như thế này có cần thiết? Nếu bạn mới bắt đầu, câu trả lời có thể là không, nhưng khi đã quen rồi, đọc class nhanh giúp bạn debug và thay đổi style dễ dàng hơn.</p><h3 id="Xay-dung-prototype-nhanh-hon"><a href="#Xay-dung-prototype-nhanh-hon" class="headerlink" title="Xây dựng prototype nhanh hơn"></a>Xây dựng prototype nhanh hơn</h3><p>Prototyping, hay là chuyện làm những giao diện giả để kiểm tra UI/UX, không còn lạ với dân làm frontend nữa. Một trong những lý do bạn chọn Bootstrap, Foundation, hay Bulma… cho dự án vì đơn giản chúng cung cấp những component được xây dựng sẵn, cùng với hệ thống grid và các class hỗ trợ. Nhưng rồi bạn sẽ lâm vào cảnh đánh nhau với các class của framework để tuỳ biến cho phù hợp với chuẩn thiết kế. Kết quả ra sao thì bạn biết rồi.</p><p>Các framework được thiết kế theo hướng atomic không có nhiều component, nhưng bù lại chúng không đặt quá nhiều ý kiến riêng và ép buộc bạn phải làm theo. Hầu hết đều cho phép bạn tuỳ chỉnh màu sắc, kích thước theo ý, từ đó bạn có thể xây dựng lên những component cần thiết.</p><h2 id="Han-che"><a href="#Han-che" class="headerlink" title="Hạn chế"></a>Hạn chế</h2><h3 id="Bung-no-class"><a href="#Bung-no-class" class="headerlink" title="Bùng nổ class"></a>Bùng nổ class</h3><p><a href="http://tachyons.io/docs/themes/skins/" target="_blank" rel="noopener">Tachyons</a> là một trong những atomic CSS framework phổ biến nhất. Trong phiên bản 4.10.0, Tachyons hỗ trợ 37 màu. Giả sử mỗi màu sẽ có class tương ứng với màu chữ, màu nền, màu viền, hover đổi màu chữ, hover đổi màu nền, và hover đổi màu viền. Tachyons có 3 breakpoints. Như vậy tổng số class được tạo ra là 37 x 8 (thuộc tính) x 3 = 888 classes. Nếu bạn phải sử dụng nhiều màu hơn, ví dụ như color palette của <a href="https://material.io/design/color/the-color-system.html#tools-for-picking-colors" target="_blank" rel="noopener">Material Design</a>, hỗ trợ nhiều thuộc tính và pseudo selector hơn, thêm vài breakpoints nữa, bạn cũng có thể đoán được số lượng class phình ra như thế nào.</p><p>Thực tế là không phải tất cả class màu đều được sử dụng, nên việc tạo ra class để bao gồm tất cả các trường hợp là không cần thiết. Cách giải quyết ở đây là chỉ viết thêm class khi bạn thật sự cần đến nó.</p><h3 id="Tim-va-thay-doi-class-theo-yeu-cau-moi-kho-hon"><a href="#Tim-va-thay-doi-class-theo-yeu-cau-moi-kho-hon" class="headerlink" title="Tìm và thay đổi class theo yêu cầu mới khó hơn"></a>Tìm và thay đổi class theo yêu cầu mới khó hơn</h3><p>Giả sử một ngày đẹp trời nào đó, đồng chí Nguyễn Văn Xài Nơ quyết định nền màu xanh của tất cả các nút phải đậm hơn chút xíu, nút bự nghĩa là font size phải ở level 2. Với BEM, bạn chỉ cần thay đổi giá trị của class .btn–green và .btn–big là xong. Trong khi đó bạn không thể đổi mã màu của .bg-green bởi vì thay đổi này chỉ áp dụng trên nút và biết đâu được màu cũ vẫn được dùng ở nơi khác. Bạn cũng không thể tuỳ tiện tăng font size của .f3. Giải pháp an toàn nhất là tìm tất cả các nút, xoá đi class cũ và thêm vào f2 bg-dark-green. Bạn tìm các nút bằng cách nào? Search and Replace… bg-green white br-5 ma-10 f3 -&gt; bg-dark-green white br-5 ma-10 f2? Lỡ như có một class nào đó chen vào giữa bg-green white br-5 ma-10 letter-spacing-1 f3 và thế là tèn tén ten.</p><p>Nếu dự án của bạn sử dụng React, Vue, hay các thư viện hỗ trợ (web) component khác, việc thay đổi này không thành vấn đề. Còn với thuần HTML thì…coi bộ cực đó. Bạn có thể đặt tên cho UI component bằng data-, nhưng như vậy markup sẽ bị rối và ở phía người dùng, các thuộc tính này hoàn toàn không được dùng đến.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">data-ui-name</span>=<span class="string">"button-big-green"</span> <span class="attr">class</span>=<span class="string">"b1 b--green bg-green white br-5 ma-10 f3 ttu fw-400 padding-10"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"bg-dark o4 white padding-x-12 fw-600 br-left-5"</span>&gt;</span>$9.99<span class="tag">&lt;/<span class="name">span</span>&gt;</span> Purchase</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Nghi-ngo-tu-cong-dong"><a href="#Nghi-ngo-tu-cong-dong" class="headerlink" title="Nghi ngờ từ cộng đồng"></a>Nghi ngờ từ cộng đồng</h3><p>Thành thật mà nói, atomic CSS rất không tự nhiên khi tiếp xúc lần đầu tiên. Chúng ta đã quá quen với cách viết CSS truyền thống/ BEM, và khi nhìn thấy một đống class đi chung với những cái tên xa lạ như ma, px, hay ttu, nghi ngờ là phản ứng rất dễ hiểu.</p><blockquote><p><strong>Vậy có khác gì inline style?</strong></p></blockquote><p>Nhìn sơ qua thì đúng là giống như inline style vậy, và ai cũng biết inline style là bad practice. Nhưng atomic classes khác hoàn toàn và mạnh mẽ hơn inline style nhiều. Atomic classes cho phép bạn viết media queries, @support, pseudo selectors hay sử dụng animation, những điều mà inline style không làm được. Và vì atomic CSS được lưu trong tập tin CSS, trình duyệt có thể lưu vào bộ nhớ đệm, không giống như inline style.</p><blockquote><p><strong>Tên class thấy gớm</strong></p></blockquote><p>Kiểu viết tắt ma (margin all), px (padding x), ph (padding horizontal) hay bg rất phổ biến trong cộng đồng atomic CSS. Ban đầu bạn có thể thấy khó hiểu và tốn thời gian để học, nhưng sau một thời gian chúng sẽ trở nên tự nhiên.</p><p>Ngoài ra còn một số ý kiến phản đối atomic CSS nữa mà nếu muốn, bạn có thể đọc bài viết <a href="https://medium.com/simple-human/the-problem-with-atomic-css-d0c09c7aa38e" target="_blank" rel="noopener">The Problem with Atomic CSS</a> rồi tự đưa ra nhận xét. Spoiler alert: không phải tất cả luận điểm trong bài đều hợp lý.</p><h2 id="Tich-hop-vao-du-an"><a href="#Tich-hop-vao-du-an" class="headerlink" title="Tích hợp vào dự án"></a>Tích hợp vào dự án</h2><p>Nếu bạn đọc đến đây và không cảm thấy atomic CSS là một ý tưởng dị hợm thì bài viết này coi như đã thành công. Để dùng atomic CSS trong dự án, bạn có thể chọn cách dùng các thư viện có sẵn, hoặc tự xây dựng thư viện riêng.</p><h3 id="Dung-hang-an-san"><a href="#Dung-hang-an-san" class="headerlink" title="Dùng hàng ăn sẵn"></a>Dùng hàng ăn sẵn</h3><p>Cách này phù hợp với những dự án mới hoặc bạn muốn thử nghiệm với atomic CSS. Hiện tại thì hai thư viện phổ biến nhất là <a href="http://tachyons.io/" target="_blank" rel="noopener">Tachyons</a> và <a href="http://tailwindcss.com/" target="_blank" rel="noopener">Tailwind</a>. Tachyons có lượng người dùng đông đảo vì xuất hiện trước, nhưng Tailwind lại mạnh mẽ hơn vì cho phép bạn thay đổi màu sắc, kích thước, v.v… hoàn toàn theo ý muốn. Không thì bạn có thể dùng hệ thống thiết kế của <a href="https://stackoverflow.design/product/guidelines/using-stacks#goals" target="_blank" rel="noopener">StackOverflow</a> hay <a href="https://design.herokai.com/purple3" target="_blank" rel="noopener">Heroku</a> cũng được.</p><p>Sự thật là các atomic classes quá nhỏ nên chúng gần như giống hệt nhau ở tất cả framework, có khác chăng chỉ là tên gọi mà thôi.</p><h3 id="Tu-trong"><a href="#Tu-trong" class="headerlink" title="Tự trồng"></a>Tự trồng</h3><p>Trong một dự án đang chạy, nếu muốn áp dụng atomic CSS thì không gì tốt hơn là tự trồng lấy một framework. Các atomic classes rất nhỏ và đơn giản nên hoàn toàn không có gì khó để tự viết cả. Bạn có thể từ từ bóc tách các thuộc tính của các class cũ và chuyển chúng thành atomic classes. Dự án của bạn có thể sắp xếp các tập tin (S)CSS như thế này.</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">styles/utils/</span><br><span class="line">├── _animation<span class="selector-class">.scss</span></span><br><span class="line">├── _background<span class="selector-class">.scss</span></span><br><span class="line">├── _border<span class="selector-class">.scss</span></span><br><span class="line">├── _box-shadow<span class="selector-class">.scss</span></span><br><span class="line">├── _color<span class="selector-class">.scss</span></span><br><span class="line">├── _cursor<span class="selector-class">.scss</span></span><br><span class="line">├── _display<span class="selector-class">.scss</span></span><br><span class="line">├── _flex<span class="selector-class">.scss</span></span><br><span class="line">├── _font-size<span class="selector-class">.scss</span></span><br><span class="line">├── _font-weight<span class="selector-class">.scss</span></span><br><span class="line">├── _height<span class="selector-class">.scss</span></span><br><span class="line">├── _letter-spacing<span class="selector-class">.scss</span></span><br><span class="line">├── _line-<span class="attribute">height</span><span class="selector-class">.scss</span></span><br><span class="line">├── _list<span class="selector-class">.scss</span></span><br><span class="line">├── _margin<span class="selector-class">.scss</span></span><br><span class="line">├── _max-<span class="attribute">width</span><span class="selector-class">.scss</span></span><br><span class="line">├── _padding<span class="selector-class">.scss</span></span><br><span class="line">├── _ratio<span class="selector-class">.scss</span></span><br><span class="line">├── _text-align<span class="selector-class">.scss</span></span><br><span class="line">└── _width<span class="selector-class">.scss</span></span><br></pre></td></tr></table></figure><p>Về việc đặt tên, bạn có thể chọn kiểu viết tắt px, ma hay ttu như trong Tachyons, hoặc kiểu đầy đủ padding-x, margin-all, text-transform-uppercase. Cái này tuỳ thuộc vào sở thích của từng team.</p><p>Ngoài ra, việc viết lặp đi lặp lại nhóm class có thể gây nhàm chán, do đó bạn đừng quên tận dụng các công cụ tiền xử lý CSS như SASS, LESS, hay Stylus để cuộc sống dễ thở hơn. Chẳng hạn như đoạn code dưới đây để tạo ra các class liên quan đến height:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$list</span>: <span class="number">28</span> <span class="number">96</span> <span class="number">128</span> <span class="number">640</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$value</span> in <span class="variable">$list</span> &#123;</span><br><span class="line">  <span class="selector-class">.h-</span>#&#123;<span class="variable">$value</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">height</span>: #&#123;<span class="variable">$value</span>&#125;px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Khi cần thêm một giá trị mới, bạn chỉ cần bỏ nó vào $list. Bạn cũng có thể dùng mixin để tạo ra các class responsive:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">include</span> media(extra-large) &#123;</span><br><span class="line">  <span class="variable">$list</span>: <span class="number">28</span> <span class="number">96</span> <span class="number">128</span> <span class="number">640</span>;</span><br><span class="line"></span><br><span class="line">  @<span class="keyword">each</span> <span class="variable">$value</span> in <span class="variable">$list</span> &#123;</span><br><span class="line">    <span class="selector-class">.h-</span>#&#123;<span class="variable">$value</span>&#125;-xl &#123;</span><br><span class="line">      <span class="attribute">height</span>: #&#123;<span class="variable">$value</span>&#125;px;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ket"><a href="#Ket" class="headerlink" title="Kết"></a>Kết</h2><p>Nếu nhóm của bạn đang dùng BEM hay các phương pháp phát triển CSS khác và hài lòng với chúng, bạn có thể không cần atomic CSS. Atomic CSS không phải sinh ra là để triệt tiêu BEM, mà bổ sung và giúp bạn làm việc với CSS một cách hiệu quả hơn.</p><p>Cuối cùng, hãy xem video này và quyết định có nên xài atomic CSS không nhé ;)</p><div class="video-container"><iframe src="//www.youtube.com/embed/16W7c0mb-rE" frameborder="0" allowfullscreen></iframe></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Nhung-van-de-voi-cach-viet-CSS-hien-tai&quot;&gt;&lt;a href=&quot;#Nhung-van-de-voi-cach-viet-CSS-hien-tai&quot; class=&quot;headerlink&quot; title=&quot;Những vấn đề v
      
    
    </summary>
    
    
      <category term="css" scheme="http://nthung2112.github.io/tags/css/"/>
    
      <category term="atomic" scheme="http://nthung2112.github.io/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P19: Bên trong custom element + thủ thuật xây dựng component tối ưu</title>
    <link href="http://nthung2112.github.io/2019/01/Cach-Javascript-hoat-dong-P19-Ben-trong-custom-element-thu-thuat-xay-dung-component-toi-uu.html"/>
    <id>http://nthung2112.github.io/2019/01/Cach-Javascript-hoat-dong-P19-Ben-trong-custom-element-thu-thuat-xay-dung-component-toi-uu.html</id>
    <published>2019-01-05T17:03:00.000Z</published>
    <updated>2019-01-05T17:07:19.212Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>Đây là bài cuối cùng trong series rồi (chắc vậy á, lâu nay không thấy họ đăng bài mới). Cảm ơn mọi người đã ủng hộ mình trong suốt thời gian qua. Tuy nhiên nếu SessionStack có bài viết nào mới thì mình sẽ cập nhật thêm.</em></strong></p><ul><li>Element: phần tử</li><li>Custom element: phần tử tùy chọn (tức là những element do người dùng tự tạo ra)</li><li>Component: thành phần</li></ul><p>Chào các bạn đến với bài thứ 19 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.<br><a id="more"></a></p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Trong bài trước chúng ta đã thảo luận về Shadow DOM API và 1 vài ý tưởng vốn là các mảnh ghép của 1 bức tranh lớn hơn: web components. Toàn bộ ý tưởng đằng sau tiêu chuẩn <strong>web components</strong> là có thể mở rộng các tính năng sẵn có của HTML bằng cách tạo ra các element vừa nhỏ gọn, hướng mô đun và có thể tái sử dụng nhiều lần. Đây là 1 tiêu chuẩn tương đối mới trong W3C và đã được chấp nhận bởi đa số các trình duyệt lớn và có thể thấy nó xuất hiện trong nhiều môi trường production… dĩ nhiên là với 1 chút sự giúp đỡ từ các thư viện polyfill mà chúng ta sẽ nói sau.<br>*_Polyfill là để chỉ việc biến đổi, thay thế hoặc chỉnh sửa các tính năng mới của ngôn ngữ JS, HTML, CSS sao cho nó có thể hoạt động được trên các trình duyệt cũ như IE</p><p>Như các bạn đã biết, trình duyệt cung cấp cho chúng ta 1 số ít các công cụ quan trọng để xây dựng website và các webapp. Ta đang nói về HTML, CSS &amp; Javascript. Bạn dùng HTML để kiến trúc nên app của bạn, CSS để trang điểm và làm cho nó đẹp hơn rồi dùng Javascript thực hiện các hành động khác. Tuy nhiên, trước khi <strong>web components</strong> được giới thiệu thì không có cách nào dễ dàng để liên kết các hành vi của Javascript đến với kiến trúc của HTML.</p><p>Trong bài viết này, chúng ta sẽ tìm hiểu về nền tảng của web component: <strong>custom element</strong>. Nói ngắn gọn, API custom element cho phép bạn tạo ra các custom HTML element với logic Javascript và CSS style tích hợp sẵn. Rất nhiều người cảm thấy bối rối nhầm lẫn custom element với Shadow DOM. Nhưng chúng là 2 ý tưởng hoàn toàn khác nhau và chúng thực sử bổ khuyết cho nhau thay vì thay thế lẫn nhau.</p><p>Một vài framework và library như Angular, React… cố giải quyết cùng 1 vấn đề bằng cách giới thiệu ý tưởng riêng của họ. Bạn có thể so sánh custom element với Angular directive hoặc React component. Tuy nhiên, custom element gần gũi với trình duyệt mà không yêu cầu gì hơn ngoài bản gốc của Javascript, HTML, CSS. Dĩ nhiên, điều này không có nghĩa rằng nó là bản thay thế cho các Javascript framework điển hình. Các framework hiện đại cho phép chúng ta thực hiện nhiều thứ hơn là chỉ giả lập hành vi của custom element. Vì thế mà chúng có thể cùng hoạt động bên cạnh nhau.</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>Trước khi chúng ta đào sâu hơn thì hãy cùng duyệt qua những gì mà API cung cấp. Object global customElements sẵn có cho ta vài phương thức:</p><ul><li>define(tagName, constructor, options): Định nghĩa custom element mới. Nó nhận vào 3 đối số: 1 thẻ tên hợp lệ cho custom element, định nghĩa lớp cho custom element và 1 object options. Hiện tại thì chỉ có 1 option được hỗ trợ là extends, mang giá trị là 1 string chỉ định tên của element có sẵn để mở rộng. Thường được dùng để tạo ra các tùy biến của element sẵn có.</li><li>get(tagName): Trả về constructor của 1 custom element nếu như element được định nghĩa và ngược lại thì trả về undefined. Nó nhận vào 1 đối số duy nhất: thẻ tên hợp lệ của custom element.</li><li>whenDefined(tagName): Trả về 1 promise và được resolve khi custom element được định nghĩa. Nếu như element đã được định nghĩa rồi thì nó sẽ resolve ngay lập tức. Promise bị reject nếu như thẻ tên không phải là tên hợp lệ của custom element. Nó nhận vào 1 đối số: thẻ tên hợp lệ của 1 custom element.</li></ul><h1 id="Cach-tao-custom-element"><a href="#Cach-tao-custom-element" class="headerlink" title="Cách tạo custom element"></a>Cách tạo custom element</h1><p>Tạo ra custom element rất đơn giản. Bạn chỉ cần làm 2 việc: định nghĩa 1 lớp cho element và cho nó extends từ lớp HTMLElement, việc thứ 2 là đăng ký tên cho element đó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">'my-custom-element'</span>, MyCustomElement);</span><br></pre></td></tr></table></figure><p>Hoặc nếu muốn thì bạn có thể sử dụng anonymous class (lớp vô danh) trong trường hợp bạn muốn code gọn gàng hơn 1 chút:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">customElements.define(<span class="string">'my-custom-element'</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Như các bạn đã thấy, custom element được đăng ký bằng phương thức customElements.define(…)</p><h1 id="Custom-element-giai-quyet-van-de-gi"><a href="#Custom-element-giai-quyet-van-de-gi" class="headerlink" title="Custom element giải quyết vấn đề gì ?"></a>Custom element giải quyết vấn đề gì ?</h1><p>Vậy chứ vấn đề ở đây là gì? <strong>Div soups</strong> chẳng hạn. Thế div soups là cái nồi gì? Thì rõ theo nghĩa đen thì nó là cái nồi súp thẻ div. Trong các ứng dụng webapp hiện đại thì đây là kiểu kiến trúc rất phổ biến khi ta có rất nhiều các thẻ div lồng nhau như thế này đây:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top-container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle-container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inside-container"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inside-inside-container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"are-we-really-doing-this"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mariana-trench"</span>&gt;</span></span><br><span class="line">            …</span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Kiểu kiến trúc như thế này thường được dùng vì nó bảo trình duyệt phải render những gì mà developer muốn. Nhưng nó lại làm cho code HTML khó đọc và rất khó bảo trì. Ví dụ chúng ta có 1 component trông như thế này:<br><img src="https://cdn-images-1.medium.com/max/1000/0*v56OyrPtg_cZzzaZ" alt=""></p><p>Vậy thì theo cách cũ, HTML sẽ như thế này:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"primary-toolbar toolbar"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-button"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-button-outer-box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-button-inner-box"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icon"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icon-undo"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-button"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-button-outer-box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-button-inner-box"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icon"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icon-redo"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-button"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-button-outer-box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-button-inner-box"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icon"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icon-print"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-toggle-button toolbar-button"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-button-outer-box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-button-inner-box"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icon"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icon-paint-format"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Tuy nhiên, tưởng tượng rằng chúng ta có thể làm như thế này:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">primary-toolbar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">toolbar-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">toolbar-button</span> <span class="attr">class</span>=<span class="string">"icon-undo"</span>&gt;</span><span class="tag">&lt;/<span class="name">toolbar-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">toolbar-button</span> <span class="attr">class</span>=<span class="string">"icon-redo"</span>&gt;</span><span class="tag">&lt;/<span class="name">toolbar-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">toolbar-button</span> <span class="attr">class</span>=<span class="string">"icon-print"</span>&gt;</span><span class="tag">&lt;/<span class="name">toolbar-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">toolbar-toggle-button</span> <span class="attr">class</span>=<span class="string">"icon-paint-format"</span>&gt;</span><span class="tag">&lt;/<span class="name">toolbar-toggle-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">toolbar-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">primary-toolbar</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Rõ ràng ví dụ thứ 2 nhìn sạch sẽ và gọn hơn nhiều. Dễ bảo trì, dễ đọc cho cả trình duyệt và developer. Đơn giản hơn nhiều.</p><p>Vấn đề tiếp theo là khả năng tái sử dụng. Công việc của developer chúng ta đòi hỏi không chỉ viết code hoạt động được mà còn phải bảo trì được. Và 1 điều làm cho code dễ bảo trì là nó có thể dễ dàng tái sử dụng 1 phần nào đó của code thay vì phải viết đi viết lại nhiều lần.</p><p>Dưới đây là 1 ví dụ đơn giản nhưng bạn sẽ hiểu ý tưởng của nó. Giả sử ta có element sau:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-custom-element"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"email"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Nếu chúng ta cần sử dụng nó ở nơi nào khác thì ta sẽ phải viết lại đoạn HTML trên nhiều lần. Giả sử như ta cần thay đổi 1 phần nào đó và áp dụng cho mọi element. Ta sẽ phải đi tìm tất cả mọi nơi có đoạn code đó và chỉnh sửa chính xác cùng 1 thay đổi y chang nhau rất nhiều lần, bùm…..</p><p>Vậy thì không tốt hơn nếu ta chỉ cần như vậy thôi sao:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-custom-element</span>&gt;</span><span class="tag">&lt;/<span class="name">my-custom-element</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Nhưng webapp hiện đại không chỉ có HTML tĩnh. Bạn cần tương tác với nó nữa. Và đây là lúc ta cần Javascript. Thường thì bạn sẽ tạo ra 1 vài element, ghép chúng vào bất kỳ event listener nào mà bạn muốn để cho nó có thể tương tác phản hồi khi có input từ người dùng. Bất kể là click, kéo-thả, hover, nhấn bàn phím, vân vân</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">'.my-custom-element'</span>);</span><br><span class="line"></span><br><span class="line">myDiv.addEventListener(<span class="string">'click'</span>, _ =&gt; &#123;</span><br><span class="line">  myDiv.innerHTML = <span class="string">'&lt;b&gt; I have been clicked &lt;/b&gt;'</span>;</span><br><span class="line">&#125;);<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-custom-element"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  I have not been clicked yet.</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Với API custom element, toàn bộ phần logic này có thể được đóng gói vào bên trong chính element đó. Xem ví dụ bên dưới</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    self.addEventListener(<span class="string">'click'</span>, _ =&gt; &#123;</span><br><span class="line">      self.innerHTML = <span class="string">'&lt;b&gt; I have been clicked &lt;/b&gt;'</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">'my-custom-element'</span>, MyCustomElement);<span class="xml"><span class="tag">&lt;<span class="name">my-custom-element</span>&gt;</span></span></span><br><span class="line"><span class="xml">  I have not been clicked yet</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">my-custom-element</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Mới đầu nhìn vào thì có vẻ như giải pháp custom element này đòi hỏi nhiều Javascript. Tuy nhiên trong các ứng dụng thực tế thì bạn sẽ hiếm khi gặp phải trường hợp mà bạn tạo ra 1 element mà không phải tái sử dụng nó. Một diều điển hình nữa trong các webapp hiện đại là đa số các element đều được tạo ra bằng code trong quá trình hoạt động (dynamic). Vì thế bạn cần phải xử lý các trường hợp riêng biệt khi element được thêm vào bằng Javascript hoặc nó được định nghĩa trước kia trong kiến trúc HTML. Bạn sẽ có toàn bộ những tính năng ấy nếu dùng custom element.</p><p>Tóm lại, custom element làm code bạn dễ hiểu, dễ bảo trì hơn, chia nhỏ nó thành các module khép kín nhỏ hơn, có thể tái sử dụng.</p><h1 id="Cac-yeu-cau"><a href="#Cac-yeu-cau" class="headerlink" title="Các yêu cầu"></a>Các yêu cầu</h1><p>Trước khi bạn bắt đầu tạo custom element của chính mình, bạn nên biết rằng có 1 số quy tắc đặc biệt mà ta phải tuân theo:</p><ul><li>Tên <strong>phải</strong> chứa dấu gạch ngang (-). Bằng cách này bộ parser của HTML mới hiểu được element nào là do người dùng tạo ra và element nào là sẵn có. Nó cũng đảm bảo rằng không có xung đột khi đặt tên với các element sẵn có (bất kể bây giờ hay trong tương lai, khi một element mới được thêm vào). Ví dụ, <code>&lt;my-custom-element&gt;</code> là 1 tên hợp lệ trong khi <code>&lt;myCustomElement&gt;</code> và <code>&lt;my_custom_element&gt;</code> thì không.</li><li>Không được đăng ký cùng 1 thẻ tên nhiều hơn 1 lần. Điều này sẽ làm cho trình duyệt bắn ra 1 biệt lệ DOMException. Bạn không thể ghi đè các custom element.</li><li>Custom element không thể tự đóng thẻ. Bộ parser HTML chỉ cho phép 1 nhóm các element sẵn có có thể tự đóng thẻ của nó (ví dụ: <code>&lt;img&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;br&gt;</code>).</li></ul><h1 id="Cac-kha-nang"><a href="#Cac-kha-nang" class="headerlink" title="Các khả năng"></a>Các khả năng</h1><p>Vậy thì bạn thực sự có thể làm được gì với custom element? Và câu trả lời là: rất nhiều thứ.</p><p>Một trong số những tính năng tốt nhất là định nghĩa class của element thực sự liên kết đến chính DOM element của nó. Điều này có nghĩa bạn có thể dùng trực tiếp this với event listener, truy cập vào các property của nó, truy cập các node con và vân vân.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.addEventListener(<span class="string">'mouseover'</span>, _ =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'I have been hovered'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dĩ nhiên là nó cho bạn khả năng để ghi đè lại node con của 1 element với nội dung mới. Và cũng dĩ nhiên là điều này không nên làm, bởi vì nó sẽ dẫn đến nhiều vấn đề không mong muốn. Rõ ràng nếu như bạn có 1 custom element đang hoạt động và đột nhiên phát hiện ra phần markup của element của mình bị thay đổi thì sẽ bối rối lắm.</p><p>Có 1 vài vị trí đặc biệt mà bạn có thể định nghĩa để thực thi code tại các thời điểm cụ thể trong vòng đời của element.</p><ul><li>constructor: constructor được gọi 1 lần khi element được tạo ra hoặc nâng cấp (chúng ta sẽ nói về nó sau). Đa số nó được dùng để khởi tạo state (trạng thái), gắn kết các event listener, tạo shadow DOM, vân vân. Lưu ý bạn hầu như cần phải gọi super() trong constructor.</li><li>connectedCallback: phương thức connectedCallback được gọi mỗi lần element được thêm vào DOM. Nó có thể được dùng (khuyến nghị nên dùng) để delay (hoãn lại) vài việc cho đến khi element thực sự được gắn vào trang (chẳng hạn như lấy tài nguyên từ server).</li><li>disconnectedCallback: tương tự như connectedCallback thì disconnectedCallback được gọi khi 1 element bị lấy ra khỏi DOM. Thường là để giải phóng tài nguyên. Lưu ý rằng disconnectedCallback không bao giờ được gọi nếu như user đóng tab. Hãy cẩn thận với những thứ mà bạn khởi tạo lúc đầu.</li><li>attributeChangedCallback: phương thức này được gọi khi 1 attribute của element được thêm vào, gỡ ra, cập nhật hoặc thay thế. Nó cũng được gọi khi element được tạo ra bởi parser. Tuy nhiên, lưu ý rằng nó chỉ áp dụng cho các attribute nằm trong danh sách an toàn (whitelist) của property observedAttributes</li><li>addoptedCallback: phương thức này được gọi khi document.adoptNote(…) được gọi để đưa đó sang 1 document khác.</li></ul><p>Lưu ý rằng tất cả các callbacks ở trên đều là <strong>đồng bộ</strong>. Ví dụ, connectedCallback được gọi ngay lập tức sau khi element được thêm vào DOM và trong lúc đó không có gì xảy ra.</p><h1 id="Phan-chieu-property"><a href="#Phan-chieu-property" class="headerlink" title="Phản chiếu property"></a>Phản chiếu property</h1><p>Các element HTML sẵn có cung cấp 1 khả năng rất tiện dụng: phản chiếu property. Nghĩa là các giá trị của 1 vài property được phản chiếu trực tiếp về DOM dưới dạng attribute. Một ví dụ điển hình là property id.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myDiv.id = <span class="string">'new-id'</span>;</span><br></pre></td></tr></table></figure><p>Cũng sẽ cập nhật DOM thành:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"new-id"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Và nó cũng áp dụng theo hướng ngược lại nữa. Phần này cực kỳ tiện lợi bởi vì nó cho phép bạn cấu hình các element khai báo.</p><p>Custom element không có tính năng như thế này nhưng có 1 cách để bạn tự triển khai. Ta có thể có được tính năng tương tự khi định nghĩa các getter &amp; setter cho các property.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  get myProperty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hasAttribute(<span class="string">'my-property'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set myProperty(newValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setAttribute(<span class="string">'my-property'</span>, newValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.removeAttribute(<span class="string">'my-property'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Mo-rong-element"><a href="#Mo-rong-element" class="headerlink" title="Mở rộng element"></a>Mở rộng element</h1><p>API custom element cho phép bạn không chỉ tạo ra các element HTML mà còn có thể mở rộng element sẵn có. Phương pháp này hoạt động cực tốt cho cả element sẵn có và custom element. Bạn chỉ cần mở rộng định nghĩa class của nó là được.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAwesomeButton</span> <span class="keyword">extends</span> <span class="title">MyButton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">'my-awesome-button'</span>, MyAwesomeButton);</span><br></pre></td></tr></table></figure><p>Hoặc trong trường hợp của element có sẵn, ta cần thêm 1 param thứ 3 vào hàm customElements.define(…) - một object với property extends và giá trị là thẻ tên của element đang được mở rộng. Bằng cách này trình duyệt biết được chính xác thì element nào đang được mở rộng bởi vì có rất nhiều element sẵn có cùng chia sẻ giao diện DOM. Nếu không chỉ định element nào mà mình muốn mở rộng, trình duyệt sẽ không biết được chức năng nào đang được mở rộng.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">'my-button'</span>, MyButton, &#123;<span class="attr">extends</span>: <span class="string">'button'</span>&#125;);</span><br></pre></td></tr></table></figure><p>Một element gốc mở rộng (extended native element) còn được gọi là element được tùy biến (customized built-in element).</p><p>Nguyên tắc vàng cho bạn đó là luôn luôn mở rộng các element đang tồn tại sẵn. Và làm việc này một cách dần dần. Nó cho phép bạn giữ lại tất cả các tính năng trước đó (property, attribute, các hàm).</p><p>Chú ý rằng element được tùy biến chỉ được hỗ trợ từ Chrome 67 trở lên. Nó sẽ được triển khai cho các trình duyệt khác ngoại trừ Safari.</p><h1 id="Nang-cap-element"><a href="#Nang-cap-element" class="headerlink" title="Nâng cấp element"></a>Nâng cấp element</h1><p>Như đã nói ở trên, chúng ta sử dụng phương thức customElements.define(…) để đăng ký 1 custom element. Nhưng nó không có nghĩa rằng đó là việc đầu tiên bạn phải làm. Đăng ký custom element có thể được hoãn lại sau này. Kể cả sau khi chính element đó được thêm vào DOM. Quá trình này được gọi là nâng cấp element. Để giúp bạn biết được thực sự khi nào thì element được định nghĩa thì trình duyệt có cung cấp phương thức customElements.whenDefine(…). Bạn truyền thẻ tên của element vào, nó trả về 1 promise và sẽ được resolve khi element đăng ký xong.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">customElements.whenDefined(<span class="string">'my-custom-element'</span>).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'My custom element is defined'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Ví dụ, khi bạn muốn delay 1 vài thứ cho đến khi tất cả các element con được định nghĩa xong, cực kỳ có ích khi mà bạn có các custom element lồng nhau. Thỉnh thoảng element cha sẽ dựa vào sự triển khai của các element con. Trong trường hợp này bạn cần đảm bảo rằng các element con được định nghĩa trước element cha.</p><h1 id="Shadow-DOM"><a href="#Shadow-DOM" class="headerlink" title="Shadow DOM"></a>Shadow DOM</h1><p>Như đã nói, custom element và shadow DOM đi đôi với nhau. Custom element được dùng để đóng gói logic Javascript vào bên trong 1 element trong khi shadow DOM được dùng để tạo ra 1 môi trường khép kín cho phần DOM không bị ảnh hưởng bởi các yếu tố bên ngoài. Mình đề nghị bạn nên đọc lại <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-17---ben-trong-Shadow-DOM---xay-dung-component-khep-kin" target="_blank" rel="noopener">bài viết trước</a> để hiểu thêm về shadow DOM và các ý tưởng của nó.</p><p>Để sử dụng shadow DOM cho custom element, bạn chỉ cần đơn giản gọi this.attachShadow</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> shadowRoot = <span class="keyword">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'open'</span>&#125;);</span><br><span class="line">    <span class="keyword">let</span> elementContent = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    shadowRoot.appendChild(elementContent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h1><p>Chúng ta đã tìm hiểu sơ về template trong <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-17---ben-trong-Shadow-DOM---xay-dung-component-khep-kin" target="_blank" rel="noopener">bài viết trước về shadow DOM</a> và chúng xứng đáng có 1 bài viết riêng. Ở đây chúng ta sẽ đưa ra 1 ví dụ đơn giản làm thế nào để bạn có thể kết hợp các template vào quá trình tạo ra custom element. Sử dụng thẻ <code>&lt;template&gt;</code> bạn có thể khai báo thẻ của 1 mảnh DOM, một thứ được parse nhưng không được render trên trang.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=<span class="string">"my-custom-element-template"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"my-custom-element"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"email"</span> /&gt;</span><br><span class="line">    &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"submit"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;<span class="keyword">let</span> myCustomElementTemplate = <span class="built_in">document</span>.querySelector(<span class="string">'#my-custom-element-template'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> shadowRoot = <span class="keyword">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'open'</span>&#125;);</span><br><span class="line">    shadowRoot.appendChild(myCustomElementTemplate.content.cloneNode(<span class="literal">true</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Giờ đây chúng ta có thể kết hợp custom element với shadow DOM và template, ta có được 1 element khép kín trong phạm vi của chính nó và có kiến trúc HTML riêng biệt cũng như Javascript logic</p><h1 id="Styling"><a href="#Styling" class="headerlink" title="Styling"></a>Styling</h1><p>Chúng ta đã đi qua phần của HTML &amp; Javascript, giờ là về CSS. Rõ ràng thì ta cần 1 cách để chỉnh style cho các element. Chúng ta có thể thêm CSS stylesheet vào bên trong shadow DOM nhưng bạn sẽ thắc mắc là làm thế nào ta có thể chỉnh style của element từ bên ngoài với vai trò là 1 user của element đó. Và câu trả lời lại đơn giản: bạn cứ style nó giống như cách bạn làm với các element gốc.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my-custom-element &#123;</span><br><span class="line">  border-radius: <span class="number">5</span>px;</span><br><span class="line">  width: <span class="number">30</span>%;</span><br><span class="line">  height: <span class="number">50</span>%;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lưu ý rằng style định nghĩa từ bên ngoài có độ ưu tiên cao hơn và nó sẽ ghi đè style định nghĩa từ element.</p><p>Bạn cũng biết có 1 số trường hợp khi trang được load nhưng nội dung trên trang vẫn ở dạng HTML thô và chưa được style (flash of unstyled content - FOUC). Bạn có thể ngăn chặn tình huống này bằng cách định nghĩa style cho các undefined component và sử dụng một số cách transition khi chúng được định nghĩa xong. Để làm như vậy ta cần dùng selector :defined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my-button:not(:defined) &#123;</span><br><span class="line">  height: <span class="number">20</span>px;</span><br><span class="line">  width: <span class="number">50</span>px;</span><br><span class="line">  opacity: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Element-khong-ton-tai-unknown-va-custom-element-chua-dinh-nghia-undefined"><a href="#Element-khong-ton-tai-unknown-va-custom-element-chua-dinh-nghia-undefined" class="headerlink" title="Element không tồn tại (unknown) và custom element chưa định nghĩa (undefined)"></a>Element không tồn tại (unknown) và custom element chưa định nghĩa (undefined)</h1><p>Tiêu chuẩn HTML rất linh động và cho phép khai báo bất kỳ thẻ nào ta muốn. Nếu trình duyệt không thể nhận ra thẻ đó thì nó sẽ được parse dưới dạng HTMLUnknownElement.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'thisElementIsUnknown'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (element <span class="keyword">instanceof</span> HTMLUnknownElement) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The selected element is unknown'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tuy nhiên, điều này lại không áp dụng với custom element. Bạn có nhớ khi chúng ta bàn về việc có 1 số quy tắc đặt tên để định nghĩa custom element? Lý do là nếu như trình duyệt nhận ra tên <strong>hợp lệ</strong> cho 1 custom element thì nó sẽ parse nó dưới dạng HTMLElement và trình duyệt cân nhắc để trở thành custom element chưa định nghĩa.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'this-element-is-undefined'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (element <span class="keyword">instanceof</span> HTMLElement) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The selected element is undefined but not unknown'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mặc dù không có sự khác biệt nào có thể nhìn bằng mắt thường giữa HTMLElement và HTMLUnknownElement nhưng cũng có vài thứ mà ta cần phải nhớ. Parser sẽ đối xử với chúng khác nhau. Nếu một element có cái tên hợp lệ (theo kiểu custom element như đã nói ở trên) thì sẽ được kiểm tra xem nó có phần triển khai nào cho custom element không. Nó sẽ được đối xử như 1 div bình thường cho tới khi phần triển khai đó được định nghĩa. Ngược lại element chưa định nghĩa thì không triển khai bất kỳ phương thức hay property nào.</p><h1 id="Ho-tro-tu-trinh-duyet"><a href="#Ho-tro-tu-trinh-duyet" class="headerlink" title="Hỗ trợ từ trình duyệt"></a>Hỗ trợ từ trình duyệt</h1><p>Phiên bản đầu tiên của custom element được giới thiệu trong Chrome 36+. Cái gọi là API v0 của custom element mà giờ đây đã không dùng nữa và cân nhắc rằng đó là những yếu kém mặc dù vẫn đang tồn tại. Nếu bạn muốn tìm hiểu về v0 thì có thể đọc <a href="https://www.html5rocks.com/en/tutorials/webcomponents/customelements/" target="_blank" rel="noopener">bài viết ở đây</a>. API v1 của custom element xuất hiện kể từ Chrome 54 và Safari 10.1 (chỉ có 1 phần). Microsoft Edge thì đang trong giai đoạn thử mẫu và Mozilla đã có từ v50 những không được kích hoạt sẵn và cần người dùng tự kích hoạt nó. Hiện tại chỉ có các trình duyệt webkit mới hỗ trợ hoàn toàn. Tuy nhiên như đã nhắc ở trên, có các polyfill tồn tại cho phép bạn dùng custom element trên tất cả các trình duyệt, kể cả IE11.</p><h1 id="Kiem-tra-tinh-kha-dung"><a href="#Kiem-tra-tinh-kha-dung" class="headerlink" title="Kiểm tra tính khả dụng"></a>Kiểm tra tính khả dụng</h1><p>Để đảm bảo trình duyệt có hỗ trợ custom element bạn có thể làm là thực hiện 1 bài kiểm tra nhỏ để xem property customElements có tồn tại trong object window hay không:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> supportsCustomElements = <span class="string">'customElements'</span> <span class="keyword">in</span> <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (supportsCustomElements) &#123;</span><br><span class="line">  <span class="comment">// Bạn có thể dùng API Custom elements ở đây</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hoặc nếu ta dùng thư viện polifyll:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line"></span><br><span class="line">    script.src = src;</span><br><span class="line">    script.onload = resolve;</span><br><span class="line">    script.onerror = reject;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Chạy lazy load cho polyfill nếu cần thiết</span></span><br><span class="line"><span class="keyword">if</span> (supportsCustomElements) &#123;</span><br><span class="line">  <span class="comment">// Trình duyệt hỗ trợ sẵn cho custom element. Bạn có thể dùng bình thường.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  loadScript(<span class="string">'path/to/custom-elements.min.js'</span>).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Polyfill cho custom element đã được kích hoạt. Bạn có thể dùng bình thường.</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vậy nói gọn gọn lại, 1 phần của tiêu chuẩn web component là custom element cho bạn các khả năng sau:</p><ul><li>Liên kết Javascript và CSS với HTML element</li><li>Cho phép bạn mở rộng các element HTML sẵn có (cả element gốc và custom element)</li><li>Không cần thư viện hay framework ngoài. Bạn chỉ cần Javascript, HTML và CSS gốc và có thể cần thêm thư viện polyfill để hỗ trợ trình duyệt cũ.</li><li>Nó được xây dựng để hoạt động trơn tru, mượt mà với các tính năng khác của web component (shadow DOM, template, slots, vân vân)</li><li>Liên kết chặt chẽ với công cụ dev của trình duyệt.</li><li>Tận dụng các tính năng tiếp cận sẵn có.</li></ul><p>Custom element không khác với những thứ chúng ta đã dùng bấy lâu nay. Nó chỉ là 1 cách khác để làm cho mọi việc dễ dàng hơn khi phát triển webapp. Nó mở ra cánh cổng đến với việc xây dựng những app phức tạp với tốc độ nhanh. Tuy nhiên càng phức tạp thì càng có nhiều khả năng có lỗi mà khó tìm hiểu hoặc tái lập. Vì thế khi debug ta cần nhiều ngữ cảnh và công cụ như SessionStack để hỗ trợ.</p><p>SessionStack tích hợp vào trong webapp và bắt đầu thu thập các thông tin như sự kiện người dùng, dữ liệu mạng, biệt lệ, thông báo debug, thay đổi trên DOM, vân vân, và gửi chúng về server của họ.</p><p>Sau đó, dữ liệu thu được sẽ được xử lý để tạo ra đoạn video trải nghiệm để bạn có thể xem user đã tương tác như thế nào với sản phẩm của bạn. Bên cạnh những thông tin kỹ thuật mà SessionStack đã cung cấp thì nó còn cho phép bạn khả năng để tái hiện lại các vấn đề mà bạn không bao giờ biết được khi debug trước đây.</p><p>Để đảm bảo cho SessionStack luôn luôn thực hiện được các phiên làm việc hoàn hảo đến từng pixel thì team của họ đã bám sát lấy những công nghệ, framework và tiêu chuẩn web tiên tiến cũng như mới nhất.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;Đây là bài cuối cùng trong series rồi (chắc vậy á, lâu nay không thấy họ đăng bài mới). Cảm ơn mọi người đã ủng hộ mình trong suốt thời gian qua. Tuy nhiên nếu SessionStack có bài viết nào mới thì mình sẽ cập nhật thêm.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Element: phần tử&lt;/li&gt;
&lt;li&gt;Custom element: phần tử tùy chọn (tức là những element do người dùng tự tạo ra)&lt;/li&gt;
&lt;li&gt;Component: thành phần&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Chào các bạn đến với bài thứ 19 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P18: WebRTC &amp; cơ chế mạng peer-to-peer</title>
    <link href="http://nthung2112.github.io/2019/01/Cach-Javascript-hoat-dong-P18-WebRTC-co-che-mang-peer-to-peer.html"/>
    <id>http://nthung2112.github.io/2019/01/Cach-Javascript-hoat-dong-P18-WebRTC-co-che-mang-peer-to-peer.html</id>
    <published>2019-01-05T17:00:00.000Z</published>
    <updated>2019-01-06T10:16:09.777Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>Thêm một bài nữa mang nặng kiến thức về mạng mà mình lại không chuyên về mảng này, nếu mình dịch chỗ nào không phù hợp thì nhờ mọi người giúp đỡ nhé @</em>@_</strong></p><ul><li><strong>Peer-To-Peer hay P2P</strong>: Mạng ngang hàng</li><li><strong>Real-time</strong>: thời gian thực</li></ul><p>Chào các bạn đến với bài thứ 18 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.<br><a id="more"></a></p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Đầu tiên thì WebRTC là cái gì vậy? Nó là viết tắt của chữ <strong>R</strong>eal <strong>T</strong>ime <strong>C</strong>ommunication (Giao tiếp thời gian thực), nghe qua chắc bạn cũng đã có cái gì sơ sơ về công nghệ này rồi nhỉ.</p><p>WebRTC lấp đầy 1 khoảng trống lớn trong nền tảng web. Trước đây, các công nghệ P2P chẳng hạn như những app chat trên desktop có thể làm những việc mà web không làm được. Nhưng WebRTC đã thay đổi điều đó.</p><p>Về cơ bản WebRTC cho phép webapp có thể thiết lập giao tiếp Peer-To-Peer, chính là nội dung trong bài viết này. Ta sẽ thảo luận về các chủ đề sau đây để có thể mang đến cho bạn 1 cái nhìn toàn cảnh về “ruột gan phèo phổi” của WebRTC:</p><ul><li>Giao tiếp Peer-To-Peer</li><li>Tường lửa và NAT Traversal</li><li>Tín hiệu (Signaling), Phiên (Session), Giao thức (Protocol)</li><li>Các API của WebRTC</li></ul><h1 id="Giao-tiep-Peer-To-Peer"><a href="#Giao-tiep-Peer-To-Peer" class="headerlink" title="Giao tiếp Peer-To-Peer"></a>Giao tiếp Peer-To-Peer</h1><p>Để có thể giao tiếp lẫn nhau thông qua trình duyệt web, mỗi trình duyệt của user phải thực hiện những bước sau đây:</p><ul><li>Đồng ý để bắt đầu giao tiếp</li><li>Biết cách xác định vị trí của đối tượng</li><li>Vượt qua an ninh và tưởng lửa bảo vệ</li><li>Chuyển giao tất cả các giao tiếp đa phương tiện theo real-time</li></ul><p>1 trong số những thách thức lớn nhất liên quan đến các giao tiếp P2P dựa trên trình duyệt là làm sao để biết vị trí &amp; thiết lập 1 kết nối socket mạng (network socket connection) với 1 trình duyệt khác để vận chuyển dữ liệu 2 chiều. Ta sẽ xem xét những khó khăn liên quan đến việc thiết lập kết nối này.</p><p>Khi webapp của bạn cần dữ liệu hoặc tài nguyên, nó sẽ lấy về từ các server. Tuy nhiên, nếu bạn muốn tạo ra 1 ứng dụng video chat chẳng hạn, bằng cách kết nối trực tiếp đến trình duyệt của người khác - thì đây là vấn đề, vì bạn không biết địa chỉ bởi vì trình duyệt của người kia không phải là 1 web server. Vì vậy để có thể thiết lập 1 kết nối P2P ta cần rất nhiều thứ.</p><h1 id="Tuong-lua-va-NAT-Traversal"><a href="#Tuong-lua-va-NAT-Traversal" class="headerlink" title="Tường lửa và NAT Traversal"></a>Tường lửa và NAT Traversal</h1><p>Thường thì máy tính của bạn không không có địa chỉ IP public tĩnh. Lý do là máy tính của bạn phải núp đằng sau tường lửa và thiết bị NAT (Network access translation - Bộ phiên dịch truy cập mạng).</p><p>Thiết bị NAT sẽ dịch địa chỉ IP cá nhân từ bên trong tường lửa thành địa chỉ IP công khai (public-facing IP). Ta cần các thiết bị NAT để bảo mật và giải quyết sự giới hạn của IPv4 đối với những địa chỉ IP công khai sẵn có. Đó là lý do tại sao webapp không nên giả định rằng thiết bị hiện tại có 1 địa chỉ IP public tĩnh.</p><p>Cùng tìm hiểu 1 chút về cách hoạt động của các thiết bị NAT. Nếu như bạn đang ở trong môi trường công cộng và kết nối vào mạng WiFi, máy tính của bạn sẽ được gán 1 địa chỉ IP mà nó chỉ tồn tại đằng sau NAT. Giả sử IP là 172.0.23.4, tuy nhiên, với thế giới bên ngoài, địa chỉ IP của bạn có thể mang giá trị khác, ví dụ 164.53.27.98. Vì vậy, thế giới bên ngoài sẽ thấy các request của bạn đến từ địa chỉ 164.53.27.98 nhưng thiết bị NAT sẽ đảm bảo các response cho những request (được gửi từ máy của bạn) sẽ trả về đúng chỗ là 172.0.23.4. Ơn trời các bảng ánh xạ (mapping table). Lưu ý rằng ngoài địa chỉ IP thì cổng (port) cũng là điều kiện cần thiết cho các giao tiếp mạng.</p><p>Do có sự tham gia của các thiết bị NAT, trình duyệt của bạn cần tìm được địa chỉ IP của máy tính có trình duyệt mà bạn muốn giao tiếp.</p><p>Đến đây thì ta lại phải nhờ đến các server <strong>STUN</strong> (<strong>S</strong>ession <strong>T</strong>raversal <strong>U</strong>tilities for <strong>N</strong>AT - Tiện ích truyền tải theo phiên cho NAT) và <strong>TURN</strong> (<strong>T</strong>raversal <strong>U</strong>sing <strong>R</strong>elays around <strong>N</strong>AT - Truyền tải sử dụng điểm chuyển tiếp vòng quanh NAT). Để các công nghệ WebRTC hoạt động được, đầu tiên thì 1 request hỏi địa chỉ IP public của bạn sẽ được gửi đến server STUN. Bạn cứ nghĩ theo hướng kiểu như máy tính đang tạo truy vấn đến 1 server từ xa để hỏi về địa chỉ IP mà server đó nhận câu truy vấn là bao nhiêu. Server từ xa sẽ trả về địa chỉ IP mà nó thấy. Nói ngắn gọn là máy tính của bạn “hỏi” 1 server từ xa địa chỉ IP của chính máy bạn là bao nhiêu.</p><p>Giả sử tiến trình này hoạt động bình thường và bạn nhận được địa chỉ IP public của mình cũng như số port, bạn sẽ có thể nói với những peer ngang hàng khác làm thế nào để kết nối trực tiếp đến bạn. Những peer này cũng có thể làm cùng 1 việc là sử dụng STUN &amp; server TURN và nói cho bạn biết nên liên lạc đến địa chỉ nào.</p><h1 id="Signaling-Sessions-Protocols"><a href="#Signaling-Sessions-Protocols" class="headerlink" title="Signaling, Sessions, Protocols"></a>Signaling, Sessions, Protocols</h1><p><strong><em>Tín hiệu, phiên, giao thức</em></strong></p><p>Quá trình khám phá thông tin mạng được mô tả ở trên chỉ là 1 phần của chủ đề về Signaling to bự hơn nhiều, trong trường hợp của WebRTC thì phần signaling này dựa trên 1 chuẩn JSEP (<strong>J</strong>avascript <strong>S</strong>ession <strong>E</strong>stablishment <strong>P</strong>rotocol - Giao thức thiết lập phiên của Javascript). Signaling bao gồm cả khám phá mạng (network discovery) và NAT Traversal, tạo và quản lý phiên, bảo mật giao tiếp, siêu dữ liệu (metadata) và phối hợp khả năng của media, xử lý lỗi.</p><p>Để kết nối có thể hoạt động, peer thu được những điều kiện về local media cho metadata (ví dụ: những khả năng về kích thước và kiểu codec) và gom góp các địa chỉ mạng có thể có cho host của ứng dụng. Cơ chế signaling dùng để truyền tới/lui những thông tin quan trọng này không được định nghĩa trong API của WebRTC.</p><p>Signaling không được quy định bởi chuẩn WebRTC và nó không được triển khai bằng API của nó để cho phép sử dụng một cách linh động các công nghệ và giao thức cần thiết. Các WebRTC developer sẽ đối phó với signaling và server xử lý signaling.</p><p>Giả sử app WebRTC dựa trên trình duyệt của bạn có thể xác định được địa chỉ IP public của nó bằng cách sử dụng STUN như đã nói ở trên, bước tiếp theo thực sự là 1 màn đàm phán &amp; thiết lập phiên kết nối đến với peer.</p><p>Phần đàm phán và thiết lập khởi tạo phiên xảy ra khi dùng 1 giao thức signaling/giao tiếp được đặc tả trong các giao tiếp đa phương tiện. Giao thức này cũng chịu trách nhiệm cho việc điều hành các quy định trong đó phiên được quản lý và hủy bỏ.</p><p>Một trong số các giao thức như vậy có tên là <strong>S</strong>ession <strong>I</strong>nitiation <strong>P</strong>rotocol (SIP - Giao thức khởi tạo phiên). Lưu ý rằng do sự linh động của WebRTC signaling, SIP không phải là giao thức signaling duy nhất có thể dùng. Giao thức signaling được chọn phải hoạt động với 1 giao thức ở tầng ứng dụng gọi là <strong>S</strong>ession <strong>D</strong>escription <strong>P</strong>rotocol (SDP - Giao thức mô tả phiên), giao thức này được sử dụng trong trường hợp của WebRTC. Tất cả các metadata đa phương tiện cụ thể được truyền đi bằng giao thức SDP này.</p><p>Bất kỳ peer nào (ví dụ: app tận dụng WebRTC) thử giao tiếp với 1 peer khác đều sinh ra 1 tập các ứng viên giao thức Interactive Connectivity Establishment (ICE - Thiết lập kết nối tương tác). Những ứng viên này biểu diễn 1 bộ kết hợp của địa chỉ IP, port, giao thức giao vận được dùng. Lưu ý rằng 1 máy tính có thể có nhiều giao diện mạng (không dây, có dây, vân vân), vì thế có thể được gán nhiều địa chỉ IP cho mỗi giao diện.</p><p>Dưới đây là sơ đồ lấy từ MDN mô tả lại sự trao đổi:<br><img src="https://cdn-images-1.medium.com/max/1000/0*SXRTlnVxy2-hE9ZX" alt=""></p><h1 id="Thiet-lap-ket-noi"><a href="#Thiet-lap-ket-noi" class="headerlink" title="Thiết lập kết nối"></a>Thiết lập kết nối</h1><p>Mỗi peer đầu tiên phải thiết lập địa chỉ IP public như đã nói ở trên. “Kênh” (channel) dữ liệu signaling sau đó được tự động tạo ra để xác định các peer và hỗ trợ đàm phán peer-to-peer và thiết lập phiên.</p><p>Thế giới bên ngoài hoàn toàn không biết hoặc không thể truy xuất đến những “kênh” này và nó cũng yêu cầu 1 định danh duy nhất nếu muốn truy cập.</p><p>Lưu ý rằng, do sự linh động của WebRTC và cũng bởi tiến trình signaling không được cụ thể hóa trong các tiêu chuẩn, ý tưởng và cách thực hiện của “kênh” có thể sẽ có ít nhiều khác biệt tuy vào công nghệ sử dụng. Rõ ràng, 1 vài giao thức không cần đến cơ chế “kênh” mà vãn giao tiếp được.</p><p>Chúng ta sẽ giả sử rằng “kênh” được dùng trong việc triển khai cho các mục đích được nhắc tới ở bài viết này.</p><p>Một khi 2 hoặc nhiều peer đã cùng kết nối vào 1 “kênh” thì những peer đã có thể giao tiếp và trao đổi thông tin phiên. Tiến trình này về mặt nào đó thì tương tự như <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" target="_blank" rel="noopener">mô hình publish/subscribe</a>. Về cơ bản, peer khởi tạo ban đầu sẽ gửi 1 “lời đề nghị” sử dụng 1 giao thức signaling chẳng hạn như Session Initiation Protocol (SIP - Giao thức khởi tạo phiên) và SDP. Người khởi tạo sẽ chờ để nhận được “câu trả lời” từ bất kỳ người nhận nào đã kết nối với “kênh”.</p><p>Khi đã nhận được câu trả lời, 1 tiến trình diễn ra để xác định và trao đổi giao thức ứng viên ICE tốt nhất (Interactive Connectivity Establishment - Thiết lập kết nối tương tác) mà mỗi peer thu thập được. Một khi chọn được ứng viên ICE tối ưu thì về cơ bản sẽ có nhiều thứ theo sau đó được chấp nhận, bao gồm: những metadata cần thiết, các định tuyến mạng (địa chỉ IP và port) và các thông tin media thường dùng để giao tiếp với mỗi peer. Phiên mạng socket mạng giữa những peer sau đó được thiết lập hoàn chỉnh và kích hoạt. Tiếp đó, các luồng dữ liệu local và các endpoint kênh dữ liệu được tạo ra bởi mỗi peer, dữ liệu đa phương tiện cuối cùng được chuyển đi theo cả 2 đường sử dụng bất kỳ công nghệ giao tiếp 2 chiều nào.</p><p>Nếu như tiến trình đồng ý chấp nhận ứng viên ICE tốt nhất bị thất bại, thỉnh thoảng nguyên nhân là do tường lửa hoặc kỹ thuật NAT đang dùng, thì giải pháp dự phòng sau đó là sử dụng 1 server TURN dưới dạng 1 điểm chuyển tiếp thay thế. Tiến trình này về cơ bản sẽ dùng 1 server hoạt động như người trung gian và nó chuyển tiếp bất kỳ dữ liệu nào truyền qua lại giữa các peer. Lưu ý rằng đây không phải là giao tiếp peer-to-peer thực thụ trong đó các peer truyền dữ liệu 2 chiều trực tiếp đến với nhau.</p><p>Khi sử dụng giải pháp dự phòng TURN để giao tiếp, mỗi peer sẽ không cần phải biết làm thế nào để liên lạc và truyền dữ liệu đến bên kia. Thay vào đó, nó cần biết server TURN public nào để gửi và nhận dữ liệu đa phương tiện theo thời gian thực xuyên suốt phiên giao tiếp.</p><p>Điều quan trọng cần phải hiểu rằng đây chắc chẳn là 1 dạng “kế hoạch dự phòng” và chỉ dùng khi không còn cách nào khác. Các server TURN phải khá vững chắc, có băng thông rộng, khả năng xử lý và có thể xử lý 1 lượng lớn dữ liệu tiềm tàng. Cách sử dụng server TURN vì thế rõ ràng là sẽ phát sinh thêm chi phí và sự phức tạp.</p><h1 id="Cac-API-cua-WebRTC"><a href="#Cac-API-cua-WebRTC" class="headerlink" title="Các API của WebRTC"></a>Các API của WebRTC</h1><p>Có 3 mục phân loại API chính trong WebRTC:</p><ul><li><strong>Media Capture and Streams</strong> (luồng media và chụp media) - cho phép bạn truy xuất vào các thiết bị đầu vào, chẳng hạn như microphone hay web camera. API cho phép bạn lấy 1 luồng media từ các thiết bị đó.</li><li><strong>RTCPeerConnection</strong> - dùng những API này, bạn có thể gửi theo thời gian thực 1 luồng âm thanh &amp; hình ảnh đã bắt được thông qua internet đến 1 endpoint WebRTC khác. Bạn có thể tạo ra kết nối giữa máy local và peer từ xa. Nó cũng cung cấp các phương thức để kết nối đến 1 peer từ xa, duy trì và kiểm soát kết nối &amp; đóng kết nối 1 khi ta không cần đến nó nữa.</li><li><strong>RTCDataChannel</strong> - API này cho phép bạn truyền dữ liệu tùy ý. Mỗi kênh dữ liệu được liên kết với 1 RTCPeerConnection.</li></ul><p>Chúng ta sẽ đi sâu vào thảo luận mỗi loại trên.</p><h2 id="Media-Capture-amp-Streams"><a href="#Media-Capture-amp-Streams" class="headerlink" title="Media Capture &amp; Streams"></a>Media Capture &amp; Streams</h2><p>API <strong>Media Capture &amp; Streams</strong>, thường được gọi là <em>Media Stream API</em> hoặc <em>Stream API</em>, là 1 API hỗ trợ những luồng (stream) dữ liệu âm thanh hay hình ảnh, các phương thức để làm việc với chúng, những hạn chế liên kết với từng loại dữ liệu, callback thành công/thất bại khi sử dụng dữ liệu bất đồng bộ và những sự kiện được bắn ra suốt quá trình.</p><p>Phương thức getUserMedia() của <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices" target="_blank" rel="noopener">MediaDevices</a> nhắc nhở người dùng cấp quyền để sử dụng đầu vào media, nó tạo ra 1 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream" target="_blank" rel="noopener">MediaStream</a> kèm với các track chứa kiểu request của media. Luồng đó có thể chứa 1 track video (được tạo ra bởi phần cứng hay nguồn video ảo chẳng hạn như camera, thiết bị ghi video, dịch vụ chia sẻ màn hình, vân vân), 1 track audio (tương tự, được tạo ra bởi nguồn ghi vật lý hoặc nguồn ghi ảo như microphone, bộ chuyển A/D…) và có thể có cả những loại track khác.</p><p>Nó sẽ trả về 1 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a> và resolve thành object <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream" target="_blank" rel="noopener">MediaStream</a>. Nếu người dùng từ chối cấp quyền hoặc là media phù hợp không tồn tại thì promise đó sẽ bị reject với PermissionDeniedError hoặc NotFoundError.</p><p>Mô hình singleton MediaDevice có thể được truy xuất thông qua object navigator như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">navigator.mediaDevices.getUserMedia(constraints)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line"> <span class="comment">/* use the stream */</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"> <span class="comment">/* handle the error */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Lưu ý là bạn cần truyền object constraints để nói cho API loại stream nào để trả về. Bạn có thể cấu hình tất cả những thứ linh tinh liên quan, bao gồm cả camera mà bạn dùng (camera trước/sau), tần suất khung hình, độ phân giải, vân vân.</p><p>Kể từ phiên bản 25, các trình duyệt dựa trên nhân Chromium cho phép dữ liệu âm thanh từ getUserMedia() có thể được truyền đến element audio hoặc video (nhưng lưu ý rằng mặc định thì các media element bị tắt tiếng (mute))</p><p>getUserMedia còn có thể được dùng như 1 <a href="http://updates.html5rocks.com/2012/09/Live-Web-Audio-Input-Enabled" target="_blank" rel="noopener">node đầu vào cho Web Audio API</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gotStream</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.AudioContext = <span class="built_in">window</span>.AudioContext || <span class="built_in">window</span>.webkitAudioContext;</span><br><span class="line">    <span class="keyword">var</span> audioContext = <span class="keyword">new</span> AudioContext();</span><br><span class="line">    <span class="comment">// Tạo AudioNode từ stream</span></span><br><span class="line">    <span class="keyword">var</span> mediaStreamSource = audioContext.createMediaStreamSource(stream);</span><br><span class="line">    <span class="comment">// Kết nối nó đến điểm đích để nghe bạn </span></span><br><span class="line">    <span class="comment">// hoặc bất kỳ node nào khác đang xử lý</span></span><br><span class="line">    mediaStreamSource.connect(audioContext.destination);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">navigator.getUserMedia(&#123;<span class="attr">audio</span>:<span class="literal">true</span>&#125;, gotStream);</span><br></pre></td></tr></table></figure><h3 id="Gioi-han-ve-su-rieng-tu"><a href="#Gioi-han-ve-su-rieng-tu" class="headerlink" title="Giới hạn về sự riêng tư"></a>Giới hạn về sự riêng tư</h3><p>Là 1 API có thể chứa nhiều điều lo ngại đáng kể về quyền riêng tư, getUserMedia() được tổ chức bởi các đặc điểm kỹ thuật với những yêu cầu rất cụ thể về thông báo người dùng và quản lý quyền truy cập. getUserMedia() phải luôn luôn xin quyền từ người dùng trước khi mở bất kỳ thiết bị thu thập thông tin media nào chẳng hạn như webcam hay microphone. Trình duyệt có thể có tính năng cấp quyền trên mỗi domain (once-per-domain), nhưng nó phải hỏi bạn ít nhất là lần đầu tiên hoạt động và người dùng phải đặc biệt cấp quyền tiếp theo nếu họ muốn.</p><p>Một điều quan trọng tương đương là các quy định xung quanh thông báo (notification). Trình duyệt được yêu cầu phải hiển thị 1 thông số thể hiện camera hoặc microphone đang hoạt động, hơn hết thảy bất kỳ thông số thể hiện phần cứng nào khác. Họ cũng phải hiện 1 chỉ số cho thấy rằng quyền được được cấp để sử dụng thiết bị đầu vào, kể cả nếu như thiết bị đó chưa được kích hoạt để ghi chép tại thời điểm đó.</p><h1 id="RTCPeerConnection"><a href="#RTCPeerConnection" class="headerlink" title="RTCPeerConnection"></a>RTCPeerConnection</h1><p>Giao diện <strong>RTCPeerConnection</strong> thể hiện 1 kết nối WebRTC giữa máy tính local và peer từ xa. Nó cung cấp các phương thức để kết nối đến peer từ xa, duy trì, kiểm soát kết nối và ngắt kết nối một khi nó không cần dùng tới nữa.</p><p>Dưới đây là 1 mô hình kiến trúc của WebRTC thể hiện vai trò của RTCPeerConnection:<br><img src="https://cdn-images-1.medium.com/max/1000/0*Nm9r_NLcAhJernmo" alt=""></p><p>Từ góc độ của Javascript, điều cần hiểu trong mô hình trên là <strong>RTCPeerConnection</strong> trao cho các web developer một cái nhìn tinh tế từ những sự phức tạp xuất phát từ đống “nội tạng” rối rắm bên dưới. Các mã codec và giao thức được dùng bởi WebRTC thực hiện 1 lượng lớn công việc dể làm cho giao tiếp real-time hoạt động được, kể cả với các mạng không đáng tin cậy:</p><ul><li>Che dấu mất gói tin (Package loss concealment - PLC, là 1 kỹ thuật dùng để che đậy ảnh hưởng của tình trạng mất gói tin trong giao tiếp VoIP)</li><li>Hủy bỏ phản hồi (Echo cancellation - trong mạng máy tính thì “echo” được hiểu là quá trình gửi trả về gói tin đã gửi đi)</li><li>Khả năng thích ứng băng thông</li><li>Bộ đệm jitter động (jitter buffer - Trong kỹ thuật VoIP thì jitter buffer là vùng dữ liệu chia sẻ nơi mà các gói tin âm thanh có thể được thu thập, lưu trữ và gửi đi đến bộ xử lý âm thanh)</li><li>Tự động chiếm quyền kiểm soát</li><li>Giảm nhiễu và xóa nhiễu</li><li>“Dọn dẹp” hình ảnh</li></ul><h1 id="RTCDataChannel"><a href="#RTCDataChannel" class="headerlink" title="RTCDataChannel"></a>RTCDataChannel</h1><p>Cũng như hình ảnh và âm thanh, WebRTC cũng hỗ trợ giao tiếp real-time cho các loại dữ liệu khác.</p><p>API RTCDataChannel cho phép peer-to-peer trao đổi các dữ liệu tùy ý.</p><p>Có rất nhiều trường hợp sử dụng API này, ví dụ:</p><ul><li>Dùng trong các game</li><li>Ứng dụng chat real-time</li><li>Truyền file</li><li>Các mạng phi tập trung</li></ul><p>API cũng có nhiều tính năng để tận dụng tối đa RTCPeerConnection và kích hoạt sức mạnh cũng như sự linh động của giao tiếp peer-to-peer:</p><ul><li>Tận dụng cài đặt phiên của RTCPeerConnection</li><li>Đa kênh đồng thời với khả năng phân chia mức độ ưu tiên</li><li>Ngữ cảnh vận chuyển đáng tin cậy và không đáng tin cậy.</li><li>Tích hợp sẵn bảo mật (DTLS) và kiểm soát tắc nghẽn.</li></ul><p>Cú pháp tương tự như WebSocket mà ta đã biết, với phương thức send() và sự kiện message:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peerConnection = <span class="keyword">new</span> webkitRTCPeerConnection(servers,</span><br><span class="line">    &#123;<span class="attr">optional</span>: [&#123;<span class="attr">RtpDataChannels</span>: <span class="literal">true</span>&#125;]&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">peerConnection.ondatachannel = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    receiveChannel = event.channel;</span><br><span class="line">    receiveChannel.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">"#receiver"</span>).innerHTML = event.data;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sendChannel = peerConnection.createDataChannel(<span class="string">"sendDataChannel"</span>, &#123;<span class="attr">reliable</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"button#send"</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">document</span>.querySelector(<span class="string">"textarea#send"</span>).value;</span><br><span class="line">    sendChannel.send(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Sự giao tiếp diễn ra trực tiếp giữa các trình duyệt, vì thế RTCDataChannel có thể nhanh hơn nhiều so với WebSocket kể cả khi cần đến 1 server chuyển tiếp (TURN).</p><h1 id="WebRTC-trong-the-gioi-thuc"><a href="#WebRTC-trong-the-gioi-thuc" class="headerlink" title="WebRTC trong thế giới thực"></a>WebRTC trong thế giới thực</h1><p>Trong thế giới thực thì WebRTC cần có server, tuy nhiên thực tế lại đơn giản hơn:</p><ul><li>Các user tự khám phá ra đối tác của họ và trao đổi các chi tiết chẳng hạn như tên.</li><li>Các ứng dụng WebRTC phía client (các peer) trao đổi thông tin mạng.</li><li>Các peer trao đổi dữ liệu về media chẳng hạn như định dạng hình ảnh và độ phân giải.</li><li>Các ứng dụng WebRTC phía client di chuyển xuyên qua các <a href="http://en.wikipedia.org/wiki/NAT_traversal" target="_blank" rel="noopener">cổng NAT</a> và tường lửa.</li></ul><p>Nói cách khác, WebRTC cần phải có 4 tính năng ở phía server:</p><ul><li>User khám phá ra và giao tiếp.</li><li>Signaling</li><li>Di chuyển NAT/tường lửa</li><li>Các server chuyển tiếp trong trường hợp giao tiếp peer-to-peer thất bại.</li></ul><p>Giao thức <a href="http://en.wikipedia.org/wiki/STUN" target="_blank" rel="noopener">STUN</a> và bản mở rộng <a href="http://en.wikipedia.org/wiki/Traversal_Using_Relay_NAT" target="_blank" rel="noopener">TURN</a> của nó được dùng bởi <a href="http://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment" target="_blank" rel="noopener">ICE</a> để kích hoạt RTCPeerConnection nhằm đối phó với di chuyển NAT và các thay đổi mạng mơ hồ khác.</p><p>Như đã nhắc đến trước đó, ICE là 1 giao thức để kết nối các peer, chẳng hạn như 2 ứng dụng video chat client. Khi khởi tạo, ICE sẽ thử kết nối trực tiếp đến các peer với độ trễ thấp nhất có thể thông qua UDP. Trong tiến trình này, các server STUN có 1 tác vụ duy nhất: kích hoạt 1 peer phía sau NAT để tìm địa chỉ public &amp; số port. Bạn có thể kiểm tra các server STUN đang tồn tại ở danh sách này (Google cũng có 1 số server)</p><p>|  | # source : <a href="http://code.google.com/p/natvpn/source/browse/trunk/stun_server_list" target="_blank" rel="noopener">http://code.google.com/p/natvpn/source/browse/trunk/stun_server_list</a> |<br>|  | # A list of available STUN server. |<br>|  |  |<br>|  | stun.l.google.com:19302 |<br>|  | stun1.l.google.com:19302 |<br>|  | stun2.l.google.com:19302 |<br>|  | stun3.l.google.com:19302 |<br>|  | stun4.l.google.com:19302 |<br>|  | stun01.sipphone.com |<br>|  | stun.ekiga.net |<br>|  | stun.fwdnet.net |<br>|  | stun.ideasip.com |<br>|  | stun.iptel.org |<br>|  | stun.rixtelecom.se |<br>|  | stun.schlund.de |<br>|  | stunserver.org |<br>|  | stun.softjoys.com |<br>|  | stun.voiparound.com |<br>|  | stun.voipbuster.com |<br>|  | stun.voipstunt.com |<br>|  | stun.voxgratia.org |<br>|  | stun.xten.com |</p><p><a href="https://gist.github.com/zziuni/3741933/raw/212e4b6316110dc5c128d08f65ff8f174d7ae383/stuns" target="_blank" rel="noopener">view raw</a> <a href="https://gist.github.com/zziuni/3741933#file-stuns" target="_blank" rel="noopener">stuns</a> hosted with ❤ by <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>.<br><img src="https://cdn-images-1.medium.com/max/1000/1*ONNxJHqmMTXB1Nuq3qTNXQ.png" alt=""></p><h2 id="Tim-nhung-ung-vien-ket-noi"><a href="#Tim-nhung-ung-vien-ket-noi" class="headerlink" title="Tìm những ứng viên kết nối"></a>Tìm những ứng viên kết nối</h2><p>Nếu như UDP thất bại, ICE sẽ thử TCP: đầu tiên là HTTP, sau đó là HTTPS. Nếu kết nối trực tiếp thất bại - cụ thể là bởi vì dịch chuyển NAT &amp; tường lửa mức độ doanh nghiệp - ICE sẽ dùng 1 server TURN trung gian (điểm chuyển tiếp). Nói cách khác, ICE đầu tiên sẽ dùng STUN với UDP để kết nối trực tiếp các peer với nhau, nếu thất bại, nó sẽ đổi kế hoạch sang dùng server chuyển tiếp TURN. Cụm từ “tìm kiếm ứng viên” nhắc đến quá trình tìm kiếm các giao diện mạng &amp; port.<br><img src="https://cdn-images-1.medium.com/max/1000/1*0REL14sYPR34hY7yua6-PA.png" alt=""></p><h1 id="Bao-mat"><a href="#Bao-mat" class="headerlink" title="Bảo mật"></a>Bảo mật</h1><p>Có rất nhiều cách mà 1 ứng dụng hoặc plugin giao tiếp real-time có thể bị ảnh hưởng về bảo mật. Ví dụ:</p><ul><li>Dữ liệu hoặc media không được mã hóa có thể bị chặn trên đường đi giữa các trình duyệt hay giữa trình duyệt và server</li><li>Một ứng dụng có thể ghi chép và phân phối âm thanh, hình ảnh mà user hoàn toàn không biết</li><li>Malware hoặc virus máy tính có thể được cài đặt cùng với 1 ứng dụng hoặc plugin vớ vẩn.</li></ul><p>WebRTC có nhiều tính năng để tránh các vấn đề trên:</p><ul><li>WebRTC triển khai sử dụng các giao thức bảo mật chẳng hạn như <a href="http://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security" target="_blank" rel="noopener">DTLS</a> và <a href="http://en.wikipedia.org/wiki/Secure_Real-time_Transport_Protocol" target="_blank" rel="noopener">SRTP</a></li><li>Mã hóa là điều cần thiết đối với tất cả các component của WebRTC, bao gồm cả cơ chế signaling.</li><li>WebRTC không phải là 1 plugin: các component của nó chạy trong sandbox của trình duyệt và không chạy ở luồng riêng, các component không yêu cầu cài đặt riêng lẻ và được cập nhật mỗi khi trình duyệt được cập nhật.</li><li>Truy xuất camera và microphone phải được cấp quyền rõ ràng và khi camera hoặc microphone đang hoạt động thì phải được thể hiện ra ở phía giao diện người dùng.</li></ul><p>WebRTC là 1 công nghệ cực kỳ thú vị &amp; mạnh mẽ dành cho các sản phẩm cần làm việc với mô hình truyền tải real-time giữa các trình duyệt.</p><p>Ví dụ, ở SessionStack, họ cho phép user tích hợp thư viện Javascript của họ vào bên trong webapp của user. Nhiệm vụ của nó là bắt đầu thu thập các dữ liệu như sự kiện người dùng, thay đổi trên DOM, dữ liệu mạng, biệt lệ, thông báo debug, vân vân, và gửi chúng về cho server.</p><p>Trong khi đó, user của bạn có thể vào trong webapp của họ, mở 1 phiên làm việc bình thường và xem nó hoạt động theo thời gian thực. Sử dụng các dữ liệu thu thập được, SessionStack có thể tái tạo mọi thứ đã từng xảy ra trên trình duyệt của user, kết hợp các thông tin về hình ảnh thuần túy với 1 bộ giả lập console của trình duyệt và mọi thứ bên trong nó. Bạn cứ nghĩ nó giống như desktop từ xa nhưng không bắt người dùng cuối phải tải về bất cứ chương trình nào. Và trên hết tất cả các thông tin hình ảnh, bạn có thể thực sự thấy được các thông tin kỹ thuật lấy từ phiên.</p><p>Họ đã làm được tất cả điều đó thuần túy với các server, tuy nhiên sử dụng WebRTC họ có thể thật sự không cần phụ thuộc vào server nữa mà giao tiếp trực tiếp giữa các trình duyệt với nhau, giảm độ trễ và sức mạnh tính toán cần thiết.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;Thêm một bài nữa mang nặng kiến thức về mạng mà mình lại không chuyên về mảng này, nếu mình dịch chỗ nào không phù hợp thì nhờ mọi người giúp đỡ nhé @&lt;/em&gt;@_&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Peer-To-Peer hay P2P&lt;/strong&gt;: Mạng ngang hàng&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Real-time&lt;/strong&gt;: thời gian thực&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Chào các bạn đến với bài thứ 18 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P17: Bên trong Shadow DOM + xây dựng component khép kín</title>
    <link href="http://nthung2112.github.io/2019/01/Cach-Javascript-hoat-dong-P17-Ben-trong-Shadow-DOM-xay-dung-component-khep-kin.html"/>
    <id>http://nthung2112.github.io/2019/01/Cach-Javascript-hoat-dong-P17-Ben-trong-Shadow-DOM-xay-dung-component-khep-kin.html</id>
    <published>2019-01-05T16:50:00.000Z</published>
    <updated>2019-01-06T10:16:19.727Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>Trong bài có nhiều từ mình để nguyên mà không dịch nhé, vì dịch ra thì bay mất nghĩa @</em>@_</strong></p><ul><li><strong>element</strong>: phần tử</li><li><strong>custom element</strong>: phần tử tự tạo</li><li><strong>component</strong>: thành phần</li><li><strong>custom component</strong>: thành phần tự tạo</li><li><strong>markup</strong>: nói chung là ngôn ngữ đánh dấu, hay nói dễ hiểu hơn là code HTML (Hyper Text <strong>Markup</strong> Language)</li></ul><p>Chào các bạn đến với bài thứ 17 trong series khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.<br><a id="more"></a></p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Web Components (Thành phần web) là 1 bộ các công nghệ khác nhau cho phép ta tạo ra những custom element có thể tái sử dụng. Tính năng của chúng được đóng gói tách hoàn toàn khỏi code và bạn có thể dùng nó trong webapp của mình.</p><p>Có 4 loại Web Component tiêu chuẩn:</p><ul><li>Shadow DOM (Bóng của DOM)</li><li>HTML Templates (các mẫu HTML)</li><li>Custom elements (Các custom element)</li><li>HTML Imports</li></ul><p>Trong bài này ta sẽ tập trung vào <strong>Shadow DOM</strong></p><p>Shadow DOM được thiết kế như 1 công cụ dùng để xây dựng các app dựa trên component. Nó cung cấp các giải pháp cho các vấn đề chung trong ngành phát triển web mà bạn chắc chắn đã gặp qua:</p><ul><li><strong>Isolated DOM (DOM cô lập)</strong>: 1 DOM của component khép kín (ví dụ: document.querySelector() không trả về các node trong Shadow DOM của component). Điều này cũng làm đơn giản hóa các CSS Selector trong webapp của bạn bởi vì các DOM component đều bị cô lập, nó cho phép bạn khả năng sử dụng chung nhiều id/class mà không lo bị xung đột về cách đặt tên.</li><li><strong>Scoped CSS (CSS trong phạm vi)</strong>: CSS định nghĩa bên trong Shadow DOM chỉ có phạm vi trong nó. Các quy tắc về style không lọt ra ngoài và style của trang cũng không can thiệp vào nó.</li><li><strong>Composition (kết hợp)</strong>: Thiết kế 1 API khai báo, dựa trên markup cho component của bạn.</li></ul><h1 id="Shadow-DOM"><a href="#Shadow-DOM" class="headerlink" title="Shadow DOM"></a>Shadow DOM</h1><p>Bài viết này giả định rằng bạn đã quen thuộc với các khái niệm và API về DOM. Nếu bạn chưa rõ thì có thể đọc bài viết chi tiết về nó ở đây: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction</a></p><p>Shadow DOM cũng chỉ là 1 DOM bình thường, ngoại trừ 2 điều sau:</p><ul><li>Cách tạo ra/sử dụng trong mối quan hệ với toàn bộ trang so với cách mà bạn tạo/sử dụng DOM thường.</li><li>Cách tương tác của nó trong mối quan hệ với toàn bộ trang</li></ul><p>Một cách tổng quát, bạn tạo ra các node DOM và nối (append) chúng dưới dạng children vào element khác. Trong trường hợp của Shadow DOM, bạn tạo ra 1 cây DOM trong phạm vi (scoped DOM) và được kết nối vào element tuy nhiên nó tách biệt với children của chính nó. Cây con trong phạm vi này được gọi là <strong>shadow tree</strong>. Element mà nó nối vào được gọi là <strong>shadow host</strong>. Bất cứ thứ gì bạn thêm vào shadow tree trở thành 1 phần local của element chủ, bao gồm cả <code>&lt;style&gt;</code>. Đây là cách mà Shadow DOM có được phạm vi của CSS style.</p><h1 id="Tao-Shadow-DOM"><a href="#Tao-Shadow-DOM" class="headerlink" title="Tạo Shadow DOM"></a>Tạo Shadow DOM</h1><p>Một <strong>shadow root</strong> là 1 phần của document và được nối vào 1 element chủ (host element). Thời điểm bạn nối 1 shadow root chính là lúc element có được shadow DOM của nó. Để tạo shadow DOM cho 1 element, ta gọi element.attachShadow():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> header = <span class="built_in">document</span>.createElement(<span class="string">'header'</span>);</span><br><span class="line"><span class="keyword">var</span> shadowRoot = header.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'open'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> paragraphElement = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"></span><br><span class="line">paragraphElement.innerText = <span class="string">'Shadow DOM'</span>;</span><br><span class="line">shadowRoot.appendChild(paragraphElement);</span><br></pre></td></tr></table></figure><p>Phần <a href="http://w3c.github.io/webcomponents/spec/shadow/#h-methods" target="_blank" rel="noopener">thông số kỹ thuật</a> này định nghĩa 1 danh sách các element mà shadow tree <strong>không thể</strong> nối vào.</p><h1 id="Tinh-ket-hop-trong-Shadow-DOM"><a href="#Tinh-ket-hop-trong-Shadow-DOM" class="headerlink" title="Tính kết hợp trong Shadow DOM"></a>Tính kết hợp trong Shadow DOM</h1><p>Tính kết hợp là 1 trong số những tính năng quan trọng nhất của Shadow DOM.</p><p>Khi viết code HTML, “kết hợp” là cách mà bạn xây dựng webapp. Bạn kết nối và cài đặt các viên gạch khác nhau (còn gọi là các element) chẳng hạn như <code>&lt;div&gt;</code>, <code>&lt;header&gt;</code>, <code>&lt;form&gt;</code>, vân vân, để xây dựng UI cho webapp. Một số tag thậm chí có thể hoạt động với nhau.</p><p>Sự kết hợp định nghĩa tại sao các element như <code>&lt;select&gt;</code>, <code>&lt;form&gt;</code>, <code>&lt;video&gt;</code>… lại linh động và chấp nhận các element HTML cụ thể làm children của nó để thực hiện các công việc đặc biệt.</p><p>Ví dụ, <code>&lt;select&gt;</code> biết cách render các element <code>&lt;option&gt;</code> thành 1 danh sách dropdown với các item được định nghĩa trước.</p><p>Shadow DOM giới thiệu các tính năng sau mà từ đó ta có thể thực hiện tính “kết hợp”.</p><h1 id="Light-DOM-DOM-nhe"><a href="#Light-DOM-DOM-nhe" class="headerlink" title="Light DOM (DOM nhẹ)"></a>Light DOM (DOM nhẹ)</h1><p>Đây là đoạn markup mà user của component của bạn viết ra. DOM này tồn tại bên ngoài Shadow DOM của component. Nó là một children thực của element. Tưởng tượng rằng bạn đã tạo ra 1 custom component có tên <code>&lt;extended-button&gt;</code> có thể mở rộng button mặc định của HTML và bạn muốn thêm 1 bức hình, thêm vài đoạn text bên trong nó, thì dưới đây là những gì mà nó nên có:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">extended-button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- thẻ img và span là Light DOM của extended-button --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"boot.png"</span> <span class="attr">slot</span>=<span class="string">"image"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Launch<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">extended-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>extended-button là component tùy chọn mà bạn định nghĩa, đoạn HTML bên trong nó được gọi là <strong>Light DOM</strong> và được thêm vào bởi user của component của bạn.</p><p>Shadow DOM ở đây chính là component mà bạn đã tạo ra (tức là <code>&lt;extended-button&gt;</code>). Với component thì Shadow DOM là local, nó định nghĩa cho chính bản thân nó cấu trúc nội bộ, CSS trong phạm vi và đóng gói toàn bộ các chi tiết về triển khai.</p><h1 id="Flattened-DOM-tree-Cay-DOM-phang"><a href="#Flattened-DOM-tree-Cay-DOM-phang" class="headerlink" title="Flattened DOM tree (Cây DOM phẳng)"></a>Flattened DOM tree (Cây DOM phẳng)</h1><p>Kết quả của trình duyệt khi phân phối Light DOM - một sản phẩm được tạo ra bởi user và đặt vào trong Shadow DOM của bạn cùng với phần định nghĩa của custom component, sẽ render ra sản phẩm cuối cùng. Cây phẳng (flattened tree) là những gì sau cuối mà bạn thấy trong DevTools và được render trên trang.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">extended-button</span>&gt;</span></span><br><span class="line">  #shadow-root</span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined">…</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"boot.png"</span> <span class="attr">slot</span>=<span class="string">"image"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>Launch<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">extended-button</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h1><p>Khi bạn phải tái sử dụng liên tục 1 vài đoạn markup nào đó trên trang web, cách tốt hơn là ta sử dụng 1 kiểu template hơn là cứ lặp đi lặp lại cùng 1 cấu trúc đó hết lần này đến lần khác. Trước đây vẫn làm được điều này nhưng bây giờ thì dễ hơn nhiều với element HTML <code>&lt;template&gt;</code> hỗ trợ sẵn bởi rất nhiều trình duyệt hiện đại. Element này và nội dung của nó không được render trên DOM nhưng nó vẫn có thể tham chiếu đến bằng Javascript.</p><p>Cùng xem 1 ví dụ đơn giản nào:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"my-paragraph"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> Paragraph content. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Đoạn code đó sẽ không hiển thị trên trang của bạn trừ khi bạn tham chiếu đến nó bằng Javascript và nối nó vào DOM bằng 1 cách nào đó, chẳng hạn như:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> template = <span class="built_in">document</span>.getElementById(<span class="string">'my-paragraph'</span>);</span><br><span class="line"><span class="keyword">var</span> templateContent = template.content;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(templateContent);</span><br></pre></td></tr></table></figure><p>Giờ đây, để đạt được cùng 1 mục đích chung thì có nhiều kỹ thuật khác nhau để lựa chọn nhưng như đã đề cập trước đây, sẽ dễ dàng hơn nhiều nếu như các kỹ thuật đó được hỗ trợ natively. template được các trình duyệt hỗ trợ khá tốt (trừ IE)</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*3SRCEtv7rMhWpB5s" alt=""></p><p>Tự bản thân template đã rất có ích rồi, nhưng nó còn hoạt động tốt hơn nữa với các custom element. Chúng ta sẽ định nghĩa vài custom element trong 1 bài viết khác, còn bây giờ, trong lúc này thì bạn nên biết là có 1 API customElement trên trình duyệt cho phép chúng ta định nghĩa thẻ (tag) riêng của ta với các tùy chọn render.</p><p>Giờ ta sẽ định nghĩa 1 web component sử dụng template trên làm nội dung cho Shadow DOM, chúng ta gọi nó là <my-paragraph>:</my-paragraph></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">customElements.define(<span class="string">'my-paragraph'</span>,</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>() &#123;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">let</span> template = <span class="built_in">document</span>.getElementById(<span class="string">'my-paragraph'</span>);</span><br><span class="line">     <span class="keyword">let</span> templateContent = template.content;</span><br><span class="line">     <span class="keyword">const</span> shadowRoot = <span class="keyword">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'open'</span>&#125;).appendChild(templateContent.cloneNode(<span class="literal">true</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Điểm then chốt cần chú ý ở đây là chúng ta nối 1 bản sao của nội dung template vào shadow root - thứ được tạo ra bằng phương thức <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode" target="_blank" rel="noopener">Node.cloneNode()</a></p><p>Và bởi vì ta nối nội dung của nó với 1 Shadow DOM nên ta có thể đưa thêm 1 vài thông tin về style bên trong template với element <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style" target="_blank" rel="noopener"><code>&lt;style&gt;</code></a>, sau đó phần style này sẽ được đóng gói bên trong custom element. Phần này sẽ không hoạt động nếu ta chỉ nối nó vào 1 DOM bình thường.</p><p>Ví dụ ta đổi template thành như sau:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"my-paragraph"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    p &#123;</span></span><br><span class="line"><span class="undefined">      color: white;</span></span><br><span class="line"><span class="undefined">      background-color: #666;</span></span><br><span class="line"><span class="undefined">      padding: 5px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph content. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Giờ thì component tùy chọn ta đã định nghĩa với template trên có thể được dùng như thế này:<br><code>&lt;my-paragraph&gt;&lt;/my-paragraph&gt;</code></p><h1 id="Slots-khe-trong"><a href="#Slots-khe-trong" class="headerlink" title="Slots (khe trống)"></a>Slots (khe trống)</h1><p>Templates có một vài nhược điểm, 1 trong số đó là nội dung của nó thuộc loại “tĩnh”, không cho phép ta render kèm theo các dữ liệu hoặc biến để làm cho nó hoạt động theo cách bình thường như các template HTML tiêu chuẩn mà ta thường sử dụng.</p><p>Và đây là lúc mà <code>&lt;slot&gt;</code> xuất hiện.</p><p>Bạn có thể tưởng tượng rằng slots giống như người giữ chỗ, nó cho phép bạn đặt HTML riêng của mình vào trong template. Nó giúp cho bạn tạo ra các template HTML linh động hơn, dễ tùy biến hơn bằng cách thêm vào nhiều slot.</p><p>Viết lại template ở phần trên với slot:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"my-paragraph"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"my-text"</span>&gt;</span>Default text<span class="tag">&lt;/<span class="name">slot</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Nếu như nội dung của slot không được định nghĩa khi element được đính kèm theo markup, hoặc nếu như trình duyệt không hỗ trợ slot thì <code>&lt;my-paragraph&gt;</code> sẽ chỉ hiện dòng nội dung backup “Default text”.</p><p>Để định nghĩa nội dung slot, ta cần đính kèm 1 cấu trúc HTML bên trong element <code>&lt;my-paragraph&gt;</code> với thuộc tính <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-slot" target="_blank" rel="noopener">slot</a> và gán giá trị của nó với name của slot mà ta muốn nó truyền vào.</p><p>Giống như code dưới đây:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-paragraph</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"my-text"</span>&gt;</span>Let's have some different text!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-paragraph</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Các element có thể được chèn vào trong slot được gọi là <a href="https://developer.mozilla.org/en-US/docs/Web/API/Slotable" target="_blank" rel="noopener">Slotable</a>; khi 1 element được chèn vào trong slot thì ta nói nó đã bị slotted.</p><p>Để ý rằng ví dụ trên chúng ta đã chèn 1 element <span> vào, nó chính là slotted element. Nó có 1 thuộc tính slot giá trị bằng my-text - cùng giá trị với thuộc tính name trong phần định nghĩa của slot ở template.</span></p><p>Sau khi được render trên trình duyệt, đoạn code trên sẽ tạo ra 1 cây Flattened DOM như sau:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-paragraph</span>&gt;</span></span><br><span class="line">  #shadow-root</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"my-text"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"my-text"</span>&gt;</span>Let's have some different text!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-paragraph</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Lưu ý đến phần tử #shadow-root - nó xuất hiện như 1 chỉ thị rằng Shadow DOM đang tồn tại ở đây.</p><h1 id="Styling"><a href="#Styling" class="headerlink" title="Styling"></a>Styling</h1><p>Một component sử dụng Shadow DOM có thể được tùy chỉnh style từ trang chính, có thể định nghĩa style của riêng nó hoặc cung cấp hook dưới dạng <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables" target="_blank" rel="noopener">thuộc tính tùy chỉnh CSS</a> để user có thể ghi đè những thiết lập mặc định.</p><h2 id="Dinh-nghia-style-cho-component"><a href="#Dinh-nghia-style-cho-component" class="headerlink" title="Định nghĩa style cho component"></a>Định nghĩa style cho component</h2><p><strong>Scoped CSS</strong> (CSS trong phạm vi) là 1 trong số các tính năng tuyệt vời nhất của Shadow DOM:</p><ul><li>Các CSS selector từ trang bên ngoài sẽ không áp dụng được vào bên trong component của bạn</li><li>Các style định nghĩa bên trong component sẽ không ảnh hưởng đến toàn bộ trang. Chúng được đóng gói trong phạm vi của element chủ.</li></ul><p>Các CSS selector được dùng bên trong Shadow DOM áp dụng với component một cách cục bộ. Trong thực tiễn thì điều này nghĩa là ta có thể dùng nhiều lần các tên id/class phổ biến mà không cần lo về sự xung đột giữa chúng trên trang. CSS selector càng đơn giản thì càng có hiệu năng tốt hơn.</p><p>Giờ ta cùng xem 1 đoạn #shadow-root dưới đây định nghĩa style:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#shadow-root</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  #container &#123;</span></span><br><span class="line"><span class="undefined">    background: white;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  #container-items &#123;</span></span><br><span class="line"><span class="undefined">    display: inline-flex;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container-items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Tất cả style ở ví dụ trên đều nằm trong vùng local của #shadow-root</p><p>Bạn có thể dùng element <code>&lt;link&gt;</code> để chèn thêm stylesheets ở ngoài vào trong #shadow-root và nó cũng sẽ thuộc về vùng local.</p><h1 id="pseudo-class-host"><a href="#pseudo-class-host" class="headerlink" title="pseudo-class :host"></a>pseudo-class :host</h1><p>_Ai chưa biết về pseudo-class thì có thể tham khảo ở đây: <a href="https://www.w3schools.com/css/css_pseudo_classes.asp" target="_blank" rel="noopener">https://www.w3schools.com/css/css_pseudo_classes.asp</a>_</p><p>:host cho phép bạn chọn và chỉnh style cho element làm host (chủ) của shadow tree:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">  <span class="selector-pseudo">:host</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/* mặc định thì các custom element có thuộc tính display: inline */</span></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>Có 1 điều bạn cần phải cẩn thận khi sử dụng :host: phần định nghĩa :host trong các trang cha (parent) sẽ có ưu tiên cao hơn định :host định nghĩa trong element. Điều này cho phép người dùng có thể ghi đè phần định nghĩa style cao nhất từ bên ngoài. Bên cạnh đó, :host chỉ hoạt động trong ngữ cảnh của 1 shadow root, vì vậy bạn không thể dùng nó bên ngoài Shadow DOM.</p><p>Dạng function :host(<selector>) cho phép bạn trỏ trực tiếp đến host nếu nó khớp với 1 <selector>. Đây là 1 cách rất tuyệt vời để component của bạn có thể đóng gói các hành vi phản hồi đến các tương tác hoặc trạng thái người dùng và chỉnh style cho các node bên trong dựa trên host:</selector></selector></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">  <span class="selector-pseudo">:host</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.4</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-pseudo">:host(</span><span class="selector-pseudo">:hover)</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-pseudo">:host(</span><span class="selector-attr">[disabled]</span>) &#123; <span class="comment">/* style khi host có thuộc tính disabled */</span></span><br><span class="line">    <span class="attribute">background</span>: grey;</span><br><span class="line">    <span class="attribute">pointer-events</span>: none;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.4</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-pseudo">:host(.pink)</span> &gt; <span class="selector-id">#tabs</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: pink; <span class="comment">/* tô màu cho node #tabs khi host có class="pink" */</span></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="Dung-chu-de-theme-va-element-voi-pseudo-class-host-context-lt-selector-gt"><a href="#Dung-chu-de-theme-va-element-voi-pseudo-class-host-context-lt-selector-gt" class="headerlink" title="Dựng chủ đề (theme) và element với pseudo-class :host-context(&lt;selector&gt;)"></a>Dựng chủ đề (theme) và element với pseudo-class <code>:host-context(&lt;selector&gt;)</code></h1><p>Pseudo-class <code>:host-context(&lt;selector&gt;)</code> khớp host element nếu nó hoặc bất kỳ element cha (ancestor) nào của nó khớp với <selector>.</selector></p><p>Một ví dụ phổ biến cho trường hợp này là làm việc với chủ để (theming). Thực tế là có rất nhiều người khi làm theme đều thêm class vào thẻ <code>&lt;html&gt;</code> hoặc <code>&lt;body&gt;</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"lightheme"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">custom-container</span>&gt;</span></span><br><span class="line">  …</span><br><span class="line">  <span class="tag">&lt;/<span class="name">custom-container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>:host-context(.lightheme) sẽ chỉnh style cho <fancy-tabs> khi nó là con cháu (descendant) của .lightheme:</fancy-tabs></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:host-context(.lightheme)</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:host-context() có thể có ích cho theming nhưng có 1 cách khác còn tốt hơn nữa, đó là định nghĩa 1 style hooks sử dụng các thuộc tính custom của CSS, bạn có thể xem ở đây: <a href="https://developers.google.com/web/fundamentals/web-components/shadowdom#stylehooks" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/web-components/shadowdom#stylehooks</a></p><h1 id="Chinh-style-cho-host-element-cua-component-tu-ben-ngoai"><a href="#Chinh-style-cho-host-element-cua-component-tu-ben-ngoai" class="headerlink" title="Chỉnh style cho host element của component từ bên ngoài"></a>Chỉnh style cho host element của component từ bên ngoài</h1><p>Bạn có thể chỉnh style cho host element của component từ bên ngoài vào bằng cách dùng tag name của nó như 1 selector, kiểu vậy nè:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">custom-container</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Style bên ngoài có mức ưu tiên cao hơn style định nghĩa bên trong Shadow DOM.</p><p>Ví dụ, nếu user viết 1 selector như sau:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">custom-container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…thì nó sẽ ghi đè lên rule của component:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:host</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tức là width lúc này có giá trị 500px</p><p>Styling chính component thì chỉ có thể đến mức này thôi. Vậy nếu bạn muốn style các thành phần sâu hơn bên trong của component thì sao? Ta sẽ cần đến các thuộc tính custom của CSS.</p><h1 id="Tao-style-hook-su-dung-thuoc-tinh-custom-cua-CSS"><a href="#Tao-style-hook-su-dung-thuoc-tinh-custom-cua-CSS" class="headerlink" title="Tạo style hook sử dụng thuộc tính custom của CSS"></a>Tạo style hook sử dụng thuộc tính custom của CSS</h1><p>User có thể dùng mẹo để chỉnh style cho các thành phần bên trong nếu như tác giả của component đó có cung cấp styling hook sử dụng <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables" target="_blank" rel="noopener">thuộc tính custom của CSS</a>.</p><p>Ý tưởng tương tự với <code>&lt;slot&gt;</code> nhưng áp dụng cho style.</p><p>Cùng xem ví dụ bên dưới:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- main page --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  custom-container &#123;</span></span><br><span class="line"><span class="undefined">    margin-bottom: 60px;</span></span><br><span class="line"><span class="undefined">     - custom-container-bg: black;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">custom-container</span> <span class="attr">background</span>&gt;</span>…<span class="tag">&lt;/<span class="name">custom-container</span>&gt;</span></span><br></pre></td></tr></table></figure><p>bên trong Shadow DOM của nó:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:host(</span><span class="selector-attr">[background]</span>) &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>( - custom-container-bg, #CECECE);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trong trường hợp này, component sẽ sử dụng màu black làm giá trị cho background bởi vì user muốn thế. Nếu không thì nó sẽ dùng giá trị mặc định là #CECECE.</p><p>Nếu là tác giả của component, bạn có trách nhiệm cho developer biết về những thuộc tính custom của CSS mà họ có thể sử dụng. Hãy xem như đó là luật bất thành văn khi public một component.</p><h1 id="Javascript-API-cho-slot"><a href="#Javascript-API-cho-slot" class="headerlink" title="Javascript API cho slot"></a>Javascript API cho slot</h1><p>Shadow DOM API cung cấp nhiều tiện ích hữu dụng để làm việc với slot</p><h2 id="Su-kien-slotchange"><a href="#Su-kien-slotchange" class="headerlink" title="Sự kiện slotchange"></a>Sự kiện slotchange</h2><p>Sự kiện slotchange được bắn ra khi node phân phối của slot bị thay đổi. Ví dụ, nếu user thêm/bớt children từ light DOM.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slot = <span class="keyword">this</span>.shadowRoot.querySelector(<span class="string">'#some_slot'</span>);</span><br><span class="line">slot.addEventListener(<span class="string">'slotchange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Light DOM change'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Để kiểm soát các kiểu thay đổi khác trên light DOM, bạn có thể dùng MutationObserver trong constructor của element. Chúng ta đã từng thảo luận về nó trong <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-10---Quan-sat-thay-doi-tren-DOM-bang-MutationObserver" target="_blank" rel="noopener">Phần 10</a> rồi.</p><h2 id="Phuong-thuc-assignedNodes"><a href="#Phuong-thuc-assignedNodes" class="headerlink" title="Phương thức assignedNodes()"></a>Phương thức assignedNodes()</h2><p>Sẽ rất có ích khi biết rằng các element có liên kết với slot. Gọi slot.assignedNodes() sẽ cho phép bạn biết những element nào mà slot render. Option {flatten: true} cũng sẽ trả về nội dung fallback của slot (nếu như không có node nào đang được phân phối).</p><p>Cùng xem ví dụ sau đây:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">'slot1'</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Default content<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Giả sử nó nằm trong 1 component gọi là <code>&lt;my-container&gt;</code></p><p>Giờ ta sẽ test thử các cách sử dụng khác nhau của component này và kết quả trả về của assignedNodes():</p><p>Trường hợp đầu tiên, ta sẽ thêm nội dung vào slot:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"slot1"</span>&gt;</span> container text <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-container</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Gọi assignedNodes() sẽ có kết quả <code>[&lt;span slot=&#39;slot1&#39;&gt; container text &lt;/span&gt;]</code>. Để ý rằng kết quả là 1 array các node.</p><p>Trong trường hợp thứ 2, ta để nội dung trống trơn:<br><code>&lt;my-container&gt; &lt;/my-container&gt;</code></p><p>Kết quả khi gọi assignedNodes() là 1 array rỗng [].</p><p>Tuy nhiên nếu như bạn đẩy thêm option {flatten: true} thì nó sẽ lấy giá trị mặc định và trả về [</p><p>Default content</p>].<p></p><p>Ngoài ra, để có thể chạm tới 1 element bên trong slot, bạn có thể gọi assignedNodes() để xem nếu có element nào đang được gán vào component slot hay không.</p><h1 id="Mo-hinh-su-kien-event-model"><a href="#Mo-hinh-su-kien-event-model" class="headerlink" title="Mô hình sự kiện (event model)"></a>Mô hình sự kiện (event model)</h1><p>Thật thú vị khi để ý thấy điều gì xảy ra khi 1 sự kiện nằm trong Shadow DOM được bắn ra.</p><p>Mục tiêu của sự kiện được điều chỉnh để bảo trì sự đóng gói, cô lập bởi Shadow DOM. Khi 1 sự kiện được tái-mục-tiêu (re-target), trông giống như là nó xuất phát từ chính component hơn là từ các element bên trong của Shadow DOM - vốn là 1 phần của component.</p><p>Dưới đây là danh sách các sự kiện có thể phát ra ngoài Shadow DOM (1 số thì không):</p><ul><li><strong>Sự kiện Focus</strong>: blur, focus, focusin, focusout</li><li><strong>Sự kiện cho con trỏ chuột</strong>: click, dbclick, mousedown, mouseenter, mousemove, vân vân.</li><li><strong>Sự kiện cho con lăn chuột</strong>: wheel</li><li><strong>Sự kiện cho input</strong>: beforeinput, input</li><li><strong>Sự kiện cho bàn phím</strong>: keydown, keyup</li><li><strong>Sự kiện kết hợp</strong>: compositionstart, compositionupdate, compositionend</li><li><strong>Sự kiện kéo-thả</strong>: dragstart, drag, dragend, drop, vân vân.</li></ul><h1 id="Cac-su-kien-custom"><a href="#Cac-su-kien-custom" class="headerlink" title="Các sự kiện custom"></a>Các sự kiện custom</h1><p>Các sự kiện custom mặc định thì không phát ra bên ngoài Shadow DOM. Nếu bạn muốn điều phối 1 sự kiện custom và muốn nó phát ra ngoài, bạn cần thêm 2 option: bubbles: true và composed: true</p><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="keyword">this</span>.shadowRoot.querySelector(<span class="string">'#container'</span>);</span><br><span class="line">container.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">'containerchanged'</span>, &#123;<span class="attr">bubbles</span>: <span class="literal">true</span>, <span class="attr">composed</span>: <span class="literal">true</span>&#125;));</span><br></pre></td></tr></table></figure><p>Sự hỗ trợ trình duyệt: Để xác định xem trình duyệt có sẵn hỗ trợ cho Shadow DOM hay không thì ta có thể kiểm tra sự tồn tại của attachShadow:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> supportsShadowDOMV1 = !!HTMLElement.prototype.attachShadow;</span><br></pre></td></tr></table></figure><p>Nhưng nói chung là không được nhiều cho lắm:</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*k0vSOmvdDkRJzcpW" alt=""></p><p>Nhìn chung thì Shadow DOM có lối hành xử rất khác với DOM thường. Team SessionStack có 1 chút kinh nghiệm khi sử dụng chúng trong thư viện của họ. Thư viện đó khi được tích hợp vào trong webapp thì sẽ bắt đầu thu thập các thông tin chẳng hạn như sự kiện người dùng, dữ liệu mạng, biệt lệ, thông báo debug, thay đổi trên DOM, vân vân, và gửi chúng về cho server của họ.</p><p>Sau đó, họ sẽ xử lý các dữ liệu thu được để cho phép bạn có thể dùng SessionStack để tái hiện lại các vấn đề xảy ra trong sản phẩm của bạn. Sự khó khăn họ gặp phải trong quá trình phát triển khi sử dụng Shadow DOM: họ phải kiểm soát mọi thay đổi trên DOM để có thể tái tạo lại sau này. Họ dùng MutationObserver để làm việc đó. Tuy nhiên, Shadow DOM không trigger các sự kiện MutationObserver trong phạm vi toàn cục, nghĩa là họ phải xử lý các component này theo 1 cách hoàn toàn khác.<br>Họ cũng nhận thấy rằng ngày nay, có rất nhiều webapp đang tận dụng sức mạnh của Shadow DOM nên có vẻ như công nghệ này sẽ có 1 tương lai rất rạng ngời.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;Trong bài có nhiều từ mình để nguyên mà không dịch nhé, vì dịch ra thì bay mất nghĩa @&lt;/em&gt;@_&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;element&lt;/strong&gt;: phần tử&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;custom element&lt;/strong&gt;: phần tử tự tạo&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;component&lt;/strong&gt;: thành phần&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;custom component&lt;/strong&gt;: thành phần tự tạo&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;markup&lt;/strong&gt;: nói chung là ngôn ngữ đánh dấu, hay nói dễ hiểu hơn là code HTML (Hyper Text &lt;strong&gt;Markup&lt;/strong&gt; Language)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Chào các bạn đến với bài thứ 17 trong series khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P16: Engine lưu trữ + lựa chọn API lưu trữ nào cho phù hợp</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P16-Engine-luu-tru-lua-chon-API-luu-tru-nao-cho-phu-hop.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P16-Engine-luu-tru-lua-chon-API-luu-tru-nao-cho-phu-hop.html</id>
    <published>2018-11-25T09:42:00.000Z</published>
    <updated>2018-11-25T09:44:30.253Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 16 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Lựa chọn cơ chế lưu trữ đúng đắn cho thiết bị lưu trữ ở local rất quan trọng khi thiết kế webapp. Một engine lưu trữ tốt sẽ đảm bảo thông tin của bạn được lưu chắc chắn, giảm băng thông và cải thiện sự phản hồi. Chiến lược lưu trữ bộ nhớ đệm phù hợp là thành phần cốt lõi cho phép trải nghiệm mobile web offline, càng ngày càng có nhiều người dùng cảm thấy rằng như đó là trải nghiệm mặc định phải có.</p><p>Trong chương này, chúng ta sẽ thảo luận về những API lưu trữ có sẵn &amp; các service và cung cấp một số hướng dẫn làm thế nào để lựa chọn đúng loại cho webapp của bạn.<br><a id="more"></a></p><h1 id="Data-model-mo-hinh-du-lieu"><a href="#Data-model-mo-hinh-du-lieu" class="headerlink" title="Data model (mô hình dữ liệu)"></a>Data model (mô hình dữ liệu)</h1><p>Mô hình lưu trữ dữ liệu xác định làm thế nào để dữ liệu được tổ chức nội bộ. Điều này ảnh hưởng toàn bộ thiết kế của webapp, định nghĩa sự cân bằng để làm cho webapp hoạt động hiệu quả nhưng vẫn giải quyết được vấn đề cần giải quyết. Giống như bất cứ thứ gì liên quan đến kỹ thuật, không tồn tại phương pháp nào “tốt hơn” và cũng không có giải pháp một-cho-tất-cả nào hết. Cùng xem qua 1 chút về một số data model mà ta có thể dùng:</p><ul><li><strong>Kiểu cấu trúc</strong>: Dữ liệu được lưu trong các bảng kèm với các trường đã được định nghĩa, giống như các hệ quản trị cơ sở dữ liệu đặc trưng dựa trên SQL, chúng có tính linh hoạt và các câu truy vấn động. Một ví dụ nổi bật về kho dữ liệu kiểu cấu trúc trên trình duyệt chính là IndexedDB.</li><li><strong>key/value</strong>: kho dữ liệu key/value, và cả cơ sở dữ liệu NoSQL, cho phép lưu trữ và trích xuất dữ liệu không có cấu trúc được đánh index bằng 1 key duy nhất. Kho dữ liệu kiểu key/value giống như bảng băm (hash table) ở chỗ chúng cho phép truy cập liên tục vào các dữ liệu ẩn đã được đánh index. Một ví dụ điển hình cho kho dữ liệu key/value là Cache API trên trình duyệt và Apache Cassandra trên server.</li><li><strong>Byte Streams</strong>: mô hình đơn giản này lưu dữ liệu dưới dạng 1 biến độ dài, một chuỗi ẩn các byte, và nó để lại bất kỳ hình thức tổ chức nội bộ nào cho lớp ứng dụng. Mô hình này đặc biệt tốt cho các hệ thống tập tin (file) và các blob dữ liệu có tổ chức dạng phân cấp. Ví dụ điển hình của kho dữ liệu byte stream bao gồm những hệ thống file và các dịch vụ lưu trữ cloud.</li></ul><h1 id="Tinh-ben-vung"><a href="#Tinh-ben-vung" class="headerlink" title="Tính bền vững"></a>Tính bền vững</h1><p>Có thể phân tích các phương pháp lưu trữ cho webapp với sự mức độ ưu tiên cho timeframe hơn là dữ liệu nào cần được bền vững:</p><ul><li><strong>Session Persistence (Bền vững phiên)</strong>: dữ liệu trong mục này chỉ được giữ cố định miễn là một session của web hoặc một tab trên trình duyệt vẫn đang hoạt động. Ví dụ về cơ chế lưu trữ với phiên bền vững chính là <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener">Session Storage API</a></li><li><strong>Device Persistence (Bền vững thiết bị)</strong>: dữ liệu trong mục này được giữ cố định xuyên suốt nhiều session và nhiều tab hoặc cửa sổ trình duyệt, trên 1 thiết bị cụ thể. Ví dụ: <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage" target="_blank" rel="noopener">Cache API</a></li><li><strong>Global Persistence (Bền vững toàn cục)</strong>: dữ liệu trong mục này được giữ cố định xuyên suốt các session &amp; các thiết bị. Vì thế, đây là dạng mạnh mẽ nhất của bền vững dữ liệu. Nó không được lưu trữ trên chính thiết bị và điều đó nghĩa là bạn cần phải có 1 kiểu lưu trữ ở phía server. Chúng ta sẽ không thảo luận chi tiết về nó vì bài viết này chỉ tập trung vào lưu trữ dữ liệu trên thiết bị.</li></ul><h1 id="Ben-vung-du-lieu-tren-trinh-duyet"><a href="#Ben-vung-du-lieu-tren-trinh-duyet" class="headerlink" title="Bền vững dữ liệu trên trình duyệt"></a>Bền vững dữ liệu trên trình duyệt</h1><p>Ngày nay có rất ít các browser API cho phép bạn lưu trữ dữ liệu. Chúng ta sẽ tìm hiểu qua một vài thứ như thế và tạo 1 bản so sánh để có thể dễ dàng lựa chọn giải pháp phù hợp.</p><p>Tuy nhiên thì đầu tiên, có vài thứ bạn cần phải cân nhắc trước khi chọn làm thế nào để cố định dữ liệu. Dĩ nhiên thì thứ đầu tiên bạn cần phải hiểu kỹ chính là webapp của bạn được dùng như thế nào, sau đó còn có bảo trì và nâng cấp. Thậm chí nếu bạn có câu trả lời cho các câu hỏi đó, bạn cũng sẽ phải kết thúc với 1 số lựa chọn và chọn chúng. Vì thế nên dưới đây là 1 số thứ bạn nên xem qua:</p><ul><li><strong>Trình duyệt hỗ trợ</strong>: bạn cần phải nhớ kỹ 1 sự thật là các API được xây dựng tốt &amp; được chuẩn hóa có mức độ ưu ái cao hơn, bởi vì chúng hướng tới sự tồn tại lâu dài và được hỗ trợ rộng rãi. Những API đó cũng thường có tài liệu rộng hơn và cộng đồng developer hỗ trợ giàu kinh nghiệm hơn.</li><li><strong>Transactions (giao dịch)</strong>: đôi khi transactions rất quan trọng đối với 1 tập hợp của các hoạt động lưu trữ tự động thành công hay thất bại. Các cơ sở dữ liệu theo truyền thống luôn hỗ trợ tính năng này sử dụng 1 mô hình transaction, những cập nhật liên quan được nhóm lại thành các đơn vị chuyên biệt.</li><li><strong>Sync/Async (đồng bộ/bất đồng bộ)</strong>: một vài API lưu trữ thể hiện sự đồng bộ khi mà các request lưu trữ hoặc lấy dữ liệu sẽ chặn tiến trình đang hoạt động cho tới khi request được hoàn thành. Sử dụng API lưu trữ đồng bộ có thể chặn tiến trình chính và làm cho trải nghiệm UI trên webapp bị đông cứng không hoạt động. Nếu có thể, hãy dùng các API bất đồng bộ.</li></ul><h1 id="So-sanh"><a href="#So-sanh" class="headerlink" title="So sánh"></a>So sánh</h1><p>Trong phần này, chúng ta sẽ so sánh các API hiện có dành cho web developer và so sánh chúng với các tiêu chí đã nói ở trên</p><table><thead><tr><th>API</th><th>Mô hình dữ liệu (Data model)</th><th>Tính bền vững (persistence)</th><th>Trình duyệt hỗ trợ</th><th>Transactions</th><th>Sync/Async</th></tr></thead><tbody><tr><td>File System (hệ thống file)</td><td>Byte stream</td><td>thiết bị</td><td>52%</td><td>Không</td><td>Async</td></tr><tr><td>Local Storage</td><td>key/value</td><td>thiết bị</td><td>93%</td><td>Không</td><td>Sync</td></tr><tr><td>Session Storage</td><td>key/value</td><td>session</td><td>93%</td><td>Không</td><td>Sync</td></tr><tr><td>Cookies</td><td>cấu trúc</td><td>thiết bị</td><td>100%</td><td>Không</td><td>Sync</td></tr><tr><td>Cache</td><td>key/value</td><td>thiết bị</td><td>60%</td><td>Không</td><td>Async</td></tr><tr><td>IndexedDB</td><td>hỗn hợp (hybrid)</td><td>thiết bị</td><td>83%</td><td>Có</td><td>Async</td></tr></tbody></table><h1 id="File-System-API-he-thong-file"><a href="#File-System-API-he-thong-file" class="headerlink" title="File System API (hệ thống file)"></a>File System API (hệ thống file)</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*9KPehy4mUb8f-hSp" alt=""></p><p>Với File System API, webapp có thể tạo, đọc, điều hướng và ghi vào 1 khu vực sandbox thuộc hệ thống local file của user.</p><p>API được chia nhỏ thành nhiều chủ đề:</p><ul><li>Đọc và sửa file: File/Blob, FileList, FileReader</li><li>Tạo và ghi file: Blob(), FileWriter</li><li>Các thư mục và truy cập hệ thống file: DirectoryReader, FileEntry/DirectoryEntry, LocalFileSystem</li></ul><p>File System API không phải là 1 hệ thống API tiêu chuẩn. Bạn không nên dùng nó trên sản phẩm webapp production bởi vì nó sẽ không hoạt động với tất cả user. Có rất sự không tương thích lớn giữa các triển khai khác nhau và hành vi của chúng sẽ chắc chắn bị thay đổi trong tương lai.</p><p><strong>FileSystem</strong> - interface của File &amp; Directory Entries API được dùng để thể hiện 1 hệ thống file. Những object này có thể được lấy từ thuộc tính <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemEntry/filesystem" target="_blank" rel="noopener">filesystem</a> của bất kỳ entry thuộc hệ thống file nào. Một vài trình duyệt cung cấp thêm các API để tạo &amp; quản lý các hệ thống file.</p><p>Interface này sẽ không cấp quyền cho bạn truy cập vào hệ thống file của user. Thay vào đó, bạn sẽ có 1 “ổ đĩa ảo” (virtual drive) bên trong sandbox của trình duyệt. Nếu bạn muốn truy cập vào hệ thống file của user, bạn cần phải gọi hỏi user bằng cách ví dụ như cài 1 Chrome extension.</p><h2 id="Yeu-cau-1-he-thong-file"><a href="#Yeu-cau-1-he-thong-file" class="headerlink" title="Yêu cầu 1 hệ thống file"></a>Yêu cầu 1 hệ thống file</h2><p>Một webapp có thể yêu cầu truy cập đến một hệ thống file sandbox bằng cách gọi: window.requestFileSystem():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lưu ý: Hệ thống file đã được đánh tiền tố tính đến Google Chrome 12.</span></span><br><span class="line"><span class="built_in">window</span>.requestFileSystem = <span class="built_in">window</span>.requestFileSystem || <span class="built_in">window</span>.webkitRequestFileSystem;</span><br><span class="line"><span class="built_in">window</span>.requestFileSystem(type, size, successCallback, opt_errorCallback)</span><br></pre></td></tr></table></figure><p>Nếu bạn gọi hàm requestFileSystem() lần đầu tiên thì 1 vùng lưu trữ mới được tạo ra. Quan trọng hãy nhớ rằng hệ thống file này được gói gọn trong sandbox, nghĩa là 1 webapp không thể truy cập file của webapp khác.</p><p>Sau khi bạn có quyền truy cập vào hệ thống file, bạn có thể làm tất cả các hoạt động cơ bản với file &amp; thư mục.</p><p>FileSystem là 1 lựa chọn lưu trữ khá khác biệt với các loại khác vì nó hướng đến thỏa mãn như cầu lưu trữ ở phía client trong những tình huống không dùng được cơ sở dữ liệu. Một cách tổng quát thì đó là những ứng dụng hoạt động với những cục blob nhị phân cỡ bự và/hoặc chia sẻ dữ liệu với các ứng dụng khác bên ngoài trình duyệt.</p><p>Dưới đây là những trường hợp có thể sử dụng FileSystem API:</p><ul><li>Tải lên (upload) liên tục: khi 1 file hay thư mục được chọn để upload, nó copy các file vào trong 1 vùng local sandbox và upload từng phần, từng phần.</li><li>Video game, âm nhạc hoặc các app khác mà có nhiều tài nguyên media.</li><li>Chỉnh sửa âm thanh/hình ảnh với truy cập offline hoặc là lưu đệm local để tăng tốc độ - những cục blob dữ liệu như thế thường rất lớn khi đọc-ghi.</li><li>Xem video offline - cần phải download 1 lượng lớn file để xem sau hoặc seek + streaming hiệu quả.</li><li>Ứng dụng Web Mail offline - download các file đính kèm và lưu chúng ở local.</li></ul><p>Tình hình hỗ trợ của API:<br><img src="https://cdn-images-1.medium.com/max/1000/0*ndU4N8xQF6QEQmSY" alt=""></p><h1 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*AsoHzlowoLItnUEL" alt=""></p><p>API localstorage cho phép bạn truy cập object <a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage" target="_blank" rel="noopener">Storage</a> dành cho origin của <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document" target="_blank" rel="noopener">Document</a>. Dữ liệu lưu trữ xuyên suốt nhiều session trình duyệt. localstorage tương tự như <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window.sessionStorage" target="_blank" rel="noopener">sessionStorage</a>, ngoại trừ việc dữ liệu lưu ở trong dataStorage không bị hết hạn, dữ liệu trong sessionStorage sẽ bị dọn dẹp khi session của trang kết thúc, tức là khi đóng tab trang đó.</p><p>Để ý rằng dữ liệu lưu trong localStorage hay sessionStorage là cụ thể cho origin của từng trang, bao gồm sự kết hợp của giao thức (protocol), host và cổng (port).</p><p>Tình hình hỗ trợ sáng sủa của nó:<br><img src="https://cdn-images-1.medium.com/max/1000/0*hxC_NUPNycUBhj-L" alt=""></p><h1 id="Session-Storage"><a href="#Session-Storage" class="headerlink" title="Session Storage"></a>Session Storage</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*-IMsNws_L1g0Syla" alt=""></p><p>sessionStorage cho phép bạn truy cập vào 1 object <a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage" target="_blank" rel="noopener">Storage</a> của session cho origin hiện tại. sessionStorage tương tự như <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">localStorage</a>, như đã giải thích ngắn gọn ở trên. Điểm khác biệt duy nhất là dữ liệu lưu trong localStorage không bị hết hạn, còn trong sessionStorage thì bị xóa khi session của trang kết thúc. Một session của trang tồn tại miễn là cửa sổ trình duyệt vẫn còn mở và tồn tại khi trang reload hoặc restore. <strong>Mở trang trong 1 tab mới hoặc cửa sổ mới sẽ tạo ra session mới</strong>, khác với cách hoạt động của session cookies.</p><p>Dữ liệu lưu trong sessionStorage hay localStorage là <strong>dành riêng cho origin của trang</strong>.</p><p>Tình hình hỗ trợ của sessionStorage:<br><img src="https://cdn-images-1.medium.com/max/1000/0*PTDs1BkbMgekizit" alt=""></p><h1 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*VKQINIYfu2O7d7BH" alt=""></p><p>Một cookie (hay web cookie, cookie trình duyệt) là 1 cục dữ liệu nhỏ xíu mà server gửi đến trình duyệt của user. Trình duyệt có thể lưu nó và gửi ngược về cùng server đó trong request tiếp theo. Thông thường, nó được dùng để cho biết nếu 2 request đến từ cùng 1 trình duyệt - ví dụ: giữ cho user tiếp tục đăng nhập. Nó ghi nhớ thông tin trạng thái cho giao thức HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#HTTP_is_stateless_but_not_sessionless" target="_blank" rel="noopener">không trạng thái</a> (stateless).</p><p>Cookies có 3 trường hợp dùng chính:</p><ul><li><strong>Quản lý session</strong>: login, giỏ hàng online, lưu điểm game hay bất cứ thứ gì server cần nhớ.</li><li><strong>Cá nhân hóa (Personalization)</strong>: các thiết đặt của người dùng, chủ để và những cài đặt khác.</li><li><strong>Theo dõi</strong>: ghi lại và phân tích hành vi của người dùng.</li></ul><p>Cookies đã từng được dùng để lưu trữ tổng quát ở phía client. Như vậy vẫn hợp pháp vì lúc đó nó là giải pháp duy nhất để lưu trữ thông tin ở phía client, ngày nay thì người ta thường chọn các API lưu trữ hiện đại hơn. Cookies được gửi về với mỗi request nên có thể ảnh hưởng xấu đến hiệu năng (đặc biệt với các kết nối trên thiết bị di động).</p><p>Có 2 loại cookies:</p><ul><li><strong>Cookie phiên (session cookies</strong>: Chúng bị xóa khi client tắt. Trình duyệt web có thể dùng <strong>khôi phục session</strong> để lấy lại gần hết session cookies, giống như là trình duyệt chưa bao giờ bị tắt vậy.</li><li><strong>Cookie dài hạn (permanent cookie)</strong>: thay vì hết hạn khi người dùng tắt trình duyệt, <em>permanent cookie</em> hết hạn tại 1 ngày nhất định (Expires) hoặc là sau 1 khoảng thời gian nhất định (Max-Age).</li></ul><p>Lưu ý rằng các thông tin bí mật và nhạy cảm không nên lưu hoặc vận chuyển với HTTP Cookies bởi vì rõ ràng toàn bộ cơ chế này vốn không an toàn.</p><p>Và rõ ràng là cookies hoạt động tốt với tất cả các trình duyệt.</p><h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*XZ2U-ztABhWJOSky" alt=""></p><p>Interface <strong>Cache</strong> cung cấp cơ chế lưu trữ cho cặp object <a href="http://fetch.spec.whatwg.org/#request" target="_blank" rel="noopener">Request</a>/<a href="http://fetch.spec.whatwg.org/#response" target="_blank" rel="noopener">Response</a> được lưu đệm. Lưu ý rằng interface Cache được dùng trong phạm vi window giống như workers. Bạn không phải dùng nó cùng với service worker mặc dù nó được định nghĩa trong thông tin của service worker.</p><p>Một origin có thể có nhiều object Cache (có tên cụ thể). Bạn có trách nhiệm triển khai code (ví dụ như trong <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker" target="_blank" rel="noopener">ServiceWorker</a>) để xử lý cập nhật cho Cache. Các item trong Cache không được cập nhật trừ khi được yêu cầu tường minh; chúng không hết hạn trừ khi bị xóa. Dùng hàm <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open" target="_blank" rel="noopener">CacheStorage.open()</a> để mở 1 object Cache với tên cụ thể và gọi bất kỳ phương thức Cache nào để bảo trì Cache.</p><p>Bạn cũng có trách nhiệm dọn dẹp định kỳ các cache entry. Mỗi trình duyệt có 1 giới hạn cứng với số lượng cache lưu trữ cấp cho 1 origin. Hạn mức sử dụng Cache ước tính tồn tại trong API <a href="https://developer.mozilla.org/en-US/docs/Web/API/StorageEstimate" target="_blank" rel="noopener">StorageEstimate</a>. Trình duyệt làm công việc tốt nhất của nó để quản lý dung lượng đĩa nhớ nhưng nó có thể xóa lưu trữ Cache của 1 origin. Đại khái là trình duyệt hoặc sẽ xóa tất cả dữ liệu của 1 origin hoặc không làm gì cả. Đảm bảo đánh phiên bản của cache bằng tên và chỉ dùng phiên bản cache nào mà code của bạn có thể sử dụng an toàn. Bạn có thể xem thêm bài <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker_API/Using_Service_Workers#Deleting_old_caches" target="_blank" rel="noopener">Xóa cache cũ</a> để hiểu thêm.</p><p>Interface <strong>CacheStorage</strong> thể hiện sự lưu trữ cho các object <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">Cache</a></p><p>Interface:</p><ul><li>Cung cấp thư mục master của tất cả các cache có tên mà có thể truy xuất bởi <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker" target="_blank" rel="noopener">ServiceWorker</a> hoặc các loại worker khác hoặc phạm vi <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window" target="_blank" rel="noopener">window</a> (bạn không bị giới hạn chỉ sử dụng với service worker kể cả thông tin của <a href="https://w3c.github.io/ServiceWorker/" target="_blank" rel="noopener">Service Worker</a> có định nghĩa như vậy).</li><li>Duy trì khả năng ánh xạ (mapping) tên tương ứng với object <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">Cache</a></li></ul><p>Dùng phương thức <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open" target="_blank" rel="noopener">CacheStorage.open()</a> để lấy 1 instance của <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">Cache</a></p><p>Dùng phương thức <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/match" target="_blank" rel="noopener">CacheStorage.match()</a> để kiểm tra nếu 1 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request" target="_blank" rel="noopener">Request</a> có phải là 1 key trong bất kỳ object <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">Cache</a> nào mà object CacheStorage theo dõi.</p><p>Bạn có thể truy cập CacheStorage thông qua thuộc tính toàn cục <a href="https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/caches" target="_blank" rel="noopener">caches</a></p><h1 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*HP66Xm7oe9u8Ofk1" alt=""></p><p>IndexedDB là 1 cách để bạn lưu trữ dữ liệu một cách bền vững bên trong trình duyệt của người dùng. Bởi vì nó cho phép bạn tạo các webapp với khả năng viết câu truy vấn đa dạng bất kể tình trạng mạng. Những ứng dụng này có thể làm việc online &amp; offline. IndexedDB có ích cho các ứng dụng cần lưu trữ 1 lượng lớn dữ liệu (ví dụ: danh sách các DVD cho mượn trong thư viện) và các ứng dụng không cần sự kết nối internet ổn định để hoạt động (ví dụ: ứng dụng mail, danh sách to-do, notepad).</p><p>Trong bài này, nó là cơ sở dữ liệu lưu trữ mà chúng ta sẽ thảo luận chi tiết hơn 1 chút bởi vì các API lưu trữ khác đều được hiểu biết khá rộng. Thêm nữa, IndexedDB càng ngày càng phổ biến với các webapp phức tạp ngày càng gia tăng.</p><h2 id="Ben-trong-IndexedDB"><a href="#Ben-trong-IndexedDB" class="headerlink" title="Bên trong IndexedDB"></a>Bên trong IndexedDB</h2><p>IndexedDB cho phép bạn lưu trữ và lấy các object được lưu bằng cách dùng key. Tất cả thay đổi bạn thực hiện với cơ sở dữ liệu đều xảy ra trong phạm vi transaction. Giống như nhiều giải pháp lưu trữ web khác, IndexedDB bám sát nguyên tắc cùng origin (<a href="http://www.w3.org/Security/wiki/Same_Origin_Policy" target="_blank" rel="noopener">same-origin policy</a>). Vì thế bạn có thể truy cập dữ liệu lưu trữ trong phạm vi 1 domain nhưng không thể truy cập dữ liệu của các domain khác.</p><p>IndexedDB là API bất đồng bộ (<a href="https://developer.mozilla.org/en/IndexedDB#Asynchronous_API" target="_blank" rel="noopener">asynchronous</a>) có thể sử dụng trong hầu hết các ngữ cảnh, bao gồm cả <a href="https://developer.mozilla.org/En/DOM/Using_web_workers" target="_blank" rel="noopener">WebWorkers</a>. Nó thường bao gồm cả 1 phiên bản đồng bộ (<a href="https://developer.mozilla.org/en/IndexedDB#Synchronous_API" target="_blank" rel="noopener">synchronous</a>) nữa để dùng trong web worker nhưng đã bị xóa bỏ bởi vì cộng đồng web không có hứng thú với nó.</p><p>IndexedDB thường cạnh tranh với cơ sở dữ liệu WebSQL nhưng nó đã bị hủy bởi W3C. Trong khi cả 2 IndexedDB và WebSQL là các giải pháp lưu trữ, chúng lại không cung cấp cùng tính năng. CSDL WebSQL là 1 hệ truy cập CSDL quan hệ trong khi IndexedDB là hệ bảng đánh số (indexed table).</p><p>Đừng bắt đầu với IndexedDB nếu như bạn chỉ nghe nói hoặc giả định rằng nó tốt hơn các loại CSDL khác. Thay vì thế hãy đọc thật kỹ tài liệu của nó. Dưới đây là 1 vài ý tưởng cần thiết mà bạn cần phải biết:</p><ul><li><strong>CSDL IndexedDB lưu theo cặp key-value</strong>: giá trị có thể là object cấu trúc phức tạp và key có thể là thuộc tính của những object đó. Bạn có thể tạo index dùng bất kỳ thuộc tính nào của object để dễ tìm kiếm cũng như khi cần sắp xếp. Key cũng có thể là object nhị phân.</li><li><strong>API IndexedDB đa phần là bất đồng bộ</strong>: API không đưa dữ liệu cho bạn bằng cách trả về giá trị. Thay vì thế nó truyền vào 1 hàm callback. Bạn không “lưu” 1 giá trị vào trong CSDL hoặc “lấy” nó ra theo nghĩa đồng bộ. Thay vào đó, bạn “yêu cầu” (request) một hành động trên CSDL. Một sự kiện thông báo cho bạn khi hành động hoàn thành và kiểu sự kiện bạn nhận được nếu như có hành động thành công hay thất bại. Không khác mấy so với cách hoạt động của <a href="https://developer.mozilla.org/en/DOM/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a> (hoặc là cả tá thứ khác về Javascript)</li><li><strong>IndexedDB dùng rất nhiều request</strong>: request là object nhận các sự kiện thành công hay thất bại như đã nói ở trên. Chúng có thuộc tính onsuccess và onerror cũng như readyState, result và errorCode sẽ cho bạn biết về trạng thái của request.</li><li><strong>IndexedDB hướng đối tượng</strong>: IndexedDB không phải CSDL quan hệ với các bảng thể hiện tập hợp hàng &amp; cột. Điểm khác biệt cơ bản này ảnh hưởng đến giai đoạn thiết kế và xây dựng ứng dụng của bạn.</li><li><strong>IndexedDB không dùng ngôn ngữ truy vấn cấu trúc (SQL)</strong>: nó dùng kiểu truy vấn trên index để tạo ra con trỏ, chính con trỏ này dùng để lặp xuyên suốt tập kết quả. Nếu bạn không quen với hệ thống NoSQL thì có thể xem thêm <a href="https://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="noopener">bài này trên Wikipedia</a></li><li><strong>IndexedDB dùng nguyên tắc cùng origin</strong>: một origin là domain, giao thức tầng ứng dụng và cổng (port) của URL của văn bản là nơi mà code được thực thi. Mỗi origin có 1 tập các CSDL riêng của nó. Mỗi CSDL có 1 cái tên định danh nó trong origin.</li></ul><h2 id="Gioi-han-cua-IndexedDB"><a href="#Gioi-han-cua-IndexedDB" class="headerlink" title="Giới hạn của IndexedDB"></a>Giới hạn của IndexedDB</h2><p>IndexedDB được thiết kế để dùng với hầu hết các tình huống cần lưu trữ ở phía client. Nó không được thiết kế cho 1 vài trường hợp dưới đây:</p><ul><li><strong>Sắp xếp toàn cầu (Internationalized sorting)</strong>: không phải tất cả ngôn ngữ đều sắp xếp array theo cùng 1 cách, vì thế mà Internationalized sorting không được hỗ trợ. CSDL không thể lưu dữ liệu theo 1 thứ tự toàn cầu cụ thể, bạn có thể tự tay sắp xếp dữ liệu đọc từ CSDL ra.</li><li><strong>Đồng bộ hóa</strong>: API không được thiết kế để thực hiện đồng bộ hóa với CSDL ở phía server. Bạn phải viết code riêng để đồng bộ CSDL IndexedDB ở client với CSDL ở server.</li><li><strong>Tìm kiếm toàn văn bản (Full text searching )</strong>: API không cung cấp giải pháp tương tự như LIKE trong SQL.</li></ul><p>Thêm vào đó, hãy cẩn thận trình duyệt có thể xóa CSDL trong những trường hợp sau đây:</p><ul><li><strong>User yêu cầu xóa</strong>: nhiều trình duyệt có cài đặt cho phép user xóa tất cả dữ liệu lưu trữ cho 1 website, bao gồm cả cookies, bookmarks, mật khẩu được lưu và dữ liệu IndexedDB.</li><li><strong>Trình duyệt đang chạy chế độ riêng tư</strong>: một vài trình duyệt có chế độ riêng tư như private browsing (Firefox) hay incognito (Chrome). Tại cuối session, trình duyệt sẽ xóa toàn bộ CSDL.</li><li><strong>Ổ cứng hoặc giới hạn cho phép bị đầy</strong></li><li><strong>Dữ liệu bị hỏng</strong></li></ul><p>Các trường hợp chính xác và khả năng của trình duyệt thay đổi theo thời gian, nhưng nguyên lý chung của các nhà phát triển trình duyệt là tạo ra nỗ lực tốt nhất để lưu giữ dữ liệu khi có thể.</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*kGDQYE70_z58D7na" alt=""></p><h1 id="Lua-chon-API-luu-tru"><a href="#Lua-chon-API-luu-tru" class="headerlink" title="Lựa chọn API lưu trữ"></a>Lựa chọn API lưu trữ</h1><p>Như đã đề cập ở trên, sẽ tốt hơn nếu chọn các API được hỗ trợ rộng rãi trong nhiều trình duyệt và cung cấp mô hình gọi bất đồng bộ nhằm nâng tối đa khả năng phản hồi của UI. Như 1 cách tự nhiên, ngữ cảnh như thế này sẽ dẫn đến các lựa chọn công nghệ:</p><ul><li>Với lưu trữ offline, dùng <a href="https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/cache-api" target="_blank" rel="noopener">Cache API</a>. API này tồn tại trong các trình duyệt hỗ trợ công nghệ <a href="https://jakearchibald.github.io/isserviceworkerready/" target="_blank" rel="noopener">Service Worker</a>, cần thiết để xây dựng app offline.</li><li>Để lưu trữ trạng thái của ứng dụng và các dữ liệu do người dùng tạo ra, sử dụng IndexedDB. Nó cho phép user làm việc offline trên nhiều trình duyệt hơn so với những trình duyệt chỉ hỗ trợ Cache API.</li></ul><p><a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=classes-inheritance-transpiling-outro" target="_blank" rel="noopener">SessionStack</a> sử dụng các API lưu trữ khác nhau. Ví dụ, thư viện tích hợp vào trong webapp của khách hàng dùng cả cookies &amp; session storage. Lý do là thư viện đó cần thu thập các dữ liệu chẳng hạn như các sự kiện, thay đổi trên DOM, dữ liệu mạng, biệt lệ, thông tin debug, vân vân, rồi sau đó gửi về server. Họ thu thập dữ liệu như vậy từ session của người dùng nhưng họ cần 1 cách chính xác để xác định khi nào session của user bắt đầu và kết thúc.</p><p>Họ cân nhắc 1 session sẽ là toàn bộ chu kỳ sử dụng webapp từ lúc bắt đầu, bao gồm cả xem trang và điều hướng cho đến khi user đóng trình duyệt hay tab và không quay trở lại trong vài phút, phần này họ dùng 1 sự kết hợp của session storage &amp; logic ở phía server. Còn gì nữa nào, họ cho phép bạn xác định từng người dùng cuối để có thể cung cấp cho bạn dữ liệu người dùng trên mỗi session. Họ dựa vào cookies để làm việc này (giống như các công cụ giám sát/phân tích).</p><p>Trong ứng dụng của họ, bạn có thể xem (xem theo yêu cầu hoặc thời gian thực) những sự kiện đã thu tập dưới dạng video được tái tạo lại cách mà user gặp phải các vấn đều, họ sử dụng chủ yếu là cookies bởi vì serivce RESTful của họ về cơ bản thì cần authentication token để authenticate, authorize và xác nhận request.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 16 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;h1 id=&quot;Khai-quat&quot;&gt;&lt;a href=&quot;#Khai-quat&quot; class=&quot;headerlink&quot; title=&quot;Khái quát&quot;&gt;&lt;/a&gt;Khái quát&lt;/h1&gt;&lt;p&gt;Lựa chọn cơ chế lưu trữ đúng đắn cho thiết bị lưu trữ ở local rất quan trọng khi thiết kế webapp. Một engine lưu trữ tốt sẽ đảm bảo thông tin của bạn được lưu chắc chắn, giảm băng thông và cải thiện sự phản hồi. Chiến lược lưu trữ bộ nhớ đệm phù hợp là thành phần cốt lõi cho phép trải nghiệm mobile web offline, càng ngày càng có nhiều người dùng cảm thấy rằng như đó là trải nghiệm mặc định phải có.&lt;/p&gt;
&lt;p&gt;Trong chương này, chúng ta sẽ thảo luận về những API lưu trữ có sẵn &amp;amp; các service và cung cấp một số hướng dẫn làm thế nào để lựa chọn đúng loại cho webapp của bạn.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P15: Bên trong Class &amp; Inheritance + Transpiling với Babel &amp; Typescript</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P15-Ben-trong-Class-Inheritance-Transpiling-voi-Babel-Typescript.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P15-Ben-trong-Class-Inheritance-Transpiling-voi-Babel-Typescript.html</id>
    <published>2018-11-25T09:37:00.000Z</published>
    <updated>2018-11-25T09:40:14.437Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 15 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Ngày nay, cách phổ biến nhất để dựng cấu trúc của bất kỳ dự án phần mềm nào là sử dụng class. Trong bài viết này, chúng ta sẽ cùng khám phá các cách khác nhau để triển khai class trong Javascript và làm thế nào ta có thể xây dựng cây thứ bậc của class (class hierarchy). Chúng ta sẽ bắt đầu bằng cách đào sâu tìm hiểu cách hoạt động của prototype và phân tích những cách để giả lập kế thừa class trong các thư viện nổi tiếng. Tiếp đến ta sẽ xem làm cách nào mà transpiling có thể thêm những tính năng không được hỗ trợ chính thức cho ngôn ngữ và cách mà nó được dùng trong Babel &amp; Typescript để giới thiệu về sự hỗ trợ của class trong ECMAScript 2015. Cuối cùng, ta sẽ kết thúc với một vài ví dụ về class được triển khai native trong V8.<br><a id="more"></a></p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Trong Javascript, về bản chất không có kiểu dữ liệu nguyên thủy và mọi thứ tạo ra đều là object. Ví dụ, nếu ta tạo 1 string:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">"SessionStack"</span>;</span><br></pre></td></tr></table></figure><p>Thì chúng ta có thể gọi nhiều phương thức khác nhau trên object vừa mới được tạo ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.repeat(<span class="number">2</span>)); <span class="comment">// SessionStackSessionStack</span></span><br><span class="line"><span class="built_in">console</span>.log(a.toLowerCase()); <span class="comment">// sessionstack</span></span><br></pre></td></tr></table></figure><p>Không giống như các ngôn ngữ khác, trong Javascript, khai báo string hay number sẽ tự động tạo ra một object mà nó sẽ đóng gói giá trị đó và cung cấp nhiều phương thức khác nhau có thể thực thi được kể cả với các kiểu dữ liệu nguyên thủy.</p><p>Một sự thật thú vị khác là những kiểu dữ liệu phức tạp, chẳng hạn như array, cũng là object. Nếu bạn nhìn kỹ hơn vào typeof của một array, bạn sẽ thấy nó là object. Số index của mỗi phần tử trong danh sách chính là thuộc tính của object. Vì thế khi bạn truy xuất một phần tử bằng số index trong array, bạn thực ra chỉ truy xuất vào thuộc tính của object array và trả về giá trị của nó. Khi nói về vấn đề lưu trữ dữ liệu thì 2 định nghĩa sau là giống hệt nhau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [“SessionStack”];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = &#123;</span><br><span class="line">  “<span class="number">0</span>”: “SessionStack”,</span><br><span class="line">  “length”: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kết quả là thời gian cần để truy xuất 1 phần tử trong array và 1 thuộc tính của object là như nhau. Thật khó để nhận ra. Trước đây, trong 1 project, tác giả phải thực hiện quá trình tối ưu hóa rất lớn cho một đoạn code quan trọng. Sau khi thử tất cả các lựa chọn dễ, tác giả đã thay thế toàn bộ object được dùng trong project bằng array. Về lý thuyết, truy xuất 1 phần tử trong 1 array thì nhanh hơn truy xuất 1 key trong hash map (bản đồ băm). Tác giả đã ngạc nhiên rằng cách làm này không mang lại một chút hiệu quả hơn với hiệu năng. Trong Javascript, cả array và object đều được triển khai về việc truy xuất 1 key trong hash map và sẽ tốn cùng 1 lượng thời gian như nhau.</p><h1 id="Gia-lap-class-voi-prototype"><a href="#Gia-lap-class-voi-prototype" class="headerlink" title="Giả lập class với prototype"></a>Giả lập class với prototype</h1><p>Khi nghĩ về object, thứ đầu tiên xuất hiện chính là class. Tất cả chúng ta thông thường đều xây dựng cấu trúc của ứng dụng dựa trên class và các mối quan hệ giữa chúng với nhau. Mặc dù object trong Javascript xuất hiện khắp nơi, ngôn ngữ này lại không sử dụng kiểu kế thừa truyền thống dựa trên class. Thay vào đó nó dùng <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model" target="_blank" rel="noopener">prototype</a>.<br>[<img src="https://cdn-images-1.medium.com/max/1000/0*SufKRGfPZIDlw1OG" alt=""></p><p>Trong Javascript, mọi object được kết nối đến object khác - chính là prototype của nó. Khi bạn thử truy xuất 1 thuộc tính hoặc phương thức trên 1 object, quá trình tìm kiếm (thuộc tính/phương thức) sẽ bắt đầu với chính object đó trước. Nếu không tìm thấy thì nó sẽ tiếp tục với prototype của object đó.</p><p>Chúng ta sẽ thử với 1 ví dụ đơn giản về định nghĩa constructor cho 1 class:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Component.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ta thêm hàm render vào prototype bởi vì chúng ta muốn mỗi instance của Component đều có thể tìm thấy nó. Khi bạn gọi phương thức này trên mỗi instance của class Component, quá trình tìm kiếm đầu tiên sẽ thực hiện trên chính instance đó. Sau đó nó tiếp tục thực hiện tìm trên prototype và tại đây thì phương thức render được tìm thấy.<br><img src="https://cdn-images-1.medium.com/max/1000/0*hZbijxS0vXu8vUmz" alt=""></p><p>Giờ ta thử mở rộng class Component ra, ta sẽ thêm vào một class con:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InputField</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.content = <span class="string">`&lt;input type="text" value="<span class="subst">$&#123;value&#125;</span>" /&gt;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nếu ta muốn InputField mở rộng chức năng của class Component và có thể gọi phương thức render của nó thì ta cần phải thay đổi prototype. Khi 1 phương thức được gọi trên instance của class con, ta không muốn tìm kiếm trong prototype trống rỗng của nó. Quá trình tìm kiếm sẽ tiếp tục ở class Component.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputField.prototype = <span class="built_in">Object</span>.create(<span class="keyword">new</span> Component());</span><br></pre></td></tr></table></figure><p>Bằng cách này, phương thức render có thể được tìm thấy trong prototype của class Component. Để có thể kế thừa, ta cần kết nối prototype của InputField đến 1 instance của class Component. Nhiều thư viện sử dụng phương thức <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener">Object.setPrototypeOf</a> để làm việc này.</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*avLiOV_zXLxOgBee" alt=""></p><p>Tuy nhiên đây không phải là việc duy nhất mà ta cần làm. Mỗi khi mở rộng 1 class, ta cần chú ý:</p><ul><li>Đặt prototype của class con là 1 instance của class cha</li><li>Gọi constructor của class cha trong constructor của class con để quá trình khởi tạo logic trong constructor của class cha có thể được thực thi.</li><li>Giới thiệu cách truy xuất phương thức từ class cha. Bạn cần phải làm thế khi muốn ghi đè 1 phương thức và bạn muốn gọi đến phần triển khai gốc trong phương thức ở class cha.</li></ul><p>Như bạn thấy thì nếu muốn sử dụng tất cả tính năng của kế thừa dựa trên class thì bạn cần thực thi phần logic phức tạp này mỗi lần kế thừa. Mỗi khi bạn cần tạo ra nhiều class thì tốt nhất là đóng gói mớ logic ấy trong 1 (hoặc vài) hàm để có thể tái sử dụng. Đây là cách mà các developer trước đây giải quyết vấn đề kế thừa dựa trên class - bằng cách giả lập với nhiều thư viện khác nhau. Những giải pháp này trở nên rất phổ biến và rõ ràng là có thiếu sót trong ngôn ngữ Javascript. Đó là lý do mà cú pháp mới để tạo class và hỗ trợ kế thừa class được giới thiệu trong bản sửa đổi lớn đầu tiên của ECMAScript 2015.</p><h1 id="Transpiling-class"><a href="#Transpiling-class" class="headerlink" title="Transpiling class"></a>Transpiling class</h1><p>Khi tính năng mới của ES6 (hay ECMAScript 2015) được đề xuất, cộng đồng Javascript developer không ngồi yên chờ đợi tất cả các engine và trình duyệt bắt đầu hỗ trợ nó. Một cách tốt hơn để đạt được là thông qua transpile. Nó cho phép 1 đoạn code viết trong ECMAScript 2015 được biến đổi thành Javascript mà tất cả trình duyệt đều có thể hiểu. Bao gồm cả khả năng viết class với kế thừa dựa trên class và transpile chúng thành code hoạt động được.<br><img src="https://cdn-images-1.medium.com/max/1000/0*QhRSzkngh6Aty-nD" alt=""></p><p>Một trong số những transpiler nổi tiếng nhất cho Javascript là Babel. Giờ thì cùng xem transpile hoạt động thế nào, ta sẽ áp dụng nó cho đoạn code về Component viết ở trên nhé:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(content) &#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> component = <span class="keyword">new</span> Component(<span class="string">'SessionStack'</span>);</span><br><span class="line">component.render();</span><br></pre></td></tr></table></figure><p>Và đây là những gì Babel transpile ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Component = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Component);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.content = content;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(Component, [&#123;</span><br><span class="line">    key: <span class="string">'render'</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.content);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Component;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>Như bạn thấy, code được biến đổi thành ECMAScript 5, loại có thể được thực thi trên bất kỳ môi trường nào. Ngoài ra còn có 1 số hàm được thêm vào. Chúng là 1 phần của thư viện Babel tiêu chuẩn.</p><p>Hàm _classCallCheck và _createClass có mặt như 1 phần trong kết quả biên dịch. Hàm đầu tiên đảm bảo hàm constructor không bao giờ được gọi như 1 hàm bình thường. Điều này được thực hiện bằng việc kiểm tra có hay không ngữ cảnh mà trong đó hàm được đánh giá là 1 instance của object Component. Code sẽ kiểm tra nếu<br>nó trỏ đến instance. Hàm thứ 2 _createClass xử lý việc tạo ra các thuộc tính cho object và được truyền vào dưới dạng danh sách các object với key &amp; value.</p><p>Để khám phá về cách kế thừa hoạt động ra sao thì ta cùng phân tích class InputField được kế thừa từ Component</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputField</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">const</span> content = <span class="string">`&lt;input type="text" value="<span class="subst">$&#123;value&#125;</span>" /&gt;`</span>;</span><br><span class="line">        <span class="keyword">super</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kết quả sau khi xử lý transpile với Babel:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> InputField = <span class="function"><span class="keyword">function</span> (<span class="params">_Component</span>) </span>&#123;</span><br><span class="line">  _inherits(InputField, _Component);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">InputField</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, InputField);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> content = <span class="string">'&lt;input type="text" value="'</span> + value + <span class="string">'" /&gt;'</span>;</span><br><span class="line">    <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, (InputField.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(InputField)).call(<span class="keyword">this</span>, content));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> InputField;</span><br><span class="line">&#125;(Component);</span><br></pre></td></tr></table></figure><p>Trong ví dụ trên, logic kế thừa được đóng gói trong hàm _inherits. Nó thực hiện cùng y chang hành động mà chúng ta đã mô tả trong phần trước bằng cách cài đặt prototype của class con trở thành 1 instance của class cha.</p><p>Để transpile code, Babel thực hiện nhiều quá trình chuyển đổi. Đầu tiên code ECMAScript 2015 được parse và biến đổi thành một dạng thể hiện trung gian, gọi là <strong>Abstract Syntax Tree</strong>, chính là chủ đề ta đã thảo luận ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-14---Parsing--Abstract-Syntax-Tree---meo-giam-toi-da-thoi-gian-parse" target="_blank" rel="noopener">bài trước</a>. Sau đó cây này được biến đổi lần nữa thành 1 cây AST khác mà mỗi node của nó được biến đổi thành phần tương ứng trong ECMAScript 5. Cuối cùng cây AST được chuyển ngược lại thành code.</p><h1 id="AST-trong-Babel"><a href="#AST-trong-Babel" class="headerlink" title="AST trong Babel"></a>AST trong Babel</h1><p>Một cây AST sẽ có nhiều node, mỗi node chỉ có duy nhất 1 node cha. Trong Babel, tồn tại 1 kiểu cơ bản cho các node. Nó chưa thông tin về loại node và vị trí của chúng trong code. Có nhiều loại node khác nhau, chẳng hạn như Literals thể hiện string, number, null, vân vân. Cũng có cả node Statements dành cho các luồng kiểm soát (if) và vòng lặp (for, while). Có cả node đặc biệt dành cho class. Nó là 1 con (child) của class Node cơ bản. Nó mở rộng bằng cách thêm các trường để lưu tham chiếu đến class cơ bản và body của class như là 1 node riêng biệt.</p><p>Giờ ta sẽ biến đổi đoạn code sau thành cây AST</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(content) &#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đây là kết quả:<br><img src="https://cdn-images-1.medium.com/max/1000/0*-OqUfzpRtgDJQjXY" alt=""></p><p>Sau khi tạo ra cây AST, mỗi node được biến đổi thành node ECMAScript 5 tương đương với nó và chuyển ngược lại thành code thường theo tiêu chuẩn của ECMAScript 5. Quá trình này được thực hiện bằng 1 tiến trình tìm kiếm node nằm ở vị trí xa nhất với root node và biến đổi chúng thành code. Sau đó node cha của nó sẽ được biến đổi bằng đoạn code đã sinh ra cho các node con của nó. Quá trình này được gọi là <a href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank" rel="noopener">depth-first traversal</a></p><p>Trong ví dụ trên, đầu tiên code của 2 node MethodDefinition sẽ được sinh ra, theo sau nó là code của node ClassBody và cuối cùng là node ClassDeclaration</p><h1 id="Transpile-voi-TypeScript"><a href="#Transpile-voi-TypeScript" class="headerlink" title="Transpile với TypeScript"></a>Transpile với TypeScript</h1><p>Một framework phổ biến khác hỗ trợ khả năng transpile chính là TypeScript. Nó giới thiệu cú pháp kiểu mới để viết ứng dụng Javascript và được biến đổi thành ECMAScript 5 mà có thể chạy trên bất kỳ trình duyệt hay engine nào. Dưới đây là phần triển khai của class Component trong TypeScript:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    content: string;</span><br><span class="line">    <span class="keyword">constructor</span>(content: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Và đây là cây AST được sinh ra:<br><img src="https://cdn-images-1.medium.com/max/1000/0*j3zkSjnrL4fnCK3A" alt=""></p><p>Nó hỗ trợ kế thừa:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputField</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value: string) &#123;</span><br><span class="line">        <span class="keyword">const</span> content = <span class="string">`&lt;input type="text" value="<span class="subst">$&#123;value&#125;</span>" /&gt;`</span>;</span><br><span class="line">        <span class="keyword">super</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kết quả transpile ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> InputField = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</span><br><span class="line">    __extends(InputField, _super);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">InputField</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> content = <span class="string">"&lt;input type=\"text\" value=\""</span> + value + <span class="string">"\" /&gt;"</span>;</span><br><span class="line">        _this = _super.call(<span class="keyword">this</span>, content) || <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> _this;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> InputField;</span><br><span class="line">&#125;(Component));</span><br></pre></td></tr></table></figure><p>Kết quả cuối cùng một lần nữa lại là ECMAScript 5 với 1 số hàm thêm vào từ thư viện của TypeScript. Logic được đóng gói trong __extends là giống y hệt như những gì chúng ta đã thảo luận ở phần trước.</p><p>Với Babel và TypeScript càng ngày càng được đón nhận nồng nhiệt, class tiêu chuẩn và kế thừa dựa trên class trở thành 1 cách chuẩn của phần cấu trúc những ứng dụng Javascript. Điều này đẩy nhanh tiến độ về native support (hỗ trợ tự nhiên) cho class trên trình duyệt.</p><h1 id="Native-support-ho-tro-tu-nhien"><a href="#Native-support-ho-tro-tu-nhien" class="headerlink" title="Native support (hỗ trợ tự nhiên)"></a>Native support (hỗ trợ tự nhiên)</h1><p>Vào năm 2014, <a href="https://www.chromestatus.com/feature/4633745457938432" target="_blank" rel="noopener">native support cho class</a> được giới thiệu trong Chrome. Nó cho phép cú pháp khai báo class được thực hiện mà không cần phải dùng đến các thư viện hay transpiler.<br><img src="https://cdn-images-1.medium.com/max/1000/0*jJuHfRMipW8PPcb0" alt=""></p><p>Quá trình triển khai class một cách tự nhiên được gọi là syntax sugar (cú pháp ngọt ngào). Đây chỉ là 1 cú pháp dễ chịu có thể biên dịch xuống thành cùng loại với kiểu nguyên thủy đang được hỗ trợ mặc định trong ngôn ngữ. Bạn có thể dùng kiểu định nghĩa class mới, dễ dùng hơn, nhưng cuối cùng nó cũng quay về tạo constructor và gán prototypes</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*c2HpOiUYMimMXHv2" alt=""></p><h1 id="Su-ho-tro-cua-V8"><a href="#Su-ho-tro-cua-V8" class="headerlink" title="Sự hỗ trợ của V8"></a>Sự hỗ trợ của V8</h1><p>Cùng xem cách hoạt động của native support cho class trong ECMAScript 2015 trên V8. Như ta đã thảo luận ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-14---Parsing--Abstract-Syntax-Tree---meo-giam-toi-da-thoi-gian-parse" target="_blank" rel="noopener">bài trước</a>, đầu tiên cú pháp mới cần được parse thành code Javascript cũ và thêm vào cây AST. Vì thế kết quả của định nghĩa class là 1 node mới (loại <a href="https://github.com/v8/v8/blob/a86fa968136f0ec6237f51a0d535fbd932868d4d/src/ast/ast.h#L2421" target="_blank" rel="noopener">ClassLiteral</a>) được thêm vào cây.</p><p>Node này chứa 1 vài thứ. Đầu tiên, nó giữ constructor ở 1 hàm khác. Nó cũng chứa 1 danh sách các thuộc tính của class. Chúng có thể là phương thức, getter, setter, các trường public hay private. Node này cũng chứa luôn tham chiếu đến class cha mà chính class cha này lại nữa chứa constructor &amp; danh sách các thuộc tính và class cha khác (của nó).</p><p>Một khi ClassLiteral này được <a href="https://github.com/v8/v8/blob/be3a1df9008ee78d1101855d3044db54a203f515/src/interpreter/bytecode-generator.cc#L1818" target="_blank" rel="noopener">chuyển thành code</a>, nó được dịch 1 lần nữa thành các hàm và prototypes.</p><p>Với team tại <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=classes-inheritance-transpiling-outro" target="_blank" rel="noopener">SessionStack</a>, tối ưu hóa từng phần nhỏ của code là cực kỳ quan trọng những cũng là 1 công việc rất thách thức. Có 2 lý do cho việc cần thiết phải tối ưu hóa mức độ cao.</p><p>Đầu tiên, thư viện của họ sẽ tích hợp với trong webapp, nó thu thập dữ liệu từ phiên làm việc của user, chẳng hạn như sự kiện, thay đổi trên DOM, dữ liệu mạng, biệt lệ, thông báo lỗi, vân vân. Thu thập thông tin mà không làm ảnh hưởng đến hiệu năng của webapp là 1 thách thức khó mà team của tác giả đã giải quyết thành công.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 15 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Ngày nay, cách phổ biến nhất để dựng cấu trúc của bất kỳ dự án phần mềm nào là sử dụng class. Trong bài viết này, chúng ta sẽ cùng khám phá các cách khác nhau để triển khai class trong Javascript và làm thế nào ta có thể xây dựng cây thứ bậc của class (class hierarchy). Chúng ta sẽ bắt đầu bằng cách đào sâu tìm hiểu cách hoạt động của prototype và phân tích những cách để giả lập kế thừa class trong các thư viện nổi tiếng. Tiếp đến ta sẽ xem làm cách nào mà transpiling có thể thêm những tính năng không được hỗ trợ chính thức cho ngôn ngữ và cách mà nó được dùng trong Babel &amp;amp; Typescript để giới thiệu về sự hỗ trợ của class trong ECMAScript 2015. Cuối cùng, ta sẽ kết thúc với một vài ví dụ về class được triển khai native trong V8.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P14: Parsing, Abstract Syntax Tree &amp; mẹo giảm tối đa thời gian parse</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P14-Parsing-Abstract-Syntax-Tree-meo-giam-toi-da-thoi-gian-parse.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P14-Parsing-Abstract-Syntax-Tree-meo-giam-toi-da-thoi-gian-parse.html</id>
    <published>2018-11-25T09:32:00.000Z</published>
    <updated>2018-11-25T09:35:26.778Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 14 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Chúng ta đều biết rằng những thứ lộn xộn có thể hợp thành 1 thứ lớn hơn gọi là Javascript. Một đoạn code không chỉ có thể di chuyển qua mạng mà nó còn phải được parse, biên dịch sang bytecode và cuối cùng thực thi. Trong các bài trước, chúng ta đã thảo luận về những thứ chẳng hạn như JS engine, runtime, callstack cũng như engine V8 được dùng chủ yếu trong Chrome và NodeJS. Tất cả đều đóng vai trò quan trọng trong toàn bộ quá trình thực thi của Javascript. Chủ đề mà chúng ta sẽ tìm hiểu hôm nay cũng không kém quan trọng: chúng ta sẽ nghiên cứu xem làm thế nào mà đa số các engine JS parse văn bản thành một thứ gì đó có nghĩa đối với máy móc, những gì xảy ra sau đó và làm thế nào để web developer như chúng ta có thể tận dụng những kiến thức đó làm điểm mạnh.<br><a id="more"></a></p><h1 id="Ngon-ngu-lap-trinh-hoat-dong-nhu-the-nao"><a href="#Ngon-ngu-lap-trinh-hoat-dong-nhu-the-nao" class="headerlink" title="Ngôn ngữ lập trình hoạt động như thế nào?"></a>Ngôn ngữ lập trình hoạt động như thế nào?</h1><p>Cùng lùi lại 1 chút và xem xem ngôn ngữ lập trình hoạt động thế nào. Không cần biết là bạn đang xài ngôn ngữ gì, bạn sẽ luôn cần một phần mềm có thể đọc mã nguồn và khiến cho máy tính thực hiện một điều gì đó. Phần mềm này có thể là trình thông dịch hoặc trình biên dịch.</p><p>Không cần biết bạn đang xài ngôn ngữ thông dịch (Javascript, Python, Ruby) hay ngôn ngữ biên dịch (C#, Java, Rust), luôn luôn có 1 điểm chung giữa chúng: parse đoạn mã nguồn từ văn bản gốc thành một cấu trúc dữ liệu được gọi là Abstract Syntax Tree (AST).</p><p>Các AST không chỉ thể hiện mã nguồn dưới dạng cấu trúc mà chúng còn đóng vai trò quan trọng trong phân tích ngữ nghĩa, chính là nơi mà trình biên dịch xác nhận tính đúng đắn và cách sử dụng phù hợp của chương trình cũng như các phần tử của ngôn ngữ. Về sau, các AST được dùng để sinh ra bytecode hoặc mã máy.</p><h1 id="Cac-ung-dung-AST"><a href="#Cac-ung-dung-AST" class="headerlink" title="Các ứng dụng AST"></a>Các ứng dụng AST</h1><p>AST không chỉ được dùng trong trình thông dịch và trình biên dịch ngôn ngữ, chúng còn có nhiều ứng dụng trong thế giới máy tính. Một trong số đó là dùng chúng là phân tích code tĩnh. Các nhà phân tích tĩnh không thực thi code, họ cần hiểu cấu trúc của code. Ví dụ: bạn muốn triển khai một công cụ tìm sự giống nhau giữa các kiến trúc code để từ đó bạn có thể refactor nhằm giảm sự trùng lặp. Bạn có thể làm việc này bằng cách so sánh string bình thường nhưng cách triển khai thì khá cơ bản và giới hạn.</p><p>Một cách tự nhiên, nếu bạn có hứng thú triển khai một công cụ thì bạn không cần phải viết riêng cho nó 1 cái parser. Có rất nhiều triển khai mã nguồn mở có sẵn có khả năng tương thích toàn diện với thông số kỹ thuật của Ecmascript. Ví dụ: Esprima và Acorn. Cũng có rất nhiều công cụ có thể giúp ta với sản phẩm nhận được từ parser, hay còn gọi là AST. Các AST cũng được dùng nhiều trong phần triển khai của các code transpiler. Ví dụ: bạn cần triển khai một bộ transpiler để chuyển code Python thành Javascript. Ý tưởng cơ bản là ta cần một Python transpiler để sinh ra cây AST - thứ mà ta cần để có thể sinh ra code Javascript sau này.</p><p>Bạn có thể tự hỏi, làm sao như vậy được? Điểm mấu chốt là các AST chỉ là một điểm khác biệt về cách thể hiện một vài ngôn ngữ. Trước khi parse, nó thể hiện dưới dạng văn bản đi kèm theo một số quy luật nhất định để hình thành nên 1 ngôn ngữ. Sau khi parse, nó thể hiện dưới dạng một kiến trúc dạng cây chứa chính xác cùng 1 thông tin với văn bản đầu vào. Vì thế, bạn có thể luôn luôn có thể làm ngược lại và go back về dạng biểu diễn văn bản.</p><h1 id="Javascript-parsing"><a href="#Javascript-parsing" class="headerlink" title="Javascript parsing"></a>Javascript parsing</h1><p>Giờ thì cùng tìm hiểu cây AST được xây dựng như thế nào. Đầu tiên ta có một hàm Javascript đơn giản như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parser sẽ sản sinh ra cây AST như sau:<br><img src="https://cdn-images-1.medium.com/max/1000/0*mSOIiWpkctkD0Gfg." alt=""></p><p>Lưu ý rằng vì mục đích dễ nhìn và đẹp thì hình trên chỉ là phiên bản tối giản của sản phẩm thực sự từ parser. Cây AST thật sẽ phức tạp hơn rất nhiều. Tuy nhiên, mục đích của chúng ta là có được ý tưởng cơ bản về việc mã nguồn sẽ biến thành cái gì trước khi nó được thực thi. Nếu bạn muốn xem cây AST thứ thiệt trông như thế nào thì bạn có thể <a href="https://astexplorer.net/" target="_blank" rel="noopener">vào đây</a>. Đó là 1 công cụ online, bạn chỉ cần nhập code Javascript vào và nó sẽ sinh ra cây AST cho đoạn code đó.</p><p>Bạn sẽ tự hỏi tại sao chúng ta cần biết về cách hoạt động của Javascript parser. Sau tất cả thì nó thuộc về trách nhiệm của trình duyệt. Và về mặt nào đó thì đúng là như thế. Tuy nhiên, bạn có thể xem hình bên dưới, đó là đồ thị biểu diễn tổng thời gian phân phối cho từng bước trong quá trình thực thi code Javascript. Hãy nhìn kỹ hơn và thử xem có thấy được gì thú vị không.<br><img src="https://cdn-images-1.medium.com/max/1000/0*eEArxn147Ev8xf5n." alt=""></p><p>Bạn có thấy được không? Nhìn kỹ xem. Trung bình thì trình duyệt chiếm khoảng 15-20% tổng thời gian thực thi để parse Javascript. Những con số này không phải là bịa đặt. Chúng là số liệu thống kê từ những ứng dụng và website có thật đang bằng cách này hay cách khác sử dụng Javascript. Giờ thì 15% có vẻ như không nhiều lắm, nhưng tin tôi đi, nó có giá trị đấy. Một app SPA tiêu chuẩn sẽ load khoảng 0.4MB code Javascript và trình duyệt tiêu tốn xấp xỉ 370ms để parse nó.</p><p>Thêm một lần nữa, bạn sẽ nói rằng nó chẳng đáng bao nhiêu thời gian cả. Và rõ ràng con số đó quá nhỏ. Tuy nhiên nhớ kỹ rằng đây chỉ là thời gian cần để parse code Javascript thành cây AST. Chưa bao gồm thời gian thực thi chính nó hay bất kỳ tiến trình nào diễn ra trong khi load trang (ví dụ như <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-11---Render-engine---meo-toi-uu-hoa-hieu-nang-render" target="_blank" rel="noopener">CSS &amp; HTML rendering</a>). Và tất cả thông số này mới chỉ thể hiện cho desktop. Khi chúng ta đi sâu hơn trên mobile, mọi thứ sẽ trở nên phức tạp hơn nhiều. <strong>Thời gian dành cho việc parse trên mobile thường có thể nhiều hơn 2-5 lần so với trên desktop.</strong></p><p><img src="https://cdn-images-1.medium.com/max/1000/0*3R6-AyKY1831P10d." alt=""></p><p>Đồ thị trên thể hiện thời gian parse của 1 gói code Javascript 1MB trên rất nhiều thiết bị mobile &amp; desktop thuộc nhiều phân khúc khác nhau.</p><p>Gì nữa nào? Web app đang càng trở nên phức tạp theo từng phút cũng như càng có nhiều business logic phải xử lý ở phía client để có thể mang lại trải nghiệm giống hệt như native app. Bạn có thể dễ dàng hiểu được những điều đó ảnh hưởng như thế nào đến website/wepapp của bạn. Tất cả những gì bạn cần là mở dev tool của trình duyệt lên và để nó đo đạc lượng thời gian dành cho parsing, biên dịch và mọi thứ diễn ra trên trình duyệt cho tới khi trang web được load hoàn toàn.<br><img src="https://cdn-images-1.medium.com/max/1000/0*A5ucCHOZsxXyHMfN." alt=""></p><p>Thật không may, không có dev tool nào cho các trình duyệt mobile. Nhưng đừng lo lắng, điều này không có nghĩa rằng bạn không thể làm gì được. Đây là lý do những công cụ như <a href="https://github.com/danielmendel/DeviceTiming" target="_blank" rel="noopener">DeviceTiming</a> tồn tại. Nó có thể giúp bạn đo đạc thời gian parse và thực thi cho các đoạn code trong một môi trường kiểm soát. Nó hoạt động bằng cách gói gọn code local với đoạn code đo lường, vì thế nên mỗi lần trang web của bạn được truy cập từ các thiết bị khác nhau, bạn có thể đo đạc thời gian parse và thực thi.</p><p>Điều tốt là engine Javascript đã làm rất nhiều thứ nhằm tránh cách công việc thừa thãi và tối hưu hóa nhiều hơn. Dưới đây là 1 vài thứ mà các engine của những trình duyệt lớn đã làm.</p><p>Ví dụ với V8, nó thực hiện script streaming &amp; code caching. Script streaming nghĩa là các đoạn code bất đồng bộ &amp; bị trì hoãn sẽ được parse trong 1 tiến trình riêng ngay khi quá trình download bắt đầu. Nó giúp cho quá trình parsing gần như hoàn thành ngay lập tức sau khi đoạn code (script) được tải xong. Kết quả là các trang sẽ load nhanh hơn khoảng 10%.</p><p>Code Javascript thường được biên dịch thành bytecode mỗi khi có một lượt truy cập trang. Tuy nhiên, cục bytecode này lại bị bỏ đi khi người dùng truy cập đến trang khác. Điều này xảy ra vì code được biên dịch phụ thuộc rất nhiều vào trạng thái và ngữ cảnh của máy tại thời điểm biên dịch. Đây là lý do Chrome 42 giới thiệu bytecode caching (bộ đệm bytecode). Đây là một kỹ thuật lưu trữ code đã biên dịch ở local để khi user quay trở lại trang cũ trước đó thì tất cả mọi hoạt động như download, parse, biên dịch… có thể bỏ qua. Nó cho phép Chrome tiết kiệm 40% thời gian parse &amp; thực thi. Thêm nữa, kết quả nó tiết kiệm pin nhiều hơn nếu chạy trên các thiết bị mobile.</p><p>Trong Opera, engine <a href="https://dev.opera.com/blog/carakan/" target="_blank" rel="noopener">Carakan</a> có thể dùng lại kết quả biên dịch từ chương trình khác vừa mới được biên dịch gần đây. Không có các yêu cầu cụ thể nào về việc code phải đến từ cùng 1 trang hay domain. Kỹ thuật caching này thực sự rất hữu ích và có thể hoàn toàn bỏ qua bước biên dịch. Nó phụ thuộc vào hành vi tiêu chuẩn của user và ngữ cảnh lươt web: mỗi khi user thực hiện cùng chuỗi hành trình với một user khách trên app/website thì cùng 1 đoạn code Javascript sẽ được tải. Tuy nhiên, Opera đã sớm thay thế Carakan bằng Google V8.</p><p>Bộ engine <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" target="_blank" rel="noopener">SpiderMonkey</a> của Firefox không lưu cache bất kỳ thứ gì. Nó đại khái là chuyển qua dùng một thao tác giám sát để đếm xem 1 đoạn code Javascript được thực thi bao nhiêu lần. Dựa trên số đếm này nó xác định phần nào của code đang hot và cần được tối ưu hóa.</p><p>Rõ ràng có một số người lựa chọn không làm gì cả. <a href="http://en.wikipedia.org/wiki/Maciej_Stachowiak" target="_blank" rel="noopener">Maciej Stachowiak</a>, lead developer của Safari, chỉ định rằng Safari không thực hiện bất kỳ hoạt động cache nào cho bytecode đã biên dịch. Có vẻ như họ đã có cân nhắc về việc này nhưng không triển khai nó bởi vì nó chỉ nhỏ hơn 2% tổng thời gian thực thi.</p><p>Những hoạt động tối ưu hóa không trực tiếp ảnh hưởng đến chuyện parsing của code Javascript nhưng chúng chắc chắn đang làm tốt nhất có thể để bỏ qua nó một cách hoàn toàn. Còn cách tối ưu hóa nào tốt hơn là tối ưu hóa hoàn toàn?</p><p>Có nhiều thứ chúng ta có thể làm để cải thiện thời gian load app ban đầu. Ta có thể làm tối giản lượng code Javascript đang sử dụng: ít code, ít parse, ít thực hi. Để làm được điều này, ta cần đưa ra vừa đúng lượng code cần thiết cho một tính năng cụ thể thay vì load 1 cục thiệt to lớn và dùng nó vào mọi thứ. Ví dụ, pattern <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" target="_blank" rel="noopener">PRPL</a> có thuyết giảng về mô hình chuyển giao code như vậy. Nói cách khác, ta có thể kiểm tra các dependency và xem nếu như có gì đó thừa thãi không cần thiết làm chậm code của chúng ta. Về phần này thì hi vọng là sẽ có 1 topic riêng để nói về nó.</p><p>Mục đích của bài viết này là để thảo luận chúng ta - những web developer - có thể làm được gì để giúp cho Javascript parser có thể chạy nhanh hơn. Và chính là đây, các Javascript parser hiện đại sử dụng các phỏng đoán để xác định nếu một đoạn code cụ thể nào đó chuẩn bị được thực thi ngay hoặc quá trình thực thi sẽ bị tạm ngưng và dời lại trong một thời điểm khác.</p><p>Dựa trên các phỏng đoán, parser sẽ làm hoặc là eager parsing (parse nhanh) hoặc là lazy parsing (parse từ từ). Eager parsing chạy xuyên suốt các hàm nào cần được biên dịch tức thời. Nó thực hiện 3 việc chính: xây dựng cây AST, xây dựng hệ thống cấp bậc (hierarchy) cho scope và tìm tất cả các lỗi cú pháp.</p><p>Lazy parsing thì ngược lại, nó chỉ được dùng cho các hàm chưa cần được biên dịch. Nó không xây dựng cây AST và cũng không tìm lỗi cú pháp. Nó chỉ xây dựng hệ thống cấp bậc cho scope và tiết kiệm được một nửa thời gian so với eager.</p><p>Rõ ràng đây không phải là ý tưởng mới. Kể cả trình duyệt như IE9 cũng hỗ trợ tối ưu hóa mặc dù nó chạy hơi thô sơ nếu như so với cách mà parser ngày nay hoạt động.</p><p>Giờ thì cùng xem một ví dụ về cách nó hoạt động. Giả sử ta có đoạn code sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(baz(<span class="number">100</span>, <span class="number">200</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Giống như ví dụ trước, code được đưa vào parser để phân tích cú pháp và trả ra cây AST. Vậy thì đây là những gì thực hiện theo từng dòng:</p><p>Định nghĩa hàm bar nhận 1 biến x và nó có 1 câu lệnh return trả về kết quả của phép tính cộng giữa x và 10.</p><p>Định nghĩa hàm baz nhận 2 biến (x và y). Nó có 1 câu lệnh return. Hàm này trả về kết quả của phép tính cộng giữa x và y.</p><p>Gọi hàm baz với 2 đối số là 100 và 200.</p><p>Tạo ra 1 lời gọi hàm đến console.log với giá trị là kết quả của lời gọi hàm trước đó.</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*60xiqW7kPsQg5ssn." alt=""></p><p>Điều gì vừa xảy ra vậy? Parser thấy có một định nghĩa hàm foo, định nghĩa bar và 1 hàm baz, một lời gọi đến hàm baz, một lời gọi đến hàm console.log. Chờ đã… có một số thứ parser đã làm hoàn toàn không liên quan. Đó là việc parse hàm bar. Tại sao lại không liên quan? Bởi vì hàm bar chưa bao giờ được gọi (ít nhất là cho tới thời điểm này). Đây chỉ là một ví dụ đơn giản và có vẻ như không bình thường nhưng nó xuất hiện trên rất nhiều app thực, có rất nhiều hàm được định nghĩa nhưng không bao giờ dùng đến.</p><p>Thay vì parse hàm bar, chúng ta có thể đánh dấu nó đã được khai báo nhưng không chỉ ra cụ thể nó làm gì. Parsing sẽ diễn ra khi cần thiết ngay trước khi hàm được thực thi. Và dĩ nhiên là lazy parsing cũng vẫn cần thiết để tìm toàn bộ body của hàm và tạo một khai báo cho hàm đó. Nó không cần cây cú pháp bởi vì nó vẫn chưa được xử lý. Thêm nữa, bộ nhớ heap vẫn chưa được cấp phát (phần này cũng chiếm 1 lượng tương đối trong tài nguyên hệ thống). Nói ngắn gọn thì bỏ qua một số bước trên sẽ cải thiện đáng kể hiệu năng.</p><p>Vậy nên nhìn lại ví dụ trên, ta có cây AST mới sẽ như thế này:<br><img src="https://cdn-images-1.medium.com/max/1000/0*IN688nPbgu8zYETe." alt=""></p><p>Lưu ý rằng hàm bar được khai báo và chấp nhận, nhưng chỉ có thế thôi. Chúng ta không làm gì với body của hàm. Trong trường hợp này, body của hàm chỉ có 1 câu lệnh return. Tuy nhiên, trong hầu hết các ứng dụng thực tế, nó có thể lớn hơn rất nhiều, bao gồm nhiều câu lệnh return, điền kiện, vòng lặp, định nghĩa các biến và kể cả các khai báo hàm lồng nhau. Tất cả những thứ này sẽ gây tốn thời gian cũng như tài nguyên hệ thống bởi vì hàm không bao giờ được gọi.</p><p>Đây là một ý tưởng cực kỳ đơn giản nhưng trong thực tế công việc thì việc triển khai nó lại không đơn giản. Dưới đây là một ví dụ mà chắc chắn không phải là trường hợp duy nhất. Toàn bộ phương thức sử dụng các hàm, vòng lặp, điều kiện, object, vân vân. Cơ bản là toàn bộ code cần được parse.</p><p>Ví dụ một mô hình phổ biến để triển khai Javascript module:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// toàn bộ logic của module</span></span><br><span class="line">    <span class="comment">// return về module.</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>Mô hình này dễ dàng nhận ra bởi các Javascript parser hiện đại và là một dấu hiệu cho thấy code bên trong có thể dùng eager parsing.</p><p>Vậy tại sao parser không mặc định lazy parsing? Nếu có gì đó được parse lazy thì nó phải được thực thi ngay lập tức và điều này thực sự gây ra sự chậm chạp. Một lazy parse được thực hiện và ngay sau đó là eager parse. Kết quả là tốc độ chậm hơn 50% khi so sánh với chỉ dùng 1 eager parse.</p><p>Đến lúc này ta đã có kiến thức cơ bản về phía hậu trường, giờ thì thử xem chúng ta có giúp gì cho parser được không. Ta có thể viết code theo cách mà các hàm có thể được parse tại thời điểm phù hợp. Có một pattern được xài chung giữa các parser: đóng gói hàm bên trong dấu ngoặc (). Đây luôn là một dấu hiệu tích cực cho parser hiểu rằng hàm sẽ được thực thi ngay lập tức. Nếu parser bắt gặp một dấu mở ngoặc ( và ngay liền sau đó là một định nghĩa hàm, nó sẽ parse eager hàm đó. Chúng ta có thể giúp parser bằng cách khai báo hàm một cách tường minh như vậy hàm sẽ được thực thi ngay lập tức.</p><p>Giả sử ta có hàm Javascript như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bởi vì không có dấu hiệu rõ ràng rằng hàm sẽ được thực thi ngay lập tức nên trình duyệt sẽ thực hiện lazy parse. Tuy nhiên, chúng ta biết rằng như vậy là không đúng nên ta có thể làm 2 việc.</p><p>Đầu tiên, ta lưu hàm vào trong 1 biến:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Lưu ý rằng ta vẫn giữ lại tên hàm foo giữa từ khóa function và dấu mở ngoặc (. Điều này tuy không cần thiết nhưng bạn bên làm vì trong trường hợp xử lý biệt lệ, stacktrace sẽ hiện ra tên cụ thể của hàm thay vì một chữ <anonymous> khô khan.</anonymous></p><p>Parser vẫn thực hiện lazy parse. Ta có thể ngăn chặn điều này bằng cách thêm một chi tiết nhỏ: gói hàm đó lại trong dấu ngoặc.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Tại thời điểm này, khi parser thấy dấu mở ngoặc ( ngay trước từ khóa function nó sẽ ngay lập tức thực hiện eager parsing.</p><p>Sẽ hơi khó để quản lý bởi vì chúng ta sẽ cần phải biết trong trường hợp nào thì parser chọn parse lazy hay eager. Thêm nữa ta cần phải suy nghĩ và tìm hiểu một hàm cụ thể nào đó có được gọi ngay lập tức hay không. Chúng ta chắc chắn không muốn làm vậy. Ít nhất thì nó sẽ làm cho code khó đọc &amp; khó hiểu hơn. Công cụ như Optimize.js có thể giúp ta rất nhiều. Mục đích duy nhất của nó là tối ưu hóa thời gian loaing ban đầu của code Javascript. Chúng thực hiện phân tích code tĩnh và chỉnh sửa lại để đóng gói những hàm nào cần được thực thi bên trong dấu ngoặc (), trình duyệt sẽ có thể parse eager và chuẩn bị chúng sẵn sàng để thực thi.</p><p>Chúng ta có thể tiếp tục code bình thường và có đc đoạn code sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, World!'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>Mọi thứ có vẻ tốt, hoạt động đúng như mong đợi và nhanh nữa. Bởi vì có dấu mở ngoặc ( trước khi khai báo hàm. Rất tuyệt. Dĩ nhiên rồi, trước khi đưa lên production ta cần minify để tiết kiệm dung lượng. Đoạn code sau là sản phẩm cuối cùng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'Hello, World!'</span>)&#125;();</span><br></pre></td></tr></table></figure><p>Một lần nữa, chúng có vẻ tốt phải không? Code hoạt động y như cũ. Nhưng có gì đó thiếu thiếu. Trình minify đã gỡ dấu ngoặc đóng gói bên ngoài hàm và thay vào đó thêm 1 dấu chấm than ! ngay trước hàm. Điều này nghĩa là parser sẽ bỏ qua nó và thực hiện lazy parse. Trên hết thì để có thể thực thi hàm nó sẽ thực hiện eager parse ngay sau khi lazy parse. Vậy thì lại làm code chạy chậm hơn. May mắn thay, chúng ta có những công cụ như Optimize.js giúp ta trong những trường hợp này. Truyền đoạn code đã minify vào Optimize.js và đây là kết quả đầu ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'Hello, World!'</span>)&#125;)();</span><br></pre></td></tr></table></figure><p>Giờ thì ta đã có thành phẩm tốt nhất: code được minify và parser dễ dàng xác định được những hàm nào cần parse eager hàm nào cần parse lazy.</p><h1 id="Bien-dich-truoc-Pre-compilation"><a href="#Bien-dich-truoc-Pre-compilation" class="headerlink" title="Biên dịch trước (Pre-compilation)"></a>Biên dịch trước (Pre-compilation)</h1><p>Vậy tại sao ta không thực hiện toàn bộ các bước này ở phía server. Dĩ nhiên thì sẽ tốt hơn nếu chúng ta thực hiện 1 lần rồi triển khai kết quả cho tất cả client, thay vì bắt mỗi client phải thực hiện nó mỗi lần chạy. Thật ra thì có những thảo luận về việc engine nên cung cấp một cách để thực thi những đoạn code đã được biên dịch trước để đỡ tốn thời gian cho trình duyệt.</p><p>Về bản chất thì ý tưởng chính là có một công cụ ở phía server có thể sinh ra bytecode rồi truyền trực tiếp về phía client và thực thi. Nếu thực sự được như vậy thì thời gian khởi động app phía client sẽ được cải thiện đáng kể. Nghe rất hấp dẫn, nhưng mọi việc không đơn giản như vậy.</p><p>Điều này có thể gây ra hiệu ứng ngược lại, hiệu ứng lớn là đằng khác, vì hầu hết code có thể sẽ cần phải được ký &amp; xử lý vì những lý do bảo mật. Đội ngũ V8 đang làm việc nội bộ với nhau để tránh re-parsing để quá trình biên dịch trước sẽ có lợi ích như thế.</p><h1 id="Mot-vai-meo-vat-ban-co-the-thuc-hien-de-app-chay-nhanh-hon"><a href="#Mot-vai-meo-vat-ban-co-the-thuc-hien-de-app-chay-nhanh-hon" class="headerlink" title="Một vài mẹo vặt bạn có thể thực hiện để app chạy nhanh hơn"></a>Một vài mẹo vặt bạn có thể thực hiện để app chạy nhanh hơn</h1><ul><li>Kiểm tra các dependency. Loại bỏ những thứ không cần thiết.</li><li>Chia nhỏ code thành nhiều phần nhỏ hơn thay vì load nguyên 1 cục bự.</li><li>Trì hoãn quá trình load Javascript nếu có thể. Bạn chỉ cần load phần code nào cần thiết dựa trên route hiện tại mà thôi.</li><li>Dùng dev tool &amp; DeviceTiming để tìm hiểu phần nào đang bị thắt cổ chai.</li><li>Dùng công cụ như Optimize.js để giúp parser quyết định khi nào nên parse eager &amp; lazy.</li></ul><p>SessionStack là công cụ hỗ trợ tái tạo lại mọi thứ xảy ra đối với người dùng cuối tại thời điểm họ gặp phải vấn đề khi đang tương tác với webapp. Công cụ này không dựng lại phiên làm việc đó thành 1 video thật mà chỉ giả lập tất cả các sự kiện trong một môi trường sandbox trên trình duyệt. Điều này có ý nghĩa nhất định, ví dụ trong trường hợp codebase của page hiện tại lớn và phức tạp.</p><p>Những kỹ thuật trên là những thứ mà team tác giả gần đây kết hợp trong quá trình phát triển SessionStack. Những tối ưu hóa đó cho phép họ load SessionStack nhanh hơn. SessionStack chạy càng nhanh nó càng có thể giải phóng tài nguyên của trình duyệt nhanh hơn và mang lại trải nghiệm một cách liên tục &amp; tự nhiên cho người dùng khi họ load &amp; xem lại các session làm việc.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 14 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;h1 id=&quot;Khai-quat&quot;&gt;&lt;a href=&quot;#Khai-quat&quot; class=&quot;headerlink&quot; title=&quot;Khái quát&quot;&gt;&lt;/a&gt;Khái quát&lt;/h1&gt;&lt;p&gt;Chúng ta đều biết rằng những thứ lộn xộn có thể hợp thành 1 thứ lớn hơn gọi là Javascript. Một đoạn code không chỉ có thể di chuyển qua mạng mà nó còn phải được parse, biên dịch sang bytecode và cuối cùng thực thi. Trong các bài trước, chúng ta đã thảo luận về những thứ chẳng hạn như JS engine, runtime, callstack cũng như engine V8 được dùng chủ yếu trong Chrome và NodeJS. Tất cả đều đóng vai trò quan trọng trong toàn bộ quá trình thực thi của Javascript. Chủ đề mà chúng ta sẽ tìm hiểu hôm nay cũng không kém quan trọng: chúng ta sẽ nghiên cứu xem làm thế nào mà đa số các engine JS parse văn bản thành một thứ gì đó có nghĩa đối với máy móc, những gì xảy ra sau đó và làm thế nào để web developer như chúng ta có thể tận dụng những kiến thức đó làm điểm mạnh.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P13: Bên trong CSS &amp; JS animation &amp; các giải pháp tối ưu hiệu năng của nó</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P13-Ben-trong-CSS-JS-animation-cac-giai-phap-toi-uu-hieu-nang-cua-no.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P13-Ben-trong-CSS-JS-animation-cac-giai-phap-toi-uu-hieu-nang-cua-no.html</id>
    <published>2018-11-25T09:11:00.000Z</published>
    <updated>2018-11-25T09:14:13.336Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 13 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Mọi người đã biết rõ animation đóng vai trò cần thiết trong việc tạo ra các webapp hấp dẫn. Khi người dùng dần dần chuyển sự chú ý của họ sang UX và các doanh nghiệp bắt đầu nhận ra sự quan trọng của trải nghiệm người dùng thú vị &amp; hoàn hảo thì các ứng dụng web dần trở nên nặng nề hơn &amp; cần thể hiện nhiều UI động hơn. Tất cả những thứ này cần đến các animation phức tạp để tạo ra các chuyển dịch trạng thái mượt mà xuyên suốt hành trình trải nghiệm của người dùng. Giờ đây thì điều đó không còn là thứ gì đặc biệt nữa. User càng lúc càng giỏi và họ mong đợi ở những giao diện người dùng có tính tương tác và phản hồi cao.</p><p>Tuy nhiên animating giao diện không nhất thiết phải đơn giản, minh bạch. Thứ gì cần được animated, khi nào và cảm giác mà một animation mang lại, đó mới là những câu hỏi khó trả lời.<br><a id="more"></a></p><h1 id="So-sanh-Javascript-amp-CSS-animation"><a href="#So-sanh-Javascript-amp-CSS-animation" class="headerlink" title="So sánh Javascript &amp; CSS animation"></a>So sánh Javascript &amp; CSS animation</h1><p>Có 2 phương pháp chính để tạo web animation là dùng Javascript hoặc CSS. Không có lựa chọn nào đúng hay sai cả, tất cả tùy thuộc vào thứ mà bạn muốn đạt được.</p><h2 id="Animate-voi-CSS"><a href="#Animate-voi-CSS" class="headerlink" title="Animate với CSS"></a>Animate với CSS</h2><p>Animating với CSS là cách đơn giản nhất để làm một thứ gì đó chuyển động trên màn hình.</p><p>Chúng ta sẽ bắt đầu với một ví dụ nhanh về việc di chuyển một phần tử 50px theo cả 2 trục X và Y. Có thể thực hiện bằng cách đặt một CSS transition với thời gian 1000ms.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(0, 0);</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: -webkit-transform <span class="number">1000ms</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(0, 0);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1000ms</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-class">.move</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(50px, 50px);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(50px, 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Khi class move được thêm vào, giá trị transform bị thay đổi và transition bắt đầu.</p><p>Bên cạnh transition duration (thời gian dịch chuyển), có những tùy chọn cho <strong>easing</strong>, về bản chất thì đây là cảm giác của animation. Chúng ta sẽ tìm hiểu easing chi tiết hơn trong các phần sau của bài viết này.</p><p>Nếu như trong đoạn code trên, bạn tạo ra những class CSS riêng biệt để quản lý animation thì bạn có thể dùng Javascript để tắt/mở mỗi animation.</p><p>Nếu như bạn có phần tử sau:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  Sample content.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bạn có thể dùng Javascript để tắt/mở animation của nó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boxElements = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'box'</span>),</span><br><span class="line">    boxElementsLength = boxElements.length,</span><br><span class="line">    i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; boxElementsLength; i++) &#123;</span><br><span class="line">  boxElements[i].classList.add(<span class="string">'move'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đoạn code trên lấy tất cả những phần tử có class box và thêm class move vào để trigger animation.</p><p>Làm như thế này tạo sự cân bằng cho app của bạn. Bạn có thể tập trung vào quản lý trạng thái với Javascript và chỉ cần đơn giản đặt những class thích hợp vào phần tử cần phải đặt, để cho trình duyệt xử lý các animation. Nếu bạn tiếp tục tìm hiểu theo hướng này, bạn có thể listen sự kiện transitioned trên mỗi phần tử, nhưng chỉ nếu như bạn phải support cho mấy phiên bản cũ của IE:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*Qm9OFPq3siW0tCKfa03DqQ.png" alt=""></p><p>Listen sự kiện transitioned (được bắn ra tại cuối thời điểm transition) giống như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boxElement = <span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>); <span class="comment">// Lấy phần tử đầu tiên có class `box`</span></span><br><span class="line">boxElement.addEventListener(<span class="string">'transitionend'</span>, onTransitionEnd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onTransitionEnd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Xử lý sự kiện transition đã hoàn thành.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thêm nữa, khi sử dụng CSS transition, bạn có thể dùng CSS animation, nó cho phép bạn có quyền nhiều hơn để kiểm soát mỗi animation keyframe, duration và iteration.</p><blockquote><p>Keyframes được dùng để hướng dẫn chỉ định trình duyệt những giá trị của thuộc tính CSS cần phải có tại mỗi thời điểm nhất định và nó sẽ giúp xử lý phần còn lại.</p></blockquote><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Đây là phiên bản đơn giản, không có </span></span><br><span class="line"><span class="comment"> * tiền tố vendor. Nếu có thêm chúng thì </span></span><br><span class="line"><span class="comment"> * sẽ còn dài dòng hơn nữa.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.box &#123;</span><br><span class="line">  <span class="comment">/* Chọn animation */</span></span><br><span class="line">  animation-name: movingBox;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* duration của animation */</span></span><br><span class="line">  animation-duration: <span class="number">2300</span>ms;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* số lần mà ta muốn animation chạy */</span></span><br><span class="line">  animation-iteration-count: infinite;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* làm cho animation đảo ngược vào mỗi vòng lặp lẻ */</span></span><br><span class="line">  animation-direction: alternate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes movingBox &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">    transform: translate(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    opacity: <span class="number">0.4</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">25</span>% &#123;</span><br><span class="line">    opacity: <span class="number">0.9</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">50</span>% &#123;</span><br><span class="line">    transform: translate(<span class="number">150</span>px, <span class="number">200</span>px);</span><br><span class="line">    opacity: <span class="number">0.2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    transform: translate(<span class="number">40</span>px, <span class="number">30</span>px);</span><br><span class="line">    opacity: <span class="number">0.8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Animation trông như thế này đây: <a href="https://sessionstack.github.io/blog/demos/keyframes/" target="_blank" rel="noopener">https://sessionstack.github.io/blog/demos/keyframes/</a></p><p>Với CSS animation, bạn định nghĩa chính animation độc lập với phần tử đích và sử dụng thuộc tính animation-name để chọn animation được yêu cầu.</p><p>Các CSS animation phần nào được đặt sẵn tiền tố vender, với -webkit- đang được sử dụng trong Safari, Safari Mobile và Android. Chrome, Opera, Internet Explorer và Firefox tất cả đều không có sẵn tiền tố. Nhiều công cụ có thể giúp bạn thêm phiên bản tiền tố của CSS mà bạn cần, cho phép bạn viết code mà không cần phải thêm tiền tố.</p><h2 id="Animate-voi-Javascript"><a href="#Animate-voi-Javascript" class="headerlink" title="Animate với Javascript"></a>Animate với Javascript</h2><p>Tạo animation với Javascript phức tạp hơn nhiều so với sử dụng CSS transition hay animation nhưng thường thì nó cung cấp cho developer nhiều sức mạnh đáng kể.</p><p>Javascript animation được viết nội tuyến như là 1 phần của code. Bạn cũng có thể đóng gói nó bên trong các object. Bên dưới là code Javascript mà bạn cần để viết lại đoạn CSS transition ở phần trên:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boxElement = <span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>);</span><br><span class="line"><span class="keyword">var</span> animation = boxElement.animate([</span><br><span class="line">  &#123;<span class="attr">transform</span>: <span class="string">'translate(0)'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">transform</span>: <span class="string">'translate(150px, 200px)'</span>&#125;</span><br><span class="line">], <span class="number">500</span>);</span><br><span class="line">animation.addEventListener(<span class="string">'finish'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  boxElement.style.transform = <span class="string">'translate(150px, 200px)'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Mặc định thì Web Animation chỉ chỉnh sửa phần trình bày của một phần tử. Nếu như bạn muốn object của mình vẫn giữ nguyên vị trí lúc nó được di chuyển tới thì bạn nên sửa lại style của nó khi animation kết thúc. Đây là lý do tại sao chúng ta listen sự kiện finish trong code trên, đặt thuộc tính box.style.transform bằng giá trị translate(150px, 200px) thì nó sẽ thể hiện giống như trường hợp transform thứ 2 trong CSS animation ở trên.</p><p>Với Javascript animation, bạn hoàn toàn kiểm soát style của phần tử tại thời điểm bất kỳ. Nghĩa là bạn có thể làm animation chậm lại, tạm ngưng, dừng hẳn, đảo ngược và điều khiển phần tử cho tới khi phù hợp. Điều này cực kỳ hữu ích nếu bạn muốn xây dựng các ứng dụng hướng đối tượng phức tạp bởi vì bạn có thể đóng gói các hành vi của app một cách chính xác.</p><h1 id="Easing-la-gi"><a href="#Easing-la-gi" class="headerlink" title="Easing là gì?"></a>Easing là gì?</h1><p>Chuyển động tự nhiên làm cho user cảm thấy dễ chịu hơn với webapp của bạn và mang đến trải nghiệm UX tốt hơn.</p><p>Một cách tự nhiên, không có thứ gì di chuyển theo đường thẳng từ điểm này đến điểm khác. Thật ra thì mọi thứ đều có xu hướng tăng tốc và giảm tốc khi chúng di chuyển trong thế giới vật lý của chúng ta và có rất nhiều yếu tố khác nhau ảnh hưởng. Bộ não con người được thiết kế bẩm sinh để cảm nhận những chuyển động nên khi bạn thực hiện animation trên webapp hãy nhớ những kiến thức này.</p><p>Một vài thuật ngữ bạn cần hiểu:</p><ul><li><strong>ease in</strong>: là khi chuyển động bắt đầu chậm và tăng tốc dần lên.</li><li><strong>ease out</strong>: chuyển động bắt đầu nhanh và giảm tốc dần.</li></ul><p>Easing cho phép bạn tạo các animation cho cảm giác tự nhiên hơn.</p><h2 id="Cac-tu-khoa-cho-easing"><a href="#Cac-tu-khoa-cho-easing" class="headerlink" title="Các từ khóa cho easing"></a>Các từ khóa cho easing</h2><p>CSS transition và animation cho phép bạn chọn loại easing mà bạn muốn. Có nhiều từ khóa khác nhau ảnh hưởng đến easing của animation. Bạn cũng có thể tạo ra easing hoàn toàn của riêng bạn.</p><p>Dưới đây là 1 số từ khóa bạn có thể dùng trong CSS để điều khiển easing:</p><ul><li>linear</li><li>ease-in</li><li>ease-out</li><li>ease-in-out</li></ul><p>Giờ thì cùng tìm hiểu về chúng nào.</p><h2 id="Linear-animation"><a href="#Linear-animation" class="headerlink" title="Linear animation"></a>Linear animation</h2><p>Các animation không có bất cứ kiểu easing nào thì được gọi là <strong>linear</strong> (thẳng hàng, còn hàn lâm hơn thì “Tuyến tính”).<br>Đồ thị thể hiện một linear animation:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*M5htfOGgza04ISv_l-69zg.png" alt=""></p><p>Thời gian càng tăng thì giá trị cũng tăng với lượng tương ứng. Với chuyển động linear, mọi thứ có xu hướng thiếu tự nhiên. Nói chung bạn nên tránh sử dụng chuyển động linear.</p><p>Đây là cách triển khai một linear animation đơn giản:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 500<span class="selector-tag">ms</span> <span class="selector-tag">linear</span>;</span><br></pre></td></tr></table></figure><h2 id="Ease-out-animation"><a href="#Ease-out-animation" class="headerlink" title="Ease-out animation"></a>Ease-out animation</h2><p>Như đã nói ở trên, ease out làm cho animation bắt đầu nhanh hơn so với kiểu linear trong khi đó nó lại chậm dần khi kết thúc. Đồ thị trông như thế này:<br><img src="https://cdn-images-1.medium.com/max/1000/1*VDWQl67cmbyAFC5xL9Og4g.png" alt=""></p><p>Nhìn chung, ease out là sự lựa chọn tốt nhất cho UI bởi vì khởi động nhanh làm cho animation của bạn có cảm giác phản hồi tốt trong khi chậm dần khi kết thúc mang lại cảm giác tự nhiên do sự chuyển động không đồng nhất.</p><p>Có nhiều cách để triển khai hiệu ứng ease out nhưng cách đơn giản nhất là từ khóa ease-out trong CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 500<span class="selector-tag">ms</span> <span class="selector-tag">ease-out</span>;</span><br></pre></td></tr></table></figure><h2 id="Ease-in-animation"><a href="#Ease-in-animation" class="headerlink" title="Ease-in animation"></a>Ease-in animation</h2><p>Đây là kiểu đối lập lại với ease-out animation: bắt đầu chậm chạp và kết thúc nhanh. Đồ thị mô tả:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*rWh8YlBn8SypiMduLiYDhA.png" alt=""></p><p>So với ease-out animation thì ease-in có hơi không bình thường vì chúng tạo ra cảm giác thiếu sự phản hồi, bởi vì chúng khởi động chậm. Kết thúc nhanh có thể cũng tạo ra cảm giác lạ tương tự, toàn bộ animation đều tăng tốc trong khi đối tượng ở thế giới thực có xu hướng giảm tốc khi dừng lại đột ngột.</p><p>Để dùng ease-in animation thì bạn có thể dùng từ khóa tương tự như trên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 500<span class="selector-tag">ms</span> <span class="selector-tag">ease-in</span>;</span><br></pre></td></tr></table></figure><h2 id="Ease-in-out-animation"><a href="#Ease-in-out-animation" class="headerlink" title="Ease-in-out animation"></a>Ease-in-out animation</h2><p>Đây là animation kết hợp của ease-in và ease-out. Đồ thị:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*tGXhNroe8KxGN7r4UTVSHw.png" alt=""></p><p>Không nên sử dụng anmation-duration quá lâu bởi vì nó mang lại cảm giác rằng UI của bạn thiếu sự phản hồi.</p><p>Cách sử dụng ease-in-out animation:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 500<span class="selector-tag">ms</span> <span class="selector-tag">ease-in-out</span>;</span><br></pre></td></tr></table></figure><h2 id="Tuy-bien-easing"><a href="#Tuy-bien-easing" class="headerlink" title="Tùy biến easing"></a>Tùy biến easing</h2><p>Bạn có thể định nghĩa đường cung easing cho riêng bạn để có thể kiểm soát nhiều hơn những cảm giác mà animation có thể tạo ra.</p><p>Trên thực tế, các từ khóa ease-in, ease-out, liner, ease được nối với những đường cung Bezier (<a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank" rel="noopener">Bézier curves</a>) đã định nghĩa sẵn, bạn có thể xem chi tiết ở <a href="http://www.w3.org/TR/css3-transitions/" target="_blank" rel="noopener">Thông số kỹ thuật của CSS transition</a> hoặc của <a href="https://w3c.github.io/web-animations/#scaling-using-a-cubic-bezier-curve" target="_blank" rel="noopener">Web Animation</a></p><h2 id="Duong-cung-Bezier"><a href="#Duong-cung-Bezier" class="headerlink" title="Đường cung Bezier"></a>Đường cung Bezier</h2><p>Cùng tìm hiểu về cách hoạt động của đường cung Bezier nào.<br>Một cung Bezier nhận 4 giá trị, hoặc nói rõ hơn thì nó nhận vào 2 cặp số. Mỗi cặp định nghĩa tọa độ X và Y của 1 điểm kiểm soát thuộc khối cung Bezier. Điểm bắt đầu của cung Bezier có tọa độ (0, 0) và kết thúc là ở (1, 1). Bạn có thể đặt cả 2 cặp số. Giá trị X cho 2 kiểm kiểm soát phải nằm trong khoảng [0, 1] còn giá trị của Y thì có thể vượt quá giới hạn [0, 1], mặc dù thông số kỹ thuật không nói rõ là bao nhiêu.</p><p>Kể cả những thay đổi nhỏ trong giá trị X và Y của mỗi điểm kiểm soát mang đến cho bạn một cung hoàn toàn khác biệt. Ở 2 đồ thị bên dưới, cung Bezier có các điểm gần nhau nhưng khác tọa độ.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*2v7G1ZJ1C-y_mWHOYQfQKQ.png" alt=""></p><p>và</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*P5nzyldL4rg36dZmt2RViQ.png" alt=""></p><p>Như bạn thấy thì đồ thị khá là khác nhau. Điểm kiểm soát đầu tiên có vector với giá trị sai khác là (0.045, 0.183) còn điểm thứ 2 là (-0.427, -0.054)</p><p>Còn đây là phần CSS cho đường cung thứ 2:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 500<span class="selector-tag">ms</span> <span class="selector-tag">cubic-bezier</span>(0<span class="selector-class">.465</span>, 0<span class="selector-class">.183</span>, 0<span class="selector-class">.153</span>, 0<span class="selector-class">.946</span>);</span><br></pre></td></tr></table></figure><p>2 số đầu tiên là tọa độ X và Y của điểm kiểm soát thứ nhất, 2 số tiếp theo là của điểm kiểm soát thứ 2.</p><h1 id="Toi-uu-hoa-hieu-nang"><a href="#Toi-uu-hoa-hieu-nang" class="headerlink" title="Tối ưu hóa hiệu năng"></a>Tối ưu hóa hiệu năng</h1><p>Bạn cần phải duy trì 60 khung hình/giây (60 fps - game thủ hiểu cái này lắm nè :D) khi làm animation nếu không thì nó sẽ ảnh hưởng tiêu cực đến UX.</p><p>Và như 1 lẽ dĩ nhiên thì animation không hề miễn phí. Không phải là chuyện tiền nong, mà là hiệu năng. Animate một vài thuộc tính có thể không tốn kém như một số khác. Ví dụ: animate width và height của 1 phần tử sẽ thay đổi trạng thái hình học của nó và là nguyên nhân ảnh hưởng đến các phần tử khác trên trang bị thay đổi vị trí hoặc kích thước. Quá trình này được gọi là layout. Chúng ta cũng đã thảo luận chi tiết về layout và rendering trong <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-11---Render-engine---meo-toi-uu-hoa-hieu-nang-render" target="_blank" rel="noopener">bài trước rồi</a>.</p><p>Nói chung, bạn cần tránh animate những thuộc tính nào có thể trigger quá trình layout hoặc tô màu (paint). Với đa số các trình duyệt hiện đại thì điều này nghĩa là hạn chế animation với opacity và transform</p><h2 id="Will-change"><a href="#Will-change" class="headerlink" title="Will-change"></a>Will-change</h2><p>Bạn có thể dùng <a href="https://dev.w3.org/csswg/css-will-change/" target="_blank" rel="noopener">will-change</a> để thông báo cho trình duyệt biết bạn có ý định thay đổi thuộc tính của 1 phần tử. Nó cho phép trình duyệt cài đặt sẵn sàng trước những tối hưu hóa thích hợp nhất khi bạn cần thay đổi. Tuy nhiên cũng đừng lạm dụng will-change, bởi vì làm như thế có thể làm cho trình duyệt hao tốn tài nguyên và quay ngược lại gây ra nhiều vấn đề hơn về hiệu năng.</p><p>Cách để thêm will-change cho transform và opacity:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">will-change</span>: transform, opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trình duyệt hỗ trợ:<br><img src="https://cdn-images-1.medium.com/max/1000/1*eyaMLcORDVsCFIf5h_ygjA.png" alt=""></p><h2 id="Chon-Javascript-hay-CSS"><a href="#Chon-Javascript-hay-CSS" class="headerlink" title="Chọn Javascript hay CSS"></a>Chọn Javascript hay CSS</h2><p>Có lẽ bạn cũng đã thấy rằng không có câu trả lời đúng cho câu hỏi này, tùy thuộc vào nhiều yếu tố, dưới đây là những thứ bạn cần cân nhắc mỗi khi lựa chọn:</p><ul><li>Các animation dựa trên CSS và Web Animation được hỗ trợ native và được xử lý trong tiến trình gọi là “tiến trình tổng hợp” (compositor thread). Khác với “tiến trình chính” của trình duyệt, nơi mà styling, layout, painting và code Javascript được thực thi. Nghĩa là nếu như trình duyệt đang bận xử lý 1 số tác vụ nặng ký trên tiến trình chính thì những animation đó vẫn có thể tiếp tục thực hiện mà không bị can thiệp.</li><li>Trong một vài trường hợp. các thay đổi đối với transform và opacity có thể được xử lý bởi tiến trình tổng hợp.</li><li>Nếu animation trigger paint, layout hoặc cả 2 thì tiến trình chính sẽ cần phải tham gia xử lý. Trường hợp này xảy ra cho cả CSS và Javascript animation, và dĩ nhiên là việc thực hiện layout hoặc paint như vậy sẽ làm chậm bất kỳ tác vụ nào liên quan đến thực thi CSS hay Javascript</li></ul><h2 id="Chon-dung-thu-de-animate"><a href="#Chon-dung-thu-de-animate" class="headerlink" title="Chọn đúng thứ để animate"></a>Chọn đúng thứ để animate</h2><p>Những animation tuyệt vời thường tạo nên sự thích thú và gắn kết giữa project của bạn với người dùng. Bạn có thể animate bất cứ thứ gì bạn muốn, dù là width, height, position, color, background, vân vân, nhưng cần phải chú ý đến những nút thắt cổ chai tiềm tàng về hiệu năng. Những animation được chọn lựa 1 cách bất cẩn có thể ảnh hưởng tiêu cực đến UX, vì vậy animation cần phải vừa phù hợp vừa tốt cho hiệu năng. Animate càng ít càng tốt, chỉ nên animate khi bạn cần UX trở nên tự nhiên hơn nhưng đừng lạm dụng nó.</p><h2 id="Dung-animation-de-ho-tro-tuong-tac"><a href="#Dung-animation-de-ho-tro-tuong-tac" class="headerlink" title="Dùng animation để hỗ trợ tương tác"></a>Dùng animation để hỗ trợ tương tác</h2><p>Không nên animate chỉ vì bạn thích thế. Thay vì vậy, sử dụng animation tại những vị trí chiến lược để <em>củng cố</em> thêm về tương tác người dùng. Tránh animation làm ngắt quãng hoặc cản trở một cách không cần thiết các hoạt động của user</p><h2 id="Tranh-animate-nhung-thuoc-tinh-phuc-tap"><a href="#Tranh-animate-nhung-thuoc-tinh-phuc-tap" class="headerlink" title="Tránh animate những thuộc tính phức tạp"></a>Tránh animate những thuộc tính phức tạp</h2><p>Chỉ có duy nhất 1 thứ tệ hơn cả animation đặt sai chỗ chính là những animation làm cho trang web bị lag. Kiểu animation này làm cho user cảm thấy bực bội và chán nản.</p><p>Team tác giả sử dụng animation khá dễ dàng với <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=js-series-rendering-engine-outro" target="_blank" rel="noopener">SessionStack</a>. Nói chung, họ theo sát những nguyên tắc đã nêu ở trên nhưng cũng có một số trường hợp mà họ phải dùng animation vì sự phức tạp của UI. SessionStack phải tái tạo lại dưới dạng video toàn bộ những thứ xảy ra với người dùng cuối tại thời điểm họ gặp phải vấn đề khi đang lướt web hay dùng webapp. Để làm được điều này SessionStack tận dụng duy nhất những dữ liệu thu thập được xuyên suốt phiên làm việc: sự kiện từ user, thay đổi trên DOM, request mạng, biệt lệ, thông báo debug, vân vân. Trình chơi của họ được tối ưu hóa khá tốt để có thể render một cách chính xác và sử dụng toàn bộ dữ liệu thu thập được để giả lập chính xác đến từng pixel trình duyệt của người dùng và những thứ xảy ra trên nó, cả về khía cạnh nhìn thấy được và góc nhìn kỹ thuật.</p><p>Để đảm bảo quá trình tái tạo diễn ra một cách tự nhiên, đặc biệt với những phiên làm việc kéo dài và nặng dữ liệu, team tác giả sử dụng các animation để chỉ định chính xác hoạt động loading/buffering và bám sát các nguyên tắc tốt nhất để triển khai chúng, do đó họ không cần quá nhiều CPU và vẫn có thể để cho event loop được rảnh tay render các session.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 13 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;h1 id=&quot;Khai-quat&quot;&gt;&lt;a href=&quot;#Khai-quat&quot; class=&quot;headerlink&quot; title=&quot;Khái quát&quot;&gt;&lt;/a&gt;Khái quát&lt;/h1&gt;&lt;p&gt;Mọi người đã biết rõ animation đóng vai trò cần thiết trong việc tạo ra các webapp hấp dẫn. Khi người dùng dần dần chuyển sự chú ý của họ sang UX và các doanh nghiệp bắt đầu nhận ra sự quan trọng của trải nghiệm người dùng thú vị &amp;amp; hoàn hảo thì các ứng dụng web dần trở nên nặng nề hơn &amp;amp; cần thể hiện nhiều UI động hơn. Tất cả những thứ này cần đến các animation phức tạp để tạo ra các chuyển dịch trạng thái mượt mà xuyên suốt hành trình trải nghiệm của người dùng. Giờ đây thì điều đó không còn là thứ gì đặc biệt nữa. User càng lúc càng giỏi và họ mong đợi ở những giao diện người dùng có tính tương tác và phản hồi cao.&lt;/p&gt;
&lt;p&gt;Tuy nhiên animating giao diện không nhất thiết phải đơn giản, minh bạch. Thứ gì cần được animated, khi nào và cảm giác mà một animation mang lại, đó mới là những câu hỏi khó trả lời.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P12: Bên trong lớp Network + Làm sao để tối ưu hóa hiệu năng và bảo mật Javascript</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P12-Ben-trong-lop-Network-Lam-sao-de-toi-uu-hoa-hieu-nang-va-bao-mat-Javascript.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P12-Ben-trong-lop-Network-Lam-sao-de-toi-uu-hoa-hieu-nang-va-bao-mat-Javascript.html</id>
    <published>2018-11-25T09:06:00.000Z</published>
    <updated>2018-11-25T09:10:31.361Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 12 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Như đã nói trong bài trước về <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-11---Render-engine---meo-toi-uu-hoa-hieu-nang-render" target="_blank" rel="noopener">render engine</a>, tác giả bài viết tin rằng sự khác biệt giữa một Javascript developer tốt (good) và tuyệt vời (great) là dev tuyệt vời không những hiểu về các thành phần cơ bản của một ngôn ngữ mà còn cả phần cốt lõi cũng như môi trường xung quanh nó.<br><a id="more"></a></p><h1 id="Nhac-so-qua-ve-lich-su-mot-chut"><a href="#Nhac-so-qua-ve-lich-su-mot-chut" class="headerlink" title="Nhắc sơ qua về lịch sử một chút"></a>Nhắc sơ qua về lịch sử một chút</h1><p>49 năm trước, một thứ gọi là ARPAnet được tạo ra. Nó chính là một <a href="https://en.wikipedia.org/wiki/Packet_switching" target="_blank" rel="noopener">mạng chuyển đổi gói tin sớm</a> và cũng là <a href="https://en.wikipedia.org/wiki/Internet_protocol_suite" target="_blank" rel="noopener">mạng đầu tiên triển khai bộ TCP/IP</a>. Mạng này cài đặt một liên kết giữa trường đại học California và Học viện nghiên cứu Stanford. 20 năm sau, Tim Berners-Lee phát hành một lời đề nghị cho “Mesh” - thứ mà sau này được biết đến là World Wide Web. Trong 49 năm đó, internet đã đi được một quãng đường dài, bắt đầu chỉ với 2 máy tính trao đổi các gói dữ liệu và giờ đạt tới hơn 75 triệu server, 3.8 tỉ người dùng internet và 1.3 tỉ websites.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*x8P3OcgcgKrEEDpgT2IKkQ.jpeg" alt=""></p><p>Trong bài này, chúng ta sẽ thử phân tích những kỹ thuật nào trình duyệt hiện đại sử dụng để tự động đẩy mạnh hiệu năng (thậm chí bạn không biết đến điều đó), và chúng ta sẽ đặc biệt soi kỹ vào lớp networking của trình duyệt. Ở cuối bài, tác giả sẽ cung cấp một số ý tưởng làm thế nào để giúp trình duyệt đẩy mạnh hơn nữa hiệu năng của webapp của bạn.</p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Trình duyệt web hiện đại được thiết kế đặc trị cho việc truyền tải webapp/website một cách nhanh chóng, hiệu quả và an toàn bảo mật. Với hàng trăm component cùng hoạt động trên nhiều layer khác nhau, từ quản lý tiến trình và bảo mật sandbox đến các GPU pipeline, audio và video, và còn nhiều thứ khác nữa, trình duyệt trông giống như một hệ điều hành hơn là một phần mềm bình thường.</p><p>Hiệu năng tổng quát của trình duyệt được xác định bằng một cơ số các component lớn: parsing (phân giải), layout, tính toán style, quá trình thực thi Javascript &amp; WebAssembly, rendering và dĩ nhiên là cả <strong>networking stack</strong> (ngăn xếp mạng).</p><p>Các kỹ sư thường nghĩ rằng networking stack là một nút cổ chai. Điều này xảy ra thường xuyên vì tất cả các tài nguyên đều cần phải được lấy về từ internet trước khi các bước còn lại được thực hiện. Với networking layer, để hoạt động hiệu quả nó cần phải đóng vai trò nhiều hơn là một bộ quản lý socket đơn giản. Với chúng ta, nó như một thứ núp dưới dạng một cơ chế rất đơn giản để kéo tài nguyên về nhưng đó thực sự là một nền tảng (platform) đầy đủ với các tiêu chí tối ưu hóa, APIs và service của riêng nó.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*WqInzMPQGGcMX9AOONN76g.jpeg" alt=""></p><p>Là web developer, chúng ta không cần phải lo nghĩ về từng gói tin TCP hay UDP, định dạng request, caching và tất cả những thứ liên quan. Toàn bộ sự phức tạp này được trình duyệt gánh dùm nên ta chỉ cần tập trung vào ứng dụng mà chúng ta đang tạo ra. Tuy nhiên, hiểu rõ điều gì thực sự đang diễn ra bên trong có thể giúp chúng ta tạo ra app nhanh hơn và bảo mật tốt hơn.</p><p>Về bản chất thì dưới đây là những gì xảy ra khi user bắt đầu tương tác với trình duyệt:</p><ul><li>User nhập một URL vào thanh địa chỉ trên trình duyệt</li><li>Giả sử URL đó chỉ đến 1 tài nguyên trên mạng, trình duyệt sẽ bắt đầu kiểm tra local cache và cache của ứng dụng và cố thử sử dụng một phải copy có sẵn ở local để đáp ứng request.</li><li>Nếu cache không dùng được, tình duyệt sẽ lấy tên miền từ URL và yêu cầu địa chỉ IP của server từ một <a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener">DNS</a>. Nếu tên miền đã được cache sẵn thì không cần truy vấn đến DNS.</li><li>Trình duyệt tạo ra một gói tin HTTP nói rằng nó yêu cầu một trang web đang cư trú tại một server từ xa.</li><li>Gói tin được gửi đến TCP layer, layer này sẽ thêm thông tin của chính nó vào vị trí trên cùng của gói tin HTTP. Thông tin này cần thiết để duy trì phiên khởi động.</li><li>Gói tin sau đó được trao cho IP layer với công việc chính là tìm hiểu một cách để gửi gói tin từ user đến server từ xa. Thông tin này cũng được lưu vào vị trí trên cùng của gói tin.</li><li>Gói tin được gửi đến server từ xa.</li><li>Khi đã nhận gói tin, một phản hồi được gửi ngược lại theo cách thức tương tự.</li></ul><p><a href="http://www.w3.org/TR/navigation-timing/" target="_blank" rel="noopener">Đặc tính kỹ thuật của Navigation Timing</a> từ W3C cung cấp một API trình duyệt cũng như khả năng hiển thị dữ liệu về thời gian và hiệu năng đằng sau mỗi request trên trình duyệt. Giờ thì cùng quan sát các component, mỗi phần sẽ đóng một vai trò quan trọng trong việc cung cấp các trải nghiệm người dùng (UX) tối ưu:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*rjBdCBwOx5Gp_A6b6FQgfw.png" alt=""></p><p>Toàn bộ tiến trình networking rất phức tạp và có nhiều layer khác nhau có thể trở thành một nút cổ chai. Đây là lý do các trình duyệt cố gắng phấn đấu để cải thiện hiệu năng bản thân bằng cách sử dụng rất nhiều kỹ thuật đa dạng để giảm thiểu tối đa sự ảnh hưởng của toàn bộ giao tiếp network.</p><h1 id="Quan-ly-socket"><a href="#Quan-ly-socket" class="headerlink" title="Quản lý socket"></a>Quản lý socket</h1><p>Cùng khởi động với một số thuật ngữ nào:</p><ul><li><strong>Origin</strong>: một bộ 3 chứa các giao thức ứng dụng, tên miền và số port (ví dụ: https, <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a>, 443)</li><li><strong>Socket pool</strong>: một nhóm các socket thuộc về cùng origin (tất cả các trình duyệt lớn đều giới hạn pool size lớn nhất là 6 socket).</li></ul><p>Javascript và WebAssembly <strong>không cho phép</strong> chúng ta quản lý vòng đời của các network socket riêng tư, và dĩ nhiên như vậy là tốt! Điều này không những giúp chúng ta dễ dàng hơn mà còn cho phép trình duyệt tự động thực hiện rất nhiều tối ưu hóa hiệu năng, một trong số đó bao gồm: sử dụng lại socket, yêu cầu sự ưu tiên và ràng buộc muộn (late binding), giao dịch giao thức, ép buộc giới hạn kết nối, vân vân.</p><p>Thật ra các trình duyệt hiện đại đã làm tốt trong việc chia tách vòng quản lý request khỏi phần quản lý socket. Các socket được tổ chức trong các pool và được nhóm lại theo origin, mỗi pool bắt buộc phải giới hạn kết nối và các ràng buộc bảo mật. Các request chờ được xếp vào trong hàng đợi, đánh thứ tự ưu tiên và sau đó gắn kết với những socket riêng tư trong pool. Trừ khi server có ý định đóng kết nối thì cùng một socket có thể được sử dụng lại một cách tự động xuyên suốt nhiều request.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*0e8X3UTBpsiBSZKa3l1hXA.png" alt=""></p><p>Bởi vì mở mới 1 kết nối TCP thường kèm theo chi phí tốn kém cho nên tái sử dụng lại các kết nối cũ sẽ đảm bảo hiệu năng tốt hơn nhiều. Mặc định thì trình duyệt sử dụng cơ chế gọi là “keepalive” (giữ cho sống) để tiết kiệm thời gian từ việc mở mới kết nối đến server khi có request được tạo ra. Thời gian trung bình để mở 1 kết nối TCP là:</p><ul><li>Request đến máy local: 23ms</li><li>Request trong nội bộ châu lục: 120ms</li><li>Request giữa các châu lục với nhau: 225ms</li></ul><p>Kiểu kiến trúc này mở ra cánh cửa đến với rất nhiều cơ hội để tối ưu hóa. Request có thể được thực thi với những thứ tự khác nhau tùy thuộc vào độ ưu tiên của nó. Trình duyệt có thể tối ưu hóa sự phân chia băng thông giữa toàn bộ các socket hoặc là nó có thể mở socket khi dự đoán trước về một request.</p><p>Như đã nói trước đó, toàn bộ đều được quản lý bởi trình duyệt và không yêu cầu chúng ta giúp bất cứ thứ gì. Nhưng nó không nhất thiết nghĩa là chúng ta không thể làm gì. Chọn lựa đúng pattern về giao tiếp mạng, loại và tần suất transfer, lựa chọn các giao thức và tinh chỉnh/tối ưu hóa server stack có thể đóng vai trò rất lớn trong việc cải thiện hiệu năng tổng thể của ứng dụng.</p><p>Một vài trình duyệt thậm chí còn đi xa hơn. Ví dụ, Chrome có thể tự dạy cho chính nó hoạt động nhanh hơn khi bạn sử dụng nó. Nó học hỏi dựa trên những trang bạn đã ghé thăm và kiểu duyệt web điển hình cho nên nó có thể dự đoán hành vi người dùng có khả năng và thực hiện hành động trước khi user làm gì đó. Ví dụ đơn giản nhất là tự động render trước nội dung của trang khi user rê chuột lên 1 link. Nếu bạn thấy hứng thú về chủ đề tối ưu hóa của Chrome thì có thể đọc thêm chương này <a href="https://www.igvita.com/posa/high-performance-networking-in-google-chrome/" target="_blank" rel="noopener">https://www.igvita.com/posa/high-performance-networking-in-google-chrome/</a> nằm trong quyển sách <a href="https://hpbn.co/" target="_blank" rel="noopener">High-Performance Browser Networking</a></p><h1 id="Bao-mat-mang-va-dong-goi-sandbox"><a href="#Bao-mat-mang-va-dong-goi-sandbox" class="headerlink" title="Bảo mật mạng và đóng gói sandbox"></a>Bảo mật mạng và đóng gói sandbox</h1><p>Cho phép trình duyệt quản lý các socket riêng biệt có một ý nghĩa rất quan trọng: bằng cách này trình duyệt cho phép áp đặt một hệ thống đồng nhất các ràng buộc về chính sách và bảo mật lên những nguồn tài nguyên ứng dụng không đáng tin cậy. Ví dụ như trình duyệt sẽ không chấp nhận API truy xuất trực tiếp vào network socket thô vì như vậy có thể cho phép các ứng dụng độc hại tạo kết nối tùy tiện đến bất cứ host nào. Trình duyệt cũng áp đặt các giới hạn kết nối để bảo vệ server cũng như client khỏi cạn kiệt tài nguyên.</p><p>Trình duyệt định dạng tất cả các request đi ra để áp đặt sự đồng nhất và các ngữ nghĩa giao thức tốt để bảo vệ server. Tương tự, giải mã response được thực hiện một cách tự động để bảo vệ user từ những server độc hại.</p><h2 id="Trao-doi-TLS"><a href="#Trao-doi-TLS" class="headerlink" title="Trao đổi TLS"></a>Trao đổi TLS</h2><p><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">Transport Layer Security (TLS)</a> là một giao thức mật mã cung cấp giao tiếp bảo mật trong mạng máy tính. Nó được sử dụng rộng rãi trong nhiều ứng dụng, một trong số đó là trình duyệt web. Website có thể dùng TLS để bảo đảm an ninh cho tất cả các giao tiếp giữa server và trình duyệt web.</p><p>Toàn bộ quá trình bắt tay TLS bao gồm các bước sau:</p><ol><li>Client gửi một lời nhắn “Client hello” đến server, cùng với một giá trị ngẫu nhiên của client và bộ mã hóa được hỗ trợ.</li><li>Server trả lời bằng cách gửi lời nhắn “Server hello” về cho client, cùng với giá trị ngẫu nhiên của server.</li><li>Server gửi chứng chỉ xác thực của nó về cho client và có thể yêu cầu một chứng chỉ tương tự từ phía client. Server gửi lời nhắn “Server hello done”.</li><li>Nếu server đã yêu cầu một chứng chỉ từ client thì client phải gửi nó.</li><li>Client tạo ra một Pre-Master Secret ngẫu nhiên và mã hóa nó với public key từ chứng chỉ của server, gửi Pre-Master Secret đã được mã hóa về cho server.</li><li>Server nhận Pre-Master Secret. Server và client mỗi bên sẽ sinh ra Master Secret và session key (chìa khóa phiên) dựa trên Pre-Master Secret.</li><li>Client gửi thông báo “Change cipher spec” đến server để xác định rằng client sẽ bắt đầu sử dụng session key mới để băm và mã hóa message. Client cũng đồng thời gửi tin nhắn “Client finished”.</li><li>Server nhận “Change cipher spec” và chuyển đổi trạng thái bảo mật của record layer của nó sang trạng thái bảo mật mã hóa đối xứng bằng session key. Server gửi lời nhắn “server finished” về cho client.</li><li>Client và server giờ có thể trao đổi dữ liệu ứng dụng thông qua kênh bảo mật mà chúng đã thiết lập. Tất cả message được gửi từ client đến server và ngược lại đều được mã hóa bằng session key.</li></ol><p>User được cảnh báo trong trường hợp một trong số xác thực nào đó bị sai, ví dụ: server đang dùng một chứng chỉ tự cấp.</p><h2 id="Chinh-sach-cung-origin"><a href="#Chinh-sach-cung-origin" class="headerlink" title="Chính sách cùng origin"></a>Chính sách cùng origin</h2><p>Hai trang có cùng origin nếu như giao thức, cổng (nếu được chỉ định) và host đều giống nhau giữa 2 trang</p><p>Dưới đây là một vài ví dụ về các tài nguyên có thể được nhúng cross-origin (xuyên origin):</p><ul><li>Javascript với code <code>&lt;script src=&quot;…&quot;&gt;&lt;/script&gt;</code>. Thông báo lỗi cú pháp chỉ tồn tại cho những đoạn script cùng origin.</li><li>CSS với <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;…&quot;&gt;</code>. Do quy tắc cú pháp thoải mái của CSS nên CSS cross-origin cần một header Content-Type đúng loại. Sự hạn chế thì tùy thuộc vào trình duyệt.</li><li>Hình ảnh với thẻ <code>&lt;img /&gt;</code></li><li>File đa phương tiện với <code>&lt;video&gt;</code> và <code>&lt;audio&gt;</code></li><li>Plug in với <code>&lt;object&gt;</code>, <code>&lt;embed&gt;</code> and <code>&lt;applet&gt;</code></li><li>Fonts với @font-face. Vài trình duyệt cho phép các font cross-origin, một số khác thì yêu cầu fonts trong cùng origin.</li><li>Bất cứ thứ gì với <code>&lt;frame&gt;</code> và <code>&lt;iframe&gt;</code>. Một trang có thể sử dụng header X-Frame-Options để ngăn chặn trường hợp tương tác cross-origin này.</li></ul><p>Danh sách trên vẫn còn thiếu sót nhiều, mục đích của nó là làm nổi bật nguyên tắc “quyền hạn tối thiểu” (least privilege). Trình duyệt chỉ phô ra những API và tài nguyên cần thiết cho code của chương trình: ứng dụng hỗ trợ dữ liệu và URL, trình duyệt định dạng các request và xử lý toàn bộ vòng đời của mỗi kết nối.</p><p>Rất đáng để lưu tâm rằng hoàn toàn không có một concept cụ thể nào của “chính sách cùng origin” (same-origin policy). Thay vào đó, chỉ có 1 bộ cơ chế liên quan áp đặt các ràng buộc lên việc truy xuất DOM, cookie và quản lý trạng thái của session, mạng và các thành phần khác của trình duyệt.</p><h1 id="Luu-dem-tai-nguyen-va-trang-thai-cua-client"><a href="#Luu-dem-tai-nguyen-va-trang-thai-cua-client" class="headerlink" title="Lưu đệm tài nguyên và trạng thái của client"></a>Lưu đệm tài nguyên và trạng thái của client</h1><p>Request nhanh nhất và tốt nhất chính là không gọi request nào cả. Trước khi điều phối một request, trình duyệt tự động kiểm tra bộ đệm tài nguyên của nó, thực hiện các kiểm tra xác nhận cần thiết và trả về một bản copy local của tài nguyên đó nếu phù hợp với những điều kiện cụ thể. Nếu tài nguyên ở local không tồn tại trong cache thì request lên mạng được gọi và response sẽ được chèn tự động vào trong cache để cho lần truy cập tiếp theo nếu được phép.</p><ul><li>Trình duyệt tự động đánh giá các chỉ thị lưu đệm (cache directives) cho mỗi tài nguyên.</li><li>Trình duyệt tự động xác nhận lại các tài nguyên hết hạn khi nó có thể.</li><li>Trình duyệt tự động quản lý kích cỡ của bộ đệm và thu hồi tài nguyên.</li></ul><p>Quản lý bộ đệm tài nguyên một cách hiệu quả và tối ưu là rất khó. Ơn trời trình duyệt đã xử lý toàn bộ những thứ phức tạp ấy giúp chúng ta rồi, tất cả những gì ta cần làm là đảm bảo server của mình trả về cache directive phù hợp, để hiểu rõ hơn thì bạn có thể đọc bài <a href="https://hpbn.co/optimizing-application-delivery/#cache-resources-on-the-client" target="_blank" rel="noopener">Cache Resources on the Client</a>. Bạn cung cấp các response headers như Cache-Control, ETag và Last-Modified cho tất cả nguồn tài nguyên trên trang của bạn, phải không?</p><p>Cuối cùng, một chức năng thường bị bỏ quả nhưng khá quan trọng của trình duyệt chính là nhiệm vụ cung cấp xác thực, session và quản lý cookie. Trình duyệt duy trì các gói cookie (cookie jars - tác giả chơi chữ “cookie - bánh quy”) riêng biệt cho mỗi origin, cung cấp các ứng dụng cần thiết và server APIs để đọc/ghi cookie, session và dữ liệu xác thực mới, tự động nối &amp; xử lý các header HTTP phù hợp để tự động hóa toàn bộ quá trình thay cho chúng ta.</p><p>Ví dụ:<br>Một ví dụ đơn giản nhưng dễ minh họa nhất về sự tiện dụng của việc hoãn quản lý trạng thái session với trình duyệt: một session đã được xác thực có thể chia sẻ giữa nhiều tab với nhau hoặc nhiều cửa sổ trình duyệt và ngược lại; một hành động đăng xuất (sign-out) ở 1 tab sẽ vô hiệu hóa các session đang mở ở toàn bộ các cửa sổ đang mở khác.</p><h1 id="Cac-API-ung-dung-va-giao-thuc"><a href="#Cac-API-ung-dung-va-giao-thuc" class="headerlink" title="Các API ứng dụng và giao thức"></a>Các API ứng dụng và giao thức</h1><p>Càng đi sâu tìm hiểu về các dịch vụ network sẵn có thì cuối cùng chúng ta cũng đã tiến đến các API ứng dụng và giao thức (Application APIs &amp; Protocols). Như ta đã biết, những layer thấp thì cung cấp một mảng rộng các dịch vụ quan trọng: quản lý socket &amp; kết nối, xử lý request &amp; response, áp đặt nhiều chính sách bảo mật, lưu đệm &amp; còn nhiều nữa. Mỗi khi chúng ta khởi tạo HTTP hay XMLHttpRequest, sự kiện long-lived Server-Sent hay WebSocket session, hoặc mở kết nối WebRTC… chúng ta đang tương tác với một hoặc nhiều các dịch vụ đó.</p><p>Không có giao thức hay API nào tốt nhất. Mỗi ứng dụng phức tạp sẽ cần một tổ hợp các giao vận (transports) khác nhau dựa trên sự đa dạng của các yêu cầu: giao tiếp với bộ đệm trình duyệt, protocol overhead (metadata hoặc thông tin điều hướng mạng được gửi bởi ứng dụng), độ trễ của message, độ tin cậy, kiểu truyền tải dữ liệu, vân vân. Một số giao thức có thể đáp ứng với độ trễ thấp (ví dụ: Server-Sent Events, WebSocket), nhưng không yêu cầu các tiêu chí quan trọng khác, chẳng hạn như khả năng tận dụng bộ đệm trình duyệt hoặc hỗ trợ truyền tải nhị phân hiệu quả trong mọi trường hợp.</p><h1 id="Mot-vai-thu-ban-co-the-lam-de-cai-thien-hieu-nang-va-bao-mat-cua-Webapp"><a href="#Mot-vai-thu-ban-co-the-lam-de-cai-thien-hieu-nang-va-bao-mat-cua-Webapp" class="headerlink" title="Một vài thứ bạn có thể làm để cải thiện hiệu năng và bảo mật của Webapp"></a>Một vài thứ bạn có thể làm để cải thiện hiệu năng và bảo mật của Webapp</h1><ul><li>Luôn luôn sử dụng header <code>Connection: Keep-Alive</code> trong các request. Trình duyệt đã mặc định sẵn rồi. Đảm bảo server sử dụng cơ chế tương tự.</li><li>Sử dụng header Cache-Control, Etag và Last-Modified phù hợp để tiết kiệm thời gian download cho trình duyệt.</li><li>Dành thời gian để tinh chỉnh và tối ưu hóa web server, phép màu sẽ xảy ra! Nhớ rằng quá trình này rất cụ thể cho từng loại webapp và kiểu dữ liệu mà bạn trao đổi.</li><li>Luôn luôn dùng TLS! Đặc biệt nếu như bạn có bất kỳ xác thực nào trong ứng dụng của bạn.</li><li>Nghiên cứu trình duyệt cung cấp các chính sách bảo mật nào và áp đặt chúng vào trong ứng dụng của bạn.</li></ul><p>Hiệu năng và bảo mật là ưu tiên hàng đầu trong <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=js-series-networking-layer-outro" target="_blank" rel="noopener">SessionStack</a>. Lý do tại sao team tác giả không thể nghiêng về một bên nào hơn là bởi vì một khi đã tích hợp SessionStack vào webapp, nó bắt đầu giám sát mọi thứ từ thay đổi trên DOM, tương tác người dùng đến request mạng, biệt lệ và thông báo debug. Tất cả thông tin này được truyền về server theo thời gian thực và cho phép user có thể chạy lại các vấn đề đã xảy ra dưới dạng video &amp; xem mọi thứ xảy ra với người dùng của bạn. Tất cả hoạt động này được thực hiện với độ trễ tối thiểu và không ảnh hưởng tới hiệu năng của app của bạn.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 12 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Như đã nói trong bài trước về &lt;a href=&quot;https://kipalog.com/posts/Duc-khoet-Javascript--Phan-11---Render-engine---meo-toi-uu-hoa-hieu-nang-render&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;render engine&lt;/a&gt;, tác giả bài viết tin rằng sự khác biệt giữa một Javascript developer tốt (good) và tuyệt vời (great) là dev tuyệt vời không những hiểu về các thành phần cơ bản của một ngôn ngữ mà còn cả phần cốt lõi cũng như môi trường xung quanh nó.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P11: Render engine &amp; mẹo tối ưu hóa hiệu năng render</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P11-Render-engine-meo-toi-uu-hoa-hieu-nang-render.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P11-Render-engine-meo-toi-uu-hoa-hieu-nang-render.html</id>
    <published>2018-11-25T08:29:00.000Z</published>
    <updated>2018-11-25T08:33:25.317Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 11 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Trong những bài trước của series “Đục khoét Javascript”, chúng ta đã tập trung vào tìm hiểu <strong>ngôn ngữ</strong> Javascript, các tính năng của nó, cách chúng được thực thi trên trình duyệt, làm thế nào để tối ưu hóa, vân vân.</p><p>Tuy nhiên, khi bạn xây dựng webapp, bạn không chỉ viết code Javascript. Code của bạn còn tương tác với môi trường. Thấu hiểu môi trường, cách nó hoạt động cũng như các thành phần của nó sẽ cho phép bạn xây dựng app tốt hơn và có nền tảng chuẩn bị tốt để đề phòng những nguy cơ tiềm tàng có thể xảy đến bất cứ lúc nào khi lên production.<br><a id="more"></a><br><img src="https://cdn-images-1.medium.com/max/1000/1*lMBu87MtEsVFqqbfMum-kA.png" alt=""></p><p>Các thành phần chính của trình duyệt:</p><ul><li><strong>Giao diện (User interface)</strong>: phần này bao gồm thanh địa chỉ (address bar), nút back &amp; forward, menu bookmark, vân vân. Về bản chất, đây là những phần thuộc về trình duyệt hiển thị lên cho bạn thấy, ngoại trừ khung hiển thị trang web.</li><li><strong>Engine trình duyệt (Browser engine)</strong>: nó xử lý các giao tiếp giữa user interface và rendering engine</li><li><strong>Engine dựng hình (Rendering engine)</strong>: chịu trách nhiệm hiển thị trang web. Rendering engine sẽ phân giải HTML &amp; CSS và hiển thị nội dung đó lên màn hình.</li><li><strong>Mạng (Networking)</strong>: đây là những lời gọi mạng chẳng hạn như XHR request, chúng được tạo ra bằng cách sử dụng nhiều triển khai khác nhau cho nhiều nền tảng khác nhau nằm phía sau một interface độc lập nền tảng (platform-independent interface). Chúng ta sẽ thảo luận về lớp network chi tiết hơn ở bài tiếp theo (số 12) trong series này nhé.</li><li><strong>Giao diện ở backend (UI Backend)</strong>: dùng để vẽ nên các thành phần cốt lõi, ví dụ như checkbox hay cửa sổ. Phần này thể hiện một interface chung không phụ thuộc hay đặc trưng cho nền tảng. Nó sử dụng các phương thức về UI của hệ điều hành.</li><li><strong>Javascript engine</strong>: Chúng ta đã tìm hiểu về phần này trong <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-2---Ben-trong-engine-V8---5-meo-de-toi-uu-hoa-code" target="_blank" rel="noopener">bài trước</a>. Về cơ bản, đây là nơi code Javascript được thực thi.</li><li><strong>Cố định dữ liệu (Data persistence)</strong>: app của bạn có thể cần lưu trữ dữ liệu ở phía local. Các loại kiến trúc lưu trữ được hỗ trợ ở đây gồm có <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">localStorage</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">indexDB</a>, <a href="https://en.wikipedia.org/wiki/Web_SQL_Database" target="_blank" rel="noopener">WebSQL</a> và <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystem" target="_blank" rel="noopener">FileSystem</a></li></ul><p>Trong bài này, chúng ta sẽ tập trung vào rendering engine (engine dựng hình), bởi vì nó xử lý quá trình phân giải và hình ảnh hóa (visualization) code HTML &amp; CSS, là phần mà đa số app Javascript cần tương tác liên tục.</p><h1 id="Khai-quat-ve-rendering-engine"><a href="#Khai-quat-ve-rendering-engine" class="headerlink" title="Khái quát về rendering engine"></a>Khái quát về rendering engine</h1><p>Công việc chính của rendering engine là hiển thị trang được yêu cầu lên màn hình của trình duyệt.</p><p>Rendering engine có thể hiển thị HTML, văn bản XML và ảnh. Nếu bạn sử dụng thêm plugin ở ngoài thì engine có thể hiển thị các loại văn bản khác, chẳng hạn như PDF.</p><h1 id="Rendering-engines"><a href="#Rendering-engines" class="headerlink" title="Rendering engines"></a>Rendering engines</h1><p>Tương tự như Javascript engine, trình duyệt khác nhau cũng sử dụng các rendering engine khác nhau. Một vài bộ engine nổi tiếng:</p><ul><li><strong>Gecko</strong> — Firefox</li><li><strong>WebKit</strong> — Safari</li><li><strong>Blink</strong> — Chrome, Opera (từ phiên bản 15 trở đi)</li></ul><h1 id="Qua-trinh-render"><a href="#Qua-trinh-render" class="headerlink" title="Quá trình render"></a>Quá trình render</h1><p>Rendering engine nhận nội dung của văn bản được yêu cầu từ lớp networking.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*9b1uEMcZLWuGPuYcIn7ZXQ.png" alt=""></p><h1 id="Xay-dung-DOM-tree"><a href="#Xay-dung-DOM-tree" class="headerlink" title="Xây dựng DOM tree"></a>Xây dựng DOM tree</h1><p>Bước đầu tiên của công cuộc rendering là phân giải văn bản HTML và chuyển những phần tử đã phân giải thành những DOM node thực sự trong DOM tree.</p><p>Giả sử bạn có đoạn input như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"theme.css"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">  &lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt; Hello, &lt;span&gt; friend! &lt;/</span>span&gt; &lt;/p&gt;</span><br><span class="line">    &lt;div&gt; </span><br><span class="line">      &lt;img src=<span class="string">"smiley.gif"</span> alt=<span class="string">"Smiley face"</span> height=<span class="string">"42"</span> width=<span class="string">"42"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>DOM tree của đoạn HTML trên sẽ giống như sau:<br><img src="https://cdn-images-1.medium.com/max/1000/1*ezFoXqgf91umls9FqO0HsQ.png" alt=""></p><p>Về cơ bản thì mỗi phần tử được thể hiện như là một node cha của tất cả các element khác nằm trực tiếp ngay bên dưới (bên trong) nó. Nguyên tắc này được áp dụng một cách đệ quy.</p><h1 id="Xay-dung-CSSOM-tree"><a href="#Xay-dung-CSSOM-tree" class="headerlink" title="Xây dựng CSSOM tree"></a>Xây dựng CSSOM tree</h1><p>CSSOM viết tắt của <strong>CSS Object Model</strong>. Trong khi trình duyệt đang xây dựng DOM, nó bắt gặp một thẻ link trong phần head và dẫn tới một file CSS tên là theme.css ở bên ngoài. Dự đoán rằng nó có thể cần đến tài nguyên này để render trang, ngay lập tức nó điều phối 1 request đến. Giả sử file theme.css có nội dung như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">body &#123; </span><br><span class="line">  font-size: <span class="number">16</span>px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123; </span><br><span class="line">  font-weight: bold; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">span &#123; </span><br><span class="line">  color: red; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p span &#123; </span><br><span class="line">  display: none; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img &#123; </span><br><span class="line">  float: right; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tương tự HTML, engine cần chuyển tất cả CSS sang một thứ gì đó mà trình duyệt có thể xử lý, chính là CSSOM. Dưới đây là mô phỏng của CSSOM tree:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*5YU1su2mdzHEQ5iDisKUyw.png" alt=""></p><p>Bạn có tự hỏi tại sao CSSOM lại có cấu trúc dạng cây (tree)? Khi tính toán bộ style cuối cùng cho mỗi object tren trang, trình duyệt sẽ bắt đầu với rule áp dụng toàn cục nhất cho node đó (ví dụ: nếu nó là con của phần tử body thì áp dụng tất cả style của body) và tinh chỉnh một cách đệ quy những style đã được tính toán bằng cách áp dụng các rule cụ thể hơn.</p><p>Với ví dụ ở trên, bất kỳ text nào nằm bên trong thẻ span mà span nằm trong phần tử body thì đều có font-size 16 và màu đỏ. Những style này được kế thừa từ phần tử body. Nếu như span là con của phần tử p thì nội dung của nó sẽ bị ẩn bởi vì có style khác cụ thể hơn đã được áp dụng cho nó (ở đây là display: none).</p><p>Thêm nữa, lưu ý rằng tree ở trên chưa phải là CSSOM tree hoàn chỉnh và chỉ thể hiện những style mà ta đã ghi đè trong style sheet. Mỗi trình duyệt cung cấp 1 bộ style mặc định, còn được biết tới là <strong>user agent styles</strong> - đây chính những gì ta thấy nếu như không cung cấp style cụ thể. Style của chúng ta thêm vào chỉ đơn giản là ghi đè lại những phần mặc định này.</p><h1 id="Xay-dung-render-tree"><a href="#Xay-dung-render-tree" class="headerlink" title="Xây dựng render tree"></a>Xây dựng render tree</h1><p>Cùng với phần thể hiện trực quan trong HTML kết hợp với dữ liệu style từ CSSOM tree là chúng ta đã có đủ nguyên liệu để tạo ra render tree.</p><p>Bạn sẽ thắc mắc “render tree” là gì? Nó là 1 cây (tree) của các phần tử trực quan được xây dựng theo thứ tự trong đó chúng được hiển thị trên màn hình. Đó là sự thể hiện 1 cách trực quan của HTML cùng với CSS tương ứng. Mục đích của cây này là cho phép tô màu nội dung theo đúng thứ tự.</p><p>Mỗi node trong render tree được gọi là 1 renderer hoặc render object trong Webkit.</p><p>Dưới đây là cách mà render tree của DOM &amp; CSSOM ở trên thể hiện:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*WHR_08AD8APDITQ-4CFDgg.png" alt=""></p><p>Để xây dựng render tree, trình duyệt về cơ bản sẽ làm những bước sau đây:</p><ul><li>Bắt đầu từ root của DOM tree, nó sẽ đi qua mỗi <strong>node thấy được</strong>. Vài node có thể bị ẩn đi (ví dụ như tag script, meta, vân vân) hoặc bỏ qua bởi vì chúng không phản chiếu trong kết quả render đầu ra. Vài node bị ẩn bởi CSS và cũng bị bỏ qua khỏi render tree. Ví dụ như node span trong ví dụ trên thì nó sẽ không có mặt trong render tree vì đã được set style display: none rồi.</li><li>Với mỗi node thấy được, trình duyệt sẽ tìm các rule CSSOM phù hợp và khớp với nó rồi áp dụng vào.</li><li>Trình duyệt sẽ xuất ra các node thấy được với nội dung và style tương ứng.</li></ul><p>Bạn có thể xem qua source code của RenderObject (WebKit) ở đây: <a href="https://github.com/WebKit/webkit/blob/fde57e46b1f8d7dde4b2006aaf7ebe5a09a6984b/Source/WebCore/rendering/RenderObject.h" target="_blank" rel="noopener">https://github.com/WebKit/webkit/blob/fde57e46b1f8d7dde4b2006aaf7ebe5a09a6984b/Source/WebCore/rendering/RenderObject.h</a></p><p>Cùng nghía qua một vài dòng cốt lõi trong class này nhé:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class RenderObject : public CachedImageClient &#123;</span><br><span class="line">  <span class="comment">// Tô màu lại toàn bộ object. Nó sẽ được gọi khi border color thay đổi hoặc</span></span><br><span class="line">  <span class="comment">// border style thay đổi.</span></span><br><span class="line"></span><br><span class="line">  Node* node() <span class="keyword">const</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  RenderStyle* style;  <span class="comment">// the computed style</span></span><br><span class="line">  <span class="keyword">const</span> RenderStyle&amp; style() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mỗi renderer thể hiện một khu vực hình chữ nhật tương ứng với CSS box của một node. Nó bao gồm cả thông tin hình học như độ rộng (width), chiều cao (height) hay vị trí (position).</p><h1 id="Cach-bo-tri-cua-render-tree"><a href="#Cach-bo-tri-cua-render-tree" class="headerlink" title="Cách bố trí của render tree"></a>Cách bố trí của render tree</h1><p>Khi renderer được tạo ra và thêm vào tree, nó không có thông tin vị trí hay kích thước, phần tính toán các giá trị này được gọi là layout.</p><p>HTML sử dụng mô hình layout theo dòng (flow-based layout), nghĩa là hầu như toàn bộ thời gian nó có thể tính toán thông số hình học chỉ trong 1 lần duyệt. Hệ thống tọa độ có liên quan đến root renderer. Thông số tọa độ top và left được sử dụng.</p><p>Layout là 1 quá trình đệ quy, nó bắt đầu ở root renderer, chính là thứ tương ứng với phần tử <html> trong văn bản HTML. Layout tiếp tục duyệt đệ quy qua một hoặc toàn bộ cây cấp bậc(hierarchy) renderer, tính toán các thông tin hình học cần thiết cho mỗi renderer.</html></p><p>Vị trí của root renderer là 0,0 và kích thước của nó bằng phần nhìn thấy được của cửa sổ hiển thị trên trình duyệt (còn gọi là viewport).</p><p>Bắt đầu quá trình tạo layout chính là truyền đạt lại cho mỗi node tọa độ chính xác mà nó cần phải xuất hiện trên màn hình là ở đâu.</p><h1 id="To-mau-cho-render-tree"><a href="#To-mau-cho-render-tree" class="headerlink" title="Tô màu cho render tree"></a>Tô màu cho render tree</h1><p>Trong giai đoạn này, renderer tree đã được duyệt qua và phương thức paint() của renderer được gọi để hiển thị nội dung lên màn hình.</p><p>Tô màu có thể theo cách global hoặc incremantal tương tự như layout):</p><ul><li><strong>Global (toàn cục)</strong>: toàn bộ tree được lên màu.</li><li><strong>Incremental (gia tăng)</strong>: chỉ có một vài renderer thay đổi theo cách không ảnh hưởng đến toàn bộ tree. Renderer vô hiệu hóa khung chữ nhật của chính nó trên màn hình. Điều này làm cho OS (hệ điều thành) hiểu rằng vùng đó cần phải được tô màu lại và sinh ra một paint event. OS thực hiện điều đó một cách thông minh bằng cách gộp nhiều vùng thành một.</li></ul><p>Về tổng quát thì quan trọng là cần phải hiểu rằng tô màu là quá trình diễn ra từ từ. Để có UX tốt hơn, render engine sẽ cố hiển thị nội dung trên màn hình ngay khi có thể. Nó sẽ không ngồi yên đợi cho tới khi toàn bộ HTML được parse để bắt đầu xây dựng và bố trí render tree. Từng phần của nội dung sẽ được parse và hiển thị lên trong khi tiến trình tiếp tục với những item nội dung tiếp theo đang được truyền về trên mạng.</p><h1 id="Thu-tu-xu-ly-script-va-style"><a href="#Thu-tu-xu-ly-script-va-style" class="headerlink" title="Thứ tự xử lý script và style"></a>Thứ tự xử lý script và style</h1><p>Các script được parse và thực thi ngay lập tức khi parser vừa gặp thẻ <code>&lt;script&gt;</code>. Quá trình parse của toàn bộ văn bản sẽ tạm dừng cho đến khi script thực thi xong. Nghĩa là tiến trình này diễn ra đồng bộ.</p><p>Nếu như script là file ở ngoài thì việc đầu tiên nó cần phải được lấy về từ mạng (bất đồng bộ). Tất cả công việc parse sẽ dừng lại cho đến khi lấy xong file.</p><p>HTML5 có thêm 1 tùy chọn để đánh dấu script là bất đồng bộ, do đó nó có thể được parse và thực thi trong 1 tiến trình khác.</p><h1 id="Toi-uu-hoa-hieu-suat-render"><a href="#Toi-uu-hoa-hieu-suat-render" class="headerlink" title="Tối ưu hóa hiệu suất render"></a>Tối ưu hóa hiệu suất render</h1><p>Nếu bạn muốn tối ưu hóa app thì có 5 điểm chính mà bạn cần tập trung vào dưới đây:</p><ol><li><strong>Javascript</strong> - trong các bài trước chúng ta đã nghiên cứu về chủ đề viết code tối ưu và có hiệu quả bộ nhớ cao mà không làm ảnh hưởng đến UI. Với trường hợp của render, chúng ta cần phải suy nghĩ về cách mà code Javascript sẽ tương tác với các phần tử DOM trên trang. Javascript có thể tạo ra rất nhiều thay đổi với UI, đặc biệt là các app SPA.</li><li><strong>Tính toán Style</strong> - đây là tiến trình xác định CSS rule nào sẽ áp dụng vào phần tử nào dựa trên các selector. Một khi các rule đã được định nghĩa, chúng sẽ được áp dụng và tính toán style cuối cùng cho mỗi phần tử.</li><li><strong>Layout</strong> - khi trình duyệt biết rule nào áp dụng cho phần tử nào, nó có thể bắt đầu tính toán bao nhiêu không gian một phần tử sẽ chiếm dụng và vị trí của nó sẽ nằm ở đâu trên màn hình của trình duyệt. Mô hình layout của trang web xác định một phần tử có thể gây ảnh hưởng đến phần tử khác. Ví dụ, độ rộng của <body> có thể ảnh hưởng độ rộng của phần tử con của nó. Điều này nghĩa là quá trình layout sẽ là quá trình nặng về tính toán số học. Phần “vẽ” được thực hiện trong nhiều layer khác nhau.</body></li><li><strong>Tô màu</strong> - đây là lúc mà các pixel thực sự được lên màu. Tiến trình bao gồm cả phần vẽ các câu chữ, màu sắc, hình ảnh, viền, đổ bóng, vấn vân, từng phần nhìn thấy được của từng phần tử.</li><li><strong>Kết hợp (Compositing)</strong> - Bởi vì các phần nhỏ của webpage được vẽ vào trong nhiều lớp khác nhau, chúng cần được kết hợp vào một màn hình theo đúng thứ tự để page có thể render một cách chính xác. Điều này rất quan trọng, đặc biệt là với các phần tử chồng nhau.</li></ol><h1 id="Toi-uu-hoa-JavaScript"><a href="#Toi-uu-hoa-JavaScript" class="headerlink" title="Tối ưu hóa JavaScript"></a>Tối ưu hóa JavaScript</h1><p>Javascript thường trigger những thay đổi nhìn thấy được trên trình duyệt. Và những tác vụ đó nhân lên nhiều lần khi xây dựng ứng dụng SPA.</p><p>Dưới đây là 1 số mẹo nhỏ để bạn biết nên tối ưu phần nào của code Javascript nhằm cải thiện render:</p><ul><li>Tránh sử dụng setTimeout và setInterval đối với những cập nhật nhìn thấy được. Hai hàm này sẽ gọi callback tại 1 thời điểm nào đó trong frame, có thể là cuối frame. Thứ chúng ta cần là trigger thay đổi ngay khi bắt đầu frame để tránh bị sót.</li><li>Đưa những tính toán Javascript phức tạp và tốn thời gian vào trong Web Workers như chúng ta đã thảo luận ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-7---Thanh-phan-cua-WebWorker---5-truong-hop-su-dung" target="_blank" rel="noopener">bài trước</a>.</li><li>Sử dụng các tác vụ siêu nhỏ (micro-tasks) để thông báo sự thay đổi của DOM với nhiều frame. Dùng trong trường hợp các tác vụ cần truy xuất vào DOM, điều này Web Workers không làm được. Về cơ bản thì nó nghĩa là bạn cần chia nhỏ 1 tác vụ lớn thành nhiều phần nhỏ hơn và chạy chúng bên trong các hàm requestAnimationFrame, setTimeout, setInterval tùy thuộc vào đặc tính của mỗi tác vụ.</li></ul><h1 id="Toi-uu-hoa-CSS"><a href="#Toi-uu-hoa-CSS" class="headerlink" title="Tối ưu hóa CSS"></a>Tối ưu hóa CSS</h1><p>Chỉnh sửa DOM bằng cách thêm bớt các phần tử, thay đổi các thuộc tính… sẽ làm cho trình duyệt phải tính toán lại style của phần tử và trong nhiều trường hợp, là phải tính lại layout của toàn bộ trang hoặc 1 phần của trang.</p><p>Để tối ưu quá trình render, bạn cần cân nhắc những điều sau:</p><ul><li>Giảm thiểu sự phức tạp trong các selector. Sự phức tạp của selector có thể chiếm đến hơn 50% thời gian cần thiết để tính toán style cho 1 phần tử (phần còn lại là thời gian để xây dựng style).</li><li>Giảm số lượng phần tử cần được tính toán style. Về bản chất thì thay đổi style trực tiếp cho 1 vài phần tử thì tốt hơn là vô hiệu toàn bộ page.</li></ul><h1 id="Toi-uu-hoa-layout"><a href="#Toi-uu-hoa-layout" class="headerlink" title="Tối ưu hóa layout"></a>Tối ưu hóa layout</h1><p>Tính toán lại layout có thể ngốn nhiều tài nguyên của trình duyệt nên bạn cần cân nhắc những điều sau:</p><ul><li>Giảm số lượng layout bất cứ khi nào có thể. Khi bạn thay đổi style thì trình duyệt kiểm tra để xem thử có thay đổi nào cần layout phải được tính toán lại không. Các thay đổi về property như width, height, left, top và trên hết là những property nào liên quan đến hình học, cần có layout. Vì thế tránh thay đổi chúng hết mức có thể.</li><li>Dùng flexbox bất cứ khi nào có thể dùng. Nó chạy nhanh hơn và có thể cải thiện hiệu năng một cách đáng kể.</li><li>Tránh ép buộc layout đồng bộ. Nhớ rằng khi Javascript chạy, tất cả giá trị của layout cũ từ frame trước đó được xác định và sẵn sàng cho bạn truy vấn. Không vấn đề gì nếu như bạn muốn truy xuất box.offsetHeight. Tuy nhiên, nếu bạn thay đổi style của box trước khi nó được truy xuất (ví dụ: cố tình thêm CSS class vào 1 phần tử), trình duyệt đầu tiên sẽ áp dụng thay đổi của style rồi sau đó mới chạy đến phần layout. Điều có có thể gây tốn thời gian và làm ảnh hưởng nặng đến tài nguyên máy tính, vì thế nên tránh càng xa nó càng tốt.</li></ul><h1 id="Toi-uu-hoa-to-mau"><a href="#Toi-uu-hoa-to-mau" class="headerlink" title="Tối ưu hóa tô màu"></a>Tối ưu hóa tô màu</h1><p>Đây thường là tác vụ chạy lâu nhất trong số các tác vụ nên quan trọng là tránh mặt nó càng xa càng tốt. Những gì bạn có thể làm:</p><ul><li>Thay đổi bất kỳ property nào khác ngoài transform hay opacity sẽ trigger tác vụ tô màu. Nhớ sử dụng tiết kiệm nhé.</li><li>Nếu bạn trigger một layout, bạn cũng sẽ trigger luôn tác vụ tô màu bởi vì thay đổi về kích thước hình học cũng sẽ thay đổi phần nhìn thấy được của phần tử.</li><li>Giảm diện tích tô màu thông qua thăng cấp layer và dàn dựng các animation.</li></ul><p>Render là một khía cạnh quan trọng trong cách thức hoạt động của <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=js-series-rendering-engine-outro" target="_blank" rel="noopener">SessionStack</a>. SessionStack phải tái tạo lại một video về mọi thứ đã diễn ra với user tại thời điểm họ trải nghiệm qua một vấn đề khi đang lướt webapp của bạn. Để làm được điều này, SessionStack chỉ xử lý duy nhất những dữ liệu mà thư viện của nó thu thập được: các sự kiện từ user, thay đổi trên DOM, request lên mạng, biệt lệ, thông báo debug, vân vân. Trình phát video được tối ưu hóa tối đa để có thể render một cách chính xác và sử dụng toàn bộ những dữ liệu thu thập được để có thể đưa ra một bản giả lập trình duyệt của user hoàn-hảo-đến-từng-pixel cũng như những gì đã xảy ra trên đó, cả về mặt kỹ thuật lẫn quan sát.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 11 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Trong những bài trước của series “Đục khoét Javascript”, chúng ta đã tập trung vào tìm hiểu &lt;strong&gt;ngôn ngữ&lt;/strong&gt; Javascript, các tính năng của nó, cách chúng được thực thi trên trình duyệt, làm thế nào để tối ưu hóa, vân vân.&lt;/p&gt;
&lt;p&gt;Tuy nhiên, khi bạn xây dựng webapp, bạn không chỉ viết code Javascript. Code của bạn còn tương tác với môi trường. Thấu hiểu môi trường, cách nó hoạt động cũng như các thành phần của nó sẽ cho phép bạn xây dựng app tốt hơn và có nền tảng chuẩn bị tốt để đề phòng những nguy cơ tiềm tàng có thể xảy đến bất cứ lúc nào khi lên production.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P10: Quan sát thay đổi trên DOM bằng MutationObserver</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P10-Quan-sat-thay-doi-tren-DOM-bang-MutationObserver.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P10-Quan-sat-thay-doi-tren-DOM-bang-MutationObserver.html</id>
    <published>2018-11-25T08:24:00.000Z</published>
    <updated>2018-11-25T08:29:18.823Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 10 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*mPXf5zRCdEQ42Hn0." alt=""></p><p>Webapp càng ngày càng nặng hơn ở phía client bởi vì nhiều lý do đại loại như UI phải “phì nhiêu” để chứa đựng những thứ logic phức tạp bên trong bao gồm cả tính toán theo thời gian thực (real-time), và nhiều nhiều thứ khác nữa.</p><p>Sự phức tạp gia tăng làm cho chúng ta khó nắm bắt chính xác trạng thái của UI tại mỗi thời điểm trong vòng đời của webapp.</p><p>Điều này càng khó hơn nữa nếu chúng ta xây dựng một vài thứ chẳng hạn như library hay framework mà cần phải phản ứng cũng như xử lý những hành động dựa trên DOM.<br><a id="more"></a></p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a> (tạm dịch: Người quan sát sự biến đổi) là một WebAPI được các trình duyệt hiện đại cung cấp để phát hiện các thay đổi trên DOM. Với API này một người có thể listen các node mới được thêm vào hoặc gỡ ra, thuộc tính thay đổi hoặc những thay đổi về nội dung văn bản trong một text node.</p><p>Tại sao phải cần làm thế?</p><p>Có một số ít trường hợp trong đó MutationObserver API thực sự hữu ích. Ví dụ:</p><ul><li>Bạn muốn thông báo cho người dùng webapp rằng một vài sự thay đổi đã xảy ra trên trang mà người đó đang sử dụng.</li><li>Bạn đang làm việc với 1 Javascript framework sang chảnh mới, nó cần load rất nhiều JS module một cách tự động dựa trên sự thay đổi của DOM.</li><li>Bạn đang làm việc với bộ soạn thảo WYSIWYG và thử triển khai tính năng undo/redo. Bằng cách tận dụng MutationObserver API, bất kỳ lúc nào bạn cũng có thể biết phần nào đã thay đổi và dễ dàng undo chúng.</li></ul><p><img src="https://cdn-images-1.medium.com/max/1000/1*48tGIboHxgLeKEjMTGkUGg.png" alt=""></p><p>Trên đây chỉ là 1 số ví dụ về lợi ích của MutationObserver.</p><h1 id="Cach-su-dung-MutationObserver"><a href="#Cach-su-dung-MutationObserver" class="headerlink" title="Cách sử dụng MutationObserver"></a>Cách sử dụng MutationObserver</h1><p>Triển khai MutationObserver khá dễ dàng. Bạn cần tạo 1 instance MutationObserver bằng cách truyền cho nó 1 hàm và hàm này được gọi mỗi khi 1 sự thay đổi xảy ra. Đối số đầu tiên của hàm là 1 tập hợp tất cả các sự thay đổi xảy ra trên 1 khối duy nhất. Mỗi sự thay đổi cung cấp thông tin về loại của nó cũng như thay đổi nào đã xảy ra.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutationObserver = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</span><br><span class="line">  mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mutation);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Object tạo ra có 3 phương thức:</p><ul><li><strong>observe</strong>: bắt đầu lắng nghe sự thay đổi. Nó nhận 2 đối số: DOM node mà bạn muốn quan sát và một object chưa các thiết lập.</li><li><strong>disconnect</strong>: dừng quá trình lắng nghe thay đổi.</li><li><strong>takeRecords</strong>: trả về khối thay đổi cuối cùng trước khi callback được kích hoạt.</li></ul><p>Đoạn code sau thể hiện quá trình quan sát (observing) diễn ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bắt đầu lắng nghe thay đổi trong root HTML của trang.</span></span><br><span class="line">mutationObserver.observe(<span class="built_in">document</span>.documentElement, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span>,</span><br><span class="line">  characterData: <span class="literal">true</span>,</span><br><span class="line">  childList: <span class="literal">true</span>,</span><br><span class="line">  subtree: <span class="literal">true</span>,</span><br><span class="line">  attributeOldValue: <span class="literal">true</span>,</span><br><span class="line">  characterDataOldValue: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Giờ giả sử ta có 1 div cực kỳ đơn giản trong DOM:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"sample-div"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"test"</span>&gt; Simple div &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>Sử dụng jQuery, bạn có thể xóa thuộc tính class từ div đó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#sample-div"</span>).removeAttr(<span class="string">"class"</span>);</span><br></pre></td></tr></table></figure><p>Khi đã bắt đầu quan sát, sau khi gọi hàm mutationObserver.observe(…) ta có thể xem thông tin log được in ra trong console của <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord" target="_blank" rel="noopener">MutationRecord</a>.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*UxkSstuyCvmKkBTnjbezNw.png" alt=""></p><p>Đây là sự biến đổi tạo ra bởi ta đã xóa thuộc tính class.</p><p>Cuối cùng, để dừng sự quan sát DOM sau khi đã xong việc, ta làm như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dừng MutationObserver, không lắng nghe thay đổi nữa.</span></span><br><span class="line">mutationObserver.disconnect();</span><br></pre></td></tr></table></figure><p>Ngày nay MutationObserver được hỗ trợ khá tốt:</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*nlOmrsfy-Y1XoR8B." alt=""></p><h1 id="Giai-phap-thay-the"><a href="#Giai-phap-thay-the" class="headerlink" title="Giải pháp thay thế"></a>Giải pháp thay thế</h1><p>Tuy nhiên, MutationObserver cũng chỉ mới xuất hiện chưa lâu. Vậy thì trước khi có nó, các developer dùng cái gì?</p><p>Dưới đây là 1 vài lựa chọn:</p><ul><li><strong>Polling</strong></li><li><strong>MutationEvents</strong></li><li><strong>CSS animations</strong></li></ul><h2 id="Polling"><a href="#Polling" class="headerlink" title="Polling"></a>Polling</h2><p>Giải pháp đơn giản nhất và kém tinh tế nhất là polling (bỏ phiếu bình chọn). Sử dụng WebAPI setInterval bạn có thể thiết lập 1 tác vụ kiểm tra sự thay đổi theo chu kỳ nhất định. Dĩ nhiên thì cách này làm giảm hiệu năng của webapp 1 cách đáng sợ.</p><h2 id="MutationEvents"><a href="#MutationEvents" class="headerlink" title="MutationEvents"></a>MutationEvents</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events" target="_blank" rel="noopener">MutationEvents API</a> được giới thiệu vào năm 2000. Mặc dù nó có ích, các sự kiện thay đổi (mutation events) được bắn ra mỗi khi có 1 sự thay đổi bất kỳ trên DOM và một lần nữa làm ảnh hưởng đến hiệu năng. Ngày nay thì MutationEvents API đã bị hủy bỏ và những trình duyệt hiện đại sẽ sớm ngừng hỗ trợ nó.</p><p>Danh mục trình duyệt hỗ trợ cho MutationEvents:</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*l-QdpBfjwNfPDTyh." alt=""></p><h2 id="CSS-animations"><a href="#CSS-animations" class="headerlink" title="CSS animations"></a>CSS animations</h2><p>Một giải pháp thay thế hơi kỳ cục đó là dựa trên <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations" target="_blank" rel="noopener">CSS Animations</a>. Nghe có vẻ bối rối nhỉ. Về cơ bản thì ý tưởng của nó là tạo ra 1 animation có thể được trigger khi có một element được thêm vào DOM. Khoảnh khắc animation bắt đầu, sự kiện animationstart sẽ được bắn ra: nếu bạn đã gắn 1 event handler vào sự kiện đó thì bạn sẽ biết 1 cách chính xác khi nào element được thêm vào DOM. Thời gian thực hiện của animation phải cực nhỏ để cho nó dường như vô hình trước con mắt user.</p><p>Đầu tiên ta cần một element cha, bên trong nó ta sẽ listen sự kiện chèn node:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=”container-element”&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>Để có thể xử lý khi có node chèn vào, ta cần thiết lập một chuỗi các <a href="https://www.w3schools.com/cssref/css3_pr_animation-keyframes.asp" target="_blank" rel="noopener">keyframe</a> animation khởi động khi node được thêm vào:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@keyframes nodeInserted &#123; </span><br><span class="line"> <span class="keyword">from</span> &#123; <span class="attr">opacity</span>: <span class="number">0.99</span>; &#125;</span><br><span class="line"> to &#123; <span class="attr">opacity</span>: <span class="number">1</span>; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Với keyframe được tạo ra đó, animation cần phải được áp dụng vào các element mà ta muốn lắng nghe. Lưu ý là thời gian duration rất nhỏ, mục đích là để kéo dãn dấu vết của animation trên trình duyệt:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#container-element * &#123;</span><br><span class="line"> animation-duration: <span class="number">0.001</span>s;</span><br><span class="line"> animation-name: nodeInserted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bước thiết lập này sẽ thêm animation vào tất cả các node con của container-element. Khi animation kết thúc (sau 0.001s như trên), sự kiện chèn node sẽ được bắn ra.</p><p>Ta cần một hàm event listener Javascript. Trong hàm đó ta phải gọi event.animationName để đảm bảo đó chính là animation mà ta cần.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertionListener = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Đảm bảo đây là animation mà ta cần xử lý.</span></span><br><span class="line">  <span class="keyword">if</span> (event.animationName === <span class="string">"nodeInserted"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Node has been inserted: "</span> + event.target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Giờ thì thêm event listener vào node cha:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(“animationstart”, insertionListener, <span class="literal">false</span>); <span class="comment">// standard + firefox</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(“MSAnimationStart”, insertionListener, <span class="literal">false</span>); <span class="comment">// IE</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(“webkitAnimationStart”, insertionListener, <span class="literal">false</span>); <span class="comment">// Chrome + Safari</span></span><br></pre></td></tr></table></figure><p>Trình duyệt hỗ trợ CSS animation:</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*W4wHvVAeUmc45vA2." alt=""></p><p>MutationObserver cung cấp một số tính năng nâng cao hơn tất cả 3 giải pháp trên. Về bản chất, nó bao phủ toàn bộ mỗi thay đổi có thể diễn ra trên DOM và nó được tối ưu hóa khi bắn ra các thay đổi trong 1 chuỗi hàng loạt. Trên hết MutationObserver được hỗ trợ bởi tất cả các trình duyệt hiện đại đi kèm với 1 số polyfills để dùng MutationEvents</p><p>MutationObserver chiếm giữ một vị trí trung tâm trong thư viện của <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=mutation-observer-post" target="_blank" rel="noopener">SessionStack</a>.</p><p>Khi bạn đã tích hợp thư viện của SessionStack vào webapp, nó bắt đầu thu thập các thông tin chẳng hạn như thay đổi trên DOM, request mạng, biệt lệ, thông báo debug, vân vân, và gửi chúng về server. SessionStack dùng chính những dữ liệu này để tái tạo lại mọi thứ đã xảy ra với user của bạn và hiển thị các vấn đề của sản phẩm trong cùng 1 tình huống mà nó diễn ra với user. Khá nhiều người nghĩ rằng SessionStack ghi lại video, nhưng không phải vậy. Ghi video rất tốn kém, mặt khác lượng dữ liệu thu thập được lại rất nhẹ và không ảnh hưởng đến UX cũng như hiệu năng của webapp của bạn.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 10 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1000/0*mPXf5zRCdEQ42Hn0.&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Webapp càng ngày càng nặng hơn ở phía client bởi vì nhiều lý do đại loại như UI phải “phì nhiêu” để chứa đựng những thứ logic phức tạp bên trong bao gồm cả tính toán theo thời gian thực (real-time), và nhiều nhiều thứ khác nữa.&lt;/p&gt;
&lt;p&gt;Sự phức tạp gia tăng làm cho chúng ta khó nắm bắt chính xác trạng thái của UI tại mỗi thời điểm trong vòng đời của webapp.&lt;/p&gt;
&lt;p&gt;Điều này càng khó hơn nữa nếu chúng ta xây dựng một vài thứ chẳng hạn như library hay framework mà cần phải phản ứng cũng như xử lý những hành động dựa trên DOM.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P9: Cấu tạo của Web Push Notifications</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P9-Cau-tao-cua-Web-Push-Notifications.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P9-Cau-tao-cua-Web-Push-Notifications.html</id>
    <published>2018-11-24T15:51:00.000Z</published>
    <updated>2018-11-24T15:53:39.773Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 9 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Hôm nay chúng ta sẽ chuyển hướng sự chú ý qua <strong>web push notifications</strong> (tạm dịch: thông báo đẩy trên trang web): chúng ta sẽ tìm hiểu về thành phần của nó, khám phá các quy trình gửi/nhận thông báo phía sau và cuối bài sẽ cùng tìm hiểu làm sao SessionStack sử dụng chúng để xây dựng chức năng của sản phẩm.</p><p>Push Notifications rất phổ biến trong thế giới của điện thoại. Vì lý do này hay lý do khác, chúng bước chân vào thế giới web lại khá muộn mặc dù nó là tính năng rất được các developer ưa chuộng và đề xuất.<br><a id="more"></a></p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Web Push Notifications cho phép user tham gia vào các cập nhật theo thời gian từ webapp nhằm mục đích thu hút người dùng dựa trên nội dung thú vị, quan trọng và đúng lúc đối với họ.</p><p>Push dựa trên Service Workers - chính là chủ đề mà chúng ta đã <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-8---Service-Workers--vong-doi-va-cac-truong-hop-su-dung" target="_blank" rel="noopener">thảo luận ở bài trước</a>.</p><p>Lý do lựa chọn dùng Service Workers trong trường hợp này là vì chúng hoạt động trong background. Rất phù hợp cho Push Notifications vì như vậy nghĩa là code chỉ được thực thi khi user tương tác với chính notification đó.</p><h1 id="Push-amp-notification"><a href="#Push-amp-notification" class="headerlink" title="Push &amp; notification"></a>Push &amp; notification</h1><p>Push và notification là 2 API khác nhau.</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API" target="_blank" rel="noopener">Push</a>: được gọi khi server cung cấp thông tin cho Server Worker</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API" target="_blank" rel="noopener">Notification</a>: hành động của Service Worker hoặc một đoạn script trên webapp nhằm hiển thị thông tin đến user.</li></ul><h1 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h1><p>Có 3 bước cơ bản để triển khai 1 push:</p><ul><li><strong>Giao diện (UI)</strong>: thêm vào những logic cần thiết ở phía client để đăng ký user với push. Đây là phần logic Javascript mà UI của webapp cần để cho phép user đăng ký vào push message.</li><li><strong>Gửi push message</strong>: triển khai lời gọi API trên server để trigger một push message tới thiết bị của user.</li><li><strong>Nhận push message</strong>: xử lý push message một khi nó về tới trình duyệt.</li></ul><p>Giờ thì chúng ta sẽ tìm hiểu toàn bộ quá trình một cách chi tiết hơn.</p><h1 id="Xac-nhan-ho-tro-tu-trinh-duyet"><a href="#Xac-nhan-ho-tro-tu-trinh-duyet" class="headerlink" title="Xác nhận hỗ trợ từ trình duyệt"></a>Xác nhận hỗ trợ từ trình duyệt</h1><p>Đầu tiên là cần phải kiểm tra xem trình duyệt bạn đang dùng có hỗ trợ cho push message hay không. Chúng ta có 2 bài check đơn giản:</p><ul><li>Kiểm tra serviceWorker trong object navigator</li><li>Kiểm tra PushManager trong object window</li></ul><p>Code kiểm tra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator)) &#123; </span><br><span class="line">  <span class="comment">// Service Worker không được hỗ trợ, vô hiệu hóa hoặc ẩn UI đi. </span></span><br><span class="line">  <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(<span class="string">'PushManager'</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123; </span><br><span class="line">  <span class="comment">// Push không được hỗ trợ, vô hiệu hóa hoặc ẩn UI đi. </span></span><br><span class="line">  <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dang-ky-mot-Service-Worker"><a href="#Dang-ky-mot-Service-Worker" class="headerlink" title="Đăng ký một Service Worker"></a>Đăng ký một Service Worker</h1><p>Tại thời điểm này, ta đã biết các chức năng đều được hỗ trợ. Bước tiếp theo sẽ là đăng ký Service Worker.</p><p>Đăng ký một Service Worker như thế nào thì bạn cũng đã quen với những diễn giải từ <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-8---Service-Workers--vong-doi-va-cac-truong-hop-su-dung" target="_blank" rel="noopener">bài trước</a> rồi.</p><h1 id="Yeu-cau-duoc-cap-quyen"><a href="#Yeu-cau-duoc-cap-quyen" class="headerlink" title="Yêu cầu được cấp quyền"></a>Yêu cầu được cấp quyền</h1><p>Xong phần với Service Worker thì ta có thể đi tiếp đến phần đăng ký user. Bạn cần phải có quyền của user thì mới gửi push message đến họ được.</p><p>API dùng để lấy quyền (permission) cũng tương đổi đơn giản, tuy nhiên điểm bất lợi là API đã thay đổi từ việc dùng callback sang trả về Promise. Nó sinh ra vấn đề khác: chúng ta không thể biết version của API đã được triển khai trên trình duyệt hiện tại, vì thế chúng ta phải xử lý cả 2 trường hợp.</p><p>Nó trông như thế này đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestPermission</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> permissionResult = Notification.requestPermission(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Xử lý phiên bản cũ với callback.</span></span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (permissionResult) &#123;</span><br><span class="line">      permissionResult.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">permissionResult</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permissionResult !== <span class="string">'granted'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Permission not granted.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lời gọi đến Notification.requestPermission() sẽ hiển thị 1 bảng thông báo nhỏ:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*xhB8ceUNM6vb8s0ZQKMHNg.png" alt=""></p><p>Một khi quyền đã được cấp, được đóng hoặc block thì chúng ta cũng nhận được những kết quả tương tự dưới dạng string: granted, default, denied.</p><p>Nhớ rằng nếu user click chuột vào nút Block thì webapp của bạn sẽ không thể hỏi user về chuyện cấp quyền một lần nữa, cho tới khi user tự “unblock” app của bạn bằng cách thay đổi trạng thái của quyền. Tùy chọn này được giấu trong bảng cài đặt.</p><h1 id="Dang-ky-mot-user-voi-PushManager"><a href="#Dang-ky-mot-user-voi-PushManager" class="headerlink" title="Đăng ký một user với PushManager"></a>Đăng ký một user với PushManager</h1><p>Khi Service Worker đã được đăng ký và chúng ta được user cấp quyền, ta có thể subscribe 1 user bằng cách gọi registration.pushManager.subscribe() khi đăng ký Service Worker của bạn.</p><p>Toàn bộ đoạn code như sau (bao gồm cả phần đăng ký Service Worker):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribeUserToPush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> navigator.serviceWorker.register(<span class="string">'service-worker.js'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> subscribeOptions = &#123;</span><br><span class="line">      userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">      applicationServerKey: btoa(</span><br><span class="line">        <span class="string">'BEl62iUYgUivxIkv69yViEuiBIa-Ib9-SkvMeAtA3LFgDzkrxZJjSgSnfckjBJuBkr3qBUYIHBQFLXYp5Nksh8U'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> registration.pushManager.subscribe(subscribeOptions);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">pushSubscription</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'PushSubscription: '</span>, <span class="built_in">JSON</span>.stringify(pushSubscription));</span><br><span class="line">    <span class="keyword">return</span> pushSubscription;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registration.pushManager.subscribe(options) nhận một object options gồm 1 param bắt buộc và 1 param tùy chọn:</p><ul><li><strong>userVisibleOnly</strong>: một boolean chỉ định push subscription trả về sẽ chỉ được dùng cho message mà hiệu ứng của message đó user có thể nhìn thấy được. Nó phải được gán bằng true nếu không thì sẽ lỗi (Có cả 1 quá khứ lịch sử về nó).</li><li><strong>applicationServerKey</strong>: một DOMString hoặc ArrayBufffer chứa public key được mã hóa thành Base64 mà server push sẽ dùng để xác thực server của app.</li></ul><p>Server của bạn cần sinh ra một cặp server key cho app, chúng còn được biết đến là key VAPID duy nhất cho server. Đây là 1 cặp public-private key. Private key thì được giữ một cách bí mật ở phía bạn trong khi public key được trao đổi với client. Những key này cho phép push service biết app server nào đã đăng ký user và đảm bảo đó chính là server trigger các push message đến người dùng cụ thể.</p><p>Bạn chỉ cần tạo ra cặp private/public key 1 lần duy nhất cho ứng dụng. Có 1 cách làm nhanh đó là dùng trang này <a href="https://web-push-codelab.glitch.me/" target="_blank" rel="noopener">https://web-push-codelab.glitch.me/</a></p><p>Trình duyệt truyền applicationServerKey (public key) lên một push server khi đăng ký user, nghĩa là push server có thể liên kết public key của app bạn với PushSubscription của user.</p><p>Đây là những gì diễn ra:</p><ul><li>Webapp của bạn được load xong và bạn gọi subscribe(), truyền server key vào.</li><li>Trình duyệt tạo 1 request lên mạng đến một push service để sinh ra một endpoint, sau đó liên kết endpoint này với key và trả về cho trình duyệt.</li><li>Trình duyệt sẽ thêm endpoint này vào trong object PushSubscription, chính là object được trả về từ subscribe() promise.</li></ul><p>Về sau, cứ mỗi khi bạn muốn gửi 1 push message, bạn chỉ cần tạo một <strong>Authorization header</strong> có chưa thông tin đã ký (signed) với private key từ server ứng dụng của bạn. Khi push service nhận request để gửi một push message, nó sẽ xác minh header bằng cách tìm public key đã liên kết với endpoint cụ thể đó (ở bước thứ 2)</p><h1 id="Object-PushSubscription"><a href="#Object-PushSubscription" class="headerlink" title="Object PushSubscription"></a>Object PushSubscription</h1><p>Một PushSubscription chứa những thông tin cần thiết để gửi push message đến thiết bị của user:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"endpoint"</span>: <span class="string">"https://domain.pushservice.com/some-id"</span>,</span><br><span class="line">  <span class="string">"keys"</span>: &#123;</span><br><span class="line">    <span class="string">"p256dh"</span>:</span><br><span class="line"><span class="string">"BIPUL12DLfytvTajnryr3PJdAgXS3HGMlLqndGcJGabyhHheJYlNGCeXl1dn18gSJ1WArAPIxr4gK0_dQds4yiI="</span>,</span><br><span class="line">    <span class="string">"auth"</span>:<span class="string">"FPssMOQPmLmXWmdSTdbKVw=="</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>endpoint ở đây là URL của push service. Để trigger một push mesage ta cần tạo request POST đến URL này.<br>Object keys chứa giá trị dùng để mã hóa dữ liệu thông tin được gửi đi với push message.<br>Một khi user đã được đăng ký và bạn có PushSubscription thì bạn cần gửi nó về cho server. Tại đây (trên server) bạn sẽ lưu thông tin tham gia của user vào database và kể từ bây giờ sẽ dùng nó để gửi push message về cho user đó.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*hTMGxzZrOmxxIfaQU7nKig.png" alt=""></p><h1 id="Gui-push-message"><a href="#Gui-push-message" class="headerlink" title="Gửi push message"></a>Gửi push message</h1><p>Khi bạn cần gửi một push message cho nhiều user, điều đầu tiên bạn cần là push service. Bạn đang chỉ bảo cho push service (thông qua API) dữ liệu để gửi, gửi đến ai và các tình huống về việc làm thế nào để gửi message. Thông thường, lời gọi API này sẽ được thực hiện trên server.</p><h1 id="Push-Services"><a href="#Push-Services" class="headerlink" title="Push Services"></a>Push Services</h1><p>Push service là thứ dùng để nhận các request, xác nhận chúng và chuyển giao push message cho trình duyệt phù hợp.</p><p>Lưu ý rằng bạn không quản lý push service, nó là 1 dịch vụ của bên thứ 3. Server của bạn giao tiếp với push service thông qua API. Một ví dụ về push service chính là <a href="https://firebase.google.com/docs/cloud-messaging/" target="_blank" rel="noopener">Google’s FCM</a></p><p>Push service xử lý tất cả những việc nặng nhọc. Ví dụ: Nếu như trình duyệt đang offline, push service sẽ xếp message vào hàng đợi và chờ cho đến khi trình duyệt online lại trước khi gửi message đi 1 cách tuần tự.</p><p>Mỗi tình duyệt có thể dùng bất kỳ push service nào và điều này vượt ngoài khả năng kiểm soát của developer.</p><p>Tuy nhiên tất cả các push service có chung API nên việc này không làm cho quá trình triển khai trở nên khó khăn.</p><p>Để lấy được URL xử lý các request cho push message, bạn cần phải kiểm tra giá trị của endpoint trong object PushSubscription.</p><h1 id="Push-Service-API"><a href="#Push-Service-API" class="headerlink" title="Push Service API"></a>Push Service API</h1><p>Push Service API cung cấp 1 cách để gửi message đến cho user. API là 1 <a href="https://tools.ietf.org/html/draft-ietf-webpush-protocol-12" target="_blank" rel="noopener">Web Push Protocol</a> theo tiêu chuẩn IETF định nghĩa cách ta gọi API đến một push service</p><p>Dữ liệu bạn gửi với push message phải được mã hóa. Bằng cách này, bạn ngăn chặn push service đọc dữ liệu gửi đi. Điều này rất quan trọng vì trình duyệt chính là người quyết định nên dùng push service nào (có thể đó là push service không đáng tin cậy và bảo mật kém)</p><p>Với mỗi push message, bạn có thể đưa ra hướng dẫn như sau:</p><ul><li><strong>TTL</strong>: định nghĩa một message nên chờ bao lâu trong hàng đợi trước khi nó bị gỡ ra và không được chuyển đi.</li><li><strong>Mức độ ưu tiên (priority)</strong>: định nghĩa mức độ ưu tiên của mỗi message, cách này giúp cho push service chỉ gửi những thông tin có mức độ ưu tiên cao, ví dụ trong trường hợp pin thiết bị của người dùng sắp cạn.</li><li><strong>Chủ đề (topic)</strong>: cung cấp cho push message một tên chủ đề sẽ thay thế message đang chờ xử lý (pending) có cùng chủ đề để khi thiết bị đang hoạt động, user sẽ không nhận thông tin cũ, lỗi thời.</li></ul><p><img src="https://cdn-images-1.medium.com/max/1000/1*PgclyCPqxWc1rENfAOesag.png" alt=""></p><h1 id="Su-kien-Push-tren-trinh-duyet"><a href="#Su-kien-Push-tren-trinh-duyet" class="headerlink" title="Sự kiện Push trên trình duyệt"></a>Sự kiện Push trên trình duyệt</h1><p>Một khi bạn gửi message đến push service như giải thích ở trên, message sẽ chuyển sang trạng thái chờ (pending) cho đến khi 1 trong số những điều sau đây xảy ra:</p><ul><li>Thiết bị online</li><li>Message hết hạn trên hàng đợi do TTL.</li></ul><p>Khi push service truyền một message, trình duyệt sẽ nhận nó, giải mã và điều phối một sự kiện push trong Service Worker của bạn.</p><p>Điều tuyệt vời là trình duyệt thực thi code Service Worker của bạn thậm chí cả khi web page chưa mở lên:</p><ul><li>Push message được gửi tới trình duyệt và được giải mã.</li><li>Trình duyệt đánh thức Service Worker</li><li>Một sự kiện push được phân phối đến Service Worker</li></ul><p>Code để cài đặt một listener cho push even cũng khá tương đồng với các loại event listener khác trong Javascript:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.data) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'This push event has data: '</span>, event.data.text());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'This push event has no data.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Một điều cần phải hiểu về Service Worker là bạn có ít quyền kiểm soát về thời gian chạy của code Service Worker. Trình duyệt quyết định khi nào thì đánh thức nó dậy và khi nào thì hủy nó.</p><p>Trong Service Worker, event.waitUntil(promise) cho trình duyệt biết công việc vẫn đang thực hiện cho tới khi promise được giải quyết xong và trình duyệt sẽ không hủy service worker nếu nó cần quá trình đó hoàn thành.</p><p>Dưới đây là 1 ví dụ về xử lý sự kiện push:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = self.registration.showNotification(<span class="string">'Push notification!'</span>);</span><br><span class="line"></span><br><span class="line">  event.waitUntil(promise);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Gọi self.registration.showNotification() hiển thị một thông báo đến user và nó trả về promise, promise này được resolve khi thông báo đã được hiển thị lên.</p><p>Phương thức showNotification(title, options) có thể được chỉnh sửa để phù hợp với nhu cầu. Param title là 1 string, còn options là object như dưới đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"//"</span>: <span class="string">"Visual Options"</span>,</span><br><span class="line">  <span class="string">"body"</span>: <span class="string">"&lt;String&gt;"</span>,</span><br><span class="line">  <span class="string">"icon"</span>: <span class="string">"&lt;URL String&gt;"</span>,</span><br><span class="line">  <span class="string">"image"</span>: <span class="string">"&lt;URL String&gt;"</span>,</span><br><span class="line">  <span class="string">"badge"</span>: <span class="string">"&lt;URL String&gt;"</span>,</span><br><span class="line">  <span class="string">"vibrate"</span>: <span class="string">"&lt;Array of Integers&gt;"</span>,</span><br><span class="line">  <span class="string">"sound"</span>: <span class="string">"&lt;URL String&gt;"</span>,</span><br><span class="line">  <span class="string">"dir"</span>: <span class="string">"&lt;String of 'auto' | 'ltr' | 'rtl'&gt;"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">"//"</span>: <span class="string">"Behavioural Options"</span>,</span><br><span class="line">  <span class="string">"tag"</span>: <span class="string">"&lt;String&gt;"</span>,</span><br><span class="line">  <span class="string">"data"</span>: <span class="string">"&lt;Anything&gt;"</span>,</span><br><span class="line">  <span class="string">"requireInteraction"</span>: <span class="string">"&lt;boolean&gt;"</span>,</span><br><span class="line">  <span class="string">"renotify"</span>: <span class="string">"&lt;Boolean&gt;"</span>,</span><br><span class="line">  <span class="string">"silent"</span>: <span class="string">"&lt;Boolean&gt;"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">"//"</span>: <span class="string">"Both Visual &amp; Behavioural Options"</span>,</span><br><span class="line">  <span class="string">"actions"</span>: <span class="string">"&lt;Array of Strings&gt;"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">"//"</span>: <span class="string">"Information Option. No visual affect."</span>,</span><br><span class="line">  <span class="string">"timestamp"</span>: <span class="string">"&lt;Long&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bạn có thể tìm hiểu chi tiết về mỗi options ở đây: <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification</a></p><p>Push Notification là một cách tuyệt vời để thu thập sự chú ý của user những khi có thông tin gấp, quan trọng hoặc cần thời điểm nhạy cảm mà bạn muốn chia sẻ với họ.</p><p>Team SessionStack thực hiện push notifications để báo cho user biết khi có crash, vấn đề hoặc điều gì đó bất thường trong sản phẩm của họ. Việc này giúp cho user biết ngay lập tức nếu có gì không đúng đang xảy ra. Sau đó họ có thể replay lại issue đó dưới dạng video và xem mọi thứ diễn ra với người dùng cuối của họ bằng cách tận dụng dữ liệu được thu thập với thư viện của SessionStack, chẳng hạn như thay đổi trên DOM, tương tác người dùng, request mạng, biệt lệ không được xử lý và các thông báo lỗi.</p><p>Tính năng này không chỉ sẽ giúp user sử dụng SessionStack hiểu và tái hiện lại bất kỳ vấn đề nào mà nó còn cho phép họ nhận được thông báo ngay khi nó xuất hiện.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 9 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Hôm nay chúng ta sẽ chuyển hướng sự chú ý qua &lt;strong&gt;web push notifications&lt;/strong&gt; (tạm dịch: thông báo đẩy trên trang web): chúng ta sẽ tìm hiểu về thành phần của nó, khám phá các quy trình gửi/nhận thông báo phía sau và cuối bài sẽ cùng tìm hiểu làm sao SessionStack sử dụng chúng để xây dựng chức năng của sản phẩm.&lt;/p&gt;
&lt;p&gt;Push Notifications rất phổ biến trong thế giới của điện thoại. Vì lý do này hay lý do khác, chúng bước chân vào thế giới web lại khá muộn mặc dù nó là tính năng rất được các developer ưa chuộng và đề xuất.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P8: Service Workers, vòng đời và các trường hợp sử dụng</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P8-Service-Workers-vong-doi-va-cac-truong-hop-su-dung.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P8-Service-Workers-vong-doi-va-cac-truong-hop-su-dung.html</id>
    <published>2018-11-24T15:04:00.000Z</published>
    <updated>2018-11-24T15:16:23.564Z</updated>
    
    <content type="html"><![CDATA[<p>Bạn có lẽ đã biết rằng <a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener">Progressive Web Apps</a> chỉ có thể phổ biến hơn khi chúng hướng tới trải nghiệm người dùng (UX) mượt mà hơn, giống như là tạo 1 native app hơn là một trải nghiệm mang phong cách trình duyệt.</p><p>Một trong số những yêu cầu khi xây dựng PWA là làm nó cực kỳ đáng tin cậy ở khoản loading: nó có thể chạy kể cả trong tình trạng internet không ổn định hoặc rớt mạng.</p><p>Trong bài này, chúng ta sẽ đào sâu vào Service Workers: cách chúng hoạt động và chúng ta nên quan tâm đến đâu. Cuối bài, team tác giả có một số lợi ích độc đáo của Service Workers mà chúng ta nên dùng đồng thời chia sẻ kinh nghiệm của họ tại <a href="https://www.sessionstack.com/" target="_blank" rel="noopener">SessionStack</a>.<br><a id="more"></a></p><h1 id="Khai-quat"><a href="#Khai-quat" class="headerlink" title="Khái quát"></a>Khái quát</h1><p>Nếu bạn muốn hiểu rõ mọi thứ về Service Workers, bạn cần phải bắt đầu với bài viết trước về <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-7---Thanh-phan-cua-WebWorker---5-truong-hop-su-dung" target="_blank" rel="noopener">Web Workers</a>.</p><p>Về cơ bản, Service Worker chỉ là 1 loại của Web Worker và cụ thể hơn là nó giống như 1 <a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" target="_blank" rel="noopener">Shared Worker</a>:</p><ul><li>Service Worker chạy trong global context của chính nó</li><li>Nó không thể gắn kết với 1 trang cụ thể</li><li>Không thể truy cập vào DOM</li></ul><p>Một trong những lý do tại sao Service Worker API rất tuyệt vời là chúng cho phép webapp hỗ trợ trải nghiệm khi offline, cho phép developer hoàn toàn điều khiển luồng sử dụng.</p><h1 id="Vong-doi-cua-Service-Worker"><a href="#Vong-doi-cua-Service-Worker" class="headerlink" title="Vòng đời của Service Worker"></a>Vòng đời của Service Worker</h1><p>Vòng đời của một service worker là hoàn toàn tách biệt với web page. Nó bao gồm các giai đoạn sau:</p><ul><li>Tải về (Download)</li><li>Cài đặt (Installation)</li><li>Kích hoạt (Activation)</li></ul><h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p>Đây là khi trình duyệt tải file .js chứa Service Worker</p><h2 id="Cai-dat"><a href="#Cai-dat" class="headerlink" title="Cài đặt"></a>Cài đặt</h2><p>Để cài đặt một Service Worker cho webapp của bạn thì bạn cần phải đăng ký nó trước trong code Javascript. Khi Service Worker đã đăng ký xong, nó sẽ nhắc nhở tình duyệt khởi động một bước cài đặt chạy nền Service Worker.</p><p>Bằng cách đăng ký Service Worker, bạn đã thông báo cho trình duyệt file Javascript của worker nằm ở đâu. Cùng xem ví dụ bên dưới:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/sw.js'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Đăng ký thành công</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration successful'</span>);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Đăng ký thất bại</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration failed: '</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Code sẽ kiểm tra nếu môi trường hiện tại có support Service Worker hay không. Nếu như có thì file /sw.js sẽ được đăng ký.</p><p>Bạn có thể gọi phương thức register() mỗi khi một trang load lên mà không phải lo lắng gì, trình duyệt sẽ sẽ tự kiểm tra nếu service worker đã được đăng ký hay chưa và tự xử lý một cách phù hợp.</p><p>Một điểm quan trọng ở phương thức register() là vị trí của file service worker. Trong trường hợp này bạn có thể thấy rằng file service worker đang ở root của domain. Nghĩa là phạm vi (scope) của service worker sẽ bao hàm toàn bộ origin. Nói cách khác, service worker này sẽ nhận các sự kiện fetch (mà chúng ta sẽ thảo luận sau) cho mọi thứ trên domain này. Nếu ta đăng ký file service worker ở /example/sw.js thì service worker chỉ có thể thấy các sự kiện fetch cho trang có URL bắt đầu với /example/ (ví dụ: /example/page/1, /example/page/2)</p><p>Trong giai đoạn cài đặt, tốt nhất ta nên load và cache những tài nguyên dạng tĩnh (static asset). Một khi các tài nguyên đã được cache thành công thì quá trình cài đặt Service Worker cũng hoàn thành. Nếu không (load fail), Service Worker sẽ thử lại (retry). Một khi đã thành công, bạn sẽ biết các static asset đang nằm trong cache.</p><p>Bạn sẽ tự hỏi nếu như quá tình đăng ký diễn ra sau sự kiện load thì được không. Điều này không bắt buộc, nhưng đó là cách tốt nhất và được đề nghị làm theo.</p><p>Tại sao? Giả sử một user lần đầu tiên ghé thăm webapp của bạn. Không có service worker nào cả và trình duyệt không có cách nào để biết trước có hay không một service worker cần được cài đặt. Nếu như Service Worker đã được cài đặt, trình duyệt sẽ dành ra 1 lượng CPU và bộ nhớ cho tiến trình đó, ngược lại thì trình duyệt sẽ dành toàn bộ cho quá trình render web page.</p><p>Điểm mấu chốt là nếu bạn chỉ cài đặt Service Worker trên trang của bạn thì bạn đang mạo hiểm về độ delay của quá trình loading &amp; render chứ không phải đang làm cho trang có thể sẵn sàng cho người dùng một cách nhanh nhất có thể.</p><p>Lưu ý rằng điều này chỉ quan trọng cho lần đầu tiên ghé thăm trang. Những lần ghé thăm sau thì không bị ảnh hưởng với quá trình cài đặt Service Worker. Một khi Service Worker đã được kích hoạt trong lần đầu ghé thăm trang, nó có thể xử lý các sự kiện loading/caching cho những lần ghé thăm kế tiếp. Điều này rất có ý nghĩa bởi vì nó cần phải sẵn sàng để xử lý trường hợp kết nối mạng bị hạn chế.</p><h2 id="Kich-hoat"><a href="#Kich-hoat" class="headerlink" title="Kích hoạt"></a>Kích hoạt</h2><p>Sau khi Service Worker cài đặt, bước tiếp theo là kích hoạt nó. Bước này là cơ hội tuyệt vời để quản lý cache trước đó.</p><p>Một khi đã kích hoạt, Service Worker sẽ bắt đầu kiểm soát toàn trang nằm trong phạm vi của nó. Một sự thật rất thú vị: page nào đăng ký Service Worker lần đầu tiên sẽ không bị điều khiển cho đến khi nó load lại. Một khi Service Worker kiểm soát, nó sẽ có những trạng thái sau:</p><ul><li>Nó sẽ xử lý các sự kiện fetch &amp; message diễn ra khi một request mạng hoặc message được tạo ra từ page.</li><li>Nó sẽ bị hủy bỏ để giải phóng bộ nhớ.</li></ul><p>Dưới đây là vòng đời của nó:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*mVOrpKC9pFTMg4EXPozoog.png" alt=""></p><h1 id="Xu-ly-qua-trinh-cai-dat-ben-trong-Service-Worker"><a href="#Xu-ly-qua-trinh-cai-dat-ben-trong-Service-Worker" class="headerlink" title="Xử lý quá trình cài đặt bên trong Service Worker"></a>Xử lý quá trình cài đặt bên trong Service Worker</h1><p>Sau khi page xoay vòng quá trình đăng ký, ta cùng tìm hiểu điều gì diễn ra bên trong script của Service Worker, code này xử lý sự kiện cài đặt bằng cách thêm một event listener vào instance của Service Worker.</p><p>Đây là những bước cần thiết khi xử lý sự kiện cài đặt</p><ul><li>Mở cache</li><li>Cache các file</li><li>Xác nhận tất cả các asset cần thiết đều đã được cache.</li></ul><p>Dưới đây là quá trình cài đặt đơn giản bên trong Service Worker:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CACHE_NAME = <span class="string">'my-web-app-cache'</span>;</span><br><span class="line"><span class="keyword">var</span> urlsToCache = [</span><br><span class="line">  <span class="string">'/'</span>,</span><br><span class="line">  <span class="string">'/styles/main.css'</span>,</span><br><span class="line">  <span class="string">'/scripts/app.js'</span>,</span><br><span class="line">  <span class="string">'/scripts/lib.js'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// event.waitUntil nhận một promise để biết quá trình</span></span><br><span class="line">  <span class="comment">// cài đặt mất bao lâu và có thành công hay không.</span></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(CACHE_NAME)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Opened cache'</span>);</span><br><span class="line">        <span class="keyword">return</span> cache.addAll(urlsToCache);</span><br><span class="line">      &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Nếu tất cả các file đều đã được lưu cache thành công thì service worker sẽ được cài đặt. Nếu một file nào đó không download được thì bước cài đặt sẽ bị fail. Vì thế hãy cẩn thận với những file bạn truyền vào.</p><p>Xử lý sự kiện cài đặt hoàn toàn không bắt buộc và bạn có thể bỏ qua, trong trường hợp đó bạn không cần phải thực hiện thêm bước nào nữa.</p><h1 id="Cache-request-trong-qua-trinh-thuc-thi-runtime"><a href="#Cache-request-trong-qua-trinh-thuc-thi-runtime" class="headerlink" title="Cache request trong quá trình thực thi (runtime)"></a>Cache request trong quá trình thực thi (runtime)</h1><p>Phần này thực sự thú vị một cách xuất sắc. Đây là nơi bạn sẽ biết làm thế nào để can thiệp request và trả về cache đã được tạo (và tạo mới).</p><p>Sau khi Service Worker cài đặt xong và user điều hướng đến page khác hoặc refresh lại page hiện tại, Service Worker sẽ nhận được sự kiện fetch. Đây là một ví dụ thể hiện làm thế nào để trả về những asset đã cache hoặc thực hiện một request mới và cache kết quả:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    <span class="comment">// Phương thức này xem xét request và tìm xem có</span></span><br><span class="line">    <span class="comment">// kết quả nào đã được cache từ tất cả các cache</span></span><br><span class="line">    <span class="comment">// mà Service Worker đã tạo.</span></span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Nếu tìm thấy cache thì trả về response.</span></span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Nhân bản request. Một request là 1 stream và chỉ có thể sử dụng 1 lần. </span></span><br><span class="line">        <span class="comment">// Bởi vì chúng ta đang xài 1 cái cho cache và 1 cái cho trình duyệt để fetch,</span></span><br><span class="line">        <span class="comment">// nến ta cần phải nhân bản request.</span></span><br><span class="line">        <span class="keyword">var</span> fetchRequest = event.request.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache không tìm thấy nên ta cần thực hiện fetch</span></span><br><span class="line">        <span class="comment">// để tạo request tới mạng và trả về dữ liệu nếu tìm thấy</span></span><br><span class="line">        <span class="comment">// thứ gì đó.</span></span><br><span class="line">        <span class="keyword">return</span> fetch(fetchRequest).then(</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// Kiểm tra nếu ta nhận được response hợp lệ.</span></span><br><span class="line">            <span class="keyword">if</span>(!response || response.status !== <span class="number">200</span> || response.type !== <span class="string">'basic'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Nhân bản response bởi vì nó cũng không phải là 1 stream.</span></span><br><span class="line">            <span class="comment">// Bởi vì chúng ta muốn trình duyệt sử dụng response cũng như</span></span><br><span class="line">            <span class="comment">// cache sử dụng response, ta cần nhân bản nó thành 2 stream.</span></span><br><span class="line">            <span class="keyword">var</span> responseToCache = response.clone();</span><br><span class="line"></span><br><span class="line">            caches.open(CACHE_NAME)</span><br><span class="line">              .then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// Thêm request vào cache phục vụ sau này</span></span><br><span class="line">                cache.put(event.request, responseToCache);</span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Tóm gọn lại thì đây là những điều đã diễn ra:</p><ul><li>event.respondWith() sẽ xác định làm thế nào chúng ta phản hồi với sự kiện fetch. Ta truyền một promise từ caches.match(), hàm đang kiểm tra request và tìm kiếm nếu có bất kỳ kết quả đã được cache sẵn nào từ những cache đã được tạo trước đó.</li><li>Nếu có cache, response được lấy ra.</li><li>Ngược lại, fetch được thực thi.</li><li>Kiểm tra nếu trạng thái là 200. Chúng ta sẽ kiểm tra kiểu response là cơ bản, nghĩa là nó sẽ chỉ ra request từ origin của chúng ta. Request đến các asset của bên thứ 3 không thể cache được trong trường hợp này.</li><li>Response được thêm vào cache.</li></ul><p>Request và response phải được nhân bản (clone) vì chúng là <a href="https://streams.spec.whatwg.org/" target="_blank" rel="noopener">stream</a>. Thân (body) của một stream chỉ có thể sử dụng 1 lần. Và khi ta cần dùng nó, ta phải nhân bản nó bởi vì trình duyệt cũng cần sử dụng nó nữa.</p><h1 id="Cap-nhat-Service-Worker"><a href="#Cap-nhat-Service-Worker" class="headerlink" title="Cập nhật Service Worker"></a>Cập nhật Service Worker</h1><p>Khi một user ghé thăm webapp của bạn, trình duyệt sẽ thử download lại file .js chứa code Service Worker. Tác vụ này sẽ được chạy nền.</p><p>Nếu có một chút khác biệt dù chỉ một byte giữa file Service Worker mới download về và file cũ thì trình duyệt cũng sẽ giả định rằng có sự thay đổi và Service Worker mới phải khởi tạo lại.</p><p>Service Worker mới sẽ bắt đầu khởi tạo và cài đặt. Tuy nhiên vào thời điểm này, Service Worker cũ vẫn đang kiểm soát page trên webapp của bạn, nghĩa là Service Worker mới sẽ nằm trong trạng thái chờ đợi.</p><p>Một khi trang đang mở được đóng lại, Service Worker cũ sẽ bị hủy bởi trình duyệt và Service Worker mới cài đặt sẽ chiếm quyền kiểm soát toàn bộ. Đây là khi sự kiện kích hoạt của nó được kích hoạt.</p><p>Tại sao lại cần phải làm tất cả điều này? Là để tránh vấn đề khi có 2 phiên bản webapp chạy đồng thời trong các tab khác nhau. Việc này diễn ra một cách rất phổ biến và có thể tạo ra những lỗi tồi tệ (ví dụ: bạn có schema khác nhau trong khi lưu trữ dữ liệu local trên trình duyệt).</p><h1 id="Xoa-du-lieu-trong-cache"><a href="#Xoa-du-lieu-trong-cache" class="headerlink" title="Xóa dữ liệu trong cache"></a>Xóa dữ liệu trong cache</h1><p>Bước phổ biến nhất trong callback kích hoạt là quản lý cache. Bạn sẽ cần phải làm điều này ngay bởi vì nếu bạn dọn dẹp cache cũ trong bước cài đặt, Service Worker cũ sẽ dừng lại một cách đột ngột và không thể phân phối các file từ cache đó nữa.</p><p>Dưới đây là ví dụ cách bạn có thể xóa vài file không nằm trong danh sách an toàn trong cache (trong trương hợp này là có chữ page-1 và page-2 trong tên của nó)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">'page-1'</span>, <span class="string">'page-2'</span>];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="comment">// Lấy tất cả key từ cache.</span></span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">cacheNames</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">        <span class="comment">// Lặp qua mảng các file.</span></span><br><span class="line">        cacheNames.map(<span class="function"><span class="keyword">function</span>(<span class="params">cacheName</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// Nếu file trong cache không nằm trong danh sách an toàn</span></span><br><span class="line">          <span class="comment">// thì nó sẽ bị xóa.</span></span><br><span class="line">          <span class="keyword">if</span> (cacheWhitelist.indexOf(cacheName) === <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Yeu-cau-HTTPS"><a href="#Yeu-cau-HTTPS" class="headerlink" title="Yêu cầu HTTPS"></a>Yêu cầu HTTPS</h1><p>Khi xây dựng webapp, bạn có thể sử dụng Service Worker qua localhost nhưng một khi đã deploy nó lên production, bạn cần chuẩn bị HTTPS (và đó cũng là lý do cuối cùng bạn cần đến HTTPS).</p><p>Sử dụng Service Worker, bạn có thể chiếm quyền kết nối và ngụy tạo response. Nếu không dùng HTTPS, webapp của bạn trở thành đối tượng của cách tấn công <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener">kẻ-trung-gian</a> (man-in-the-middle).</p><p>Để an toàn hơn, bạn cần phải đăng ký Service Worker với page được phân phối qua HTTPS để bạn biết được Service Worker nào trình duyệt nhận về mà không bị thay đổi khi lưu thông qua mạng.</p><h1 id="Cac-trinh-duyet-ho-tro"><a href="#Cac-trinh-duyet-ho-tro" class="headerlink" title="Các trình duyệt hỗ trợ"></a>Các trình duyệt hỗ trợ</h1><p>Sự hỗ trợ cho Service Worker ngày càng được cải thiện:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*6o2TRDmrJlS97vh1wEjLYw.png" alt=""></p><p>Bạn có thể theo dõi tiến độ cho tất cả các trình duyệt tại đây: <a href="https://jakearchibald.github.io/isserviceworkerready/" target="_blank" rel="noopener">https://jakearchibald.github.io/isserviceworkerready/</a></p><h1 id="Service-Workers-mo-ra-chan-troi-moi"><a href="#Service-Workers-mo-ra-chan-troi-moi" class="headerlink" title="Service Workers mở ra chân trời mới"></a>Service Workers mở ra chân trời mới</h1><p>Một số tính năng độc đáo mà Service Worker cung cấp:</p><ul><li><strong>Push notifications </strong>: cho phép user tham gia vào lắng nghe cập nhật theo thời gian</li><li><strong>Đồng bộ dưới nền (background sync)</strong>: cho phép bạn tạm hoãn các hành động cho tới khi user có kết nối ổn định. Bằng cách này bạn có thể đảm bảo rằng bất kỳ thứ gì mà user cần gửi thì chắc chắn nó sẽ được gửi đi.</li><li><strong>Đồng bộ định kỳ (periodic sync - tương lai)</strong>: API cung cấp khả năng quản lý đồng bộ dưới nền theo chu kỳ.</li><li><strong>Ranh giới ảo (Geofencing - tương lai)</strong>: bạn có thể định nghĩa params, còn gọi là những geofence bao quanh một khu vực. Webapp sẽ nhận thông báo khi có một thiết bị vượt qua geofence, điều này cho phép bạn cung cấp trả nghiệm có ích dựa trên vị trí địa lý của user.</li></ul><p>Mỗi mục này sẽ được thảo luận chi tiết hơn trong các bài viết khác.</p><p>Team tác giả đang nỗ lực không ngừng để mang lại trải nghiệm UX mượt mà nhất có thể cho SessionStack, tối ưu hóa thời gian tải trang và thời gian phản hồi.</p><p>Khi bạn replay lại 1 session của user trên <a href="https://www.sessionstack.com/" target="_blank" rel="noopener">SessionStack</a> (hoặc xem nó trong thời gian thực), phần SessionStack front-end sẽ không ngừng lấy dữ liệu từ server về để tạo ra một trải nghiệm liền mạch như lưu trong buffer. Một khi bạn đã tích hợp thư viện của SessionStack vào trong webapp, nó sẽ bắt đầu thu thập dữ liệu liên tục về thay đổi trên DOM, tương tác người dùng, request mạng, biệt lệ không được xử lý và thông báo lỗi.</p><p>Khi một phiên làm việc được replay hoặc stream theo thời gian thực thì SessionStack phục vụ tất cả dữ liệu cho phép bạn thấy mọi thứ về trải nghiệm người dùng ở góc độ trình duyệt của user (cả về mặt kỹ thuật lẫn hình ảnh). Những công việc này cần phải được thực hiện cực nhanh để không làm cho user phải chờ đợi.</p><p>Bởi vì dữ liệu được front-end kéo về nên đây là một sàn diễn tuyệt vời cho Service Worker có thể “tỏa sáng” mà xử lý những trường hợp như reload player và stream mọi thứ thêm vài lần nữa. Xử lý kết nối mạng bị chậm cũng cực kỳ quan trọng.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Bạn có lẽ đã biết rằng &lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Progressive Web Apps&lt;/a&gt; chỉ có thể phổ biến hơn khi chúng hướng tới trải nghiệm người dùng (UX) mượt mà hơn, giống như là tạo 1 native app hơn là một trải nghiệm mang phong cách trình duyệt.&lt;/p&gt;
&lt;p&gt;Một trong số những yêu cầu khi xây dựng PWA là làm nó cực kỳ đáng tin cậy ở khoản loading: nó có thể chạy kể cả trong tình trạng internet không ổn định hoặc rớt mạng.&lt;/p&gt;
&lt;p&gt;Trong bài này, chúng ta sẽ đào sâu vào Service Workers: cách chúng hoạt động và chúng ta nên quan tâm đến đâu. Cuối bài, team tác giả có một số lợi ích độc đáo của Service Workers mà chúng ta nên dùng đồng thời chia sẻ kinh nghiệm của họ tại &lt;a href=&quot;https://www.sessionstack.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SessionStack&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P7: Thành phần của WebWorker + 5 trường hợp sử dụng</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P7-Thanh-phan-cua-WebWorker-5-truong-hop-su-dung.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P7-Thanh-phan-cua-WebWorker-5-truong-hop-su-dung.html</id>
    <published>2018-11-16T00:27:00.000Z</published>
    <updated>2018-11-16T00:30:02.825Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 7 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Trong bài này chúng ta sẽ tìm hiểu về Web Workers: một cái nhìn tổng quan, thảo luận về các loại worker khách nhau, các thành phần của nó hoạt động với nhau như thế nào và những điểm mạnh cũng như điểm yếu của nó trong các ngữ cảnh khác nhau. Cuối cùng, team tác giả sẽ cung cấp 5 trường hợp mà trong đó Web Worker là sự lựa chọn đúng đắn.</p><p>Bạn đã quen với sự thật rằng Javascript chạy đơn luồng như chúng ta đã <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-1---Khai-quat-ve-engine--runtime-va-callstack" target="_blank" rel="noopener">thảo luận chi tiết ở bài trước</a>. JS cũng giúp các developer viết code bất đồng bộ.<br><a id="more"></a></p><h1 id="Nhung-han-che-cua-lap-trinh-bat-dong-bo"><a href="#Nhung-han-che-cua-lap-trinh-bat-dong-bo" class="headerlink" title="Những hạn chế của lập trình bất đồng bộ"></a>Những hạn chế của lập trình bất đồng bộ</h1><p>Chúng ta đã thảo luận ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-4---Event-loop--lap-trinh-bat-dong-bo---5-meo-cai-thien-Async-Await" target="_blank" rel="noopener">bài trước</a> về lập trình bất đồng bộ và khi nào thì nên dùng.</p><p>Lập trình bất đồng bộ cho phép UI của app trở nên mượt mà, bằng cách “lên lịch” cho từng phần của code được thực thi ở thời gian phù hợp trong event loop, do đó nó cho phép render UI được thực hiện trước.</p><p>Một trường hợp tốt để dùng lập trình bất đồng bộ là khi ta gọi Ajax request. Bởi vì request có thể tốn nhiều thời gian nên có thể để cho nó chạy bất đồng bộ và trong khi client chờ kết quả trả về, những code khác vẫn được thực thi.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Giả sử bạn dùng jQuery</span></span><br><span class="line">jQuery.ajax(&#123;</span><br><span class="line">    url: <span class="string">'https://api.example.com/endpoint'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// code được thực thi khi response trả về</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Nhưng điều này lại gây ra vấn đề khác: request được xử lý bởi Web API của trình duyệt, nhưng làm thế nào mà code khác có thể chạy bất đồng bộ? Ví dụ nếu như code bên trong một success callback lại chạy ngốn rất nhiều CPU:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = performCPUIntensiveCalculation();</span><br></pre></td></tr></table></figure><p>Nếu như performCPUIntensiveCalculation không phải là một request HTTP nhưng lại block code xử lý (ví dụ: 1 vòng lặp rất lớn), không có cách nào để giải phóng event loop và unblock cho UI trình duyệt, nó sẽ đóng băng và không phản hồi lại với user.</p><p>Nghĩa là trong Javascript, những hàm bất đồng bộ chỉ giải quyết vấn đề nhỏ của hạn chế ở đơn luồng.</p><p>Trong những trường hợp đó, bạn có thể làm cho unblock UI khỏi quá trình tính toán quá lâu bằng cách sử dụng setTimeout. Ví dụ, tách một chuỗi xử lý tính toán phức tạp vào trong nhiều lời gọi setTimeout, bằng cách đó bạn có thể đặt chúng vào những “vị trí” khác nhau trong event loop và cách này có thể giúp cho render UI được tốt hơn.</p><p>Cùng xem một ví dụ đơn giản về tính toán số trung bình của 1 mảng số nguyên:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = numbers.length,</span><br><span class="line">        sum = <span class="number">0</span>,</span><br><span class="line">        i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        sum += numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum / len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dưới đây là cách ta viết lại code trên và “giả lập” trường hợp bất đồng bộ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">averageAsync</span>(<span class="params">numbers, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = numbers.length,</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calculateSumAsync</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="comment">// Đưa hàm tiếp theo vào event loop</span></span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                sum += numbers[i];</span><br><span class="line">                calculateSumAsync(i + <span class="number">1</span>);</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// hết mảng, gọi callback</span></span><br><span class="line">            callback(sum / len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    calculateSumAsync(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cách này sẽ dùng setTimeout để thêm mỗi bước thực hiện tính toán vào trong event loop. Giữa mỗi lần tính toán sẽ có đủ thời gian cho các tính toán được thêm vào và giải phóng trình duyệt khỏi bị đóng băng.</p><h1 id="Web-Workers-den-giai-cuu"><a href="#Web-Workers-den-giai-cuu" class="headerlink" title="Web Workers đến giải cứu"></a>Web Workers đến giải cứu</h1><p>HTML5 mang đến cho chúng ta rất nhiều thứ tuyệt vời:</p><ul><li>SSE (đã thảo luận và so sánh với WebSocket ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-5---Dao-sau-WebSocket---HTTP-2-voi-SSE---Hay-chon-gia-dung" target="_blank" rel="noopener">bài trước</a>)</li><li>Geolocation</li><li>Application cache</li><li>Local Storage</li><li>Drag and Drop</li><li><strong>Web Workers</strong></li></ul><p>Web Workers là tiến trình trong trình duyệt nhưng có thể được dùng để thực thi Javascript code mà không cản trở event loop</p><p>Điều này thực sự kỳ diệu. Toàn bộ mô hình của Javascript dựa trên ý tưởng về môi trường đơn luồng nhưng giờ đây là có Web Workers và nó gỡ bỏ (1 phần nào) sự hạn chế đó.</p><p>Web Workers cho phép developer đặt những công việc có thời gian chạy dài và những công việc nặng về xử lý tính toán trong background mà không gây trở ngại đến UI, làm app của bạn mượt mà hơn. Ngoài ra, không cần phải xài trick với setTimeout để đánh lừa event loop nữa.</p><p><a href="http://afshinm.github.io/50k/" target="_blank" rel="noopener">Ở đây</a> có một demo mẫu thể hiện sự khác nhau khi thực hiện sắp xếp mảng dùng và không dùng Web Workers.</p><h1 id="Khai-quat-ve-Web-Workers"><a href="#Khai-quat-ve-Web-Workers" class="headerlink" title="Khái quát về Web Workers"></a>Khái quát về Web Workers</h1><p>Web Workers cho phép bạn làm những việc như thực thi các đoạn code xử lý tốn thời gian để tính toán các phép tính hao tổn nheiefu CPU nhưng không làm cản trở UI. Thực ra, nó sẽ chạy song song. Web Workers là đa luồng.</p><p>Bạn sẽ thắc mắc: “Chứ không phải Javascript là ngôn ngữ đơn luồng à?”</p><p>Đây là lúc mà bạn sẽ thốt lên <em>aha</em> ngạc nhiên khi nhận ra Javascript là một ngôn ngữ không định nghĩa mô hình tiến trình. <strong>Web Workers không phải là một phần của Javascript, nó là tính năng của trình duyệt mà có thể truy xuất thông qua Javascript</strong>. Đa số các trình duyệt có lịch sử về đơn tiến trình (giờ thì thay đổi rồi), và đa số các triển khai của Javascript đều diễn ra trên trình duyệt. Web Workers không được triển khai trên Node.js, nó có khái niệm hơi khác một chút về cluster hay child_process.</p><p>Có 3 loại Web Workers được đề cập đến trong <a href="http://www.whatwg.org/specs/web-workers/current-work/" target="_blank" rel="noopener">thông số kỹ thuật</a>:</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">Dedicated Workers</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" target="_blank" rel="noopener">Shared Workers</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker_API" target="_blank" rel="noopener">Service workers</a></li></ul><h1 id="Dedicated-Workers-Worker-chuyen-dung"><a href="#Dedicated-Workers-Worker-chuyen-dung" class="headerlink" title="Dedicated Workers (Worker chuyên dụng)"></a>Dedicated Workers (Worker chuyên dụng)</h1><p>Dedicated Web Workers được khởi tạo bởi tiến trình chính và chỉ có thể giao tiếp với tiến trình đó.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*ya4zMDfbNUflXhzKz9EBIw.png" alt=""></p><h1 id="Shared-Workers-Worker-chia-se"><a href="#Shared-Workers-Worker-chia-se" class="headerlink" title="Shared Workers (Worker chia sẻ)"></a>Shared Workers (Worker chia sẻ)</h1><p>Shared Workers có thể được truy cập bởi tất cả các tiến trình chạy trên cùng origin (khác tab trình duyệt, iframe hoặc là các shared worker khác)</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*lzOIevUBVy5eWyf2kHf--w.png" alt=""></p><p>Nếu bạn muốn dùng thử SessionStack để hiểu và khám phá lại những vấn đề kỹ thuật cũng như UX trên webapp của bạn, team SessionStack đang có bản dùng thử miễn phí, <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=Post-5-websockets-getStarted" target="_blank" rel="noopener">ở đây nhé</a>.</p><h1 id="Service-Workers-Worker-dich-vu"><a href="#Service-Workers-Worker-dich-vu" class="headerlink" title="Service Workers (Worker dịch vụ)"></a>Service Workers (Worker dịch vụ)</h1><p>Một Service Worker là worker hướng sự kiện (event-driven) được đăng ký với origin và path. Nó có thể điều khiển web page/site mà nó liên kết, can thiệp và chỉnh sửa sự điều hướng và các yêu cầu tài nguyên, lưu đệm tài nguyên với phong cách rất chi tiết để cho phép bạn có toàn quyền điều khiển về việc app của bạn xử lý như thế nào trong từng trường hợp cụ thể (ví dụ như khi rớt mạng)</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*6o2TRDmrJlS97vh1wEjLYw.png" alt=""></p><p>Trong bài này chúng ta sẽ tập trung vào <strong>Dedicated Worker</strong> và chỉ gọi nó dưới cái tên <strong>Web Workers</strong> hoặc <strong>Worker</strong></p><h1 id="Web-Workers-hoat-dong-nhu-the-nao"><a href="#Web-Workers-hoat-dong-nhu-the-nao" class="headerlink" title="Web Workers hoạt động như thế nào?"></a>Web Workers hoạt động như thế nào?</h1><p>Web Workers được triển khai dưới dạng đuôi .js và được đính kèm theo request HTTP bất đồng bộ trong web của bạn. Những request này được ẩn hoàn toàn bởi <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener">Web Worker API</a></p><p>Workers sử dụng message kiểu tiến trình để thực hiện quá trình hoạt động song song. Chúng có thể giữ cho UI được cập nhật mới nhất, có thể tương tác và mượt mà với người dùng một cách hoàn hảo.</p><p>Web Workers chạy trong một tiến trình cô lập trong trình duyệt. <strong>Do đó là code chúng thực thi cần phải đặt trong 1 file riêng biệt</strong>. Điều này rất quan trọng nhé.</p><p>Cách tạo worker cơ bản</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'task.js'</span>);</span><br></pre></td></tr></table></figure><p>Nếu task.js tồn tại và có thể truy cập được, trình duyệt sẽ thiết lập một tiến trình mới để tải file bất đồng bộ. Sau khi quá trình tải file hoàn tất, nó sẽ thực thi code trong đó và worker bắt đầu làm việc.</p><p>Trong trường hợp file lỗi không load được thì trả về 404 và worker sẽ dừng lại một cách yên lặng như chưa có gì xảy ra.</p><p>Để bắt đầu tạo worker, bạn cần gọi phương thức postMessage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage();</span><br></pre></td></tr></table></figure><h1 id="Giao-tiep-cua-Web-Worker"><a href="#Giao-tiep-cua-Web-Worker" class="headerlink" title="Giao tiếp của Web Worker"></a>Giao tiếp của Web Worker</h1><p>Để giao tiếp giữa một Web Worker và trang của bạn thì bạn cần phải sử dụng phương thức postMessage hoặc <a href="https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel" target="_blank" rel="noopener">kênh phát sóng</a> (Broadcast channel).</p><h1 id="Phuong-thuc-postMessage"><a href="#Phuong-thuc-postMessage" class="headerlink" title="Phương thức postMessage"></a>Phương thức postMessage</h1><p>Các trình duyệt mới hỗ trợ object JSON như là param đầu tiên của phương thức trong khi các trình duyệt cũ hơn thì chọn string</p><p>Dưới đây là ví dụ về một page có worker có thể giao tiếp qua lại với nó như thế nào bằng cách truyền một object JSON. Truyền string cũng tương tự:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"startComputation()"</span>&gt;Start computation&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  function startComputation() &#123;</span></span><br><span class="line"><span class="regexp">    worker.postMessage(&#123;'cmd': 'average', 'data': [1, 2, 3, 4]&#125;);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  var worker = new Worker('doWork.js');</span></span><br><span class="line"><span class="regexp">  worker.addEventListener('message', function(e) &#123;</span></span><br><span class="line"><span class="regexp">    console.log(e.data);</span></span><br><span class="line"><span class="regexp">  &#125;, false);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>Và đoạn code của worker:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = e.data;</span><br><span class="line">  <span class="keyword">switch</span> (data.cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'average'</span>:</span><br><span class="line">      <span class="keyword">var</span> result = calculateAverage(data); <span class="comment">// Tính trung bình cộng từ một array</span></span><br><span class="line">      self.postMessage(result);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      self.postMessage(<span class="string">'Unknown command'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>Khi click vào button, trang chính sẽ gọi tới postMessage. Dòng worker.postMessage truyền một object JSON vào worker, object chứa thông tin là cmd và data. Worker sẽ xử lý message thông qua một message handler đã được định nghĩa.</p><p>Khi message đến, các thao tác tính toán thực sự sẽ được thực hiện trong worker mà không cản trở event loop. Worker kiểm tra event e được truyền vào và thực thi giống như một hàm Javascript bình thường. Khi xong việc kết quả sẽ được trả ngược lại cho trang chính.</p><p>Trong ngữ cảnh của worker, cả self và this đều đang tham chiếu đến global scope.</p><blockquote><p>Có 2 cách để dừng worker: gọi hàm worker.terminate() từ ngoài trang chính hoặc gọi self.close() bên trong worker.</p></blockquote><h1 id="Kenh-phat-song-Broadcast-Channel"><a href="#Kenh-phat-song-Broadcast-Channel" class="headerlink" title="Kênh phát sóng (Broadcast Channel)"></a>Kênh phát sóng (Broadcast Channel)</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel" target="_blank" rel="noopener">Broadcast Channel</a> giống như một API giao tiếp tổng quát. Nó cho phép chúng ta broadcast message tới tất cả các ngữ cảnh cùng chia sẻ chung origin. Tất cả các tab trình duyệt, iframe hoặc worker phục vụ chung origin có thể phát và nhận message.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kết nối đến một broadcast channel</span></span><br><span class="line"><span class="keyword">var</span> bc = <span class="keyword">new</span> BroadcastChannel(<span class="string">'test_channel'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ví dụ gửi một message đơn giản</span></span><br><span class="line">bc.postMessage(<span class="string">'This is a test message.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ví dụ về một event handler có chức</span></span><br><span class="line"><span class="comment">// năng in message ra console</span></span><br><span class="line">bc.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(e.data); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ngắt kết nối</span></span><br><span class="line">bc.close()</span><br></pre></td></tr></table></figure><p>Xem hình minh họa thì bạn sẽ hiểu cách hoạt động của Broadcast Channel rõ ràng hơn:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*NVT6WbNrH_mQL64--b-l1Q.png" alt=""></p><p>Broadcast Channel bị hạn chế hỗ trợ từ các trình duyệt:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*81mCsOzyJj-HfQ1lP_033w.png" alt=""></p><h1 id="Kich-thuoc-message"><a href="#Kich-thuoc-message" class="headerlink" title="Kích thước message"></a>Kích thước message</h1><p>Có 2 cách để gửi message trong Web Workers:</p><ul><li><p><strong>Sao chép message</strong>: message được serialized, sao chép, gửi đi và được de-serialized ở đầu kia. Trang web và worker không dùng chung instance, vì thế cuối cùng là kết quả sẽ bị trùng lặp ở cả 2 phía. Đa số các trình duyệt triển khai tính năng này bằng cách encoding/decoding giá trị ở cả 2 phía thành JSON một cách tự động. Đúng như dự đoán thì các hoạt động dữ liệu như thế này bổ sung thêm chi phí đáng kể vào việc truyền tải message. Message càng lớn thì thời gian gửi càng lâu.</p></li><li><p><strong>Truyền tải message</strong>: điều này nghĩa là bên gửi sẽ không thể sử dụng nó một khi đã gửi đi. Truyền tải dữ liệu gần như tức thời. Hạn chế là chỉ duy nhất <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a> là có thể gửi được.</p></li></ul><h1 id="Tinh-nang-co-san-cua-Web-Workers"><a href="#Tinh-nang-co-san-cua-Web-Workers" class="headerlink" title="Tính năng có sẵn của Web Workers"></a>Tính năng có sẵn của Web Workers</h1><p>Web Workder chỉ có truy xuất tới một tập hợp nhỏ các tính năng của Javascript bởi vì bản chất đa luồng của nó, dưới đây là danh sách các tính năng:</p><ul><li>Object navigator</li><li>Object location (chỉ đọc - read only)</li><li>XMLHttpRequest</li><li>setTimeout()/clearTimeout() và setInterval()/clearInterval()</li><li>Bộ đệm ứng dụng (<a href="https://www.html5rocks.com/tutorials/appcache/beginner/" target="_blank" rel="noopener">Application Cache</a>)</li><li>Import script bên ngoài thông qua importScripts()</li><li><a href="https://www.html5rocks.com/en/tutorials/workers/basics/#toc-enviornment-subworkers" target="_blank" rel="noopener">Tạo các web worker khác</a></li></ul><h1 id="Han-che-cua-Web-Workers"><a href="#Han-che-cua-Web-Workers" class="headerlink" title="Hạn chế của Web Workers"></a>Hạn chế của Web Workers</h1><p>Hơi buồn là Web Worker không có quyền truy cập đến một số tính năng quan trọng của Javascript:</p><ul><li>DOM (not thread-safe)</li><li>Object window</li><li>Object document</li><li>Object parent</li></ul><p>Điều này nghĩa là Web Worker không thể thay đổi DOM (và UI). Nó có thể hơi khó khăn, nhưng nếu bạn đã quen với viêc sử dụng Web Worker đúng cách thì bạn sẽ bắt đầu sử dụng khả năng “tính toán độc lập” của nó trong khi các code thay đổi UI đang được xử lý và hoạt động. Worker sẽ chăm sóc tất cả những phần nặng nhọc cho bạn và khi đã xong viêc thì bạn chỉ cần gửi kết quả ra màn hình để cập nhật UI cho phù hợp.</p><h1 id="Xu-ly-loi"><a href="#Xu-ly-loi" class="headerlink" title="Xử lý lỗi"></a>Xử lý lỗi</h1><p>Giống như code Javascript khác, bạn sẽ cần xử lý lỗi khi Web Worker bắn ra. Nếu có lỗi xảy ra trong quá trình worker thực thi, ErrorEvent sẽ được bắn. Interface này sẽ bao gồm 3 thuộc tính hữu ích cho việc tìm ra bạn đang sai chỗ nào:</p><ul><li><strong>filename</strong>: tên của worker script gây ra lỗi</li><li><strong>lineno</strong>: số của dòng gây ra lỗi</li><li><strong>message</strong>: mô tả lỗi</li></ul><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Line: '</span> + e.lineno);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'In: '</span> + e.filename);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Message: '</span> + e.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'workerWithError.js'</span>);</span><br><span class="line">worker.addEventListener(<span class="string">'error'</span>, onError, <span class="literal">false</span>);</span><br><span class="line">worker.postMessage(); <span class="comment">// Khởi tạo worker mà không truyền messageself.addEventListener('message', function(e) &#123;</span></span><br><span class="line">  postMessage(x * <span class="number">2</span>); <span class="comment">// Intentional error. 'x' is not defined.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Ở đây bạn thấy rằng chúng ta tạo worker và bắt đầu listen sự kiện error.</p><p>Bên trong worker (file workerWithError.js) chúng ta cố tình tạo một exception bằng cách nhân x với 2 trong khi x không hề tồn tại trong scope đó. Exception được bắn ra khi khởi tạo script và hàm onError được gọi với thông tin về lỗi.</p><h1 id="Truong-hop-nen-su-dung-Web-Workers"><a href="#Truong-hop-nen-su-dung-Web-Workers" class="headerlink" title="Trường hợp nên sử dụng Web Workers"></a>Trường hợp nên sử dụng Web Workers</h1><p>Cho đến bây giờ thì chúng ta đã nghiên cứu về điểm mạnh và hạn chế của Web Workers. Cùng xem những trường hơp nào thì dùng chúng là tốt nhất:</p><ul><li><strong>Dò tia (Ray tracing)</strong>: ray tracing là một kỹ thuật <a href="https://en.wikipedia.org/wiki/Rendering_%28computer_graphics%29" target="_blank" rel="noopener">render</a> để sinh ra những hình ảnh bằng cách dò theo vết đường đi của ánh sáng theo dạng pixel. Ray traycing sử dụng rất nhiều phép tính toán học có ảnh hướng lớn đến CPU để giả lập đường đi của ánh sáng. Ý tưởng về giả lập những hiệu ứng như phản chiếu (reflection), khúc xạ (refraction), vật liệu, vân vân. Tất cả các logic tính toán như vậy đều có thể đưa vào Web Worker để tránh gây trở ngại với UI thread. Thậm chí có thể tốt hơn nếu bạn có thể chia nhỏ quá trình render hình ảnh ra nhiều worker (và chia ra nhiều CPU). Đây là 1 minh họa đơn giản của ray tracing sử dụng Web Workers:  <a href="https://nerget.com/rayjs-mt/rayjs.html" target="_blank" rel="noopener">https://nerget.com/rayjs-mt/rayjs.html</a></li><li><strong>Mã hóa (Encryption)</strong>: Mã hóa end-to-end (E2EE) càng ngày càng phổ biến do sự gia tăng khắt khe về các quy định của dữ liệu nhạy cảm &amp; cá nhân. Mã hóa có thể khá tốn thời gian, đặc biệt nếu có rất nhiều dữ liệu cần được mã hóa thường xuyên (trước khi gửi về server chẳng hạn). Đây là một trường hợp trong đó Web Worker là lựa chọn rất tốt vì nó không yêu cầu truy xuất đến DOM hay các thứ khác, chỉ thuần túy là thuật toán mã hóa. Một khi đã được đẩy vào worker xử lý, nó sẽ hoạt động rất trơn tru và không ảnh hưởng đến trải nghiệm của người dùng.</li><li><strong>Tải trước dữ liệu</strong>: Để tối ưu website hoặc webapp và cải thiện thời gian loading, bạn có thể nhờ vả Web Workers để load và lưu dữ liệu trước và sử dụng chúng về sau khi cần đến. Web Workers rất tốt trong trường hợp này vì nó không ảnh hướng đến UI, không giống như khi ta dùng mà không có workers.</li><li><strong>Progressive Web Apps</strong>: Chúng cần được load thật nhanh kể cả khi kết nối mạng không ổn định. Nghĩa là dữ liệu cần phải được lưu trên trình duyệt. IndexDB hoặc những API tương tự hỗ trợ tốt khoản này. Về cơ bản thì lưu trữ ở phía client là cần thiết. Để có thể sử dụng mà không gây cản trở đến UI, công việc cần phải được hoàn thành trong Web Workers. Trong trường hợp của IndexDB, có một API bất đồng bộ cho phép bạn làm việc này mà không dùng workers, tuy nhiên cũng có một API đồng bộ trước đây (có thể sẽ được giới thiệu lại) chỉ được phép chạy bên trong workers.</li><li><strong>Kiểm tra chính tả (Spell checking)</strong>: một bộ spell checker cơ bản hoạt động như sau: chương trình sẽ đọc một file từ điển với danh sách các từ đúng chính tả. Từ điển sẽ được parse thành cây tìm kiếm (search tree) để có thể tìm kiếm văn bản hiệu quả. Khi một từ được đưa vào checker, chương trình sẽ kiểm tra nếu nó tồn tại trong cây tìm kiếm. Nếu từ đó không tồn tại, chương trình sẽ cung cấp từ thay thế bằng cách thay đổi ký tự thay thế và kiểm tra nếu đó là 1 từ hợp lệ nếu nó là từ mà user muốn viết ra. Tất cả quá trình này có thể dễ dàng giảm tải cho hệ thống bằng Web Workers và user có thể gõ chữ, viết câu mà không gây cản trở với UI trong khi worker thực thi tất cả các phần tìm kiếm và đưa ra đề xuất.</li></ul><p>Hiệu năng và độ tin cậy là rất quan trọng đối với team SessionStack. Lý do là vì một khi đã tích hợp SessionStack vào web app của bạn, chương trình sẽ bắt đầu ghi lại mọi thứ từ thay đổi trên DOM và tương tác người dùng đến các request mạng, exception không được xử lý và các thông báo lỗi. Tất cả dữ liệu được truyền về cho server của chương trình trong <strong>thời gian thực</strong> để có thể cho phép bạn chạy lại những issue từ webapp dưới dạng video và xem thử điều gì đang diễn ra với user. Tất cả điều này được thực hiện với độ trễ tối thiểu và không có ảnh hưởng đến hiệu năng của app của bạn.</p><p>Đây là lý do mà team tác giả đã đưa toàn bộ logic (phần nào có thể) từ cả thư viện điều hành &amp; phần player vào Web Worker để xử lý các công viêc nặng tải với CPU như băm để xác nhận tính toàn vẹn dữ liệu, render, vân vân.</p><p>Công nghệ web liên tục thay đổi và phát triển vì thế team tác giả đã đi thêm 1 chặng đường dài để đảm bảo SessionStack thật nhẹ và không gây ảnh hưởng đến hiệu năng của người dùng.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 7 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Trong bài này chúng ta sẽ tìm hiểu về Web Workers: một cái nhìn tổng quan, thảo luận về các loại worker khách nhau, các thành phần của nó hoạt động với nhau như thế nào và những điểm mạnh cũng như điểm yếu của nó trong các ngữ cảnh khác nhau. Cuối cùng, team tác giả sẽ cung cấp 5 trường hợp mà trong đó Web Worker là sự lựa chọn đúng đắn.&lt;/p&gt;
&lt;p&gt;Bạn đã quen với sự thật rằng Javascript chạy đơn luồng như chúng ta đã &lt;a href=&quot;https://kipalog.com/posts/Duc-khoet-Javascript--Phan-1---Khai-quat-ve-engine--runtime-va-callstack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;thảo luận chi tiết ở bài trước&lt;/a&gt;. JS cũng giúp các developer viết code bất đồng bộ.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P6: So sánh với WebAssembly + Một số trường hợp tốt hơn nên sử dụng</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P6-So-sanh-voi-WebAssembly-Mot-so-truong-hop-tot-hon-nen-su-dung.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P6-So-sanh-voi-WebAssembly-Mot-so-truong-hop-tot-hon-nen-su-dung.html</id>
    <published>2018-11-16T00:19:00.000Z</published>
    <updated>2018-11-16T00:21:12.978Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 6 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Lần này chúng ta sẽ khám phá về WebAssembly và phân tích cách hoạt động của nó, quan trọng hơn là những điểm vượt trội hơn so với Javascript về mặt hiệu năng: thời gian tải, tốc độ thực thi, dọn rác (GC), sử dụng bộ nhớ, truy cập API, debugging, đa luồng và tính di động (portability).</p><p>Cách chúng ta xây dựng web app trên bờ vực cách mạng - vẫn đang trong những ngày đầu nhưng cách chúng ta suy nghĩ về web app đang dần thay đổi.<br><a id="more"></a></p><h1 id="Cung-xem-WebAssembly-co-the-lam-gi"><a href="#Cung-xem-WebAssembly-co-the-lam-gi" class="headerlink" title="Cùng xem WebAssembly có thể làm gì"></a>Cùng xem WebAssembly có thể làm gì</h1><p>WebAssembly (gọi tắt <strong>wasm</strong>) là một loại bytecode cấp độ thấp và hiệu quả cho web.</p><p>WASM cho phép bạn sử dụng ngôn ngữ khác Javascript (như C, C++, Rust…), viết chương trình với những ngôn ngữ đó, và biên dịch trước (ahead of time) sang WebAssembly.</p><p>Kết quả là webapp sẽ load và thực thi rất nhanh.</p><h1 id="Thoi-gian-tai-loading-time"><a href="#Thoi-gian-tai-loading-time" class="headerlink" title="Thời gian tải (loading time)"></a>Thời gian tải (loading time)</h1><p>Để load Javascript, trình duyệt phải load tất cả file .js đúng nguyên văn bản.</p><p>WebAssembly load nhanh hơn trong trình duyệt bởi vì chỉ có những file wasm <strong>đã được biên dịch</strong> là được truyền tải qua internet. Và bởi vì wasm là ngôn ngữ bậc thấp gần giống assembly có format nhị phân rất nhỏ gọn.</p><h1 id="Thuc-thi-execution"><a href="#Thuc-thi-execution" class="headerlink" title="Thực thi (execution)"></a>Thực thi (execution)</h1><p>Wasm chạy chậm hơn 20% <strong>so với native code</strong>. Dù gì đi nữa thì đây là một kết quả đáng kinh ngạc. Nó là một định dạng được biên dịch sang môi trường sandbox và chạy cùng rất nhiều ràng buộc để đảm bảo nó không có những điểm yếu bảo mật hoặc rất khó để chống lại. Tốc độ chậm là không đáng kể khi so với native code. Hơn nữa, nó sẽ được cải thiện chạy nhanh hơn trong tương lai.</p><p>Ngoài ra, khả năng tương thích rất tốt với trình duyệt là điểm mạnh, tất cả những engine lớn đều có hỗ trợ WebAssembly và đều đưa ra thời gian thực thi tương đương nhau.</p><p>Để hiểu WebAssembly thực thi nhanh như thế nào so với Javascript, bạn nên <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-2---Ben-trong-engine-V8---5-meo-de-toi-uu-hoa-code" target="_blank" rel="noopener">đọc bài trước trong series Đục khoét Javascript</a></p><p>Cùng xem điều gì xảy ra trong V8:<br><img src="https://cdn-images-1.medium.com/max/1000/0*bN9YVBLw_tT1Xvte." alt=""></p><p>Cách tiếp cận của V8: biên dịch chậm</p><p>Ở bên trái, chúng ta có Javascript source, bao gồm các hàm. Đầu tiên thì nó cần phải được parse (phân tích cú pháp) để chuyển tất cả string sang token và sinh ra <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">Abstract Syntax Tree</a> (AST - Cây cú pháp trừu tượng, chúng ta sẽ có một bài viết về nó sau). Cây AST là đại diện biểu thị logic của chương trình JS trong bộ nhớ. Một khi nó được sinh ra, V8 sẽ đi thẳng đến mã máy. Về cơ bản thì bạn sẽ duyệt qua cây đó, tạo ra mã máy và hàm của bạn đã được biên dịch. Không có tiến trình nào cố gắng tăng tốc nó.</p><p>Giờ thì lướt qua xem V8 pipeline làm gì tiếp theo:</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*wzuQ9LYv7CAUICOC." alt=""></p><p>Chúng ta có <a href="https://github.com/v8/v8/wiki/TurboFan" target="_blank" rel="noopener">TurboFan</a>, 1 trong những trình biên dịch tối ưu hóa của V8. Trong khi app Javascript đang chạy thì còn có rất nhiều code khác chạy trong V8. TurboFan thực hiện điều hành, nếu có gì chạy chậm bất kể là đang nghẽn cổ chai (bottleneck) hay những điểm nóng (hot spots), thì sẽ được tối ưu hóa. Nó đẩy phần code đang ngốn tài nguyên CPU đó qua một bộ <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener">JIT</a> tối ưu để tạo ra code nhanh hơn nhiều.</p><p>Nó giải quyết vấn đề, nhưng bên cạnh đó quá trình phân tích code và quyết định nên tối ưu như thế nào cũng làm tốn tài nguyên CPU. Điều này, làm hao tổn thời lượng pin nhiều hơn, đặc biệt là trên các thiết bị di động.</p><p>Chà, wasm thì không cần. Nó đi thẳng vào quá trình làm việc như dưới đây:</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*GDU4GguTzk8cSAYk." alt=""></p><p>Wasm đã duyệt qua quá trình tối ưu hóa ngay trong giai đoạn biên dịch. Trên hết thì parsing đã không còn cần thiết nữa. Bạn có mã nhị phân tối ưu có thể gắn trực tiếp vào bộ phận backend để sinh ra mã máy. Tất cả các sự tối ưu hóa đã được hoàn thành bởi trình biên dịch ở frontend.</p><p>Điều này làm cho quá trình thực thi wasm trở nên hiệu quả hơn rất nhiều bởi vì ta có thể bỏ qua 1 số bước trong khi xử lý.</p><h1 id="Mo-hinh-bo-nho"><a href="#Mo-hinh-bo-nho" class="headerlink" title="Mô hình bộ nhớ"></a>Mô hình bộ nhớ</h1><p><img src="https://cdn-images-1.medium.com/max/1000/0*QphcOVaiVC2YL7Jd." alt=""></p><p>Bộ nhớ của 1 chương trình C++ là chuỗi liền kề các block nhớ không có “lỗ”. Một trong số các tính năng của wasm giúp đẩy mạnh sự bảo mật là ý tưởng về stack thực thi đặt riêng biệt với bộ nhớ thẳng hàng (linear). Trong C++ ta có heap, cấp phát từ đáy của heap và phát triển stack ở đỉnh heap. Ta có thể lấy con trỏ và tìm kiếm trong bộ nhớ stack để chơi đùa với những biến mà chúng ta còn không đụng tới.</p><p>Đây là một điểm cạm bẫy mà rất nhiều malware khai thác.</p><p>WebAssembly sử dụng một mô hình hoàn toàn khác. Stack thực thi tách biệt với chương trình chính WebAssembly nên không có cách nào bạn có thể chỉnh sửa và thay đổi những biến bên trong nó. Thêm nữa là các hàm có offset là số nguyên chứ ko dùng contror. Hàm trỏ vào một bảng chức năng vô hướng. Sau đó, các con số được tính toán trực tiếp này được đưa vào bên trong module. Nó được xây dựng theo cách này để có thể load nhiều wasm cùng lần, đánh offset tất cả các index và nó sẽ chạy tốt.</p><p>Để tìm hiểu sâu hơn về mô hình bộ nhớ và các cách quản lý trong Javascript, bạn có thể <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-3---Quan-ly-bo-nho---4-truong-hop-ro-ri-pho-bien" target="_blank" rel="noopener">xem lại bài trước</a>.</p><h1 id="Don-rac-GC"><a href="#Don-rac-GC" class="headerlink" title="Dọn rác (GC)"></a>Dọn rác (GC)</h1><p>Chúng ta đã biết quản lý bộ nhớ của Javascript có bao gồm cả xử lý dọn rác Garbage Collector.</p><p>Đối với WebAssembly thì hơi khác một chút. Nó hỗ trợ những ngôn ngữ quản lý bộ nhớ thủ công. Bạn có thể sử dụng GC của chính bạn với các wasm module, nhưng công việc đó hơi phức tạp.</p><p>Hiện tại, WebAssembly được thiết kế xoay quanh các trường hợp sử dụng của C++ và RUST. Bởi vì wasm là ngôn ngữ thấp nên sẽ dễ hiểu hơn nếu sử dụng những ngôn ngữ lập trình gần gũi &amp; dễ biên dịch ra ngôn ngữ assembly. C có thể sử dụng malloc thường, C++ có thể dùng con trỏ thông minh. Rust dùng một mô hình khác hoàn toàn (nhưng là 1 chủ đề khác nhé). Những ngôn ngữ này không dùng GC, do đó chúng không cần các tác vụ runtime để theo dõi bộ nhớ. WebAssembly phù hợp với chúng.</p><p>Thêm nữa, những ngôn ngữ này không phải được thiết kế 100% cho việc truy vấn những thứ phức tạp thuộc về Javascript, ví dụ như thay đổi DOM. Nó khá vô nghĩa khi phải viết toàn bộ app HTML trên nền C++ bởi vì C++ không được thiết kế với mục đích làm webapp. Đa số các trường hợp các kỹ sư dùng C++ hoặc Rust, họ hướng tới WebGL hoặc những thư viện có tính tối ưu hóa cao. (Ví dụ: phép tính toán học khó và phức tạp)</p><p>Tuy nhiên, trong tương lai WebAssembly sẽ hỗ trợ những ngôn ngữ có sẵn GC.</p><h1 id="Truy-xuat-Platform-API"><a href="#Truy-xuat-Platform-API" class="headerlink" title="Truy xuất Platform API"></a>Truy xuất Platform API</h1><p>Tùy thuộc vào môi trường runtime thực thi Javascript, quyền truy xuất vào những API đang tồn tại đặc trưng cho platform có thể được truy cập trực tiếp thông qua app JS của bạn. Ví dụ: bạn chạy JS code trên trình duyệt, bạn có 1 cục các Web API mà webapp có thể gọi và điều khiển trình duyệt hoặc chức năng thiết bị và có quyền truy xuất vào DOM, CSSOM, WebGL, IndexedDB, Web Audio API, vân vân.</p><p>WebAssembly module không có quyền truy cập vào platform API. Mọi thứ đều trung gian qua Javascript. Nếu bạn muốn truy xuất vào một số API đặc trưng cho platform bên trong module WebAssembly thì bạn phải gọi nó thông qua Javascript.</p><p>Ví dụ, nếu muốn dùng console.log, bạn gọi nó thông qua JS thay vì C++. Và dĩ nhiên là sẽ có những hạn chế về JS mà ta phải chấp nhận.</p><p>Nhưng trường hợp này sẽ sớm được khắc phục khi mà đặc điểm kỹ thuật sẽ cung cấp các platform API cho wasm trong tương lai, bạn sẽ có thể sớm phát triển app mà không cần Javascript.</p><h1 id="Anh-xa-ma-nguon-Source-map"><a href="#Anh-xa-ma-nguon-Source-map" class="headerlink" title="Ánh xạ mã nguồn (Source map)"></a>Ánh xạ mã nguồn (Source map)</h1><p>Khi bạn làm tối giản code JS, bạn cần đảm bảo có thể debug nó. Đó là khi mà ta cần đến <a href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" target="_blank" rel="noopener">Source Map</a>.</p><p>Về cơ bản, Source Map là 1 cách để map một file tối giản về với trạng thái ban đầu của nó. Khi bạn build sản phẩm cho môi trường production, cùng với file JS đã kết hợp &amp; tối gian, bạn sẽ sinh ra 1 file source map chứa thông tin về file JS gốc. Khi bạn query một dòng cụ thể với số cột nào đó file JS, bạn có thể tra cứu trong source map để tìm ra vị trí gốc ban đầu của nó.</p><p>WebAssembly không hỗ trợ source map vì nó chưa có mô tả kỹ thuật cho phần này nhưng hi vọng là tương lai gần sẽ hỗ trợ.</p><p>Khi bạn đặt breakpoint trong code C++, bạn sẽ thấy code C++ thay vì WebAssembly, ít nhất là vẫn còn có ích.</p><h1 id="Da-luong-Multithreading"><a href="#Da-luong-Multithreading" class="headerlink" title="Đa luồng (Multithreading)"></a>Đa luồng (Multithreading)</h1><p>Ai cũng biết Javascript là đơn luồng. Có nhiều cách để cải thiện Event Loop và nâng cấp phần lập trình bất đồng bộ mà chúng tôi đã <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-4---Event-loop--lap-trinh-bat-dong-bo---5-meo-cai-thien-Async-Await" target="_blank" rel="noopener">giới thiệu trong bài trước</a>.</p><p>Javascript có thể dùng Web Workers nhưng nó rất hạn chế trường hợp. Về cơ bản, bất kỳ tính toán nào ảnh hưởng nặng đến CPU và block luồng xử UI đều có thể được đẩy ra load riêng với WebWorker. Tuy nhiên, WebWorker lại không truy xuất được vào DOM.</p><p>WebAssembly hiện tại không hỗ trợ đa luồng. Tuy nhiên, điều này chắc chắn sẽ được thay đổi. Wasm đang tiến gần tới những tiến trình native (ví dụ: luồng kiểu C++). Có những luồng “thực” sẽ tạo ra rất nhiều cơ hội mới trên trình duyệt. Và lẽ dĩ nhiên, nó cũng sẽ bị lạm dụng nhiều hơn.</p><h1 id="Tinh-di-dong-Portability"><a href="#Tinh-di-dong-Portability" class="headerlink" title="Tính di động (Portability)"></a>Tính di động (Portability)</h1><p>Ngày nay Javascript có thể chạy ở bất kỳ đâu, từ trình duyệt đến server, kể cả trong các hệ thống nhúng.</p><p>WebAssembly được thiết kế để an toàn và linh động. Như Javascript, nó chạy trên nhiều môi trường hỗ trợ wasm (ví dụ: mọi trình duyệt)</p><p>WebAssembly có cùng mục tiêu di động như cách mà Java đang cố thực hiện trong những ngày đầu với Applets.</p><h1 id="Khi-nao-thi-dung-WebAssembly-tot-hon-JavaScript"><a href="#Khi-nao-thi-dung-WebAssembly-tot-hon-JavaScript" class="headerlink" title="Khi nào thì dùng WebAssembly tốt hơn JavaScript?"></a>Khi nào thì dùng WebAssembly tốt hơn JavaScript?</h1><p>Trong các phiên bản đầu của WebAssembly, chức năng chính chỉ tập trung vào các phép tính nặng tải trên CPU (các bài toán phức tạp chẳng hạn). Ứng dụng chủ yếu nhất khi nghĩ đến là games - có cả hàng tấn pixel cần thao tác xử lý trên màn hình. Bạn có thể viết app bằng ngôn ngữ mà bạn quen thuộc như C++/Rust bằng OpenGL sao đó biên dịch sang wasm và nó sẽ chạy trên trình duyệt.</p><p>Bạn có thể xem ví dụ sau (tốt nhất là dùng Firefox): <a href="http://s3.amazonaws.com/mozilla-games/tmp/2017-02-21-SunTemple/SunTemple.html" target="_blank" rel="noopener">http://s3.amazonaws.com/mozilla-games/tmp/2017-02-21-SunTemple/SunTemple.html</a>. Nó chạy trên nền <a href="https://www.unrealengine.com/en-US/what-is-unreal-engine-4" target="_blank" rel="noopener">Unreal engine</a>.</p><p>Một trường hợp khác tiêu biểu cho viêc sử dụng WebAssembly (về mặt hiệu năng) là triển khai một số thư viện chạy các tác vụ nặng với CPU, ví dụ như xử lý ảnh.</p><p>Như đã nói ở trước, wasm có thể giảm khá nhiều lượng tiêu thụ pin trên các thiết bị di động (phụ thuộc vào engine), bởi vì đa số các bước xử lý đều đã được hoàn thành trước trong khi biên dịch.</p><p>Trong tương lai, bạn sẽ có thể sử dụng code WASM nhị phân kể cả khi bạn không thực sự viết code có thể biên dịch ra nó. Bạn có thể tìm vài projects trên NPM đang bắt đầu triển khai theo hướng này.</p><p>Với trường hợp thay đổi DOM và sử dụng nhiều platform API thì tốt nhất vẫn là dùng Javascript, bởi vì rõ ràng nó hỗ trợ tốt với các API đó.</p><p>Ở <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=Post-6-webassembly-outro" target="_blank" rel="noopener">SessionStack</a>, tác giả liên tục mở rộng biên giới hiệu năng của Javascript nhằm viết được nhiều code tối ưu và hiệu quả cao. Giải pháp của họ cần cung cấp hiệu năng nhanh chóng mặt vì không thể gây ảnh hưởng lên hiệu năng của app của khách hàng.</p><p>Một khi bạn đã tích hợp SessionStack vào web app của bạn, nó sẽ ghi lại mọi thứ diễn ra trên app/website: những thay đổi trên DOM, tương tác của người dùng, JS exception, stack trace, những request bị fail và cả thông báo debug, cho phép bạn chạy lại (replay) những issue đã xảy ra dưới dạng video và xem chúng diễn ra như thế nào với người dùng. Tất cả đều hoạt động theo thời gian thực (real-time) và không ảnh hưởng đến hiệu năng của webapp. SessionStack phải tối ưu hóa code một cách tối đa và làm cho quá trình này bất đồng bộ nhất có thể.</p><p>Không chỉ là một thư viện! Khi bạn chạy lại một session của người dùng trong SessionStack thì nó phải render lại toàn bộ những gì mà trình duyệt của user thực hiện tại thời điểm vấn đề xảy ra và team tác giả phải xây dựng lại toàn bộ trạng thái, cho phép bạn có thể nhảy tới nhảy lui trong timeline session. Để đạt được điều đó, team tác giả đã tận dụng tối đa khả năng bất đồng bộ mà Javascript cung cấp trong khi thiếu sót những giải pháp tốt hơn.</p><p>Với WebAssembly, team tác giả có thể đẩy những tiến trình xử lý và render nặng nhất vào một ngôn ngữ phù hợp hơn với công việc này và để phần thu thập dữ liệu, thay đổi DOM cho Javascript làm.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 6 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Lần này chúng ta sẽ khám phá về WebAssembly và phân tích cách hoạt động của nó, quan trọng hơn là những điểm vượt trội hơn so với Javascript về mặt hiệu năng: thời gian tải, tốc độ thực thi, dọn rác (GC), sử dụng bộ nhớ, truy cập API, debugging, đa luồng và tính di động (portability).&lt;/p&gt;
&lt;p&gt;Cách chúng ta xây dựng web app trên bờ vực cách mạng - vẫn đang trong những ngày đầu nhưng cách chúng ta suy nghĩ về web app đang dần thay đổi.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P5: Hiểu sâu về WebSocket &amp; HTTP/2 với SSE</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P5-Hieu-sau-ve-WebSocket-HTTP-2-voi-SSE.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P5-Hieu-sau-ve-WebSocket-HTTP-2-voi-SSE.html</id>
    <published>2018-11-16T00:04:00.000Z</published>
    <updated>2018-11-16T00:16:38.066Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 5 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Trong phần này chúng ta sẽ đào sâu với thế giới của những giao thức giao tiếp, ánh xạ (mapping) và thảo luận về những thuộc tính cũng như thành phần của chúng. Chúng ta sẽ đưa ra 1 so sánh nhỏ giữa WebSockets và HTTP/s. Cuối cùng, team SessionStack sẽ chia sẻ một vài ý tưởng về việc lựa chọn phương thức nào cho phù hợp với giao thức mạng.<br><a id="more"></a></p><h1 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu"></a>Giới thiệu</h1><p>Ngày nay những webapp phức tạp có nhiều tính năng, UI động xuất hiện như trăm hoa đua nở. Cũng không phải bất ngờ, internet cũng đã phát triển được một quãng đường khá dài kể từ khi bắt đầu.</p><p>Ban đầu, internet không được xây dựng để dành cho những app động và phức tạp. Nó được hình thành như là một tập hợp của các trang HTML, kết nối với nhau để cấu thành nên khái niệm về “Web” chứa thông tin. Phần lớn mọi thứ được xây dựng xung quanh mô hình request/response nổi tiếng của HTTP. Một client tải trang và không có gì xảy ra cho đến khi user bắt đầu click và di chuyển đến trang tiếp theo.</p><p>Khoảng năm 2005, AJAX được giới thiệu và rất nhiều người đã khám phá khả năng tạo kết nối giữa client và server theo 2 chiều (<strong>bidirectional</strong>). Và vẫn như thế, tất cả giao tiếp HTTP được chỉ đạo bởi client yêu cầu user tương tác hoặc thực hiện theo chu kỳ để lấy dữ liệu mới từ server.</p><h1 id="Tao-mot-HTTP-“2-chieu”"><a href="#Tao-mot-HTTP-“2-chieu”" class="headerlink" title="Tạo một HTTP “2 chiều”"></a>Tạo một HTTP “2 chiều”</h1><p>Công nghệ cho phép server gửi dữ liệu về client một cách “chủ động” đã phát triển được 1 thời gian. Push và Comet là ví dụ.</p><p>Một trong số mẹo nổi tiếng để tạo ra ảo giác rằng server đang gửi dữ liệu về client được gọi là long polling. Với long polling, client mở kết nối HTTP đến server và giữ nó tiếp tục mở cho đến khi có response trả về. Mỗi khi server có dữ liệu mới cần được gửi, nó chuyển giao thông tin dưới dạng một response.</p><p>Cùng xem một ví dụ đơn giản về long polling:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">poll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $.ajax(&#123; </span><br><span class="line">        url: <span class="string">'https://api.example.com/endpoint'</span>, </span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// Làm gì đó với `data`</span></span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// Cài đặt poll mới theo đệ quy</span></span><br><span class="line">          poll();</span><br><span class="line">        &#125;, </span><br><span class="line">        dataType: <span class="string">'json'</span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, <span class="number">10000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>Đây là một hàm tự thực thi cơ bản chạy một cách tự động lần đầu tiên. Nó sẽ cài đặt một khoảng thời gian 10 giây và sau mỗi lời gọi Ajax bất đồng bộ đến server, callback lại gọi ajax lần nữa.</p><p>Vài kỹ thuật khác có thể kể đến như <a href="http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/net/Socket.html" target="_blank" rel="noopener">Flash</a>, request nhiều thành phần XHR và <a href="http://cometdaily.com/2007/12/27/a-standards-based-approach-to-comet-communication-with-rest/" target="_blank" rel="noopener">htmlfiles</a> nổi tiếng.</p><p>Tất cả những phương pháp này đều có chung một vấn đề: Chúng qua mặt HTTP, làm cho chúng không phù hợp với những app có độ trễ thấp. Giả sử như game bắn súng nhiều người chơi trên trình duyệt hoặc bất kỳ game onlinen nào có đối thủ thực.</p><h1 id="Gioi-thieu-WebSockets"><a href="#Gioi-thieu-WebSockets" class="headerlink" title="Giới thiệu WebSockets"></a>Giới thiệu WebSockets</h1><p>Thông số kỹ thuật của WebSocket định nghĩa một kết nối API dạng “socket” (ổ cắm điện!) giữa trình duyệt và server. Theo nghĩa đen thì có 1 kết nối cố định giữa client và server và cả 2 bên có thể gửi dữ liệu bất kỳ lúc nào.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*a4lA5FYDkjA9mv53NPKtOg.png" alt=""></p><p>Client thiết lập một kết nối WebSocket thông qua một tiến trình được gọi là WebSocket handshake (bắt tay WebSocket). Tiến trình này bắt đầu với client gửi một request HTTP thông thường đến server. Nó kèm theo header Upgrade để thông báo cho server rằng client muốn tạo một kết nối WebSocket.</p><p>Cùng xem thử quá trình mở kết nối WebSocket như thế nào ở phía client:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new WebSocket with an encrypted connection.</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://websocket.example.com'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>WebSocket URL sử dụng ws scheme. Chúng ta còn có cả wss cho những kết nối WebSocket bảo mật hơn, tương tự như HTTPS.</p></blockquote><p>Scheme này bắt đầu một tiến trình mở kết nối WebSocket đến websocket.example.com.</p><p>Dưới đây là 1 ví dụ đơn giản của header của request khởi tạo.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET ws:<span class="comment">//websocket.example.com/ HTTP/1.1</span></span><br><span class="line">Origin: http:<span class="comment">//example.com</span></span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: websocket.example.com</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure><p>Nếu server hỗ trợ giao thức WebSocket, nó sẽ đồng ý để nâng cấp và giao tiếp thông qua header Upgrade trong response.</p><p>Cùng xem phần thiết lập của nó trong Node.js như thế nào:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chúng ta sẽ dùng https://github.com/theturtle32/WebSocket-Node</span></span><br><span class="line"><span class="comment">// Triển khai WebSocket</span></span><br><span class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'websocket'</span>).server;</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// xử lý HTTP request. </span></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tạo server</span></span><br><span class="line">wsServer = <span class="keyword">new</span> WebSocketServer(&#123;</span><br><span class="line">  httpServer: server</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// WebSocket server</span></span><br><span class="line">wsServer.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> connection = request.accept(<span class="literal">null</span>, request.origin);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Đây là callback quan trọng nhất,chúng ta sẽ </span></span><br><span class="line">  <span class="comment">// xử lý thông tin của client ở đây.</span></span><br><span class="line">  connection.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Xử lý thông tin WebSocket</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  connection.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">connection</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Đóng kết nối</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Sau khi thành lập kết nối, server trả về:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="built_in">Date</span>: Wed, <span class="number">25</span> Oct <span class="number">2017</span> <span class="number">10</span>:<span class="number">07</span>:<span class="number">34</span> GMT</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: WebSocket</span><br></pre></td></tr></table></figure><p>Khi kết nối đã được thiết lập, sự kiện open sẽ được bắn ra cho instance WebSocket ở phía client:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://websocket.example.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hiện thông báo khi kết nối WebSocket thành công.</span></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'WebSocket is connected.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Giờ thì quá trình “bắt tay” đã hoàn tất, kết nối khởi tạo HTTP được thay thế bằng WebSocket và sử dụng cùng loại nền tảng kết nối TCP/IP. Tại thời điểm này, cả 2 bên đều có thể gửi dữ liệu.</p><p>Với WebSocket, bạn có thể truyền bao nhiêu thông tin tùy thích mà không cần phải gánh chịu những chi phí không đáng có liên quan đến request HTTP truyền thống. Dữ liệu được truyền đi thông qua WebSocket dưới dạng tin nhắn (message), mỗi tin nhắn bao gồm một hoặc nhiều <em>frame</em> chứa dữ liệu bạn gửi đi (gọi là <em>kiện hàng</em> - <em>payload</em>). Để đảm bảo message có thể tái cấu trúc một cách chính xác khi nó đến với client, mỗi frame được gán cứng từ 4-12 byte thông tin về payload. Sử dụng hệ thống thông tin dựa trên frame như thế này giúp giảm tải khối lượng dữ liệu dư thừa (non-payload data) phải truyền đi, có thể làm cho độ trễ giảm đi đáng kể.</p><p><strong>Lưu ý</strong>: <em>Đặc biệt chú ý là client chỉ được thông báo về message mới một khi tất cả frame đều được nhận và payload message gốc được tái cấu trúc đầy đủ</em></p><h1 id="WebSocket-URLs"><a href="#WebSocket-URLs" class="headerlink" title="WebSocket URLs"></a>WebSocket URLs</h1><p>Chúng ta có đề cập sơ qua về WebSocket URL scheme ở trên. Trong thực thế, chúng giới thiệu có 2 scheme mới là ws:// và wss://</p><p>URL có cấu trúc ngữ pháp cụ thể về scheme. WebSocket URL đặc biệt vì nó không hỗ trợ nhóm ký tự anchor (có dấu thăng ở trước, ví dụ: #đây_là_anchor).</p><p>Có những luật chung được áp dụng cho cả style của WebSocket URL và HTTP URL. ws không được mã hóa, nó có cổng mặc định là 80 trong khi đó wss yêu cầu mã hóa TLS và dùng cổng 443 mặc định.</p><h1 id="Framing-protocol-Giao-thuc-framing"><a href="#Framing-protocol-Giao-thuc-framing" class="headerlink" title="Framing protocol (Giao thức framing)"></a>Framing protocol (Giao thức framing)</h1><p>Cùng đào sâu một chút về framing protocol với những gì <a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC</a> cung cấp:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                     <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (<span class="number">4</span>)  |A|     (<span class="number">7</span>)     |             (<span class="number">16</span>/<span class="number">64</span>)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (<span class="keyword">if</span> payload len==<span class="number">126</span>/<span class="number">127</span>)   |</span><br><span class="line">| |<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, <span class="keyword">if</span> payload len == <span class="number">127</span>  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, <span class="keyword">if</span> MASK set to <span class="number">1</span>  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>Theo như RFC định nghĩ về WebSocket thì nó chỉ có duy nhất một header trước mỗi gói tin, và nó khá phức tạp. Chúng ta cùng tìm hiểu:</p><ul><li>fin (1 bit): biểu thị nếu frame đó là frame cuối cùng tạo nên message. Hầu hết message đều có thể chứa trong một frame duy nhất và bit này luôn có giá trị. Thực nghiệm cho thấy Firefox tạo 1 frame thứ 2 sau mỗi 32K.</li><li>rsv1, rsv2, rsv3 (Mỗi thứ 1 bit): phải bằng 0 trừ khi có một <a href="https://tools.ietf.org/html/rfc6066" target="_blank" rel="noopener">extension</a> (đại khái như tiện ích mở rộng) được trao đổi và nó định nghĩa ý nghĩa cho giá trị khác 0. Nếu nhận về một giá trị khác 0 và không có extension nào xác định ý nghĩa của giá trị khác 0 đó được trao đổi thì người nhận cuối sẽ bị mất kết nối.</li><li>opcode (4 bit): nó cho biết những gì frame đại diện. Có những giá trị sau đây được dùng:<ul><li>0x00: frame này tiếp tục payload từ frame trước đó.</li><li>0x01: frame này chứa dữ liệu chữ (text).</li><li>0x02: frame này chứa dữ liệu nhị phân (binary).</li><li>0x08: frame này hủy kết nối.</li><li>0x09: frame này là ping.</li><li>0x0a: frame này là pong.</li></ul></li></ul><p>(Bạn có thể thấy rằng có nhiều giá trị không sử dụng, chúng được dự trữ cho tương lai khi cần)</p><ul><li>mask (1 bit): biểu thị nếu kết nối đã được che đậy (mask). Rõ ràng là mỗi message từ client đến server <em>phải được che đậy</em> và về mặt kỹ thuật thì nó sẽ hủy kết nối nếu không được che đậy.</li><li>payload_len (7 bit): độ dài của payload. WebSocket frame có những độ dài theo các khoảng tính theo byte như sau:<ul><li>0-125 biểu thị độ dài của payload</li><li>Nếu là 126 byte thì 2 byte tiếp theo biểu thị độ dài payload dưới dạng số nguyên 16bit không dấu</li><li>Nếu là 127 byte thì 8 byte tiếp theo biểu thị độ dài payload dưới dạng số nguyên 64bit không dấu</li><li>Vậy là độ dài payload sẽ vào khoảng ~7bit, 16bit hoặc 64bit.</li></ul></li><li>masking-key (32 bit): tất cả frame được gửi từ client đến server sẽ được che đậy (mask) bằng một giá trị 32bit đính kèm trong frame.</li><li>payload: Dữ liệu thật sự cần được che đậy. Độ dài của nó chính là payload_len</li></ul><p>Tại sao WebSocket lại dựa trên frame (frame-based) mà không dựa trên dòng chảy (stream-based)? Có trời mới biết, tác giả cũng không biết vì sao nên nếu bạn có thông tin gì về điều này thì có thể nhắn tin đến tác giả. Ngoài ra thì có <a href="https://news.ycombinator.com/item?id=3377406" target="_blank" rel="noopener">một topic thảo luận rất tốt về vấn đề này trên HackerNews</a>, bạn có thể tham khảo.</p><h1 id="Du-lieu-tren-frame"><a href="#Du-lieu-tren-frame" class="headerlink" title="Dữ liệu trên frame"></a>Dữ liệu trên frame</h1><p>Như đã nói ở trên, dữ liệu có thể phân mảnh thành nhiều frame. Frame đầu tiên chuyển giao dữ liệu có một opcode biểu thị kiểu dữ liệu đang được truyền. Điều này cần thiết bởi vì Javascript hầu như không có hỗ trợ cho kiểu dữ liệu nhị phân (binary) khi nó được xây dựng. 0x01 biểu thị kiểu encode văn bản UTF-8, 0x02 là dữ liệu nhị phân. Đa số mọi người sẽ chuyển giao JSON trong trường hợp bạn muốn chọn opcode văn bản. Khi bạn phát tín hiệu (emit) dữ liệu nhị phân nó sẽ được thể hiện trên trình duyệt dưới dạng cụ thể là <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a>.</p><p>API để gửi dữ liệu thông qua WebSocket khá đơn giản:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://websocket.example.com'</span>);</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  socket.send(<span class="string">'Some message'</span>); <span class="comment">// Gửi dữ liệu đến server.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Khi WebSocket nhận dữ liệu (ở phía client), một sự kiện message được bắn ra. Sự kiện này bao gồm một thuộc tính gọi là data có thể dùng để truy cập nội dung của message.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Xử lý message gửi đi từ server.</span></span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = event.data;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Bạn có thể khám phá dữ liệu một cách dễ dàng trong mỗi frame trong kết nối WebSocket sử dụng tab Network trong Chrome DevTools:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*Sz4wI2ukt91vRrgf8UonWw.png" alt=""></p><h1 id="Su-phan-manh"><a href="#Su-phan-manh" class="headerlink" title="Sự phân mảnh"></a>Sự phân mảnh</h1><p>Dữ liệu payload có thể được chia thành nhiều frame riêng. Nơi nhận có nhiệm vụ lưu đệm chúng cho đến khi bit fin được set. Thế nên bạn có thể chuyển 1 chuỗi “Hello World” trong 11 gói tin của 6 (độ dài header) + 1 byte cho mỗi gói. Sự phân mảnh không được chấp nhận cho gói tin điều khiển (control packages). Tuy nhiên, đặc điểm kỹ thuật muốn bạn có thể xử lý những frame điều khiển xen kẽ nhau. Đó là trường hợp gói tin TCP nhận được có thứ tự lộn xộn.</p><p>Logic để kết nối frame được mô tả sơ lược như sau:</p><ul><li>Nhận frame đầu tiên</li><li>Ghi nhớ opcode</li><li>Nối các frame payload lại với nhau cho đến khi bit fin được set.</li><li>Giả định rằng opcode cho mỗi gói tin là 0</li></ul><p>Mục đích chính của sự phân mảnh là cho phép gửi message khi không biết rõ kích thước ban đầu của message. Với sự phân mảnh, server có thể chọn một kích thước buffer (bộ đệm) phù hợp và khi buffer đầy thì ghi mảnh (fragment) đó vào network. Trường hợp sử dụng phụ của sự phân mảnh là truyền tin đa luồng (multiplexing), vốn dĩ không cần một message lớn trên một kênh logic để tiếp nhận toàn bộ kênh đầu ra, vì thế multiplexing cần phải giải phóng để cắt message ra thành nhiều mảnh để có thể chia sẻ đến kênh đầu ra tốt hơn.</p><h1 id="Heartbeating-nhip-tim-la-gi"><a href="#Heartbeating-nhip-tim-la-gi" class="headerlink" title="Heartbeating (nhịp tim) là gì ?"></a>Heartbeating (nhịp tim) là gì ?</h1><p>Tại một thời điểm sau khi “bắt tay” (handshake), cả client và server có thể lựa chọn để gửi đi một ping đến phía kia. Khi ping được nhận, người nhận phải gửi ngược lại một pong ngay khi có thể. Đó gọi là heartbeat (nhịp tim đập). Bạn có thể dùng nó để đảm bảo client vẫn đang được kết nối.</p><p>Một ping hay pong chỉ là frame bình thường, không phải frame điều khiển. Ping có opcode là 0x9 và opcode của pong là 0xA. Khi bạn nhận được ping, gửi ngược lại pong với chính xác cùng dữ liệu Payload như ping (với ping và pong thì độ dài payload tối đa là 125). Bạn cũng có thể nhận được pong mà chưa từng gửi ping. Nếu nó xảy ra thì bỏ qua, quên nó đi.</p><p>Heartbeat có thể rất có ích. Có nhiều dịch vụ (chẳng hạn như bộ cân bằng tải - load balancer) sẽ hủy những kết nối đứng yên (idle). Thêm nữa, bên nhận không thể biết nếu bên kia (bên gửi) đã bị kết thúc hay chưa. Chỉ có đến lần gửi thông tin tiếp theo ta mới nhận ra có gì đó không ổn.</p><h1 id="Xu-ly-loi"><a href="#Xu-ly-loi" class="headerlink" title="Xử lý lỗi"></a>Xử lý lỗi</h1><p>Bạn có thể xử lý bao nhiêu lỗi xảy ra cũng được bằng cách listen đến sự kiện error.<br>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://websocket.example.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Xử lý lỗi xảy ra.</span></span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'WebSocket Error: '</span> + error);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Dong-ket-noi"><a href="#Dong-ket-noi" class="headerlink" title="Đóng kết nối"></a>Đóng kết nối</h1><p>Để đóng kết nổi thì client hoặc server phải gửi một frame điều khiển với dữ liệu chứa opcode 0x8. Ngay khi nhận được frame đó thì bên nhận sẽ gửi trả một frame đóng (close). Bên gửi sẽ đóng kết nối. Bất kỳ thông tin nào nhận được sau khi đóng kết nối đều bị vứt bỏ.</p><p>Đây là cách bạn khởi tạo quá trình đóng kết nối WebSocket từ client:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Đóng nếu kết nối đang được mở.</span></span><br><span class="line"><span class="keyword">if</span> (socket.readyState === WebSocket.OPEN) &#123;</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Để thực hiện dọn dẹp sau khi đóng kết nối thành công, bạn có thể thêm một event listener vào sự kiện close:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dọn dẹp những thứ cần thiết.</span></span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Disconnected from WebSocket.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Server lắng nghe sự kiện close để xử lý nếu cần:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reasonCode, description</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Kết nối đang bị đóng.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="So-sanh-WebSockets-va-HTTP-2"><a href="#So-sanh-WebSockets-va-HTTP-2" class="headerlink" title="So sánh WebSockets và HTTP/2"></a>So sánh WebSockets và HTTP/2</h1><p>Trong khi HTTP/2 cung cấp nhiều thứ, nó lại không hoàn toàn thay thế sự cần thiết cho các công nghệ push/streaming hiện có.</p><p>Điều quan trọng đầu tiên về HTTP/2 mà ta cần chú ý là nó không phải là một thay thế cho tất cả HTTP. Những động từ, mã status và đa số các loại header sẽ vẫn như cũ. HTTP/2 hướng đến cải thiện sự hiệu quả trong cách mà dữ liệu truyền trên đường dây.</p><p>Giờ nếu so sánh HTTP/2 với WebSocket thì ta có nhiều thứ tương đồng:</p><table><thead><tr><th></th><th>HTTP/2</th><th>WebSocket</th></tr></thead><tbody><tr><td>Headers</td><td>Được nén (HPACK)</td><td>Không nén</td></tr><tr><td>Binary</td><td>Có</td><td>Nhị Phân hoặc Văn Bản</td></tr><tr><td>Multiplexing</td><td>Có</td><td>Có</td></tr><tr><td>Sự ưu tiên</td><td>Có</td><td>Không</td></tr><tr><td>Nén</td><td>Có</td><td>Có</td></tr><tr><td>Đinh hướng</td><td>Client/Server hoặc là Server Push</td><td>2 chiều</td></tr><tr><td>Full-duplex</td><td>Có</td><td>Có</td></tr></tbody></table><p>Như đã thấy ở trên, HTTP/2 giới thiệu tính năng <a href="https://en.wikipedia.org/wiki/Push_technology?oldformat=true" target="_blank" rel="noopener">Server Push</a> để cho phép server gửi tài nguyên một cách chủ động đến bộ đệm phía client. Tuy nhiên, nó không cho phép tự ý push dữ liệu xuống client. Server push chỉ được xử lý bằng browser và không được bật trong code của ứng dụng, nghĩa là không có API cho app để get thông báo từ những sự kiện như thế này.</p><p>Đây là nơi Sự kiện server gửi thông tin (Server-Sent Events - SSE) trở nên rất có ích. SSE là 1 cơ chế cho phép server push dữ liệu bất đồng bộ về client một khi kết nối client-server được thiết lập. Server có thể lựa chọn để gửi dữ liệu khi nào một “cục” dữ liệu mới đã sẵn sàng. Nó có thể được cân nhắc như là mô hình đăng ký-xuất bản (<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" target="_blank" rel="noopener">publish-subscribe</a>) 1 chiều. Nó cũng cung cấp một chuẩn Javascript client API tên là EventSource được triển khai trong đa số các trình duyệt hiện đại như là 1 phần của tiêu chuẩn HTML5 bởi <a href="https://www.w3.org/TR/eventsource/" target="_blank" rel="noopener">W3C</a>. Chú ý rằng trình duyệt không hỗ trợ <a href="http://caniuse.com/#feat=eventsource" target="_blank" rel="noopener">EventSource API</a> cũng có thể dễ dàng polyfill.</p><p>Bởi vì SSE dựa trên HTTP, nó có thể phù hợp với HTTP/2 và có thể kết hợp để đạt được sự tốt nhất của cả 2 bên: HTTP/2 xử lý tầng giao vận (transport layer) hiệu quả dựa trên các luồng multiplex và SSE cung cấp API cho app để thực hiện push.</p><p>Để hiểu hoàn toàn về Stream và Multiplexing, đầu tiên ta cần biết sơ lược về định nghĩa tại IETF: <em>một “stream” là chuỗi tuần tự 2 chiều và độc lập của nhiều frame được trao đổi giữa client và server trong một kết nối HTTP/2. Mộ trong số những đặc tính chính của nó là một kết nối HTTP/2 có thể chứa đồng thời nhiều stream đang mở với frame endpoint xen kẽ từ nhiều stream.</em></p><p><img src="https://cdn-images-1.medium.com/max/1000/1*pSh7IORJoUXbwCjyJ7fM9A.png" alt=""></p><p>Phải nhớ rằng SSE là dựa trên HTTP. Nghĩa là với HTTP/2, không chỉ nhiều stream SSE được xen kẽ trên một kết nối TCP mà cũng cơ chế đó có thể thực hiện với sự kết hợp của nhiều stream SSE (push từ server đến client) và nhiều client request (client đến server). Nhờ ơn HTTP/2 và SSE mà giờ đây chúng ta đã có một kết nối HTTP 2 chiều thuần túy với API đơn giản để code ứng dụng có thể đăng ký cho server push. Thiếu đi khả năng giao tiếp 2 chiều thường được xem như là một bước cải lùi khi so sánh SSE với WebSocket. Cảm ơn HTTP/2, nhờ nó mà điều này không còn là vần đề nữa. Thêm nữa là nó mở ra cơ hội để bỏ qua WebSocket và tập trung vào những công nghệ thay thế dựa trên HTTP.</p><h1 id="Lam-the-nao-de-chon-giua-WebSocket-amp-HTTP-2"><a href="#Lam-the-nao-de-chon-giua-WebSocket-amp-HTTP-2" class="headerlink" title="Làm thế nào để chọn giữa WebSocket &amp; HTTP/2?"></a>Làm thế nào để chọn giữa WebSocket &amp; HTTP/2?</h1><p>WebSocket chắc chắn sẽ tồn tại trong sự thống trị của HTTP/2 + SSE, chủ yếu bởi vì nó là công nghệ đã được đón nhận và trong nhiều trường hợp cụ thể nó có sự vượt trội so với HTTP/2 như cách nó được xây dựng cho khả năng giao tiếp 2 chiều với ít chi phí tốn kém (ví dụ: headers).</p><p>Giả sử bạn muốn xây dựng game MMO (Massive Multiplayer Online: Game nhiều người chơi trực tuyến) cần một lượng khổng lồ message từ cả 2 đầu kết nối. Trong những trường hợp như thế thì WebSocket thể hiện rất rất tốt.</p><p>Tổng quát thì sử dụng WebSocket khi nào bạn cần một kết nối với độ trễ rất thấp, gần như là realtime giữa client &amp; server. Nhớ kỹ rằng việc này có thể yêu cầu bạn cân nhắc lại cách xây dựng ứng dụng server-side của bạn, cũng như chuyển sang tập trung vào những công nghệ như event queue.</p><p>Nếu trường hợp của bạn cần hiển thị tin tức thị trường, dữ liệu thị trường, ứng dụng chat… theo thời gian thực, sử dụng HTTP/2 + SSE sẽ cung cấp cho bạn kênh giao tiếp 2 chiều hiệu quả trong khi gặt hái nhiều lợi ích khi hoạt động trong thế giới của HTTP:</p><ul><li>WebSocket thường gây ra khó khăn khi cân nhắc sự tương thích với hạ tầng web hiện tại cũng như nó nâng cấp kết nối HTTP đến một giao thức hoàn toàn khác mà không có gì dính dáng tới HTTP.</li><li>Mở rộng và bảo mật: những thành phần của web (firewall, phát hiện xâm nhập, cân bằng tải) được xây dựng, bảo trì và thiết đặt với tư tưởng của HTTP, một môi trường cho ứng dụng lớn và nghiêm ngặt sẽ ưu tiên khả năng phục hồi, bảo vật và khả năng mở rộng.</li></ul><p>Bạn cũng cần phải cân nhắc về vấn đề hỗ trợ của trình duyệt:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*YFr59cEF2qxzjjleebvbcQ.png" alt=""></p><p>Khá tốt phải không nào?</p><p>Nhưng với HTTP/2 thì không hẳn:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*C1VWSKOx89vqdiSiflDRJw.png" alt=""></p><ul><li>Chỉ có TLS (Cũng không tệ lắm)</li><li>Hỗ trợ một phần cho IE11 nhưng chỉ trên Windows 10</li><li>Chỉ hỗ trợ OSX 10.11 trở lên trên Safari</li><li>Chỉ hỗ trợ HTTP/2 nếu bạn có thể điều hướng nó qua APLN (server của bạn cũng cần phải hỗ trợ nó rõ ràng)</li></ul><p>Hỗ trợ SSE thì tốt hơn một chút:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*9ryMUEZhtbTg7lECHVz0fw.png" alt=""></p><p>Chỉ có IE/Edge là không hỗ trợ (Opera Mini cũng thế). Vẫn có những polyfill khá tốt để giúp chúng ta làm viêc với SSE trên IE/Edge.</p><h1 id="SessionStack-lua-chon-nhu-the-nao"><a href="#SessionStack-lua-chon-nhu-the-nao" class="headerlink" title="SessionStack lựa chọn như thế nào?"></a>SessionStack lựa chọn như thế nào?</h1><p>Team SessionStack sử dụng cả 2 WebSocket và HTTP, tùy thuộc vào từng trường hợp. Một khi bạn đã tích hợp SessionStack vào web app của bạn, nó sẽ ghi lại mọi thứ diễn ra trên app/website: những thay đổi trên DOM, tương tác của người dùng, JS exception, stack trace, những request bị fail và cả thông báo debug, cho phép bạn chạy lại (replay) những issue đã xảy ra dưới dạng video và xem chúng diễn ra như thế nào với người dùng. Tất cả đều hoạt động theo thời gian thực (real-time) và không ảnh hưởng đến hiệu năng của webapp.</p><p>Điều đó nghĩa là bạn có thể tham gia vào một phiên làm việc của user, trong khi user đang hoạt động trên trình duyệt. Trong trường hợp này, team tác giả chọn sử dụng HTTP bởi vì không cần giao tiếp 2 chiều (server chỉ cần stream dữ liệu đến trình duyệt). Nếu dùng WebSocket ở đây thì sẽ rất tệ, càng khó để bảo trì và mở rộng.</p><p>Tuy nhiên, thư viện SessionStack tích hợp vào trong webapp của bạn sử dụng WebSocket (nếu có thể, còn không thì HTTP). Nó sắp xếp và gửi dữ liệu về server và cũng là giao tiếp 1 chiều. Team tác giả chọn WebSocket vì trong trường hợp này vài tính năng cần thiết sử dụng giao tiếp 2 chiều.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 5 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Trong phần này chúng ta sẽ đào sâu với thế giới của những giao thức giao tiếp, ánh xạ (mapping) và thảo luận về những thuộc tính cũng như thành phần của chúng. Chúng ta sẽ đưa ra 1 so sánh nhỏ giữa WebSockets và HTTP/s. Cuối cùng, team SessionStack sẽ chia sẻ một vài ý tưởng về việc lựa chọn phương thức nào cho phù hợp với giao thức mạng.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P4: Event loop, lập trình bất đồng bộ &amp; 5 mẹo cải thiện Async/Await</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P4-Event-loop-lap-trinh-bat-dong-bo-5-meo-cai-thien-Async-Await.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P4-Event-loop-lap-trinh-bat-dong-bo-5-meo-cai-thien-Async-Await.html</id>
    <published>2018-11-13T16:34:00.000Z</published>
    <updated>2018-11-13T16:39:26.827Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 4 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Lần này chúng ta sẽ mở rộng những gì có trong bài đầu tiên bằng cách đánh giá những nhược điểm của môi trường đơn luồng (single thread) và làm thế nào để vượt qua chúng nhằm xây dựng những Javascript UI ấn tượng. Và vẫn như cũ, cuối bài viết tác giả sẽ chia sẻ 5 mẹo nhỏ để viết code tốt hơn với async/await.<br><a id="more"></a></p><h1 id="Tai-sao-don-luong-lai-la-gioi-han"><a href="#Tai-sao-don-luong-lai-la-gioi-han" class="headerlink" title="Tại sao đơn luồng lại là giới hạn."></a>Tại sao đơn luồng lại là giới hạn.</h1><p>Trong bài đầu tiên của series, chúng ta suy ngẫm về câu hỏi điều gì xảy ra khi chúng ta có 1 hàm trong callstack và hàm đó lại ngốn quá nhiều thời gian để thực thi.</p><p>Hãy tưởng tượng, ta thực hiện một thuật toán chuyển đổi hình ảnh phức tạp chạy trên browser.</p><p>Trong khi callstack đang thực thi các hàm, trình duyệt lại không thể làm gì cả, nó bị kẹt. Nghĩa là trình duyệt không thể vẽ, render, nó không thể chạy code khác, chỉ đơn giản là kẹt. Và vấn đề là ở đây, giao diện (UI) của app bạn sẽ hoạt động không hiệu quả.</p><p>App của bạn bị kẹt.</p><p>Trong một vài trường hợp thì đây không phải vấn đề nghiêm trọng. Tuy nhiên, có vấn đề còn lớn hơn nữa. Một khi trình duyệt của bạn xử lý quá nhiều thứ trong callstack, nó sẽ bị “đỡ” trong 1 khoảng thời gian dài. Tại thời điểm đó, đa số các browser sẽ chọn giải pháp hiện lỗi, hỏi người dùng có muốn hủy trang hiện tại không.</p><p>Điều này thật là xấu xí và ảnh hưởng nghiêm trọng đến trải nghiệm (UX):</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*MCt4ZC0dMVhJsgo1u6lpYw.jpeg" alt=""></p><h1 id="Nhung-thanh-phan-xay-dung-nen-1-chuong-trinh-JS"><a href="#Nhung-thanh-phan-xay-dung-nen-1-chuong-trinh-JS" class="headerlink" title="Những thành phần xây dựng nên 1 chương trình JS"></a>Những thành phần xây dựng nên 1 chương trình JS</h1><p>Bạn có thể viết toàn bộ code JS trong 1 file .js duy nhất nhưng chương trình của bạn chắc chắn chứa nhiều thành phần nhỏ (gọi là những block), chỉ có một số block sẽ được <strong>thực thi ngay</strong> (gọi là nhóm A) và phần còn lại thì <strong>chạy sau</strong> (nhóm B). Đơn vị block phổ biến nhất là function (hàm).</p><p>Vấn đề mà đa số các developer JS mới gặp phải là họ nghĩ rằng nhóm B không cần phải được thực thi một cách nghiêm ngặt ngay sau khi thực thi nhóm A. Nói cách khác, những nhiệm vụ không được hoàn thành ngay bây giờ thì theo lỹ thuyết nó sẽ được hoàn thành một cách bất đồng bộ, nghĩa là bạn sẽ không phải gặp tình huống blocking (bị chặn) như đề cập ở trên</p><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Giả sử ajax(..) là một hàm Ajax thuộc thư viện nào đó</span></span><br><span class="line"><span class="keyword">var</span> response = ajax(<span class="string">'https://example.com/api'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(response);</span><br><span class="line"><span class="comment">// `response` sẽ không chứa dữ liệu trả về</span></span><br></pre></td></tr></table></figure><p>Chắc bạn cũng nhận thấy rằng những request Ajax như thế này không chạy đồng bộ với nhau, nghĩa là tại thời điểm code thực thi, hàm ajax(…) chưa có dữ liệu trả về để gán vào biến response</p><p>Một cách đơn giản cho thường gặp để “chờ” một hàm xử lý bất đồng bộ trả kết quả về đó là sử dụng callback:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'https://example.com/api'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response); <span class="comment">// "response" giờ đã có dữ liệu</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Chú ý: Bạn có thể viết những Ajax request đồng bộ, tuy nhiên đừng bao giờ làm thế. Nếu bạn viết Ajax như vậy thì UI sẽ bị block cứng đơ và người dùng sẽ không thể thực hiện các hành động như click, nhập dữ liệu, điều hướng, lăn chuột… Một trải nghiệm kinh khủng.</p><p>Đây là cách mà Ajax được viết đồng bộ, nhưng làm ơn, đừng bao giờ sử dụng nó trong app của bạn:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Giả sử bạn đang dùng jQuery</span></span><br><span class="line">jQuery.ajax(&#123;</span><br><span class="line">    url: <span class="string">'https://api.example.com/endpoint'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// callback ở đây.</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span>: <span class="literal">false</span> <span class="comment">// Một ý tưởng cực kỳ tồi tệ</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Chúng ta đã sử dụng Ajax request để ví dụ. Ngoài ra bạn có thể dùng bất kỳ đoạn code nào để thực hiện bất đồng bộ.</p><p>Dưới đây là ví dụ khác với hàm setTimeout(callback, milliseconds). Cách thức mà hàm setTimeout hoạt động là nó sẽ đặt 1 sự kiện (ở đây là sự kiện timeout) và để nó thực hiện sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'first'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'second'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">third</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'third'</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line">setTimeout(second, <span class="number">1000</span>); <span class="comment">// gọi hàm `second` sau 1000ms</span></span><br><span class="line">third();</span><br></pre></td></tr></table></figure><p>Và đây là kết quả của đoạn code trên:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">third</span><br><span class="line">second</span><br></pre></td></tr></table></figure><h1 id="Mo-xe-Event-Loop-vong-lap-su-kien"><a href="#Mo-xe-Event-Loop-vong-lap-su-kien" class="headerlink" title="Mổ xẻ Event Loop (vòng lặp sự kiện)"></a>Mổ xẻ Event Loop (vòng lặp sự kiện)</h1><p>Chúng ta sẽ bắt đầu với một chút “kỳ quặc” - mặc dù JS chấp nhận code chạy bất đồng bộ (như trường hợp của setTimeout) thì cho đến khi giới thiệu ES6, JS cũng không thực sự có một khái niệm trực tiếp nào về bất đồng bộ. Bộ engine JS chưa bao giờ làm gì vượt ra khỏi việc thực thi <strong>một</strong> khối lệnh trong chương trình của bạn tại 1 thời điểm cố định.</p><p>Bạn có thể xem chi tiết hơn về cách engine JS (cụ thể là Google V8) hoạt động như thế nào ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-2---Ben-trong-engine-V8---5-meo-de-toi-uu-hoa-code" target="_blank" rel="noopener">bài viết trước</a>.</p><p>Vậy thì ai là người ra lệnh cho engine JS phải thực thi những khối lệnh trong chương trình? Trên thực tế, engine JS không chạy cô lập, nó hoạt động bên trong một môi trường chủ (hosting environment), môi trường này đối với đa số các developer chính là trình duyệt web hoặc Node.js. Thực ra, ngày nay, JS đã và đang được nhúng vào rất nhiều loại thiết bị khác nhau, từ robot cho tới bóng đèn. Mỗi một thiết bị có thể xem như là 1 loại khác nhau của môi trường chủ cho engine JS.</p><p>Mẫu số chung của tất cả các môi trường đó là một cơ chế tích hợp sẵn được gọi là <strong>event-loop</strong> (vòng lặp sự kiện), nó xử lý quá trình thực thi của nhiều khối lệnh trong chương trình theo thời gian, mỗi lần đều gọi engine JS.</p><p>Điều này nghĩa là engine JS chỉ là 1 môi trường thực thi theo yêu cầu cho bất kỳ đoạn code JS tùy ý nào. Nó chỉ là môi trường bao quanh có lịch trình cho các sự kiện (quá trình thực thi code JS).</p><p>Ví dụ, khi code JS của bạn gọi Ajax request để lấy dữ liệu từ server, bạn cài đặt một đoạn code <em>response</em> trong một hàm (gọi là callback), và engine JS sẽ truyền đạt lại với môi trường chủ: <em>Này, tao chuẩn bị tạm ngưng quá trình thực thi ngay bây giờ, nhưng mà khi nào mày xong việc với request đó và có một vài cục dữ liệu thì nhớ gọi lại hàm này nhé.</em></p><p>Trình duyệt sau đó sẽ lắng nghe về response từ mạng, và khi nó có gì đó trả về cho bạn, nó sẽ lên lịch cho hàm callback được thực thi bằng cách chèn nó vào trong event loop</p><p>Cùng xem sơ đồ này nào:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*FA9NGxNB6-v1oI2qGEtlRQ.png" alt=""></p><p>Bạn có thể xem lại phần bài viết về Memory Heap &amp; Call Stack trong <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-1---Khai-quat-ve-engine--runtime-va-callstack" target="_blank" rel="noopener">bài viết trước đây</a></p><p>Vậy thì những Web APIs này là gì? Về bản chất, chúng là những tiến trình mà bạn không thể truy xuất (access), bạn chỉ có thể gọi nó. Chúng là những thành phần của trình duyệt mà trong đó cách xử lý đồng bộ được bắt đầu. Nếu bạn là một Node.js developer thì chúng là những C++ APIs.</p><p><strong>Vậy cuối cùng thì event loop là cái éo gì ?</strong></p><p><img src="https://cdn-images-1.medium.com/max/1000/1*KGBiAxjeD9JT2j6KDo0zUg.png" alt=""></p><p><strong>Event Loop</strong> có một công việc đơn giản: theo dõi Call Stack và Callback Queue (hàng đợi các hàm callback). Nếu Call Stack đang trống, nó sẽ lấy event đầu tiên từ trong hàng đợi ra và đẩy nó vảo trong Call Stack - tức là thực thi nó.</p><p>Mỗi vòng lặp như thế được gọi là 1 <strong>tick</strong> trong Event Loop. Mỗi sự kiện chỉ là 1 hàm callback.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb1</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'cb1'</span>);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Bye'</span>);</span><br></pre></td></tr></table></figure><p>Cùng <em>thực thi</em> đoạn code trên và xem điều gì xảy ra nào:</p><ol><li>Trạng thái đang trống, console của trình duyệt đang trống, Call Stack đang trống. <img src="https://cdn-images-1.medium.com/max/1000/1*9fbOuFXJHwhqa6ToCc_v2A.png" alt=""></li><li>console.log(‘Hi’) được thêm vào Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*dvrghQCVQIZOfNC27Jrtlw.png" alt=""></li><li>console.log(‘Hi’) được thực thi. <img src="https://cdn-images-1.medium.com/max/1000/1*yn9Y4PXNP8XTz6mtCAzDZQ.png" alt=""></li><li>console.log(‘Hi’) bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*iBedryNbqtixYTKviPC1tA.png" alt=""></li><li>setTimeout(function cb1() { … }) được thêm vào Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*HIn-BxIP38X6mF_65snMKg.png" alt=""></li><li>setTimeout(function cb1() { … }) được thực thi. Trình duyệt tạo một timer - vốn là một phần của Web APIs. Nó sẽ thực hiện phần đếm ngược cho bạn. <img src="https://cdn-images-1.medium.com/max/1000/1*vd3X2O_qRfqaEpW4AfZM4w.png" alt=""></li><li>The setTimeout(function cb1() { … }) được thực hiện xong và bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*_nYLhoZPKD_HPhpJtQeErA.png" alt=""></li><li>console.log(‘Bye’) được thêm vào Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*1NAeDnEv6DWFewX_C-L8mg.png" alt=""></li><li>console.log(‘Bye’) được thực thi. <img src="https://cdn-images-1.medium.com/max/1000/1*UwtM7DmK1BmlBOUUYEopGQ.png" alt=""></li><li>console.log(‘Bye’) bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*-vHNuJsJVXvqq5dLHPt7cQ.png" alt=""></li><li>Sau ít nhất 5000ms, timer hoàn thành công việc của nó và đẩy cb1 callback vào trong Callback Queue. <img src="https://cdn-images-1.medium.com/max/1000/1*eOj6NVwGI2N78onh6CuCbA.png" alt=""></li><li>Event Loop lấy cb1 từ trong Callback Queue và đưa nó vào trong Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*jQMQ9BEKPycs2wFC233aNg.png" alt=""></li><li>cb1 được thực thi và nó thêm console.log(‘cb1’) vào trong Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*hpyVeL1zsaeHaqS7mU4Qfw.png" alt=""></li><li>console.log(‘cb1’) được thực thi. <img src="https://cdn-images-1.medium.com/max/1000/1*lvOtCg75ObmUTOxIS6anEQ.png" alt=""></li><li>console.log(‘cb1’) bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*Jyyot22aRkKMF3LN1bgE-w.png" alt=""></li><li>cb1 bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*t2Btfb_tBbBxTvyVgKX0Qg.png" alt=""></li></ol><p>Ảnh gif tổng hợp lại quá trình 16 bước ở trên:<br><img src="https://cdn-images-1.medium.com/max/1000/1*TozSrkk92l8ho6d8JxqF_w.gif" alt=""></p><p>Thật thú vị khi biết rằng ES6 có mô tả event loop hoạt động như thế nào, nghĩa là về mặt kỹ thuật, nó nằm trong phạm vi trách nghiệm của một JS engine, tức là không còn chỉ đóng vai trò môi trường chủ. Một lý do chính đáng cho sự thay đổi này chính là việc giới thiệu Promise trong ES6 bởi vì promise mới cần truy xuất trực tiếp, kiểm soát tối đa lịch trình điều hành đối với event loop queue (Sau này chúng ta sẽ thảo luận chi tiết hơn)</p><h1 id="setTimeout-…-hoat-dong-nhu-the-nao"><a href="#setTimeout-…-hoat-dong-nhu-the-nao" class="headerlink" title="setTimeout(…) hoạt động như thế nào?"></a>setTimeout(…) hoạt động như thế nào?</h1><p>Điều quan trọng cần phải biết là setTimeout(…) không tự động đặt callback vào trong event loop queue. Nó thiết lập một bộ đếm. Khi bộ đếm kết thúc, môi trường đặt callback vào trong event loop, vì thế những <strong>tick</strong> tiếp theo có thể lấy nó ra và thực thi:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(myCallback, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>Nó không có nghĩa là myCallback sẽ được thực thi sau 1000ms, mà đúng hơn là, trong 1000ms, myCallback sẽ được thêm vào trong queue. Tuy nhiên queue này có thể đang có event khác đã được thêm vào trước đó, và vì thế callback của bạn sẽ phải chờ.</p><p>Có một vài bài biết hoặc bài hướng dẫn dành cho người mới bắt đầu với bất đồng bộ trong JS hướng dẫn rằng ta nên setTimeout(callback, 0). Bây giờ bạn đã biết cách event loop làm việc và cách setTimeout hoạt động rồi: gọi setTimeout với thời gian là <strong>0</strong> chỉ vì mục đích hoãn callback lại cho tới khi Call Stack rỗng hoàn toàn.</p><p>Hãy xem ví dụ dưới đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callback'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Bye'</span>);</span><br></pre></td></tr></table></figure><p>Mặc dù thời gian chờ của callback là <em>0ms</em> nhưng kết quả in ra lại như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hi</span><br><span class="line">Bye</span><br><span class="line">callback</span><br></pre></td></tr></table></figure><h1 id="Jobs-cong-viec-trong-ES6-la-gi"><a href="#Jobs-cong-viec-trong-ES6-la-gi" class="headerlink" title="Jobs (công việc) trong ES6 là gì?"></a>Jobs (công việc) trong ES6 là gì?</h1><p>Một khái niệm mới gọi là <strong>Job Queue</strong> (Hàng đợi công việc) được giới thiệu trong ES6. Nó là lớp trên cùng của event loop queue. Nhiều khả năng bạn sẽ gặp phải nó khi xử lý vấn đề liên quan đến bất đồng bộ của Promise (Chúng ta sẽ nói về nó sau).</p><p>Bây giờ thì chúng ta chỉ tìm hiểu về mặt ý tưởng cơ bản để sau này khi thảo luận về bất đồng bộ với Promise, bạn có thể hiểu về những hành động đã được lên lịch và xử lý.</p><p>Tưởng tượng nó như thế này: Job queue là 1 queue được gắn vào cuối mỗi tick trong event loop queue. Mỗi hành động bất đồng bộ nhất định khi xảy ra trong 1 tick sẽ không làm cho toàn bộ event được thêm vào event loop queue nhưng thay vì thế sẽ thêm 1 item (tức là job) vào cuối job queue của tick hiện tại.</p><p>Điều này nghĩa là bạn có thể thêm những tính năng khác để có thể thực thi sau và bạn có thể chắc chắn rằng nó sẽ được thực thi ngay sau đó, trước bất kỳ đoạn code nào khác.</p><p>Một job có thể thêm nhiều job khác vào đoạn cuối của cùng 1 queue. Trên lý thuyết, job có thể lặp (loop) vô thời hạn (một job thực hiện thêm nhiều job khác, v..v…), do đó nó sẽ làm cho chương trình bị quá tải tài nguyên cần thiết để tiếp tục chạy. Về mặt khái niệm thì điều này tương tự như một công việc có thời gian thực thi dài hoặc là một vòng lặp vô hạn (ví dụ: while(true)).</p><p>Job cũng giống như trick setTimeout(callback, 0) (set thời gian bằng _0_) nhưng được triển khai theo cách có vẻ như “chính thống” hơn và có sự đảm bảo về thứ tự: thực hiện sau, nhưng phải làm ngay khi có thể.</p><h1 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h1><p>Như bạn đã biết, callback là cách phổ biến nhất để thể hiện &amp; quản lý sự bất đồng bộ trong JS. Rõ ràng, callback là mô hình bất đồng bộ cơ bản nhất trong JS. Vô số chương trình JS, kể cả những app tinh vi và phức tạp nhất thì cũng phải dùng tới callback.</p><p>Ngoại trừ việc callback không xuất hiện mà không có thiếu sót. Nhiều developer đang cố gắng tìm kiếm những mô hình bất đồng bộ tốt hơn. Tuy nhiên, chúng ta không thể sử dụng bất kỳ phương pháp thay thế nào khác nếu như bạn chưa thực sự hiểu rõ về callback.</p><p>Ở chương tiếp theo, chúng ta sẽ khám phá sâu hơn về vấn đề này để tìm hiểu tại sao những mô hình bất đồng bộ tinh vi khác (sẽ nói ở những bài sau) là cần thiết và được đề nghị nên sử dụng.</p><h1 id="Callback-long-nhau-nested-callback"><a href="#Callback-long-nhau-nested-callback" class="headerlink" title="Callback lồng nhau (nested callback)"></a>Callback lồng nhau (nested callback)</h1><p>Xem đoạn code dưới đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">listen(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ajax(<span class="string">'https://api.example.com/endpoint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">text</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (text == <span class="string">"hello"</span>) &#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">"world"</span>) &#123;</span><br><span class="line">            doSomethingElse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Chúng ta có 3 hàm lồng nhau, mỗi hàm thể hiện 1 bước trong chuỗi bất đồng bộ.</p><p>Kiểu code như thế này thường được gọi là <strong>callback hell</strong>. Nhưng <em>callback hell</em> thực sự không phải vấn đề về lồng nhau hay cách dòng, thụt lề. Câu chuyện thực sự sâu xa hơn thế nhiều.</p><p>Đầu tiên, chúng ta listen một event <em>click</em>, sau đó thì chờ timer hoạt động, rồi cuối cùng là chờ cho Ajax trả kết quả về và quá trình này có thể lặp lại nhiều lần mỗi khi chúng ta click.</p><p>Thoạt nhìn đoạn code này thể hiện sự đồng bộ một cách tự nhiên theo thứ tự các bước như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>…rồi sau đó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>…tiếp theo là:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'https://api.example.com/endpoint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>…và cuối cùng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (text == <span class="string">"hello"</span>) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">"world"</span>) &#123;</span><br><span class="line">    doSomethingElse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chà, đúng là một cách thể hiện code bất đồng bộ một cách rất tự nhiên, phải không nào? <em>cười</em></p><h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>Cùng xem đoạn code sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x + y);</span><br></pre></td></tr></table></figure><p>Rất rõ ràng rằng nó tính tổng của x và y rồi in kết quả ra console. Tuy nhiên, nếu như giá trị của x và y chưa tồn tại và vẫn còn đang chờ để được xác định thì sao? Giả sử chúng ta cần lấy giá trị của x và y từ server trước khi chúng được dùng để tính tổng.<br>Tưởng tượng rằng chúng ta có một hàm loadX và loadY để thực hiện load dữ liệu cho x và y từ server và một hàm để tính tổng 2 số sau khi chúng được load xong.<br>Đoạn code sẽ giống như thế này (xấu xí và phức tạp, phải không nào?):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">getX, getY, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x, y;</span><br><span class="line">    getX(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        x = result;</span><br><span class="line">        <span class="keyword">if</span> (y !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            callback(x + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    getY(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        y = result;</span><br><span class="line">        <span class="keyword">if</span> (x !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            callback(x + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Một hàm đồng bộ hoặc bất đồng bộ để get giá trị của "x"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Một hàm đồng bộ hoặc bất đồng bộ để get giá trị của "y"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchY</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line">sum(fetchX, fetchY, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Có một điều quan trọng cần phải nêu lên ở đây: trong đoạn code trên, chúng ta xem x và y như những giá trị tương lai và hàm sum() không quan tâm về việc x hay y hay cả 2 biến có hay không có tồn tại giá trị.</p><p>Dĩ nhiên là cách tiếp cận thô dựa trên callback này cho ta nhiều thứ đáng mong đợi. Đây chỉ là 1 bước tiến nhỏ để hiểu về ích lợi của <em>giá trị tương lai</em> mà không cần lo lắng về khía cạnh thời gian khi chúng sẵn có.</p><h1 id="Gia-tri-cua-Promise"><a href="#Gia-tri-cua-Promise" class="headerlink" title="Giá trị của Promise"></a>Giá trị của Promise</h1><p>Cùng xem ví dụ về x + y được thực hiện với Promise:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">xPromise, yPromise</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `Promise.all([ .. ])` nhận vào 1 mảng các promise,</span></span><br><span class="line">    <span class="comment">// và trả về 1 promise chờ đợi tất cả chúng hoàn thành</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([xPromise, yPromise])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// khi một promise được phân giải (resolve),</span></span><br><span class="line">    <span class="comment">// ta lấy giá trị x, y trả về và cộng chúng lại.</span></span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">values</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// `values` là mảng chứa giá trị của các object</span></span><br><span class="line">        <span class="comment">// từ những promise đã được resolve</span></span><br><span class="line">        <span class="keyword">return</span> values[<span class="number">0</span>] + values[<span class="number">1</span>];</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `fetchX()` và `fetchY()` trả về promise </span></span><br><span class="line"><span class="comment">// chứa kết quả tương ứng, có thể có </span></span><br><span class="line"><span class="comment">// luôn hoặc chờ sau mới có dữ liệu</span></span><br><span class="line">sum(fetchX(), fetchY())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ta có 1 promise cho tổng của 2 số.</span></span><br><span class="line"><span class="comment">// Giờ thì gọi mắt xích (chain-call) hàm `.then(...)` để chờ </span></span><br><span class="line"><span class="comment">// kết quả của promise trả về.</span></span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Có 2 lớp Promise trong đoạn code này.</p><p>fetchX() và fetchY() được gọi trực tiếp và giá trị trả về của chúng (<strong>promise!</strong>) được đẩy vào hàm sum(…). Giá trị mà những promise này thể hiện có thể sẵn sàng để dùng ngay lúc gọi hàm hoặc là sau đó 1 chút nhưng bất kể sớm hay muộn thì mỗi promise đều chuẩn hóa hành vi của nó cho giống nhau. Chúng ta suy đoán về giá trị của x và y theo hướng độc lập thời gian. Theo chu kỳ, chúng là những <em>giá trị tương lai</em>.</p><p>Lớp thứ 2 là promise do hàm sum(…) tạo ra (thông qua Promise.all([ … ])) và trả về, và cũng chờ nó get giá trị khi gọi .then(…). Khi hàm sum(…) hoàn tất, tổng <em>giá trị tương lai</em> đã sẵn sàng và có thể in nó ra. Chúng ta ẩn phần logic chờ <em>giá trị tương lai</em> của x và y trong hàm `sum(…).</p><p><strong>Lưu ý</strong>: <em>Bên trong sum(…), lời gọi đến Promise.all([ … ]) tạo một promise (cái này sẽ gọi đến xPromise và yPromise rồi phân giải chúng). Chain-call đến .then() sẽ tạo ra 1 promise khác và promise này sẽ trả về values[0] + values[1] ngay khi resolve (với giá trị kết quả của phép cộng). Do đó lời gọi .then(…) ta đặt ở cuối hàm .sum(…), tức là cuối đoạn code, thực ra là xử lý trên giá trị trả về của promise thứ 2 hơn là promise thứ nhất được tạo ra bởi Promise.all([ … ]). Mặc dù vậy thì chúng ta không chain-call vào cuối hàm .then(…) sau vì làm vậy sẽ tạo thêm 1 promise và ta lại phải xử lý nó. Phần Promise chain-call này sẽ được giải thích kỹ hơn ở các phần sau trong chương này.</em></p><p>Với Promise, lời gọi .then(…) có thể nhận 2 hàm param, hàm thứ nhất là để thực hiện thao tác với response hoàn thành (như trên), hàm thứ 2 là với trường hợp bị lỗi và bác bỏ (rejection).</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sum(fetchX(), fetchY())</span><br><span class="line">.then(</span><br><span class="line">    <span class="comment">// Hàm xử lý hoàn thành</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( sum );</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Hàm xử lý bác bỏ</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error( err ); <span class="comment">// bummer!</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Nếu có gì đó không đúng trong quá trình get x và y hoặc là có sai sót khác thì promise mà .sum(…) trả về sẽ bị reject, hàm callback thứ 2 xử lý lỗi đã được đẩy vào .then(…) sẽ nhận giá trị reject từ promise.</p><p>Bởi vì promise đóng gói trạng thái độc lập thời gian từ bên ngoài - chờ cho giá trị được xử lý hoàn thành/reject, và bản thân promise đã là độc lập thời gian, do đó nhiều promise có thể được kết hợp với nhau theo những cách có thể đoán trước được bất kể là thời gian hay kết quả.</p><p>Hơn nữa, một khi promise được resolve thì nó sẽ tồn tại vĩnh viễn: nó trở thành một giá trị <strong>bất biến</strong> tại thời điểm đó, và có thể được lấy ra sử dụng bao nhiêu lần cũng được</p><p>Thực sự là rất hữu ích khi ta nối promise thanhf 1 chuỗi:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        setTimeout(resolve, time);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"after 1000ms"</span>);</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"after another 2000ms"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"step 4 (next Job)"</span>);</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">5000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>Gọi hàm delay(2000) sẽ tạo ra 1 promise mà nó được hoàn thành trong 2000ms, sau đó trả nó về từ hàm hoàn thành trong .then() đầu tiên, điều này làm cho hàm .then(…) thứ hai sẽ chờ 2000ms</p><p><strong>Lưu ý</strong>: <em>Bởi vì giá promise là bất biến sau khi đã được resolve, chúng ta có thể truyền nó đi khắp nơi mà không cần lo lắng về việc nó bất ngờ bị thay đổi. Điều này đặc biệt có ích khi có nhiều đoạn code cùng sử dụng kết quả của 1 promise. Tính bất biến nghe có vẻ như là một chủ đề liên quan đến học thuật, nhưng thật ra nó là 1 phần rất cơ bản và có khía cạnh quan trọng trong thiết kế promise mà ta không nên bỏ qua.</em></p><h1 id="Promise-hay-khong-Promise"><a href="#Promise-hay-khong-Promise" class="headerlink" title="Promise hay không Promise ?"></a>Promise hay không Promise ?</h1><p>Một chi tiết quan trọng về promise là phải biết một giá trị thực sự là promise hay không phải. Nói cách khác, đó có phải là 1 giá trị sẽ hành xử như 1 promise?</p><p>Chúng ta biết rằng promise được xây dựng bằng lệnh new Promise(…), và bạn cho rằng p instanceof Promise là đủ để kiểm tra? Thực ra thì không hẳn.</p><p>Chủ yếu bởi vì bạn có thể nhận giá trị promise từ một cửa sổ trình duyệt khác (ví dụ: iframe), nó sẽ có promise riêng của nó, khác với promise trong cửa sổ/frame hiện tại của bạn, và câu lệnh check ở trên sẽ fail khi xác định instance của promise.</p><p>Hơn nữa, một thư viện hay framework có thể sử dụng promise của riêng nó mà không dùng promise mặc định của ES6. Thật ra, bạn có thể dùng promise của thư viện trên những trình duyệt cũ không hỗ trợ promise.</p><h1 id="Nuot-chung-ngoai-le-exception"><a href="#Nuot-chung-ngoai-le-exception" class="headerlink" title="Nuốt chửng ngoại lệ (exception)"></a>Nuốt chửng ngoại lệ (exception)</h1><p>Nếu trong quá trình tạo promise hoặc là khi tiếp nhận kết quả từ nó, một lỗi biệt lệ JS xảy ra, ví dụ như TypeError hoặc ReferenceError, exception sẽ được bắt, khi đó nó sẽ ép (force) cho promise đang chạy bị reject.</p><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    foo.bar();    <span class="comment">// `foo` chưa được định nghĩa, lỗi!</span></span><br><span class="line">    resolve(<span class="number">374</span>); <span class="comment">// Code sẽ không đến được đây :(</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// không đến đây luôn :(</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// `err` sẽ là một object của exception`TypeError`</span></span><br><span class="line">    <span class="comment">// từ dòng `foo.bar()`.</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Nhưng nếu như một promise được hoàn thành nhưng có lỗi exception JS trong quá trình tiếp nhận (ví dụ như trong callback của .then(…) )? Kể cả như thế thì nó cũng không bị mất, bạn sẽ thấy một chút ngạc nhiên khi biết cách mà chúng được xử lý. Đào sâu thêm 1 tí nào:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">374</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    foo.bar();</span><br><span class="line">    <span class="built_in">console</span>.log(message);   <span class="comment">// không đến được đây nè.</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// không đến được đây nè.</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Có vẻ như exception từ foo.bar() thực sự đã bị nuốt trôi (swallow). Đúng là như thế. Có gì đó sâu hơn bên trong đã hoạt động sai tuy nhiên chúng ta lại không biết. Lời gọi p.then(…) cho chính nó trả về 1 promise khác và nó sẽ bị reject với ReferenceError exception.</p><h1 id="Xu-ly-nhung-biet-le-khong-bi-bat-Uncaught-exception"><a href="#Xu-ly-nhung-biet-le-khong-bi-bat-Uncaught-exception" class="headerlink" title="Xử lý những biệt lệ không bị bắt (Uncaught exception)"></a>Xử lý những biệt lệ không bị bắt (Uncaught exception)</h1><p>Có nhiều cách tiếp cận khác mà nhiều người cho rằng sẽ tốt hơn.</p><p>Một đề nghị phổ biến đó là promise nên có thêm một phương thức done(…), nó sẽ đánh dấu chuỗi promise là đã xong (done). .done(…)không tạo ra và trả về một promise vì thế callback truyền qua .done(…) rõ ràng là không liên quan đến việc báo cáo các vấn đề xảy ra với một chuỗi promise không tồn tại.</p><p>Nó hoạt động giống như bạn đã biết trong các điều kiện uncaught error: các exception bên trong một hàm reject trong .done(…) sẽ bị bắn ra ngoài developer console dưới dạng global uncaught error.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">374</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// Số number không có hàm của string,</span></span><br><span class="line">    <span class="comment">// nên sẽ bắn ra lỗi</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg.toLowerCase());</span><br><span class="line">&#125;)</span><br><span class="line">.done(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Nếu có uncaught exception ở đây thì nó sẽ bị bắn ra như là một global exception</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Dieu-gi-xay-ra-trong-ES8-va-Async-await"><a href="#Dieu-gi-xay-ra-trong-ES8-va-Async-await" class="headerlink" title="Điều gì xảy ra trong ES8 và Async/await"></a>Điều gì xảy ra trong ES8 và Async/await</h1><p>Javascript ES8 giới thiệu async/await để giúp cho công việc xử lý promise dễ dàng hơn. Chúng ta sẽ lướt sơ qua những khả năng mà async/await cung cấp và xem thử làm thế nào để dùng chúng để viết code bất đồng bộ một cách phù hợp.</p><p>Vậy thì đầu tiên là xem thử hoạt động của async/await.</p><p>Bạn định nghĩa một hàm bất đồng bộ sử dụng định nghĩa hàm async. Những hàm như vậy sẽ trả về object <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank" rel="noopener">AsyncFunction</a>. Object AsyncFunction biểu diễn hàm bất đồng bộ trong đó nó thực thi code bên trong nó.</p><p>Khi một hàm async được gọi, nó sẽ trả về Promise. Khi hàm async trả về giá trị, nó lại không phải promise, một promise sẽ được tạo ra tự động và được phân giải (resolve) với giá trị trả về từ hàm. Khi hàm async bắn ra exception, promise sẽ reject với giá trị bắn ra.</p><p>Một hàm async có thể chứa thể hiện await, nó sẽ dừng quá trình thực thi của hàm và đợi cho promise giải quyết xong rồi quay lại thực thi tiếp và trả về giá trị đã được resolve.</p><p>Bạn có thể xem như promise trong JS tương tự với Java Future hay C# Task.</p><blockquote><p>Mục đích của async/await là làm đơn giản hóa quá trình sử dụng promise.</p></blockquote><p>Xem ví dụ sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hàm JS bình thường</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'374'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Giống như hàm trên</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getNumber2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">374</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tương tự, những hàm bắn ra exception tương tự với những hàm trả về promise bị reject:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'Some error'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'Some error'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Từ khóa await chỉ có thể được dùng bên trong hàm async và cho phép bạn chờ promise một cách đồng bộ. Nếu chúng ta sử dụng promise bên ngoài một hàm async thì phải dùng tới callback:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `rp` là một hàm gọi promise.</span></span><br><span class="line">    <span class="keyword">var</span> promise1 = rp(<span class="string">'https://api.example.com/endpoint1'</span>);</span><br><span class="line">    <span class="keyword">var</span> promise2 = rp(<span class="string">'https://api.example.com/endpoint2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hiện tại cả 2 request đều được gọi đồng thời và</span></span><br><span class="line">    <span class="comment">// ta phải đợi cho nó hoàn thành.</span></span><br><span class="line">    <span class="keyword">var</span> response1 = <span class="keyword">await</span> promise1;</span><br><span class="line">    <span class="keyword">var</span> response2 = <span class="keyword">await</span> promise2;</span><br><span class="line">    <span class="keyword">return</span> response1 + <span class="string">' '</span> + response2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bởi vì ta không ở trong hàm `async` </span></span><br><span class="line"><span class="comment">// nên chúng ta phải dùng `then()`.</span></span><br><span class="line">loadData().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Done'</span>));</span><br></pre></td></tr></table></figure><p>Bạn có thể định nghĩa hàm async bằng cách sử dụng async function expression (AFE - Thể hiện hàm async). Một AFE tương tự và gần giống như một async function statement (AFS). Điểm khác biệt chính giữa AFE và AFS là tên của hàm, trong AFE ta có thể bỏ qua tên để tạo hàm vô danh (anonymous function). Một AFE có thể sử dụng như một IIFE (<a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" target="_blank" rel="noopener">Immediately Invoked Function Expression</a>), loại hàm được thực thi ngay sau khi nó được định nghĩa.</p><p>Nó trông như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadData = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `rp` là một hàm gọi promise.</span></span><br><span class="line">    <span class="keyword">var</span> promise1 = rp(<span class="string">'https://api.example.com/endpoint1'</span>);</span><br><span class="line">    <span class="keyword">var</span> promise2 = rp(<span class="string">'https://api.example.com/endpoint2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hiện tại cả 2 request đều được gọi đồng thời và</span></span><br><span class="line">    <span class="comment">// ta phải đợi cho nó hoàn thành.</span></span><br><span class="line">    <span class="keyword">var</span> response1 = <span class="keyword">await</span> promise1;</span><br><span class="line">    <span class="keyword">var</span> response2 = <span class="keyword">await</span> promise2;</span><br><span class="line">    <span class="keyword">return</span> response1 + <span class="string">' '</span> + response2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Quan trọng là async/await được hỗ trợ và có thể chạy trên đa số các trình duyệt:</p><p> <a href="https://cdn-images-1.medium.com/max/1000/0*z-A-JIe5OWFtgyd2." target="_blank" rel="noopener"><img src="https://cdn-images-1.medium.com/max/1000/0*z-A-JIe5OWFtgyd2." alt=""></a> <a></a></p><p>Nếu như trình duyệt nào không hỗ trợ thì ta vẫn có thể sử dụng các JS transpiler như <a href="https://babeljs.io/docs/plugins/transform-async-to-generator/" target="_blank" rel="noopener">Babel</a> hay <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html" target="_blank" rel="noopener">TypeScript</a></p><p>Cuối cùng thì điều quan trọng nhất là không nên chọn lựa một cách mù quáng những cách tiếp cận “mới nhất” để viết code bất đồng bộ. Tốt hơn là bạn hiểu về cấu trúc bất đồng bộ của JS, nghiên cứu tại sao nó lại là một vấn đề nghiêm túc và hiểu một cách sâu sắc về các thành phần bên trong của giải pháp mà bạn lựa chọn. Mỗi cách tiếp cận khác nhau đều có những điểm mạnh và điểm yếu, hãy cân nhắc.</p><h1 id="5-meo-de-viet-code-bat-dong-bo-vua-chac-chan-vua-de-bao-tri"><a href="#5-meo-de-viet-code-bat-dong-bo-vua-chac-chan-vua-de-bao-tri" class="headerlink" title="5 mẹo để viết code bất đồng bộ vừa chắc chắn vừa dễ bảo trì"></a>5 mẹo để viết code bất đồng bộ vừa chắc chắn vừa dễ bảo trì</h1><h3 id="1-Clean-code-code-sach"><a href="#1-Clean-code-code-sach" class="headerlink" title="1. Clean code (code sạch):"></a>1. <strong>Clean code (code sạch)</strong>:</h3><p>Sử dụng async/await cho phép bạn viết code ít hơn nhiều. Mỗi lần sử dụng async/await bạn có thể bỏ qua một số bước không cần thiết, ví dụ: .then(), viết hàm anonymous để xử lý responsive, đặt tên response từ callback…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `rp` là một hàm gọi promise</span></span><br><span class="line">rp(‘https:<span class="comment">//api.example.com/endpoint1').then(function(data) &#123;</span></span><br><span class="line"> <span class="comment">// …</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>…so với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `rp` là một hàm gọi promise</span></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> rp(‘https:<span class="comment">//api.example.com/endpoint1');</span></span><br></pre></td></tr></table></figure><h3 id="2-Xu-ly-loi"><a href="#2-Xu-ly-loi" class="headerlink" title="2. Xử lý lỗi:"></a>2. <strong>Xử lý lỗi</strong>:</h3><p>Async/await giúp chúng ta có thể xử lý cả lỗi đồng bộ và bất đồng bộ với cùng một cấu trúc code: chính là try/catch nổi tiếng. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// Catches synchronous errors.</span></span><br><span class="line">        getJSON().then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> parsed = <span class="built_in">JSON</span>.parse(response);</span><br><span class="line">            <span class="built_in">console</span>.log(parsed);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// Catches asynchronous errors</span></span><br><span class="line">            <span class="built_in">console</span>.log(e); </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…so với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">await</span> getJSON());</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Dieu-kien"><a href="#3-Dieu-kien" class="headerlink" title="3. Điều kiện:"></a>3. <strong>Điều kiện</strong>:</h3><p>Viết code điều kiện với async/await rõ ràng hơn rất nhiều:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response.needsAnotherRequest) &#123;</span><br><span class="line">        <span class="keyword">return</span> makeAnotherRequest(response)</span><br><span class="line">          .then(<span class="function"><span class="keyword">function</span>(<span class="params">anotherResponse</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(anotherResponse)</span><br><span class="line">            <span class="keyword">return</span> anotherResponse</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…so với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> response = <span class="keyword">await</span> getJSON();</span><br><span class="line">  <span class="keyword">if</span> (response.needsAnotherRequest) &#123;</span><br><span class="line">    <span class="keyword">var</span> anotherResponse = <span class="keyword">await</span> makeAnotherRequest(response);</span><br><span class="line">    <span class="built_in">console</span>.log(anotherResponse)</span><br><span class="line">    <span class="keyword">return</span> anotherResponse</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="keyword">return</span> response;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Stack-Frames"><a href="#4-Stack-Frames" class="headerlink" title="4. Stack Frames:"></a>4. <strong>Stack Frames</strong>:</h3><p>Không giống như async/await, stack lỗi trả về từ một chuỗi promise làm chúng ta không biết lỗi xuất phát từ đâu mà lần:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> callAPromise()</span><br><span class="line">    .then(callback1)</span><br><span class="line">    .then(callback2)</span><br><span class="line">    .then(callback3)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"boom"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">loadData()</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line"><span class="comment">// Error: boom at callAPromise.then.then.then.then (index.js:8:13)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>…so với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> callAPromise1()</span><br><span class="line">  <span class="keyword">await</span> callAPromise2()</span><br><span class="line">  <span class="keyword">await</span> callAPromise3()</span><br><span class="line">  <span class="keyword">await</span> callAPromise4()</span><br><span class="line">  <span class="keyword">await</span> callAPromise5()</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"boom"</span>);</span><br><span class="line">&#125;</span><br><span class="line">loadData()</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="comment">// Error: boom at loadData (index.js:7:9)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-Qua-trinh-Debug"><a href="#5-Qua-trinh-Debug" class="headerlink" title="5. Quá trình Debug:"></a>5. <strong>Quá trình Debug</strong>:</h3><p>Nếu bạn đã từng sử dụng promise, bạn sẽ biết rằng debug với chúng thực sự là ác mộng. Giả sử bạn đặt breakpoint bên trong .then() và dùng những lệnh debug như stop-over, debugger sẽ không đi đến .then() tiếp theo bởi vì nó “lỡ chân” bước vào code bất đồng bộ.<br>Với async/await bạn có thể duyệt qua những lời gọi await chính xác như những hàm đồng bộ thông thường.</p><p><strong>Viết code Javascript bất đồng bộ là rất quan trọng không chỉ cho app mà cả cho những thư viện nữa</strong>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 4 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Lần này chúng ta sẽ mở rộng những gì có trong bài đầu tiên bằng cách đánh giá những nhược điểm của môi trường đơn luồng (single thread) và làm thế nào để vượt qua chúng nhằm xây dựng những Javascript UI ấn tượng. Và vẫn như cũ, cuối bài viết tác giả sẽ chia sẻ 5 mẹo nhỏ để viết code tốt hơn với async/await.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P3: Quản lý bộ nhớ &amp; 4 trường hợp memory leaks phổ biến</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P3-Quan-ly-bo-nho-4-truong-hop-memory-leaks-pho-bien.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P3-Quan-ly-bo-nho-4-truong-hop-memory-leaks-pho-bien.html</id>
    <published>2018-11-13T16:03:00.000Z</published>
    <updated>2018-11-13T16:05:48.137Z</updated>
    
    <content type="html"><![CDATA[<p>Mấy hôm trước chúng ta đã bắt đầu series bài viết đục khoét về Javascript và cách nó hoạt động như thế nào, bằng cách hiểu về những thành phần cơ bản và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và <em>ngon</em> hơn.</p><p>Bài đầu tiên là tổng quan về series, cung cấp cái nhìn toàn cảnh về engine, runtime &amp; callstack. Bài thứ 2 là một cái nhìn cụ thể hơn về những thành phần bên trong của bộ engine V8 của Google và một số mẹo vặt để tối ưu Javascript code.</p><p>Ở bài thứ 3 này, chúng ta sẽ thảo luận về một vấn đề không kém phần quan trọng nhưng lại thường bị các dev bỏ qua do sự phức tạp ngày càng gia tăng của các ngôn ngữ lập trình thường dùng: quản lý bộ nhớ. Chúng ta cũng sẽ tìm hiểu một số mẹo để có thể xử lý những trường hợp rò rì bộ nhớ của Javascript mà team SesstionStack đã áp dụng để tránh bị rò rỉ và không làm tốn bộ nhớ của webapp.<br><a id="more"></a></p><h1 id="Tong-quan"><a href="#Tong-quan" class="headerlink" title="Tổng quan"></a>Tổng quan</h1><p>Những ngôn ngữ như C có bộ quản lý bộ nhớ level thấp khá cơ bản là malloc() và free(). Những phương thức này được sử dụng để cấp phát một cách tường minh và giải phóng bộ nhớ trên hệ điều hành.</p><p>Một cách tương tự, Javascript cấp phát bộ nhớ khi object, string, … được tạo ra và <em>tự động</em> giải phóng nó mỗi khi không được sử dụng nữa bởi một tiến trình dọn rác (garbage collection). Quá trình giải phóng tài nguyên một cách <em>tự động hóa</em> như thế này gây ra sự nhầm lẫn và làm cho Javascript (và những ngôn ngữ bậc cao khác) developer cảm thấy “ấn tượng” nên họ thường bỏ qua vấn đề quản lý bộ nhớ. <strong>Đây là một sai lầm lớn.</strong></p><p>Kể cả khi làm việc với ngôn ngữ bậc cao, developer cũng nên hiểu về vấn đề quản lý bộ nhớ (ít nhất là những thứ cơ bản). Thỉnh thoảng có những vấn đề xảy ra với quản lý bộ nhớ tự động (bug hay sự giới hạn thực hiện trong GC…) mà developer cần phần hiểu để có thể xử lý một cách đúng đắn (hoặc tìm cách “đi đường vòng” vượt qua nó với ít thiệt hại nhất).</p><h1 id="Vong-doi-cua-bo-nho"><a href="#Vong-doi-cua-bo-nho" class="headerlink" title="Vòng đời của bộ nhớ"></a>Vòng đời của bộ nhớ</h1><p>Dù cho bạn đang dùng ngôn ngữ lập trình nào đi nữa thì vòng đời bộ nhớ hầu như đều giống nhau:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*slxXgq_TO38TgtoKpWa_jQ.png" alt=""></p><p>Đây là những gì xảy ra ở mỗi bước trong vòng đời:</p><ul><li><p><strong>Cấp phát bộ nhớ</strong>: bộ nhớ được cấp phát bởi hệ điều hành và cho phép chương trình sử dụng nó. Ở ngôn ngữ bậc thấp (như C), đây là một quá trình tường minh, rõ ràng mà developer phải xử lý. Trong các ngôn ngữ bậc cao thì phần này ngôn ngữ sẽ làm giúp bạn.</p></li><li><p><strong>Sử dụng bộ nhớ</strong>: Đây là thời điểm khi chương tình của bạn sử dụng những vùng nhớ đã được cấp phát trước đó. Các thao tác Đọc và Ghi được thực hiện khi chúng ta thực thi những biến đã được khai báo trong code.</p></li><li><p><strong>Giải phóng bộ nhớ</strong>: Giờ là lúc giải phóng toàn bộ những vùng nhớ mà bạn không còn dùng đến nữa để sử dụng lại về sau. Giống như phần cấp phát, bước này được thực hiện một cách tường minh trong các ngôn ngữ bậc thấp.</p></li></ul><p>Để hiểu thêm về các khái niệm của callstack và heap thì mời bạn xem lại <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-1---Khai-quat-ve-engine--runtime-va-callstack" target="_blank" rel="noopener">Phần 1</a> của series.</p><h1 id="Bo-nho-la-gi"><a href="#Bo-nho-la-gi" class="headerlink" title="Bộ nhớ là gì?"></a>Bộ nhớ là gì?</h1><p>Trước khi đi sâu vào bộ nhớ của Javascript, chúng ta sẽ duyệt sơ qua bộ nhớ cơ bản và cách hoạt động của nó.</p><p>Ở phần cứng, bộ nhớ máy tính bao gồm một cơ số các <a href="https://vi.wikipedia.org/wiki/Flip-flop" target="_blank" rel="noopener">flip flops</a> (đại khái là 1 trạng thái đóng-mở). Mỗi flip-flop chứa một vài transistor và có thể lưu trữ 1 bit thông tin. Một flip-flop độc lập có thể được truy xuất bằng số định danh duy nhất (<strong>unique identifier</strong>), do đó chúng ta có thể đọc và ghi lên chúng. Và lẽ dĩ nhiên, về mặt ý tưởng chúng ta có thể công nhận rằng toàn bộ bộ nhớ máy tính là 1 mảng khổng lồ các bit có thể đọc &amp; ghi.</p><p>Về phần con người thì họ không giỏi làm việc với bit nên tổ chức chúng vào những nhóm lớn hơn, 8 bit thành 1 byte. Ngoài byte còn có word (16 hoặc 32 bit)</p><p>Có rất nhiều thứ được lưu trữ trong bộ nhớ:</p><ol><li>Tất cả các biến và dữ liệu được sử dụng trong các chương trình.</li><li>Code của chương trình chạy, kể cả code của hệ điều hành.</li></ol><p>Trình biên dịch và hệ điều hành làm việc với nhau để xử lý hầu như toàn bộ phần quản lý bộ nhớ nhưng chúng tôi khuyến cáo bạn nên có cái nhìn sơ lược về những gì xảy ra ở nội bộ bên trong.</p><p>Khi biên dịch code, trình biên dịch sẽ xem xét các kiểu dữ liệu nguyên thủy (string, number, boolean…) và tính toán trước bao nhiêu bộ nhớ mà chúng cần sử dụng. Lượng bộ nhớ cần thiết sau đó sẽ được cấp phát cho chương tình trong không gian callstack. Vùng không gian được cấp phát được gọi là stack space bởi vì khi gọi hàm, bộ nhớ của nó được thêm vào vị trí trên cùng của bộ nhớ hiện tại. Và khi hủy bỏ, chúng bị gỡ bỏ theo quy tắc LIFO (last-in-first-out, vào sau ra trước). Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n; <span class="comment">// 4 bytes</span></span><br><span class="line">int x[<span class="number">4</span>]; <span class="comment">// mảng 4 phần tử, mỗi phần tử 4 bytes</span></span><br><span class="line">double m; <span class="comment">// 8 bytes</span></span><br></pre></td></tr></table></figure><p>Trình biên dịch sẽ tính toán ngay lập tức đoạn code này cần 4 + 4 * 4 + 8 = 28 bytes</p><blockquote><p>Đó là cách hoạt động của kích thước vùng nhớ cho kiểu số integer và double. Khoảng 20 năm trước, integer là 2 byte và double là 4 byte. Code của bạn không phải phụ thuộc vào kích thước của các kiểu dữ liệu cơ bản.</p></blockquote><p>Trình biên dịch sẽ chèn code tương tác với hệ điều hành để yêu cầu số lượng byte cần thiết để lưu trữ các biến.</p><p>Trong ví dụ trên, trình biên dịch biết chính xác bao nhiêu bộ nhớ cần thiết cho mỗi biến. Thực tế thì mỗi khi ghi dữ liệu vào biến n, nó sẽ được dịch nội bộ thành mộ thứ đại loại như “địa chỉ vùng nhớ 4127963”</p><p>Để ý rằng nếu ta thử truy xuất x[4] thì ta sẽ truy xuất nhầm sang dữ liệu đang liên kết với m. Bởi vì chúng ta đang cố truy xuất vào một phần tử không tồn tại trong mảng: 4 byte này nằm ngoài vùng x[3] vốn là vùng nhớ được cấp phát cuối cùng của mảng (index đánh từ 0 :v), và vậy là có thể ta đọc/ghi nhầm sang các bit của biến m. Điều này có thể gây ra nhiều hậu quả không mong muốn cho toàn bộ chương trình. Xem hình cho rõ hơn nhé:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*5aBou4onl1B8xlgwoGTDOg.png" alt=""></p><p>Khi một hàm gọi một hàm khác thì mỗi hàm sẽ chiếm một phần của stack. Phần đó sẽ lưu giữ tất cả những biến cục bộ cũng như một bộ đếm để ghi nhớ vị trí mà quá trình thực thi của hàm dừng lại. Khi hàm kết thúc thì vùng bộ nhớ lại được giải phóng cho thằng khác dùng.</p><h1 id="Cap-phat-dong"><a href="#Cap-phat-dong" class="headerlink" title="Cấp phát động"></a>Cấp phát động</h1><p>Thật không may là mọi thứ dường như không dễ như ta tưởng khi mà ta không biết bao nhiêu bộ nhớ 1 biến có thể cần tại thời điểm thực thi. Giả sử chúng ta muốn làm như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n = readInput(); <span class="comment">// đọc input từ người dùng</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// tạo 1 mảng với "n" phần tử</span></span><br></pre></td></tr></table></figure><p>Tại thời điểm biên dịch, trình biên dịch không biết mảng sẽ cần bao nhiêu bộ nhớ bởi vì nó được xác định bởi dữ liệu nhập vào từ phía người dùng.</p><p>Vì thế nó không thể cấp phát vùng nhớ cho biến trên stack. Thay vì thế, chương trình của chúng ta cần hỏi hệ điều hành về kích thước bộ nhớ phù hợp trong khi thực thi (run-time). Vùng nhớ này được gán từ không gian <em>heap</em>. Sự khác biệt giữa cấp phát bộ nhớ động và tĩnh được tổng kết trong bảng sau:</p><table><thead><tr><th>Cấp phát tĩnh</th><th>Cấp phát động</th></tr></thead><tbody><tr><td>Biết kích thước tại thời điểm biên dịch.</td><td>Không biết kích thức lúc biên dịch</td></tr><tr><td>Thực hiện lúc biên dịch</td><td>Thực hiện lúc thực thi (runtime)</td></tr><tr><td>Gán vào stack</td><td>Gán vào heap</td></tr><tr><td>Gán theo thứ tự FILO (first-in-last-out)</td><td>Gán không theo thứ tự cụ thể nào cả</td></tr></tbody></table><p>Để có thể có cái nhìn sâu sắc về cấp phát bộ nhớ động, có thể chúng ta cần dành thêm thời gian tìm hiểu về <strong>con trỏ</strong>, nhưng như vậy thì hơi bị lạc đề. Nếu bạn thấy có hứng thú với chủ đề này thì xin lỗi phải hẹn bạn trong 1 bài viết khác rồi.</p><h1 id="Cap-phat-trong-Javascript"><a href="#Cap-phat-trong-Javascript" class="headerlink" title="Cấp phát trong Javascript"></a>Cấp phát trong Javascript</h1><p>Javascript giúp developer giảm bớt trách nhiệm trong việc cấp phát bộ nhớ. JS tự làm hết mọi thứ.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">374</span>; <span class="comment">// cấp phát bộ nhớ cho số</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'sessionstack'</span>; <span class="comment">// cấp phát cho string </span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// cấp phát cho object và các thuộc tính của nó</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">'str'</span>];  <span class="comment">// (giống như object) cấp phát cho</span></span><br><span class="line">                           <span class="comment">// mảng và các giá tị của nó</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">3</span>;</span><br><span class="line">&#125; <span class="comment">// cấp phát cho hàm (là 1 object có thể thực thi)</span></span><br><span class="line"><span class="comment">// function expressions cũng cấp phát object</span></span><br><span class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>Một vài lời gọi hàm cũng trả về dạng cấp phát object:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// cấp phát Date object</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">// cấp phát 1 phần tử DOM</span></span><br></pre></td></tr></table></figure><p>Phương thức có thể cấp phát giá trị hoặc object:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'sessionstack'</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substr(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 là 1 string mới</span></span><br><span class="line"><span class="comment">// Bởi vì string là bất biến, </span></span><br><span class="line"><span class="comment">// JavaScript có thể chọn không cấp phát bộ nhớ</span></span><br><span class="line"><span class="comment">// mà lưu trữ phạm vi [0, 3]</span></span><br><span class="line"><span class="keyword">var</span> a1 = [<span class="string">'str1'</span>, <span class="string">'str2'</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="string">'str3'</span>, <span class="string">'str4'</span>];</span><br><span class="line"><span class="keyword">var</span> a3 = a1.concat(a2); </span><br><span class="line"><span class="comment">// mảng mới gồm 4 phần tử là</span></span><br><span class="line"><span class="comment">// sự kết hợp của mảng a1 và a2</span></span><br></pre></td></tr></table></figure><h1 id="Su-dung-bo-nho-trong-Javascript"><a href="#Su-dung-bo-nho-trong-Javascript" class="headerlink" title="Sử dụng bộ nhớ trong Javascript"></a>Sử dụng bộ nhớ trong Javascript</h1><p>Sử dụng bộ nhớ đã được cấp phát trong Javascript có thể gói gọn một cách đơn giản trong 2 chữ <strong>đọc/ghi</strong></p><p>Việc này có thể thực hiện bằng cách đọc/ghi giá trị của biến hoặc thuộc tính của object hoặc truyền đối số (argument) vào 1 hàm.</p><h1 id="Giai-phong-khi-khong-dung-bo-nho-nua"><a href="#Giai-phong-khi-khong-dung-bo-nho-nua" class="headerlink" title="Giải phóng khi không dùng bộ nhớ nữa"></a>Giải phóng khi không dùng bộ nhớ nữa</h1><p>Đa số các phần đề về quản lý bộ nhớ xảy ra ở giai đoạn này.</p><p>Công việc khó nhất ở đây là tìm hiểu khi nào bộ nhớ đã được cấp phát có còn được sử dụng hay không. Thường thì nó yêu cầu developer xác định vùng nhớ nào trong chương trình không dùng nữa và giải phóng nó.</p><p>Ngôn ngữ bậc cao thêm vào 1 chương tình gọi là bộ dọn rác (garbage collector - GC) thực hiện công việc đi tìm những vùng nhớ đã được cấp phát và tìm hiểu xem nó còn được sử dụng hay không, nếu không dùng nữa thì sẽ tự động giải phóng nó.</p><p>Điều hơi chuối là tiến trình này chỉ tương đối đúng, bởi vì vấn đề tổng quát về việc xác định một vùng nhớ có còn được sử dụng hay không là bất khả thi (không thể thực hiện bằng thuật toán).</p><p>Đa số GC hoạt động bằng cách thu thập những vùng nhớ không còn bị truy xuất đến, ví dụ: tất cả biến đang trỏ đến nó đều đi ra khỏi phạm vi thực thi. Tuy nhiên, điều này cũng lại không hẳn là chính xác vì tại bất kỳ thời điểm nào một địa chỉ vùng nhớ đều có thể được trỏ tới bởi 1 biến, nhưng biến đó lại không bao giờ được sử dụng nữa.</p><h1 id="Qua-trinh-don-rac"><a href="#Qua-trinh-don-rac" class="headerlink" title="Quá trình dọn rác"></a>Quá trình dọn rác</h1><p>Rõ ràng cách thức để tìm được vùng nhớ “không còn dùng nữa” là bất khả thi cho nên GC thực hiện một giải pháp hạn chế cho vấn đề chung. Phần này sẽ giải thích những khái niệm cần thiết để bạn có thể hiểu được những thuật toán GC và các giới hạn của chúng.</p><h2 id="Tham-chieu-bo-nho"><a href="#Tham-chieu-bo-nho" class="headerlink" title="Tham chiếu bộ nhớ"></a>Tham chiếu bộ nhớ</h2><p>Ý tưởng chính của những thuật toán GC dựa trên <strong>tham chiếu</strong></p><p>Trong ngữ cảnh quản lý bộ nhớ, một object A tham chiếu đến object B khác nếu như A có truy xuất đến B (có thể tường minh hoặc không tường minh). Ví dụ: một Javascript object có tham chiếu đến prototype của chính nó (<strong>không tường minh</strong>) và tham chiếu đến giá trị của thuộc tính của nó (<strong>tường minh</strong>).</p><p>Trong trường hợp này, khái niệm của 1 “object” được mở rộng thành một thứ gì đó hơn là JS object thông thường và bao trùm cả function scope (hoặc là lexical scope toàn cục).</p><blockquote><p>Lexical scoping định nghĩa cách mà những tên biến được phân giải trong các hàm lồng nhau: những hàm con chưa scope của hàm cha kể cả khi hàm cha đã được return.</p></blockquote><h2 id="Bo-dem-tham-chieu"><a href="#Bo-dem-tham-chieu" class="headerlink" title="Bộ đếm tham chiếu"></a>Bộ đếm tham chiếu</h2><p>Đây là thuật toán dọn rác đơn giản nhất. Một object được đánh giá là “rác có thể dọn” nếu như không có tham chiếu nào trỏ đến nó.</p><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  o2: &#123;</span><br><span class="line">    x: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Tạo 2 object</span></span><br><span class="line"><span class="comment">// 'o1' tham chiếu đến 'o2' vì nó là 1 thuộc tính của 'o1'</span></span><br><span class="line"><span class="comment">// Hiện tại không có rác để dọn.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o3 = o1; <span class="comment">// biến 'o3' đang tham chiếu tới cùng 1 object với 'o1'</span></span><br><span class="line"></span><br><span class="line">o1 = <span class="number">1</span>;      <span class="comment">// giờ thì object được tham chiếu trước đó bởi 'o1'         </span></span><br><span class="line">            <span class="comment">// chỉ còn lại 1 tham chiếu duy nhất là 'o3'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o4 = o3.o2; <span class="comment">// tham chiếu đến thuộc tính 'o2'</span></span><br><span class="line">                <span class="comment">// object này giờ có 2 tham chiếu: </span></span><br><span class="line">                <span class="comment">// một là thuộc tính của 'o3': o3.o2</span></span><br><span class="line">                <span class="comment">// hai là biến 'o4'</span></span><br><span class="line"></span><br><span class="line">o3 = <span class="string">'374'</span>; <span class="comment">// Giờ thì object trước đây là của o1 không còn tham chiếu nữa.</span></span><br><span class="line">            <span class="comment">// Nó có thể bị dọn dẹp bởi GC </span></span><br><span class="line">            <span class="comment">// Tuy nhiên thuộc tính 'o2' của nó thì vẫn còn</span></span><br><span class="line">            <span class="comment">// được tham chiếu bởi biến 'o4' nên chưa bị dọn</span></span><br><span class="line"></span><br><span class="line">o4 = <span class="literal">null</span>; <span class="comment">// thuộc tính 'o2' trước đây trong 'o1' giờ</span></span><br><span class="line">           <span class="comment">// đã không còn gì tham chiếu đến nó</span></span><br><span class="line">           <span class="comment">// lần này thì GC có thể dọn nó được rồi.</span></span><br></pre></td></tr></table></figure><h2 id="Van-de-tu-tham-chieu-vong-tron"><a href="#Van-de-tu-tham-chieu-vong-tron" class="headerlink" title="Vấn đề từ tham chiếu vòng tròn"></a>Vấn đề từ tham chiếu vòng tròn</h2><p>Có một số giới hạn liên quan đến tham chiếu vòng tròn. Trong ví dụ sau, 2 object được tạo ra và được tham chiếu lẫn nhau, tạo thành 1 vòng tròn. Chúng sẽ được đẩy ra ngoài scope sau khi hàm kết thúc nên về mặt lý thuyết thì chúng vô dụng và có thể được giải phóng. Tuy nhiên, thuật toán đếm tham chiếu xem xét rằng mỗi object đều đang có ít nhất 1 tham chiếu đến object đó nên thuật toán sẽ bỏ qua mà không dọn dẹp.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o1.p = o2; <span class="comment">// o1 tham chiếu đến o2</span></span><br><span class="line">  o2.p = o1; <span class="comment">// o2 tham chiếu đến o1\. </span></span><br><span class="line">            <span class="comment">// 2 thanh niên này tạo thành 1 vòng tròn tham chiếu.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1000/1*GF3p99CQPZkX3UkgyVKSHw.png" alt=""></p><h2 id="Thuat-toan-Danh-dau-va-don-dep-Mark-and-sweep"><a href="#Thuat-toan-Danh-dau-va-don-dep-Mark-and-sweep" class="headerlink" title="Thuật toán Đánh dấu và dọn dẹp (Mark-and-sweep)"></a>Thuật toán Đánh dấu và dọn dẹp (Mark-and-sweep)</h2><p>Để xác định xem object có còn cần thiết không thì thuật toán này thử xem object đó có thể truy cập tới hay không.</p><p>Thuật toán <strong>Mark-and-sweep</strong> có 3 bước:</p><ol><li><strong>Roots</strong>: Nhìn chung, <em>roots</em> là những biến toàn cục (global) được tham chiếu đến trong code. Với Javascript, một biến toàn cục có vai trò như 1 <em>root</em> chính là object <strong>window</strong>. Trong Node.js thì nó gọi là <strong>global</strong>. Danh sách hoàn chỉnh các <em>roots</em> được xây dựng bởi GC.</li><li>Thuật toán sẽ điều tra tất cả các <em>roots</em> và con cháu (children) của nó rồi đánh dấu chúng là đang hoạt động (active) (nghĩa là, chúng không phải rác). Thứ gì mà không phải con cháu của root, root không truy xuất đến được thì đều bị coi là <em>rác</em>.</li><li>Cuối cùng, GC sẽ giải phóng các vùng nhớ không được đánh dấu <em>active</em> và trả bộ nhớ lại cho hệ điều hành.</li></ol><p><img src="https://cdn-images-1.medium.com/max/1000/1*WVtok3BV0NgU95mpxk9CNg.gif" alt=""></p><p>Thuật toán này tốt hơn thuật toán trước vì “đối tượng không có tham chiếu” dẫn tới trường hợp đối tượng không thể truy cập, ở hướng ngược lại thì nó giải quyết được vấn đề của tham chiếu vòng tròn.</p><p>Năm 2012, tất cả trình duyệt hiện đại đều tích hợp sẵn bộ GC Mark-and-sweep. Những cải tiến dành cho bộ Javascript GC (như GC Thế hệ (Generational)/ Gia tăng (Incremental)/ Đồng thời (Concurrent)/ Song song (Parallel)) trong những năm gần đây đều là những nâng cấp của thuật toán Mark-and-sweep, nhưng không phải là cải tiến thuật toán GC, cũng không phải quyết định xem 1 object có thể truy cập được hay là không.</p><p><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">Trong bài viết này</a>, bạn có thể tìm hiểu chi tiết hơn về quá trình truy tìm rác, nó cũng bao gồm luôn cả thuật toán Mark-and-sweep và cách tối ưu hóa của nó.</p><h2 id="Tham-chieu-vong-tron-chi-la-muoi"><a href="#Tham-chieu-vong-tron-chi-la-muoi" class="headerlink" title="Tham chiếu vòng tròn chỉ là muỗi"></a>Tham chiếu vòng tròn chỉ là muỗi</h2><p>Trong ví dụ đầu tiên, sau khi hàm được trả về, 2 object đều không được tham chiếu đến bởi một object có thể truy cập được từ đối tượng toàn cục. Một lẽ dĩ nhiên, thì chúng sẽ bị GC đánh dấu và dọn sạch sẽ.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*FbbOG9mcqWZtNajjDO6SaA.png" alt=""></p><p>Mặc dù giữa 2 object đều có tham chiếu lẫn nhau nhưng chúng không thể truy cập được từ <em>root</em></p><h2 id="Hanh-vi-phan-truc-quan-cua-GC"><a href="#Hanh-vi-phan-truc-quan-cua-GC" class="headerlink" title="Hành vi phản trực quan của GC"></a>Hành vi phản trực quan của GC</h2><p>Mặc dù GC rất tiện lợi nhưng chúng cũng đi kèm với những khuyết điểm. Một trong số đó là sự <em>không xác định được</em>. Nói cách khác, GC là không thể đoán trước được. Ta không thể biết rõ khi nào thì GC được thực thi. Có nghĩa là trong một vài trường hợp chương trình sử dụng nhiều bộ nhớ hơn số lượng mà chúng cần. Trong trường hợp khác, những thời điểm tạm dừng ngắn hạn (short-pauses) có thể đáng được chú ý trong một số ứng dụng đặc biệt nhạy cảm.<br>Mặc dù <em>không xác định được</em> nghĩa là không biết khi nào GC sẽ chạy, đa số GC đều dùng chung một mô hình thu thập trong quá trình cấp phát. Nếu như cấp phát không chạy, hầu như GC cũng không chạy. Cần cân nhắc trường hợp sau:</p><ol><li>Cấp phát một số lược bộ nhớ lớn.</li><li>Đa số các phần tử này (hoặc toàn bộ) đều được đánh dấu là không thể truy cập (Giả sử chúng ta vô hiệu hóa một tham chiếu đang trỏ đến bộ nhớ cache mà chúng ta không cần nữa.)</li><li>Không có cấp phát nào được thực thi nữa.</li></ol><p>Trong trường hợp này, đa số các GC sẽ không chạy bất kỳ một thu gom nào. Nói cách khác, mặc dù có những tham chiếu không thể truy cập được đang tồn tại nhưng chúng lại không được GC “để mắt” đến. Đây không phải là một loại rò rỉ nghiêm trọng nhưng dĩ nhiên nó vẫn sử dụng bộ nhớ nhiều hơn bình thường.</p><h1 id="Ro-ri-bo-nho-la-gi"><a href="#Ro-ri-bo-nho-la-gi" class="headerlink" title="Rò rỉ bộ nhớ là gì ?"></a>Rò rỉ bộ nhớ là gì ?</h1><p>Nếu bạn đọc hết những phần ở trên thì cũng dễ hiểu thôi, rò rỉ bộ nhớ là những vùng nhớ được cấp phát và sử dụng trong chương trình nhưng sau đó, khi không còn dùng nữa, chúng vẫn không được giải phóng và trả về cho hệ điều hành hoặc là kho chứa bộ nhớ.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg" alt=""></p><p>Các ngôn ngữ lập trình có nhiều cách khác nhau để quản lý bộ nhớ. Tuy nhiên, một vùng nhớ cụ thể được dùng hay không thực sự là <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Release_when_the_memory_is_not_needed_anymore" target="_blank" rel="noopener">vấn đề khó đoán</a>. Nói cách khác, chỉ có developer mới biết khi nào thì một vùng nhớ nên được giải phóng và trả lại cho hệ điều hành.</p><p>Những ngôn ngữ lập trình cung cấp các tính năng giúp developer làm việc này. Trong khi một số ngôn ngữ khác muốn developer hiểu tường tận về việc khi nào thì 1 vùng nhớ không được sử dụng nữa. Wikipedia có bài viết hay về việc quản lý bộ nhớ <a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" target="_blank" rel="noopener">tự động</a> và <a href="https://en.wikipedia.org/wiki/Manual_memory_management" target="_blank" rel="noopener">bằng tay</a>, bạn có thể xem qua.</p><h2 id="4-loai-ro-ri-pho-bien-trong-Javascript"><a href="#4-loai-ro-ri-pho-bien-trong-Javascript" class="headerlink" title="4 loại rò rỉ phổ biến trong Javascript"></a>4 loại rò rỉ phổ biến trong Javascript</h2><h3 id="1-Bien-toan-cuc"><a href="#1-Bien-toan-cuc" class="headerlink" title="1. Biến toàn cục"></a>1. Biến toàn cục</h3><p>Javascript xử lý những biến không được khai báo một cách khá thú vị: khi một biến không được khai báo được tham chiếu đến thì một biến mới sẽ được tạo ra trong object toàn cục (global). Trên trình duyệt thì tên của nó là <strong>window</strong>, nghĩa là đoạn này</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    bar = <span class="string">"some text"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…tương đương với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.bar = <span class="string">"some text"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Giả sử mục đích của bar chỉ để tham chiếu đến 1 biến trong hàm foo thì một biến toàn cục dư thừa lúc này đã được tạo ra bởi vì ta định nghĩa bar mà không dùng var. Ở ví dụ trên, nó không gây ra nhiều tổn hại, nhưng dĩ nhiên bạn có thể tưởng tượng ra bối cảnh đáng lo ngại hơn nhiều. Ví dụ như gán 1 object phức tạp trong bar chẳng hạn.</p><p>Thỉnh thoảng bạn cũng có thể vô tình tạo biến toàn cục bằng this:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.var1 = <span class="string">"potential accidental global"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// trong hàm foo() ở đây thì "this" đang trỏ tới biến toàn cục </span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>Bạn có thể tránh trường hợp đáng tiếc này bằng cách thêm dòng use strict vào đầu file Javascript, nó sẽ, nói nôm na, là bật chế độ “nghiêm túc” lên khi phân tích cú pháp (parse) code JS và sẽ ngăn chặn trường hợp vô tình tạo biến toàn cục.</p><p>Những biến toàn cục ngoài dự tính như trên rõ ràng là 1 vấn đề, tuy nhiên, thường thì code của bạn sẽ bị “nhiễm độc” bởi những biến toàn cục tường minh mà những biến đó lại không thể thu thập bởi GC. Đặc biệt chú ý đến các biến toàn cục thường được dùng để lưu trữ tạm thời và xử lý 1 số lượng lớn thông tin. Sử dụng biến toàn cục để lưu trữ dữ liệu nếu bạn <strong>phải</strong> làm thế, nhưng nhớ kỹ là gán nó bằng null hoặc gán lại 1 giá trị khác khi đã xong việc với nó.</p><h3 id="2-Timers-hoac-callbacks-bi-bo-quen"><a href="#2-Timers-hoac-callbacks-bi-bo-quen" class="headerlink" title="2. Timers hoặc callbacks bị bỏ quên"></a>2. Timers hoặc callbacks bị bỏ quên</h3><p>Lần này ta lấy setInterval làm ví dụ vì nó thường được dùng trong JS.</p><p>Những thư viện có dùng callback cung cấp observer và các công cụ tương tự thường đảm bảo tham chiếu đến callback sẽ không thể truy cập được một khi instance của nó không thể truy cập được. Ví dụ dưới đây không phải hiếm:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverData = loadData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> renderer = <span class="built_in">document</span>.getElementById(<span class="string">'renderer'</span>);</span><br><span class="line">    <span class="keyword">if</span>(renderer) &#123;</span><br><span class="line">        renderer.innerHTML = <span class="built_in">JSON</span>.stringify(serverData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>); <span class="comment">// hàm sẽ được thực thi sau mỗi 5 giây.</span></span><br></pre></td></tr></table></figure><p>Đoạn code trên cho thấy hậu quả của việc sử dụng timer có tham chiếu đến node hay dữ liệu cũ, không còn dùng nữa.</p><p>Object renderer có thể được thay thế hoặc gỡ bỏ ở đâu đó trong quá trình thực thi, điều này làm cho hàm callback trong setInterval trở nên thừa thãi. Nếu điều này xảy ra, dù cho callback hay những thứ bên trong có đủ điều kiện để được dọn dẹp thì trước hết cái interval đó phải dừng lại trước đã (bỏi vì nó vẫn đang hoạt động mà). Dĩ nhiên nếu như serverData đang chứa hay đang xử lý cả 1 đống dữ liệu thì cũng không thể bị thu dọn được.</p><p>Khi sử dụng observer, bạn cần đảm bảo phải có một câu lệnh tường minh để gỡ bỏ chúng mỗi khi xong việc (Dù là observer đó không cần dùng nữa hay object không thể truy cập được).</p><p>May mắn thay, đa số các trình duyệt hiện đại đều làm giúp bạn việc đó rồi: chúng sẽ tự động thu thập các observer mỗi khi object trong đó trở nên không thể truy cập được kể cả nếu như bạn quên gỡ các listener. Trước đây, một số trình duyệt không làm được điều này (IE6 chẳng hạn).</p><p>Nhưng cách tốt nhất vẫn là gỡ bỏ observer khi đã xong việc với nó. Bạn xem ví dụ dưới đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'launch-button'</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">   counter++;</span><br><span class="line">   element.innerHtml = <span class="string">'text '</span> + counter;</span><br><span class="line">&#125;</span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, onClick);</span><br><span class="line"><span class="comment">// Do stuff </span></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>, onClick);</span><br><span class="line">element.parentNode.removeChild(element);</span><br><span class="line"><span class="comment">// Giờ thì "element" đã được đưa ra khỏi phạm vi thực thi,</span></span><br><span class="line"><span class="comment">// Cả "element" và "onClick" sẽ được dọn dẹp kể cả trên các trình duyệt cũ</span></span><br></pre></td></tr></table></figure><p>Bạn không càn phải gọi hàm removeEventListener trước khi làm cho node không thể truy cập được vì các trình duyệt hiện đại hỗ trợ GC có thể tự động xác định và xử lý chúng một cách thích hợp.</p><p>Nếu bạn dùng jQuery APIs (có nhiều thư viện và frameworks khác cũng hỗ trợ), bạn cũng có thể gỡ bỏ các listener trước khi node bị đưa vào “dĩ vãng” và không dùng nữa. Những thư viện cũng đảm bảo không có rò rỉ bộ nhớ kể cả khi ứng dụng của bạn chạy trên những trình duyệt cũ.</p><h3 id="3-Closures"><a href="#3-Closures" class="headerlink" title="3. Closures"></a>3. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">Closures</a></h3><p>Một phần quan trọng của Javascript chính là closure: một hàm con có thể truy xuất đến biến của hàm bên ngoài nó. Trong quá tình triển khai chi tiết môi trường thực thi (runtime) của JS thì có thể xảy ra tình trạng rò rỉ bộ nhớ với closure như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing) <span class="comment">// một tham chiếu đến 'originalThing'</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>Một khi replaceThing được gọi, theThing sẽ trở thành một object mới chứa 1 mảng rất lớn và 1 closure someMethod. Tuy nhiên, originalThing được tham chiếu bởi 1 closure mà nó lại nằm trong biến unused (chính là biến theThing từ lời gọi đến replaceThing trước đó). Nhớ rằng ở đây một khi <strong>phạm vi (scope) của closure được tạo ra cho closure trong cùng parent scope thì scope đó được dùng chung</strong>.</p><p>Trong trường hợp này, scope tạo ra cho closure someMethod được chia sẻ với unused. unused có tham chiếu đến originalThing. Mặc dù unused không bao giờ được dùng, someMehod có thể được sử dụng thông qua theThing bên ngoài scope của replaceThing (ví dụ: ở 1 nơi toàn cục nào đó). Và khi someMethod chia sẻ closure với unused, tham chiếu đến originalThing trong unused ép nó phải ở trong trạng thái hoạt động (toàn bộ scope chia sẻ giữa 2 closure). Điều này ngăn chặn GC hoạt động.</p><p>Trong ví dụ trên, scope được tạo ra cho closure someMethod được chia sẻ với unused, trong khi unused tham chiếu tới originalThing. someMethod có thể được gọi thông qua theThing bên ngoài scope của replaceThing, mặc dù sự thật là unused không bao giờ được sử dụng. Rõ ràng unused tham chiếu đến originalThing yêu cầu nó phải giữ trạng thái đang hoạt động bởi vì someMethod chia sẻ closure scope với unused.</p><p>Tất cả những điều này có thể làm bộ nhớ bị rò rỉ đáng kể. Bạn có thể thấy biểu đồ sử dụng bộ nhớ dâng lên cao ngất khi đoạn code trên bị lặp đi lặp lại. Kích thước của nó không bị giảm đi khi GC hoạt động. Một danh sách liên kết các closure được tạo ra (root của nó là theThing) và mỗi closure scope lại chưa một tham chiếu gián tiếp tới mảng khổng lồ.</p><p>Vấn đề này được tìm thấy bởi Meteor team và họ có <a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" target="_blank" rel="noopener">1 bài viết cụ thể mô tả về nó ở đây</a>.</p><h3 id="4-Tham-chieu-ngoai-DOM"><a href="#4-Tham-chieu-ngoai-DOM" class="headerlink" title="4. Tham chiếu ngoài DOM"></a>4. Tham chiếu ngoài DOM</h3><p>Có những trường hợp mà developer lưu trữ DOM node bên trong cấu trúc dữ liệu. Giả sử bạn muốn cập nhật một cách nhanh chóng dữ liệu của nhiều row trong 1 table. Nếu bạn lưu tham chiếu đến mỗi DOM row trong 1 dictionary hay mảng, sẽ có 2 tham chiếu đến cùng 1 phần tử DOM: 1 là từ cây DOME, và 1 là từ dictionary. Nếu bạn chọn lựa xóa bỏ những row này, bạn cũng phải nhớ làm cho 2 tham chiếu trên không thể truy cập được.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">    button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</span><br><span class="line">    image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    elements.image.src = <span class="string">'http://example.com/image_name.png'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Cái ảnh là 1 node con trực tiếp của body</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'image'</span>));</span><br><span class="line">    <span class="comment">// Ở thời điểm này ta vẫn có 1 tham chiếu đến #button trong </span></span><br><span class="line">    <span class="comment">// biến toàn cục "element". Nói cách khác, "button" vẫn còn nằm</span></span><br><span class="line">    <span class="comment">// trong bộ nhớ và GC không thể dọn dẹp nó được.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cần phải xem xét kỹ lưỡng khi tham chiếu đến node con hay node lá bên trong cây DOME. Nếu bạn giữ tham chiếu đến 1 table cell (thẻ <td>) trong code và chọn xóa table khỏi DOM tuy nhiên vẫn giữ tham chiếu đến cell đó, bạn có thể sẽ phải đối mặt với 1 vụ rò rỉ lớn. Bạn nghĩ rằng GC sẽ giải phóng tất cả mọi thứ ngoại trừ cell đó. Tuy nhiên, điều này không dễ dàng như vậy. Bởi vì cell là 1 node con của table và những node con thì có tham chiếu đến parent của chúng, vì thế 1 tham chiếu đến 1 cell có thể giữ cả 1 table lớn trong bộ nhớ.</td></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mấy hôm trước chúng ta đã bắt đầu series bài viết đục khoét về Javascript và cách nó hoạt động như thế nào, bằng cách hiểu về những thành phần cơ bản và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và &lt;em&gt;ngon&lt;/em&gt; hơn.&lt;/p&gt;
&lt;p&gt;Bài đầu tiên là tổng quan về series, cung cấp cái nhìn toàn cảnh về engine, runtime &amp;amp; callstack. Bài thứ 2 là một cái nhìn cụ thể hơn về những thành phần bên trong của bộ engine V8 của Google và một số mẹo vặt để tối ưu Javascript code.&lt;/p&gt;
&lt;p&gt;Ở bài thứ 3 này, chúng ta sẽ thảo luận về một vấn đề không kém phần quan trọng nhưng lại thường bị các dev bỏ qua do sự phức tạp ngày càng gia tăng của các ngôn ngữ lập trình thường dùng: quản lý bộ nhớ. Chúng ta cũng sẽ tìm hiểu một số mẹo để có thể xử lý những trường hợp rò rì bộ nhớ của Javascript mà team SesstionStack đã áp dụng để tránh bị rò rỉ và không làm tốn bộ nhớ của webapp.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
