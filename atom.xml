<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Learn and Share</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nthung2112.github.io/"/>
  <updated>2018-06-27T01:11:20.866Z</updated>
  <id>http://nthung2112.github.io/</id>
  
  <author>
    <name>Hung Tan Nguyen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>10 mẹo CSS hữu ích bạn nên biết</title>
    <link href="http://nthung2112.github.io/2018/06/10-meo-CSS-huu-ich-ban-nen-biet.html"/>
    <id>http://nthung2112.github.io/2018/06/10-meo-CSS-huu-ich-ban-nen-biet.html</id>
    <published>2018-06-27T01:01:00.000Z</published>
    <updated>2018-06-27T01:11:20.866Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Pagespeed Optimization</strong> (tối ưu hóa tốc độ trang) là một công việc mà hầu như mọi Web developer đều quan tâm và nên biết, mục đích của nó là đưa nội dung website đến với người xem nhanh nhất có thể.</p><p>Front-end developer thường làm việc với HTML, CSS, Javascript và các hình ảnh. Do đó, đây cũng là các đối tượng chính để chúng ta tối ưu tốc độ tải trang cho website. Tốc độ tải trang của website ngoài các yếu tố liên quan do server thì còn phụ thuộc vào kích thước và số lượng file phải tải về, do đó càng giảm được kích thước file lẫn số lượng file cần phải tải về thì cũng đồng thời tăng tốc độ tải file và giảm số lượng request lên server.<br><a id="more"></a><br>Ở bài này mình sẽ giới thiệu với các bạn 10 mẹo CSS hữu ích giúp giảm kích thước, số lượng file CSS, tối ưu file CSS và phát triển CSS dễ dàng hơn, nội dung bài gồm những phần sau:</p><ol><li><a href="#01-han-che-su-dung-import">Hạn chế sử dụng @import</a></li><li><a href="#02-su-dung-cach-viet-ngan-gon">Sử dụng cách viết ngắn gọn (shorthand properties)</a></li><li><a href="#03-khai-bao-class-bo-tro">Khai báo class bổ trợ (Helper classes)</a></li><li><a href="#04-han-che-su-dung-inline-css-trong-elements">Hạn chế sử dụng CSS trong element của HTML (inline CSS attributes in HTML elements)</a></li><li><a href="#05-giam-so-luong-file-css">Giảm số lượng file CSS (Combine external CSS)</a></li><li><a href="#06-giam-kich-thuoc-file-css">Giảm kích thước file CSS</a></li><li><a href="#07-ap-dung-ky-thuat-oocss">Áp dụng OOCSS (Object Oriented CSS)</a></li><li><a href="#08-to-chuc-class-va-id-mot-cach-khoa-hoc">Đặt tên class và id một cách khoa học</a></li><li><a href="#09-ngon-ngu-tien-xu-ly-css">Ngôn ngữ tiền xử lý CSS (CSS Preprocessor)</a></li><li><a href="#10-gioi-thieu-so-luoc-koala-app">Sử dụng Koala-app khi làm việc với CSS</a></li></ol><h2 id="1-Han-che-su-dung-import"><a href="#1-Han-che-su-dung-import" class="headerlink" title="1. Hạn chế sử dụng @import"></a>1. Hạn chế sử dụng @import</h2><p>Hạn chế sử dụng @import hoặc tốt nhất là không nên sử dụng @import trong file CSS, vì nó sẽ <strong>làm chậm quá trình tải</strong> và <strong>không sử dụng được khả năng tải file đồng thời của browser</strong>. Để dễ hiểu bạn hãy xem ví dụ sau:</p><p>Mình có 2 file CSS là a.css và b.css được nhúng vào trang web như sau:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'a.css'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'b.css'</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Trong file b.css, bạn import file c.css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(c.css);</span><br></pre></td></tr></table></figure><p>Kết quả khi browser tải trang sẽ như thế này:</p><p>HTML downloada.cssb.cssc.css</p><p>Chú thích:</p><ul><li>Request 1: browser gửi request để lấy HTML về</li><li>Request 2: browser gửi request để lấy a.css</li><li>Request 3: browser gửi request để lấy b.css</li><li>Request 4: browser gửi request để lấy c.css</li></ul><p>Như các bạn thấy ở hình trên, để tải được c.css thì browser phải chờ để tải xong a.css.</p><p><strong>Lý do</strong>: Vì browser khi đã tải xong b.css và bắt đầu đọc nội dung bên trong thì thấy <strong>@import</strong> yêu cầu phải tải thêm c.css, lúc này browser phải đứng chờ cho nhóm proccess trước đó chạy xong (trong trường hợp này là chờ a.css) thì mới bắt đầu tải tiếp c.css và tiếp tục render sau khi đã tải xong.</p><p>Trong khi đó nếu bạn loại bỏ @import url(c.css) trong b.css đi và nhúng trực tiếp c.css vào trang HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'a.css'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'b.css'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'c.css'</span>&gt;</span></span><br></pre></td></tr></table></figure><p>thì bạn sẽ có kết quả như sau:</p><p>HTML downloada.cssb.cssc.css</p><p>Lúc này browser sẽ bắt đầu tải file đồng thời không cần phải chờ cho a.css tải xong, sẽ rút ngắn được thời gian tải file xuống.</p><p>Như tiêu đề mình nói rằng nên <strong>Hạn chế</strong> sử dụng @import, vậy một câu hỏi nhỏ đặt ra là <strong>khi nào thì nên dùng @import?</strong>.</p><p>Theo mình thì khi <strong>những định nghĩa CSS cần lệ thuộc vào một định nghĩa ở file CSS khác trước – thì khi đó nên dùng @import</strong>, ví dụ bạn sử dụng các bộ thư viện reset CSS như <a href="https://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a>, bạn cần reset tất cả các định nghĩa CSS về một chuẩn chung trước khi viết định nghĩa CSS tiếp theo – lúc này bạn sẽ dùng @import để import file Normalize.css vào trong file định nghĩa CSS của bạn, lý do sử dụng @import ở đây là để tránh cơ chế tải file đồng thời của browser và bắt buộc browser phải tải và áp định nghĩa CSS của Normalize.css trước rồi mới đến các định nghĩ CSS ở bên dưới @import.</p><p>Một câu hỏi tiếp theo <strong>Nếu nhất thiết phải dùng @import như ví dụ trên, thì các nào khác để giải quyết thay vì dùng @import hay không?</strong>.</p><p>Tất nhiên là có cách, đó là bạn copy toàn bộ nội dung của file Normalize.css vào trong file CSS của bạn, hay còn gọi là <strong>Combine external CSS</strong> mình sẽ giới thiệu phía bên dưới.</p><h2 id="2-Su-dung-cach-viet-ngan-gon"><a href="#2-Su-dung-cach-viet-ngan-gon" class="headerlink" title="2. Sử dụng cách viết ngắn gọn"></a>2. Sử dụng cách viết ngắn gọn</h2><p>Sử dụng cách viết ngắn gọn (shorthand properties) để dễ dàng thiết lập một số thuộc tính chỉ trên một dòng, đây cũng là một cách để bạn dễ dàng kiểm soát – theo dõi code của mình, đồng thời cũng hỗ trợ giảm số lượng ký tự trong file css và giảm kích thước file.</p><p>Lấy ví dụ đơn giản về cách thiết lập thuộc tính hình ảnh cho background</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>:<span class="selector-id">#000</span>;</span><br><span class="line"><span class="selector-tag">background-image</span><span class="selector-pseudo">:url(bg-image.jpg)</span>;</span><br><span class="line"><span class="selector-tag">background-repeat</span><span class="selector-pseudo">:no-repeat</span>;</span><br><span class="line"><span class="selector-tag">background-attachment</span><span class="selector-pseudo">:fixed</span>;</span><br><span class="line"><span class="selector-tag">background-position</span><span class="selector-pseudo">:center</span> <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure><p>Bạn có thể viết thành</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>:<span class="selector-id">#000</span> <span class="selector-tag">url</span>(<span class="selector-tag">bg-image</span><span class="selector-class">.jpg</span>) <span class="selector-tag">no-repeat</span> <span class="selector-tag">fixed</span> <span class="selector-tag">center</span> <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure><p>Cấu trúc shorthand của thuộc tính background như sau</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: &lt;<span class="selector-tag">color</span>&gt; &lt;<span class="selector-tag">image</span>&gt; &lt;<span class="selector-tag">repeat</span>&gt; &lt;<span class="selector-tag">attachment</span>&gt; &lt;<span class="selector-tag">position</span>&gt;;</span><br></pre></td></tr></table></figure><p>Ngoài background thì còn có một số thuộc tính khác cũng có thể sử dụng shorthand như margin, padding, border, outline, … bạn có thể tham khảo thêm trên <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Shorthand_properties" target="_blank" rel="noopener">Mozilla Developer Network (MDN)</a>. Ở cuối trang này có danh sách các thuộc tính có thể áp dụng shorthand.</p><p>Bên cạnh đó, nếu bạn thích khai báo mã màu HEX thì đối với một số mã màu thông dụng bạn cũng có thể viết ngắn gọn lại ví dụ như #FFF thay cho #FFFFFF hay #000 thay cho #000000. Bạn có thể tham khảo cách chuyển đổi tại <a href="http://maettig.com/?page=PHP/CSS_Color_Converter" target="_blank" rel="noopener">CSS Color Converter</a>.</p><h2 id="3-Khai-bao-class-bo-tro"><a href="#3-Khai-bao-class-bo-tro" class="headerlink" title="3. Khai báo class bổ trợ"></a>3. Khai báo class bổ trợ</h2><p>Class bổ trợ (Helper classes) là những class được định nghĩa sẵn một số thuộc tính đơn giản và thường hay sử dụng. Ví dụ như text-align, font-weight, color… Class bổ trợ trong quá trình viết HTML các bạn chỉ cần thêm class đó vào mà không cần phải định nghĩa lại thuộc tính. Cách làm này khá hữu dụng khi bạn sử dụng một CSS framework và cần custom “rất ít” thuộc tính, hoặc bạn không chọn được tên class phù hợp cho element đó, hay element đó không cần xác định class để làm gì đó với javascript.</p><p>Điểm lợi của việc này ngoài việc bạn không cần định nghĩa lại một số thuộc tính không cần thiết, thì nếu CSS càng nhiều thì bạn sẽ tiết kiệm được khá nhiều thuộc tính cần khai báo lại và sẽ giảm được kích thước file CSS. Ví dụ:</p><p>Mình có các element sau cần viết CSS và mình đang dùng framework bootstrap:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-success btn-md text-uppercase"</span>&gt;</span></span><br><span class="line">    Show More</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Thay vì mình cần phải viết CSS như sau để custom lại theo ý mình</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">text-align</span>: center; <span class="attribute">padding-top</span>: <span class="number">20px</span>; &#125;</span><br><span class="line"><span class="selector-tag">p</span> &gt; <span class="selector-tag">button</span> &#123; <span class="attribute">background-color</span>: <span class="number">#fff</span>; <span class="attribute">padding-right</span>: <span class="number">30px</span>; <span class="attribute">padding-left</span>: <span class="number">30px</span> &#125;</span><br></pre></td></tr></table></figure><p>Thì mình sẽ khai báo class bổ trợ để có thể tái sử dụng cho nhiều trường hợp khác về sau ( Những class có sẵn của bootstrap mình sẽ không liệt kê vào, vì hiện giờ mình cần custom các element này )</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.padding-top-20</span> &#123; <span class="attribute">padding-top</span>: <span class="number">20px</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-30</span> &#123; <span class="attribute">padding-right</span>: <span class="number">30px</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-30</span> &#123; <span class="attribute">padding-left</span>: <span class="number">30px</span>; &#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.btn-bg-white</span> &#123; <span class="attribute">background-color</span>: <span class="number">#fff</span>; &#125;</span><br></pre></td></tr></table></figure><p>Như vậy trong HTML mình sẽ khai báo như sau</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-center padding-top-20"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-success btn-md btn-bg-white text-uppercase padding-right-30 padding-left-30"</span>&gt;</span>Show More<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Như vậy thì về sau những class này mình có thể tái sử dụng rất nhiều lần ở rất nhiều element, và mình có thể bỏ đi khá nhiều công đoạn phải gõ lại code CSS khi có phát sinh thêm element mới.</p><p>Điều này mình học hỏi từ bootstrap và cảm thấy nó khá là hay. Bạn có thể tham khảo thêm các <a href="https://getbootstrap.com/css/#helper-classes" target="_blank" rel="noopener">helper class</a> hoặc <a href="https://getbootstrap.com/css/#type" target="_blank" rel="noopener">typography</a> của bootstrap để hiểu rõ hơn.</p><h2 id="4-Han-che-su-dung-Inline-CSS-trong-cac-elements"><a href="#4-Han-che-su-dung-Inline-CSS-trong-cac-elements" class="headerlink" title="4. Hạn chế sử dụng Inline CSS trong các elements"></a>4. Hạn chế sử dụng Inline CSS trong các elements</h2><p>Ở đây, mình chỉ khuyên các bạn nên hạn chế sử dụng, vì điều này sẽ làm các bạn khó kiểm soát code CSS của mình. “Vạn bất đắc dĩ” cần giải quyết nhanh (hotfix) thì hãy dùng hoặc nếu chỉ dùng một lần hoặc là CSS động từ javascript thì có thể chấp nhận được.</p><p>Theo như <a href="https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery#CSSattributes" target="_blank" rel="noopener">Google Pagespeed Insights</a> thì việc này sẽ làm code bị lặp lại không cần thiết và vi phạm <a href="https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery#CSSattributes" target="_blank" rel="noopener">Chính sách Bảo mật Nội dung của W3</a>, trong một số trường hợp thì các attribute này sẽ bị chặn.</p><h2 id="5-Giam-so-luong-file-CSS"><a href="#5-Giam-so-luong-file-CSS" class="headerlink" title="5. Giảm số lượng file CSS"></a>5. Giảm số lượng file CSS</h2><p>Gom các file CSS lại với nhau (Combine external CSS) là việc dễ làm nhất, thay vì phải viết thành nhiều file như header.css, navigation.css, footer.css… vào trong văn bản HTML thì bạn hãy gom các file này thành một file duy nhất. Nội dung file này sẽ chứa toàn bộ nội dung của các file trên, như vậy bạn sẽ giảm được nhiều request đến server và giảm tải cho server khá nhiều.</p><p>Thay vì sử dụng như vầy</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/header.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/navigation.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/footer.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Nên gom chúng lại thành</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/style.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-Giam-kich-thuoc-file-CSS"><a href="#6-Giam-kich-thuoc-file-CSS" class="headerlink" title="6. Giảm kích thước file CSS"></a>6. Giảm kích thước file CSS</h2><p>Giảm kích thước file CSS được thực hiện bằng cách loại bỏ các khoảng trắng không cần thiết, dấu xuống hàng, dấu chấm phẩy cuối cùng trong class hoặc id… Công đoạn này còn được gọi là <strong>minify</strong>. Để tiện phân biệt giữa file chưa minify và file đã minify thì bạn nên thêm <strong>.min</strong> vào tên file đã minify. Ví dụ style.css sau khi minify sẽ thành style.min.css.</p><p>Bạn có thể truy cập vào <a href="http://www.cleancss.com/css-minify/" target="_blank" rel="noopener">Clean CSS</a> để thực hiện minify css hoặc sử dụng tool Koala-app mình sẽ giới thiệu bên dưới để tự động xuất file minify trong quá trình viết code.</p><h2 id="7-Ap-dung-ky-thuat-OOCSS"><a href="#7-Ap-dung-ky-thuat-OOCSS" class="headerlink" title="7. Áp dụng kỹ thuật OOCSS"></a>7. Áp dụng kỹ thuật OOCSS</h2><p><strong>OOCSS</strong> (Object Oriented CSS) – CSS hướng đối tượng, thật ra hướng đối tượng ở đây có nghĩa là bạn gom các thuộc tính giống nhau của 2 class cùng áp dụng cho một element thành một class để giảm thiểu sự lặp lại. Ví dụ:</p><p>Thay vì khai báo 2 class cho button như sau</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.42857143</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#337ab7</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#2e6da4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.btn-success</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.42857143</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mình sẽ gom một số thuộc tính của 2 class này thành một class khác có tên là btn:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.42857143</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#337ab7</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#2e6da4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.btn-success</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Như vậy nếu sau này có thay đổi gì về một số thuộc tính chung của 2 class thì mình chỉ cần thay đổi class btn thì sẽ dễ dàng và nhanh hơn.</p><h2 id="8-To-chuc-class-va-id-mot-cach-khoa-hoc"><a href="#8-To-chuc-class-va-id-mot-cach-khoa-hoc" class="headerlink" title="8. Tổ chức class và id một cách khoa học"></a>8. Tổ chức class và id một cách khoa học</h2><p>Việc này để hỗ trợ bạn sau này khi xem lại code của mình dễ dàng hơn và không bị rối với cách đặt tên của mình, đồng thời cũng dễ dàng nếu có áp dụng một số CSS preprocessor hay BEM.</p><p>Thay vì đặt tên</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.titlepost</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.headerpost</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.contentpost</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>thì nên đặt thành</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post-title</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post-header</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post-content</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>hoặc tổ chức thành</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post</span> &gt; <span class="selector-class">.title</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post</span> &gt; <span class="selector-class">.header</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post</span> &gt; <span class="selector-class">.content</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="9-Ngon-ngu-tien-xu-ly-CSS"><a href="#9-Ngon-ngu-tien-xu-ly-CSS" class="headerlink" title="9. Ngôn ngữ tiền xử lý CSS"></a>9. Ngôn ngữ tiền xử lý CSS</h2><p><strong>Tiền xử lý CSS</strong> (CSS Preprocessor) – là một cách mở rộng của CSS hoặc cũng có thể coi nó là một ngôn ngữ riêng. Mục đích của CSS preprocessor là để bạn dễ dàng cấu trúc các đoạn code CSS, giảm thời gian phải viết đi viết lại một đoạn code, dễ dàng áp dụng OOCSS… Nói cách khác bạn có thể hiểu CSS preprocessor gần như là một ngôn ngữ lập trình vì nó cũng có biến, kế thừa class, và dễ dàng tạo ra một thư viện riêng cho bạn quản lý, kế thừa và tái sử dụng ở những dự án khác.</p><p>CSS preprocessor hiện nay có rất nhiều nhưng phổ biến nhất hiện nay là <a href="http://lesscss.org/" target="_blank" rel="noopener"><strong>Less</strong></a> và <a href="http://sass-lang.com/" target="_blank" rel="noopener"><strong>Sass.</strong></a> Ở đây mình giới thiệu các bạn về Sass vì mình đang sử dụng nó thay cho Less, và CSS framework phổ biến – <a href="https://blog.getbootstrap.com/2015/08/19/bootstrap-4-alpha/" target="_blank" rel="noopener">Bootstrap, kể từ phiên bản 4 đã chuyển từ Less qua Sass</a>. Về Sass các bạn xem <a href="http://sass-lang.com/install" target="_blank" rel="noopener">hướng dẫn cài đặt trên trang chủ</a>.</p><p>Khi bắt đầu với một dự án có áp dụng Sass, việc đầu tiên mình thường làm là cấu trúc CSS thành nhiều file nhỏ để tránh nhồi nhét CSS vào một file và dễ dàng cho việc quản lý, tìm kiếm khi cần thiết. Mình thường cấu trúc các file Sass như sau:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scss</span><br><span class="line">|-- style.scss</span><br><span class="line">|-- _variable.scss</span><br><span class="line">|-- _helper.scss</span><br><span class="line">|-- _mixins.scss</span><br><span class="line">|-- components</span><br><span class="line">|-- -- _header.scss</span><br><span class="line">|-- -- _footer.scss</span><br><span class="line">|-- mixins</span><br><span class="line">|-- -- button.scss</span><br><span class="line">|-- -- label.scss</span><br></pre></td></tr></table></figure><p>Trong file style.scss nội dung như sau:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"variable"</span>;</span><br><span class="line">@impprt <span class="string">"helper"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"mixins"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Components</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"components/header"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"components/footer"</span>;</span><br></pre></td></tr></table></figure><p>Chú thích:</p><ul><li>_variable.scss: variable chứa các thông tin về các biến dùng chung</li><li>_helper.scss: helper sẽ chứa/import các class helper</li><li>_mixins.scss: mixins sẽ chứa/import các class custom hoặc class được tái sử dụng nhiều lần</li></ul><p>Nội dung file _helper.scss như mình đã nói sẽ tạo ra các class helper, nhưng ở đây mình áp dụng tính chất của Scss để tạo ra các class với ít dòng code nhất:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$numbersPX</span>:</span><br><span class="line">  <span class="string">"10"</span> <span class="number">10px</span>,</span><br><span class="line">  <span class="string">"15"</span> <span class="number">15px</span>,</span><br><span class="line">  <span class="string">"20"</span> <span class="number">20px</span>,</span><br><span class="line">  <span class="string">"25"</span> <span class="number">25px</span>,</span><br><span class="line">  <span class="string">"30"</span> <span class="number">30px</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// padding</span></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$i</span> in <span class="variable">$numbersPX</span>&#123;</span><br><span class="line">  <span class="selector-class">.padding-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.padding-top-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.padding-bottom-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.padding-right-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-right</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.padding-left-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>khi Sass complier ra file CSS thì mình sẽ thu được kết quả như sau</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.padding-10</span> &#123; <span class="attribute">padding</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-10</span> &#123; <span class="attribute">padding-top</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-10</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-10</span> &#123; <span class="attribute">padding-right</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-10</span> &#123; <span class="attribute">padding-left</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-15</span> &#123; <span class="attribute">padding</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-15</span> &#123; <span class="attribute">padding-top</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-15</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-15</span> &#123; <span class="attribute">padding-right</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-15</span> &#123; <span class="attribute">padding-left</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-20</span> &#123; <span class="attribute">padding</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-20</span> &#123; <span class="attribute">padding-top</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-20</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-20</span> &#123; <span class="attribute">padding-right</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-20</span> &#123; <span class="attribute">padding-left</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-25</span> &#123; <span class="attribute">padding</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-25</span> &#123; <span class="attribute">padding-top</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-25</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-25</span> &#123; <span class="attribute">padding-right</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-25</span> &#123; <span class="attribute">padding-left</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-30</span> &#123; <span class="attribute">padding</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-30</span> &#123; <span class="attribute">padding-top</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-30</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-30</span> &#123; <span class="attribute">padding-right</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-30</span> &#123; <span class="attribute">padding-left</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="10-Gioi-thieu-so-luoc-Koala-App"><a href="#10-Gioi-thieu-so-luoc-Koala-App" class="headerlink" title="10. Giới thiệu sơ lược Koala App"></a>10. Giới thiệu sơ lược Koala App</h2><p><a href="http://koala-app.com" target="_blank" rel="noopener">Koala app</a> là một ứng dụng GUI hỗ trợ biên dịch Less, Sass, Compass và CoffeeScript sang CSS và JS. Koala App chạy được trên cả 3 môi trường Mac OS, Linux và Windows nên rất tiện nếu bạn cần thay đổi qua lại giữa các hệ điều hành. Ngoài ra, Koala App còn hỗ trợ minify cho cả CSS và JS.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2016/01/image01-700x453.png" alt=""></p><p>Sử dụng Koala App rất đơn giản, bạn chỉ cần mở lên và ấn dấu + trên đầu chương trình để chọn thư mục chứa các file cần xử lý, và Koala App sẽ tự động scan toàn bộ các folder bên trong và theo dõi khi có thay đổi.</p><p>Nếu bạn “siêng” thì có thể tham khảo cách để tự cấu hình project để Koala-app hoạt động theo ý mình <a href="https://github.com/oklai/koala/wiki/Using-project-settings" target="_blank" rel="noopener">tại đây</a>.</p><p>Trên đây là những mẹo CSS rút ra từ kinh nghiệm làm việc của mình. Nếu bạn còn những mẹo hay khác thì đừng ngại chia sẻ bên dưới nhé.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Pagespeed Optimization&lt;/strong&gt; (tối ưu hóa tốc độ trang) là một công việc mà hầu như mọi Web developer đều quan tâm và nên biết, mục đích của nó là đưa nội dung website đến với người xem nhanh nhất có thể.&lt;/p&gt;
&lt;p&gt;Front-end developer thường làm việc với HTML, CSS, Javascript và các hình ảnh. Do đó, đây cũng là các đối tượng chính để chúng ta tối ưu tốc độ tải trang cho website. Tốc độ tải trang của website ngoài các yếu tố liên quan do server thì còn phụ thuộc vào kích thước và số lượng file phải tải về, do đó càng giảm được kích thước file lẫn số lượng file cần phải tải về thì cũng đồng thời tăng tốc độ tải file và giảm số lượng request lên server.&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://nthung2112.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Tối ưu hiệu suất render để website mượt hơn</title>
    <link href="http://nthung2112.github.io/2018/06/Toi-uu-hieu-suat-render-de-website-muot-hon.html"/>
    <id>http://nthung2112.github.io/2018/06/Toi-uu-hieu-suat-render-de-website-muot-hon.html</id>
    <published>2018-06-26T00:50:00.000Z</published>
    <updated>2018-06-27T01:12:25.692Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Optimizing Performance</strong> (tối ưu hóa hiệu suất) cho website là một công việc mà bất kỳ front-end developer nào cũng nên biết, mục đích là để trang web đáp ứng được 3 tiêu chí:</p><ol><li><strong>NHẸ</strong>: Giảm kích thước trang web và các thành phần đi kèm như javascript, css, hình ảnh… nhằm đảm bảo <strong>thời gian tải xuống ngắn hơn</strong>. Chúng ta có thể dùng các bộ minify cho javascript, css…, nén các tập tin hình ảnh, font chữ, svg… ngoài ra còn có các kĩ thuật như code splitting, browser caching, HTTP caching…</li><li><strong>NHANH</strong> <strong>Hiển thị nội dung trang web càng sớm càng tốt</strong> bằng cách: chia cấu trúc DOM hợp lý, hạn chế blocking CSS/JS, hạn chế chỉnh sửa DOM tree, chia các file ra thành nhiều module, tải resource bất đồng bộ, tối ưu hóa các selector của CSS và JS…</li><li><strong>MƯỢT</strong>: Sau khi nội dung trang web đã được tải về và hiển thị thì việc tiếp theo là <strong>bảo đảm các hiệu ứng animation, transition, scrolling… phải mượt</strong>, không bị lag và giật (jank).</li></ol><a id="more"></a><p>Trong 3 tiêu chí này, có 2 tiêu chí mà front-end developer chúng ta hằng ngày đều thực hiện là <strong>nhẹ và nhanh</strong>. Bằng cách sử dụng các framework (angularjs, reactjs…) và các bộ build tool (grunt, gulp, webpack…), các resource trong project ở môi trường production lúc nào cũng được minify và đóng gói đầy đủ, gọn gàng.</p><p>Do đó, trong bài này tôi sẽ hướng dẫn cho bạn cách đáp ứng được tiêu chí thứ 3, đó là <strong>MƯỢT</strong>, thứ mà ít có framework hay công cụ nào có thể hỗ trợ bạn được.</p><p> <a href="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image05.png" target="_blank" rel="noopener"><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image05-700x455.png" alt=""></a> </p><p>Trên thực tế, các web page yêu cầu độ mượt cao thường là các webpage có nhiều hiệu ứng, chuyển động, ví dụ như các trang landing page, giới thiệu sản phẩm, HTML5 game, hoặc các ứng dụng có animation chạy trên các thiết bị có cấu hình thấp. Bạn có thể xem qua một số trang sau:</p><ul><li><a href="http://world.mathigon.org/" target="_blank" rel="noopener">http://world.mathigon.org/</a></li><li><a href="http://matthew.wagerfield.com/parallax/" target="_blank" rel="noopener">http://matthew.wagerfield.com/parallax/</a></li></ul><h2 id="Lam-the-nao-de-web-page-“muot”"><a href="#Lam-the-nao-de-web-page-“muot”" class="headerlink" title="Làm thế nào để web page “mượt”?"></a>Làm thế nào để web page “mượt”?</h2><p>Mượt ở đây chính là “Rendering Performance”, để tối ưu hiệu suất render chúng ta phải hiểu được quá trình render của browser.</p><h3 id="60"><a href="#60" class="headerlink" title="60"></a>60</h3><p>… là số khung hình trên một giây mà các thiết bị phổ biến hiện nay hỗ trợ (60fps). Để cho trang web mượt thì tốc độ render phải đáp ứng được con số này. Tức là trong <strong>1 giây</strong> chúng ta phải cho ra <strong>60 khung hình</strong>. Với mỗi khung hình, chúng ta có 1 / 60 = 16,66 mili giây. Trên thực tế, browser còn có một số tác vụ khác phải làm bên cạnh việc render, vì thế chúng ta trừ hao còn lại khoảng 16ms.</p><p>Bất cứ animation hay transition nào, muốn đảm bảo được tốc độ 60fps thì phải cũng phải đảm bảo trong vòng <strong>16ms phải render được một khung hình</strong>, nếu không thì sẽ bị hiện tượng “frame skip”, hiệu ứng sẽ bị giật, lag.</p><h3 id="Can-phai-lam-nhung-gi-trong-16ms-do"><a href="#Can-phai-lam-nhung-gi-trong-16ms-do" class="headerlink" title="Cần phải làm những gì trong 16ms đó?"></a>Cần phải làm những gì trong 16ms đó?</h3><p>Để cho ra được 1 khung hình, đây là các việc mà browser phải thực hiện (<strong>the pixel pipeline</strong>):</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image19-700x107.png" alt=""></p><p>Giải thích ngắn gọn:</p><p><strong>1. JavaScript</strong>: là hoạt động execute code của javascript.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'my-element'</span>).style.width = <span class="string">'300px'</span>;</span><br></pre></td></tr></table></figure><p><strong>2. Style calculation</strong>: tính toán các thuộc tính theo các quy tắc từ file CSS (hoặc thẻ <code>&lt;style&gt;</code>, thuộc tính style).</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'my-element'</span> <span class="attr">style</span>=<span class="string">'width: 300px'</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3. Layout</strong>: browser thực hiện “chia vùng” cho các element khi hiển thị trên màn hình, dựa trên các thuộc tính đã tính toán được từ bước Style.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image28.png" alt=""></p><p><strong>4. Paint</strong>: tô màu cho từng pixel, bao gồm việc: vẽ chữ (render font), hình ảnh, màu, vẽ các hiệu ứng CSS như border, box-shadow… Việc tô màu này được thực hiện trên nhiều “layer” cùng một lúc (phần sau sẽ giải thích rõ hơn về layer). Đây là bước chiếm nhiều thời gian nhất.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image23.png" alt=""></p><p><strong>5. Composite</strong>: gộp các layer đã được vẽ (ở bước Paint) và hiển thị lên màn hình theo đúng thứ tự của các layer đó.</p><p>Như vậy, chỉ với 16ms browser phải thực hiện 5 bước như trên để có thể render ra được 1 khung hình. Vậy để đảm bảo mọi thứ đều hoàn thành dưới 16ms, việc chúng ta cần làm là tối ưu từng bước. Cụ thể là:</p><ul><li><p><strong>JavaScript:</strong></p><ul><li>Dùng requestAnimationFrame.</li><li>Dùng Web workers, Micro-task cho các tác vụ nặng.</li><li>Profiling with Chrome DevTools.</li></ul></li><li><p><strong>Style:</strong></p><ul><li>Giảm độ phức tạp của selector</li><li>Giảm số lượng element bị ảnh hưởng</li></ul></li><li><p><strong>Layout:</strong></p><ul><li>Hạn chế kích hoạt layout</li><li>Sử dụng Flexbox</li><li>Hạn chế forced synchronous layout.</li></ul></li><li><p><strong>Paint:</strong></p><ul><li>Paint là tác vụ xử lý lâu nhất</li><li>Box-shadow, large image không tốt cho paint</li><li>Tạo và quản lý layer hợp lý</li></ul></li><li><p><strong>Composite:</strong></p><ul><li>Sử dụng transform và opacity</li><li>Quản lý các layer bằng Chrome DevTools</li></ul></li></ul><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image22-250x203.png" alt=""></p><h2 id="Tung-buoc-toi-uu-hieu-suat-render"><a href="#Tung-buoc-toi-uu-hieu-suat-render" class="headerlink" title="Từng bước tối ưu hiệu suất render"></a>Từng bước tối ưu hiệu suất render</h2><h3 id="Buoc-1-Javascript"><a href="#Buoc-1-Javascript" class="headerlink" title="Bước 1: Javascript"></a>Bước 1: Javascript</h3><h4 id="1-1-Su-dung-requestAnimationFrame-de-thuc-hien-cac-thay-doi-tren-UI"><a href="#1-1-Su-dung-requestAnimationFrame-de-thuc-hien-cac-thay-doi-tren-UI" class="headerlink" title="1.1. Sử dụng requestAnimationFrame để thực hiện các thay đổi trên UI."></a>1.1. Sử dụng requestAnimationFrame để thực hiện các thay đổi trên UI.</h4><p>Khi thực hiện các thay đổi trên UI bằng JavaScript, bạn sẽ muốn thực hiện nó ngay vào lúc bắt đầu của frame, lúc đó browser sẽ có được toàn bộ 16ms để thực hiện các thay đổi (JavaScript ⇒ Style ⇒ Layout ⇒ Paint ⇒ Composite). Để làm được điều này bạn cần dùng hàm requestAnimationFrame. Hàm này có chức năng “hẹn giờ” chạy vào đúng thời điểm của frame tiếp theo.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If run as a requestAnimationFrame callback, this</span></span><br><span class="line"><span class="comment"> * will be run at the start of the frame.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateScreen</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Make visual updates here.</span></span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(updateScreen);</span><br></pre></td></tr></table></figure><p>Một số đoạn code trên mạng hoặc trong các framework thường sử dụng hàm setTimeout, tuy nhiên hàm được gọi bởi setTimeout sẽ không khởi chạy lúc bắt đầu frame, dẫn đến việc không tận dụng hết được khoảng thời gian 16ms, do đó gây ra hiện tượng frame skip, gây giật, lag.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image071-700x300.png" alt=""></p><h4 id="1-2-Chuyen-cac-tac-vu-nang-sang-Web-workers"><a href="#1-2-Chuyen-cac-tac-vu-nang-sang-Web-workers" class="headerlink" title="1.2. Chuyển các tác vụ nặng sang Web workers"></a>1.2. Chuyển các tác vụ nặng sang Web workers</h4><p>Đối với các tác vụ nặng như encode/decode, xử lý dữ liệu lớn… chúng ta nên chuyển tác vụ đó sang <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage" target="_blank" rel="noopener">Web Workers</a>. Web Workers hoạt động trên một thread riêng biệt, sẽ giúp giảm tải cho UI Thread và giúp tiết kiệm được thời gian xử lý.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSortWorker = <span class="keyword">new</span> Worker(<span class="string">"sort-worker.js"</span>);</span><br><span class="line">dataSortWorker.postMesssage(dataToSort);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The main thread is now free to continue working on other things...</span></span><br><span class="line"> </span><br><span class="line">dataSortWorker.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sortedData = evt.data;</span><br><span class="line">  <span class="comment">// Update data on screen...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Tuy nhiên, Web Workers không thể tương tác với DOM tree, do đó một số tác vụ không thể chuyển qua Web Workers được. Trong trường hợp này ta có thể áp dụng phương pháp “micro-task”: chia nhỏ task ra, sau đó sử dụng requestAnimationFrame để cập nhật UI. Lúc này, nếu mỗi task nhỏ có thời gian thực thi bé hơn 16ms thì sẽ tránh được hiện tượng giật, lag như khi chạy cả task lớn.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskList = breakBigTaskIntoMicroTasks(monsterTaskList);</span><br><span class="line">requestAnimationFrame(processTaskList);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processTaskList</span>(<span class="params">taskStartTime</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> taskFinishTime;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">   <span class="comment">// Assume the next task is pushed onto a stack.</span></span><br><span class="line">   <span class="keyword">var</span> nextTask = taskList.pop();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Process nextTask.</span></span><br><span class="line">   processTask(nextTask);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Go again if there’s enough time to do the next task.</span></span><br><span class="line">   taskFinishTime = <span class="built_in">window</span>.performance.now();</span><br><span class="line"> &#125; <span class="keyword">while</span> (taskFinishTime - taskStartTime &lt; <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (taskList.length &gt; <span class="number">0</span>)</span><br><span class="line">   requestAnimationFrame(processTaskList);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Su-dung-Chrome-DevTools-de-“dieu-tra”-JavaScript-execution"><a href="#1-3-Su-dung-Chrome-DevTools-de-“dieu-tra”-JavaScript-execution" class="headerlink" title="1.3. Sử dụng Chrome DevTools để “điều tra” JavaScript execution"></a>1.3. Sử dụng Chrome DevTools để “điều tra” JavaScript execution</h4><p>Chrome DevTools là công cụ cực kỳ hữu ích. Ở tab “Timeline” của Chrome DevTools, bạn có thể kiểm tra được độ mượt của web page bằng cách:</p><ol><li>Nhấn nút Record (hoặc Ctrl + R trên Windows, Command + R trên Mac)</li><li>Thực hiện animation / transition trên trang web chính</li><li><p>Nhấn nút Stop Record.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image24-700x515.png" alt=""></p></li></ol><p>Chrome DevTools sẽ hiển thị toàn bộ các thông tin liên quan đến các tác vụ JavaScript ⇒ Style ⇒ Layout ⇒ Paint ⇒ Composite. Bạn có thể kiếm tra để xem tác vụ nào chiếm nhiều thời gian nhất và gây ra frame skip.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image06.png" alt=""></p><h3 id="Buoc-2-Style-calculation"><a href="#Buoc-2-Style-calculation" class="headerlink" title="Bước 2: Style calculation"></a>Bước 2: Style calculation</h3><p>Cố gắng giữ cho selector của bạn càng đơn giản càng tốt, và giảm số lượng element bị ảnh hưởng bởi selector, ví dụ:</p><p>Nên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123; <span class="comment">/* styles */</span> &#125;</span><br></pre></td></tr></table></figure><p>Không nên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:nth-last-child(-n+1)</span> <span class="selector-class">.title</span> &#123; <span class="comment">/* styles */</span> &#125;</span><br></pre></td></tr></table></figure><p>Không nên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*, *<span class="selector-pseudo">:before</span>, *<span class="selector-pseudo">:after</span> &#123; <span class="comment">/* styles */</span> &#125;</span><br></pre></td></tr></table></figure><p>Nên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="comment">/* styles */</span> &#125;</span><br></pre></td></tr></table></figure><p>Việc sử dụng các selector này cần phải cân bằng giữa việc code gọn gàng đẹp đẽ và hiệu suất. Khi sử dụng các selector phức tạp thì browser cần phải thực hiện nhiều tính toán, nhưng nếu chỉ sử dụng các selector đơn giản thì lại khiến code của chúng ta khó quản lý.</p><p>Giải pháp ở đây là chúng ta nên sử dụng một số kỹ thuật quản lý style như: <a href="https://bem.info/" target="_blank" rel="noopener">BEM (Block, Element, Modifier)</a>, <a href="https://github.com/postcss/postcss" target="_blank" rel="noopener">PostCSS</a>. Các công cụ này sẽ giúp chúng ta vừa dễ quản lý code CSS ở môi trường dev, và cũng vừa đảm bảo hiệu suất ở môi trường production sau khi build.</p><h3 id="Buoc-3-Layout"><a href="#Buoc-3-Layout" class="headerlink" title="Bước 3: Layout"></a>Bước 3: Layout</h3><h4 id="3-1-Han-che-kich-hoat-tinh-toan-layout"><a href="#3-1-Han-che-kich-hoat-tinh-toan-layout" class="headerlink" title="3.1. Hạn chế kích hoạt tính toán layout"></a>3.1. Hạn chế kích hoạt tính toán layout</h4><p>Việc thay đổi một số thuộc tính CSS của element có thể kích hoạt browser tính toán lại layout của element đó.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Changing width and height</span></span><br><span class="line"><span class="comment"> * triggers layout.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-class">.box--expanded</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">350px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Khi một element bị thay đổi layout thì thường là các element khác cũng sẽ bị thay đổi theo (kích thước, vị trí…). Do đó nếu trang của bạn có nhiều element và việc kích hoạt layout diễn ra quá thường xuyên thì hoàn toàn không tốt cho performance.</p><p>Bạn có thể sử dụng Chrome DevTools để kiểm tra xem web page của bạn có bị kích hoạt layout quá nhiều hay không.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image02-700x489.png" alt=""></p><p>Ví dụ trong hình này, bạn có thể thấy sự kiện Layout chiếm tới 20.636ms, vượt qua con số 16ms và tất nhiên là sẽ dẫn đến frame skip, số lượng element cần tính toán lại layout là 1618 (rất nhiều).</p><p>Để biết được những thuộc tính nào sẽ kích hoạt Layout (và lý do vì sao), bạn có thể tra cứu ở trang <a href="http://csstriggers.com/" target="_blank" rel="noopener">http://csstriggers.com/</a> – công cụ do một Googler viết cho mục đích tra cứu.</p><h4 id="3-2-Su-dung-cac-thuoc-tinh-moi-cua-CSS3"><a href="#3-2-Su-dung-cac-thuoc-tinh-moi-cua-CSS3" class="headerlink" title="3.2. Sử dụng các thuộc tính mới của CSS3"></a>3.2. Sử dụng các thuộc tính mới của CSS3</h4><p>CSS3 có cung cấp một số thuộc tính mới không những giúp chúng ta canh chỉnh layout dễ hơn mà còn giúp tăng hiệu suất rất nhiều. Điển hình là Flexbox, việc sử dụng flexbox để canh chỉnh layout sẽ dễ hơn so với cách dùng float truyền thống.</p><p>Xem bài hướng dẫn tuyệt vời về Flexbox: <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">http://css-tricks.com/snippets/css/a-guide-to-flexbox/</a></p><p>Về hiệu suất, dưới đây là 2 hình ảnh đo hiệu suất của việc kích hoạt layout trên 1300 elements.</p><p>Sử dụng Float:</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image16-700x476.png" alt=""></p><p>Sử dụng Flexbox:</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image14-700x454.png" alt=""></p><p>Có thể thấy con số “Self Time” giảm từ <strong>~14ms</strong> chỉ còn <strong>~3.5ms</strong>, đó là một sự thay đổi rất đáng kể.</p><h4 id="3-3-Han-che-kich-hoat-layout-som"><a href="#3-3-Han-che-kich-hoat-layout-som" class="headerlink" title="3.3. Hạn chế kích hoạt layout sớm"></a>3.3. Hạn chế kích hoạt layout sớm</h4><p>Hãy xem xét đoạn code sau: thay đổi kích thước của 3 elements</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> h1 = element1.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write (invalidates layout)</span></span><br><span class="line">element1.style.height = (h1 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Read (triggers layout)</span></span><br><span class="line"><span class="keyword">var</span> h2 = element2.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write (invalidates layout)</span></span><br><span class="line">element2.style.height = (h2 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Read (triggers layout)</span></span><br><span class="line"><span class="keyword">var</span> h3 = element3.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write (invalidates layout)</span></span><br><span class="line">element3.style.height = (h3 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure><p>Khi một element (DOM) được ghi giá trị mới thì layout sẽ bị đánh dấu <strong>giá trị hết hiệu lực</strong> (invalidates) và sẽ được tính toán lại tại một thời điểm nào đó. Để đảm bảo performance, browser sẽ thực hiện tính toán lại layout vào <strong>thời điểm bắt đầu của frame tiếp theo</strong>.</p><p>Tuy nhiên nếu trong thời gian <strong>frame hiện tại chưa kết thúc</strong>, ta muốn lấy giá trị kích thước của element thì lúc này browser buộc phải thực hiện <strong>tính toán layout lại sớm hơn</strong> so với thông thường để có thể trả về kết quả. Hiện tượng này gọi là “forced synchronous layout” – tạm dịch “kích hoạt layout sớm”, và nó gây ra vấn đề về performance khi ta phải thực hiện nhiều tác vụ hơn trong 1 frame.</p><p>Để giải quyết, cách nhanh nhất là chúng ta sẽ “đọc trước, ghi sau”.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> h1 = element1.clientHeight;</span><br><span class="line"><span class="keyword">var</span> h2 = element2.clientHeight;</span><br><span class="line"><span class="keyword">var</span> h3 = element3.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write (invalidates layout)</span></span><br><span class="line">element1.style.height = (h1 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">element2.style.height = (h2 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">element3.style.height = (h3 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Document reflows at end of frame</span></span><br></pre></td></tr></table></figure><p>Hoặc sử dụng requestAnimationFrame để “hẹn giờ” cho cả 3 thao tác ghi vào frame tiếp theo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> h1 = element1.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write</span></span><br><span class="line">requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> element1.style.height = (h1 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> h2 = element2.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write</span></span><br><span class="line">requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> element2.style.height = (h2 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Bằng cách này, cả 3 thao tác ghi đều sẽ được thực hiện một lần trong frame tiếp theo, tốt hơn cho hiệu suất.</p><p>Bạn sẽ thấy rõ tác dụng của việc hạn chế layout sớm trong một số trường hợp thực tế như sau “Layout thrashing”:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Puts the browser into a read-write-read-write cycle.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">  paragraphs[i].style.width = box.offsetWidth + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Như đoạn code trên, layout sẽ liên tục bị trigger và kích hoạt sớm ở trong vòng lặp (read: box.offsetWidth, và write: paragraphs[i].style.width) điều này là thảm họa cho browser</p><p>(hình: dấu chấm than vàng là báo hiệu <strong>forced synchronous layout</strong>).</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image17.png" alt=""></p><p>Nếu đã biết về vấn đề forced synchronous layout, đoạn code trên nên được viết lại như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read.</span></span><br><span class="line"><span class="keyword">var</span> width = box.offsetWidth;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeAllParagraphsToMatchBlockWidth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">   <span class="comment">// Now write.</span></span><br><span class="line">   paragraphs[i].style.width = width + <span class="string">'px'</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nếu cảm thấy việc quản lý layout quá phức tạp, bạn có thể tham khảo sử dụng thư viện <a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">FastDOM</a>, thư viện này giúp bạn quản lý các tác vụ read/write để đảm bảo không gây ra forced synchronous layout.</p><h3 id="Buoc-4-Paint"><a href="#Buoc-4-Paint" class="headerlink" title="Bước 4: Paint"></a>Bước 4: Paint</h3><h4 id="4-1-Dung-Chrome-Developer-Tools-de-phat-hien-van-de-performance-khi-paint"><a href="#4-1-Dung-Chrome-Developer-Tools-de-phat-hien-van-de-performance-khi-paint" class="headerlink" title="4.1. Dùng Chrome Developer Tools để phát hiện vấn đề performance khi paint"></a>4.1. Dùng Chrome Developer Tools để phát hiện vấn đề performance khi paint</h4><p>Bất kỳ sự thay đổi nào trên màn hình browser đều yêu cầu quá trình paint, animation, transition, lúc bôi đen đoạn text hay cả con trỏ nhấp nháy ở textbox.</p><p>Để biết được browser phải vẽ lại những phần nào trên màn hình, bạn có thể bật chức năng “Show paint rectangles” ở tab “Rendering” trong Chrome Developer Tools.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image18.png" alt=""></p><p>Những vùng bị vẽ lại sẽ được tô và hiển thị màu xanh lá cây trên màn hình.</p><p> <img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image21-700x454.png" alt=""></p><p>Bạn có thể xem chi tiết hoạt động vẽ của browser bằng cách kích hoạt chế độ “Paint profiler” ở tab “Timeline” khi record.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image03.png" alt=""></p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image04.png" alt=""></p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image15-700x454.png" alt=""></p><p>Ở chế độ này, bạn có thể kiểm tra <strong>quá trình vẽ của tất cả các element</strong> trong web page. Dựa vào các thông tin này bạn có thể phân tích và đưa ra hướng giải quyết phù hợp nếu quá trình paint mất quá nhiều thời gian. Một số yếu tố khiến quá trình paint diễn ra chậm:</p><ul><li>Các hiệu ứng CSS phức tạp: box-shadow, gradient, curves</li><li>Các element chồng đè lên nhau.</li><li>Các hình ảnh có kích thước quá lớn</li><li>…</li></ul><h4 id="4-2-Su-dung-hop-ly-cac-layer"><a href="#4-2-Su-dung-hop-ly-cac-layer" class="headerlink" title="4.2. Sử dụng hợp lý các layer"></a>4.2. Sử dụng hợp lý các layer</h4><p>Trên thực tế, quá trình vẽ diễn ra song song trên nhiều các layer khác nhau, việc phân chia các layer hợp lý sẽ giúp tiết kiệm được thời gian vẽ rất nhiều.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image27-700x602.png" alt=""></p><p>Ví dụ trong trường hợp này, khi bạn cuộn trang thì browser phải vẽ lại layer trên cùng (text), còn layer hình bên dưới có vị trí cố định, không có gì thay đổi nên không cần phải vẽ lại nữa. Các layer này sẽ được gộp lại (ở bước cuối cùng – composite) và hiển thị lên màn hình.</p><p><strong>Làm sao để tạo layer?</strong></p><p>Vẽ – Paint – là tác vụ nặng nhất, chiếm nhiều thời gian nhất trong các bước, do đó bạn có thể thấy rõ được lợi ích của việc <strong>phân chia các layer làm sao cho browser ít phải vẽ lại nhất</strong>.</p><p>Một layer (compositor layer) sẽ được tạo khi bạn sử dụng thuộc tính will-change (trên Chrome, Opera, Firefox) thuộc tính này báo hiệu cho browser biết element sẽ có sự thay đổi, do đó sẽ đưa element này vào một layer mới.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moving-element</span> &#123; <span class="attribute">will-change</span>: transform; &#125;</span><br></pre></td></tr></table></figure><p>Đối với các browser không hỗ trợ will-change bạn có thể sử dụng thuộc tính 3D transform để “ép buộc” tạo layer mới:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moving-element</span> &#123; <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0); &#125;</span><br></pre></td></tr></table></figure><p>Cần lưu ý, việc tạo layer mới sẽ yêu cầu thêm bộ nhớ và tác vụ để quản lý các layer, do đó bạn không nên tạo quá nhiều layer, và chiến lược tao layer ở đây không cố định mà còn tùy thuộc vào tính chất của các animation, transition có trên website của bạn.</p><p><strong>Không nên:</strong> (layer explosions – tạo ra quá nhiều layer không cần thiết)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123; </span><br><span class="line"> <span class="attribute">will-change</span>: transform;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Buoc-5-Composite"><a href="#Buoc-5-Composite" class="headerlink" title="Bước 5: Composite"></a>Bước 5: Composite</h2><p>Tại bước này, browser sẽ tiến hành gộp các compositor layer đã được vẽ (ở bước 4) và hiển thị lên màn hình.</p><p>Trường hợp lý tưởng nhất cho performance là bỏ qua 2 bước Layout và Paint, công việc của browser chỉ là thay đổi các compositor layer để tạo ra một frame.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image20-700x107.png" alt=""></p><p>Để làm được điều đó, bạn chỉ được thay đổi các thuộc tính mà Compositor có thể xử lý độc lập (mà không cần phải kích hoạt Layout và Paint). Các thuộc tính đó là <strong>transform</strong> và <strong>opacity</strong>.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image12-700x525.png" alt=""></p><p>Tuy nhiên trên thực tế chúng ta cần phải thay đổi nhiều thuộc tính hơn nữa để đáp ứng được yêu cầu khi animate các hiệu ứng. Do đó, giải pháp chính là phải <strong><span class="c0">tạo và quản lý được các layer một cách hợp lý</span></strong>. Để quản lý được các layer, bạn có thể sử dụng công cụ Chrome Developer Tools.</p><p>Trong tab “Timeline” đánh dấu vào mục Paint</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image26.png" alt=""></p><p>Tiến hành record và chọn phần Paint trên kết quả hiển thị</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image08.png" alt=""></p><p>Ở đây bạn sẽ thấy thẻ “Layer” trong phần thông tin của frame</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image001.png" alt=""></p><p>Từ đây bạn có thể tra cứu toàn bộ các frame mà web page đang có.</p><p> <img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image13-700x525.png" alt=""></p><p>Danh sách các layer được liệt kê dưới dạng cây (layer tree), preview dạng 3D, có thông tin về kích thước, bộ nhớ, lý do layer được tạo…</p><h2 id="Tong-ket"><a href="#Tong-ket" class="headerlink" title="Tổng kết"></a>Tổng kết</h2><p>Như vậy là ta đã đi từng bước để có thể tối ưu hiệu suất render cho web page:</p><ul><li><p><strong>JavaScript</strong><br>   – Dùng requestAnimationFrame<br>   – Dùng Web workers, Micro-task cho tác vụ nặng<br>   – Profiling with Chrome DevTools</p></li><li><p><strong>Style</strong><br>   – Giảm độ phức tạp của selector<br>   – Giảm số lượng element bị ảnh hưởng</p></li><li><p><strong>Layout</strong><br>   – Hạn chế kích hoạt layout<br>   – Sử dụng Flexbox<br>   – Hạn chế forced synchronous layout.</p></li><li><p><strong>Paint</strong><br>   – Paint là tác vụ xử lý lâu nhất<br>   – Box-shadow, large image không tốt cho paint<br>   – Tạo và quản lý layer hợp lý</p></li><li><p><strong>Composite</strong><br>   – Sử dụng transform và opacity<br>   – Quản lý các layer bằng Chrome DevTools</p></li></ul><p>Sau khi đã thực hiện những bước trên, web page của bạn sẽ hoạt động mượt mà, trơn tru với 60fps. Chúc bạn thành công!</p><p>60FPS FOR THE WIN!</p><h1 id="Chuyen-ngoai-le"><a href="#Chuyen-ngoai-le" class="headerlink" title="Chuyện ngoài lề"></a>Chuyện ngoài lề</h1><p>Ở Silicon Straits Saigon, chúng tôi có một bài test dành cho Front-end Developer, đó là implement hiệu ứng scrolling sau (ảnh động, load hơi lâu): <a href="https://bit.ly/1CCYx9y" target="_blank" rel="noopener">http://bit.ly/1CCYx9y</a></p><p>Các bạn có thể vận dụng những kiến thức có được trong bài viết này để “thử sức” với hiệu ứng trên.</p><p>Đây là bài làm của tôi, mặc dù không được hoàn hảo nhưng có thể dùng được cho mục đích tham khảo.</p><p>Link: <a href="https://trungdq88.github.io/css-stuffs/delay-scroll/" target="_blank" rel="noopener">http://trungdq88.github.io/css-stuffs/delay-scroll/</a></p><p>Timeline Record:</p><p> <img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image05-700x455.png" alt=""></p><p>Layers (một phần):</p><p> <img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image10-700x299.png" alt=""></p><h2 id="Cac-nguon-tham-khao-trong-bai-viet"><a href="#Cac-nguon-tham-khao-trong-bai-viet" class="headerlink" title="Các nguồn tham khảo trong bài viết:"></a>Các nguồn tham khảo trong bài viết:</h2><p>Một số hình ảnh và code mẫu:</p><ul><li>Google Developer: <a href="https://developers.google.com/web/fundamentals/performance/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/</a></li><li>Preventing Layout Thrashing:<a href="http://wilsonpage.co.uk/preventing-layout-thrashing/" target="_blank" rel="noopener">http://wilsonpage.co.uk/preventing-layout-thrashing/</a></li></ul><p>Các trang web có hiệu ứng đẹp:</p><ul><li><a href="http://world.mathigon.org/" target="_blank" rel="noopener">http://world.mathigon.org/</a></li><li><a href="http://matthew.wagerfield.com/parallax/" target="_blank" rel="noopener">http://matthew.wagerfield.com/parallax/</a></li></ul><p>Khóa học:</p><ul><li>Udacity Course: Browser Rendering Optimization – Building 60 FPS Web Apps: <a href="https://www.udacity.com/course/browser-rendering-optimization--ud860" target="_blank" rel="noopener">https://www.udacity.com/course/browser-rendering-optimization–ud860</a></li></ul><p>Các nguồn khác:</p><ul><li>Web Workers: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage</a></li><li>BEM: <a href="https://bem.info/" target="_blank" rel="noopener">https://bem.info/</a></li><li>PostCSS: <a href="https://github.com/postcss/postcss" target="_blank" rel="noopener">https://github.com/postcss/postcss</a></li><li>CSS Trigger: <a href="http://csstriggers.com/" target="_blank" rel="noopener">http://csstriggers.com/</a></li><li>Guide to Flexbox: <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">http://css-tricks.com/snippets/css/a-guide-to-flexbox/</a></li><li>FastDOM: <a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">https://github.com/wilsonpage/fastdom</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Optimizing Performance&lt;/strong&gt; (tối ưu hóa hiệu suất) cho website là một công việc mà bất kỳ front-end developer nào cũng nên biết, mục đích là để trang web đáp ứng được 3 tiêu chí:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;NHẸ&lt;/strong&gt;: Giảm kích thước trang web và các thành phần đi kèm như javascript, css, hình ảnh… nhằm đảm bảo &lt;strong&gt;thời gian tải xuống ngắn hơn&lt;/strong&gt;. Chúng ta có thể dùng các bộ minify cho javascript, css…, nén các tập tin hình ảnh, font chữ, svg… ngoài ra còn có các kĩ thuật như code splitting, browser caching, HTTP caching…&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NHANH&lt;/strong&gt; &lt;strong&gt;Hiển thị nội dung trang web càng sớm càng tốt&lt;/strong&gt; bằng cách: chia cấu trúc DOM hợp lý, hạn chế blocking CSS/JS, hạn chế chỉnh sửa DOM tree, chia các file ra thành nhiều module, tải resource bất đồng bộ, tối ưu hóa các selector của CSS và JS…&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MƯỢT&lt;/strong&gt;: Sau khi nội dung trang web đã được tải về và hiển thị thì việc tiếp theo là &lt;strong&gt;bảo đảm các hiệu ứng animation, transition, scrolling… phải mượt&lt;/strong&gt;, không bị lag và giật (jank).&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>10 câu hỏi phỏng vấn mà Javascript Developer nên biết</title>
    <link href="http://nthung2112.github.io/2018/06/10-cau-hoi-phong-van-ma-Javascript-Developer-nen-biet.html"/>
    <id>http://nthung2112.github.io/2018/06/10-cau-hoi-phong-van-ma-Javascript-Developer-nen-biet.html</id>
    <published>2018-06-23T15:11:00.000Z</published>
    <updated>2018-06-23T15:28:47.131Z</updated>
    
    <content type="html"><![CDATA[<p>Tại hầu hết các công ty, người quản lý phải tin tưởng các developers, cho họ tham gia các cuộc phỏng vấn kỹ thuật để đánh giá các kỹ năng ứng cử viên. Nếu bạn làm tốt như một ứng cử viên, bạn sẽ cần phải phỏng vấn. Đây là cách làm.</p><a id="more"></a><h3 id="It-Starts-With-People"><a href="#It-Starts-With-People" class="headerlink" title="It Starts With People"></a>It Starts With People</h3><p>In <a href="https://medium.com/javascript-scene/how-to-build-a-high-velocity-development-team-4b2360d34021" target="_blank" rel="noopener">“How to Build a High Velocity Development Team”</a>, Tôi đã nêu một vài điểm đáng để lặp lại:</p><blockquote><p>“Nothing predicts business outcomes better than an exceptional team. If you’re going to beat the odds, you need to invest here, first.”</p></blockquote><p>Như Marcus Lemonis đã nói, cần tập trung vào 3 P’s:</p><hr><blockquote><p>“People, Process, Product”</p></blockquote><hr><div class="video-container"><iframe src="//www.youtube.com/embed/37rMZSA6oLk" frameborder="0" allowfullscreen></iframe></div><p>Your early hires should be very strong, senior-level candidates. People who can hire and mentor other developers, and help the mid-level and junior developers you’ll eventually want to hire down the road.</p><p>Read <a href="https://medium.com/javascript-scene/why-hiring-is-so-hard-in-tech-c462c3230017" target="_blank" rel="noopener">“Why Hiring is So Hard in Tech”</a> for a good breakdown of the general do’s and don’ts of candidate evaluation.</p><hr><blockquote><p>The best way to evaluate a candidate is a pair programming exercise.</p></blockquote><hr><p>Pair program with the candidate. Let the candidate drive. Watch and listen more than you talk. A good project might be to pull tweets from the Twitter API and display them on a timeline.</p><p>That said, no single exercise will tell you everything you need to know. An interview can be a very useful tool as well, but don’t waste time asking about syntax or language quirks. You need to see the big picture. Ask about architecture and paradigms — the big decisions that can have a major impact on the whole project.</p><p>Syntax and features are easy to Google. It’s much harder to Google for software engineering wisdom or the common paradigms and idioms JavaScript developers pick up with experience.</p><p>JavaScript is special, and it plays a critical role in almost every large application. What is it about JavaScript that makes it meaningfully different from other languages?</p><p>Here are some questions that will help you explore the stuff that really matters:</p><h4 id="1-Can-you-name-two-programming-paradigms-important-for-JavaScript-app-developers"><a href="#1-Can-you-name-two-programming-paradigms-important-for-JavaScript-app-developers" class="headerlink" title="1. Can you name two programming paradigms important for JavaScript app developers?"></a>1. Can you name two programming paradigms important for JavaScript app developers?</h4><p>JavaScript is a multi-paradigm language, supporting <strong>imperative/procedural</strong> programming along with <strong>OOP</strong> (Object-Oriented Programming) and <strong>functional programming</strong>. JavaScript supports OOP with <strong>prototypal inheritance</strong>.</p><p><strong>Good to hear:</strong></p><ul><li>Prototypal inheritance (also: prototypes, OLOO).</li><li>Functional programming (also: closures, first class functions, lambdas).</li></ul><p><strong>Red flags:</strong></p><ul><li>No clue what a paradigm is, no mention of prototypal oo or functional programming.</li></ul><h4 id="2-What-is-functional-programming"><a href="#2-What-is-functional-programming" class="headerlink" title="2. What is functional programming?"></a>2. What is functional programming?</h4><p>Functional programming produces programs by composing mathematical functions and avoids shared state &amp; mutable data. Lisp (specified in 1958) was among the first languages to support functional programming, and was heavily inspired by lambda calculus. Lisp and many Lisp family languages are still in common use today.</p><p>Functional programming is an essential concept in JavaScript (one of the two pillars of JavaScript). Several common functional utilities were added to JavaScript in ES5.</p><p><strong>Good to hear:</strong></p><ul><li>Pure functions / function purity.</li><li>Avoid side-effects.</li><li>Simple function composition.</li><li>Examples of functional languages: Lisp, ML, Haskell, Erlang, Clojure, Elm, F Sharp, OCaml, etc…</li><li>Mention of features that support FP: first-class functions, higher order functions, functions as arguments/values.</li></ul><p><strong>Red flags:</strong></p><ul><li>No mention of pure functions / avoiding side-effects.</li><li>Unable to provide examples of functional programming languages.</li><li>Unable to identify the features of JavaScript that enable FP.</li></ul><h4 id="3-What-is-the-difference-between-classical-inheritance-and-prototypal-inheritance"><a href="#3-What-is-the-difference-between-classical-inheritance-and-prototypal-inheritance" class="headerlink" title="3. What is the difference between classical inheritance and prototypal inheritance?"></a>3. What is the difference between classical inheritance and prototypal inheritance?</h4><p><strong>Class Inheritance:</strong> instances inherit from classes (like a blueprint — a description of the class), and create sub-class relationships: hierarchical class taxonomies. Instances are typically instantiated via constructor functions with the <em><code>new</code></em> keyword. Class inheritance may or may not use the <em><code>class</code></em> keyword from ES6.</p><p><strong>Prototypal Inheritance:</strong> instances inherit directly from other objects. Instances are typically instantiated via factory functions or <em><code>Object.create()</code>.</em> Instances may be composed from many different objects, allowing for easy selective inheritance.</p><hr><blockquote><p>In JavaScript, prototypal inheritance is simpler &amp;<br>more flexible than class inheritance.</p></blockquote><hr><p><strong>Good to hear:</strong></p><ul><li>Classes: create tight coupling or hierarchies/taxonomies.</li><li>Prototypes: mentions of concatenative inheritance, prototype delegation, functional inheritance, object composition.</li></ul><p><strong>Red Flags:</strong></p><ul><li>No preference for prototypal inheritance &amp; composition over class inheritance.</li></ul><h4 id="4-What-are-the-pros-and-cons-of-functional-programming-vs-object-oriented-programming"><a href="#4-What-are-the-pros-and-cons-of-functional-programming-vs-object-oriented-programming" class="headerlink" title="4. What are the pros and cons of functional programming vs object-oriented programming?"></a>4. What are the pros and cons of functional programming vs object-oriented programming?</h4><p><strong>OOP Pros:</strong> It’s easy to understand the basic concept of objects and easy to interpret the meaning of method calls. OOP tends to use an imperative style rather than a declarative style, which reads like a straight-forward set of instructions for the computer to follow.</p><p><strong>OOP Cons:</strong> OOP Typically depends on shared state. Objects and behaviors are typically tacked together on the same entity, which may be accessed at random by any number of functions with non-deterministic order, which may lead to undesirable behavior such as race conditions.</p><p><strong>FP Pros:</strong> Using the functional paradigm, programmers avoid any shared state or side-effects, which eliminates bugs caused by multiple functions competing for the same resources. With features such as the availability of point-free style (aka tacit programming), functions tend to be radically simplified and easily recomposed for more generally reusable code compared to OOP.</p><p>FP also tends to favor declarative and denotational styles, which do not spell out step-by-step instructions for operations, but instead concentrate on <strong>what</strong> to do, letting the underlying functions take care of the <strong>how</strong>. This leaves tremendous latitude for refactoring and performance optimization, even allowing you to replace entire algorithms with more efficient ones with very little code change. (e.g., memoize, or use lazy evaluation in place of eager evaluation.)</p><p>Computation that makes use of pure functions is also easy to scale across multiple processors, or across distributed computing clusters without fear of threading resource conflicts, race conditions, etc…</p><p><strong>FP Cons:</strong> Over exploitation of FP features such as point-free style and large compositions can potentially reduce readability because the resulting code is often more abstractly specified, more terse, and less concrete.</p><p>More people are familiar with _OO_ and imperative programming than functional programming, so even common idioms in functional programming can be confusing to new team members.</p><p>FP has a much steeper learning curve than OOP because the broad popularity of OOP has allowed the language and learning materials of OOP to become more conversational, whereas the language of FP tends to be much more academic and formal. FP concepts are frequently written about using idioms and notations from lambda calculus, algebras, and category theory, all of which requires a prior knowledge foundation in those domains to be understood.</p><p><strong>Good to hear:</strong></p><ul><li>Mentions of trouble with shared state, different things competing for the same resources, etc…</li><li>Awareness of FP’s capability to radically simplify many applications.</li><li>Awareness of the differences in learning curves.</li><li>Articulation of side-effects and how they impact program maintainability.</li><li>Awareness that a highly functional codebase can have a steep learning curve.</li><li>Awareness that a highly OOP codebase can be extremely resistant to change and very brittle compared to an equivalent FP codebase.</li><li>Awareness that immutability gives rise to an extremely accessible and malleable program state history, allowing for the easy addition of features like infinite undo/redo, rewind/replay, time-travel debugging, and so on. Immutability can be achieved in either paradigm, but a proliferation of shared stateful objects complicates the implementation in OOP.</li></ul><p><strong>Red flags:</strong></p><ul><li>Unable to list disadvantages of one style or another — Anybody experienced with either style should have bumped up against some of the limitations.</li></ul><p><strong>Learn More:</strong></p><ul><li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 1</a> — Prototypal OO.</li><li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 2</a> — Functional Programming.</li></ul><h4 id="5-When-is-classical-inheritance-an-appropriate-choice"><a href="#5-When-is-classical-inheritance-an-appropriate-choice" class="headerlink" title="5. When is classical inheritance an appropriate choice?"></a>5. When is classical inheritance an appropriate choice?</h4><p>The answer is never, or almost never. Certainly never more than one level. Multi-level class hierarchies are an anti-pattern. I’ve been issuing this challenge for years, and the only answers I’ve ever heard fall into one of several <a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a" target="_blank" rel="noopener">common misconceptions</a>. More frequently, the challenge is met with silence.</p><blockquote><p>“If a feature is sometimes useful<br>and sometimes dangerous<br>and if there is a better option<br>then <strong>always use the better option</strong>.”<br>~ Douglas Crockford</p></blockquote><p><strong>Good to hear:</strong></p><ul><li>Rarely, almost never, or never.</li><li>A single level is sometimes OK, from a framework base-class such as React.Component.</li><li>“Favor object composition over class inheritance.”</li></ul><h4 id="6-When-is-prototypal-inheritance-an-appropriate-choice"><a href="#6-When-is-prototypal-inheritance-an-appropriate-choice" class="headerlink" title="6. When is prototypal inheritance an appropriate choice?"></a>6. When is prototypal inheritance an appropriate choice?</h4><p>There is more than one type of prototypal inheritance:</p><ul><li><strong>Delegation</strong> (i.e., the prototype chain).</li><li><strong>Concatenative</strong> (i.e. mixins, <em><code>Object.assign()</code></em>).</li><li><strong>Functional</strong> (Not to be confused with functional programming. A function used to create a closure for private state/encapsulation).</li></ul><p>Each type of prototypal inheritance has its own set of use-cases, but all of them are equally useful in their ability to enable <strong>composition,</strong> which creates <strong>has-a</strong> or <strong>uses-a</strong> or <strong>can-do</strong> relationships as opposed to the <strong>is-a</strong> relationship created with class inheritance.</p><p><strong>Good to hear</strong>:</p><ul><li>In situations where modules or functional programming don’t provide an obvious solution.</li><li>When you need to compose objects from multiple sources.</li><li>Any time you need inheritance.</li></ul><p><strong>Red flags:</strong></p><ul><li>No knowledge of when to use prototypes.</li><li>No awareness of mixins or <em><code>Object.assign()</code>.</em></li></ul><h4 id="7-What-does-“favor-object-composition-over-class-inheritance”-mean"><a href="#7-What-does-“favor-object-composition-over-class-inheritance”-mean" class="headerlink" title="7. What does “favor object composition over class inheritance” mean?"></a>7. What does “favor object composition over class inheritance” mean?</h4><p>This is a quote from <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="noopener">“Design Patterns: Elements of Reusable Object-Oriented Software”</a>. It means that code reuse should be achieved by assembling smaller units of functionality into new objects instead of inheriting from classes and creating object taxonomies.</p><p>In other words, use <strong>can-do, has-a,</strong> or <strong>uses-a</strong> relationships instead of <strong>is-a</strong> relationships.</p><p><strong>Good to hear:</strong></p><ul><li>Avoid class hierarchies.</li><li>Avoid brittle base class problem.</li><li>Avoid tight coupling.</li><li>Avoid rigid taxonomy (forced is-a relationships that are eventually wrong for new use cases).</li><li>Avoid the gorilla banana problem (“what you wanted was a banana, what you got was a gorilla holding the banana, and the entire jungle”).</li><li>Make code more flexible.</li></ul><p><strong>Red Flags:</strong></p><ul><li>Fail to mention any of the problems above.</li><li>Fail to articulate the difference between composition and class inheritance, or the advantages of composition.</li></ul><h4 id="8-What-are-two-way-data-binding-and-one-way-data-flow-and-how-are-they-different"><a href="#8-What-are-two-way-data-binding-and-one-way-data-flow-and-how-are-they-different" class="headerlink" title="8. What are two-way data binding and one-way data flow, and how are they different?"></a>8. What are two-way data binding and one-way data flow, and how are they different?</h4><p>Two way data binding means that UI fields are bound to model data dynamically such that when a UI field changes, the model data changes with it and vice-versa.</p><p>One way data flow means that the model is the single source of truth. Changes in the UI trigger messages that signal user intent to the model (or “store” in React). Only the model has the access to change the app’s state. The effect is that data always flows in a single direction, which makes it easier to understand.</p><p>One way data flows are deterministic, whereas two-way binding can cause side-effects which are harder to follow and understand.</p><p><strong>Good to hear:</strong></p><ul><li>React is the new canonical example of one-way data flow, so mentions of React are a good signal. Cycle.js is another popular implementation of uni-directional data flow.</li><li>Angular is a popular framework which uses two-way binding.</li></ul><p><strong>Red flags:</strong></p><ul><li>No understanding of what either one means. Unable to articulate the difference.</li></ul><h4 id="9-What-are-the-pros-and-cons-of-monolithic-vs-microservice-architectures"><a href="#9-What-are-the-pros-and-cons-of-monolithic-vs-microservice-architectures" class="headerlink" title="9. What are the pros and cons of monolithic vs microservice architectures?"></a>9. What are the pros and cons of monolithic vs microservice architectures?</h4><p>A monolithic architecture means that your app is written as one cohesive unit of code whose components are designed to work together, sharing the same memory space and resources.</p><p>A microservice architecture means that your app is made up of lots of smaller, independent applications capable of running in their own memory space and scaling independently from each other across potentially many separate machines.</p><p><strong>Monolithic Pros:</strong> The major advantage of the monolithic architecture is that most apps typically have a large number of cross-cutting concerns, such as logging, rate limiting, and security features such audit trails and DOS protection.</p><p>When everything is running through the same app, it’s easy to hook up components to those cross-cutting concerns.</p><p>There can also be performance advantages, since shared-memory access is faster than inter-process communication (IPC).</p><p><strong>Monolithic cons:</strong> Monolithic app services tend to get tightly coupled and entangled as the application evolves, making it difficult to isolate services for purposes such as independent scaling or code maintainability.</p><p>Monolithic architectures are also much harder to understand, because there may be dependencies, side-effects, and magic which are not obvious when you’re looking at a particular service or controller.</p><p><strong>Microservice pros:</strong> Microservice architectures are typically better organized, since each microservice has a very specific job, and is not concerned with the jobs of other components. Decoupled services are also easier to recompose and reconfigure to serve the purposes of different apps (for example, serving both the web clients and public API).</p><p>They can also have performance advantages depending on how they’re organized because it’s possible to isolate hot services and scale them independent of the rest of the app.</p><p><strong>Microservice cons:</strong> As you’re building a new microservice architecture, you’re likely to discover lots of cross-cutting concerns that you did not anticipate at design time. A monolithic app could establish shared magic helpers or middleware to handle such cross-cutting concerns without much effort.</p><p>In a microservice architecture, you’ll either need to incur the overhead of separate modules for each cross-cutting concern, or encapsulate cross-cutting concerns in another service layer that all traffic gets routed through.</p><p>Eventually, even monolthic architectures tend to route traffic through an outer service layer for cross-cutting concerns, but with a monolithic architecture, it’s possible to delay the cost of that work until the project is much more mature.</p><p>Microservices are frequently deployed on their own virtual machines or containers, causing a proliferation of VM wrangling work. These tasks are frequently automated with container fleet management tools.</p><p><strong>Good to hear:</strong></p><ul><li>Positive attitudes toward microservices, despite the higher initial cost vs monolthic apps. Aware that microservices tend to perform and scale better in the long run.</li><li>Practical about microservices vs monolithic apps. Structure the app so that services are independent from each other at the code level, but easy to bundle together as a monolithic app in the beginning. Microservice overhead costs can be delayed until it becomes more practical to pay the price.</li></ul><p><strong>Red flags:</strong></p><ul><li>Unaware of the differences between monolithic and microservice architectures.</li><li>Unaware or impractical about the additional overhead of microservices.</li><li>Unaware of the additional performance overhead caused by IPC and network communication for microservices.</li><li>Too negative about the drawbacks of microservices. Unable to articulate ways in which to decouple monolithic apps such that they’re easy to split into microservices when the time comes.</li><li>Underestimates the advantage of independently scalable microservices.</li></ul><h4 id="10-What-is-asynchronous-programming-and-why-is-it-important-in-JavaScript"><a href="#10-What-is-asynchronous-programming-and-why-is-it-important-in-JavaScript" class="headerlink" title="10. What is asynchronous programming, and why is it important in JavaScript?"></a>10. What is asynchronous programming, and why is it important in JavaScript?</h4><p>Synchronous programming means that, barring conditionals and function calls, code is executed sequentially from top-to-bottom, blocking on long-running tasks such as network requests and disk I/O.</p><p>Asynchronous programming means that the engine runs in an event loop. When a blocking operation is needed, the request is started, and the code keeps running without blocking for the result. When the response is ready, an interrupt is fired, which causes an event handler to be run, where the control flow continues. In this way, a single program thread can handle many concurrent operations.</p><p>User interfaces are asynchronous by nature, and spend most of their time waiting for user input to interrupt the event loop and trigger event handlers.</p><p>Node is asynchronous by default, meaning that the server works in much the same way, waiting in a loop for a network request, and accepting more incoming requests while the first one is being handled.</p><p>This is important in JavaScript, because it is a very natural fit for user interface code, and very beneficial to performance on the server.</p><p><strong>Good to hear:</strong></p><ul><li>An understanding of what blocking means, and the performance implications.</li><li>An understanding of event handling, and why its important for UI code.</li></ul><p><strong>Red flags:</strong></p><ul><li>Unfamiliar with the terms asynchronous or synchronous.</li><li>Unable to articulate performance implications or the relationship between asynchronous code and UI code.</li></ul><hr><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Stick to high-level topics. If they can answer these questions, that typically means that they have enough programming experience to pick up language quirks &amp; syntax in a few weeks, even if they don’t have a lot of JavaScript experience.</p><p>Don’t disqualify candidates based on stuff that’s easy to learn (including classic CS-101 algorithms, or any type of puzzle problem).</p><p>What you really need to know is, “does this candidate understand how to put an application together?”</p><p>That’s it for the spoken interview.</p><p>In real interviews, I place a much stronger emphasis on coding challenges and <strong><em>watching candidates code.</em></strong> Those topics are covered in depth in my <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" target="_blank" rel="noopener">“Master the JavaScript Interview”</a> series.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tại hầu hết các công ty, người quản lý phải tin tưởng các developers, cho họ tham gia các cuộc phỏng vấn kỹ thuật để đánh giá các kỹ năng ứng cử viên. Nếu bạn làm tốt như một ứng cử viên, bạn sẽ cần phải phỏng vấn. Đây là cách làm.&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Local Storage, Session Storage và Cookie</title>
    <link href="http://nthung2112.github.io/2018/06/Local-Storage-Session-Storage-va-Cookie.html"/>
    <id>http://nthung2112.github.io/2018/06/Local-Storage-Session-Storage-va-Cookie.html</id>
    <published>2018-06-23T11:40:00.000Z</published>
    <updated>2018-06-23T11:45:41.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Su-khac-nhau-va-cach-su-dung-Local-Storage-Session-Storage-va-Cookie"><a href="#Su-khac-nhau-va-cach-su-dung-Local-Storage-Session-Storage-va-Cookie" class="headerlink" title="Sự khác nhau và cách sử dụng Local Storage, Session Storage và Cookie"></a>Sự khác nhau và cách sử dụng Local Storage, Session Storage và Cookie</h1><p>Bạn bị lẫn lộn giữa <strong>session storage</strong>, <strong>local storage</strong> và <strong>cookies</strong>? Bài viết dưới đây sẽ giúp bạn hiểu rõ được sự khác nhau giữa 3 cách lưu trữ này. Các kiểu không gian lưu trữ khác nhau có sẵn cho các dữ liệu có thể trên máy chủ hoặc máy khách, cho phép chúng ta chọn lựa theo nhu cầu.<br><a id="more"></a></p><h2 id="1-Local-storage"><a href="#1-Local-storage" class="headerlink" title="1. Local storage"></a>1. Local storage</h2><h3 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu:"></a>Giới thiệu:</h3><ul><li>Khả năng lưu trữ vô thời hạn: Có nghĩa là chỉ bị xóa bằng JavaScript, hoặc xóa bộ nhớ trình duyệt, hoặc xóa bằng localStorage API.</li><li>Lưu trữ được 5MB: Local Storage cho phép bạn lưu trữ thông tin tương đối lớn lên đến 5MB, lưu được lượng thông tin lớn nhất trong 3 loại.</li><li>Không gửi thông tin lên server như Cookie nên bảo mật tốt hơn.</li></ul><h3 id="Trinh-duyet-ho-tro"><a href="#Trinh-duyet-ho-tro" class="headerlink" title="Trình duyệt hỗ trợ:"></a>Trình duyệt hỗ trợ:</h3><table><thead><tr><th>Trình duyệt</th><th>Phiên bản</th></tr></thead><tbody><tr><td>Chrome</td><td>&gt;= 4.0</td></tr><tr><td>Internet Explorer / Edge</td><td>&gt;= 8.0</td></tr><tr><td>Firefox</td><td>&gt;= 3.5</td></tr><tr><td>Safari</td><td>&gt;= 4.0</td></tr><tr><td>Chrome</td><td>&gt;= 11.5</td></tr></tbody></table><p>Để kiểm tra xem trình duyệt có hỗ trợ localStorage hay không thì chúng ta dùng typeof như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(Storage) !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="comment">//Nếu có hỗ trợ</span></span><br><span class="line">    <span class="comment">//Thực hiện thao tác với Storage</span></span><br><span class="line">    alert(<span class="string">'Trình duyệt của bạn hỗ trợ Storage'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//Nếu không hỗ trợ</span></span><br><span class="line">    alert(<span class="string">'Trình duyệt của bạn không hỗ trợ Storage'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Xem-localStorage-bang-trinh-duyet"><a href="#Xem-localStorage-bang-trinh-duyet" class="headerlink" title="Xem localStorage bằng trình duyệt"></a>Xem localStorage bằng trình duyệt</h3><p>Để xem localstorage bằng trình duyệt các bạn vào trang web cần xem (ở đây mình ví dụ với trang web <a href="http://book.framgia.vn/" target="_blank" rel="noopener">http://book.framgia.vn/</a>) và sau đó các bạn ấn F12 (hoặc Ctrl + shift + i) sau đó làm theo như hình sau:</p><p><img src="https://images.viblo.asia/9bcca9a7-81d0-46af-86de-6a461f67db95.png" alt=""></p><p>Chọn tab Application, di chuyển đến Storage để thấy các Storage của trình duyệt. Để xem các local Storage đang được lưu trữ, mở rộng phần Local Storage như hình. Ở đây ta có thể thấy có 2 biến Local Storage đang được lưu là <em>pusherTransportEncrypted</em> và <em>lang</em> với giá trị của 2 biến được hiển thị bên cạnh (cột Value). Như vậy, cột Key chính là danh sách các biến local Storage đang được lưu và cột Value là các giá trị tương ứng. Để xóa hết các giá trị local Storage này đi, bạn có thể chọn biểu tượng cấm (Clear All) hoặc chọn bên cạnh là biểu tượng dấu X (Delete Selected).</p><h3 id="Su-dung"><a href="#Su-dung" class="headerlink" title="Sử dụng"></a>Sử dụng</h3><ul><li>Khởi tạo localStorage</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br><span class="line"><span class="comment">// hoặc</span></span><br><span class="line">localStorage.key = <span class="string">'value'</span>;</span><br><span class="line"><span class="comment">// hoặc</span></span><br><span class="line">localStorage[<span class="string">'key'</span>] = <span class="string">'value'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Trong đó: key là tên biến, value là giá trị của biến muốn gán vào.</p></blockquote><ul><li>Để lấy giá trị localStorage và sử dụng, ta dùng getItem</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localStorage.getItem(<span class="string">'key'</span>);</span><br><span class="line"><span class="comment">// hoặc</span></span><br><span class="line">localStorage.key;</span><br></pre></td></tr></table></figure><p><strong>Ví dụ</strong> cụ thể như sau:</p><p><img src="https://images.viblo.asia/42ea1e74-930e-4457-b8a2-125036df89dc.png" alt=""></p><ul><li>Để lấy số lượng localStorage đã có trong trình duyệt, sử dụng length như sau:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.length;</span><br></pre></td></tr></table></figure><p>Ví dụ</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(Storage) !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="comment">//Nếu hỗ trợ</span></span><br><span class="line">    <span class="keyword">var</span> data = localStorage.length;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Nếu không hỗ trợ</span></span><br><span class="line">    alert(<span class="string">'Trình duyệt của bạn không hỗ trợ'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Để xóa 1 biến trong localStorage, sử dụng removeItem(tên_key)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.removeItem(key);</span><br></pre></td></tr></table></figure><p>Hoặc xóa tất cả các biến trong localStorage, sử dụng clear</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure><h2 id="2-Session-Storage"><a href="#2-Session-Storage" class="headerlink" title="2. Session Storage"></a>2. Session Storage</h2><h3 id="Gioi-thieu-1"><a href="#Gioi-thieu-1" class="headerlink" title="Giới thiệu:"></a>Giới thiệu:</h3><ul><li>Lưu trên Client: Cũng giống như localStorage thì sessionStorage cũng dùng để lưu trữ dữ liệu trên trình duyệt của khách truy cập (client).</li><li>Mất dữ liệu khi đóng tab: Dữ liệu của sessionStorage sẽ mất khi bạn đóng trình duyệt.</li><li>Dữ liệu không được gửi lên Server</li><li>Thông tin lưu trữ nhiều hơn cookie (ít nhất 5MB)</li></ul><h3 id="Trinh-duyet-ho-tro-1"><a href="#Trinh-duyet-ho-tro-1" class="headerlink" title="Trình duyệt hỗ trợ"></a>Trình duyệt hỗ trợ</h3><table><thead><tr><th>Trình duyệt</th><th>Phiên bản</th></tr></thead><tbody><tr><td>Chrome</td><td>&gt;= 5.0</td></tr><tr><td>Internet Explorer / Edge</td><td>&gt;= 8.0</td></tr><tr><td>Firefox</td><td>&gt;= 2</td></tr><tr><td>Safari</td><td>&gt;= 4.0</td></tr><tr><td>Opera</td><td>&gt;= 10.5</td></tr></tbody></table><p>Vì sessionStorage cũng nằm trong gói Storage nên các bạn cũng có thể sử dụng lại đoạn code kiểm tra trình duyệt có hỗ trợ Storage hay không ở phía trên.</p><h3 id="Xem-Session-Storage-bang-trinh-duyet"><a href="#Xem-Session-Storage-bang-trinh-duyet" class="headerlink" title="Xem Session Storage bằng trình duyệt"></a>Xem Session Storage bằng trình duyệt</h3><p>Tương tự như localStorage, có thể chọn mở rộng mục Session Storage để xem các giá trị được lưu trữ.</p><h3 id="Su-dung-1"><a href="#Su-dung-1" class="headerlink" title="Sử dụng"></a>Sử dụng</h3><p>sessionStorage cũng có cú pháp và cách sử dụn các thuộc tính, phương thức như localStorage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span>(Storage) !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="comment">// Khởi tạo sesionStorage</span></span><br><span class="line">    sessionStorage.setItem(<span class="string">'name'</span>, <span class="string">'Ted Mosby'</span>);</span><br><span class="line">    <span class="comment">// get sessionStorage</span></span><br><span class="line">    sessionStorage.getItem(<span class="string">'name'</span>);</span><br><span class="line">    <span class="comment">// lấy ra số lượng session đã lưu trữ</span></span><br><span class="line">    sessionStorage.length;</span><br><span class="line">    <span class="comment">// xóa 1 item localStorage</span></span><br><span class="line">    sessionStorage.removeItem(<span class="string">'name'</span>);</span><br><span class="line">    <span class="comment">// xóa tất cả item trong sessionStorage</span></span><br><span class="line">    sessionStorage.clear();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'Trình duyệt của bạn không hỗ trợ!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3. Cookie"></a>3. Cookie</h2><h3 id="Gioi-thieu-2"><a href="#Gioi-thieu-2" class="headerlink" title="Giới thiệu:"></a>Giới thiệu:</h3><ul><li>Thông tin được gửi lên server: Cookie sẽ được truyền từ server tới browser và được lưu trữ trên máy tính của bạn khi bạn truy cập vào ứng dụng, mỗi khi người dùng tải ứng dụng, trình duyệt sẽ gửi cookie để thông báo cho ứng dụng về hoạt động trước đó của bạn. Vì vậy đừng bao giờ lưu trữ những thông tin quan trọng, yêu cầu tính bảo mật cao vào cookie vì nó hoàn toàn có thể bị sửa đổi và đánh cắp, thấp chí có thể lợi dụng điều này để tấn công website của bạn.</li><li>Cookie chủ yếu là để đọc phía máy chủ (cũng có thể được đọc ở phía máy khách), localStorage và sessionStorage chỉ có thể được đọc ở phía máy khách.</li><li>Có thời gian sống: Mỗi cookie thường có khoảng thời gian timeout nhất định do lập trình viên xác định trước.</li><li>Lưu trữ: cho phép lưu trữ tối đa 4KB và vài chục cookie cho một domain.</li></ul><h3 id="Xem-cookie-bang-trinh-duyet"><a href="#Xem-cookie-bang-trinh-duyet" class="headerlink" title="Xem cookie bằng trình duyệt"></a>Xem cookie bằng trình duyệt</h3><p>Tương tự như localStorage, có thể chọn mở rộng mục Cookies để xem các giá trị cookie được lưu trữ</p><p><img src="https://images.viblo.asia/94606099-1b52-4377-b354-69dd4cc0fa5e.png" alt=""></p><h3 id="Su-dung-2"><a href="#Su-dung-2" class="headerlink" title="Sử dụng"></a>Sử dụng</h3><p>Cookie có thể được tạo bằng nhiều cách, bài viết này sẽ trình bày về sử dụng cookie trong javascript. JavaScript có thể tạo, đọc, và xóa cookies với document.cookie.</p><ul><li>Tạo cookie: Javascript có thể tạo cookie như sau:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=Ted Mosby'</span>;</span><br></pre></td></tr></table></figure><p>Chúng ta cũng có thể thêm vào ngày hết hạn cho cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=Ted Mosby; expires=Thu, 18 Dec 2018 8:00:00 UTC'</span>;</span><br></pre></td></tr></table></figure><p>Hoặc đặt hẹn giờ sau bao lâu cookie sẽ hết hạn với max-age (tính bằng giây)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=Ted Mosby; max-age=9000'</span>;</span><br></pre></td></tr></table></figure><ul><li>Đọc cookie:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure><p>document.cookie sẽ trả lại tất cả cookie trong một chuỗi tring kiểu như: cookie1 = giá trị; cookie2 = giá trị; cookie3 = giá trị;</p><p>Hoặc để lấy giá trị của 1 cookie, có thể viết một hàm như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">cname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = cname + <span class="string">'='</span>;</span><br><span class="line">    <span class="keyword">var</span> decodedCookie = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line">    <span class="keyword">var</span> ca = decodedCookie.split(<span class="string">';'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;ca.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = ca[i];</span><br><span class="line">        <span class="keyword">while</span> (c.charAt(<span class="number">0</span>) == <span class="string">' '</span>) &#123;</span><br><span class="line">            c = c.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c.indexOf(name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> c.substring(name.length, c.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tham số truyền vào là cname - tên cookie muốn lấy giá trị.</p></blockquote><blockquote><p>Tạo một biến name và thêm vào “=” để tìm kiếm trong chuỗi document.cookie</p></blockquote><blockquote><p>Chia document.cookie dựa trên dấu ; thành một mảng nhiều phần tử và gán mảng đấy cho biến ca</p></blockquote><blockquote><p>Vòng lặp (i=0; i&lt;ca.length; i++) để đọc mỗi giá trị c = ca[i]</p></blockquote><blockquote><p>Nếu cookie được tìm thấy (c.indexOf(name)==0), trả về giá trị của cookie (c.substring(name.length,c.length). Nếu cookie không được tìm thấy, trả về ‘’</p></blockquote><p>Ví dụ muốn lấy giá trị của cookie tên là language thì ta có thể gọi getcookie(‘language’) và kêt quả trả về là giá trị của cookie có tên đó.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = getCookie(<span class="string">'language'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lang);</span><br></pre></td></tr></table></figure><p>Kết quả:</p><p><img src="https://images.viblo.asia/de11cb91-6bf0-47a2-840f-2ba067b391cb.png" alt=""></p><ul><li>Thay đổi giá trị cookie: Trong javascript, bạn có thể thay đổi một cookie giống như cách mà bạn tạo ra cookie, tức là ghi đè giá trị mới lên cookie đã có:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"username=Barney Stinson; expires=Wed, 26 Dec 2018 8:00:00 UTC"</span>;</span><br></pre></td></tr></table></figure><ul><li>Kiểm tra cookie: Để kiểm tra coookie, có thể xây dựng hàm như sau:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCookie</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username = getCookie(<span class="string">'username'</span>);</span><br><span class="line">    <span class="keyword">if</span> (username != <span class="string">''</span>) &#123;</span><br><span class="line">        alert(<span class="string">'Welcome again '</span> + username);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        username = prompt(<span class="string">'Please enter your name: '</span>,  <span class="string">''</span>);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="string">''</span> &amp;&amp; username != <span class="literal">null</span>) &#123;</span><br><span class="line">            setCookie(<span class="string">'username'</span>, username, <span class="number">365</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Nếu cookie được thiết lập, nó sẽ hiển thị một lời chào</p></blockquote><blockquote><p>Nếu cookie không được thiết lập, nó sẽ hiển thị một prompt box, hỏi tên của người dùng, lưu trữ tên của người dùng ở cookie trong 365 ngày, bằng việc gọi function setCookie đã được viết ở trên</p></blockquote><ul><li>Xóa cookie: Để xóa một cookie chỉ cần xét lại giá trị ngày hết hạn expires về một thời điểm đã qua</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=; expires=Thu, 01 Jan 1970 00:00:00 UTC'</span>;</span><br></pre></td></tr></table></figure><p>Tham khảo tại <a href="https://www.w3schools.com/js/js_cookies.asp" target="_blank" rel="noopener">https://www.w3schools.com/js/js_cookies.asp</a></p><h3 id="4-Thong-tin-them"><a href="#4-Thong-tin-them" class="headerlink" title="4. Thông tin thêm"></a>4. Thông tin thêm</h3><ul><li>Vì localStorage và sessionStorage được lưu trữ trên trình duyệt của người dùng, nên các bạn cần phải xem xét nội dung lưu trữ có liên quan đến vấn đề bảo mật hay không.</li><li>Và cũng chính vì localStorage và sessionStorage được lưu trữ trên trình duyệt nên việc sử dụng nó sẽ không ảnh hưởng đến hiệu xuất của trang web nhưng nó sẽ làm nặng trình duyệt của người dùng (không đáng kể).</li><li>Về phạm vi: <strong>sessionStorage</strong>: giới hạn trong một cửa sổ hoăc thẻ của trình duyệt. Một trang web được mở trong hai thẻ của cùng một trình duyệt cũng không thể truy xuất dữ liệu lẫn nhau. Như vậy, khi bạn đóng trang web thì dữ liệu lưu trong sessionStorage hiện tại cũng bị xóa. Còn <strong>localStorage</strong>: có thể truy xuất lẫn nhau giữa các cửa sổ trình duyệt. Dữ liệu sẽ được lưu trữ không giới hạn thời gian.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Su-khac-nhau-va-cach-su-dung-Local-Storage-Session-Storage-va-Cookie&quot;&gt;&lt;a href=&quot;#Su-khac-nhau-va-cach-su-dung-Local-Storage-Session-Storage-va-Cookie&quot; class=&quot;headerlink&quot; title=&quot;Sự khác nhau và cách sử dụng Local Storage, Session Storage và Cookie&quot;&gt;&lt;/a&gt;Sự khác nhau và cách sử dụng Local Storage, Session Storage và Cookie&lt;/h1&gt;&lt;p&gt;Bạn bị lẫn lộn giữa &lt;strong&gt;session storage&lt;/strong&gt;, &lt;strong&gt;local storage&lt;/strong&gt; và &lt;strong&gt;cookies&lt;/strong&gt;? Bài viết dưới đây sẽ giúp bạn hiểu rõ được sự khác nhau giữa 3 cách lưu trữ này. Các kiểu không gian lưu trữ khác nhau có sẵn cho các dữ liệu có thể trên máy chủ hoặc máy khách, cho phép chúng ta chọn lựa theo nhu cầu.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
      <category term="html5" scheme="http://nthung2112.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>Load Javascript với async và defer</title>
    <link href="http://nthung2112.github.io/2018/06/Load-Javascript-voi-async-va-defer.html"/>
    <id>http://nthung2112.github.io/2018/06/Load-Javascript-voi-async-va-defer.html</id>
    <published>2018-06-23T11:29:00.000Z</published>
    <updated>2018-06-23T11:37:52.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Van-de"><a href="#Van-de" class="headerlink" title="Vấn đề"></a>Vấn đề</h1><p><strong>Javascript</strong> là 1 trong những tài nguyên chặn trang, có nghĩa là việc hiển thị HTML có thể bị chặn hay làm chậm bởi Javascript. Khi parser đọc đến <code>&lt;script&gt;</code> tag, bất kể là inline hay là external file, quá trình parse sẽ tạm dừng để fetch script đó về và execute. Việc này có thể là vấn đề nếu chúng ta load nhiều file Javascript trên trang, làm tăng thời gian load trang mặc dù có thể việc hiển thị html ở trang không thực sự phụ thuộc vào những file javascript đó. Và may mắn thay, thẻ <code>&lt;script&gt;</code> có 2 thuộc tính, đó là <strong>async và defer</strong>, cho phép chúng ta kiểm soát và load những file này theo ý muốn, tránh chặn quá trình load trang.</p><a id="more"></a><h1 id="Mo-ta-cach-thuc-thi"><a href="#Mo-ta-cach-thuc-thi" class="headerlink" title="Mô tả cách thực thi"></a>Mô tả cách thực thi</h1><p><img src="http://www.growingwiththeweb.com/images/2014/02/26/legend.svg" alt=""></p><h2 id="lt-script-gt"><a href="#lt-script-gt" class="headerlink" title="&lt;script&gt;"></a><code>&lt;script&gt;</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script.js"</span> /&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    ....</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Với thẻ script không có thuộc tính gì khác thì HTML file sẽ được parse cho đến khi gặp phải thẻ script, đến lúc này thì quá trình parse sẽ tạm dùng và để fetch script file về (nếu là external file), sau đó execute những code script này, sau đó mới tiếp tục lại quá trình parse html </p><p><img src="http://www.growingwiththeweb.com/images/2014/02/26/script.svg" alt=""></p><h2 id="lt-script-async-gt"><a href="#lt-script-async-gt" class="headerlink" title="&lt;script async&gt;"></a><code>&lt;script async&gt;</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"script.js"</span> /&gt;</span><br></pre></td></tr></table></figure><p>Với thẻ script có thuộc tính async, khi quá trình parse html gặp phải script này, nó sẽ vẫn tiếp tục parse html cho đến khi script này được download xong, thì quá trình parse html mới tạm dừng để execute những code script này, sau đó lại tiếp tiếp quá trình parse html</p><p><img src="http://www.growingwiththeweb.com/images/2014/02/26/script-async.svg" alt=""></p><h2 id="lt-script-defer-gt"><a href="#lt-script-defer-gt" class="headerlink" title="&lt;script defer&gt;"></a><code>&lt;script defer&gt;</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"script.js"</span> /&gt;</span><br></pre></td></tr></table></figure><p>Với thẻ script có thuộc tính defer, quá trình parse html sẽ không bị dừng lại mà parse cho đến khi hoàn thành, quá trình download các script file được tiến hành song song, và cuối cùng thì sẽ execute những script code này khi html đã parse xong.</p><p><img src="http://www.growingwiththeweb.com/images/2014/02/26/script-defer.svg" alt=""></p><h1 id="Vay-nen-dung-khi-nao"><a href="#Vay-nen-dung-khi-nao" class="headerlink" title="Vậy nên dùng khi nào?"></a>Vậy nên dùng khi nào?</h1><p>Nó phụ thuộc vào từng tình huống cụ thể.</p><h2 id="Quy-tac-nhu-sau"><a href="#Quy-tac-nhu-sau" class="headerlink" title="Quy tắc như sau:"></a>Quy tắc như sau:</h2><ul><li>Nếu script là 1 module tách biệt, không phụ thuộc vào script nào khác thì nên sử dụng async cho load và execute với trang luôn</li><li>Nếu script phụ thuộc vào script khác, hoặc bị script khác phụ thuộc, thì nên dùng defer, để load và execute theo thứ tự</li><li>Nếu script nhỏ và các script khác phụ thuộc vào nó, thì cho load inline và không cần async hay defer</li></ul><h2 id="Ngoai-ra-nen-can-nhac-1-so-cau-hoi-truoc-khi-them-cac-thuoc-tinh-nay"><a href="#Ngoai-ra-nen-can-nhac-1-so-cau-hoi-truoc-khi-them-cac-thuoc-tinh-nay" class="headerlink" title="Ngoài ra nên cân nhắc 1 số câu hỏi trước khi thêm các thuộc tính này"></a>Ngoài ra nên cân nhắc 1 số câu hỏi trước khi thêm các thuộc tính này</h2><h3 id="1-The-script-dang-nam-o-dau-trong-trang"><a href="#1-The-script-dang-nam-o-dau-trong-trang" class="headerlink" title="1. Thẻ script đang nằm ở đâu trong trang"></a>1. Thẻ script đang nằm ở đâu trong trang</h3><p>Async và defer có thể rất cần thiết nếu thẻ script không nằm ở cuối trang. HMTL document được parse theo thứ tự, từ thẻ mở <html> cho đến thẻ đóng </html>. Nếu script năm ngay gần cuối thẻ đóng  thì việc sử dụng async hay defer thì cũng không có ý nghĩa lắm bởi vì việc parse html đã gần xong xuôi, và javascript không còn block gì html nữa.</p><h3 id="2-Script-do-co-doc-lap-khong"><a href="#2-Script-do-co-doc-lap-khong" class="headerlink" title="2. Script đó có độc lập không?"></a>2. Script đó có độc lập không?</h3><p>Với những file script không phụ thuộc vào những file khác, thì thuộc tính async dùng cho script đó là việc nên làm, vì nó load và execute script song song, giảm thời gian tải trang, kết quả cuối cùng nhanh hơn.</p><h3 id="3-Script-co-yeu-cau-viec-load-DOM-xong-moi-thuc-hien"><a href="#3-Script-co-yeu-cau-viec-load-DOM-xong-moi-thuc-hien" class="headerlink" title="3. Script có yêu cầu việc load DOM xong mới thực hiện?"></a>3. Script có yêu cầu việc load DOM xong mới thực hiện?</h3><p>Trong nhiều trường hợp, các script chứa đựng code tương tác với DOM, hoặc phụ thuộc vào các thành phần trên trang, yêu cầu trang phải parse xong thì mới execute script. Thông thường thì những file như thế sẽ được đặt ở cuối trang để chắc chắn mọi thử đã được parse. Tuy nhiên chúng ta có thể dùng thuộc tính defer thay thế, đảm bảo script sẽ được execute khi trang đã tải xong.</p><h3 id="4-Script-nho-va-cac-file-khac-phu-thuoc-vao-no"><a href="#4-Script-nho-va-cac-file-khac-phu-thuoc-vao-no" class="headerlink" title="4.Script nhỏ và các file khác phụ thuộc vào nó?"></a>4.Script nhỏ và các file khác phụ thuộc vào nó?</h3><p>Nếu script dung lượng nhỏ, và các file khác phụ thuộc vào nó, thì nên để script đó inline. Mặc dù nó block quá trình parse HTML, nhưng nó không đáng kể vì dung lượng nhỏ.</p><h1 id="Loi-ich"><a href="#Loi-ich" class="headerlink" title="Lợi ích"></a>Lợi ích</h1><p>Với việc biết cách sử dụng các thuộc tính async, defer hợp lí thì tốc độ load trang sẽ được cải thiện hơn, mang lại cảm giác thích thú cho người dùng. Vì vậy nó giúp tối ưu SEO, giúp tăng điểm Google Page Speed (<a href="https://developers.google.com/speed/pagespeed/insights" target="_blank" rel="noopener">https://developers.google.com/speed/pagespeed/insights</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Van-de&quot;&gt;&lt;a href=&quot;#Van-de&quot; class=&quot;headerlink&quot; title=&quot;Vấn đề&quot;&gt;&lt;/a&gt;Vấn đề&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Javascript&lt;/strong&gt; là 1 trong những tài nguyên chặn trang, có nghĩa là việc hiển thị HTML có thể bị chặn hay làm chậm bởi Javascript. Khi parser đọc đến &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, bất kể là inline hay là external file, quá trình parse sẽ tạm dừng để fetch script đó về và execute. Việc này có thể là vấn đề nếu chúng ta load nhiều file Javascript trên trang, làm tăng thời gian load trang mặc dù có thể việc hiển thị html ở trang không thực sự phụ thuộc vào những file javascript đó. Và may mắn thay, thẻ &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; có 2 thuộc tính, đó là &lt;strong&gt;async và defer&lt;/strong&gt;, cho phép chúng ta kiểm soát và load những file này theo ý muốn, tránh chặn quá trình load trang.&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Functional Programming - Phần 3 - Buông bỏ</title>
    <link href="http://nthung2112.github.io/2018/06/Functional-Programming-Phan-3-Buong-bo.html"/>
    <id>http://nthung2112.github.io/2018/06/Functional-Programming-Phan-3-Buong-bo.html</id>
    <published>2018-06-20T08:46:00.000Z</published>
    <updated>2018-06-23T08:54:01.269Z</updated>
    
    <content type="html"><![CDATA[<p>Functional Programming là một con đường khác, một phương pháp tư duy khác trong coding. Ở tầm nhìn trừu tượng hơn, người ta xếp Functional Programming vào nhóm “Declarative”, còn OOP thuộc nhóm “Imperative”.</p><p>Từ các bài học ngữ pháp chúng ta đã biết 2 kiểu câu: câu trần thuật (Declarative Sentence), và câu mệnh lệnh (Imperative Sentence).</p><p>Lập trình theo lối “Imperative Programming” là sắp xếp một loạt các mệnh lệnh liên tiếp, để máy tính thực thi tuần tự từng bước. Ở đây người ta tập trung vào “how”. Nào, hãy làm thế này, rồi làm thế kia… Một hình thức “cầm tay chỉ việc”.<br><a id="more"></a><br>Ví dụ trên trang web có 4 boxes màu đỏ thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  float: left;</span><br><span class="line">  margin: <span class="number">10</span>px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.hide &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="box hide"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box hide"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box hide"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box hide"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Mấy boxes này đang ẩn, ta cần làm chúng hiện ra bằng cách loại bỏ class “hide” đi.</p><p>Các giáo viên tin học đáng kính ở trường xưa thường dạy viết kiểu như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tìm hết các tags có class "box':</span></span><br><span class="line"><span class="keyword">const</span> els = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.box'</span>);</span><br><span class="line"><span class="comment">// quét tất cả các tags tìm thấy</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; els.length; i++) &#123;</span><br><span class="line">  <span class="comment">// với tag thứ i</span></span><br><span class="line">  <span class="keyword">let</span> el = els[i];</span><br><span class="line">  <span class="comment">// xóa bỏ class "hide" để cho tag hiện lên</span></span><br><span class="line">  el.classList.remove(<span class="string">'hide'</span>);</span><br><span class="line">  <span class="comment">// nếu còn phần tử phía sau thì tăng i lên 1 đơn vị</span></span><br><span class="line">  <span class="comment">// quay lại với xử lý tag thứ i + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Họ dùng code hướng dẫn cho máy tính làm từng nhiệm vụ.</p><p>Người tu luyện Functional Programming không tư duy theo cách đó.</p><h3 id="No-for-while"><a href="#No-for-while" class="headerlink" title="No for/while"></a>No for/while</h3><p>“Declarative Programming” là tập trung vào “what”. Chúng ta chỉ cần định nghĩa những quy tắc đầu vào, đầu ra. Chẳng hạn “nếu input là 1 thì output là 2”. Phần còn lại để máy tính xử lý.</p><p>Người tu luyện Functional Programming không cần for loop.</p><p>Code như thế này nhìn mới mẻ hơn nhiều:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getElements = <span class="function">(<span class="params">selector</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(selector));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getRemover = <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">className</span>) =&gt;</span> &#123;</span><br><span class="line">    el.classList.remove(className);</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> els = getElements(<span class="string">'.box'</span>)</span><br><span class="line">  .map(getRemover)</span><br><span class="line">  .map(<span class="function"><span class="params">removeClass</span> =&gt;</span> removeClass(<span class="string">'hide'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(els);</span><br></pre></td></tr></table></figure><p>Trước tiên chúng ta tạo ra 1 pure function getElements dùng để lấy các elements trên trang thông qua CSS Selector. Tập hợp này vốn là ArrayLike, ta dùng Array.from chuyển thành Array thực sự để có thể tận dụng các phương thức trong Array prototype.</p><p>Ở đây ta định nghĩa input là CSS Selector, output là 1 mảng DOM Elements.</p><p>Còn getRemover lại là 1 higher-order function. Có thể gọi nó bằng cách chaining getRemover(DOMElement)(classToRemove). Chúng ta lợi dụng đặc tính của higher-order function, sau 2 lần map thì chạm tới function do getRemover ném lại.</p><p>Ở đây ta định nghĩa input là DOM Element, output là function() {nhận input là className và output là DOM Element đã mất đi class đó}.</p><p>Code như vậy ta có thể đem logic dùng lại ở nhiều chỗ khác nhau, chỉ cần thay đổi input. Ví dụ loại bỏ class float-left khỏi tất cả các thẻ div.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> els = getElements(<span class="string">'div'</span>)</span><br><span class="line">  .map(getRemover)</span><br><span class="line">  .map(<span class="function"><span class="params">removeClass</span> =&gt;</span> removeClass(<span class="string">'float-left'</span>));</span><br></pre></td></tr></table></figure><h3 id="No-if-else"><a href="#No-if-else" class="headerlink" title="No if/else"></a>No if/else</h3><p>Người tu luyện Functional Programming cũng không cần if/else.</p><p>Thậm chí họ còn tạo ra cả một chiến dịch <a href="https://francescocirillo.com/pages/anti-if-campaign" target="_blank" rel="noopener">Anti-IF</a>!</p><p>Có nhiều cách để loại bỏ hoàn toàn if/else ra khỏi chương trình của bạn. Đơn giản nhất là dùng ternary.</p><h4 id="Ternary"><a href="#Ternary" class="headerlink" title="Ternary"></a>Ternary</h4><p>Trong JavaScript, ternary - tam phân - có tên gọi chính thức là Toán tử Điều kiện - Conditional Operator. Nó là cách viết ngắn gọn của if/else.</p><p>Hãy xem đoạn code dài dòng, rẽ nhánh phức tạp như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> title = <span class="string">'Mr.'</span>;</span><br><span class="line"><span class="keyword">if</span> (person.gender === <span class="string">'female'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!person.gotMarried) &#123;</span><br><span class="line">    title = <span class="string">'Ms.'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    title = <span class="string">'Mrs.'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Có thể được viết gọn lại thành:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = person.gender === <span class="string">'female'</span> ? (!person.gotMarried ? <span class="string">'Ms.'</span> : <span class="string">'Mrs.'</span>) : <span class="string">'Mr.'</span>;</span><br></pre></td></tr></table></figure><p>Không còn if/else nữa.</p><p>Ta cũng vô hình trung loại bỏ được var, let vì không cần gán lại giá trị cho title.</p><h4 id="Logical-operators"><a href="#Logical-operators" class="headerlink" title="Logical operators"></a>Logical operators</h4><p>Cách thứ 2 là khai thác sức mạnh ngầm của các logical operators &amp;&amp;, ||. Đây là những toán tử logic. Hôm trước có bạn viết <a href="https://kipalog.com/posts/--va--" target="_blank" rel="noopener">1 cái TIL ngắn</a> khá hay. Sau đây ta quan sát chúng kỹ hơn qua lăng kính Functional Programming.</p><p>Giả sử có đoạn code như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHello = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, bonjour, nihao'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doNothing = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do nothing'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greet = <span class="function">(<span class="params">hasClient</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasClient) &#123;</span><br><span class="line">    sayHello();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    doNothing();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="literal">true</span>); <span class="comment">// =&gt; 'Hello, bonjour, nihao'</span></span><br><span class="line">greet(<span class="literal">false</span>); <span class="comment">//=&gt; 'Do nothing'</span></span><br></pre></td></tr></table></figure><p>Về mặt logic, hàm greet() kiểm tra điều kiện nếu có khách thì chào, nếu không thì không làm gì cả.</p><p>Theo định nghĩa của &amp;&amp; và ||, chúng ta biết:</p><ul><li>expr1 &amp;&amp; expr2 trả về expr1 nếu expr1 là falsy, ngoài ra nó trả về expr2.</li></ul><p>Một điều thú vị ở đây là JavaScript engine luôn ước lượng giá trị biểu thức logic dạng này từ trái sang phải và theo nguyên tắc “đoản mạch” - <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation" target="_blank" rel="noopener">short-circuit evaluation</a>“. Tiên hữu nào giỏi Vật lý chắc còn nhớ hiện tượng “đoản mạch”, đó là khi dòng điện không chạy qua tải hoặc chỉ chạy qua một phần.</p><p>Vì AND chỉ trả về true nếu cả 2 mệnh đề cùng đúng, nên ngay khi bắt gặp expr1 sai, nó lập tức kết luận mệnh đề ghép là Sai và chấm dứt tại đó luôn, không chạy qua nửa bên phải expr2 nữa.</p><ul><li>expr1 || expr2 trả về expr1 nếu expr1 là truthy, ngoài ra nó trả về expr2.</li></ul><p>Vì OR trả về true nếu ít nhất 1 mệnh đề đúng, nên ngay khi bắt gặp expr1 đúng, nó lập tức kết luận mệnh đề ghép là Đúng và bỏ qua expr2.</p><p>Short-circuit thần thánh!</p><p>Các lập trình viên kinh nghiệm thường lợi dụng đặc điểm này để tối ưu hiệu suất chương trình. Họ để các biểu thức tính toán phức tạp ở nửa sau của biểu thức logic. Như vậy, khi chưa rơi vào hoàn cảnh thích hợp, chúng sẽ bị bỏ qua, không cần tốn resource xử lý.</p><p>Tới đây, ta đã có thể viết lại hàm greet() một cách bí hiểm như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="function">(<span class="params">hasClient</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (hasClient || doNothing()) &amp;&amp; sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bắt đầu phần nằm trong ngoặc đơn bên trái &amp;&amp;. Nếu hasClient là true thì giá trị phần này cũng là true, doNothing() bị bỏ qua.</p><p>Vì phần bên trái của &amp;&amp; là true nên cuối cùng, giá trị biểu thức quy về phần bên phải &amp;&amp;, tức là sayHello().</p><p>Lập luận tương tự cho trường hợp hasClient là false, dòng chảy chương trình lập tức rẽ sang doNothing(). Lúc này giá trị nửa bên trái &amp;&amp; là false, do đó không cần quan tâm đến sayHello() nữa.</p><p>Viết như trên vừa độc vừa lạ, vừa khử được if/else, mà vẫn hoàn toàn ăn khớp với điều kiện quy ước.</p><p>Tuy nhiên, logical operators nếu nhìn không quen thì có vẻ hơi khó hình dung mạch suy diễn của chương trình. Tôi chỉ đưa ra đây để các tin hữu tham khảo. Trong dự án thực tế, vẫn nên dùng ternary cho đỡ hại não đồng đội:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="function">(<span class="params">hasClient</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> hasClient ? sayHello() : doNothing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Logical-functions"><a href="#Logical-functions" class="headerlink" title="Logical functions"></a>Logical functions</h4><p>Một cách tiếp cận khác thể hiện tinh thần Functional Programming quyết liệt hơn, đó là tạo ra các hàm đặc trách nhiệm vụ xử lý logic. Ví dụ trong <a href="https://ramdajs.com" target="_blank" rel="noopener">Ramda.js</a> và <a href="https://sanctuary.js.org" target="_blank" rel="noopener">Sanctuary</a> đều có ifElse , unless , when, và hàng chục hàm logic khác.</p><p>Hàm greet nếu viết lại với Ramda sẽ trở nên xinh xắn như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> R = <span class="built_in">require</span>(<span class="string">'ramda'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greet = R.ifElse(R.identity, sayHello, doNothing);</span><br></pre></td></tr></table></figure><p>Đó là vẻ đẹp đầy tính nghệ thuật của Function Composition. Bạn cứ ngắm nhìn nó và đừng nói gì cả! Composition cũng có nghĩa là tác phẩm, như thơ của Paul Verlaine hay nhạc của Beethoven.</p><h3 id="No-new-this"><a href="#No-new-this" class="headerlink" title="No new/this"></a>No new/this</h3><p>Có 2 thứ luôn khiến Brendan Eich cảm thấy hài lòng khi <a href="https://brendaneich.com/2008/04/popularity/" target="_blank" rel="noopener">kể về lịch sử JavaScript</a>, đó là first-class function và prototype mechanism.</p><p>Ngày nay, hầu hết developer đều biết rằng thừa kế trong JavaScript là prototype-based inheritance. Nhưng ở thời kỳ web còn hoang sơ, người ta hay dùng new và các hàm constructors để lập trình OOP trong JavaScript theo kiểu class-based, giống như bên Java vẫn làm.</p><h4 id="Classical-inheritance"><a href="#Classical-inheritance" class="headerlink" title="Classical inheritance"></a>Classical inheritance</h4><p>Cổ thư ghi lại rất nhiều ví dụ kiểu này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'woof-woof, my name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rocky = <span class="keyword">new</span> Dog(<span class="string">'Rocky'</span>);</span><br><span class="line">rocky.say();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> molly = <span class="keyword">new</span> Dog(<span class="string">'Molly'</span>);</span><br><span class="line">molly.say();</span><br></pre></td></tr></table></figure><p>Hàm Dog gọi là Function Constructor, các tiền bối chân giới Đại Việt thủa trước chuyển ngữ thành “hàm dựng”. Còn chúng ta thời nay có lẽ cứ nên giữ nguyên văn.</p><h4 id="Prototypal-inheritance"><a href="#Prototypal-inheritance" class="headerlink" title="Prototypal inheritance"></a>Prototypal inheritance</h4><p>Sang đầu kỷ thứ 3, ở tông môn Yahoo! có một vị trưởng lão tu vi rất cao thâm tên là <a href="https://en.wikipedia.org/wiki/Douglas_Crockford" target="_blank" rel="noopener">Douglas Crockford</a> tung ra bộ kỳ thư “JavaScript: The Good Parts”, trong đó có đoạn nhấn mạnh bản chất prototype trong JavaScript, sự khác biệt giữa classical inheritance và prototypal inheritance. Ông cho rằng từ khóa new mang theo nhiều điểm bất cập, nên khuyến khích dùng Object.create để sao chép nguyên mẫu sang đối tượng kế thừa.</p><p>Tư tưởng của Douglas Crockford quả thực mới mẻ. Vào lúc đó, nhiều JavaScript engine còn chưa kịp hỗ trợ Object.create. Cuốn này vừa ra mắt đã gây náo loạn cả tin giới, trở thành sách gối đầu giường của rất nhiều tu sĩ.</p><p>Object.create cho phép sao chép các properties hoặc protoype của đối tượng. Hàm Dog có thể được viết lại theo hướng prototypal inheritance như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'woof-woof, my name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rocky = <span class="built_in">Object</span>.create(Dog.prototype);</span><br><span class="line">rocky.name = <span class="string">'Rocky'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> molly = <span class="built_in">Object</span>.create(Dog.prototype);</span><br><span class="line">molly.name = <span class="string">'Molly'</span>;</span><br><span class="line"></span><br><span class="line">rocky.say();</span><br><span class="line">molly.say();</span><br></pre></td></tr></table></figure><p>Không cần new nữa!</p><p>Các cường giả sau đó nhanh chóng phát triển thêm nhiều cách tiếp cận prototypal inheritance khác, nổi bật nhất phải kể đến Concatenative inheritance, Prototype delegation và Functional inheritance.</p><p>ES6 Class ngày nay chỉ vay mượn syntax của classical OOP để làm interface, còn bên trong nó chính là cơ chế prototypal inheritance.</p><h4 id="Object-Composition"><a href="#Object-Composition" class="headerlink" title="Object Composition"></a>Object Composition</h4><p>Nhưng dù sao prototypal inheritance vẫn thuộc về OOP.</p><p>Người tu luyện Functional Programming không cần new.</p><p>Gần 10 năm sau bom tấn “The Good Parts”, Douglas Crockford lại một lần nữa khiến tin giới chấn động bằng “JavaScript: The Better Parts”. Thời điểm này, ông đã không còn dùng Object.create() nữa, cũng từ bỏ luôn this, for loops, for in, while… Tu vi của ông đã tiến thêm một bước lớn. Trong clip, ông nói về những tính năng mới của ES6 lúc ấy vẫn còn chưa chính thức xuất xưởng. Mấy lão quái kiệt này luôn đi trước thiên hạ vài năm.</p><div class="video-container"><iframe src="//www.youtube.com/embed/bo36MrBfTk4" frameborder="0" allowfullscreen></iframe></div><p>Đó cũng là khi trào lưu Functional Programming đang dần nóng trở lại, người ta bắt đầu nhắc đến khái niệm <a href="https://medium.com/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381" target="_blank" rel="noopener">Object Composition</a>.</p><p>Đi cặp với new là this. Từ khóa this chẳng qua chỉ là kỹ xảo nhằm tạo ra một ngữ cảnh khu biệt (context) để thực thi các hàm. Trong JavaScript, mỗi hàm như 1 kết giới độc lập. Function khi được gắn lên object thì gọi là method. Ngữ cảnh method đó chạy thường chính là đối tượng sở hữu nó. Sau này mới sinh ra các thủ thuật bind, apply, call để đánh tráo context.</p><p>Với những người mới học JavaScript, this đôi khi trở thành nỗi khiếp sợ. Rất khó debug các vấn đề phát sinh trong hàm nếu không biết chính xác ngữ cảnh chạy nó. Mà ngữ cảnh lại thường không ổn định. Đúng hơn, phải nói rằng chúng luôn luôn mutable.</p><p>Người tu luyện Functional Programming không cần this.</p><p>Đoạn code với classical OOP trên kia có thể viết lại thành:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sayName = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(</span><br><span class="line">    state,</span><br><span class="line">    &#123;</span><br><span class="line">      say: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`woof-woof, my name is <span class="subst">$&#123;state.name&#125;</span>`</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createDog = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> state = &#123;</span><br><span class="line">    name,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(state, sayName(state));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rocky = createDog(<span class="string">'Rocky'</span>);</span><br><span class="line">rocky.say();</span><br><span class="line"><span class="keyword">const</span> molly = createDog(<span class="string">'Molly'</span>);</span><br><span class="line">molly.say();</span><br></pre></td></tr></table></figure><p>Nhìn đâu cũng thấy functions.</p><p>Không còn for/while, if/else, new/this.</p><p>Liệu bạn đã sẵn sàng rời khỏi những phàm vật ấy?</p><p>Hay nói như các nhà sư, liệu bạn có thể buông bỏ?</p><p><img src="https://i.imgur.com/LK0k8LW.jpg" alt=""></p><p>Khi lối tư duy truyền thống đã ăn sâu vào tâm trí, hễ gặp vấn đề phân cấp đối tượng thì chúng ta sẽ nghĩ ngay đến OOP, class, prototype, inheritance… thậm chí coi chúng như giải pháp tất yếu, duy nhất. Hễ xử lý tập hợp là phải looping, hễ thấy có điều kiện thì chỉ biết dựa vào if… Đây là trở ngại rất lớn cho kẻ mới nhập đạo.</p><p>Phải tìm cách rũ bỏ những thứ không cần thiết, thì mới đi xa được.</p><p>Rời khỏi chúng, chỉ giữ lại một ý niệm duy nhất: FUNCTION!</p><p>Nhất niệm “phân sần”!</p><p><img src="https://i.imgur.com/0clmtSN.jpg" alt=""></p><p>Ban đầu tất nhiên là sẽ khó khăn, lúng túng. Giống như hàng ngày bạn vẫn đi trên con đường quen thuộc từ nhà đến công sở rồi lại trở về nhà. Cho đến một hôm con đường đó bị cảnh sát chặn lại, bạn đành phải rẽ sang lối khác.</p><p>Trên con đường xa lạ ấy, bạn không còn trông thấy những điểm mốc hàng ngày vẫn thấy: 1 shop lưu niệm, 1 cây xăng, 1 tiệm cầm đồ, sau ngã tư là đến ven sông, cây cầu sơn màu đỏ, một tiệm tạp hóa thường có cô em rất xinh ngồi trước cửa… Bạn không còn bắt gặp những dấu hiệu đã quen mắt. Bạn chẳng biết mình đã đi đến đâu, còn cách nhà bao nhiêu km nữa.</p><p>Nhưng con đường nào đi lại vài lần thì cũng thành quen. Chẳng có gì đáng ngại. Vấn đề là, ngay khi bạn nhận thấy Functional Programming là thứ gì đó rất thú vị, đáng để học hỏi, vận dụng nó, bạn nên thực hiện ngay lập tức, đừng chờ đợi dịp nào thuận tiện, đừng chờ tìm được minh sư dẫn dắt. Nếu vậy, bạn sẽ khó mà rời khỏi lối mòn xưa cũ.</p><p>Krishnamurti từng diễn giải một điều gần tương tự, đại ý thế này:</p><blockquote><p>Nếu bạn đi về hướng Bắc suốt những ngày tháng của cuộc đời bạn, giống như con người đã đi theo một hướng đặc biệt, rồi có người nào đó xuất hiện và nói, “Hướng đó không đúng”. Sau đó ông ta bảo bạn, “Đi về hướng Nam, hướng Đông, bất kỳ hướng nào, ngoại trừ hướng đó.” Và khi bạn thực sự chuyển động khỏi hướng đó, có một sự thay đổi ngay tại chính những tế bào não bởi vì bạn đã phá vỡ cái khuôn mẫu. Và cái khuôn mẫu đó phải được phá vỡ ngay lúc này, không phải bốn mươi năm hay một trăm năm sau.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Functional Programming là một con đường khác, một phương pháp tư duy khác trong coding. Ở tầm nhìn trừu tượng hơn, người ta xếp Functional Programming vào nhóm “Declarative”, còn OOP thuộc nhóm “Imperative”.&lt;/p&gt;
&lt;p&gt;Từ các bài học ngữ pháp chúng ta đã biết 2 kiểu câu: câu trần thuật (Declarative Sentence), và câu mệnh lệnh (Imperative Sentence).&lt;/p&gt;
&lt;p&gt;Lập trình theo lối “Imperative Programming” là sắp xếp một loạt các mệnh lệnh liên tiếp, để máy tính thực thi tuần tự từng bước. Ở đây người ta tập trung vào “how”. Nào, hãy làm thế này, rồi làm thế kia… Một hình thức “cầm tay chỉ việc”.&lt;br&gt;
    
    </summary>
    
    
      <category term="functional programming" scheme="http://nthung2112.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Functional Programming - Phần 2 - Nhập đạo</title>
    <link href="http://nthung2112.github.io/2018/06/Functional-Programming-Phan-2-Nhap-dao.html"/>
    <id>http://nthung2112.github.io/2018/06/Functional-Programming-Phan-2-Nhap-dao.html</id>
    <published>2018-06-16T08:43:00.000Z</published>
    <updated>2018-06-23T08:53:54.125Z</updated>
    
    <content type="html"><![CDATA[<p>Như vậy, Functional Programming là nghệ thuật lập trình trong đó ta:</p><ul><li>sử dụng functions để điều khiển workflow</li><li>tuân thủ 2 nguyên tắc immutability và purity</li></ul><p>Nói cách khác, chư vị tin hữu muốn tu luyện Functional Programming thì phải giữ đạo tâm trong sáng, ý chí kiên định, hàng ngày chiêm nghiệm, suy diễn, cảm ngộ function, tu vi theo đó sẽ không ngừng thăng tiến.</p><p>Nhưng làm thế nào để cảm ngộ “phân sần ý cảnh”? Ta phải nắm bắt, quan sát, tư duy, suy tưởng về function ra sao? Sau đây là những pháp quyết nhập môn.<br><a id="more"></a></p><h3 id="Higher-order-function"><a href="#Higher-order-function" class="headerlink" title="Higher-order function"></a>Higher-order function</h3><p>Higher-order function là một khái niệm đến từ Toán học. Bất cứ hàm nào tiếp nhận 1 function như tham số, hoặc trả về 1 function như kết quả, thì đều được coi là higher-order function.</p><p>Dưới đây là 1 ví dụ, hàm getItem nhận vào hàm by mô tả điều kiện, lại trả về 1 hàm khác. Nó thừa tiêu chuẩn để gọi là higher-order function.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getItem = <span class="function"><span class="params">by</span> =&gt;</span> arr =&gt; by;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hoặc phiên bản chi tiết</span></span><br><span class="line"><span class="keyword">const</span> getItem = <span class="function">(<span class="params">by</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> by(arr);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Lập trình phong cách Functional Programming là khiêu vũ với các functions.</p><p>Trong Functional Programming, hầu như mọi functions đều là higher-order function, vì chúng đều có thể nhận vào và ném ra các functions.</p><p>Nhưng như vậy thì có lợi ích gì? Nó đơn giản cung cấp cho ta một cách khác để lập luận và suy diễn. Chẳng hạn như với hàm getItem trên kia cho phép bạn biến hóa rất nhiều dạng, tùy vào cách bạn thao túng by.</p><p>Khi bạn viết getItem, bạn không cần biết sau này sẽ phải kiểm tra điều kiện ra sao, cũng không quan tâm sẽ nhận được đầu vào như thế nào.</p><p>Bạn có thể tạo ra hàm tìm số lớn nhất trong 1 mảng toàn số như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tạo hàm engine lấy max number từ mảng</span></span><br><span class="line"><span class="keyword">const</span> maxNumber = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...arr);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rồi truyền vào getItem để được hàm cần thiết</span></span><br><span class="line"><span class="keyword">const</span> getMaxNumber = getItem(maxNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thử xem sao</span></span><br><span class="line">getMaxNumber([<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="comment">// =&gt; 8</span></span><br></pre></td></tr></table></figure><p>Thế sao không truyền thẳng cái mảng số kia vào maxNumber cho khỏe? Vì trong thiết kế này ta đang cư xử với maxNumber như plugin. Còn nhiều plugins khác nữa. Ta không gọi trực tiếp plugin mà gọi qua 1 giao diện tổng quát hơn.</p><p>Giờ ta lại có dữ liệu 1 nhóm người như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> members = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Alice'</span>,</span><br><span class="line">    height: <span class="number">165</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    height: <span class="number">152</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Celina'</span>,</span><br><span class="line">    height: <span class="number">178</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Dan'</span>,</span><br><span class="line">    height: <span class="number">194</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Eric'</span>,</span><br><span class="line">    height: <span class="number">187</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>Ta muốn tìm người cao nhất trong nhóm thì sao? Hãy thêm 1 plugin khác.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bạn tạo 1 hàm engine lấy max height từ mảng</span></span><br><span class="line"><span class="keyword">const</span> maxHeight = <span class="function">(<span class="params">people</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> people.reduce(<span class="function">(<span class="params">prev, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev.height &gt; current.height ? prev : current;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rồi truyền vào getItem để được hàm cần thiết</span></span><br><span class="line"><span class="keyword">const</span> getTallestPerson = getItem(maxHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thử xem sao</span></span><br><span class="line">getTallestPerson(members);</span><br><span class="line"><span class="comment">// =&gt; &#123; name: 'Dan', height: 194 &#125;</span></span><br></pre></td></tr></table></figure><p>Ví dụ trên tuy tầm thường, nhưng có thể là gợi ý tốt để bạn dùng higher-order function thiết kế những chương trình linh hoạt, dễ mở rộng.</p><h3 id="Function-Composition"><a href="#Function-Composition" class="headerlink" title="Function Composition"></a>Function Composition</h3><p>Đây là <a href="https://www.mathsisfun.com/sets/functions-composition.html" target="_blank" rel="noopener">khái niệm Toán học</a> mà tiếng Việt ta gọi là “hàm hợp”, hay “hàm phức hợp”. Mọi thứ trong Functional Programming đều có nguồn gốc Toán học.</p><p>Function Composition là sự phối hợp, liên kết nhiều hàm lại với nhau, thành một hàm lớn, nhiều chức năng hơn.</p><p>Có 2 kỹ thuật căn bản trong Function Composition là compose và pipe.</p><h4 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h4><p>Hãy nhớ lại, trong không gian Functional Programming tồn tại vô số pure functions nhỏ gọn, đơn giản. Đúng triết lý “do one thing and do it well” của UNIX.</p><p>Vì mỗi hàm chỉ làm 1 việc, khi muốn thực hiện nhiều hành động lên cùng một input, ta chỉ việc kết hợp các hàm cần thiết lại với nhau.</p><p>Bây giờ chúng ta hãy tạm ngừng tu luyện, tạm quên tu vi để nhập phàm, quan sát và cảm ngộ nhân sinh.</p><p>Lần này, bạn hóa thành con trai thứ 4 trong gia đình một thôn dân sinh sống dưới chân núi Tản Viên bằng nghề bán thịt…</p><p>Một hôm bạn xin được khúc cây lớn ở chỗ ông chú làm kiểm lâm kiêm lâm tặc.</p><p> <img src="https://i.imgur.com/OQofkz2.jpg" alt=""></p><p>Từ khúc gỗ này, bạn muốn làm ra cái thớt cho nhà dùng.</p><p>Là tu sĩ mới nhập môn tu luyện Functional Programming, tuy không có tu vi, nhưng bạn vẫn hình dung được sẽ cần đến các pure functions sau:</p><ul><li>cưa(): nhận vào khúc gỗ, trả về từng khoanh tròn</li><li>sấy(): nhận khoanh gỗ tươi, trả về khoanh gỗ khô</li><li>bào(): nhận vào khoanh gỗ, trả về khoanh gỗ bằng phẳng</li><li>khoan(): nhận vào khoanh gỗ, trả về khoanh gỗ có 2 lỗ (để gắn quai treo/móc lên cho gọn)</li><li>chà(): nhận vào khoanh gỗ, trả về khoanh gỗ trơn láng (dùng giấy nhám, miền ngoài gọi giấy giáp, để đánh cho nhẵn bề mặt)</li><li>móc(): nhận thớt không quai, trả về thớt có quai</li></ul><p>Mỗi hàm chỉ làm đúng 1 việc. Không hơn. Không kém. Khi đi qua chừng đó công đoạn, ta sẽ được sản phẩm mong muốn.</p><p> <img src="https://i.imgur.com/qKYfPYA.jpg" alt=""></p><p>Dĩ nhiên chúng ta đang muốn khúc gỗ được sửa đổi nên tạm bỏ qua vấn đề immutability.</p><p>Đây là phiên bản mô phỏng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cưa = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã cưa`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sấy = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã sấy`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bào = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã bào`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> khoan = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã khoan`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chà = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã chà`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> móc = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã gắn móc`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Để tạo ra 1 cái thớt, ở thời viễn cổ xa xưa, các man sĩ thường code thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thớt = cưa(<span class="string">'khúc gỗ'</span>);</span><br><span class="line">thớt = sấy(thớt);</span><br><span class="line">thớt = bào(thớt);</span><br><span class="line">thớt = khoan(thớt);</span><br><span class="line">thớt = chà(thớt);</span><br><span class="line">thớt = móc(thớt);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thớt);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc</span></span><br></pre></td></tr></table></figure><p> <img src="https://i.imgur.com/nBLW7ye.jpg" alt=""></p><p>5 vạn năm sau, khi đã xuất hiện Toán học, các tộc nhân bộ lạc Giao Chỉ thời đại Hồng Bàng lại thích code như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thớt = móc(chà(khoan(bào(sấy(cưa(<span class="string">'khúc gỗ'</span>))))));</span><br><span class="line"><span class="built_in">console</span>.log(thớt);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc</span></span><br></pre></td></tr></table></figure><p>Đây chính là Toán học cơ bản. Với y = f(g(x)), ta tính g(x) trước, được bao nhiêu truyền vào f() là ra kết quả. Việc tính toán đi từ ngoặc trong cùng ra ngoài, mắt thường nhìn thấy là từ phải sang trái, từ g đến f.</p><p>Lại thêm 5 ngàn năm nữa trôi qua. Lúc này đã có ES6. Một số cường giả Functional Programming sáng tạo ra phương thức compose, như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> (x) =&gt; f(g(x)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Bạn có thể dùng <a href="https://babeljs.io/repl" target="_blank" rel="noopener">Babel</a> dịch sang ES2015 cho dễ hiểu.</p><p>Ý tưởng của compose là xếp cuốn chiếu các hàm lại với nhau, theo thứ tự từ trái sang phải để tạo ra một hàm mới, mà khi được thực thi, nó sẽ lần lượt gọi các hàm đã truyền vào trước đó theo thứ tự ngược lại, từ phải sang trái.</p><p>Tức là nếu y = compose(f, g), thì y(x) = f(g(x));<br>Nó sẽ tính g(x) trước rồi truyền kết quả cho f;<br>Giả sử g(x) = z thì y(x) = f(z);</p><p>Nếu bạn vẫn thấy mơ hồ thì cứ xem cái này là Đạo. Chỉ có thể cảm ngộ, không thể giảng được bằng lời!</p><p>Trở lại với cái thớt. Hàm compose tất nhiên là higher-order function. Ta sẽ thử xem nó làm việc ra sao:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quăng_cho_tao_cái_thớt = compose(móc, chà, khoan, bào, sấy, cưa);</span><br><span class="line"><span class="built_in">console</span>.log(quăng_cho_tao_cái_thớt.toString());</span><br><span class="line"><span class="comment">// =&gt; bạn đoán xem log ra thứ gì?</span></span><br></pre></td></tr></table></figure><p>Bây giờ ta có 1 hàm, gọi là quăng_cho_tao_cái_thớt(), kết quả của sự lắp ghép bằng compose tất cả các pure functions ở trên.</p><p>Ta biết compose sẽ gọi từ phải sang trái, nên công đoạn nào làm trước thì để bên phải.</p><p>Chạy thử 1 phát:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thớt = quăng_cho_tao_cái_thớt(<span class="string">'khúc gỗ'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thớt); </span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc</span></span><br></pre></td></tr></table></figure><p>Vậy là đủ công đoạn, khúc gỗ đã trở thành một cái thớt tốt.</p><p>Nhưng chưa hết. Khi bạn treo cái thớt đó ở nhà, nhiều người quen đến chơi thấy đẹp hỏi mua. Nhiều đến mức bạn quyết định kinh doanh thớt.</p><p>Làm thớt kinh doanh thì phải gán nhãn, vậy là bạn tạo ra một pure function mới và dùng compose để làm khuôn sản suất loại thớt commercial này.</p><p>Dễ ợt, không ảnh hưởng gì đến loại thớt cho nhà dùng.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nhãn = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã dán nhãn`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> làm_thớt_để_bán = compose(nhãn, móc, chà, khoan, bào, sấy, cưa);</span><br></pre></td></tr></table></figure><p>Hoặc tận dụng lại khuôn mẫu cũ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> làm_thớt_để_bán = compose(nhãn, quăng_cho_tao_cái_thớt);</span><br></pre></td></tr></table></figure><p>Thử xem sao:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thớt_bán = làm_thớt_để_bán(<span class="string">'khúc gỗ'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thớt_bán);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã móc đã dán nhãn</span></span><br></pre></td></tr></table></figure><p>Để mở rộng thị phần, hướng đến phân khúc giá rẻ, bạn tạo ra dòng sản phẩm thớt tầm trung, dùng chip MediaTek, bỏ qua bước sấy khô và đánh bóng để giảm giá thành. Rất đơn giản:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> làm_thớt_loại_hai = compose(nhãn, móc, khoan, bào, cưa);</span><br></pre></td></tr></table></figure><p>Thử xem sao:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thớt_loại_hai = làm_thớt_loại_hai(<span class="string">'khúc gỗ'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thớt_loại_hai);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã bào đã khoan đã móc đã dán nhãn</span></span><br></pre></td></tr></table></figure><p>Lập trình như vậy phải nói là vô cùng tao nhã, lịch thiệp! Đôi khi tôi cảm thấy phong cách lập trình Functional Programming có sự thanh tịnh đầy chất quý tộc, vừa bình dân lại vừa hàn lâm, đẹp đến mức khó hiểu!</p><p>Nếu dùng OOP, có thể chúng ta còn đang loay hoay giữa một đống class Máy Cưa, Máy Bào, Máy Khoan… Hoặc 1 class Máy Làm Thớt khổng lồ có đủ methods cưa, bào, khoan… Rồi còn một mớ properties mà ta phải cân nhắc xem cái nào public, cái nào private. Rồi phải tạo instance, thừa kế qua lại mấy vòng may ra mới làm được cái thớt. Muốn thêm dòng sản phẩm lại càng khó khăn. Phải tạo class Thớt_nhà<em>dùng, extend ra Thớt</em>để<em>bán, Thớt</em>để_bán_loại_2, phiền phức không sao kể xiết!</p><p>Functional Programming thì chỉ cần mấy hàm đơn giản, rời rạc, dùng compose lắp ráp lại như lắp ráp dây chuyền công nghệ là chế được các kiểu thớt.</p><p>Function Composition tựa như một nhà máy hiện đại, mỗi chi tiết linh kiện được xử lý bằng một robot chuyên trách, kết hợp lại với nhau một cách khoa học để tạo ra sản phẩm hoàn thiện.</p><h4 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h4><p>Một biến thể của compose là pipe, vận hành theo chiều ngược lại. Ta có thể implement bằng cách đảo vị trí f và g thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> (x) =&gt; g(f(x)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Hoặc giữ nguyên code của compose nhưng thay reduce bằng reduceRight:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduceRight(<span class="function">(<span class="params">f, g</span>) =&gt;</span> (x) =&gt; f(g(x)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Vì pipe tổ hợp các hàm theo chiều ngược lại so với compose nên ta viết:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> làm_thớt_dỏm = pipe(cưa, bào, nhãn);</span><br></pre></td></tr></table></figure><p>Thử xem sao:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thớt_dỏm = làm_thớt_dỏm(<span class="string">'khúc gỗ'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thớt_dỏm);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã bào đã dán nhãn</span></span><br></pre></td></tr></table></figure><p>Dùng pipe có vẻ thuận mắt hơn. Thứ tự các bước cưa, bào… trông khá tự nhiên. Nếu bạn quen với cách suy luận Toán học thì bạn sẽ thích compose. Còn nếu bạn muốn trực quan dễ hiểu thì cứ dùng pipe.</p><p>compose và pipe là những thuật pháp nhập môn dễ học, dễ dùng, nhưng không kém uy lực, thư viện Functional Programming nào cũng có. Trong Ramda.js, ngoài <a href="http://ramdajs.com/docs/#compose" target="_blank" rel="noopener">compose</a> và <a href="http://ramdajs.com/docs/#pipe" target="_blank" rel="noopener">pipe</a>, các tác giả còn bổ sung thêm pipeK, pipeP, composeK, composeP.</p><p>Khi đã thông thạo, bạn hoàn toàn có thể tạo ra compose theo cách của bạn. Ví dụ composeBinary liên kết các hàm từ giữa sang 2 bên thay vì từ đầu này đến đầu kia, composeRandom liên kết các hàm không theo trật tự cố định… Đó là không gian sáng tạo thuộc về riêng bạn.</p><h3 id="Currying-function"><a href="#Currying-function" class="headerlink" title="Currying function"></a>Currying function</h3><p>Thuật ngữ currying và các dạng curry, curried của nó trong khoa học máy tính được <a href="https://en.wikipedia.org/wiki/Christopher_Strachey" target="_blank" rel="noopener">Christopher Strachey</a> đặt ra từ năm 1967 để ghi nhớ công lao của <a href="https://en.wikipedia.org/wiki/Haskell_Curry" target="_blank" rel="noopener">Haskell Brooks Curry</a>, một nhà Toán học và Luận lý học người Mỹ.</p><p>Currying function là làm cho 1 function trở thành “curried function”.</p><p>Cái function ban đầu đó hơi ngốc nghếch, nó cần bạn truyền vào N tham số để tính toán, mà nếu thiếu 1 tham số, nó sẽ không chạy.</p><p>Ví dụ hàm sum thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sum cần 3 tham số để cộng dồn lại, nếu thiếu, sẽ không tính toán ra được.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// có thể ra sân</span></span><br><span class="line">sum(<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">sum(<span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">sum(<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">sum(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nhưng</span></span><br><span class="line">sum(<span class="number">4</span>, <span class="number">5</span>); <span class="comment">// =&gt; NaN</span></span><br></pre></td></tr></table></figure><p>Đây là thiếu tiền đạo cả đội không chịu ra sân tập! Nhưng cuộc sống đâu phải lúc nào cũng thuận lợi, đầy đủ cho chúng ta? Dù cả mấy tiền đạo đều bị chấn thương, treo giò, trốn tập thì các anh còn lại vẫn phải có trách nhiệm ra sân chứ!</p><p>Currying chính là kỹ thuật biến hàm sum ngốc đó trở thành một function vi diệu hơn, nếu bạn gọi nó với 1 tham số, nó sẽ trả về 1 hàm tạm thời, giữ lại tham số đó, chờ khi nào đủ 3 tham số thì mới thực hiện tính toán.</p><p>Hình dung bạn tổ chức một buổi party, mời 3 người bạn tham gia. Lúc này đã có mặt 2 người, còn 1 người đến muộn. Bạn quyết định không cần chờ nữa. Bữa tiệc cứ bắt đầu đã, chừng nào người kia đến thì tính tiếp.</p><p>Đây là 1 cách implement cho hàm curry:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> totalArguments = fn.length;</span><br><span class="line">  <span class="keyword">let</span> next = <span class="function">(<span class="params">argumentLength, rest</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argumentLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next(</span><br><span class="line">          argumentLength - args.length,</span><br><span class="line">          [</span><br><span class="line">            ...rest,</span><br><span class="line">            ...args,</span><br><span class="line">          ]</span><br><span class="line">        );</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(...rest);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> next(totalArguments, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Và curry tất nhiên cũng là higher-order function.</p><p>Thử dùng với sum xem sao:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curriedSum = curry(sum);</span><br></pre></td></tr></table></figure><p>curriedSum bây giờ là phiên bản curried của hàm sum trước đó.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curriedSum(<span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">curriedSum(<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">curriedSum(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// và</span></span><br><span class="line">curriedSum(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// =&gt; [Function]</span></span><br></pre></td></tr></table></figure><p>curriedSum(5, 3) là 1 function. Nó đang chờ đợi tham số cuối cùng xuất hiện. Nếu bây giờ ta gọi nó với 1 tham số thì kết quả sẽ được tính toán ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curriedSum(<span class="number">5</span>, <span class="number">3</span>)(<span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br></pre></td></tr></table></figure><p>Nếu ta truyền nhiều hơn số lượng tham số còn thiếu thì sao? Ở đây là 1 tham số cuối cùng. Theo cách implement trên thì nó sẽ bỏ qua các tham số dư thừa. Các phiên bản curry của <a href="http://ramdajs.com/docs/#curry" target="_blank" rel="noopener">Ramda.js</a> và <a href="https://lodash.com/docs/4.17.10#curry" target="_blank" rel="noopener">Lodash FP</a> cũng hành xử như vậy.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curriedSum(<span class="number">5</span>, <span class="number">3</span>)(<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>); <span class="comment">// =&gt; 10</span></span><br></pre></td></tr></table></figure><p>Một điểm quan trọng nữa là ta có thể phân tách hàm gốc ra từ 1 đến N phần, với N là số lượng tham số của hàm gốc đó. Chẳng hạn, nếu hàm gốc có 3 tham số, ta có thể chia nó ra 1, 2 hoặc 3 phần. Những cách viết sau là tương đương:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curriedSum(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">curriedSum(<span class="number">3</span>, <span class="number">5</span>)(<span class="number">2</span>);</span><br><span class="line">curriedSum(<span class="number">3</span>)(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">curriedSum(<span class="number">3</span>)(<span class="number">5</span>)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>curry, cũng như compose và pipe là những kỹ thuật căn bản, ai cũng phải học, phải biết. Mọi ngôn ngữ được thiết kế với tư tưởng Functional Programming như Haskell, Scalla, Elm… đều có sẵn các hàm này. Chúng rất tinh tế và được dùng ở khắp nơi.</p><p>Chỉ cần thành thạo 3 pháp quyết này thì bạn đã được xem như đệ tử Functional Programming chân chính.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Như vậy, Functional Programming là nghệ thuật lập trình trong đó ta:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sử dụng functions để điều khiển workflow&lt;/li&gt;
&lt;li&gt;tuân thủ 2 nguyên tắc immutability và purity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nói cách khác, chư vị tin hữu muốn tu luyện Functional Programming thì phải giữ đạo tâm trong sáng, ý chí kiên định, hàng ngày chiêm nghiệm, suy diễn, cảm ngộ function, tu vi theo đó sẽ không ngừng thăng tiến.&lt;/p&gt;
&lt;p&gt;Nhưng làm thế nào để cảm ngộ “phân sần ý cảnh”? Ta phải nắm bắt, quan sát, tư duy, suy tưởng về function ra sao? Sau đây là những pháp quyết nhập môn.&lt;br&gt;
    
    </summary>
    
    
      <category term="functional programming" scheme="http://nthung2112.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Functional Programming - Phần 1 - Con đường sáng</title>
    <link href="http://nthung2112.github.io/2018/06/Functional-Programming-Phan-1-Con-duong-sang.html"/>
    <id>http://nthung2112.github.io/2018/06/Functional-Programming-Phan-1-Con-duong-sang.html</id>
    <published>2018-06-12T08:35:00.000Z</published>
    <updated>2018-06-23T08:53:43.941Z</updated>
    
    <content type="html"><![CDATA[<p>Lúc bấy giờ, Tin giới Tây phương xuất hiện 2 lão quái Nguyên Anh hậu kỳ đỉnh phong, chỉ thiếu nửa bước cảm ngộ ý cảnh là đột phá tới cảnh giới Hóa Thần. Một người là Đồ Linh tôn giả - tức Alan Turing, nổi danh với pháp môn Turing Machine. Người kia là Khâu Kỳ thượng tiên, Alonzo Church, tung hoành tam giới bằng đạo thuật Lambda Calculus (1).</p><p>Turing Machine của Alan Turing và Lambda Calculus của Alonzo Church thực ra là hai cách tiếp cận nguyên lý xử lý tính toán trong computer, thường được giới chuyên môn gọi chung là Luận đề Church - Turing (<a href="https://plato.stanford.edu/entries/church-turing/" target="_blank" rel="noopener">The Church-Turing Thesis</a>).</p><a id="more"></a><p>Turing Machine đặt cơ sở trên việc nắm giữ state machine và trạng thái tiến trình, còn ý tưởng Lambda Calculus được xây dựng trên các tính chất của hàm toán học. Lấy tu vi của bổn tiên hiện giờ thì chưa lĩnh hội được mấy thứ cao siêu như vậy, nên không dám lạm bàn ở đây. Chỉ biết rằng, 2 thuật pháp kể trên là khởi nguồn của 2 trường phái tu luyện mạnh nhất trong tin giới hiện nay: Object Oriented Programming và Functional Programming.</p><p>Có khá nhiều cơ chế lập trình - Programming Paradigm. OOP và Functional Programming chỉ là 2 trong số đó. Trong cuốn “<a href="https://drive.google.com/file/d/1sNAojaDlY4Q9LAMad_2aJLIUBt06ru7U/view" target="_blank" rel="noopener">Programming Paradigms for Dummies: What Every Programmer Should Know</a>“, tác giả Peter Van Roy đưa ra mô hình tổng hợp quan hệ giữa các cơ chế lập trình như thế này:</p><p> <img src="https://i.imgur.com/1yDCYYq.png" alt=""></p><p>Trong lịch sử công nghệ, có vẻ OOP chiếm ưu thế hơn so với Functional Programming. Bạn cứ thử nhìn xung quanh mình là biết, từ thời tập tành code đã thấy thiên địa tràn ngập quy tắc OOP rồi. Các job description, các buổi interview đều nhắc đến OOP như pháp thuật căn bản. Thảo luận kỹ thuật hầu hết xoay quanh mấy khái niệm Class, Object, Inheritance, rồi cao hơn thì SOLID, Polymorphism, Encapsulation…</p><p>Nhưng, trên thế giới, từ thời <a href="http://lisp-lang.org/" target="_blank" rel="noopener">Lisp</a> đến <a href="https://en.wikipedia.org/wiki/FP_%28programming_language%29" target="_blank" rel="noopener">FP</a>, rồi <a href="https://www.haskell.org/" target="_blank" rel="noopener">Haskell</a>, <a href="https://elixir-lang.org/" target="_blank" rel="noopener">Elixir</a>, chưa bao giờ thiếu vắng những tu tin giả đi theo con đường Functional Programming. Nhất là khoảng sau 2010, không rõ vì sao người ta bắt đầu phàn nàn nhiều hơn về OOP, trích dẫn nhiều hơn luận điểm banana/gorilla của Joe Armstrong (2), theo đó, chủ đề “Functional Programming” bắt đầu nóng dần trở lại.</p><p>Tôi biết đến Functional Programming vào khoảng 2015 qua một talk show trên YouTube của “<a href="https://en.wikipedia.org/wiki/Robert_C._Martin" target="_blank" rel="noopener">chú Bob</a>“, nhưng không hiểu lắm nên cũng không chú ý.</p><p>Phải sang 2016, tôi mới chính thức tìm hiểu sâu về Functional Programming sau khi đọc 2 loạt bài viết “<a href="https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea" target="_blank" rel="noopener">Composing Software</a>“ của <a href="https://medium.com/@_ericelliott" target="_blank" rel="noopener">Eric Elliott</a> và “<a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536" target="_blank" rel="noopener">So You Want to be a Functional Programmer</a>“ của <a href="https://medium.com/@cscalfani" target="_blank" rel="noopener">Charles Scalfani</a> trên Medium.</p><p>Eric Elliott lần lượt giải thích từng concepts của Functional Programming một cách tường tận, dễ hiểu. Còn Charles Scalfani đúng là fan cuồng Functional Programming. Anh trình bày nó dưới dạng một hệ thống triết lý, thế giới quan đặc sắc. Thậm chí, Scalfani còn đề cao Functional Programming như nấc thang tiến hóa trong lịch sử lập trình. Lối viết của anh gây ấn tượng cực mạnh.</p><p> <img src="https://i.imgur.com/e3zKVPq.png" alt=""></p><p>Trước đó, Scalfani còn có bài “<a href="https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53" target="_blank" rel="noopener">Goodbye, Object Oriented Programming</a>“ gây tranh luận sôi nổi.</p><p>Nhưng bạn đọc nên lưu ý, Functional Programming không bài xích OOP. Chúng chỉ là những con đường tu luyện khác nhau, cùng hướng về Đại Đạo. Trong khi viết code, ta hoàn toàn có thể phối hợp nhiều cơ chế lập trình khác nhau, miễn sao đạt đến kết quả Đúng - Nhanh - Ổn - Đẹp.</p><p>ReactJS là một ví dụ tiêu biểu, có thể coi nó như 7 phần Functional Programming + 3 phần OOP. Về điểm này, <a href="https://twitter.com/anjanavakil" target="_blank" rel="noopener">Anjana Vakil</a> có một bài thuyết trình rất hay ở GOTO 2017.</p><div class="video-container"><iframe src="//www.youtube.com/embed/Pg3UeB-5FdA" frameborder="0" allowfullscreen></iframe></div><p>Dù sao, từ đó đến nay, khuynh hướng tư duy Functional Programming vẫn từng bước lan rộng, ảnh hưởng đến thiết kế của rất nhiều chương trình hiện đại. Chỉ cần để ý một chút, chúng ta có thể nhận ra các đặc tính nổi bật của Functional Programming xuất hiện trong hầu hết frameworks và các bản cập nhật ngôn ngữ mới. Thậm chí, nếu xét kỹ, những khái niệm thoạt nhìn có vẻ không liên quan như WebComponent, Serverless, Microservice… cũng ẩn hiện tư tưởng Functional Programming. Và tôi gần như không còn đụng tới class, new, this nữa.</p><p> <img src="https://i.imgur.com/LuyuYCU.jpg" alt=""></p><h3 id="What’s-Functional-Programming"><a href="#What’s-Functional-Programming" class="headerlink" title="What’s Functional Programming?"></a>What’s Functional Programming?</h3><p>Vậy rốt cuộc Functional Programming là cái gì? Nếu google bạn sẽ tìm thấy hàng tá cách giải thích khác nhau. Còn tôi chủ chương nên định nghĩa ngắn gọn thế này:</p><p><em>Functional Programming là phương pháp lập trình lấy function làm đơn vị thao tác cơ bản.</em></p><p>Đúng vậy. Functional Programming xét về lý tưởng thì chỉ có function, function và function. Không lệnh gán (assignment statements), không cần tới các biến (variables), không lưu giữ trạng thái toàn cục (global state). Trong Functional Programming, chúng ta điều khiển dòng chảy chương trình bằng cách phối hợp các functions lại với nhau. Chúng ta tung hứng các functions qua lại, nhận vào function, nhả ra function, lồng ghép, xâu chuỗi, biến hóa chúng theo mọi cách có thể nghĩ ra.</p><p>Đó gọi là không gian “<a href="https://en.wikipedia.org/wiki/First-class_function" target="_blank" rel="noopener">first-class functions</a>“, nơi lập trình viên đối xử với functions như “first-class citizens”. Ở đâu functions được coi trọng như vậy, ở đó ta có thể lập trình theo cơ chế Functional Programming. JavaScript, Python, Golang, ngay cả PHP chính là như vậy. Java tính từ v8.0 ra mắt năm 2017 cũng là như vậy. Dù không hoàn hảo như Haskell, F#, etc - những tu chân giới vốn được sinh ra cho Functional Programming - nhưng ta vẫn có thể tu luyện Functional Programming được…</p><p>Chỉ có điều phải vận dụng khác một chút, linh hoạt hơn một chút. Đó là lý do tại sao trong các chương trình JavaScript, Python, dù viết theo phong cách Functional Programming nhưng vẫn phải dùng đến các biến, lệnh gán để thao tác.</p><p>Các tu tin giả tầng thấp muốn bắt đầu con đường Functional Programming cần phải nắm bắt những khái niệm cơ bản như Immutability, Purity, Higher-order functions, Currying function, Function Composition… Sau khi thăng cấp cảnh giới cao hơn thì có thể tìm hiểu Monad, Functor, Setoid, Idempotent, Lens… và nhiều nữa.</p><p>Nào, bây giờ hãy bắt đầu hành trình…</p><h3 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h3><p>Immutability nghĩa là tính bất biến.</p><p>Nguyên tắc thứ nhất trong Functional Programming là: cái nào đã khai báo một lần thì mãi mãi như vậy, không bao giờ thay đổi nữa. Các biến hoặc đối tượng trong kịch bản Functional Programming nếu có thì phải immutable.</p><p>Code thế này không phải là Functional Programming vì x và y bị thay đổi.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  y += x;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mutable là điều tối kỵ trong Functional Programming. Cần phải hạn chế đến mức thấp nhất. Các mẫu coding convention và best practices thông dụng hiện nay đều khuyến khích sử dụng const để khai báo, bỏ hẳn var , và dùng let đúng liều lượng.</p><p>Đối với Object, ta nên dùng Object.freeze để lock toàn bộ thuộc tính. Cũng có thể dùng Object.defineProperty, Object.defineProperties để lock một số thuộc tính quan trọng. Các giải pháp này đều chỉ hỗ trợ 1 cấp thuộc tính. Phải chủ động code thêm nếu muốn áp dụng lên các thuộc tính con.</p><p>Nếu dự án đủ phức tạp, hãy cân nhắc sử dụng các thư viện chuyên dụng như <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">Immutable.js</a>, <a href="https://github.com/Yomguithereal/baobab" target="_blank" rel="noopener">Baobap</a>…</p><h3 id="Purity"><a href="#Purity" class="headerlink" title="Purity"></a>Purity</h3><p>Purity là tính thuần khiết, thuần túy, sự trong sạch, không bị pha tạp.</p><p>Đây là nguyên tắc thứ hai trong Functional Programming: tất cả các hàm đều phải là pure function, không có hiệu ứng phụ (side effect), không được tác động lên bất cứ giá trị nào bên ngoài nó, cũng nói không với chỉnh sửa tham số input.</p><p>Hàm dưới đây không phải pure function vì nó chỉnh sửa DOM element bên ngoài và thay đổi giá trị chứa trong localStorage.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateView = <span class="function">(<span class="params">html</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> $view = <span class="built_in">document</span>.getElementById(<span class="string">'panel'</span>);</span><br><span class="line">  $view.innerHTML = html;</span><br><span class="line">  localStorage.setItem(<span class="string">'panelCache'</span>, html);</span><br><span class="line">  <span class="keyword">return</span> $view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đặc điểm quan trọng nữa của pure function là với mỗi tập giá trị đầu vào nhất định, luôn có 1 và chỉ 1 kết quả trả về tương ứng. Đây là tính chất của hàm số toán học.</p><p>Hàm dưới đây không phải pure function vì trả về kết quả khác nhau cho cùng đầu vào:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getDuration = <span class="function">(<span class="params">timestamp</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Date</span>.now() - timestamp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Pure function trong Functional Programming thường ngắn gọn, đơn giản và chỉ xử lý duy nhất 1 vấn đề logic.</p><p>Đây là 1 pure function kinh điển:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Dù bạn có gọi hàng triệu lần thì add(3, 2) vẫn luôn trả về 5.</p><p>Viết unit test cho pure function là nhiệm vụ dễ chịu như dạo chơi cùng một thiếu nữ ngây thơ trong trắng vậy!</p><p>Immutability và Purity là 2 đặc trưng cơ bản nhất của Functional Programming, cho phép phân biệt với các cơ chế lập trình khác. Tu tin giả tu luyện theo con đường này nhất định phải giữ tâm niệm “immutable” và “pure” trong từng sát na.</p><h3 id="Chu-thich"><a href="#Chu-thich" class="headerlink" title="Chú thích"></a>Chú thích</h3><p>1, Chữ Tàu ghi Alan Turing là 艾伦图灵 - Ngải Luân Đồ Linh, Alonzo Church là 阿隆佐邱奇 - A Long Tá Khâu Kỳ.</p><p>2, “You wanted a banana but you got a gorilla holding the banana”.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lúc bấy giờ, Tin giới Tây phương xuất hiện 2 lão quái Nguyên Anh hậu kỳ đỉnh phong, chỉ thiếu nửa bước cảm ngộ ý cảnh là đột phá tới cảnh giới Hóa Thần. Một người là Đồ Linh tôn giả - tức Alan Turing, nổi danh với pháp môn Turing Machine. Người kia là Khâu Kỳ thượng tiên, Alonzo Church, tung hoành tam giới bằng đạo thuật Lambda Calculus (1).&lt;/p&gt;
&lt;p&gt;Turing Machine của Alan Turing và Lambda Calculus của Alonzo Church thực ra là hai cách tiếp cận nguyên lý xử lý tính toán trong computer, thường được giới chuyên môn gọi chung là Luận đề Church - Turing (&lt;a href=&quot;https://plato.stanford.edu/entries/church-turing/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Church-Turing Thesis&lt;/a&gt;).&lt;/p&gt;
    
    </summary>
    
    
      <category term="functional programming" scheme="http://nthung2112.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Cấu trúc projects và đặt tên components trong React</title>
    <link href="http://nthung2112.github.io/2018/05/Cau-truc-projects-va-dat-ten-components-trong-React.html"/>
    <id>http://nthung2112.github.io/2018/05/Cau-truc-projects-va-dat-ten-components-trong-React.html</id>
    <published>2018-05-26T16:02:00.000Z</published>
    <updated>2018-05-26T13:12:57.001Z</updated>
    
    <content type="html"><![CDATA[<p>Như bạn đã biết, React chỉ là một thư viện nên nó không chỉ rõ cho người dùng cách tổ chức, phân chia cấu trúc thư mục cho dự án của mình. Xét trên một khía cạnh, có thể điều này là tốt vì dev có thể thoải mái thử rất nhiều cách khác nhau để chọn ra phương pháp phù hợp với dự án của mình. Tuy nhiên, nó lại khiến cho những dev mới bắt đầu sử dụng React cảm thấy khó hiểu. Bài viết này sẽ đưa ra một vài phương pháp phân chia folders, files giúp cho ứng dụng React của bạn có thể mở rộng một cách thuận tiện, nhất là đối với những người mới bước chân vào React và không biết phải làm như thế nào cho hợp lý.</p><a id="more"></a><h1 id="Cau-truc-files-va-folders"><a href="#Cau-truc-files-va-folders" class="headerlink" title="Cấu trúc files và folders"></a>Cấu trúc files và folders</h1><p>Một trong những câu hỏi dev thường gặp phải khi bắt đầu code là “Làm thế nào dể phân chia files và folders”. Để thuận tiện thì chúng ta sẽ bắt đầu từ cấu trúc đơn giản nhất mà package <strong>create-react-app</strong> đã tạo ra. Cụ thể là folder <strong>src</strong>. Đây là folder chính chứa source code, vì vậy chúng ta sẽ tập trung vào phần này. Toàn bộ những files, folder khác nằm ngoài vẫn sẽ được giữ nguyên:</p><p><img src="https://cdn-images-1.medium.com/max/800/1*eXN1LlNnuZmosJ7n7EsJ-Q.png" alt=""></p><h2 id="Tach-rieng-thanh-folder-Containers-va-Components"><a href="#Tach-rieng-thanh-folder-Containers-va-Components" class="headerlink" title="Tách riêng thành folder Containers và Components"></a>Tách riêng thành folder Containers và Components</h2><p>Có thể bạn đã thấy trong một vài dự án, dev thường sử dụng hai folders có tên <em>Components</em> và <em>Containers</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├─ components </span><br><span class="line">└─ containers</span><br></pre></td></tr></table></figure><p>Thoạt nhìn thì có vẻ ổn, nhưng cách phân chia như trên còn tồn tại những nhược điểm như sau:</p><ul><li><strong>Định nghĩa chức năng một cách không rõ ràng</strong> - Sử dụng cấu trúc như trên có thể gây nhầm lẫn, hiểu lần về chức năng của mỗi folder <em>Container</em> và <em>Component</em> , có nhiều người sẽ hiểu chức năng của mỗi folder theo ý khác nhau. Có người thì hiểu <em>Containers</em> là các components thực hiện việc xử lý logic (như handle click, button) và lấy dữ liệu từ server, còn components có nghĩa <em>Presentational Component</em>, thực hiện nhiệm vụ hiển thị view cho người dùng. Có người lại sử dụng <em>Containers</em> để chứa những route components (mỗi component là một link route, nếu như bạn sử dụng react-router), còn <em>Components</em> thì chứa những base component để tạo nên các route components kia. Vì thế khi làm việc trong team sẽ gây ra không đồng nhất và các member khó thống nhất trong việc sử dụng hai folder này.</li><li><strong>Components không còn linh động, reusable</strong> - Ngay cả khi bạn đã code ra một components với chức năng đặc thù, sau này bạn vẫn phải sửa lại components đó do những lí do như đổi requirements, thêm chức năng,… khiến cho file chuyển qua chuyển lại giữa 2 folders <strong>components</strong> và <strong>containers</strong>.</li><li><strong>Components trùng tên</strong> - Khi sử dụng react, tên của một component nên có ý nghĩa như chức năng của nó, và quan trọng là không nên có nhiều components trùng tên nhau trong project để tránh gây nhầm lẫn. Cách tổ chức folders như trên sẽ tạo ra 2 components có tên giống nhau, một sử dụng cho <strong>container</strong>, một sử dụng cho <strong>components</strong> (<em>presentational</em> - hiển thị)</li><li><strong>Giảm hiệu suất code</strong> - Bạn sẽ phải thường xuyên navigate giữa 2 folder trên khi viết cho một tính năng, do một tính năng thường sẽ gồm cả 2 loại components Một cách phân chia khác cũng có cấu trúc 2 folder như trên, nhưng phân biệt dựa trên module . Giả sử ứng dụng của bạn có một module User. Trong đó sẽ tách ra thành 2 folder components và containers:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">└─ User</span><br><span class="line">    ├─ components </span><br><span class="line">    └─ containers</span><br></pre></td></tr></table></figure><p>Theo hướng tiếp cận trên, dev sẽ không phải gặp khó khăn trong việc navigate giữa các folder khi code. Bạn sẽ không phải kéo lên, kéo xuống để tìm xem components của User ở đâu, khi đang hoàn thiện file trong containers để đối chiếu. Tuy nhiên, cách này sẽ sinh ra một đống folder containers và components nếu như hệ thống của bạn lớn và cót rất nhiều modules.</p><p>Như vậy, việc tách biệt 2 folder <strong>components</strong> và <strong>containers</strong> không hẳn là hợp lý. Thay vì tách riêng ra như vậy, các components sẽ được đặt hết trong folder <strong>components</strong> ngoại trừ những components sử dụng làm <em>screens</em></p><h2 id="Tai-cau-truc-folders-dua-tren-module"><a href="#Tai-cau-truc-folders-dua-tren-module" class="headerlink" title="Tái cấu trúc folders dựa trên module"></a>Tái cấu trúc folders dựa trên module</h2><p>Trong folder <strong>components</strong>, chúng ta sẽ nhóm các files lại theo module hoặc feature/tính năng.</p><p>Với tính năng CRUD user, chúng ta chỉ cần module User, nên folder tree sẽ có dạng như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">└─ components</span><br><span class="line">  └─ User</span><br><span class="line">    ├─ Form.jsx</span><br><span class="line">    └─ List.jsx</span><br></pre></td></tr></table></figure><p>Khi component được cấu thành bời nhiều hơn một file (chẳng hạn như phải import nhiều components khác, hay file chỉnh sửa css cho component đó), chúng ta sẽ đưa component này cùng các files liên quan vào một folder có cùng tên. Ví dụ như <strong>Form.jsx</strong> cần thêm <strong>Form.css</strong> để chỉnh style, bạn sẽ có một folder như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">└─ components</span><br><span class="line">  └─ User</span><br><span class="line">    ├─ Form</span><br><span class="line">    │ ├─ Form.jsx</span><br><span class="line">    │ └─ Form.css</span><br><span class="line">    └─ List.jsx</span><br></pre></td></tr></table></figure><h3 id="UI-components"><a href="#UI-components" class="headerlink" title="UI components"></a>UI components</h3><p>Ngoài các folder dành cho module hay tính năng trong ứng dụng của bạn, có thể thêm một folder _UI_ (hoặc <em>base</em>/<em>atomic</em>) dùng cho các component dạng UI - là những phần tử nhỏ sử dụng cho UI trong ứng dụng của bạn. Đây là những component giống các thư viện open source, thường được dùng đi dùng lại nhiều lần trong ứng dụng của bạn, không nhất thiết phải là một module lớn và không thực hiện các business logic. Những ví dụ về components dạng này như Button, Checkbox, SelectBox, Modal, DatePicker, BreadCrumb,…</p><h1 id="Dat-ten-cho-components"><a href="#Dat-ten-cho-components" class="headerlink" title="Đặt tên cho components"></a>Đặt tên cho components</h1><p>Ở phần trên chúng ta đã thấy được cách hệ thống files và folder trong ứng dụng, còn bây giờ sẽ tìm hiểu xem đặt tên components ra sao cho phù hợp.</p><p>Như đã đề cập ở trên, tên của components nên rõ ràng và không bị trùng lặp để có thể dễ tìm lại và tránh nhầm lẫn cho những thành viên khác trong team. Ngoài ra, tên components rõ ràng cũng giúp cho việc debug bằng những extension tools trở nên dễ dàng hơn trên trình duyệt (chẳng hạn như React Dev Tools) - vì khi app của bạn gặp lỗi khi đang chạy thì lỗi sẽ hiển thị ở đúng components xảy ra lỗi.</p><p>Để đặt tên components, chúng ta sẽ đặt theo hướng <em>path-based-component-naming</em>, nghĩa là cấu thành bởi đường dẫn từ folder src/components đến file chúng ta tạo component đó. Chẳng hạn, bạn có một file với đường dẫn <strong>src/components/User/List.jsx</strong> thì tên component được sử dụng trong <strong>List.jsx</strong> sẽ được đặt là <strong>UserList</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span></span><br></pre></td></tr></table></figure><p>Nếu một file trong folder trùng tên với tên folder, chúng ta sẽ không cần phải lặp lại cả tên folder lẫn tên file. Chẳng hạn, có một file <strong>src/components/User/Form/Form.jsx</strong> thì thay vì sử dụng <strong>UserFormForm</strong>, chúng ta sẽ đặt là UserForm.</p><p>Việc đặt tên components theo đường dẫn như trên có những ích lợi như sau:</p><ul><li><strong>Việc search file trong text editor/IDE trở nên thuận tiện hơn</strong> - Chỉ cần gõ vào ô search của IDE hay text editor mà bạn sử dụng là có thể tìm đến file một cách nhanh chóng. Hoặc navigate đến file cũng rất thuận tiện:</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*DLndSrnMgIklk7tAhzgMWg.png" alt=""></p><ul><li><p><strong>Tránh lặp đi lặp lại tên khi import</strong> Theo cách đặt tên như vậy, bạn sẽ luôn đặt tên file giống với chức năng, nhiệm vụ của nó. Đối với component <strong>form</strong> ở trên, chính xác thì phải là <strong>user form</strong>, nhưng do file đã nằm trong folder <strong>User</strong> nên chúng ta không cần lặp lại từ đó trong tên file của component, mà chỉ cần sử dung <strong>Form.jsx</strong></p><p>Có nhiều trường hợp, dev viết app React và đặt tên file/folder cũng như tên component một cách đầy đủ, bao gồm cả tên module lớn và nhỏ, và dần dần sau này khi app scale lên thì việc đặt tên này sẽ trở nên phức tạp hơn rất nhiều. Thử so sánh hai trường hợp sau đây:</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ScreensUserForm <span class="keyword">from</span> <span class="string">'./screens/User/UserForm'</span>;</span><br><span class="line"><span class="comment">// vs</span></span><br><span class="line"><span class="keyword">import</span> ScreensUserForm <span class="keyword">from</span> <span class="string">'./screens/User/Form'</span>;</span><br></pre></td></tr></table></figure><p>Đối với module nhỏ với ít thành phần như trên thì cách đặt tên thứ hai có vẻ như không tạo nhiều khác biệt lắm, ta có thể thấy cách viết thứ nhất vẫn ổn. Tuy nhiên, nếu như app của bạn scale lên với nhiều thành phần, module, chức năng phức tạp thì việc đặt tên như vậy sẽ trở nenen vô cùng kinh khủng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MediaPlanViewChannel <span class="keyword">from</span> <span class="string">'/MediaPlan/MediaPlanView/MediaPlanViewChannel.jsx'</span>;</span><br><span class="line"><span class="comment">// vs</span></span><br><span class="line"><span class="keyword">import</span> MediaPlanViewChannel <span class="keyword">from</span> <span class="string">'./MediaPlan/View/Channel'</span>;</span><br></pre></td></tr></table></figure><p>Chưa kể những dòng như thế này còn lặp lại nhiều lần vì phải import nhiều thành phần cùng lúc…. Ví lí do đó, chúng ta nên đặt tên file và folder đúng với chức năng/nhiệm vụ trực tiếp của nó, thay vì thêm vào tên của những module cha. Còn tên component thì nên đặt theo đường dẫn tương đối so với folder src/components.</p><h1 id="Screens-components-Dung-cho-mot-view-page"><a href="#Screens-components-Dung-cho-mot-view-page" class="headerlink" title="Screens components - Dùng cho một view page"></a>Screens components - Dùng cho một view page</h1><p>Ở trên, bài viết có nhắc đến những compoents không được đặt trong folder components, được gọi là <em>screens</em>. Giống như tên gọi của nó, đây là những components tượng trưng cho một <em>màn hình</em> hiển thị trong ứng dụng của bạn Lấy ví dụ đối với tính năng CRUD users, chúng ta sẽ có những màn hình cơ bản nhất bao gồm:</p><ul><li>List users (/users</li><li>Create user (/user)</li><li>Edit user (/users/:id)</li></ul><p>Như vậy, chúng ta có 3 screens khác nhau. Mỗi screen là một component cấu thành lên một page trong ứng dụng react của bạn. Screen component nên là một presentational component và không nên thực hiện xử lý business logic.</p><p>Các screens sẽ nằm trong một folder screens song song với components trong đường dẫn src, vì mỗi component ở trong sẽ đại diện cho route của ứng dụng, thay vì một module nào đó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">    ├─ components </span><br><span class="line">    └─ screens</span><br><span class="line">      └─ User</span><br><span class="line">        ├─ Form.jsx</span><br><span class="line">        └─ List.jsx</span><br></pre></td></tr></table></figure><p>Nếu ứng dụng của bạn sử dụng react-router, chúng ta sẽ giữ một file Root.jsx trong folder screens và đưa toàn bộ các view route vào trong file này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Redirect, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ScreensUserForm <span class="keyword">from</span> <span class="string">'./User/Form'</span>;</span><br><span class="line"><span class="keyword">import</span> ScreensUserList <span class="keyword">from</span> <span class="string">'./User/List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ScreensRoot = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/user/list"</span> component=&#123;ScreensUserList&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/user/create"</span> component=&#123;ScreensUserForm&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/user/:id"</span> component=&#123;ScreensUserForm&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Router&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ScreensRoot;</span><br></pre></td></tr></table></figure><p>Với cách này chúng ta đã đưa toàn bộ screens vào trong một folder có cùng tên với định nghĩa route: user/ -&gt; User/. Folder User chứa màn hình List và màn hinh Form bên trong. Từ đó bạn có thể dễ dàng tìm thấy màn hình nào render route nào bằng cách nhìn vào url.</p><p>Một màn hình có thể sử dụng để render nhiều route, như chúng ta thấy màn hình Form sẽ render 2 route dành cho việc Create và Edit. Chú ý rằng, chúng ta nên thêm prefix Screen khi đặt tên cho các screen, để tránh nhầm lẫn với các component trong folder components.</p><p>Như vậy tên của screen component đặt trong folder src/screens/User/List.jsx nên được đặt là ScreenUserList:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> UserForm <span class="keyword">from</span> <span class="string">'../../components/User/Form/Form'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ScreensUserForm = <span class="function">(<span class="params">&#123; match: &#123; params &#125; &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      &#123;<span class="string">`<span class="subst">$&#123;!params.id ? <span class="string">'Create'</span> : <span class="string">'Update'</span>&#125;</span>`</span>&#125; User</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;UserForm id=&#123;params.id&#125; /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default ScreensUserForm;</span></span><br></pre></td></tr></table></figure><p>Như trong đoạn code trên thì screen component sẽ không xử lý gì liên quan đến state (data) mà chỉ thực hiện render ra component <em>UserForm</em>.</p><p>Cuối cùng thì chúng ta sẽ có được một cấu trúc folder như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├─ components </span><br><span class="line">│  ├─ User</span><br><span class="line">│  │ ├─ Form</span><br><span class="line">│  │ │ ├─ Form.jsx</span><br><span class="line">│  │ │ └─ Form.css</span><br><span class="line">│  │ └─ List.jsx</span><br><span class="line">│  └─ UI </span><br><span class="line">│</span><br><span class="line">└─ screens</span><br><span class="line">  ├─ User</span><br><span class="line">  │ ├─ Form.jsx</span><br><span class="line">  │ └─ List.jsx</span><br><span class="line">  └─ Root.jsx</span><br></pre></td></tr></table></figure><h2 id="Tong-ket"><a href="#Tong-ket" class="headerlink" title="Tổng kết"></a>Tổng kết</h2><p>Tóm tắt lại, chúng ta cần nhớ những điểm sau đây:</p><ul><li><strong>Presentational</strong> và <strong>Container</strong> components được đặt trong folder src/components</li><li>Nhóm các components lại dựa trên module/feature</li><li>Đưa những component chung được sử dụng nhiều lần (UI components) vào trong src/components/UI</li><li>Viết component <strong>screens</strong> (màn hình) thật đơn giản, ít code</li><li>Nhóm các màn hình lại theo route của ứng dụng. Với route /user/list thì screen sẽ nằm trong src/screens/User/List.jsx.</li><li>Components được dặt tên theo đường dẫn tương đối của so với src/components hoặc src - Tên component trong file src/components/User/List.jx sẽ có tên là UserList, tên component trong file src/screens/User/List.jsx sẽ có tên là ScreensUserList.</li><li>Component trong file có cùng tên với folder chứa nó sẽ không lặp lại tên của folder. Ví dụ file src/components/User/List/List.jsx sẽ có component được đặt tên là UserList, chứ <strong>KHÔNG PHẢI</strong> là UserListList</li></ul><h1 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h1><p>Bài viết đã đưa ra một trong những cách để tổ chức, phân chia cũng như đặt tên cho file, folder và component khi thiết kế ứng dụng bằng React. Đương nhiên, đây chỉ là ý kiến chủ quan, bạn hoàn toàn có thể tự mình thiết lập và đưa ra những pattern mà bạn cảm thấy hợp lý, thuận tiện khi làm việc với React, miễn sao cho trải nghiệm của bản thân là tốt nhất. Xin cảm ơn!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Như bạn đã biết, React chỉ là một thư viện nên nó không chỉ rõ cho người dùng cách tổ chức, phân chia cấu trúc thư mục cho dự án của mình. Xét trên một khía cạnh, có thể điều này là tốt vì dev có thể thoải mái thử rất nhiều cách khác nhau để chọn ra phương pháp phù hợp với dự án của mình. Tuy nhiên, nó lại khiến cho những dev mới bắt đầu sử dụng React cảm thấy khó hiểu. Bài viết này sẽ đưa ra một vài phương pháp phân chia folders, files giúp cho ứng dụng React của bạn có thể mở rộng một cách thuận tiện, nhất là đối với những người mới bước chân vào React và không biết phải làm như thế nào cho hợp lý.&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://nthung2112.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Gooact: React trong 160 dòng code JavaScript</title>
    <link href="http://nthung2112.github.io/2018/05/Gooact-React-trong-160-dong-code-JavaScript.html"/>
    <id>http://nthung2112.github.io/2018/05/Gooact-React-trong-160-dong-code-JavaScript.html</id>
    <published>2018-05-26T08:13:00.000Z</published>
    <updated>2018-05-26T13:12:23.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lam-the-nao-de-xay-dung-React-cho-rieng-minh-chi-trong-vai-phut"><a href="#Lam-the-nao-de-xay-dung-React-cho-rieng-minh-chi-trong-vai-phut" class="headerlink" title="Làm thế nào để xây dựng React cho riêng mình chỉ trong vài phút."></a>Làm thế nào để xây dựng React cho riêng mình chỉ trong vài phút.</h2><h3 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu"></a><strong>Giới thiệu</strong></h3><p><a href="https://reactjs.org" target="_blank" rel="noopener"><strong>React</strong></a> là một thư viện tuyệt vời - nhiều nhà phát triển ngay lập tức đã yêu thích nó vì tính đơn giản, hiệu suất và cách khai báo làm việc. Nhưng cá nhân tôi có một lý do cụ thể khiến nó trở nên đặc biệt đối với tôi - và đó là cách nó hoạt động bên dưới. Tôi tìm thấy những ý tưởng đứng đằng sau React đơn giản nhưng kỳ lạ thú vị - và tôi tin rằng sự hiểu biết nguyên tắc cốt lõi của nó sẽ giúp bạn viết mã nhanh hơn và an toàn hơn.</p><p>Trong bài viết này, tôi sẽ chỉ cho cho bạn cách viết một bản sao của React đầy đủ chức năng, bao gồm Component API và tự triển khai Virtual DOM. Nó được chia thành bốn phần - mỗi phần là một chủ đề chính:</p><ul><li><strong>Elements</strong>: Trong phần này chúng ta sẽ tìm hiểu cách các khối JSX được xử lý thành phiên bản nhẹ của DOM được gọi là VDOM như thế nào.</li><li><strong>Rendering</strong>: Trong phần này tôi sẽ hướng dẫn bạn cách chuyển đổi VDOM thành DOM thông thường.</li><li><strong>Patching</strong>: Trong phần này tôi sẽ trình bày lý do tại sao thuộc tính “key” quan trọng như thế và cách sử dụng VDOM để nối lại với DOM hiện tại một cách hiệu quả.</li><li><strong>Components:</strong> Phần cuối cùng sẽ cho bạn biết về các thành phần React và quy trình tạo, vòng đời và dựng hình của chúng.</li></ul><p>Mỗi phần sẽ kết thúc bằng một ví dụ có link <strong>CodePen</strong> trực tiếp, vì vậy bạn có thể ngay lập tức kiểm tra tất cả các tiến trình chúng ta đã thực hiện. Bắt đầu nào.</p><h3 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a><strong>Elements</strong></h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*KQcMpRQeOW0sdc0wYrwSrw.png" alt=""></p><p><a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html#elements-describe-the-tree" target="_blank" rel="noopener"><strong>Element</strong></a> là một đối tượng trọng lượng nhẹ của một DOM thực tế. Nó chứa tất cả thông tin quan trọng - như node type, attributes và danh sách children —  vì vậy nó có thể dễ dàng rendered trong tương lai. Thành phần giống như cây của các elements được gọi là VDOM - một ví dụ được hiển thị bên dưới:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"ul"</span>,</span><br><span class="line">    <span class="string">"props"</span>: &#123;</span><br><span class="line">        <span class="string">"className"</span>: <span class="string">"some-list"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"children"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"li"</span>,</span><br><span class="line">            <span class="string">"props"</span>: &#123;</span><br><span class="line">                <span class="string">"className"</span>: <span class="string">"some-list__item"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"children"</span>: [</span><br><span class="line">                <span class="string">"One"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"li"</span>,</span><br><span class="line">            <span class="string">"props"</span>: &#123;</span><br><span class="line">                <span class="string">"className"</span>: <span class="string">"some-list__item"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"children"</span>: [</span><br><span class="line">                <span class="string">"Two"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thay vì viết object quái dị đó mọi lúc, hầu hết các nhà phát triển React đều sử dụng cú pháp JSX, trông giống như một sự kết hợp gọn gàng giữa mã JavaScript và các thẻ HTML:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** @jsx createElement */</span><br><span class="line">const list = <span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">"some-list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">"some-list__item"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">"some-list__item"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span>;</span><br></pre></td></tr></table></figure><p>In order to get executed it needs to be transpiled into regular function calls — notice that pragma comment which defines what function must be used:<br>Để được thực hiện, nó cần phải được chuyển thành các gọi hàm thông thường - chú ý comment pragma là phải luôn sử dụng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = createElement(<span class="string">'ul'</span>, &#123;<span class="attr">className</span>: <span class="string">'some-list'</span>&#125;,</span><br><span class="line">    createElement(<span class="string">'li'</span>, &#123;<span class="attr">className</span>: <span class="string">'some-list__item'</span>&#125;, <span class="string">'One'</span>),</span><br><span class="line">    createElement(<span class="string">'li'</span>, &#123;<span class="attr">className</span>: <span class="string">'some-list__item'</span>&#125;, <span class="string">'Two'</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Cuối cùng, function mong muốn được gọi - và nó được cho là trả về cấu trúc VDOM được mô tả ở trên. Việc triển khai của chúng tôi sẽ ngắn gọn - nhưng mặc dù có vẻ nguyên thủy, nó phục vụ mục đích cần một cách hoàn hảo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createElement = <span class="function">(<span class="params">type, props, ...children</span>) =&gt;</span> &#123;</span><br><span class="line">    props = props != <span class="literal">null</span> ? props : &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;type, props, children&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CodePen đầu tiên có sẵn <a href="https://codepen.io/SweetPalma/pen/gzpZNv?editors=0010" target="_blank" rel="noopener"><strong>ở đây</strong></a>— nó chứa phương pháp được mô tả ở trên với một vài cây VDOM do nó tạo ra.</p><h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*Wc-kOHkiu41Rc69-cG9KhA.png" alt=""></p><p><a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener"><strong>Rendering</strong></a> là một quá trình biến VDOM thành DOM hiển thị. Nói chung, nó là một thuật toán khá đơn giản mà đi qua cây VDOM và tạo ra phần tử DOM tương ứng cho mỗi node:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> render = <span class="function">(<span class="params">vdom, parent=<span class="literal">null</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent) parent.textContent = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">const</span> mount = parent ? (<span class="function"><span class="params">el</span> =&gt;</span> parent.appendChild(el)) : (<span class="function"><span class="params">el</span> =&gt;</span> el);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'string'</span> || <span class="keyword">typeof</span> vdom == <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mount(<span class="built_in">document</span>.createTextNode(vdom));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'boolean'</span> || vdom === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mount(<span class="built_in">document</span>.createTextNode(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> vdom.type == <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mount(Component.render(vdom));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> vdom.type == <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(vdom.type);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> [].concat(...vdom.children)) <span class="comment">// flatten</span></span><br><span class="line">            dom.appendChild(render(child));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> vdom.props)</span><br><span class="line">            setAttribute(dom, prop, vdom.props[prop]);</span><br><span class="line">        <span class="keyword">return</span> mount(dom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid VDOM: <span class="subst">$&#123;vdom&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setAttribute = <span class="function">(<span class="params">dom, key, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value == <span class="string">'function'</span> &amp;&amp; key.startsWith(<span class="string">'on'</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> eventType = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">        dom.__gooactHandlers = dom.__gooactHandlers || &#123;&#125;;</span><br><span class="line">        dom.removeEventListener(eventType, dom.__gooactHandlers[eventType]);</span><br><span class="line">        dom.__gooactHandlers[eventType] = value;</span><br><span class="line">        dom.addEventListener(eventType, dom.__gooactHandlers[eventType]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">'checked'</span> || key == <span class="string">'value'</span> || key == <span class="string">'id'</span>) &#123;</span><br><span class="line">        dom[key] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">'key'</span>) &#123;</span><br><span class="line">        dom.__gooactKey = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> value != <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> value != <span class="string">'function'</span>) &#123;</span><br><span class="line">        dom.setAttribute(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Code ở trên có vẻ trông đáng sợ, nhưng hãy làm cho mọi thứ trở nên ít phức tạp hơn bằng cách tách nó thành các phần nhỏ hơn:</p><ul><li><strong>Custom Attribute Setter</strong>: Các thuộc tính được chuyển đến VDOM không phải lúc nào cũng hợp lệ về DOM - những thứ như trình xử lý sự kiện, key định danh và các giá trị phải được xử lý riêng lẻ.</li><li><strong>Primitive VDOM rendering:</strong> Primitives — như strings, numbers, booleans và nulls — được chuyển thành các node văn bản thuần túy.</li><li><strong>Complex VDOM rendering:</strong> Nodes với tag string được biến thành các phần tử DOM với hiển thị children theo đệ quy.</li><li><strong>Component VDOM rendering</strong>: Nodes với tag function tag được xử lý riêng — không chú ý nhiều đến phần đó, chúng ta sẽ thực hiện nó sau.</li></ul><p>CodePen thứ hai có sẵn <a href="https://codepen.io/SweetPalma/pen/ZoGwWY?editors=0010" target="_blank" rel="noopener"><strong>ở đây</strong></a>— nó thể hiện thuật toán render trong hành động.</p><h3 id="Patching"><a href="#Patching" class="headerlink" title="Patching"></a>Patching</h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*2IcfCputh--ch7rTVLCmcw.png" alt=""></p><p><a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener"><strong>Patching</strong></a> là một quá trình hòa hợp DOM hiện có với cây VDOM mới được xây dựng.</p><p>Hãy tưởng tượng bạn có một số VDOM lồng nhau sâu và cập nhật thường xuyên. Khi một cái gì đó thay đổi, ngay cả phần nhỏ nhất - mà phải được hiển thị. Triển khai native sẽ yêu cầu render toàn bộ mỗi lần cập nhật như vậy.</p><ul><li>Xóa các nút DOM hiện có.</li><li>Re-render mọi thứ.</li></ul><p>Đó là lý do thực tế — xây dựng DOM và vẽ lại nó là một hoạt động khá tốn kém. Nhưng chúng ta có thể tối ưu hóa điều này bằng cách viết thuật toán và sẽ yêu cầu ít sửa đổi DOM:</p><ul><li>Xây dựng một VDOM mới.</li><li>Đệ quy so sánh nó với DOM hiện có.</li><li>Tìm các nút đã được thêm, xóa hoặc thay đổi theo bất kỳ cách nào.</li><li>Patch(Vá) chúng lại.</li></ul><p>Nhưng sau đó một vấn đề khác nổi lên — độ phức tạp tính toán. So sánh hai cây có độ phức tạp O(n³) — ví dụ: nếu bạn định patch một ngìn elements — nó sẽ yêu cầu <em>một tỷ</em> so sánh. Điều đó là quá nhìu. Thay vào đó, chúng ta sẽ triển khai một thuật toán độ phức tạp O(n) với hai giả định sau:</p><ul><li>Hai elements của các loại khác nhau sẽ tạo ra những cây khác nhau.</li><li>Nhà phát triển có thể gợi ý các phần tử con nào có thể không đổi qua các lần render khác nhau với prop “key”.</li></ul><p>Trong thực tế, các giả định này có giá trị đối với hầu hết các trường hợp sử dụng thực tế. Bây giờ chúng tôi đã sẵn sàng cho một phần code khác:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patch = <span class="function">(<span class="params">dom, vdom, parent=dom.parentNode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> replace = parent ? <span class="function"><span class="params">el</span> =&gt;</span> (parent.replaceChild(el, dom) &amp;&amp; el) : (<span class="function"><span class="params">el</span> =&gt;</span> el);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> vdom.type == <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Component.patch(dom, vdom, parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom != <span class="string">'object'</span> &amp;&amp; dom <span class="keyword">instanceof</span> Text) &#123;</span><br><span class="line">        <span class="keyword">return</span> dom.textContent != vdom ? replace(render(vdom)) : dom;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'object'</span> &amp;&amp; dom <span class="keyword">instanceof</span> Text) &#123;</span><br><span class="line">        <span class="keyword">return</span> replace(render(vdom));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'object'</span> &amp;&amp; dom.nodeName != vdom.type.toUpperCase()) &#123;</span><br><span class="line">        <span class="keyword">return</span> replace(render(vdom));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'object'</span> &amp;&amp; dom.nodeName == vdom.type.toUpperCase()) &#123;</span><br><span class="line">        <span class="keyword">const</span> pool = &#123;&#125;;</span><br><span class="line">        <span class="keyword">const</span> active = <span class="built_in">document</span>.activeElement;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> index <span class="keyword">in</span> <span class="built_in">Array</span>.from(dom.childNodes)) &#123;</span><br><span class="line">            <span class="keyword">const</span> child = dom.childNodes[index];</span><br><span class="line">            <span class="keyword">const</span> key = child.__gooactKey || index;</span><br><span class="line">            pool[key] = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> vchildren = [].concat(...vdom.children); <span class="comment">// flatten</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> index <span class="keyword">in</span> vchildren) &#123;</span><br><span class="line">            <span class="keyword">const</span> child = vchildren[index];</span><br><span class="line">            <span class="keyword">const</span> key = child.props &amp;&amp; child.props.key || index;</span><br><span class="line">            dom.appendChild(pool[key] ? patch(pool[key], child) : render(child));</span><br><span class="line">            <span class="keyword">delete</span> pool[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> pool) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pool[key].__gooactInstance)</span><br><span class="line">                pool[key].__gooactInstance.componentWillUnmount();</span><br><span class="line">            pool[key].remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> attr <span class="keyword">of</span> dom.attributes) dom.removeAttribute(attr.name);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> vdom.props) setAttribute(dom, prop, vdom.props[prop]);</span><br><span class="line">        active.focus();</span><br><span class="line">        <span class="keyword">return</span> dom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Hãy điều tra tất cả các kết hợp có thể:</p><ul><li><strong>Primitive VDOM + Text DOM:</strong> So sánh giá trị VDOM với nội dung DOM và thực hiện full render nếu chúng khác nhau.</li><li><strong>Primitive VDOM + Element DOM :</strong> Full render.</li><li><strong>Complex VDOM + Text DOM :</strong> Full render.</li><li><strong>Complex VDOM + Element DOM of different type :</strong> Full render.</li><li><strong>Complex VDOM + Element DOM of same type :</strong> Sự kết hợp thú vị nhất, nơi diễn ra sự hòa hợp của children, xem chi tiết bên dưới.</li><li><strong>Component VDOM + any kind of DOM:</strong> Cũng giống như trong phần trước, được xử lý riêng và sẽ được triển khai sau.</li></ul><p>Như bạn có thể thấy, các nút text và phức tạp nói chung không tương thích và yêu cầu full render — may mắn thay đó là một sự thay đổi hiếm hoi. Nhưng những gì về sự hòa hợp của children đệ quy - nó thực hiện như sau:</p><ul><li>Current active element is memoized — reconciliation may break focus sometimes.</li><li>DOM children are moved into temporary pool under their respective keys — index is used as a key by default.</li><li>VDOM children are paired to the pool DOM nodes by key and recursively patched — or rendered from scratch if pair is not found.</li><li>DOM nodes that left unpaired are removed from document.</li><li>New attributes are applied to final parent DOM.</li><li>Focus is returned back to previously active element.</li></ul><p>CodePen thứ ba có sẵn <a href="https://codepen.io/SweetPalma/pen/rvOWxa?editors=0010" target="_blank" rel="noopener"><strong>ở đây</strong></a> — bao gồm ví dụ nhỏ về list patching.</p><h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*wOrDURrPrNvH3eKeaQuyQQ.png" alt=""></p><p><a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener"><strong>Component</strong></a> về mặt khái niệm tương tự như hàm JavaScript — nó có đầu vào tùy ý được gọi là “props” và trả về tập các elements mô tả những gì sẽ xuất hiện trên màn hình. Nó có thể được định nghĩa là một stateless function hoặc derived class với trạng thái bên trong của riêng và tập các phương thức và các lifecycle hooks. Tôi sẽ ngắn gọn về lý thuyết - tốt hơn hãy xem code:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">this</span>.props = props || &#123;&#125;;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> render(vdom, parent=<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, vdom.props, &#123;<span class="attr">children</span>: vdom.children&#125;);</span><br><span class="line">        <span class="keyword">if</span> (Component.isPrototypeOf(vdom.type)) &#123;</span><br><span class="line">            <span class="keyword">const</span> instance = <span class="keyword">new</span> (vdom.type)(props);</span><br><span class="line">            instance.componentWillMount();</span><br><span class="line">            instance.base = render(instance.render(), parent);</span><br><span class="line">            instance.base.__gooactInstance = instance;</span><br><span class="line">            instance.base.__gooactKey = vdom.props.key;</span><br><span class="line">            instance.componentDidMount();</span><br><span class="line">            <span class="keyword">return</span> instance.base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> render(vdom.type(props), parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> patch(dom, vdom, parent=dom.parentNode) &#123;</span><br><span class="line">        <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, vdom.props, &#123;<span class="attr">children</span>: vdom.children&#125;);</span><br><span class="line">        <span class="keyword">if</span> (dom.__gooactInstance &amp;&amp; dom.__gooactInstance.constructor == vdom.type) &#123;</span><br><span class="line">            dom.__gooactInstance.componentWillReceiveProps(props);</span><br><span class="line">            dom.__gooactInstance.props = props;</span><br><span class="line">            <span class="keyword">return</span> patch(dom, dom.__gooactInstance.render());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Component.isPrototypeOf(vdom.type)) &#123;</span><br><span class="line">            <span class="keyword">const</span> ndom = Component.render(vdom);</span><br><span class="line">            <span class="keyword">return</span> parent ? (parent.replaceChild(ndom, dom) &amp;&amp; ndom) : (ndom);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Component.isPrototypeOf(vdom.type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> patch(dom, vdom.type(props));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(nextState) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.base &amp;&amp; <span class="keyword">this</span>.shouldComponentUpdate(<span class="keyword">this</span>.props, nextState)) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevState = <span class="keyword">this</span>.state;</span><br><span class="line">            <span class="keyword">this</span>.componentWillUpdate(<span class="keyword">this</span>.props, nextState);</span><br><span class="line">            <span class="keyword">this</span>.state = nextState;</span><br><span class="line">            patch(<span class="keyword">this</span>.base, <span class="keyword">this</span>.render());</span><br><span class="line">            <span class="keyword">this</span>.componentDidUpdate(<span class="keyword">this</span>.props, prevState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.state = nextState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextProps != <span class="keyword">this</span>.props || nextState != <span class="keyword">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Các static methods được gọi internally:</p><ul><li><strong>Render</strong>: Performs initial rendering. Stateless components are called as a regular function — result is displayed immediately. Class components are instantiated and attached to the DOM — and only then are rendered.</li><li><strong>Patching:</strong> Performs further update. Sometimes DOM node already has a component instance attached to it — pass new properties to it and patch differences. Perform full render otherwise.</li></ul><p>Các Instance methods có nghĩa là có thể bị ghi đè hoặc được gọi trong các derived classes do người dùng định nghĩa:</p><ul><li><strong>Constructor:</strong> Handles properties and defines initial state, storing them within itself.</li><li><strong>State modifier:</strong> Handles new state, fires all required lifecycle hooks and initiates patch cycle.</li><li><strong>Lifecycle hooks:</strong> Set of methods that are fired throughout component life — on mount, during updates and just before it gets removed.</li></ul><p>Lưu ý rằng phương thức render bị thiếu — nó được định nghĩa trong các child classes. CodePen cuối cùng có <a href="https://codepen.io/SweetPalma/pen/gzavjB?editors=0010" target="_blank" rel="noopener"><strong>ở đây</strong></a> — với tất cả các code chúng tôi đã thực hiện cho đến đây cùng với một ví dụ to-do đơn giản.</p><h3 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h3><p>Đó là tất cả của tôi — chúng ta có một bản sao React đầy đủ chức năng ngay bây giờ. Tôi sẽ gọi nó là Gooact — đó sẽ là một món quà nhỏ cho người bạn tốt của tôi. Chúng ta hãy xem xét kỹ hơn các kết quả:</p><ul><li>Gooact có thể xây dựng và patch hiệu quả các cây DOM phức tạp bằng cách sử dụng VDOM làm tham chiếu.</li><li>Gooact hỗ trợ cả hai functional và class components — cùng với việc xử lý chính xác internal state và hooks lifecycle hoàn chỉnh.</li><li>Gooact dùng  transpiled code cung cấp bởi Babel.</li><li>Gooact vừa đủ trong 160 dòng code JavaScript chưa nén.</li></ul><p>Mục đích chính của bài viết này là để chứng minh các nguyên tắc cốt lõi của cấu trúc bên trong React mà không cần phải đi sâu vào các API phụ trợ - đó là lý do tại sao chúng bị thiếu một số thứ sau trong Gooact:</p><ul><li>Gooact không hỗ trợ những thứ như fragments, portals, contexts, references và một số thứ khác đã được giới thiệu trong các phiên bản mới hơn.</li><li>Gooact không triển khai React Fiber do sự phức tạp của nó — nhưng tôi có thể viết một bài về nó trong tương lai.</li><li>Gooact không theo dõi các key trùng lặp và đôi khi có thể gây ra lỗi.</li><li>Gooact thiếu hỗ trợ callbacks thêm cho một số methods.</li></ul><p>Như bạn có thể thấy, đó là một lĩnh vực tuyệt vời cho các tính năng và cải tiến mới - repository có sẵn <a href="https://github.com/sweetpalma/gooact" target="_blank" rel="noopener"><strong>ở đây</strong></a>, do đó, vì vậy đừng ngần ngại fork và thử nghiệm. Bạn thậm chí có thể cài đặt nó bằng cách sử dụng NPM!</p><p>Tôi muốn cảm ơn toàn bộ <a href="https://github.com/facebook/react/blob/master/AUTHORS" target="_blank" rel="noopener"><strong>React Team</strong></a> đã tạo một thư viện tuyệt vời, làm cho cuộc sống của hàng nghìn nhà phát triển trở nên dễ dàng hơn. Đặc biệt cảm ơn đến <a href="https://github.com/developit/preact" target="_blank" rel="noopener"><strong>Preact</strong></a> tác giả chính là <a href="https://twitter.com/_developit" target="_blank" rel="noopener"><strong>Jason Miller</strong></a> — bài viết này đã được lấy cảm hứng từ cách tối giản nó được thực hiện.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Ok_UbUJOtYxN08pFNHMwMQ.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lam-the-nao-de-xay-dung-React-cho-rieng-minh-chi-trong-vai-phut&quot;&gt;&lt;a href=&quot;#Lam-the-nao-de-xay-dung-React-cho-rieng-minh-chi-trong-va
      
    
    </summary>
    
    
      <category term="react" scheme="http://nthung2112.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Cơ chế sử dụng Virtual DOM trong React</title>
    <link href="http://nthung2112.github.io/2018/05/Co-che-su-dung-Virtual-DOM-trong-React.html"/>
    <id>http://nthung2112.github.io/2018/05/Co-che-su-dung-Virtual-DOM-trong-React.html</id>
    <published>2018-05-25T15:22:00.000Z</published>
    <updated>2018-05-25T15:35:20.184Z</updated>
    
    <content type="html"><![CDATA[<p>Khi tìm hiểu về ReactJS, chắc hẳn bạn đã nghe tới khái niệm DOM ảo (Virtual DOM). Nó giúp cho hiệu suất làm việc của React cao hơn hẳn so với các thư viện và framework Javascript khác. Nhưng bạn đã bao giờ tìm hiểu DOM ảo là gì và nó hoạt động như thế nào trong React? Hôm nay, chúng ta cùng tìm hiểu về chủ đề này nhé.<br><a id="more"></a></p><h2 id="Virtual-DOM-la-gi"><a href="#Virtual-DOM-la-gi" class="headerlink" title="Virtual DOM là gì?"></a><strong>Virtual DOM là gì?</strong></h2><p>Điều đầu tiên tôi muốn nói ở đây là: Virtual DOM không được phát minh ra bởi React, mà React sử dụng nó. DOM ảo là một bản sao chép trừu tượng của DOM thật (HTML DOM). Bạn có thể tưởng tượng nó giống như một bản thiết kế, chứa các chi tiết cần thiết để cấu hình lên một DOM. Ví dụ, thay vì tạo một thẻ <code>&lt;div&gt;</code> thật chứa các thẻ <code>&lt;ul&gt;</code> bên trong, nó sẽ tạo một div object chứa <code>ul</code> object bên trong. Cụ thể ở trong React sẽ là các <code>React.div</code> và <code>React.ul</code>. Khi tương tác, ta có thể tương tác với các object đó rất nhanh mà không phải động tới DOM thật hoặc thông qua DOM API. Tiếp theo chúng ta sẽ tìm hiểu cụ thể React tương tác với DOM ảo như thế nào nhé</p><h2 id="Virtual-DOM-trong-React"><a href="#Virtual-DOM-trong-React" class="headerlink" title="Virtual DOM trong React"></a><strong>Virtual DOM trong React</strong></h2><p>Trước tiên, đã bao giờ bạn tự hỏi tại sao lại phải tương tác thông qua DOM ảo, sao không render trực tiếp ở DOM thật? Vậy bạn đã thực sự hiểu rõ DOM được tạo và re-render như thế nào mỗi khi các thành phần trong DOM thay đổi?</p><p><img src="https://cdn-images-1.medium.com/max/800/1*ZrzXoRljG5Co5KvEsWJNjA.png" alt=""></p><p>Mỗi khi có sự thay đổi, vì cấu trúc của DOM là <strong>tree structure</strong> , khi muốn thay đổi các element và các thẻ con của nó, nó phải thông qua các <strong>Reflow/Layout</strong>, sau đó các thay đổi đó sẽ được Re-painted, rất mất thời gian. Vì thế, càng nhiều các item phải <strong>reflow/repaint</strong>, web của bạn sẽ càng load chậm. Vậy React đã sử dụng DOM ảo như thế nào? Để một trang lớn như Facebook mà chúng ta dùng hàng ngày có hiệu suất làm việc cao như vậy? Để dễ hình dung, chúng ta sẽ tìm hiểu thông qua một ví dụ nho nhỏ dưới đây nhé.</p><p><img src="https://cdn-images-1.medium.com/max/800/1*QX2kUf7GoCkTNkTWBUfX-g.png" alt=""></p><p>Đó là giao diện của một app cộng hoặc trừ 2 số. Người dùng sẽ nhập vào 2 số vào 2 ô input, sau đó chọn phép toán và in ra kết quả ở phần Output.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">output</span>: <span class="string">''</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> IntegerA, IntegerB, IntegerC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">        &lt;h2&gt;using React&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          Input 1:</span></span><br><span class="line"><span class="regexp">          &lt;input type="text" placeholder="Input 1" ref="input1" /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          Input 2 :</span></span><br><span class="line"><span class="regexp">          &lt;input type="text" placeholder="Input 2" ref="input2" /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button</span></span><br><span class="line"><span class="regexp">            id="add"</span></span><br><span class="line"><span class="regexp">            onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">              IntegerA = parseInt(this.refs.input1.value);</span></span><br><span class="line"><span class="regexp">              IntegerB = parseInt(this.refs.input2.value);</span></span><br><span class="line"><span class="regexp">              IntegerC = IntegerA + IntegerB;</span></span><br><span class="line"><span class="regexp">              this.setState(&#123; output: IntegerC &#125;);</span></span><br><span class="line"><span class="regexp">            &#125;&#125;</span></span><br><span class="line"><span class="regexp">          &gt;</span></span><br><span class="line"><span class="regexp">            Add</span></span><br><span class="line"><span class="regexp">          &lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">          &lt;button</span><br><span class="line">            id=<span class="string">"subtract"</span></span><br><span class="line">            onClick=&#123;() =&gt; &#123;</span><br><span class="line">              IntegerA = <span class="built_in">parseInt</span>(<span class="keyword">this</span>.refs.input1.value);</span><br><span class="line">              IntegerB = <span class="built_in">parseInt</span>(<span class="keyword">this</span>.refs.input2.value);</span><br><span class="line">              IntegerC = IntegerA - IntegerB;</span><br><span class="line">              <span class="keyword">this</span>.setState(&#123; <span class="attr">output</span>: IntegerC &#125;);</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            Subtract</span><br><span class="line">          &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;hr /&gt;</span><br><span class="line">          &lt;h2&gt;Output: &#123;<span class="keyword">this</span>.state.output&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">import React, &#123; Component &#125; from 'react';</span></span><br><span class="line"><span class="regexp">import Calculator from './</span>Calculator<span class="string">';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default class Layout extends Component &#123;</span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;Basic Calculator&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;Calculator /&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>Và đây là DOM thật sau lần load đầu tiên</p><p><img src="https://cdn-images-1.medium.com/max/800/1*UeJO46kqBIm0Z8j9B8G6kw.png" alt="How DOM looks after initial rendering"></p><p>Còn đây là DOM ảo mà React tạo ra tương ứng với DOM thật bên trên. Trong React, nó cũng được gọi là một Component với <strong>tree structure</strong> gồm các Component con bên trong</p><p><img src="https://cdn-images-1.medium.com/max/800/1*WMkI8W__gUagZEVCUN37Pg.png" alt="Component Tree structure build by React"></p><p>Sau đây, chúng ta sẽ cùng thử nhập vào 2 số và click vào button Add và xem React xử lí như thế nào nhé.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input 1: 100</span><br><span class="line">Input 2: 50</span><br><span class="line"></span><br><span class="line">Output mong đợi sẽ là 150.</span><br></pre></td></tr></table></figure><p>Điều gì xảy ra khi ta click vào button Add? Ở ví dụ này, chúng ta set <strong>output</strong> là một <strong>state</strong>, vì thế khi một <strong>output</strong> mới được hiện ra nghĩa là ta đã set cho <strong>State</strong> đó một giá trị mới đó là 150.</p><h3 id="Danh-dau-Component-dirty"><a href="#Danh-dau-Component-dirty" class="headerlink" title="Đánh dấu Component dirty"></a>Đánh dấu Component dirty</h3><p><img src="https://cdn-images-1.medium.com/max/600/1*SBXiC6G3cjT5deW1tR0C4w.png" alt="Calculator component marked Dirty"></p><p>Trong React, khi một Component có một <strong>state</strong> mới được set, React đánh dấu nó như là một <strong>dirty Component</strong>, nghĩa là mỗi khi chúng ta gọi tới function <em>setState()</em> thì Component đó sẽ được đánh dấu là <strong>dirty</strong>. Cụ thể ở đây, khi ta click Add, React sẽ đánh dấu Component <strong>Calculator</strong> như thế nào:</p><ol><li>Tất cả các event khi ta thao tác với DOM, nó được gói trọn trong <strong>React event listener</strong>. Vì thế khi nút Add được click, event đó được gửi tới <strong>React event listener</strong> và sau đó nó sẽ chạy một <em>anonymous function</em>()</li><li>Trong <em>anonymous function()</em>, chúng ta gọi tới function <em>this.setState</em> với một <strong>state</strong> value mới.</li><li>Function <em>this.setState</em>() được chạy, Component <strong>Calculator</strong> được đánh dấu là <strong>dirty</strong>.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReactUpdates.js  - enqueueUpdate(component) function</span></span><br><span class="line">dirtyComponents.push(component);</span><br></pre></td></tr></table></figure><ol><li>Và hiện tại, Calculator của chúng ta đã được đánh dấu là <strong>dirty</strong>. Cùng xem những gì sẽ diễn ra tiếp theo</li></ol><h3 id="Chay-qua-Component-lifecycle"><a href="#Chay-qua-Component-lifecycle" class="headerlink" title="Chạy qua Component lifecycle"></a>Chạy qua Component lifecycle</h3><p><a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">Component lifecycle</a> trong React là một loạt các hàm mặc định sẽ được chạy ngay trước, trong và ngay sau quá trình update một Component. Ở ví dụ này, chúng ta không overwrite các hàm đó thì nó sẽ chạy ở các giá trị mặc định.</p><p><img src="https://cdn-images-1.medium.com/max/800/1*HmOs3RG_uYsneZFHnrmYEA.png" alt=""></p><p>Quá trình update Component được diễn ra như sau:</p><ol><li>React sẽ kiểm tra Component đó có được mark <strong>dirty</strong> hay không, sau đó bắt đầu quá trình update.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReactUpdates.js</span></span><br><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (dirtyComponents.length || asapEnqueued) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirtyComponents.length) &#123;</span><br><span class="line">      <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, <span class="literal">null</span>, transaction);</span><br></pre></td></tr></table></figure><ol><li>Sau đó, React sẽ kiểm tra xem có <strong>pending state</strong> nào phải được update hay không hoặc có <strong>forceUpdate</strong> nào không</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>._pendingStateQueue !== <span class="literal">null</span> || <span class="keyword">this</span>._pendingForceUpdate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateComponent(transaction, <span class="keyword">this</span>._currentElement, </span><br><span class="line">      <span class="keyword">this</span>._currentElement, <span class="keyword">this</span>._context, <span class="keyword">this</span>._context);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/600/1*UVixYuczWFlNJ7tbM4TAsg.png" alt=""></p><p>Trong ví dụ này của chúng ta, trong Calculator wrapper, <strong>this.pendingStateQueue,</strong> chứa State object với giá trị Output mới 3. React chạy các lifecycle methods. Đầu tiên là <em>componentWillReceiveProps</em>(), tiếp đó là <em>shouldComponentUpdate()</em> (các phương thức này có giá trị mặc định thế nào nếu chúng ta không overwrite nó thì các bạn tự tìm hiểu nhé). Trong trường hợp này, method <em>shouldComponentUpdate()</em> sẽ trả về <em>true</em>, sau đó sẽ chạy <em>componentWillUpdate(), render()</em> và <em>componentDidUpdate()</em>. Thứ quan trọng nhất trong quá trình update ở đấy chính là <em>render()</em>, đó chính là chỗ mà DOM ảo được tạo lại và update DOM ảo để tìm ra sự khác biệt để sau đó cập nhật ở DOM thật, hay nói các khác là tìm ra cụ thể những element thay đổi để update chỉ những element đó trong DOM thật.</p><h3 id="Xay-dung-lai-Component-Update-DOM-ao-tim-su-thay-doi-update-DOM-that"><a href="#Xay-dung-lai-Component-Update-DOM-ao-tim-su-thay-doi-update-DOM-that" class="headerlink" title="Xây dựng lại Component, Update DOM ảo, tìm sự thay đổi, update DOM thật"></a>Xây dựng lại Component, Update DOM ảo, tìm sự thay đổi, update DOM thật</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*9paXIsNMjkuN4iBdpJ-MXg.png" alt=""></p><p>React sẽ kiểm tra các element trước và sau khi được render lại ở lần vừa rồi có giống nhau hay không, sau đó bắt đầu quá trình đồng bộ.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prevRenderedElement = <span class="keyword">this</span>._renderedComponent._currentElement;</span><br><span class="line"> <span class="keyword">var</span> nextRenderedElement = <span class="keyword">this</span>._instance.render(); <span class="comment">//Calculator.render() method is called and the element is build.</span></span><br></pre></td></tr></table></figure><p>Quá trình đồng bộ và update DOM thật như sau: </p><p><img src="https://cdn-images-1.medium.com/max/800/1*chzMjpfd821rcHntjWb8rQ.png" alt=""></p><p>Những điểm màu đỏ nghĩa là quá trình đồng bộ sẽ được lặp lại đối với những thành phần con của nó. Và đây là DOM mà chúng ta nhận được sau quá trình đó :</p><p><img src="https://cdn-images-1.medium.com/max/600/1*l2w9vcsBN7wd2UqZ7qZTHA.png" alt=""></p><p>Trong ví dụ này, chỉ có phần Output bị thay đổi, bạn có thể nhìn thấy phần được đánh dấu flash ở hình dưới, chỉ có phần đó được DOM thật re-painted </p><p><img src="https://cdn-images-1.medium.com/max/800/1*-N2b8UJgqIUtgUfPLWtQQw.png" alt=""></p><p>Và cây component được cập nhật tại DOM thực tế.</p><p><img src="https://cdn-images-1.medium.com/max/800/1*xvjOyXVne-7Y0ch0dRTIdw.png" alt=""></p><h2 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a><strong>Kết luận</strong></h2><p>Qua ví dụ trên mong là bạn có thể hình dung phần nào đó cách thực hoạt động của DOM ảo trong React và tính hữu dụng của nó. Nhờ có DOM ảo, React có thể tìm ra các node bị thay đổi và update ở DOM thật chỉ ở những cái node đó, thật thuận tiện và nhanh gọn phải không nào.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Khi tìm hiểu về ReactJS, chắc hẳn bạn đã nghe tới khái niệm DOM ảo (Virtual DOM). Nó giúp cho hiệu suất làm việc của React cao hơn hẳn so với các thư viện và framework Javascript khác. Nhưng bạn đã bao giờ tìm hiểu DOM ảo là gì và nó hoạt động như thế nào trong React? Hôm nay, chúng ta cùng tìm hiểu về chủ đề này nhé.&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://nthung2112.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Tìm Hiểu Regular Expression Javascript</title>
    <link href="http://nthung2112.github.io/2018/05/Tim-Hieu-Regular-Expression-Javascript.html"/>
    <id>http://nthung2112.github.io/2018/05/Tim-Hieu-Regular-Expression-Javascript.html</id>
    <published>2018-05-25T14:38:00.000Z</published>
    <updated>2018-05-25T14:47:51.414Z</updated>
    
    <content type="html"><![CDATA[<p>Regular expression hay còn được gọi tắt là Regex hay RegExp, là một cách để biểu diễn khuôn mẫu của string. Đây là một phần của ngôn ngữ lập trình JavaScript, cũng như nhiều ngôn ngữ lập trình khác. Nếu bạn là một lập trình viên và đã từng sử dụng Regular Expression thì bạn chắc hẳn sẽ thấy rằng nó có cú pháp rất kinh khủng và có phần “bí ẩn”. Tuy nhiên, công cụ này lại cực kì mạnh mẽ và hiệu quả khi dùng để xử lý string. Sau đây, chúng ta sẽ cùng tìm hiểu về Regular Expression trong JavaScript.<br><a id="more"></a></p><h2 id="Khoi-tao-Regular-Expression"><a href="#Khoi-tao-Regular-Expression" class="headerlink" title="Khởi tạo Regular Expression"></a>Khởi tạo Regular Expression</h2><p>Có hai cách để tạo ra một Regular Expression là:</p><ul><li>Sử dụng hàm khởi tạo của đối tượng RegExp</li><li>Viết trực tiếp sử dụng cặp dấu “/ /“</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="regexp">/abc/</span>;</span><br></pre></td></tr></table></figure><p>Cả hai cách trên ta đều thu được một Regular Expression biểu diễn một string có dạng: <em>abc</em>.</p><h2 id="Mot-so-phuong-thuc-cua-Regular-Expression"><a href="#Mot-so-phuong-thuc-cua-Regular-Expression" class="headerlink" title="Một số phương thức của Regular Expression"></a>Một số phương thức của Regular Expression</h2><h3 id="Phuong-thuc-Test"><a href="#Phuong-thuc-Test" class="headerlink" title="Phương thức Test"></a>Phương thức Test</h3><p>Đây là phương thức đơn giản nhất dùng để kiểm tra xem một string có chứa khuôn mẫu đã định nghĩa hay không. Nếu có thì kết quả trả về là TRUE và ngược lại thì là FALSE.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/abc/</span>.test(<span class="string">"abcde"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/abc/</span>.test(<span class="string">"12abcde"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/abc/</span>.test(<span class="string">"abxcde"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>Trong ví dụ trên, 2 string “abcde” và “12abcde” đều chứa “abc” nên kết quả trả về là true. String còn lại “abxcde” không chứa “abc” nên kết quả là false.</p><h4 id="Kiem-tra-trung-khop-voi-tap-hop-cac-ki-tu"><a href="#Kiem-tra-trung-khop-voi-tap-hop-cac-ki-tu" class="headerlink" title="Kiểm tra trùng khớp với tập hợp các kí tự"></a>Kiểm tra trùng khớp với tập hợp các kí tự</h4><p>Nếu chỉ kiểm tra như ví dụ trên thì bạn hoàn toàn có thể sử dụng phương thức <em>indexOf</em> của string thay vì sử dụng Regular Expression. Tuy nhiên, với Regular Expression thì bạn có thể kiểm tra những mẫu string phức tạp hơn. <strong>Ví dụ:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0123456789]/</span>.test(<span class="string">"in 1992"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]/</span>.test(<span class="string">"in 1992"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]/</span>.test(<span class="string">"Hello "</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-5]/</span>.test(<span class="string">"Gold 9999"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>Ví dụ 1, 2, 3 kiểm tra xem string có chứa bất kì chữ số nào từ 0 đến 9. Ví dụ cuối cùng kiểm tra xem string có chứa bất kì chữ số nào từ 0 đến 5. JavaScript sử dụng cặp dấu ngoặc vuông [] để biểu thị việc kiểm tra string có chứa bất kì kí tự nào có trong cặp dấu [] hay không. Trong đó, dấu “-“ giữa hai kí tự dùng để chỉ 1 khoảng giữa hai kí tự đó.</p><ul><li>[0-9] là các chữ số từ 0 đến 9</li><li>[a-z] là các chữ cái từ a đến z</li></ul><p>Ngoài ra, JavaScript cung cấp sẵn một số cách biểu diễn một tập hợp các kí tự:</p><ul><li>\d : bất kì chữ số nào từ 0 đến 9</li><li>\w : một chữ cái</li><li>\s : kí tự trắng (dấu cách, tab, dòng mới,…)</li><li>\D : kí tự không phải số</li><li>\W : kí tự không phải chữ cái</li><li>\S : kí tự không phải kí tự trắng</li><li>. : bất kì kí tự nào trừ dòng mới.</li></ul><p>Ví dụ kiểm tra ngày giờ có định dạng: <strong>dd-mm-yyyy hh:mm</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dateTime = <span class="regexp">/\d\d-\d\d-\d\d\d\d \d\d:\d\d/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dateTime.test(<span class="string">"30-01-2003 15:20"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(dateTime.test(<span class="string">"30-jan-2003 15:20"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h4 id="Dao-nguoc-tap-hop-cac-ki-tu"><a href="#Dao-nguoc-tap-hop-cac-ki-tu" class="headerlink" title="Đảo ngược tập hợp các kí tự"></a>Đảo ngược tập hợp các kí tự</h4><p>Trường hợp bạn muốn kiểm tra một string chứa bất kì kí tự nào không có trong tập hợp đã cho thì bạn có thể sử dụng kí tự “^”. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> notBinary = <span class="regexp">/[^01]/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(notBinary.test(<span class="string">"1100100010100110"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(notBinary.test(<span class="string">"1100100010200110"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h4 id="Lap-lai-khuon-mau"><a href="#Lap-lai-khuon-mau" class="headerlink" title="Lặp lại khuôn mẫu"></a>Lặp lại khuôn mẫu</h4><p>Trong ví dụ về kiểm tra ngày giờ bên trên, “\d” xuất hiện lặp lại rất nhiều lần. Điều này gây nên sự khó theo dõi. Do đó, JavaScript cung cấp cách thức để biểu diễn sự lặp lại khuôn mẫu:</p><ul><li>“+”: biểu thị phần tử xuất hiện &gt;= 1 lần</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/'\d+'/</span>.test(<span class="string">"'123'"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/'\d+'/</span>.test(<span class="string">"''"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><ul><li>“*”: biểu thị phần tử xuất hiện &gt;= 0 lần (có thể không xuất hiện)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/'\d*'/</span>.test(<span class="string">"'123'"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/'\d*'/</span>.test(<span class="string">"''"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><ul><li>“?”: biểu thị phần tử xuất hiện 0 hoặc 1 lần</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> neighbor = <span class="regexp">/neighbou?r/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(neighbor.test(<span class="string">"neighbour"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(neighbor.test(<span class="string">"neighbor"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(neighbor.test(<span class="string">"neighbouur"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><ul><li>{n}: biểu thị phần tử xuất hiện đúng n lần</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;4&#125;/</span>.test(<span class="string">"1234"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;4&#125;/</span>.test(<span class="string">"12345"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;4&#125;/</span>.test(<span class="string">"123"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><ul><li>{x,y}: biểu thị phần tử xuất hiện từ x đến y lần</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,4&#125;/</span>.test(<span class="string">"12345"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,4&#125;/</span>.test(<span class="string">"1234"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,4&#125;/</span>.test(<span class="string">"123"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,4&#125;/</span>.test(<span class="string">"12"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,4&#125;/</span>.test(<span class="string">"1"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><ul><li>{x, }: biểu thị phần tử xuất hiện &gt;= x lần</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,&#125;/</span>.test(<span class="string">"12"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,&#125;/</span>.test(<span class="string">"1234"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,&#125;/</span>.test(<span class="string">"1"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h4 id="Nhom-cac-phan-tu"><a href="#Nhom-cac-phan-tu" class="headerlink" title="Nhóm các phần tử"></a>Nhóm các phần tử</h4><p>Trong nhiều trường hợp bạn muốn lặp lại cả một nhóm các phần tử. Khi đó, bạn phải nhóm các phần tử đó lại sử dụng cặp dấu ngoặc đơn “( )”.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cartoonCrying = <span class="regexp">/boo+(hoo+)+/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cartoonCrying.test(<span class="string">"Boohoooohoohooo"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h4 id="Lua-chon-khuon-mau"><a href="#Lua-chon-khuon-mau" class="headerlink" title="Lựa chọn khuôn mẫu"></a>Lựa chọn khuôn mẫu</h4><p>Trường hợp bạn có nhiều khuôn mẫu và bạn cần kiểm tra xem string đưa ra chứa một trong các khuôn mẫu đó thì bạn có thể viết các Regular Expression tương ứng để kiểm tra. Hoặc sử dụng kí tự (|) để biểu diễn “hoặc”:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animalCount = <span class="regexp">/\d+ (pig|cow|chicken)s?/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(animalCount.test(<span class="string">"15 pigs"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(animalCount.test(<span class="string">"15 pigchickens"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="Phuong-thuc-Exec"><a href="#Phuong-thuc-Exec" class="headerlink" title="Phương thức Exec"></a>Phương thức Exec</h3><p>Nếu như phương thức <strong>test</strong> chỉ kiểm tra xem có tồn tại khuôn mẫu hay không thì phương thức <strong>exec</strong> sẽ trả về một đối tượng chứa thông tin thành phần trùng khớp với khuôn mẫu, ngược lại thì trả về null.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> match = <span class="regexp">/\d+/</span>.exec(<span class="string">"one two 100 200"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match);</span><br><span class="line"><span class="comment">// =&gt; ["100", index: 8, input: "one two 100 200"]</span></span><br><span class="line"><span class="built_in">console</span>.log(match.index);</span><br><span class="line"><span class="comment">// =&gt; 8</span></span><br></pre></td></tr></table></figure><p>Ví dụ trên trả về thành phần thoả mãn khuôn mẫu đầu tiên là: “100”. <em>Index</em> là vị trí đầu tiên của string thoả mãn khuôn mẫu. Khi Regular Expression chứa group với cặp dấu ngoặc đơn thì phần tử đầu tiên trong kết quả sẽ là toàn bộ thành phần trùng khớp, thành phần tiếp theo là phần trùng khớp với group đầu tiên, thành phần tiếp theo là phần trùng khớp với group thứ 2,…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quotedText = <span class="regexp">/'([^']*)'/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(quotedText.exec(<span class="string">"she said 'hello'"</span>));</span><br><span class="line"><span class="comment">// =&gt; ["'hello'", "hello", index: 9, input: "she said 'hello'"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/bad(ly)?/</span>.exec(<span class="string">"bad"</span>));</span><br><span class="line"><span class="comment">// =&gt; ["bad", undefined, index: 0, input: "bad"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/(\d)+/</span>.exec(<span class="string">"123"</span>));</span><br><span class="line"><span class="comment">// =&gt; ["123", "3", index: 0, input: "123"]</span></span><br></pre></td></tr></table></figure><h4 id="Trich-xuat-du-lieu-tu-string"><a href="#Trich-xuat-du-lieu-tu-string" class="headerlink" title="Trích xuất dữ liệu từ string"></a>Trích xuất dữ liệu từ string</h4><p>Phương thức này đặc biệt hữu ích khi bạn muốn lấy thông tin ra từ string. Ví dụ sau đưa ra một string biểu diễn ngày, tháng, năm. Sau đó chúng ta sẽ trích xuất ra thông tin về ngày, tháng và năm ở trong đó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDate</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dateTime = <span class="regexp">/(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)-(\d&#123;4&#125;)/</span>;</span><br><span class="line">  <span class="keyword">var</span> match = dateTime.exec(string);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    day : match[<span class="number">1</span>],</span><br><span class="line">    month : match[<span class="number">2</span>],</span><br><span class="line">    year: match[<span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = findDate(<span class="string">"30-1-2003"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// =&gt; Object &#123;day: "30", month: "1", year: "2003"&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Ranh-gioi-cua-string"><a href="#Ranh-gioi-cua-string" class="headerlink" title="Ranh giới của string"></a>Ranh giới của string</h4><p>Trong ví dụ trên, hàm findDate vẫn tìm ra kết quả nếu như string là “30-1-200300” hay “1130-1-2003”,… Đây là trường hợp không mong muốn. Regular Expression JavaScript cung cấp 2 cách để giải quyết vấn đề này:</p><ul><li>Sử dụng kí tự biểu diễn bắt đầu (^) và kết thúc ($$ string</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDate</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dateTime = <span class="regexp">/^(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)-(\d&#123;4&#125;)$/</span>;</span><br><span class="line">  <span class="keyword">var</span> match = dateTime.exec(string);</span><br><span class="line">  <span class="keyword">if</span>(!match) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    day : match[<span class="number">1</span>],</span><br><span class="line">    month : match[<span class="number">2</span>],</span><br><span class="line">    year: match[<span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = findDate(<span class="string">"30-1-2003"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"><span class="comment">// =&gt; Object &#123;day: "30", month: "1", year: "2003"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = findDate(<span class="string">"0030-1-200300"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"><span class="comment">// =&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = findDate(<span class="string">"Hello 30-1-2003 Haha"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br><span class="line"><span class="comment">// =&gt; null</span></span><br></pre></td></tr></table></figure><ul><li>Sử dụng kí tự biên (\b)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDate</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dateTime = <span class="regexp">/\b(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)-(\d&#123;4&#125;)\b/</span>;</span><br><span class="line">  <span class="keyword">var</span> match = dateTime.exec(string);</span><br><span class="line">  <span class="keyword">if</span>(!match) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    day : match[<span class="number">1</span>],</span><br><span class="line">    month : match[<span class="number">2</span>],</span><br><span class="line">    year: match[<span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = findDate(<span class="string">"30-1-2003"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"><span class="comment">// =&gt; Object &#123;day: "30", month: "1", year: "2003"&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = findDate(<span class="string">"0030-1-200300"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"><span class="comment">// =&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = findDate(<span class="string">"Hello 30-1-2003 Haha"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br><span class="line"><span class="comment">// =&gt; Object &#123;day: "30", month: "1", year: "2003"&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Tao-doi-tuong-RegExp-mot-cach-linh-dong"><a href="#Tao-doi-tuong-RegExp-mot-cach-linh-dong" class="headerlink" title="Tạo đối tượng RegExp một cách linh động"></a>Tạo đối tượng RegExp một cách linh động</h2><p>Trong nhiều trường hợp, bạn muốn tạo ra một Regular Expression với nội dung chưa được biết trước. Bạn có thể sử dụng hàm khởi tạo của RegExp theo cách sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"lampv"</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"LamPV is a suspicious character."</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\b("</span> + name + <span class="string">")\\b"</span>, <span class="string">"gi"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text.replace(regexp, <span class="string">"_$1_"</span>));</span><br><span class="line"><span class="comment">// =&gt; _LamPV_ is a suspicious character.</span></span><br></pre></td></tr></table></figure><p>Trong đó:</p><ul><li>tham số g: chỉ ra rằng khuôn mẫu áp dụng Global, nghĩa là nó áp dụng cho tất cả thành phần trùng khớp.</li><li>tham số i: chỉ ra rằng khuôn mẫu không phân biệt chữ hoa và chữ thường.</li></ul><p>Ngoài ra, ở đây tôi có sử dụng phương thức <em>replace</em> của <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noopener">string</a> - dùng để thay thế tất cả những thành phần trùng khớp với khuôn mẫu với “_$1_”. Ở đây $$ chính là nội dung của group thứ nhất.</p><h2 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h2><p>Trên đây là một số kiến thức cơ bản về Regular Expression. Hy vọng qua bài viết này bạn phần nào hiểu và biết cách sử dụng công cụ hiệu quả này trong công việc lập trình của mình, đặc biệt là lập trình JavaScript. Tóm tắt một số khuôn mẫu cơ bản của Regular Expression:</p><ul><li>/abc/ : chuỗi các kí tự <em>abc</em></li><li>/[abc]: bất kỳ kí tự nào thuộc tập hợp a, b, c</li><li>/[^abc]: bất kỳ kí tự nào không thuộc tập a, b, c</li><li>/[0-9]/: bất kỳ kí tự nào thuộc đoạn từ 0 đến 9</li><li>/x+/: thành phần x xuất hiện &gt;= 1 lần</li><li>/x*/: thành phần x xuất hiện &gt;= 0 lần (có thể không xuất hiện)</li><li>/x?/: thành phần x xuất hiện 0 hoặc 1 lần</li><li>/x{2, 4}/: thành phần x xuất hiện từ 2 đến 4 lần</li><li>/(abc)/: cụm <em>abc</em></li><li>/a|b|c/: bất kì pattern nào trong 3 loại a, b, c</li><li>/\d/: chữ số từ 0 đến 9</li><li>/\w/: chữ cái</li><li>/\s/: kí tự trắng (dấu cách, tab, dòng mới,…)</li><li>/./ : bất kỳ kí tự nào trừ dòng mới</li><li>/\b/: ranh giới từ</li><li>/^/: bắt đầu string</li><li>/$$: kết thúc string</li></ul><h2 id="Tham-khao"><a href="#Tham-khao" class="headerlink" title="Tham khảo"></a>Tham khảo</h2><ul><li><a href="http://eloquentjavascript.net/09_regexp.html" target="_blank" rel="noopener">http://eloquentjavascript.net/09_regexp.html</a></li><li>Bài thực hành của tôi: <a href="https://github.com/completejavascript/practical-javascript/blob/master/regular_expression/regexp_golf_completejavascript.com.js" target="_blank" rel="noopener">Regexp Golf</a>, <a href="https://github.com/completejavascript/practical-javascript/blob/master/regular_expression/quoting_style_completejavascript.com.js" target="_blank" rel="noopener">Quoting style</a>, <a href="https://github.com/completejavascript/practical-javascript/blob/master/regular_expression/numbers_again_completejavascript.com.js" target="_blank" rel="noopener">Numbers again</a>.</li><li><a href="http://phamvanlam.com/xac-thuc-ma-mau-rgb-va-ma-mau-hex-su-dung-regex-trong-javascript/" target="_blank" rel="noopener">Xác thực mã màu RGB và mã màu HEX sử dụng Regex trong Javascript</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Regular expression hay còn được gọi tắt là Regex hay RegExp, là một cách để biểu diễn khuôn mẫu của string. Đây là một phần của ngôn ngữ lập trình JavaScript, cũng như nhiều ngôn ngữ lập trình khác. Nếu bạn là một lập trình viên và đã từng sử dụng Regular Expression thì bạn chắc hẳn sẽ thấy rằng nó có cú pháp rất kinh khủng và có phần “bí ẩn”. Tuy nhiên, công cụ này lại cực kì mạnh mẽ và hiệu quả khi dùng để xử lý string. Sau đây, chúng ta sẽ cùng tìm hiểu về Regular Expression trong JavaScript.&lt;br&gt;
    
    </summary>
    
    
      <category term="regex" scheme="http://nthung2112.github.io/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>Giới thiệu về Composing Software</title>
    <link href="http://nthung2112.github.io/2018/05/Gioi-thieu-ve-Composing-Software.html"/>
    <id>http://nthung2112.github.io/2018/05/Gioi-thieu-ve-Composing-Software.html</id>
    <published>2018-05-22T01:09:00.000Z</published>
    <updated>2018-05-25T15:58:41.743Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Ghi chú: Đây là phần giới thiệu về loạt bài “Composing Software” về việc học các kỹ năng functional programming và compositional software trong JavaScript ES6+ từ đầu. Hãy theo dõi còn rất nhiều thứ khác nữa!<br><a href="https://medium.com/javascript-scene/the-rise-and-fall-and-rise-of-functional-programming-composable-software-c2d91b424c8c" target="_blank" rel="noopener"><em>Bài viết Kế tiếp &gt;</em></a><br><a id="more"></a><br>Composition: “Hành động kết hợp các parts hoặc elements để tạo thành một tổng thể.”</p></blockquote><p>Trong lớp học lập trình đầu tiên của tôi, tôi đã nói rằng phát triển phần mềm là  “hành động phá vỡ một vấn đề phức tạp thành các vấn đề nhỏ hơn, và soạn các giải pháp đơn giản để tạo thành một giải pháp hoàn chỉnh cho vấn đề phức tạp.”</p><p>Một trong những hối tiếc lớn nhất của tôi trong cuộc sống là tôi đã không hiểu ý nghĩa của bài học đó từ sớm. Tôi đã học được bản chất của thiết kế phần mềm quá muộn trong cuộc sống.</p><p>Tôi đã phỏng vấn hàng trăm developers. Những gì tôi đã học được từ những buổi đó là Tôi không đơn độc. Rất ít developers phần mềm làm việc mà có nắm bắt tốt về bản chất của phát triển phần mềm. Họ không nhận thức được các công cụ quan trọng nhất chúng ta có thể có để xử lý hoặc làm thế nào để đưa chúng vào sử dụng cho tốt. 100% đã đấu tranh để trả lời một hoặc cả hai câu hỏi quan trọng nhất trong lĩnh vực phát triển phần mềm:</p><ul><li>What is function composition?</li><li>What is object composition?</li></ul><p>Vấn đề là bạn không thể tránh được ‘composition’ chỉ vì bạn không biết về nó. Bạn vẫn làm điều đó - nhưng bạn làm điều đó rất tệ. Bạn viết mã với nhiều lỗi hơn và làm cho các developers khác khó hiểu hơn. Đây là một vấn đề lớn. Các ảnh hưởng ấy tốn nhất nhiều chi phí. Chúng tôi dành nhiều thời gian hơn để duy trì phần mềm hơn là chúng tôi tạo ra nó từ đầu và các lỗi của chúng tôi tác động đến hàng tỷ người trên khắp thế giới.</p><p>Cả thế giới chạy trên phần mềm ngày nay. Mỗi chiếc xe mới là một siêu máy tính mini trên bánh xe, và các vấn đề với thiết kế phần mềm gây ra tai nạn thực sự và chi phí cuộc sống thực của con người. Vào năm 2013, Ban giám khảo đã tìm thấy nhóm phát triển phần mềm của Toyota có tội <a href="http://www.safetyresearch.net/blog/articles/toyota-unintended-acceleration-and-big-bowl-%E2%80%9Cspaghetti%E2%80%9D-code" target="_blank" rel="noopener">“Liều lĩnh không để ý”</a> sau khi một cuộc điều tra tai nạn cho thấy spaghetti code với 10000 biến global.</p><p><a href="https://www.technologyreview.com/s/607875/should-the-government-keep-stockpiling-software-bugs/" target="_blank" rel="noopener">Hackers và governments stockpile bugs</a> để theo dõi mọi người, ăn cắp thẻ tín dụng, khai thác tài nguyên máy tính để khởi chạy các cuộc tấn công từ chối dịch vụ phân tán (DDoS), crack mật khẩu và thậm chí <a href="https://www.technologyreview.com/s/604138/the-fbi-shut-down-a-huge-botnet-but-there-are-plenty-more-left/" target="_blank" rel="noopener">điều khiển cuộc bầu cử</a>.</p><p>Chúng ta phải làm tốt hơn.</p><h3 id="You-Compose-Software-Every-Day"><a href="#You-Compose-Software-Every-Day" class="headerlink" title="You Compose Software Every Day"></a>You Compose Software Every Day</h3><p>Nếu bạn là nhà phát triển phần mềm, bạn lập trình các chức năng và cấu trúc dữ liệu mỗi ngày, cho dù bạn có biết hay không. Bạn có thể làm điều đó một cách có ý thức (và tốt hơn), hoặc bạn có thể làm điều đó một cách vô tình, with duct-tape and crazy glue.</p><p>Quá trình phát triển phần mềm là chia nhỏ các vấn đề lớn thành các vấn đề nhỏ hơn, xây dựng các thành phần giải quyết những vấn đề nhỏ hơn, sau đó kết hợp các thành phần lại với nhau để tạo thành một ứng dụng hoàn chỉnh.</p><h3 id="Composing-Functions"><a href="#Composing-Functions" class="headerlink" title="Composing Functions"></a>Composing Functions</h3><p>Function composition là quá trình áp dụng một function là output của function khác. Trong đại số, có hai hàm số, <code>f</code> và <code>g</code>, <code>(f ∘ g)(x) = f(g(x))</code>. Vòng tròn là toán tử kết hợp. Nó thường được phát âm “kết hợp với” hoặc là “theo sau”. Bạn có thể nói như “f <em>kết hợp với</em> g bằng f of g of x”, or “f <em>theo sau</em> g bằng f of g of x”. Chúng ta nói f <em>theo sau</em> g bởi vì g is giá trị đầu, sau đó output của nó được chuyển thành đối số f.</p><p>Mỗi lần bạn viết code như thế này, nó là composing functions:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> doStuff = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> afterG = g(x);</span><br><span class="line">  <span class="keyword">const</span> afterF = f(afterG);</span><br><span class="line">  <span class="keyword">return</span> afterF;</span><br><span class="line">&#125;;</span><br><span class="line">doStuff(<span class="number">20</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>Mỗi khi bạn viết một chuỗi promise, nó là composing functions:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> wait = <span class="function"><span class="params">time</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">  (resolve, reject) =&gt; setTimeout(</span><br><span class="line">    resolve,</span><br><span class="line">    time</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line">wait(<span class="number">300</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">20</span>)</span><br><span class="line">  .then(g)</span><br><span class="line">  .then(f)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value)) <span class="comment">// 42</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>Tương tự như vậy, mỗi khi bạn thực hiện các gọi các chuỗi phương thức mảng, các hàm lodash, observables (RxJS, etc…) nó là composing functions. Nếu là một chuỗi, thì nó là composing. Nếu bạn chuyển một giá trị trả về vào những functions khác, nó cũng là composing. Nếu bạn gọi hai hàm theo trình tự, nó là composing nếu sử dụng dữ liệu hàm này làm dữ liệu đầu vào cho hàm kia.</p><blockquote><p>Nếu là một chuỗi, thì nó là composing.</p></blockquote><p>Khi bạn viết một functions có chủ ý, bạn sẽ làm tốt hơn.</p><p>Composing functions có chủ ý, chúng ta có thể cải thiện hàm doStuff() thành 1 dòng đơn giản:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> doStuffBetter = <span class="function"><span class="params">x</span> =&gt;</span> f(g(x));</span><br><span class="line">doStuffBetter(<span class="number">20</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>Một trong những phản đối chung về kiểu này là khó để debug. Ví dụ, chúng ta sẽ viết function composition bằng cách nào?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doStuff = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> afterG = g(x);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`after g: <span class="subst">$&#123; afterG &#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> afterF = f(afterG);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`after f: <span class="subst">$&#123; afterF &#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> afterF;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">doStuff(<span class="number">20</span>); <span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"after g: 21"</span></span><br><span class="line"><span class="comment">"after f: 42"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Đầu tiên, hãy trừu tượng rằng “after f”, “after g” và viết vào một tiện ích nhỏ gọi là trace():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> trace = <span class="function"><span class="params">label</span> =&gt;</span> value =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; label &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Now we can use it like this:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doStuff = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> afterG = g(x);</span><br><span class="line">  trace(<span class="string">'after g'</span>)(afterG);</span><br><span class="line">  <span class="keyword">const</span> afterF = f(afterG);</span><br><span class="line">  trace(<span class="string">'after f'</span>)(afterF);</span><br><span class="line">  <span class="keyword">return</span> afterF;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">doStuff(<span class="number">20</span>); <span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"after g: 21"</span></span><br><span class="line"><span class="comment">"after f: 42"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Thư viện functional programming phổ biến như Lodash và Ramda bao gồm các tiện ích để thực hiện function composition dễ hơn. Bạn có thể viết lại hàm trên như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pipe <span class="keyword">from</span> <span class="string">'lodash/fp/flow'</span>;</span><br><span class="line"><span class="keyword">const</span> doStuffBetter = pipe(</span><br><span class="line">  g,</span><br><span class="line">  trace(<span class="string">'after g'</span>),</span><br><span class="line">  f,</span><br><span class="line">  trace(<span class="string">'after f'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">doStuffBetter(<span class="number">20</span>); <span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"after g: 21"</span></span><br><span class="line"><span class="comment">"after f: 42"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>If you want to try this code without importing something, you can define pipe like this:<br>Nếu bạn muốn thử code này mà không cần nhập gì, bạn có thể xác định pipe như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pipe(...fns: [...Function]) =&gt; x =&gt; y</span></span><br><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class="function">(<span class="params">y, f</span>) =&gt;</span> f(y), x);</span><br></pre></td></tr></table></figure><p>Đừng lo lắng nếu bạn chưa thể theo dõi cách hoạt động. Sau đó, chúng tôi sẽ khám phá function composition chi tiết hơn. In fact, it’s so essential, you’ll see it defined and demonstrated many times throughout this text. The point is to help you become so familiar with it that its definition and usage becomes automatic. Be one with the composition.</p><p>pipe() creates a pipeline of functions, passing the output of one function to the input of another. When you use pipe() (and its twin, compose()) You don’t need intermediary variables. Writing functions without mention of the arguments is called <strong>point-free style.</strong> To do it, you’ll call a function that returns the new function, rather than declaring the function explicitly. That means you won’t need the function keyword or the arrow syntax (=&gt;).</p><p>Point-free style can be taken too far, but a little bit here and there is great because those intermediary variables add unnecessary complexity to your functions.</p><p>There are several benefits to reduced complexity:</p><h4 id="Working-Memory"><a href="#Working-Memory" class="headerlink" title="Working Memory"></a>Working Memory</h4><p>Bộ não con người trung bình chỉ có một vài tài nguyên được chia sẻ cho lượng tử rời rạc trong bộ nhớ làm việc <a href="http://www.nature.com/neuro/journal/v17/n3/fig_tab/nn.3655_F2.html" target="_blank" rel="noopener">working memory</a>, và mỗi biến có khả năng tiêu thụ một trong những lượng tử đó. As you add more variables, our ability to accurately recall the meaning of each variable is diminished. Working memory models typically involve 4–7 discrete quanta. Above those numbers, error rates dramatically increase.</p><p>Using the pipe form, we eliminated 3 variables — freeing up almost half of our available working memory for other things. That reduces our cognitive load significantly. Software developers tend to be better at chunking data into working memory than the average person, but not so much more as to weaken the importance of conservation.</p><h4 id="Signal-to-Noise-Ratio"><a href="#Signal-to-Noise-Ratio" class="headerlink" title="Signal to Noise Ratio"></a>Signal to Noise Ratio</h4><p>Concise code also improves the signal-to-noise ratio of your code. It’s like listening to a radio — when the radio is not tuned properly to the station, you get a lot of interfering noise, and it’s harder to hear the music. When you tune it to the correct station, the noise goes away, and you get a stronger musical signal.</p><p>Code is the same way. More concise code expression leads to enhanced comprehension. Some code gives us useful information, and some code just takes up space. If you can reduce the amount of code you use without reducing the meaning that gets transmitted, you’ll make the code easier to parse and understand for other people who need to read it.</p><h4 id="Surface-Area-for-Bugs"><a href="#Surface-Area-for-Bugs" class="headerlink" title="Surface Area for Bugs"></a>Surface Area for Bugs</h4><p>Take a look at the before and after functions. It looks like the function went on a diet and lost a ton of weight. That’s important because extra code means extra surface area for bugs to hide in, which means more bugs will hide in it.</p><blockquote><p><em>Less code = less surface area for bugs = fewer bugs.</em></p></blockquote><h3 id="Composing-Objects"><a href="#Composing-Objects" class="headerlink" title="Composing Objects"></a>Composing Objects</h3><blockquote><p>“Favor object composition over class inheritance” the Gang of Four, <a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;qid=1494993475&amp;sr=8-1&amp;keywords=design+patterns&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=6c553f16325f3939e5abadd4ee04e8b4" target="_blank" rel="noopener">“Design Patterns: Elements of Reusable Object Oriented Software”</a></p></blockquote><blockquote><p>“In computer science, a composite data type or compound data type is any data type which can be constructed in a program using the programming language’s primitive data types and other composite types. […] The act of constructing a composite type is known as composition.” ~ Wikipedia</p></blockquote><p>These are primitives:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = <span class="string">'Claude'</span>;</span><br><span class="line"><span class="keyword">const</span> lastName = <span class="string">'Debussy'</span>;</span><br></pre></td></tr></table></figure><p>And this is a composite:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = &#123;</span><br><span class="line">  firstName,</span><br><span class="line">  lastName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Likewise, all Arrays, Sets, Maps, WeakMaps, TypedArrays, etc… are composite datatypes. Any time you build any non-primitive data structure, you’re performing some kind of object composition.</p><p>Note that the Gang of Four defines a pattern called the <strong>composite pattern</strong> which is a specific type of recursive object composition which allows you to treat individual components and aggregated composites identically. Some developers get confused, thinking that the composite pattern is <em>the only form of object composition.</em> Don’t get confused. There are many different kinds of object composition.</p><p>The Gang of Four continues, “you’ll see object composition applied again and again in design patterns”, and then they catalog three kinds of object compositional relationships, including <strong>delegation</strong> (as used in the state, strategy, and visitor patterns), <strong>acquaintance</strong> (when an object knows about another object by reference, usually passed as a parameter: a uses-a relationship, e.g., a network request handler might be passed a reference to a logger to log the request — the request handler <em>uses</em> a logger), and <strong>aggregation</strong> (when child objects form part of a parent object: a has-a relationship, e.g., DOM children are component elements in a DOM node — A DOM node <em>has</em> children).</p><p>Class inheritance can be used to construct composite objects, but it’s a restrictive and brittle way to do it. When the Gang of Four says “favor object composition over class inheritance”, they’re advising you to use flexible approaches to composite object building, rather than the rigid, tightly-coupled approach of class inheritance.</p><p>We’ll use a more general definition of object composition from <a href="https://www.amazon.com/Categorical-Methods-Computer-Science-Topology/dp/0387517227/ref=as_li_ss_tl?ie=UTF8&amp;qid=1495077930&amp;sr=8-3&amp;keywords=Categorical+Methods+in+Computer+Science:+With+Aspects+from+Topology&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=095afed5272832b74357f63b41410cb7" target="_blank" rel="noopener">“Categorical Methods in Computer Science: With Aspects from Topology”</a> (1989):</p><blockquote><p>“Composite objects are formed by putting objects together such that each of the latter is ‘part of’ the former.”</p></blockquote><p>Another good reference is “Reliable Software Through Composite Design”, Glenford J Myers, 1975. Both books are long out of print, but you can still find sellers on Amazon or eBay if you’d like to explore the subject of object composition in more technical depth.</p><p><em>Class inheritance is just one kind of composite object construction.</em> All classes produce composite objects, but not all composite objects are produced by classes or class inheritance. “Favor object composition over class inheritance” means that you should form composite objects from small component parts, rather than inheriting all properties from an ancestor in a class hierarchy. The latter causes a large variety of well-known problems in object oriented design:</p><ul><li><strong>The tight coupling problem:</strong> Because child classes are dependent on the implementation of the parent class, class inheritance is the tightest coupling available in object oriented design.</li><li><strong>The fragile base class problem:</strong> Due to tight coupling, changes to the base class can potentially break a large number of descendant classes — potentially in code managed by third parties. The author could break code they’re not aware of.</li><li><strong>The inflexible hierarchy problem:</strong> With single ancestor taxonomies, given enough time and evolution, all class taxonomies are eventually wrong for new use-cases.</li><li><strong>The duplication by necessity problem:</strong> Due to inflexible hierarchies, new use cases are often implemented by duplication, rather than extension, leading to similar classes which are unexpectedly divergent. Once duplication sets in, it’s not obvious which class new classes should descend from, or why.</li><li><strong>The gorilla/banana problem:</strong> “…the problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.” ~ Joe Armstrong, <a href="http://www.amazon.com/gp/product/1430219483?ie=UTF8&amp;camp=213733&amp;creative=393185&amp;creativeASIN=1430219483&amp;linkCode=shr&amp;tag=eejs-20&amp;linkId=3MNWRRZU3C4Q4BDN" target="_blank" rel="noopener">“Coders at Work”</a></li></ul><p>The most common form of object composition in JavaScript is known as <strong>object concatenation</strong> (aka mixin composition). It works like ice-cream. You start with an object (like vanilla ice-cream), and then mix in the features you want. Add some nuts, caramel, chocolate swirl, and you wind up with nutty caramel chocolate swirl ice cream.</p><p>Building composites with class inheritance:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="string">'a'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(options);</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="string">'b'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myBar = <span class="keyword">new</span> Bar(); <span class="comment">// &#123;a: 'a', b: 'b'&#125;</span></span><br></pre></td></tr></table></figure><p>Building composites with mixin composition:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  a: <span class="string">'a'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  b: <span class="string">'b'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;...a, ...b&#125;; <span class="comment">// &#123;a: 'a', b: 'b'&#125;</span></span><br></pre></td></tr></table></figure><p>We’ll explore other styles of object composition in more depth later. For now, your understanding should be:</p><ol><li>There’s more than one way to do it.</li><li>Some ways are better than others.</li><li>You want to select the simplest, most flexible solution for the task at hand.</li></ol><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>This isn’t about functional programming (FP) vs object-oriented programming (OOP), or one language vs another. Components can take the form of functions, data structures, classes, etc… Different programming languages tend to afford different atomic elements for components. Java affords classes, Haskell affords functions, etc… But no matter what language and what paradigm you favor, you can’t get away from composing functions and data structures. In the end, that’s what it all boils down to.</p><p>We’ll talk a lot about functional programming, because functions are the simplest things to compose in JavaScript, and the functional programming community has invested a lot of time and effort formalizing function composition techniques.</p><p>What we won’t do is say that functional programming is better than object-oriented programming, or that you must choose one over the other. OOP vs FP is a false dichotomy. Every real Javascript application I’ve seen in recent years mixes FP and OOP extensively.</p><p>We’ll use object composition to produce datatypes for functional programming, and functional programming to produce objects for OOP.</p><p><em>No matter how you write software, you should compose it well.</em></p><blockquote><p>The essence of software development is composition.</p></blockquote><p>A software developer who doesn’t understand composition is like a home builder who doesn’t know about bolts or nails. Building software without awareness of composition is like a home builder putting walls together with duct tape and crazy glue.</p><p>It’s time to simplify, and the best way to simplify is to get to the essence. The trouble is, almost nobody in the industry has a good handle on the essentials. We as an industry have failed you, the software developer. It’s our responsibility as an industry to train developers better. We must improve. We need to take responsibility. Everything runs on software today, from the economy to medical equipment. There is literally no corner of human life on this planet that is not impacted by the quality of our software. We need to know what we’re doing.</p><p>It’s time to learn how to compose software.</p><p><a href="https://medium.com/javascript-scene/the-rise-and-fall-and-rise-of-functional-programming-composable-software-c2d91b424c8c" target="_blank" rel="noopener">Continued in “The Rise and Fall and Rise of Functional Programming”</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Ghi chú: Đây là phần giới thiệu về loạt bài “Composing Software” về việc học các kỹ năng functional programming và compositional software trong JavaScript ES6+ từ đầu. Hãy theo dõi còn rất nhiều thứ khác nữa!&lt;br&gt;&lt;a href=&quot;https://medium.com/javascript-scene/the-rise-and-fall-and-rise-of-functional-programming-composable-software-c2d91b424c8c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;em&gt;Bài viết Kế tiếp &amp;gt;&lt;/em&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
      <category term="hof" scheme="http://nthung2112.github.io/tags/hof/"/>
    
  </entry>
  
  <entry>
    <title>Sử dụng ký pháp BEM trong CSS</title>
    <link href="http://nthung2112.github.io/2018/05/Su-dung-ky-phap-BEM-trong-CSS.html"/>
    <id>http://nthung2112.github.io/2018/05/Su-dung-ky-phap-BEM-trong-CSS.html</id>
    <published>2018-05-20T09:05:00.000Z</published>
    <updated>2018-05-20T09:16:00.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ky-phap-BEM-la-gi"><a href="#Ky-phap-BEM-la-gi" class="headerlink" title="Ký pháp BEM là gì"></a>Ký pháp BEM là gì</h2><p>BEM viết tắt của Blocks, Elements, Modifiers, là một phương pháp đặt tên class cho HTML và CSS. Được phát triển <a href="https://en.bem.info" target="_blank" rel="noopener">tại Yandex</a> giúp lập trình viên hiểu rõ hơn mối quan hệ giữa HTML và CSS trong dự án front end.<br><a id="more"></a><br>Ví dụ sau đây sẽ minh hoạ cách sử dụng ký pháp BEM:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Một Block (khối) độc lập */</span></span><br><span class="line"><span class="selector-class">.btn</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Element (phần tử) con, phụ thuộc vào Block ở trên */</span></span><br><span class="line"><span class="selector-class">.btn__price</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modifier (bộ điều chỉnh) thay đổi trạng thái của Block */</span></span><br><span class="line"><span class="selector-class">.btn--orange</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.btn--big</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>Với cách đặt tên class này, ta có <strong>Block</strong> sẽ đại diện cho một component, và trong ví dụ ở đây, là một button <code>.btn</code>. Block cũng sẽ đóng vai trò là một <em>parent</em> mà trong nó sẽ có một hoặc nhiều hơn <strong>Element</strong> con liên quan. Tên class cho Element và mối quan hệ của nó với Block sẽ được diễn tả bằng tên của Block, tiếp theo là <em>hai gạch dưới</em>, và cuối cùng là tên của Element <code>.btn__price</code>. Thành phần thứ ba của BEM là các <strong>Modifier</strong> mà chúng sẽ giúp điều chỉnh các trạng thái hoặc phái sinh khác của Block / Element. Tên của Modifier sẽ được nối với tên Block / Element phía trước bởi <em>02 gạch ngang</em> <code>.btn--orange</code>.</p><p>Trong HTML, ký pháp BEM sẽ được dùng như sau:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn--big btn--orange"</span> <span class="attr">href</span>=<span class="string">"http://int3ractive.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__price"</span>&gt;</span>$9.99<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__text"</span>&gt;</span>Subscribe<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><iframe src="https://codepen.io/css-tricks/embed/226a65c8f7d64615aabd45048d1d3b6d" width="100%" height="300" frameborder="0" allowfullscreen></iframe><p>Ấn tượng đầu tiên với bạn có thể là tên class quá xấu và mất thời gian hơn so với việc tạo riêng một class mới cho một kiểu button mới. Tuy nhiên, ký pháp BEM sẽ mang lại nhiều lợi ích mà tôi sẽ phân tích tiếp theo sau đây:</p><h2 id="Tai-sao-su-dung-ky-phap-BEM"><a href="#Tai-sao-su-dung-ky-phap-BEM" class="headerlink" title="Tại sao sử dụng ký pháp BEM"></a>Tại sao sử dụng ký pháp BEM</h2><p>Trước tiên, ký pháp BEM giúp người mới tham gia dự án dễ dàng phát hiện ra các trạng thái và các đối tượng con của một component đã được viết sẵn. Điều này giúp tránh cho họ phải viết lại những kiểu CSS đã có sẵn và hạn chế việc viết thừa code hoặc trùng kiểu CSS, điều mà rất hay xảy ra trong dự án lớn có nhiều người tham gia.</p><p>Thứ hai, chỉ cần đọc HTML, bạn vẫn có thể nhanh chóng nắm được các thành phần phụ thuộc lẫn nhau. Trong ví dụ trên, bạn dễ dàng nhìn thấy <code>.btn__price</code> phụ thuộc vào <code>.btn</code> mặc dù bạn chưa biết vai trò cụ thể của nó ngay lập tức.</p><p>Thứ ba, với ký pháp BEM, mọi định nghĩa chỉ có một cấp class và không lồng cấp. Điều này giúp cho độ ưu tiên (specificity) chung của hệ thống CSS thấp. Đây là một lợi thế vì sau này bạn không phải “chiến đấu” với specificity của những thuộc tính đã có sẵn (VD: siêu lồng cấp <code>.a .b .c .d .e {...}</code>) cũng như vận dụng những kỹ thuật không hay để thay thế được style (chẳng hạn <code>!important</code> hay inline CSS).</p><p>Quy luật thác nước cascading của CSS là con dao hai lưỡi: nó giúp dễ dàng định nghĩa những thuộc tính và kiểu chung trên những selector tổng quát mà không cần phải khai báo lặp lại trên từng phần tử, nhưng nếu không nắm được tầm ảnh hưởng, lập trình viên CSS rất dễ gây ra những tác động phụ đến các đối tượng không liên quan khi chỉnh sửa trên những class có sẵn hoặc thậm chí viết mới. Với ký pháp BEM, lập trình viên sẽ tự tin hơn khi bắt tay chỉnh sửa hoặc viết thêm style vì đã biết rõ tầm ảnh hưởng của selector mà mình đang viết ra.</p><p>Tóm lại, ký pháp BEM, nếu áp dụng triệt để, sẽ giúp cải thiện sự phối hợp giữa các thành viên trong nhóm. Ngoài ra, nó buộc người viết CSS phải đầu tư suy nghĩ về việc xây dựng những component độc lập và tái sử dụng được (phù hợp với tiêu chí của <a href="https://github.com/stubbornella/oocss/wiki" target="_blank" rel="noopener">OOCSS</a>).</p><h2 id="Su-dung-BEM-voi-SASS"><a href="#Su-dung-BEM-voi-SASS" class="headerlink" title="Sử dụng BEM với SASS"></a>Sử dụng BEM với SASS</h2><p>Với phiên bản SASS mới nhất hiện nay, việc viết theo ký pháp BEM trong SCSS dễ dàng và thuận tiện hơn bao giờ hết.</p><p>Bạn vẫn sẽ sử dụng cách viết lồng để cô lập khối component và kết hợp với biểu tượng <em>parent</em> <code>&amp;</code> của SASS để đặt tên cho Element và Modifier mà không phải đánh lại tên của Block. VD:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line"></span><br><span class="line">    &amp;__element &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &amp;--mod &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mặc dù viết lồng cấp, khi được biên dịch thành CSS, chúng vẫn được trải phẳng thành một cấp class theo đúng tinh thần của BEM:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block__element</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block--mod</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>Nếu bạn sử dụng LibSass (nhanh hơn rất nhiều lần bản gốc Ruby) để biên dịch SASS, thì hãy đảm bảo các công cụ wrapper được cập nhật các phiên bản tương đương hoặc mới hơn như sau: node-sass <a href="https://github.com/sass/node-sass/releases/tag/v3.4.0" target="_blank" rel="noopener">3.4.0</a>, gulp-sass <a href="https://github.com/dlmanning/gulp-sass/releases/tag/v2.1.0" target="_blank" rel="noopener">2.1.0</a> (nếu sử dụng <a href="https://github.com/gulpjs/gulp" target="_blank" rel="noopener">GulpJS</a>) và grunt-sass <a href="https://github.com/sindresorhus/grunt-sass/releases/tag/v1.1.0" target="_blank" rel="noopener">1.1.0</a> (nếu sử dụng <a href="https://github.com/gruntjs/grunt" target="_blank" rel="noopener">GruntJS</a>)</p><p>Thế còn LESS? Vì tôi không sử dụng LESS nên sẽ không đề cập ở đây. Bạn có thể giúp bổ sung hướng dẫn cho LESS nếu nó có cú pháp trợ giúp tương đương.</p><h2 id="Cac-y-kien-khong-dong-tinh"><a href="#Cac-y-kien-khong-dong-tinh" class="headerlink" title="Các ý kiến không đồng tình"></a>Các ý kiến không đồng tình</h2><p>Vẫn có một số ý kiến hoài nghi và không đồng tình với phương pháp đặt tên này.</p><h3 id="Ten-class-qua-xau"><a href="#Ten-class-qua-xau" class="headerlink" title="Tên class quá xấu"></a>Tên class quá xấu</h3><p>Đồng ý với bạn rằng BEM trông kỳ quặc, tuy nhiên khả năng mà nó đem lại vô cùng lớn và sẽ hoàn toàn xoá mờ hạn chế về mặt “ngoại hình” của nó.</p><p>Ngoài ra BEM đòi hỏi phải gõ nhiều chữ hơn và chiếm nhiều byte ký tự hơn, tuy nhiên với việc sử dụng SASS như trên và việc gzip file đã trở thành tiêu chuẩn như hiện nay, những điều đó không còn là vấn đề so với lợi ích mà BEM mang lại.</p><h3 id="Descendant-selector-van-giai-quyet-duoc-van-de-nhu-truoc-gio"><a href="#Descendant-selector-van-giai-quyet-duoc-van-de-nhu-truoc-gio" class="headerlink" title="Descendant selector vẫn giải quyết được vấn đề như trước giờ"></a>Descendant selector vẫn giải quyết được vấn đề như trước giờ</h3><p>Có một <a href="https://twitter.com/samuelfine/status/575645771334291456" target="_blank" rel="noopener">chỉ trích</a> dành cho BEM thế này: Thay vì viết</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-search</span>        &#123;&#125;</span><br><span class="line"><span class="selector-class">.site-search__field</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.site-search--full</span>  &#123;&#125;</span><br></pre></td></tr></table></figure><p>Họ đặt vấn đề rằng tại sao không viết như thế này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-search</span>        &#123;&#125;</span><br><span class="line"><span class="selector-class">.site-search</span> <span class="selector-tag">input</span>  &#123;&#125;</span><br><span class="line"><span class="selector-class">.site-search</span><span class="selector-class">.full</span>   &#123;&#125;</span><br></pre></td></tr></table></figure><p>Rõ ràng cả hai cách viết đều có thể giúp hiện thực được component cụ thể này và cách thứ hai có vẻ “gọn gàng” hơn. Tuy nhiên khi CSS của toàn bộ dự án trở nên lớn và phức tạp hơn, thì rất khó tránh khỏi các kiểu được định nghĩa chồng chéo lên nhau ngoài tầm kiểm soát.</p><p>Thử tưởng tượng <code>.site-search</code> cũng nằm trong một container tên <code>.main</code> và những <code>input</code> bên trong <code>.main</code> cần được style với <code>.main input</code>. Như vậy, <code>input</code> bên trong <code>.site-search</code> sẽ bị điều chỉnh một cách không mong muốn.</p><p>Tương tự, nếu như <code>.full</code> trong ví dụ trên hoặc một tên phổ biến như <code>.label</code> được dùng như modifier, thì sẽ có rủi ro (rất cao) là một ngày nào đó một lập trình viên khác định nghĩa một class global trùng tên và sẽ làm hỏng style của element kia.</p><p>Ngoài ra, khi bạn đọc trong ngữ cảnh HTML, bạn sẽ khó thấy được quan hệ ràng buộc giữa <code>input</code> và <code>.full</code> với block <code>.site-search</code>.</p><h3 id="“Toi-don-gian-la-khong-thich-ky-phap-nay”"><a href="#“Toi-don-gian-la-khong-thich-ky-phap-nay”" class="headerlink" title="“Tôi đơn giản là không thích ký pháp này”"></a>“Tôi đơn giản là không thích ký pháp này”</h3><p>Một số người khi nhìn thấy cách đặt tên BEM đã ngay lập tức bác bỏ nó. Họ không thích BEM, đó là quyền của họ, tuy nhiên sẽ là vô lý nếu phản bác việc cần có một số quy tắc đặt tên để dễ dàng nắm bắt và quản lý CSS trong dự án trung và lớn.</p><p>Hơn nữa, bạn hoàn toàn có thể nghĩ ra cho mình một cách đặt tên khác cho hợp sở thích, nhưng vẫn dựa trên nguyên tắc của BEM đã đề ra. Là kết quả đúc kết từ những kiến trúc CSS lớn và phức tạp trước đây, đề xuất của BEM không phải vô tình lại có một số điểm chung với các phương pháp quản lý CSS khác như SMACSS hay OOCSS. Lấy ví dụ khái niệm module của SMACSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ví dụ một module */</span></span><br><span class="line"><span class="selector-class">.btn</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modifier của một module */</span></span><br><span class="line"><span class="selector-class">.btn-primary</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Btn Module với State */</span></span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.is-collapsed</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>Trong các phương pháp quản lý CSS vừa kể trên thì chỉ có BEM là làm rõ được mối quan hệ với các thành phần con bên trong.</p><p>Tóm lại, mỗi phương pháp đều có ưu nhược điểm. Quan trọng là cả team phải có phương pháp tiếp cận khoa học và áp dụng triệt để thì kiến trúc CSS của cả dự án mới vững và dễ bảo trì.</p><h2 id="Cau-hoi-thuong-gap"><a href="#Cau-hoi-thuong-gap" class="headerlink" title="Câu hỏi thường gặp:"></a>Câu hỏi thường gặp:</h2><p>❓<strong>Hỏi:</strong> Element có modifier hay không?<br>💬️ <strong>Đáp:</strong> Có. Element có thể có modifier riêng của nó. Ví dụ:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.accordion__copy--open</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>❓<strong>Hỏi:</strong> Có cần phải đặt tên class cho tất cả element (thẻ HTML) trong block hay không?<br>💬️ <strong>Đáp:</strong> Không cần thiết, chỉ những element cần có style riêng được viết trong CSS. Tuy nhiên cũng không nên lạm dụng những thẻ wrapper (phổ biến nhất là DIV) một cách vô tội vạ và không có chức năng vai trò cụ thể nào. Như vậy việc đặt tên element con cũng khiến bạn phải suy nghĩ một tag nào đó có thật sự cần thiết thêm vào trong block hay không.</p><p>❓<strong>Hỏi:</strong> Bên trong element con <code>foo</code> có một tag đóng vai trò một element con <code>bar</code> khác của block, vậy việc đặt tên class cho element <code>bar</code> này như thế nào? Có nên đặt là <code>.block__foo__bar</code>?<br>💬️ <strong>Đáp:</strong> Vẫn đặt bằng tên block và hai gạch dưới rồi đến tên element <code>.block__bar</code>, không chen giữa bằng <code>foo__</code>. Nói tóm lại, tên của element chỉ cần thể hiện quan hệ phụ thuộc với block, không cần phải chỉ rõ sự lồng bên trong nhau của các element con. (Xem thêm ví dụ trong câu hỏi tiếp theo)</p><p>❓<strong>Hỏi:</strong> Một thẻ HTML có thể là element của 2 block khác nhau không?<br>💬️ <strong>Đáp:</strong> Hoàn toàn có thể. Hãy xem ví dụ sau:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn--big btn--orange"</span> <span class="attr">href</span>=<span class="string">"http://int3ractive.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__price"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon icon--dollar-sign btn__icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>9.99<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__text"</span>&gt;</span>Subscribe<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Button có biểu tượng dollar-sign là một block <code>.icon</code>. Có thể trong block <code>.btn</code>, biểu tượng dollar-sign cần được style riêng, nên cần có một cái tên xác định rõ vai trò và style cho element này là <code>.btn__icon</code>. Nếu block <code>.icon.icon--dollar-sign</code> được dùng ở một ngữ cảnh khác, thì rõ ràng nó không cần class <code>.btn__icon</code> nữa vì tên class đã chỉ rõ sự ràng buộc với block <code>.btn</code> và chỉ được thêm vào khi ở bên trong nó.</p><p>❓<strong>Hỏi:</strong> Một element con có thể đóng vai trò là block của riêng nó không? Có thể xây dựng chuỗi component phụ thuộc nhau như <code>.a__b__c</code> không?<br>💬️ <strong>Đáp:</strong> Câu hỏi này thật sự ngoài tầm hiểu biết và kinh nghiệm của tôi. Có thể có những hoàn cảnh đặt biệt như vậy. Tuy nhiên, theo tôi, nếu có cũng không nên quá 2 cấp, tức là element con chỉ đặt đến <code>.a__b__c</code> là tối đa. Điều này là để sự phụ thuộc không quá sâu, làm giảm khả năng dùng lại của block (portability) và sự linh hoạt của các đối tượng CSS theo tinh thần OOCSS. Xem ví dụ bên dưới.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* block list */</span></span><br><span class="line"><span class="selector-class">.list</span> &#123; &#125;</span><br><span class="line"><span class="comment">/* item là con của list */</span></span><br><span class="line"><span class="selector-class">.list__item</span> &#123; &#125;</span><br><span class="line"><span class="comment">/* link là con của block list__item, để phân biệt với list__link</span></span><br><span class="line"><span class="comment">hoặc chỉ rõ mối quan hệ phụ thuộc giữa item và link*/</span></span><br><span class="line"><span class="selector-class">.list__item__link</span> &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="Sai-lam-hay-mac-phai-khi-su-dung-BEM"><a href="#Sai-lam-hay-mac-phai-khi-su-dung-BEM" class="headerlink" title="Sai lầm hay mắc phải khi sử dụng BEM:"></a>Sai lầm hay mắc phải khi sử dụng BEM:</h2><p>Tôi xin hẹn lại về vấn đề này trong một bài viết khác, khi mà bản thân đã ứng dụng nhiều và quan sát được những ví dụ thực tiễn hơn để tổng hợp những sai lầm hay mắc phải do ảnh hưởng từ phương pháp cũ cũng như cách hiểu chưa đúng về phương pháp BEM này.</p><p>Xem thêm:</p><ul><li>Bài viết <a href="http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/" target="_blank" rel="noopener">giới thiệu BEM của CSSWizadry</a></li><li>Bài viết <a href="http://www.smashingmagazine.com/2012/04/a-new-front-end-methodology-bem/" target="_blank" rel="noopener">giới thiệu BEM của Smashing Magazine</a></li><li><a href="http://webuniverse.io/css-organization-naming-conventions-and-safe-extend-without-preprocessors/" target="_blank" rel="noopener">Sử dụng BEM và @extend của SASS</a></li><li>Bài viết <a href="https://medium.com/fed-or-dead/battling-bem-5-common-problems-and-how-to-avoid-them-5bbd23dee319" target="_blank" rel="noopener">5 sai lầm phổ biến với BEM</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Ky-phap-BEM-la-gi&quot;&gt;&lt;a href=&quot;#Ky-phap-BEM-la-gi&quot; class=&quot;headerlink&quot; title=&quot;Ký pháp BEM là gì&quot;&gt;&lt;/a&gt;Ký pháp BEM là gì&lt;/h2&gt;&lt;p&gt;BEM viết tắt của Blocks, Elements, Modifiers, là một phương pháp đặt tên class cho HTML và CSS. Được phát triển &lt;a href=&quot;https://en.bem.info&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tại Yandex&lt;/a&gt; giúp lập trình viên hiểu rõ hơn mối quan hệ giữa HTML và CSS trong dự án front end.&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://nthung2112.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Giới thiệu Progressive Web App</title>
    <link href="http://nthung2112.github.io/2018/05/Gioi-thieu-Progressive-Web-App.html"/>
    <id>http://nthung2112.github.io/2018/05/Gioi-thieu-Progressive-Web-App.html</id>
    <published>2018-05-18T00:30:00.000Z</published>
    <updated>2018-05-18T00:43:05.756Z</updated>
    
    <content type="html"><![CDATA[<p><strong>P</strong>rogressive Web App (PWA) là một dạng ứng dụng web (web app) mới đang thu hút rất nhiều sự quan tâm từ các nhà phát triển web khắp thế giới đặc biệt là các doanh nghiệp hoạt động trực tuyến, tuy nhiên nó vẫn còn khá mới mẻ tại Việt Nam.<br><a id="more"></a><br>Đã có nhiều bài viết liên quan đến PWA dành cho <a href="https://addyosmani.com/blog/getting-started-with-progressive-web-apps/" target="_blank" rel="noopener">lập</a> <a href="https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/" target="_blank" rel="noopener">trình</a> <a href="https://www.smashingmagazine.com/2016/08/a-beginners-guide-to-progressive-web-apps/" target="_blank" rel="noopener">viên</a>, cho nên trong bài viết này tôi sẽ cố gắng giải thích PWA để người dùng Web phổ thông vẫn có thể hiểu.</p><h2 id="Progressive-Web-App-la-gi"><a href="#Progressive-Web-App-la-gi" class="headerlink" title="Progressive Web App là gì?"></a>Progressive Web App là gì?</h2><p><strong>PWA là ứng dụng web được viết để tận dụng những tính năng mới nhất của trình duyệt Web trên máy tính để bàn (desktop) lẫn điện thoại thông minh, nhưng đồng thời vẫn chạy được trên những trình duyệt và thiết bị cũ hơn. PWA lấy phương pháp <a href="https://www.youtube.com/watch?v=5oUSzo1oRv0" target="_blank" rel="noopener">Cải Tiến Tăng Dần (Progressive Enhancement)</a> làm cốt lõi (nên mới có chữ Progressive).</strong></p><p>Đối với những trình duyệt và thiết bị cũ, PWA hoạt động như một mobile website thông thường. Nhưng với những trình duyệt trên thiết bị di động mới nhất, PWA hoạt động như một <em>mobile app</em>[^1] thực thụ.</p><p>Những tác giả của khái niệm PWA (đến từ nhóm phát triển trình duyệt Chrome) đã đưa ra những đặc tính cần có của một PWA như sau:</p><ul><li><strong>Progressive</strong> - Chạy được trên <em>mọi</em> (nên hiểu: tuyệt đại đa số) thiết bị, do được phát triển với phương pháp Cải Tiến Tăng Dần.</li><li><strong>Responsive</strong> - Có thiết kế <em>giao diện tùy ứng</em> (responsive design), hiển thị và sử dụng được trên mobile, tablet, laptop hay bất kỳ cỡ màn hình nào trong tương lai.</li><li><strong>Connectivity independent</strong> - PWA vẫn có thể hoạt động tốt với điều kiện kết nối mạng chập chờn hoặc mất hẳn (offline).</li><li><strong>App-like</strong> - Có giao diện và trải nghiệm như mobile app thực thụ.</li><li><strong>Fresh</strong> - Dù nó hoạt động như mobile app, nhưng tính năng và giao diện luôn được cập nhật tức thời nhờ nền tảng Web (không cần người dùng update từ Apple App Store hay Google Play - gọi chung là app store).</li><li><strong>Safe</strong> - PWA phải được tải thông qua giao thức TLS (hay nôm na là HTTPS), để đảm bảo việc trao đổi dữ liệu không bị bên thứ ba can thiệp.</li><li><strong>Discoverable</strong> - Thông qua file khai báo chuẩn (được thống nhất bởi tổ chức W3C), mà các PWA dễ dàng được các cỗ máy tìm kiếm đánh dấu và thông báo cho người dùng.</li><li><strong>Re-engageable</strong> - PWA cho phép việc tái tiếp cận người dùng dễ dàng hơn nhờ những tính năng đặc biệt như là push notification (thông báo chủ động).</li><li><strong>Installable</strong> - PWA cho phép người dùng dễ dàng lưu lại web app trên điện thoại (thường là trên màn hình home screen) mà không cần phải vào app store</li><li><strong>Linkable</strong> - Dễ dàng share app chỉ với đường link và không cần người nhận phải cài đặt phức tạp chỉ để xem được nội dung bạn muốn share.</li></ul><h2 id="Nhung-diem-khac-biet-cua-Progressive-Web-App"><a href="#Nhung-diem-khac-biet-cua-Progressive-Web-App" class="headerlink" title="Những điểm khác biệt của Progressive Web App?"></a>Những điểm khác biệt của Progressive Web App?</h2><p>Trước tiên cần hiểu rằng, sự tiến hóa của mobile web app cần sự hợp tác của rất nhiều bên liên quan trong đó có các nhà phát triển trình duyệt, hệ điều hành di động, và cả những chuyên gia về ngôn ngữ lập trình cho Web. Sự tiến hóa của mobile web thường đi cùng với sự phát triển và chuẩn hóa của nền tảng Web do tổ chức <strong>W3C</strong>[^2] chịu trách nhiệm.</p><p>Khi tôi tư vấn và phát triển app cho khách hàng, rất nhiều lần doanh nghiệp từ chối lựa chọn giải pháp web app hoặc hybrid app với lý do chính là <em>“HTML5 không nhanh bằng native”</em>. Tuy nhiên điều này không còn đúng tại thời điểm hiện tại.</p><p>Nhờ những cải tiến của phần cứng thiết bị, hệ điều hành di động, trình duyệt, và nhất là đặc tả Web trong vài năm gần đây mà web app đã thêm những khả năng không thua kém native app như:</p><ul><li>Giao diện tương tác mượt mà hơn, đặt biệt là hỗ trợ đồ họa 3D, animation từ phần cứng (hardware accelerated)</li><li>Khả năng chơi video, audio thông qua trình duyệt mobile đã hoàn thiện và định dạng gần như đã thống nhất.</li><li>Bàn phím ảo thích ứng với trường nhập web form khác nhau: email, URL, telephone…</li><li>Có khả năng truy xuất các sensor và bộ phận đa phương tiện của thiết bị: định vị GPS, con quay hồi chuyển, trạng thái pin, network, camera, microphone…</li><li>Cơ sở dữ liệu (CSDL) tại trình duyệt cho phép tìm kiếm và truy cập nhanh lượng dữ liệu lớn và cho phép người dùng trở lại trang web app nhanh hơn.</li><li>Đặc tả mới về CSS cho phép designer và front end developer tạo giao diện tùy ứng (responsive design) và giao diện giống app dễ dàng hơn.</li></ul><p>Dù vậy, web app vẫn còn một số hạn chế so với native app. Chúng ta hãy xem PWA đã được bổ sung những khả năng gì để có thể xóa dần khoảng cách giữa web và native:</p><h2 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h2><p>Được giới thiệu chính thức <a href="https://en.wikipedia.org/wiki/Progressive_Web_Apps" target="_blank" rel="noopener">từ 2015</a>, PWA đã trải qua thời gian thử nghiệm và trưởng thành đủ lâu để giờ đây chúng ta có thể khẳng định PWA chính là tương lai của Web và Web App.</p><p>PWA đóng góp thêm một giải pháp ứng dụng di động nhiều hứa hẹn, giải phóng doanh nghiệp khỏi sự lệ thuộc vào app store, những hạn chế của native app. Và nếu được thiết kế hợp lý, PWA sẽ là giải pháp hợp nhất cho “mọi nền tảng” từ desktop đến mobile.</p><hr><h4 id="Ghi-chu"><a href="#Ghi-chu" class="headerlink" title="Ghi chú:"></a>Ghi chú:</h4><p>[^1]: Xin tóm tắt lại một số thuật ngữ về <strong>“app”</strong> trên thiết bị di động:</p><ul><li>Mobile app hoặc native app: (ở Việt Nam thường gọi tắt là “app”) là ứng dụng được cài đặt từ app store, được viết bằng ngôn ngữ lập trình dành riêng cho từng hệ điều hành di động khác nhau.</li><li>(Mobile) web app: là website chạy trên trình duyệt của smart phone nhưng có trải nghiệm giống app và thường trao đổi nhiều dữ liệu giữa người dùng và website.</li><li>Hybrid app: là ứng dụng được cài đặt từ app store, tuy nhiên được viết bằng cùng ngôn ngữ lập trình với web app. Dù hybrid app có thể cài được trên nhiều HĐH khác nhau nhưng nó chỉ cần được viết cùng một bộ mã nguồn với một ít điều chỉnh riêng cho mỗi loại HĐH mà nó hỗ trợ.</li></ul><p>[^2]: Tổ chức World Wide Web Consortium có trách nhiệm chuẩn hóa các đặc tả về Web và khuyến khích các trình duyệt khác nhau phải tuân theo để các website hoạt động một cách đồng nhất bất kể trình duyệt dùng để hiển thị.</p><p>[^3]: URL là đường link đến một trang web bất kỳ</p><p>[^4]: Các trình duyệt phổ biến nhất bao gồm: Chrome, Firefox, Safari, MS Edge, Opera, Samsung Internet, UC Browser. Tại Việt Nam, trình duyệt phổ biến thứ 2 sau Chrome là CocCoc. Tuy nhiên CocCoc cũng là một trình duyệt biến thể từ mã nguồn mở của Chrome nên những tính năng của PWA cũng sẽ được hỗ trợ.</p><p>[^5]: Người dùng sẽ vẫn nhận được push notification cho dù họ không lưu app về home screen chỉ cần họ đã bấm đồng ý nhận push notification. Việc yêu cầu gửi push notification cần thận trọng và chỉ thực hiện khi người dùng đã thể hiện sự quan tâm đến dịch vụ của bạn. (Nếu không khả năng người dùng từ chối nhận push notification là rất cao)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;P&lt;/strong&gt;rogressive Web App (PWA) là một dạng ứng dụng web (web app) mới đang thu hút rất nhiều sự quan tâm từ các nhà phát triển web khắp thế giới đặc biệt là các doanh nghiệp hoạt động trực tuyến, tuy nhiên nó vẫn còn khá mới mẻ tại Việt Nam.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
      <category term="pwa" scheme="http://nthung2112.github.io/tags/pwa/"/>
    
  </entry>
  
  <entry>
    <title>Giới thiệu về redux saga</title>
    <link href="http://nthung2112.github.io/2018/04/Gioi-thieu-ve-redux-saga.html"/>
    <id>http://nthung2112.github.io/2018/04/Gioi-thieu-ve-redux-saga.html</id>
    <published>2018-04-30T11:37:00.000Z</published>
    <updated>2018-04-30T11:52:22.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redux-Saga-la-gi"><a href="#Redux-Saga-la-gi" class="headerlink" title="Redux-Saga là gì?"></a>Redux-Saga là gì?</h1><p>Redux-Saga là một thư viện redux middleware, giúp quản lý những side effect trong ứng dụng redux trở nên đơn giản hơn. Bằng việc sử dụng tối đa tính năng <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">Generators</a> <code>(function*)</code> của ES6, nó cho phép ta viết async code nhìn giống như là synchronos.</p><a id="more"></a><p>Saga không chỉ tồn tại trong thế giới javascript, nó còn được coi là 1 pattern. Bạn có thể xem qua về saga pattern bằng clip này: <a href="https://youtu.be/xDuwrtwYHu8" target="_blank" rel="noopener">https://youtu.be/xDuwrtwYHu8</a></p><p>Một cách nhìn nhanh chóng thì Saga pattern là cách để quản lý những long transaction với những side effect hoặc các nguy cơ tiềm ẩn. Với mỗi transaction thành công, chúng ta đều cần có counter-transaction để revert transaction đó về trạng thái ban đầu nếu gặp trục trặc. Tham khảo thêm về saga pattern với bài viết của Roman Liutikov : <a href="https://medium.com/@roman01la/confusion-about-saga-pattern-bbaac56e622" target="_blank" rel="noopener">Confusion about Saga pattern</a></p><h1 id="Side-effect-la-gi"><a href="#Side-effect-la-gi" class="headerlink" title="Side effect là gì??"></a>Side effect là gì??</h1><p>Ta đã biết tất cả những xử lý ở REDUCER đều phải là synchronous và pure tức chỉ là xử lý đồng bộ. Nhưng trong ứng dụng thực tế thì cần nhiều hơn vậy ví dụ như asynchronous (thực hiện một số việc như gọi một hàm AJAX để fetch dữ liệu về nhưng cần đợi kết quả chứ kết quả không trả về ngay được) hoặc là impure (thực hiện lưu, đọc dữ liệu ra bên ngoài như lưu dữ liệu ra ổ cứng hay đọc cookie từ trình duyệt… đều cần đợi kết quả). Những việc như thế trong lập trình hàm gọi nó là side effects.</p><h1 id="Generator-function-la-gi"><a href="#Generator-function-la-gi" class="headerlink" title="Generator function là gì??"></a>Generator function là gì??</h1><p>Khác với function bình thường là thực thi và trả về kết quả, thì Generator function có thể thực thi, tạm dừng trả về kết quả và thực thi bằng tiếp. Từ khóa để làm được việc đấy là “YIELD”. Generator được đưa ra cách đây mấy chục năm nhưng đến ES2015 mới được bổ sung, các ngôn ngữ khác đã được bổ sung tính năng này như C#, PHP, Ruby, C++, R…</p><h1 id="Redux-Saga-hoat-dong-nhu-the-nao"><a href="#Redux-Saga-hoat-dong-nhu-the-nao" class="headerlink" title="Redux-Saga hoạt động như thế nào??"></a>Redux-Saga hoạt động như thế nào??</h1><p>Đối với logic của saga, ta cung cấp một hàm cho saga, chính hàm này là hàm đứng ra xem xét các action trước khi vào store, nếu là action quan tâm thì nó sẽ thực thi hàm sẽ được thực thi, nếu bạn biết khái niệm hook thì hàm cung cấp cho saga chính là hàm hook. Điều đặc biệt của hàm hook này nó là một generator function, trong generator function này có yield và mỗi khi yield ta sẽ trả về một plain object. Object trả về đó được gọi Effect object. effect object này đơn giản chỉ là một object bình thường nhưng chứa thông tin đặc biệt dùng để chỉ dẫn middleware của Redux thực thi các hoạt động khác ví dụ như gọi một hàm async khác hay put một action tới store. Để tạo ra effect object đề cập ở trên thì ta gọi hàm từ thư viện của saga là redux-saga/effects.</p><p><img src="https://i.stack.imgur.com/iCi6Y.png" alt=""></p><h1 id="Tai-sao-toi-phai-su-dung-Saga"><a href="#Tai-sao-toi-phai-su-dung-Saga" class="headerlink" title="Tại sao tôi phải sử dụng Saga??"></a>Tại sao tôi phải sử dụng Saga??</h1><p>Khi bắt đầu tìm tòi về redux, bạn hay tìm thấy các bài hướng dẫn sử dụng <a href="https://github.com/gaearon/redux-thunk" target="_blank" rel="noopener">redux-thunk</a> hoặc <a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener">redux-saga</a> để quản lý các async action. Vậy tại sao bạn lại được khuyên sử dụng redux-saga ?</p><p>Trích dẫn trong document của redux-saga:</p><blockquote><p>Contrary to redux thunk, you don’t end up in callback hell, you can test your asynchronous flows easily and your actions stay pure. _Tạm dịch: trái với redux thunk, bạn không cần phải phát dồ lên với các callback trong mỗi action, đến với saga đi, bạn có thể test các async action với một quy trình dễ dàng mà không làm hư các action đó !</p></blockquote><h4 id="So-sanh-saga-va-thunk"><a href="#So-sanh-saga-va-thunk" class="headerlink" title="So sánh saga và thunk:"></a>So sánh saga và thunk:</h4><ol><li><p>redux-thunk</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  API_BUTTON_CLICK,</span><br><span class="line">  API_BUTTON_CLICK_SUCCESS,</span><br><span class="line">  API_BUTTON_CLICK_ERROR,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./actions/consts'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getDataFromAPI &#125; <span class="keyword">from</span> <span class="string">'./api'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getDataStarted = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: API_BUTTON_CLICK &#125;);</span><br><span class="line"><span class="keyword">const</span> getDataSuccess = <span class="function"><span class="params">data</span> =&gt;</span> (&#123; <span class="attr">type</span>: API_BUTTON_CLICK_SUCCESS, <span class="attr">payload</span>: data &#125;)</span><br><span class="line"><span class="keyword">const</span> getDataError = <span class="function"><span class="params">message</span> =&gt;</span> (&#123; <span class="attr">type</span>: API_BUTTON_CLICK_ERROR. payload: message &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getDataFromAPI = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(getDataStarted());</span><br><span class="line"></span><br><span class="line">    getDataFromAPI()</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        dispatch(getUserSuccess(data));</span><br><span class="line">      &#125;).fail(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        dispatch(getDataError(err.message));</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Ở đây ta có một action creator getDataFromAPI() bắt đầu async progress như sau:</p><ul><li>Đầu tiên bắn ra action cho phép store biết rằng chuẩn bị 1 API request ( dispatch(getDataStarted())</li><li>Tiếp theo thực hiện API request trả về một Promise</li><li>Cuối cùng bắn ra success action nếu request thành công hoặc error action nếu có lỗi</li></ul></li><li><p>redux-saga</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; call, put, takeEvery &#125; <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  API_BUTTON_CLICK,</span><br><span class="line">  API_BUTTON_CLICK_SUCCESS,</span><br><span class="line">  API_BUTTON_CLICK_ERROR,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./actions/consts'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getDataFromAPI &#125; <span class="keyword">from</span> <span class="string">'./api'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">apiSideEffect</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">yield</span> call(getDataFromAPI);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: API_BUTTON_CLICK_SUCCESS, <span class="attr">payload</span>: data &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: API_BUTTON_CLICK_ERROR, <span class="attr">payload</span>: e.message &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the 'watcher' - on every 'API_BUTTON_CLICK' action, run our side effect</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">apiSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(API_BUTTON_CLICK, apiSideEffect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cùng một process, nhưng cách implement khác nhau hoàn toàn.</p><ul><li>put thay cho dispatch</li><li>function cuối (apiSaga()) giúp theo dõi tổng thể toàn bộ các action (ở đây có API_BUTTON_CLICK)</li><li>Với cách gọi của redux-saga, chúng ta có thể get data từ bất kì async function nào (promise, …)</li></ul></li><li><h6 id="Nhan-xet"><a href="#Nhan-xet" class="headerlink" title="Nhận xét"></a>Nhận xét</h6><p>Cả 2 cách implement đều dễ đọc, tuy nhiên đối với redux-thunk , bạn phải đối đầu với một tá các promise, các callback nếu có, rất mất thời gian cho người maintain đọc và tìm code. Với redux-saga , đơn giản bạn chỉ cần track theo try/catch block để theo dõi dòng code, bên cạnh đó còn có hàm giúp bạn track các action một cách dễ dàng.</p></li></ol><h1 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h1><p>Ở bài viết này mình đề cập đến 2 điểm nhấn chính của redux-saga là giữ cho action pure synchronos theo chuẩn redux và loại bỏ hoàn toàn callback theo javascript truyền thống. Bài viết tiếp theo mình sẽ đề cập nốt key point cuối cùng của saga là <strong>easy to test</strong>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redux-Saga-la-gi&quot;&gt;&lt;a href=&quot;#Redux-Saga-la-gi&quot; class=&quot;headerlink&quot; title=&quot;Redux-Saga là gì?&quot;&gt;&lt;/a&gt;Redux-Saga là gì?&lt;/h1&gt;&lt;p&gt;Redux-Saga là một thư viện redux middleware, giúp quản lý những side effect trong ứng dụng redux trở nên đơn giản hơn. Bằng việc sử dụng tối đa tính năng &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Generators&lt;/a&gt; &lt;code&gt;(function*)&lt;/code&gt; của ES6, nó cho phép ta viết async code nhìn giống như là synchronos.&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://nthung2112.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://nthung2112.github.io/tags/redux/"/>
    
      <category term="saga" scheme="http://nthung2112.github.io/tags/saga/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in React</title>
    <link href="http://nthung2112.github.io/2018/04/Thinking-in-React.html"/>
    <id>http://nthung2112.github.io/2018/04/Thinking-in-React.html</id>
    <published>2018-04-30T09:47:00.000Z</published>
    <updated>2018-04-30T10:03:55.328Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram.</p></blockquote><p>Một trong những phần quan trọng nhất của React là cách nó tạo ra cách nghĩ của bạn về các ứng dụng mà bạn xây dựng. Trong tài liệu này, chúng tôi sẽ hướng dẫn bạn cách để xây dựng một ứng dụng tìm kiếm sản phẩm trong table với React.</p><a id="more"></a><h1 id="Bat-dau"><a href="#Bat-dau" class="headerlink" title="Bắt đầu"></a>Bắt đầu</h1><p>Giả dụ bạn đã có sẵn một JSON API và giao diện đã sẵn sàng gọi đến nó. Cụ thể như ảnh sau: </p><p><img src="https://reactjs.org/static/thinking-in-react-mock-1071fbcc9eed01fddc115b41e193ec11-4dd91.png" alt=""></p><p>Dữ liệu trả về có dạng như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;<span class="attr">category</span>: <span class="string">"Sporting Goods"</span>, <span class="attr">price</span>: <span class="string">"$49.99"</span>, <span class="attr">stocked</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">"Football"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">category</span>: <span class="string">"Sporting Goods"</span>, <span class="attr">price</span>: <span class="string">"$9.99"</span>, <span class="attr">stocked</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">"Baseball"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">category</span>: <span class="string">"Sporting Goods"</span>, <span class="attr">price</span>: <span class="string">"$29.99"</span>, <span class="attr">stocked</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"Basketball"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">category</span>: <span class="string">"Electronics"</span>, <span class="attr">price</span>: <span class="string">"$99.99"</span>, <span class="attr">stocked</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">"iPod Touch"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">category</span>: <span class="string">"Electronics"</span>, <span class="attr">price</span>: <span class="string">"$399.99"</span>, <span class="attr">stocked</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">"iPhone 5"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">category</span>: <span class="string">"Electronics"</span>, <span class="attr">price</span>: <span class="string">"$199.99"</span>, <span class="attr">stocked</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">"Nexus 7"</span>&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="Buoc-1-Chia-UI-thanh-component-theo-bac"><a href="#Buoc-1-Chia-UI-thanh-component-theo-bac" class="headerlink" title="Bước 1: Chia UI thành component theo bậc"></a>Bước 1: Chia UI thành component theo bậc</h2><p>Việc đầu tiên bạn sẽ phải vẽ các hộp xung quanh mỗi component ( và subcomponent ) và đặt tên cho chúng. Nhưng bạn phân vân không biết khi nào nên tạo ra component? Đối với component, một kĩ thuật được sử dụng rộng rãi để design component là sử dụng <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="noopener">nguyên tắc đơn nhiệm</a>. Khi các component được sinh ra quá nhiều, bạn hãy tách chúng ra thành nhiều subcomponent. Đối với việc thuường xuyên hiển thị dữ liệu JSON, bạn nên đảm bảo về tính đúng đắn của model, liệu rằng nó sẽ được map chính xác với UI ( các component ) của bạn? Bởi vì UI và các model luôn phải dính liền với cấu trúc của thông tin, có nghĩa là công việc phân chia UI sang component là không đáng kể. Cứ chia ra thành các component và hiển thị chính xác từng mẩu dữ liệu của bạn là ổn.</p><p><img src="https://reactjs.org/static/thinking-in-react-components-eb8bda25806a89ebdc838813bdfa3601-82965.png" alt=""></p><p>Đối với dữ liệu trong ảnh, bạn sẽ nghĩ đến 5 component tương ứng với mỗi màu phải không? Sau đây là chi tiết cho từng component đó:</p><ol><li><strong>FilterableProductTable (cam)</strong>: chứa toàn bộ ví dụ</li><li><strong>SearchBar (xanh)</strong>: nhận dữ liệu từ người dùng</li><li><strong>ProductTable (xanh lá cây)</strong>: hiển thị và lọc dữ liệu dựa trên user input</li><li><strong>ProductCategoryRow (lam)</strong>: hiển thị tiêu đề cho mỗi category</li><li><strong>ProductRow (đỏ)</strong>: mỗi hàng là 1 sản phẩm</li></ol><p>Nếu bạn nhìn vào ProductTable , bạn sẽ thấy có header (bao gồm nhãn “Name” và “Price”) không phải là chính component của nó. Đây là vấn đề của việc tinh chỉnh. Ví dụ, chúng ta để phần header thuộc component ProductTable vì nó là một phần của việc render ra dữ liệu, đó là trách nhiệm của ProductTable. Tuy nhiên, nếu header này khi được sử dụng một cách phức tạp (như là tương tác với sắp xếp), nó sẽ phải tạo thêm một component riêng cho header gọi là ProductTableHeader chẳng hạn. Tóm lại, bạn nên phân chia cấu trúc của component và các subcomponent như sau:</p><ul><li>FilterableProductTable<ul><li>SearchBar</li><li>ProductTable<ul><li>ProductCategoryRow</li><li>ProductRow</li></ul></li></ul></li></ul><h2 id="Buoc-2-Xac-dinh-muc-toi-thieu-nhung-hoan-chinh"><a href="#Buoc-2-Xac-dinh-muc-toi-thieu-nhung-hoan-chinh" class="headerlink" title="Bước 2: Xác định mức tối thiểu (nhưng hoàn chỉnh)"></a>Bước 2: Xác định mức tối thiểu (nhưng hoàn chỉnh)</h2><p>Để UI của bạn tương tác tốt, bạn cần xác định các thay đổi đến dữ liệu thuộc tầng dưới (underlying data model) . Hãy sử dụng <strong>state</strong> của React.</p><p>Đầu tiên bạn nên nghĩ đến việc tối giản các mutable state. Chìa khóa thành công ở đây là <strong>DRY:</strong> <em><strong>Don’t Repeat Yourself</strong></em> . Ví dụ với ứng dụng TODO, bạn chỉ cần giữ mảng các TODO item, không cần đến các state khác như để đếm số lượng. Thay vào đó, khi bạn muốn đếm số lượng của TODO item, đơn giản là lấy ra length của TODO item array.</p><p>Cụ thể với dữ liệu mẫu trong bài viết này, chúng ta có:</p><ul><li>Nguyên mẫu danh sách sản phẩm</li><li>Text tìm kiếm mà user nhập vào</li><li>Value của checkbox</li><li>Danh sách đã lọc sản phẩm</li></ul><p>Hãy suy nghĩ về việc bạn nên để cái nào là state, trong thời gian suy nghĩ, hãy đọc các câu hỏi dưới về luồng data:</p><ol><li>Có thể pass từ parent component thông qua props không? Nếu có, state là không cần thiết.</li><li>Nó có giữ nguyên trạng thái dữ liệu suốt không? Nếu có, state không thể sử dụng được.</li><li>Bạn có đoán được data dựa vào bất kì state hay props nào trong component không? Nếu có, chỗ này càng không phải chỗ cho state.</li></ol><p>Danh sách sản phẩm nguyên bản được pass thông qua props. Text tìm kiếm và checkbox dường như sẽ thích hợp với state vì nó có thể được thay đổi bất kì lúc nào bởi người dùng. Vậy cuối cùng, danh sách lọc sản phẩm cũng không thể nào là state bởi vì chúng có thể được tính toán thông qua list sản phẩm ban đầu dựa vào search text và checkbox.</p><p>Tóm lại, bạn nên sử dụng state cho:</p><ul><li>Search text mà user nhập vào</li><li>Giá trị của checkbox khi user sử dụng</li></ul><h2 id="Buoc-4-Xac-dinh-noi-sinh-song-cua-state"><a href="#Buoc-4-Xac-dinh-noi-sinh-song-cua-state" class="headerlink" title="Bước 4: Xác định nơi sinh sống của state"></a>Bước 4: Xác định nơi sinh sống của state</h2><p>Hãy nhớ rằng, React là luồng dữ liệu một chiều, phụ thuộc theo luồng của các cấp component. Bạn không thể đoán ngay được component này sẽ có những state gì. <strong>Đây là việc chiếm nhiều thời gian và công sức nhất dành cho người mới tìm hiểu về react</strong>, hãy nhớ: đừng vội khẳng định state A thuộc component A. Để hình dung ra một cách rõ ràng, hãy theo các bước sau:</p><ul><li>Phân loại mỗi component sẽ render ra những gì dựa vào state đó.</li><li>Tìm thử trong component cha</li><li>Nếu component cha không có, tìm tiếp ở component cao hơn component cha đó</li><li>Nếu bạn không tìm ra được component đang giữ state, thử tạo một conponent mới để giữ state đó và thêm nó ở đâu đó trong cấp thư mục cao hơn thư mục chứa component cha.</li></ul><p>Ví dụ cụ thể:</p><ul><li>ProductTable cần filter sản phẩm dựa vào state và SearchBar cần phải hiển thị text được nhập và state của checkbox.</li><li>Component cha sẽ là FilterableProductTable</li><li>Tất nhiên theo lẽ tự nhiên, search text và giá trị của checkbox sẽ được lưu ở trong FilterableProductTable.</li></ul><h2 id="Buoc-5-Them-luong-du-lieu"><a href="#Buoc-5-Them-luong-du-lieu" class="headerlink" title="Bước 5: Thêm luồng dữ liệu"></a>Bước 5: Thêm luồng dữ liệu</h2><p>…</p><p>Và đây là kết quả </p><iframe src="//codepen.io/gaearon/embed/LzWZvb/?height=600" width="100%" height="600" frameborder="0" allowfullscreen></iframe><h2 id="Ket"><a href="#Ket" class="headerlink" title="Kết"></a>Kết</h2><p>Hy vọng rằng, bài viết này cho bạn ý tưởng làm thế nào để suy nghĩ về việc xây dựng các component với React. Mặc dù có thể khiến bạn gõ nhiều code hơn, hãy nhớ rằng code được đọc nhiều hơn nó được viết. Khi bạn bắt đầu xây dựng các thư viện component lớn, bạn sẽ đánh giá cao sự rõ ràng và tính mô đun, và với việc tái sử dụng code, các dòng code của bạn sẽ bắt đầu co lại.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Một trong những phần quan trọng nhất của React là cách nó tạo ra cách nghĩ của bạn về các ứng dụng mà bạn xây dựng. Trong tài liệu này, chúng tôi sẽ hướng dẫn bạn cách để xây dựng một ứng dụng tìm kiếm sản phẩm trong table với React.&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://nthung2112.github.io/tags/react/"/>
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Tổng hợp các cheat sheets tốt nhất của front-end</title>
    <link href="http://nthung2112.github.io/2018/04/Tong-hop-cac-cheat-sheets-tot-nhat-cua-front-end.html"/>
    <id>http://nthung2112.github.io/2018/04/Tong-hop-cac-cheat-sheets-tot-nhat-cua-front-end.html</id>
    <published>2018-04-30T08:36:00.000Z</published>
    <updated>2018-04-30T11:52:12.794Z</updated>
    
    <content type="html"><![CDATA[<p>Chúng ta không thể nhớ thuộc lòng tất cả các API. Đây là lúc chúng ta cần các trang cheat sheets này! Dưới đây là các bản cheat sheets tốt nhất mà tôi đã thu thập được.</p><a id="more"></a><h3 id="Javascript-ES2015-features"><a href="#Javascript-ES2015-features" class="headerlink" title="Javascript ES2015 features"></a><a href="https://devhints.io/es6" target="_blank" rel="noopener">Javascript ES2015 features</a></h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*l90SMm_aR9UD8m9QDu3kKA.png" alt="https://devhints.io/es6"></p><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a><a href="http://overapi.com/javascript" target="_blank" rel="noopener">Javascript</a></h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*sqkshvsmr7hN4Ab2A7GJzg.png" alt="http://overapi.com/javascript"></p><h3 id="Javascript-Regular-expression"><a href="#Javascript-Regular-expression" class="headerlink" title="Javascript Regular expression"></a><a href="https://www.debuggex.com/cheatsheet/regex/javascript" target="_blank" rel="noopener">Javascript Regular expression</a></h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*jHRyyzwj9z11ouDkY9dK9Q.png" alt="https://www.debuggex.com/cheatsheet/regex/javascript"></p><h3 id="React"><a href="#React" class="headerlink" title="React"></a><a href="https://devhints.io/react" target="_blank" rel="noopener">React</a></h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*VhtpckI6V0tckQa3uM9MbA.png" alt="https://devhints.io/react"></p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a><a href="https://github.com/linkmesrl/react-journey-2016/blob/master/resources/egghead-redux-cheat-sheet-3-2-1.pdf" target="_blank" rel="noopener">Redux</a></h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*KJQ-XK2yK-903OXHCRQpLw.png" alt="https://github.com/linkmesrl/react-journey-2016/blob/master/resources/egghead-redux-cheat-sheet-3-2-1.pdf"></p><h3 id="Vuejs"><a href="#Vuejs" class="headerlink" title="Vuejs"></a><a href="https://vuejs-tips.github.io/cheatsheet/" target="_blank" rel="noopener">Vuejs</a></h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*xKmyDitGEXGg1J9FBpbqHw.png" alt="https://vuejs-tips.github.io/cheatsheet/"></p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a><a href="https://vuejs-tips.github.io/vuex-cheatsheet/" target="_blank" rel="noopener">Vuex</a></h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*M-UIS7PPmvh_HuZVTqarzA.png" alt="https://vuejs-tips.github.io/vuex-cheatsheet/"></p><h3 id="Angular-4"><a href="#Angular-4" class="headerlink" title="Angular 4"></a><a href="https://angular.io/guide/cheatsheet" target="_blank" rel="noopener">Angular 4</a></h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*tx7-kHpoRsiEyp9ch3yMhw.png" alt="https://angular.io/guide/cheatsheet"></p><h3 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a><a href="https://yoksel.github.io/flex-cheatsheet/" target="_blank" rel="noopener">Flexbox</a></h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*q8xJa81twW6J-U_URHOJvQ.png" alt="https://yoksel.github.io/flex-cheatsheet/"></p><h3 id="SCSS"><a href="#SCSS" class="headerlink" title="SCSS"></a><a href="https://devhints.io/sass" target="_blank" rel="noopener">SCSS</a></h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*OlBKGGkX-lYD4Hv_3jzq0A.png" alt="https://devhints.io/sass"></p><h3 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a><a href="https://devhints.io/stylus" target="_blank" rel="noopener">Stylus</a></h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*KzGNbC0CdMdUQjF_8LWy6g.png" alt="https://devhints.io/stylus"></p><h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a><a href="https://raw.githubusercontent.com/sogko/graphql-shorthand-notation-cheat-sheet/master/graphql-shorthand-notation-cheat-sheet.png" target="_blank" rel="noopener">GraphQL</a></h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*PBnThNh1zzpCJq_70ExyRA.png" alt="https://raw.githubusercontent.com/sogko/graphql-shorthand-notation-cheat-sheet/master/graphql-shorthand-notation-cheat-sheet.png"></p><p>Missing your favorite cheatsheet? Please let me know in the comments!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chúng ta không thể nhớ thuộc lòng tất cả các API. Đây là lúc chúng ta cần các trang cheat sheets này! Dưới đây là các bản cheat sheets tốt nhất mà tôi đã thu thập được.&lt;/p&gt;
    
    </summary>
    
    
      <category term="cheat sheets" scheme="http://nthung2112.github.io/tags/cheat-sheets/"/>
    
  </entry>
  
  <entry>
    <title>Tất cả những gì bạn cần biết về CSS-in-JS</title>
    <link href="http://nthung2112.github.io/2018/04/Tat-ca-nhung-gi-ban-can-biet-ve-CSS-in-JS.html"/>
    <id>http://nthung2112.github.io/2018/04/Tat-ca-nhung-gi-ban-can-biet-ve-CSS-in-JS.html</id>
    <published>2018-04-30T08:19:00.000Z</published>
    <updated>2018-04-30T08:31:39.212Z</updated>
    
    <content type="html"><![CDATA[<p>TL;DR:<strong>Thinking in components — </strong>No longer do you have to maintain bunch of style-sheets. CSS-in-JS abstracts the CSS model to the component level, rather than the document level (modularity).</p><a id="more"></a><h4 id="Styled-React-Component-Example"><a href="#Styled-React-Component-Example" class="headerlink" title="Styled React Component Example"></a>Styled React Component Example</h4><p><img src="https://cdn-images-1.medium.com/max/1600/1*DFwkvCRyz9K0Mbl59r2hMg.png" alt=""></p><hr><p>You probably heard terms like <a href="http://cssinjs.org/?v=v9.1.0" target="_blank" rel="noopener"><strong>CSS-in-JS</strong></a>, <a href="https://www.styled-components.com" target="_blank" rel="noopener"><strong>Styled Components</strong></a>, <a href="https://github.com/FormidableLabs/radium" target="_blank" rel="noopener"><strong><em>Radium</em></strong></a>, <a href="https://github.com/Khan/aphrodite" target="_blank" rel="noopener"><strong>Aphrodite</strong></a> and you’re left there hanging <strong>“why is this a thing? — </strong>I’m perfectly happy with <strong>CSS-in-CSS</strong> (<strong><em>CSS</em> in <em>.css</em></strong>).<strong>”</strong></p><p>I’m here to shine some light on why this is a thing and hopefully we will least understand the concept and understand why it’s a thing. With that said — please feel free to use CSS-in-CSS — on no terms are you obligated to use CSS-in-JS. <strong>Whatever works best for you and makes you happy is hands down the best solution, always-always!</strong></p><p>CSS-in-JS is a delicate and controversial topic — I’m advocating having an open mind and weighing if this makes sense to you — ask yourself <strong>“will it improve my workflow?” —**</strong>in the end — that’s the only thing that matters — use tools that make you happier and more productive!**</p><p>I’ve always felt awkward having to maintain a huge folder of stylesheets. I would like to try different approaches. I’ve seen many people asking if there are new styling ideas. CSS-in-JS is so far the best concept.</p><p>Let’s give CSS-in-JS a shot.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*bsbmmLcGl2kSJSuKW-JFqw.png" alt="Small-To-Medium size project CSS"></p><hr><h3 id="What-is-CSS-in-JS"><a href="#What-is-CSS-in-JS" class="headerlink" title="What is CSS-in-JS?"></a>What is CSS-in-JS?</h3><blockquote><p><a href="https://medium.com/@oleg008/jss-is-css-d7d41400b635" target="_blank" rel="noopener">JSS is a more powerful abstraction</a> over CSS. It uses JavaScript as a language to describe styles in a declarative and maintainable way. It is a <a href="http://cssinjs.org/performance" target="_blank" rel="noopener">high performance</a> JS to CSS compiler which works at runtime and server-side. This core library is low level and framework agnostic. It is about 6KB (minified and gzipped) and is extensible via <a href="http://cssinjs.org/plugins" target="_blank" rel="noopener">plugins</a> API. —<a href="http://cssinjs.org/" target="_blank" rel="noopener"> source</a></p></blockquote><p>Keep in mind <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style" target="_blank" rel="noopener"><strong>Inline styles</strong></a> <strong>and CSS-in-JS are not the same!</strong> They’re different — Quick demonstration time!</p><h3 id="How-Inline-Styles-Works"><a href="#How-Inline-Styles-Works" class="headerlink" title="How Inline Styles Works"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style" target="_blank" rel="noopener">How Inline Styles Works</a></h3><script src="//gist.github.com/5812bd9006c91b9eb0fe08e3678d88c8.js"></script><p>In the browser this will get attached to the DOM node like so:</p><script src="//gist.github.com/02b07c1daa4816eb2a51eb8d1b494f3e.js"></script><h3 id="How-CSS-in-JS-works"><a href="#How-CSS-in-JS-works" class="headerlink" title="How CSS-in-JS works"></a>How CSS-in-JS works</h3><script src="//gist.github.com/769908d4e065b363258d9ae733febac2.js"></script><p>In the browser this will gets attached to the DOM like so:</p><script src="//gist.github.com/e76c2883a81a11ee16f4b12906572e2a.js"></script><h3 id="Difference"><a href="#Difference" class="headerlink" title="Difference"></a>Difference</h3><p>See the slight difference? CSS-in-JS attached a <code>&lt;style&gt;</code> tag on top of the DOM while inline styles just attached the properties to the DOM node.</p><p><strong><em>Why does this matter?</em></strong></p><p><strong>Not all CSS features can be aliased with JavaScript event handlers </strong>, many pseudo selectors (like :disabled, :before, :nth-child) aren’t possible, styling the html and body tags isn’t supported etc.</p><p><strong>With CSS-in-JS</strong>, you have all the power of CSS at your fingertips. Since actual CSS is generated, you can use every media query and pseudo selector you can think of. Some libraries (like jss, styled-components) even add support for neat, non-CSS-native features like nesting!</p><p><a href="https://mxstbr.blog/2016/11/inline-styles-vs-css-in-js/" target="_blank" rel="noopener"><strong>Brilliant article going in depth on how they’re different.</strong></a></p><p>“Just write the darn CSS in CSS and be done with it.”</p><p>Yes — while that’s the case for how it’s been done for a long-long time — <strong>the challenge is modern web is written in components not pages.</strong></p><p><strong>CSS was never actually made for component based approaches</strong>. CSS-in-JS solves exactly this problem. Shout-out to <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a> for solving this problem beautifully even tho Vues styles have no access to components state.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*jk3SeXoIgOfymKO-8JO23A.gif" alt="Here’s Bob Ross painting rocks to cool down the tension 😄"></p><h3 id="What-are-the-benefits-of-using-CSS-in-JS"><a href="#What-are-the-benefits-of-using-CSS-in-JS" class="headerlink" title="What are the benefits of using CSS-in-JS?"></a>What are the benefits of using CSS-in-JS?</h3><ul><li><strong>Thinking in components — </strong>No longer do you have to maintain bunch of style-sheets. CSS-in-JS abstracts the CSS model to the component level, rather than the document level (modularity).</li><li>CSS-in-JS <strong>leverages the full power of the JavaScript ecosystem</strong> to <em>enhance</em> CSS.</li><li>“<strong>True rules isolation</strong>” — Scoped selectors are not enough. CSS has properties which are inherited automatically from the parent element, if not explicitly defined. Thanks to <a href="http://cssinjs.org/jss-isolate" target="_blank" rel="noopener">jss-isolate</a> plugin, JSS rules will not inherit properties.</li><li><strong>Scoped selectors </strong>— CSS has just one global namespace. It is impossible to avoid selector collisions in non-trivial applications. Naming conventions like BEM might help within one project, but will not when integrating third-party code. JSS generates unique class names by default when it compiles JSON representation to CSS.</li><li><strong>Vendor Prefixing</strong> —The CSS rules are automatically vendor prefixed, so you don’t have to think about it.</li><li><strong>Code sharing </strong>— Easily share constants and functions between JS and CSS.</li><li><strong>Only the styles which are currently</strong> in use on your screen are also in the DOM (<a href="https://github.com/cssinjs/react-jss" target="_blank" rel="noopener">react-jss</a>).</li><li><a href="https://en.wikipedia.org/wiki/Dead_code_elimination" target="_blank" rel="noopener"><strong>Dead code elimination</strong></a></li><li><strong>Unit tests</strong> for CSS!</li></ul><h3 id="What-are-the-drawbacks-of-using-CSS-in-JS"><a href="#What-are-the-drawbacks-of-using-CSS-in-JS" class="headerlink" title="What are the drawbacks of using CSS-in-JS?"></a>What are the drawbacks of using CSS-in-JS?</h3><ul><li><strong>Learning curve</strong>.</li><li><strong>New dependencies.</strong></li><li><strong>Harder for newer teammates to adapt to the code-base</strong>. People who are new to front-end have to learn “more” things.</li><li><strong>Challenging</strong> the status quo. (not necessarily a con)</li></ul><p>The pros out-weight the cons heavily — let’s give CSS-in-JS a shot! <strong>Nothing to lose!</strong></p><hr><h3 id="Most-popular-CSS-in-JS-libaries"><a href="#Most-popular-CSS-in-JS-libaries" class="headerlink" title="Most popular CSS-in-JS libaries"></a>Most popular CSS-in-JS libaries</h3><p><em>Will provide a quick hello world example for all the popular CSS-in-JS libraries— help yourself to choose which one you like the most based on the syntax.</em></p><p><img src="https://cdn-images-1.medium.com/max/2000/1*xXIXJeI3l6_k-rXg6cqNjw.png" alt="NPM trends"></p><h4 id="Styled-Components"><a href="#Styled-Components" class="headerlink" title="Styled Components"></a><a href="https://www.styled-components.com/" target="_blank" rel="noopener">Styled Components</a></h4><p><img src="https://cdn-images-1.medium.com/max/1600/1*QvSrt0RgwuOKYlLHLjkDQw.png" alt=""></p><script src="//gist.github.com/5888c4756651dfef1e1015b822d09b27.js"></script><h3 id="JSS-React"><a href="#JSS-React" class="headerlink" title="JSS-React"></a><a href="https://github.com/cssinjs/react-jss" target="_blank" rel="noopener">JSS-React</a></h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*z7kPKLW6meQuC5sznIYnkQ.png" alt=""></p><script src="//gist.github.com/c90a6455e9dd7dce7b579b06d2e61413.js"></script><h3 id="glamorous"><a href="#glamorous" class="headerlink" title="glamorous"></a><a href="https://glamorous.rocks/" target="_blank" rel="noopener">glamorous</a></h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*tWuxJKAhaod4WNsm3MkMgQ.png" alt=""></p><script src="//gist.github.com/47c1dc52980ed0197db2ceb5ebbb9ac0.js"></script><h4 id="Radium-caveat-uses-inline-styles"><a href="#Radium-caveat-uses-inline-styles" class="headerlink" title="Radium (caveat: uses inline styles)"></a><a href="http://formidable.com/open-source/radium/" target="_blank" rel="noopener">Radium</a> (caveat: uses inline styles)</h4><p><img src="https://cdn-images-1.medium.com/max/1600/1*UsS6OxCfH6r7JLWx-wNeIQ.png" alt=""></p><script src="//gist.github.com/14b38638841f6c0539127ad52358d099.js"></script><p>Note: Radium uses <a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841" target="_blank" rel="noopener">decorators</a>!</p><h4 id="Aphrodite"><a href="#Aphrodite" class="headerlink" title="Aphrodite"></a><a href="https://github.com/Khan/aphrodite" target="_blank" rel="noopener">Aphrodite</a></h4><script src="//gist.github.com/f7d862549b680f766e68751e0f3f77d1.js"></script><h4 id="Stylotron"><a href="#Stylotron" class="headerlink" title="Stylotron"></a><a href="https://github.com/rtsao/styletron" target="_blank" rel="noopener">Stylotron</a></h4><p><img src="https://cdn-images-1.medium.com/max/1600/1*a0c0iulx7pZFScn0fsAn0w.png" alt=""></p><script src="//gist.github.com/9919c99b28ca4a063a3245efc1e4dddd.js"></script><p>These are really simple examples which demonstrate the core functionality. All of the libraries have much more functionality included — for example, <strong>theming</strong>, <strong>dynamic props</strong>, <strong>server side rendering</strong> and much more!</p><p><a href="https://medium.com/object-partners/css-in-js-benefits-drawback-and-tooling-80286b03f9aa" target="_blank" rel="noopener">Excellent post</a> going in depth about all of the features CSS-in-JS enables.</p><p><a href="https://github.com/tuchk4/awesome-css-in-js" target="_blank" rel="noopener"><strong>Here’s the full list — go and give all the libraries a quick try!</strong></a></p><p>Hate it or love it — <strong>CSS-in-JS deserves a chance!</strong></p><h4 id="Convinced-CSS-in-JS-is-not-for-me-There’s-another-option-—-CSS-Modules"><a href="#Convinced-CSS-in-JS-is-not-for-me-There’s-another-option-—-CSS-Modules" class="headerlink" title="Convinced CSS-in-JS is not for me? There’s another option — CSS Modules!"></a><a href="https://glenmaddern.com/articles/css-modules" target="_blank" rel="noopener">Convinced CSS-in-JS is not for me? There’s another option — CSS Modules!</a></h4><p>Thanks for reading!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TL;DR:&lt;strong&gt;Thinking in components — &lt;/strong&gt;No longer do you have to maintain bunch of style-sheets. CSS-in-JS abstracts the CSS model to the component level, rather than the document level (modularity).&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
      <category term="css" scheme="http://nthung2112.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Hiểu sâu về React Higher Order Components</title>
    <link href="http://nthung2112.github.io/2018/04/Hieu-sau-ve-React-Higher-Order-Components.html"/>
    <id>http://nthung2112.github.io/2018/04/Hieu-sau-ve-React-Higher-Order-Components.html</id>
    <published>2018-04-30T08:08:00.000Z</published>
    <updated>2018-04-30T08:31:59.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu"></a>Giới thiệu</h1><p>Chắc hẳn rất nhiều người trong chúng ta đã và đang sử dụng React, và tất nhiên là kèm theo hằng tá thư viện đi kèm hỗ trợ nó (lol) Và chắc hẳn bạn đã từng gặp thư viện yêu cầu bạn viết một đoạn code kiểu này để thư viện có thể hoạt động:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Component); </span><br><span class="line"><span class="comment">// Kết nối Component với Store của Redux bằng thư viện react-redux</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>Hoặc là thế này</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Radium = <span class="built_in">require</span>(<span class="string">'radium'</span>);</span><br><span class="line">@Radium</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Radium thư viện hỗ trợ inline style cho React element</span></span><br></pre></td></tr></table></figure><p>Và boom Component của chúng ta nhận được props, styles và thậm chí là render ra một view khác </p><p><img src="https://viblo.asia/uploads/8dd3d81c-5fc7-431b-867c-e96a511abb83.gif" alt=""> </p><p>Các bạn đã bao giờ tự hỏi <code>connect()</code> <code>@Radium</code> kia là gì, tại sao lại viết như vậy. Vâng trong bài viết này chúng ta sẽ cùng tìm hiểu về một khái niệm nâng cao trong React - <strong>Higher-Order Components.</strong> </p><p><img src="https://viblo.asia/uploads/d0174b65-4df5-4a89-8b4d-01a14fc0c757.gif" alt=""></p><h1 id="Higher-Order-Components-In-a-Nutshell"><a href="#Higher-Order-Components-In-a-Nutshell" class="headerlink" title="Higher-Order Components In a Nutshell"></a>Higher-Order Components In a Nutshell</h1><h2 id="What-are-Higher-Order-Components-HoCs"><a href="#What-are-Higher-Order-Components-HoCs" class="headerlink" title="What are Higher-Order Components (HoCs)?"></a>What are Higher-Order Components (HoCs)?</h2><p>Về bản chất, HoC không phải là một phần của React API, nó là một pattern xuất hiện từ những thành phần đặc tính của React. Thường được implement như một function, mà về cơ bản, là một class factory (vâng, là một class factory!)</p><blockquote><p>Higher Order Component (HoC) là một function nhận vào một component và trả về một component mới. EnhancedComponent = higherOrderComponent(WrappedComponent);</p></blockquote><h2 id="What-can-I-do-with-HOCs"><a href="#What-can-I-do-with-HOCs" class="headerlink" title="What can I do with HOCs?"></a>What can I do with HOCs?</h2><p>Ở cấp độ cao, HoC cho phép chúng ta:</p><ul><li>Code reuse, logic và tự động trừu tượng hóa (bootstrap abstraction)</li><li>Chiếm quyền render (Render Highjacking)</li><li>Trừu tượng hóa (abstraction) và điều khiển (manipulation) State</li><li>Điều khiển Props</li></ul><p>Chúng ta sẽ xem chi tiết về những mục này, nhưng trước tiên, chúng ta sẽ học cách implement HoCs bởi vì việc implement cho chúng ta thấy những điều có thể và hạn chế mà chúng ta thực sự có thể làm với HoC.</p><h1 id="HOC-factory-implementations"><a href="#HOC-factory-implementations" class="headerlink" title="HOC factory implementations"></a>HOC factory implementations</h1><p>Có 2 cách implement HoCs thường thấy trong React: <strong>Props Proxy (PP)</strong> và <strong>Inheritance Inversion (II)</strong>. Cả 2 cách cho phép các cách khác nhau để thao tác với WrappedComponent.</p><p>Trước khi bắt đầu chúng ta cần một project</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create-react-app learnHOC</span><br><span class="line">cd learnHOC/src/</span><br><span class="line">touch HOC.js</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><h2 id="Props-Proxy"><a href="#Props-Proxy" class="headerlink" title="Props Proxy"></a>Props Proxy</h2><p>Props Proxy (PP) được implement thông thường theo cách sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pP</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>Phần quan trọng nhất ở đây là method render của HoC trả về một React Element của kiểu WrappedComponent. Chúng ta cũng truyền props mà HoC nhận được, vì thế phương pháp này mới có tên Props Proxy.</p><h3 id="What-can-be-done-with-Props-Proxy"><a href="#What-can-be-done-with-Props-Proxy" class="headerlink" title="What can be done with Props Proxy?"></a>What can be done with Props Proxy?</h3><ul><li>Điều khiển props</li><li>Truy cập instance thông qua Refs</li><li>Trừu tượng hóa (Abstracting) State</li><li>Bao WrappedComponent với elements khác</li></ul><h4 id="Dieu-khien-props"><a href="#Dieu-khien-props" class="headerlink" title="Điều khiển props"></a>Điều khiển props</h4><p>Chúng ta có thể đọc, thêm, sửa đổi và xóa props được truyền cho WrappedComponent.</p><p>Nhưng cẩn thận với việc xóa hay sửa đổi các prop quan trọng, chúng ta nên đặt namespace cho HoC props để nó không phá vỡ WrappedComponent.</p><p>Ví dụ: Thêm mới props.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HOC.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pP</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        newProps: <span class="string">'something news'</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">module.exports = &#123;</span></span><br><span class="line"><span class="xml">    pP</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>Sửa lại file App một chút</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;pP&#125; <span class="keyword">from</span> <span class="string">'./HoC'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.group(<span class="string">'App'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props);</span><br><span class="line">    <span class="built_in">console</span>.groupEnd();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> pP(App);</span><br></pre></td></tr></table></figure><p>Và ở console chúng ta có kết quả <img src="https://viblo.asia/uploads/48e1c152-e99c-48a3-9074-b6be4df55b6a.png" alt=""></p><h4 id="Truy-cap-instance-thong-qua-Refs"><a href="#Truy-cap-instance-thong-qua-Refs" class="headerlink" title="Truy cập instance thông qua Refs"></a>Truy cập instance thông qua Refs</h4><p>Chúng ta có thể truy cập this (instance của WrappedComponent) với ref, nhưng chúng ta sẽ cần một quá trình render đầy đủ của WrappedComponent để ref có thể được tính toán. Điều này có nghĩa là chúng ta cần trả về WrappedComponent element từ method render của HoC, để React có thể làm quá trình đối chiếu (reconciliation process) và chúng ta sẽ có ref đến WrappedComponent instance.</p><p>Ví dụ: Chúng ta sẽ tìm hiểu làm thế nào để truy cập instance methods và instance của chính WrappedComponent thông qua refs</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HOC.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refsPP</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">RefsPP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    proc(wrappedComponentInstance) &#123;</span><br><span class="line">      <span class="built_in">console</span>.group(<span class="string">'refs Proc'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(wrappedComponentInstance);</span><br><span class="line">      wrappedComponentInstance.test();</span><br><span class="line">      <span class="built_in">console</span>.groupEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.props, &#123;<span class="attr">ref</span>: <span class="keyword">this</span>.proc.bind(<span class="keyword">this</span>)&#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">module.exports = &#123;</span></span><br><span class="line"><span class="xml">    pP,</span></span><br><span class="line"><span class="xml">    refsPP</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>Sửa file App một chút</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;pP, refsPP&#125; <span class="keyword">from</span> <span class="string">'./HoC'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  test() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'call Test'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  .....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> refsPP(App);</span><br></pre></td></tr></table></figure><p>Và ở console chúng ta có kết quả <img src="https://viblo.asia/uploads/ff5e3971-58bf-406c-ae1b-ff012e790bee.png" alt=""> Khi WrappedComponent được render xong thì ref callback sẽ được thực thi, và chúng ta sẽ có ref đến WrappedComponent instance. Điều này có thể được sử dụng để đọc/thêm các props và gọi các instance method.</p><h4 id="Truu-tuong-hoa-Abstracting-State"><a href="#Truu-tuong-hoa-Abstracting-State" class="headerlink" title="Trừu tượng hóa (Abstracting) State"></a>Trừu tượng hóa (Abstracting) State</h4><p>Chúng ta có thể trừu tượng hóa state bằng cách cung cấp props và callbacks cho WrappedComponent, tương tự như <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">Container Components làm với Presentational components</a>. Ví dụ: Chúng ta sẽ thực hiện trừu tượng hóa state để kiểm soát input</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HOC.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">statePP</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line">      <span class="keyword">this</span>.state = &#123; <span class="attr">fields</span>: &#123;&#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getField(fieldName) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.state.fields[fieldName]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state.fields[fieldName] = &#123;</span><br><span class="line">          value: <span class="string">''</span>,</span><br><span class="line">          onChange: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.state.fields[fieldName].value = event.target.value</span><br><span class="line">            <span class="keyword">this</span>.forceUpdate()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        value: <span class="keyword">this</span>.state.fields[fieldName].value,</span><br><span class="line">        onChange: <span class="keyword">this</span>.state.fields[fieldName].onChange</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.props, &#123;</span><br><span class="line">        fields: <span class="keyword">this</span>.getField.bind(<span class="keyword">this</span>),</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>Sửa file App một chút</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;pP, refsPP, statePP&#125; <span class="keyword">from</span> <span class="string">'./HoC'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  test() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'call Test'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.group(<span class="string">'App'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name'</span>, <span class="keyword">this</span>.props.fields(<span class="string">'name'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'email'</span>, <span class="keyword">this</span>.props.fields(<span class="string">'email'</span>));</span><br><span class="line">    <span class="built_in">console</span>.groupEnd();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        ....</span><br><span class="line">        &lt;form&gt;</span><br><span class="line">          &lt;label&gt;Automatically controlled input!<span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">          &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"Name"</span> &#123;...this.props.fields(<span class="string">'name'</span>)&#125;/&gt;</span><br><span class="line">          &lt;input type=<span class="string">"email"</span> placeholder=<span class="string">"Email"</span> &#123;...this.props.fields(<span class="string">'email'</span>)&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Và chúng ta có kết quả <img src="https://viblo.asia/uploads/ea2e3283-f7ba-4b7e-a282-cc3a504b3324.png" alt=""></p><p>Việc trừu tượng hóa state có nhiều ứng dụng, và được sử dụng khá nhiều trong việc giải quyết các vấn đề mà Stateless component gặp phải như không có ref chẳng hạn.</p><h4 id="Bao-WrappedComponent-voi-elements-khac"><a href="#Bao-WrappedComponent-voi-elements-khac" class="headerlink" title="Bao WrappedComponent với elements khác"></a>Bao WrappedComponent với elements khác</h4><p>Chúng ta có thể bao WrappedComponent với component hoặc element khác để styling, layout hoặc mục đích khác. Cách sử dụng cơ bản có thể hoàn thành bởi Parent Components nhưng chúng ta có nhiều sự linh hoạt hơn với HoCs như đã mô tả ở trên.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HOC.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">elmWrapPP</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ElmWrapPP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123;<span class="attr">display</span>: <span class="string">'block'</span>&#125;&#125;&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Inheritance-Inversion"><a href="#Inheritance-Inversion" class="headerlink" title="Inheritance Inversion"></a>Inheritance Inversion</h2><p>Inheritance Inversion (II) thường được implement như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Như các bạn thấy, HOC trả về class (Enhancer) kế thừa (extends) WrappedComponent. Phương pháp này gọi là Inheritance Inversion là do thay vì WrappedComponent mở rộng (kế thừa) Enhancer class nào đó, nó lại được mở rộng (kế thừa) bởi Enhancer. Theo cách này, mối quan hệ giữa chúng dường như bị đảo ngược.</p><p>II cho phép HoC truy cập vào WrappedComponent instance thông qua this, điều này có nghĩa là <strong>HoC có quyền truy cập state, props, component lifecycle hooks và cả phương thức render.</strong></p><p>Chúng ta sẽ không đi sau vào chi tiết chúng ta có thể làm gì với component lifecycle hooks, đó không phải là những gì cụ thể HoC làm, nó là React. Nhưng lưu ý rằng chúng ta hoàn toàn có thể tạo ra lifecycle hooks mới cho WrappedComponent. Và nhớ răng luôn gọi <em>super.[lifecycleHook]</em> để không phá vỡ WrappedComponent.</p><h4 id="Qua-trinh-doi-chieu-Reconciliation-process"><a href="#Qua-trinh-doi-chieu-Reconciliation-process" class="headerlink" title="Quá trình đối chiếu (Reconciliation process)"></a>Quá trình đối chiếu (Reconciliation process)</h4><p>Trước khi bắt đầu chúng ta cần tóm tát vài lý thuyết.</p><p>React Elements mô tả những gì sẽ hiển thị khi React chạy quá trình đối chiếu của nó.</p><p>React Elements có thể có 2 loại: String và Function. String Type React Element (STRE) đại diện các DOM node và Function Type React Element (FTRE) đại diện các Component được tạo ra bằng cách mở rộng React.Component. Đọc thêm tại <a href="https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener">post</a>.</p><p>FTRE sẽ được phân giải ra thành cây STRE trong quá trình đối chiếu của React (kết quả cuối cùng luôn là các DOM Element).</p><p>Điều này rất quan trọng và nó có nghĩa là:</p><blockquote><p>Inheritance Inversion High Order Components không đảm bảo là đã giải quyết được toàn bộ cây con. Điều này sẽ được chứng thực khi học Render Highjacking.</p></blockquote><h3 id="What-can-you-do-with-Inheritance-Inversion"><a href="#What-can-you-do-with-Inheritance-Inversion" class="headerlink" title="What can you do with Inheritance Inversion?"></a>What can you do with Inheritance Inversion?</h3><ul><li>Chiếm quyền render (Render Highjacking)</li><li>Điều khiển state (Manipulating state)</li></ul><h4 id="Render-Highjacking"><a href="#Render-Highjacking" class="headerlink" title="Render Highjacking"></a>Render Highjacking</h4><p>Phương pháp này gọi là Render Highjacking bởi vì HoC kiểm soát render output của WrappedComponent và chúng ta có thể làm bất kì điều gì với nó.</p><p>Trong Render Highjacking chúng ta có thể</p><ul><li>Đọc, thêm, sửa, xóa props trong bất kì React Elements nào xuất ra bởi render.</li><li>Đọc và sửa đổi React elements tree xuất ra bởi render.</li><li>Hiển thị elements tree theo điều kiện.</li><li>Bao element tree cho mục đích styling (giống như đã nói ở PP)\</li></ul><p><em>Note: render đề cấp đến WrappedComponent.render</em></p><blockquote><p>Chúng ta không thể chỉnh sửa hoặc tạo props của WrappedComponent instace, bởi vì một React Component không thể chỉnh sửa props mà nó nhận được, nhưng chúng ta có thể thay đổi các props của các element xuất ra từ phương thức render.</p></blockquote><p>Như chúng ta đã nói ở trên, II HoCs không đảm bảo toàn bộ cây con được giải quyết, điều này hàm ý một số giới hạn với kỹ thuật Render Highjacking. Quy tắc chung là với Render Highjacking chúng ta có thể thao tác với element tree mà WrappedComponent.render xuất ra không nhiều hơn cũng không ít hơn. Nếu Element tree đó có chưa một <em><a href="https://facebook.github.io/react/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">Function Type React Component</a></em> thì chúng ta sẽ không thể thao tác được với các con của Component đó. (Do chúng được hoãn lại bởi quá trình đối chiếu của React cho đến khi nó thực sự được render)</p><ul><li>Ví dụ 1: <strong>Render có điều kiện</strong> HOC sẽ render chính xác những gì mà WrappedComponent sẽ render trừ khi this.props.loggedIn = false. (Giả định là HoC sẽ nhận được loggedIn prop).</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HOC.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rHII</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.loggedIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.render()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Not loggedIn<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Và tất nhiên App của chúng ta không có props loggedIn (Lười quá (lol) ) nên kết quả sẽ là <img src="https://viblo.asia/uploads/2ab60c9f-0e2b-4a5f-8f02-6bd187c6a718.png" alt=""></p><ul><li>Ví dụ 2: <strong>Sửa đổi React Element tree</strong> xuất ra bởi render.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HOC.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeII</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> elementsTree = <span class="keyword">super</span>.render()</span><br><span class="line">      <span class="keyword">let</span> newProps = &#123;&#125;;</span><br><span class="line">      <span class="keyword">var</span> newChilds = elementsTree.props.children.map(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (child.type === <span class="string">'input'</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> childNewProps = &#123;<span class="attr">value</span>: <span class="string">'may the force be with you'</span>&#125;;</span><br><span class="line">            <span class="keyword">var</span> childProps = <span class="built_in">Object</span>.assign(&#123;&#125;, child.props, childNewProps)</span><br><span class="line">            <span class="keyword">return</span> React.cloneElement(child, childProps, child.props.children);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, elementsTree.props, newProps)</span><br><span class="line">      <span class="keyword">const</span> newElementsTree = React.cloneElement(elementsTree, props, newChilds)</span><br><span class="line">      <span class="keyword">return</span> newElementsTree</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"hljs-comment"</span>&gt;<span class="comment">// App.js&lt;/span&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"hljs-class"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hljs-keyword"</span>&gt;</span>class<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"hljs-title"</span>&gt;App&lt;<span class="regexp">/span&gt; &lt;span class="hljs-keyword"&gt;extends&lt;/</span>span&gt; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hljs-title"</span>&gt;</span>Component<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"hljs-keyword"</span>&gt;<span class="keyword">return</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">"App-header"</span>&gt;</span><br><span class="line">          &lt;img src=&#123;logo&#125; className=<span class="string">"App-logo"</span> alt=<span class="string">"logo"</span> /&gt;</span><br><span class="line">          &lt;h2&gt;Welcome to React&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;p className=<span class="string">"App-intro"</span> ref=<span class="string">"appIntro"</span>&gt;</span><br><span class="line">          To get started, edit &lt;code&gt;src/App.js&lt;<span class="regexp">/code&gt; and save to reload.</span></span><br><span class="line"><span class="regexp">        &lt;/</span>p&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"Name"</span>/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> export default treeII(App);</span></span><br></pre></td></tr></table></figure><p>Trong ví dụ trên, nếu output render bởi WrappedComponent có chứa element con có type là `input’ thì HoC sẽ thay đổi value của nó thành ‘may the force be with you’.</p><p>Chúng ta có thể làm mọi thứ ở đây, chúng ta có thể duyệt qua toàn bộ các phần tử của element tree và thay đổi bất kì props của bất kì element nào trong tree. Và đây chính xác là những gì <a href="https://github.com/FormidableLabs/radium" target="_blank" rel="noopener">Radium</a> thực hiện.</p><blockquote><p>Note: Chúng ta không thể Render Highjack với Props Proxy. Mặc dù vẫn có thể truy cập vào phương thức render thông qua WrappedComponent.prototype.render, chúng ta sẽ cần phải mô phỏng WrappedComponent instance và các props của nó, và có khả năng là phải tự xử lý component lifecycle thay vì để React làm nó. Trong thực nghiệm của tôi, nó không có giá trị nhiều lắm và nếu chúng ta muốn Render Highjacking chúng ta nên sử dụng II thay vì PP. Hãy nhớ rằng React xử lý các component instances nội bộ và cách duy nhất để chúng ta thao tác với instances là thông qua refs.</p></blockquote><h4 id="Manipulating-state"><a href="#Manipulating-state" class="headerlink" title="Manipulating state"></a>Manipulating state</h4><p>HOC có thể đọc, chỉnh sửa và xóa state của WrappedComponent instance, và chúng ta cũng có thể thêm state nếu cần. Hãy nhớ rằng chúng ta đang làm rối state của WrappedComponent, điều có thể dẫn chúng ta đến việc hủy hoại mọi thứ. Hầu hết các HOC nên được giới hạn để đọc hoặc thêm state, và sau đó được đặt tên (namespace) để không làm rối state của WrappedComponent.</p><p>Ví dụ: Debugging bằng cách truy cập props và state của WrappedComponent</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IIHOCDEBUGGER</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">II</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h2&gt;HOC Debugger Component&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;Props&lt;/</span>p&gt; <span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;JSON.stringify(this.props, null, 2)&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line">          &lt;p&gt;State&lt;<span class="regexp">/p&gt;&lt;pre&gt;&#123;JSON.stringify(this.state, null, 2)&#125;&lt;/</span>pre&gt;</span><br><span class="line">          &#123;<span class="keyword">super</span>.render()&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>HOC này sẽ bao WrappedComponent với element khác đồng thời hiện các props và state của WrappedComponent.</p><h2 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h2><p>Khi bao một component với HOC chúng ta đánh mất tên của WrappedComponent, điều này sẽ ảnh hưởng đến chúng ta trong quá trình dev và debugging.</p><p>Mọi người thường làm là tùy chỉnh tên của HOC bằng cách lấy tên của WrappedComponent và đặt trước một cái gì đó. Dưới đây trích từ React-Redux:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HOC.displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> ... </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Function getDisplayName được định nghĩa như sau</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent.displayName || </span><br><span class="line">         WrappedComponent.name || </span><br><span class="line">         ‘Component’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chúng ta thực sự không phải viết lại nó vì thư viện <a href="https://github.com/acdlite/recompose" target="_blank" rel="noopener">recompose</a> đã cung cấp function này rồi.</p><h2 id="Phu-luc"><a href="#Phu-luc" class="headerlink" title="Phụ lục"></a>Phụ lục</h2><h3 id="HOC-and-parameters"><a href="#HOC-and-parameters" class="headerlink" title="HOC and parameters"></a>HOC and parameters</h3><p>Đôi khi rất hữu ích khi sử dụng các parameters cho HOCs. Điều này ẩn trong những ví dụ bên trên và nên được phát triển tự nhiên đến Javascript developers trung gian, nhưng vì lợi ích làm cho bài viết đầy đủ, chúng ta sẽ lướt qua nó một cách nhanh chóng.</p><p>Ví dụ: HOC parameters với Props Proxy thông thường. Điều quan trọng là HOCFactoryFactory function.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOCFactoryFactory</span>(<span class="params">...params</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// do something with params</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">HOCFactory</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>Và chúng ta có thể sử dụng như thế này</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HOCFactoryFactory(params)(WrappedComponent)</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">@HOCFatoryFactory(params)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="Difference-with-Parent-Components"><a href="#Difference-with-Parent-Components" class="headerlink" title="Difference with Parent Components"></a>Difference with Parent Components</h3><p>Như đã nói ở phần ‘Bao WrappedComponent với elements khác’, ở một số cách cơ bản cảu HOC ta có thể hoàn thành với Parent Component. Vậy điểm khác biệt giữ HOC và Parent Component là gì?</p><blockquote><p>Parent Components là React Components có vài components con. React có APIs để truy cập và thao tác với component con.</p></blockquote><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">render((&lt;Parent&gt;&#123;children&#125;&lt;/</span>Parent&gt; ),  mountNode);</span><br></pre></td></tr></table></figure><p>Giờ chúng ta sẽ duyệt qua xem Parent Components có và không thể làm gì khi so sánh với HOCs và thêm vài thông tin quan trọng:</p><ul><li>Có thể Render Highjacking tương tự như với II HOC</li><li>Có thể điều khiển inner props tương tự như với II HOC</li><li>Có thể trừu tượng hóa state, nhưng có nhược điểm. Chúng ta sẽ không thể truy cập state của Parent Component từ bên ngoài trừ khi chúng ta tạo hooks cho nó. Điều này hạn chế tính hữu ích của nó.</li><li>Bao các elements với elements khác. Đây có thể là trường hợp duy nhất Parent component làm tốt hơn HOC. Nhưng tất nhiên là HOC cũng làm đc.</li><li>Thao tác với child component gặp một số vấn đề. Ví dụ nếu childrent không chỉ có 1 root element (nhiều hơn 1 first level childrent), thì chúng ta phải thêm 1 element để bao tất cả children lại, mà điều này có thể gây rườm ra cho markup của chúng ta. Trong HOCs 1 top level children root được đảm bảo bởi React/JSX.</li><li>Parent Components có thể được sử dụng tự do trong Elements tree, chúng không bị hạn chế 1 Component 1 lần như HOC.</li></ul><p>Nói chung, nếu chúng ta có thể làm được nó với Parent Components thì chúng ta nên làm nó, bởi vì Parent Components ít “hack não” hơn HOCs, nhưng như những điều đã nói, với State nó kém linh hoạt hơn so với HoCs.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Hi vọng là sau khi đọc bài này, mọi người sẽ hiểu hơn một chút về React HOCs. Chúng thực sự có ý nghĩa và đã được chứng minh khá tốt trong nhiều thư viện khác nhau. React mang lại rất nhiều sự đổi mới và những thư viện như Radium, React-Redux, React-Router trong số rất nhiều thư viện khác là những bằng chứng về điều đó.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Gioi-thieu&quot;&gt;&lt;a href=&quot;#Gioi-thieu&quot; class=&quot;headerlink&quot; title=&quot;Giới thiệu&quot;&gt;&lt;/a&gt;Giới thiệu&lt;/h1&gt;&lt;p&gt;Chắc hẳn rất nhiều người trong chúng ta đã và đang sử dụng React, và tất nhiên là kèm theo hằng tá thư viện đi kèm hỗ trợ nó (lol) Và chắc hẳn bạn đã từng gặp thư viện yêu cầu bạn viết một đoạn code kiểu này để thư viện có thể hoạt động:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; connect &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react-redux&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; connect(mapStateToProps, mapDispatchToProps)(Component); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Kết nối Component với Store của Redux bằng thư viện react-redux&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://nthung2112.github.io/tags/react/"/>
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
      <category term="hoc" scheme="http://nthung2112.github.io/tags/hoc/"/>
    
  </entry>
  
</feed>
