<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Learn and Share</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nthung2112.github.io/"/>
  <updated>2018-11-13T16:39:26.827Z</updated>
  <id>http://nthung2112.github.io/</id>
  
  <author>
    <name>Hung Tan Nguyen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cách Javascript hoạt động P4: Event loop, lập trình bất đồng bộ &amp; 5 mẹo cải thiện Async/Await</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P4-Event-loop-lap-trinh-bat-dong-bo-5-meo-cai-thien-Async-Await.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P4-Event-loop-lap-trinh-bat-dong-bo-5-meo-cai-thien-Async-Await.html</id>
    <published>2018-11-13T16:34:00.000Z</published>
    <updated>2018-11-13T16:39:26.827Z</updated>
    
    <content type="html"><![CDATA[<p>Chào các bạn đến với bài thứ 4 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.</p><p>Lần này chúng ta sẽ mở rộng những gì có trong bài đầu tiên bằng cách đánh giá những nhược điểm của môi trường đơn luồng (single thread) và làm thế nào để vượt qua chúng nhằm xây dựng những Javascript UI ấn tượng. Và vẫn như cũ, cuối bài viết tác giả sẽ chia sẻ 5 mẹo nhỏ để viết code tốt hơn với async/await.<br><a id="more"></a></p><h1 id="Tai-sao-don-luong-lai-la-gioi-han"><a href="#Tai-sao-don-luong-lai-la-gioi-han" class="headerlink" title="Tại sao đơn luồng lại là giới hạn."></a>Tại sao đơn luồng lại là giới hạn.</h1><p>Trong bài đầu tiên của series, chúng ta suy ngẫm về câu hỏi điều gì xảy ra khi chúng ta có 1 hàm trong callstack và hàm đó lại ngốn quá nhiều thời gian để thực thi.</p><p>Hãy tưởng tượng, ta thực hiện một thuật toán chuyển đổi hình ảnh phức tạp chạy trên browser.</p><p>Trong khi callstack đang thực thi các hàm, trình duyệt lại không thể làm gì cả, nó bị kẹt. Nghĩa là trình duyệt không thể vẽ, render, nó không thể chạy code khác, chỉ đơn giản là kẹt. Và vấn đề là ở đây, giao diện (UI) của app bạn sẽ hoạt động không hiệu quả.</p><p>App của bạn bị kẹt.</p><p>Trong một vài trường hợp thì đây không phải vấn đề nghiêm trọng. Tuy nhiên, có vấn đề còn lớn hơn nữa. Một khi trình duyệt của bạn xử lý quá nhiều thứ trong callstack, nó sẽ bị “đỡ” trong 1 khoảng thời gian dài. Tại thời điểm đó, đa số các browser sẽ chọn giải pháp hiện lỗi, hỏi người dùng có muốn hủy trang hiện tại không.</p><p>Điều này thật là xấu xí và ảnh hưởng nghiêm trọng đến trải nghiệm (UX):</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*MCt4ZC0dMVhJsgo1u6lpYw.jpeg" alt=""></p><h1 id="Nhung-thanh-phan-xay-dung-nen-1-chuong-trinh-JS"><a href="#Nhung-thanh-phan-xay-dung-nen-1-chuong-trinh-JS" class="headerlink" title="Những thành phần xây dựng nên 1 chương trình JS"></a>Những thành phần xây dựng nên 1 chương trình JS</h1><p>Bạn có thể viết toàn bộ code JS trong 1 file .js duy nhất nhưng chương trình của bạn chắc chắn chứa nhiều thành phần nhỏ (gọi là những block), chỉ có một số block sẽ được <strong>thực thi ngay</strong> (gọi là nhóm A) và phần còn lại thì <strong>chạy sau</strong> (nhóm B). Đơn vị block phổ biến nhất là function (hàm).</p><p>Vấn đề mà đa số các developer JS mới gặp phải là họ nghĩ rằng nhóm B không cần phải được thực thi một cách nghiêm ngặt ngay sau khi thực thi nhóm A. Nói cách khác, những nhiệm vụ không được hoàn thành ngay bây giờ thì theo lỹ thuyết nó sẽ được hoàn thành một cách bất đồng bộ, nghĩa là bạn sẽ không phải gặp tình huống blocking (bị chặn) như đề cập ở trên</p><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Giả sử ajax(..) là một hàm Ajax thuộc thư viện nào đó</span></span><br><span class="line"><span class="keyword">var</span> response = ajax(<span class="string">'https://example.com/api'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(response);</span><br><span class="line"><span class="comment">// `response` sẽ không chứa dữ liệu trả về</span></span><br></pre></td></tr></table></figure><p>Chắc bạn cũng nhận thấy rằng những request Ajax như thế này không chạy đồng bộ với nhau, nghĩa là tại thời điểm code thực thi, hàm ajax(…) chưa có dữ liệu trả về để gán vào biến response</p><p>Một cách đơn giản cho thường gặp để “chờ” một hàm xử lý bất đồng bộ trả kết quả về đó là sử dụng callback:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'https://example.com/api'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response); <span class="comment">// "response" giờ đã có dữ liệu</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Chú ý: Bạn có thể viết những Ajax request đồng bộ, tuy nhiên đừng bao giờ làm thế. Nếu bạn viết Ajax như vậy thì UI sẽ bị block cứng đơ và người dùng sẽ không thể thực hiện các hành động như click, nhập dữ liệu, điều hướng, lăn chuột… Một trải nghiệm kinh khủng.</p><p>Đây là cách mà Ajax được viết đồng bộ, nhưng làm ơn, đừng bao giờ sử dụng nó trong app của bạn:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Giả sử bạn đang dùng jQuery</span></span><br><span class="line">jQuery.ajax(&#123;</span><br><span class="line">    url: <span class="string">'https://api.example.com/endpoint'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// callback ở đây.</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span>: <span class="literal">false</span> <span class="comment">// Một ý tưởng cực kỳ tồi tệ</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Chúng ta đã sử dụng Ajax request để ví dụ. Ngoài ra bạn có thể dùng bất kỳ đoạn code nào để thực hiện bất đồng bộ.</p><p>Dưới đây là ví dụ khác với hàm setTimeout(callback, milliseconds). Cách thức mà hàm setTimeout hoạt động là nó sẽ đặt 1 sự kiện (ở đây là sự kiện timeout) và để nó thực hiện sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'first'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'second'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">third</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'third'</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line">setTimeout(second, <span class="number">1000</span>); <span class="comment">// gọi hàm `second` sau 1000ms</span></span><br><span class="line">third();</span><br></pre></td></tr></table></figure><p>Và đây là kết quả của đoạn code trên:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">third</span><br><span class="line">second</span><br></pre></td></tr></table></figure><h1 id="Mo-xe-Event-Loop-vong-lap-su-kien"><a href="#Mo-xe-Event-Loop-vong-lap-su-kien" class="headerlink" title="Mổ xẻ Event Loop (vòng lặp sự kiện)"></a>Mổ xẻ Event Loop (vòng lặp sự kiện)</h1><p>Chúng ta sẽ bắt đầu với một chút “kỳ quặc” - mặc dù JS chấp nhận code chạy bất đồng bộ (như trường hợp của setTimeout) thì cho đến khi giới thiệu ES6, JS cũng không thực sự có một khái niệm trực tiếp nào về bất đồng bộ. Bộ engine JS chưa bao giờ làm gì vượt ra khỏi việc thực thi <strong>một</strong> khối lệnh trong chương trình của bạn tại 1 thời điểm cố định.</p><p>Bạn có thể xem chi tiết hơn về cách engine JS (cụ thể là Google V8) hoạt động như thế nào ở <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-2---Ben-trong-engine-V8---5-meo-de-toi-uu-hoa-code" target="_blank" rel="noopener">bài viết trước</a>.</p><p>Vậy thì ai là người ra lệnh cho engine JS phải thực thi những khối lệnh trong chương trình? Trên thực tế, engine JS không chạy cô lập, nó hoạt động bên trong một môi trường chủ (hosting environment), môi trường này đối với đa số các developer chính là trình duyệt web hoặc Node.js. Thực ra, ngày nay, JS đã và đang được nhúng vào rất nhiều loại thiết bị khác nhau, từ robot cho tới bóng đèn. Mỗi một thiết bị có thể xem như là 1 loại khác nhau của môi trường chủ cho engine JS.</p><p>Mẫu số chung của tất cả các môi trường đó là một cơ chế tích hợp sẵn được gọi là <strong>event-loop</strong> (vòng lặp sự kiện), nó xử lý quá trình thực thi của nhiều khối lệnh trong chương trình theo thời gian, mỗi lần đều gọi engine JS.</p><p>Điều này nghĩa là engine JS chỉ là 1 môi trường thực thi theo yêu cầu cho bất kỳ đoạn code JS tùy ý nào. Nó chỉ là môi trường bao quanh có lịch trình cho các sự kiện (quá trình thực thi code JS).</p><p>Ví dụ, khi code JS của bạn gọi Ajax request để lấy dữ liệu từ server, bạn cài đặt một đoạn code <em>response</em> trong một hàm (gọi là callback), và engine JS sẽ truyền đạt lại với môi trường chủ: <em>Này, tao chuẩn bị tạm ngưng quá trình thực thi ngay bây giờ, nhưng mà khi nào mày xong việc với request đó và có một vài cục dữ liệu thì nhớ gọi lại hàm này nhé.</em></p><p>Trình duyệt sau đó sẽ lắng nghe về response từ mạng, và khi nó có gì đó trả về cho bạn, nó sẽ lên lịch cho hàm callback được thực thi bằng cách chèn nó vào trong event loop</p><p>Cùng xem sơ đồ này nào:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*FA9NGxNB6-v1oI2qGEtlRQ.png" alt=""></p><p>Bạn có thể xem lại phần bài viết về Memory Heap &amp; Call Stack trong <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-1---Khai-quat-ve-engine--runtime-va-callstack" target="_blank" rel="noopener">bài viết trước đây</a></p><p>Vậy thì những Web APIs này là gì? Về bản chất, chúng là những tiến trình mà bạn không thể truy xuất (access), bạn chỉ có thể gọi nó. Chúng là những thành phần của trình duyệt mà trong đó cách xử lý đồng bộ được bắt đầu. Nếu bạn là một Node.js developer thì chúng là những C++ APIs.</p><p><strong>Vậy cuối cùng thì event loop là cái éo gì ?</strong></p><p><img src="https://cdn-images-1.medium.com/max/1000/1*KGBiAxjeD9JT2j6KDo0zUg.png" alt=""></p><p><strong>Event Loop</strong> có một công việc đơn giản: theo dõi Call Stack và Callback Queue (hàng đợi các hàm callback). Nếu Call Stack đang trống, nó sẽ lấy event đầu tiên từ trong hàng đợi ra và đẩy nó vảo trong Call Stack - tức là thực thi nó.</p><p>Mỗi vòng lặp như thế được gọi là 1 <strong>tick</strong> trong Event Loop. Mỗi sự kiện chỉ là 1 hàm callback.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb1</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'cb1'</span>);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Bye'</span>);</span><br></pre></td></tr></table></figure><p>Cùng <em>thực thi</em> đoạn code trên và xem điều gì xảy ra nào:</p><ol><li>Trạng thái đang trống, console của trình duyệt đang trống, Call Stack đang trống. <img src="https://cdn-images-1.medium.com/max/1000/1*9fbOuFXJHwhqa6ToCc_v2A.png" alt=""></li><li>console.log(‘Hi’) được thêm vào Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*dvrghQCVQIZOfNC27Jrtlw.png" alt=""></li><li>console.log(‘Hi’) được thực thi. <img src="https://cdn-images-1.medium.com/max/1000/1*yn9Y4PXNP8XTz6mtCAzDZQ.png" alt=""></li><li>console.log(‘Hi’) bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*iBedryNbqtixYTKviPC1tA.png" alt=""></li><li>setTimeout(function cb1() { … }) được thêm vào Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*HIn-BxIP38X6mF_65snMKg.png" alt=""></li><li>setTimeout(function cb1() { … }) được thực thi. Trình duyệt tạo một timer - vốn là một phần của Web APIs. Nó sẽ thực hiện phần đếm ngược cho bạn. <img src="https://cdn-images-1.medium.com/max/1000/1*vd3X2O_qRfqaEpW4AfZM4w.png" alt=""></li><li>The setTimeout(function cb1() { … }) được thực hiện xong và bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*_nYLhoZPKD_HPhpJtQeErA.png" alt=""></li><li>console.log(‘Bye’) được thêm vào Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*1NAeDnEv6DWFewX_C-L8mg.png" alt=""></li><li>console.log(‘Bye’) được thực thi. <img src="https://cdn-images-1.medium.com/max/1000/1*UwtM7DmK1BmlBOUUYEopGQ.png" alt=""></li><li>console.log(‘Bye’) bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*-vHNuJsJVXvqq5dLHPt7cQ.png" alt=""></li><li>Sau ít nhất 5000ms, timer hoàn thành công việc của nó và đẩy cb1 callback vào trong Callback Queue. <img src="https://cdn-images-1.medium.com/max/1000/1*eOj6NVwGI2N78onh6CuCbA.png" alt=""></li><li>Event Loop lấy cb1 từ trong Callback Queue và đưa nó vào trong Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*jQMQ9BEKPycs2wFC233aNg.png" alt=""></li><li>cb1 được thực thi và nó thêm console.log(‘cb1’) vào trong Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*hpyVeL1zsaeHaqS7mU4Qfw.png" alt=""></li><li>console.log(‘cb1’) được thực thi. <img src="https://cdn-images-1.medium.com/max/1000/1*lvOtCg75ObmUTOxIS6anEQ.png" alt=""></li><li>console.log(‘cb1’) bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*Jyyot22aRkKMF3LN1bgE-w.png" alt=""></li><li>cb1 bị xóa khỏi Call Stack. <img src="https://cdn-images-1.medium.com/max/1000/1*t2Btfb_tBbBxTvyVgKX0Qg.png" alt=""></li></ol><p>Ảnh gif tổng hợp lại quá trình 16 bước ở trên:<br><img src="https://cdn-images-1.medium.com/max/1000/1*TozSrkk92l8ho6d8JxqF_w.gif" alt=""></p><p>Thật thú vị khi biết rằng ES6 có mô tả event loop hoạt động như thế nào, nghĩa là về mặt kỹ thuật, nó nằm trong phạm vi trách nghiệm của một JS engine, tức là không còn chỉ đóng vai trò môi trường chủ. Một lý do chính đáng cho sự thay đổi này chính là việc giới thiệu Promise trong ES6 bởi vì promise mới cần truy xuất trực tiếp, kiểm soát tối đa lịch trình điều hành đối với event loop queue (Sau này chúng ta sẽ thảo luận chi tiết hơn)</p><h1 id="setTimeout-…-hoat-dong-nhu-the-nao"><a href="#setTimeout-…-hoat-dong-nhu-the-nao" class="headerlink" title="setTimeout(…) hoạt động như thế nào?"></a>setTimeout(…) hoạt động như thế nào?</h1><p>Điều quan trọng cần phải biết là setTimeout(…) không tự động đặt callback vào trong event loop queue. Nó thiết lập một bộ đếm. Khi bộ đếm kết thúc, môi trường đặt callback vào trong event loop, vì thế những <strong>tick</strong> tiếp theo có thể lấy nó ra và thực thi:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(myCallback, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>Nó không có nghĩa là myCallback sẽ được thực thi sau 1000ms, mà đúng hơn là, trong 1000ms, myCallback sẽ được thêm vào trong queue. Tuy nhiên queue này có thể đang có event khác đã được thêm vào trước đó, và vì thế callback của bạn sẽ phải chờ.</p><p>Có một vài bài biết hoặc bài hướng dẫn dành cho người mới bắt đầu với bất đồng bộ trong JS hướng dẫn rằng ta nên setTimeout(callback, 0). Bây giờ bạn đã biết cách event loop làm việc và cách setTimeout hoạt động rồi: gọi setTimeout với thời gian là <strong>0</strong> chỉ vì mục đích hoãn callback lại cho tới khi Call Stack rỗng hoàn toàn.</p><p>Hãy xem ví dụ dưới đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callback'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Bye'</span>);</span><br></pre></td></tr></table></figure><p>Mặc dù thời gian chờ của callback là <em>0ms</em> nhưng kết quả in ra lại như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hi</span><br><span class="line">Bye</span><br><span class="line">callback</span><br></pre></td></tr></table></figure><h1 id="Jobs-cong-viec-trong-ES6-la-gi"><a href="#Jobs-cong-viec-trong-ES6-la-gi" class="headerlink" title="Jobs (công việc) trong ES6 là gì?"></a>Jobs (công việc) trong ES6 là gì?</h1><p>Một khái niệm mới gọi là <strong>Job Queue</strong> (Hàng đợi công việc) được giới thiệu trong ES6. Nó là lớp trên cùng của event loop queue. Nhiều khả năng bạn sẽ gặp phải nó khi xử lý vấn đề liên quan đến bất đồng bộ của Promise (Chúng ta sẽ nói về nó sau).</p><p>Bây giờ thì chúng ta chỉ tìm hiểu về mặt ý tưởng cơ bản để sau này khi thảo luận về bất đồng bộ với Promise, bạn có thể hiểu về những hành động đã được lên lịch và xử lý.</p><p>Tưởng tượng nó như thế này: Job queue là 1 queue được gắn vào cuối mỗi tick trong event loop queue. Mỗi hành động bất đồng bộ nhất định khi xảy ra trong 1 tick sẽ không làm cho toàn bộ event được thêm vào event loop queue nhưng thay vì thế sẽ thêm 1 item (tức là job) vào cuối job queue của tick hiện tại.</p><p>Điều này nghĩa là bạn có thể thêm những tính năng khác để có thể thực thi sau và bạn có thể chắc chắn rằng nó sẽ được thực thi ngay sau đó, trước bất kỳ đoạn code nào khác.</p><p>Một job có thể thêm nhiều job khác vào đoạn cuối của cùng 1 queue. Trên lý thuyết, job có thể lặp (loop) vô thời hạn (một job thực hiện thêm nhiều job khác, v..v…), do đó nó sẽ làm cho chương trình bị quá tải tài nguyên cần thiết để tiếp tục chạy. Về mặt khái niệm thì điều này tương tự như một công việc có thời gian thực thi dài hoặc là một vòng lặp vô hạn (ví dụ: while(true)).</p><p>Job cũng giống như trick setTimeout(callback, 0) (set thời gian bằng _0_) nhưng được triển khai theo cách có vẻ như “chính thống” hơn và có sự đảm bảo về thứ tự: thực hiện sau, nhưng phải làm ngay khi có thể.</p><h1 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h1><p>Như bạn đã biết, callback là cách phổ biến nhất để thể hiện &amp; quản lý sự bất đồng bộ trong JS. Rõ ràng, callback là mô hình bất đồng bộ cơ bản nhất trong JS. Vô số chương trình JS, kể cả những app tinh vi và phức tạp nhất thì cũng phải dùng tới callback.</p><p>Ngoại trừ việc callback không xuất hiện mà không có thiếu sót. Nhiều developer đang cố gắng tìm kiếm những mô hình bất đồng bộ tốt hơn. Tuy nhiên, chúng ta không thể sử dụng bất kỳ phương pháp thay thế nào khác nếu như bạn chưa thực sự hiểu rõ về callback.</p><p>Ở chương tiếp theo, chúng ta sẽ khám phá sâu hơn về vấn đề này để tìm hiểu tại sao những mô hình bất đồng bộ tinh vi khác (sẽ nói ở những bài sau) là cần thiết và được đề nghị nên sử dụng.</p><h1 id="Callback-long-nhau-nested-callback"><a href="#Callback-long-nhau-nested-callback" class="headerlink" title="Callback lồng nhau (nested callback)"></a>Callback lồng nhau (nested callback)</h1><p>Xem đoạn code dưới đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">listen(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ajax(<span class="string">'https://api.example.com/endpoint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">text</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (text == <span class="string">"hello"</span>) &#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">"world"</span>) &#123;</span><br><span class="line">            doSomethingElse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Chúng ta có 3 hàm lồng nhau, mỗi hàm thể hiện 1 bước trong chuỗi bất đồng bộ.</p><p>Kiểu code như thế này thường được gọi là <strong>callback hell</strong>. Nhưng <em>callback hell</em> thực sự không phải vấn đề về lồng nhau hay cách dòng, thụt lề. Câu chuyện thực sự sâu xa hơn thế nhiều.</p><p>Đầu tiên, chúng ta listen một event <em>click</em>, sau đó thì chờ timer hoạt động, rồi cuối cùng là chờ cho Ajax trả kết quả về và quá trình này có thể lặp lại nhiều lần mỗi khi chúng ta click.</p><p>Thoạt nhìn đoạn code này thể hiện sự đồng bộ một cách tự nhiên theo thứ tự các bước như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>…rồi sau đó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>…tiếp theo là:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'https://api.example.com/endpoint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>…và cuối cùng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (text == <span class="string">"hello"</span>) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">"world"</span>) &#123;</span><br><span class="line">    doSomethingElse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chà, đúng là một cách thể hiện code bất đồng bộ một cách rất tự nhiên, phải không nào? <em>cười</em></p><h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>Cùng xem đoạn code sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x + y);</span><br></pre></td></tr></table></figure><p>Rất rõ ràng rằng nó tính tổng của x và y rồi in kết quả ra console. Tuy nhiên, nếu như giá trị của x và y chưa tồn tại và vẫn còn đang chờ để được xác định thì sao? Giả sử chúng ta cần lấy giá trị của x và y từ server trước khi chúng được dùng để tính tổng.<br>Tưởng tượng rằng chúng ta có một hàm loadX và loadY để thực hiện load dữ liệu cho x và y từ server và một hàm để tính tổng 2 số sau khi chúng được load xong.<br>Đoạn code sẽ giống như thế này (xấu xí và phức tạp, phải không nào?):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">getX, getY, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x, y;</span><br><span class="line">    getX(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        x = result;</span><br><span class="line">        <span class="keyword">if</span> (y !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            callback(x + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    getY(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        y = result;</span><br><span class="line">        <span class="keyword">if</span> (x !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            callback(x + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Một hàm đồng bộ hoặc bất đồng bộ để get giá trị của "x"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Một hàm đồng bộ hoặc bất đồng bộ để get giá trị của "y"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchY</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line">sum(fetchX, fetchY, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Có một điều quan trọng cần phải nêu lên ở đây: trong đoạn code trên, chúng ta xem x và y như những giá trị tương lai và hàm sum() không quan tâm về việc x hay y hay cả 2 biến có hay không có tồn tại giá trị.</p><p>Dĩ nhiên là cách tiếp cận thô dựa trên callback này cho ta nhiều thứ đáng mong đợi. Đây chỉ là 1 bước tiến nhỏ để hiểu về ích lợi của <em>giá trị tương lai</em> mà không cần lo lắng về khía cạnh thời gian khi chúng sẵn có.</p><h1 id="Gia-tri-cua-Promise"><a href="#Gia-tri-cua-Promise" class="headerlink" title="Giá trị của Promise"></a>Giá trị của Promise</h1><p>Cùng xem ví dụ về x + y được thực hiện với Promise:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">xPromise, yPromise</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `Promise.all([ .. ])` nhận vào 1 mảng các promise,</span></span><br><span class="line">    <span class="comment">// và trả về 1 promise chờ đợi tất cả chúng hoàn thành</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([xPromise, yPromise])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// khi một promise được phân giải (resolve),</span></span><br><span class="line">    <span class="comment">// ta lấy giá trị x, y trả về và cộng chúng lại.</span></span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">values</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// `values` là mảng chứa giá trị của các object</span></span><br><span class="line">        <span class="comment">// từ những promise đã được resolve</span></span><br><span class="line">        <span class="keyword">return</span> values[<span class="number">0</span>] + values[<span class="number">1</span>];</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `fetchX()` và `fetchY()` trả về promise </span></span><br><span class="line"><span class="comment">// chứa kết quả tương ứng, có thể có </span></span><br><span class="line"><span class="comment">// luôn hoặc chờ sau mới có dữ liệu</span></span><br><span class="line">sum(fetchX(), fetchY())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ta có 1 promise cho tổng của 2 số.</span></span><br><span class="line"><span class="comment">// Giờ thì gọi mắt xích (chain-call) hàm `.then(...)` để chờ </span></span><br><span class="line"><span class="comment">// kết quả của promise trả về.</span></span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Có 2 lớp Promise trong đoạn code này.</p><p>fetchX() và fetchY() được gọi trực tiếp và giá trị trả về của chúng (<strong>promise!</strong>) được đẩy vào hàm sum(…). Giá trị mà những promise này thể hiện có thể sẵn sàng để dùng ngay lúc gọi hàm hoặc là sau đó 1 chút nhưng bất kể sớm hay muộn thì mỗi promise đều chuẩn hóa hành vi của nó cho giống nhau. Chúng ta suy đoán về giá trị của x và y theo hướng độc lập thời gian. Theo chu kỳ, chúng là những <em>giá trị tương lai</em>.</p><p>Lớp thứ 2 là promise do hàm sum(…) tạo ra (thông qua Promise.all([ … ])) và trả về, và cũng chờ nó get giá trị khi gọi .then(…). Khi hàm sum(…) hoàn tất, tổng <em>giá trị tương lai</em> đã sẵn sàng và có thể in nó ra. Chúng ta ẩn phần logic chờ <em>giá trị tương lai</em> của x và y trong hàm `sum(…).</p><p><strong>Lưu ý</strong>: <em>Bên trong sum(…), lời gọi đến Promise.all([ … ]) tạo một promise (cái này sẽ gọi đến xPromise và yPromise rồi phân giải chúng). Chain-call đến .then() sẽ tạo ra 1 promise khác và promise này sẽ trả về values[0] + values[1] ngay khi resolve (với giá trị kết quả của phép cộng). Do đó lời gọi .then(…) ta đặt ở cuối hàm .sum(…), tức là cuối đoạn code, thực ra là xử lý trên giá trị trả về của promise thứ 2 hơn là promise thứ nhất được tạo ra bởi Promise.all([ … ]). Mặc dù vậy thì chúng ta không chain-call vào cuối hàm .then(…) sau vì làm vậy sẽ tạo thêm 1 promise và ta lại phải xử lý nó. Phần Promise chain-call này sẽ được giải thích kỹ hơn ở các phần sau trong chương này.</em></p><p>Với Promise, lời gọi .then(…) có thể nhận 2 hàm param, hàm thứ nhất là để thực hiện thao tác với response hoàn thành (như trên), hàm thứ 2 là với trường hợp bị lỗi và bác bỏ (rejection).</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sum(fetchX(), fetchY())</span><br><span class="line">.then(</span><br><span class="line">    <span class="comment">// Hàm xử lý hoàn thành</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( sum );</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Hàm xử lý bác bỏ</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error( err ); <span class="comment">// bummer!</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Nếu có gì đó không đúng trong quá trình get x và y hoặc là có sai sót khác thì promise mà .sum(…) trả về sẽ bị reject, hàm callback thứ 2 xử lý lỗi đã được đẩy vào .then(…) sẽ nhận giá trị reject từ promise.</p><p>Bởi vì promise đóng gói trạng thái độc lập thời gian từ bên ngoài - chờ cho giá trị được xử lý hoàn thành/reject, và bản thân promise đã là độc lập thời gian, do đó nhiều promise có thể được kết hợp với nhau theo những cách có thể đoán trước được bất kể là thời gian hay kết quả.</p><p>Hơn nữa, một khi promise được resolve thì nó sẽ tồn tại vĩnh viễn: nó trở thành một giá trị <strong>bất biến</strong> tại thời điểm đó, và có thể được lấy ra sử dụng bao nhiêu lần cũng được</p><p>Thực sự là rất hữu ích khi ta nối promise thanhf 1 chuỗi:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        setTimeout(resolve, time);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"after 1000ms"</span>);</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"after another 2000ms"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"step 4 (next Job)"</span>);</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">5000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>Gọi hàm delay(2000) sẽ tạo ra 1 promise mà nó được hoàn thành trong 2000ms, sau đó trả nó về từ hàm hoàn thành trong .then() đầu tiên, điều này làm cho hàm .then(…) thứ hai sẽ chờ 2000ms</p><p><strong>Lưu ý</strong>: <em>Bởi vì giá promise là bất biến sau khi đã được resolve, chúng ta có thể truyền nó đi khắp nơi mà không cần lo lắng về việc nó bất ngờ bị thay đổi. Điều này đặc biệt có ích khi có nhiều đoạn code cùng sử dụng kết quả của 1 promise. Tính bất biến nghe có vẻ như là một chủ đề liên quan đến học thuật, nhưng thật ra nó là 1 phần rất cơ bản và có khía cạnh quan trọng trong thiết kế promise mà ta không nên bỏ qua.</em></p><h1 id="Promise-hay-khong-Promise"><a href="#Promise-hay-khong-Promise" class="headerlink" title="Promise hay không Promise ?"></a>Promise hay không Promise ?</h1><p>Một chi tiết quan trọng về promise là phải biết một giá trị thực sự là promise hay không phải. Nói cách khác, đó có phải là 1 giá trị sẽ hành xử như 1 promise?</p><p>Chúng ta biết rằng promise được xây dựng bằng lệnh new Promise(…), và bạn cho rằng p instanceof Promise là đủ để kiểm tra? Thực ra thì không hẳn.</p><p>Chủ yếu bởi vì bạn có thể nhận giá trị promise từ một cửa sổ trình duyệt khác (ví dụ: iframe), nó sẽ có promise riêng của nó, khác với promise trong cửa sổ/frame hiện tại của bạn, và câu lệnh check ở trên sẽ fail khi xác định instance của promise.</p><p>Hơn nữa, một thư viện hay framework có thể sử dụng promise của riêng nó mà không dùng promise mặc định của ES6. Thật ra, bạn có thể dùng promise của thư viện trên những trình duyệt cũ không hỗ trợ promise.</p><h1 id="Nuot-chung-ngoai-le-exception"><a href="#Nuot-chung-ngoai-le-exception" class="headerlink" title="Nuốt chửng ngoại lệ (exception)"></a>Nuốt chửng ngoại lệ (exception)</h1><p>Nếu trong quá trình tạo promise hoặc là khi tiếp nhận kết quả từ nó, một lỗi biệt lệ JS xảy ra, ví dụ như TypeError hoặc ReferenceError, exception sẽ được bắt, khi đó nó sẽ ép (force) cho promise đang chạy bị reject.</p><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    foo.bar();    <span class="comment">// `foo` chưa được định nghĩa, lỗi!</span></span><br><span class="line">    resolve(<span class="number">374</span>); <span class="comment">// Code sẽ không đến được đây :(</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// không đến đây luôn :(</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// `err` sẽ là một object của exception`TypeError`</span></span><br><span class="line">    <span class="comment">// từ dòng `foo.bar()`.</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Nhưng nếu như một promise được hoàn thành nhưng có lỗi exception JS trong quá trình tiếp nhận (ví dụ như trong callback của .then(…) )? Kể cả như thế thì nó cũng không bị mất, bạn sẽ thấy một chút ngạc nhiên khi biết cách mà chúng được xử lý. Đào sâu thêm 1 tí nào:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">374</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    foo.bar();</span><br><span class="line">    <span class="built_in">console</span>.log(message);   <span class="comment">// không đến được đây nè.</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// không đến được đây nè.</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Có vẻ như exception từ foo.bar() thực sự đã bị nuốt trôi (swallow). Đúng là như thế. Có gì đó sâu hơn bên trong đã hoạt động sai tuy nhiên chúng ta lại không biết. Lời gọi p.then(…) cho chính nó trả về 1 promise khác và nó sẽ bị reject với ReferenceError exception.</p><h1 id="Xu-ly-nhung-biet-le-khong-bi-bat-Uncaught-exception"><a href="#Xu-ly-nhung-biet-le-khong-bi-bat-Uncaught-exception" class="headerlink" title="Xử lý những biệt lệ không bị bắt (Uncaught exception)"></a>Xử lý những biệt lệ không bị bắt (Uncaught exception)</h1><p>Có nhiều cách tiếp cận khác mà nhiều người cho rằng sẽ tốt hơn.</p><p>Một đề nghị phổ biến đó là promise nên có thêm một phương thức done(…), nó sẽ đánh dấu chuỗi promise là đã xong (done). .done(…)không tạo ra và trả về một promise vì thế callback truyền qua .done(…) rõ ràng là không liên quan đến việc báo cáo các vấn đề xảy ra với một chuỗi promise không tồn tại.</p><p>Nó hoạt động giống như bạn đã biết trong các điều kiện uncaught error: các exception bên trong một hàm reject trong .done(…) sẽ bị bắn ra ngoài developer console dưới dạng global uncaught error.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">374</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// Số number không có hàm của string,</span></span><br><span class="line">    <span class="comment">// nên sẽ bắn ra lỗi</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg.toLowerCase());</span><br><span class="line">&#125;)</span><br><span class="line">.done(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Nếu có uncaught exception ở đây thì nó sẽ bị bắn ra như là một global exception</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Dieu-gi-xay-ra-trong-ES8-va-Async-await"><a href="#Dieu-gi-xay-ra-trong-ES8-va-Async-await" class="headerlink" title="Điều gì xảy ra trong ES8 và Async/await"></a>Điều gì xảy ra trong ES8 và Async/await</h1><p>Javascript ES8 giới thiệu async/await để giúp cho công việc xử lý promise dễ dàng hơn. Chúng ta sẽ lướt sơ qua những khả năng mà async/await cung cấp và xem thử làm thế nào để dùng chúng để viết code bất đồng bộ một cách phù hợp.</p><p>Vậy thì đầu tiên là xem thử hoạt động của async/await.</p><p>Bạn định nghĩa một hàm bất đồng bộ sử dụng định nghĩa hàm async. Những hàm như vậy sẽ trả về object <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank" rel="noopener">AsyncFunction</a>. Object AsyncFunction biểu diễn hàm bất đồng bộ trong đó nó thực thi code bên trong nó.</p><p>Khi một hàm async được gọi, nó sẽ trả về Promise. Khi hàm async trả về giá trị, nó lại không phải promise, một promise sẽ được tạo ra tự động và được phân giải (resolve) với giá trị trả về từ hàm. Khi hàm async bắn ra exception, promise sẽ reject với giá trị bắn ra.</p><p>Một hàm async có thể chứa thể hiện await, nó sẽ dừng quá trình thực thi của hàm và đợi cho promise giải quyết xong rồi quay lại thực thi tiếp và trả về giá trị đã được resolve.</p><p>Bạn có thể xem như promise trong JS tương tự với Java Future hay C# Task.</p><blockquote><p>Mục đích của async/await là làm đơn giản hóa quá trình sử dụng promise.</p></blockquote><p>Xem ví dụ sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hàm JS bình thường</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'374'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Giống như hàm trên</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getNumber2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">374</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tương tự, những hàm bắn ra exception tương tự với những hàm trả về promise bị reject:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'Some error'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'Some error'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Từ khóa await chỉ có thể được dùng bên trong hàm async và cho phép bạn chờ promise một cách đồng bộ. Nếu chúng ta sử dụng promise bên ngoài một hàm async thì phải dùng tới callback:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `rp` là một hàm gọi promise.</span></span><br><span class="line">    <span class="keyword">var</span> promise1 = rp(<span class="string">'https://api.example.com/endpoint1'</span>);</span><br><span class="line">    <span class="keyword">var</span> promise2 = rp(<span class="string">'https://api.example.com/endpoint2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hiện tại cả 2 request đều được gọi đồng thời và</span></span><br><span class="line">    <span class="comment">// ta phải đợi cho nó hoàn thành.</span></span><br><span class="line">    <span class="keyword">var</span> response1 = <span class="keyword">await</span> promise1;</span><br><span class="line">    <span class="keyword">var</span> response2 = <span class="keyword">await</span> promise2;</span><br><span class="line">    <span class="keyword">return</span> response1 + <span class="string">' '</span> + response2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bởi vì ta không ở trong hàm `async` </span></span><br><span class="line"><span class="comment">// nên chúng ta phải dùng `then()`.</span></span><br><span class="line">loadData().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Done'</span>));</span><br></pre></td></tr></table></figure><p>Bạn có thể định nghĩa hàm async bằng cách sử dụng async function expression (AFE - Thể hiện hàm async). Một AFE tương tự và gần giống như một async function statement (AFS). Điểm khác biệt chính giữa AFE và AFS là tên của hàm, trong AFE ta có thể bỏ qua tên để tạo hàm vô danh (anonymous function). Một AFE có thể sử dụng như một IIFE (<a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" target="_blank" rel="noopener">Immediately Invoked Function Expression</a>), loại hàm được thực thi ngay sau khi nó được định nghĩa.</p><p>Nó trông như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadData = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `rp` là một hàm gọi promise.</span></span><br><span class="line">    <span class="keyword">var</span> promise1 = rp(<span class="string">'https://api.example.com/endpoint1'</span>);</span><br><span class="line">    <span class="keyword">var</span> promise2 = rp(<span class="string">'https://api.example.com/endpoint2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hiện tại cả 2 request đều được gọi đồng thời và</span></span><br><span class="line">    <span class="comment">// ta phải đợi cho nó hoàn thành.</span></span><br><span class="line">    <span class="keyword">var</span> response1 = <span class="keyword">await</span> promise1;</span><br><span class="line">    <span class="keyword">var</span> response2 = <span class="keyword">await</span> promise2;</span><br><span class="line">    <span class="keyword">return</span> response1 + <span class="string">' '</span> + response2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Quan trọng là async/await được hỗ trợ và có thể chạy trên đa số các trình duyệt:</p><p> <a href="https://cdn-images-1.medium.com/max/1000/0*z-A-JIe5OWFtgyd2." target="_blank" rel="noopener"><img src="https://cdn-images-1.medium.com/max/1000/0*z-A-JIe5OWFtgyd2." alt=""></a> <a></a></p><p>Nếu như trình duyệt nào không hỗ trợ thì ta vẫn có thể sử dụng các JS transpiler như <a href="https://babeljs.io/docs/plugins/transform-async-to-generator/" target="_blank" rel="noopener">Babel</a> hay <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html" target="_blank" rel="noopener">TypeScript</a></p><p>Cuối cùng thì điều quan trọng nhất là không nên chọn lựa một cách mù quáng những cách tiếp cận “mới nhất” để viết code bất đồng bộ. Tốt hơn là bạn hiểu về cấu trúc bất đồng bộ của JS, nghiên cứu tại sao nó lại là một vấn đề nghiêm túc và hiểu một cách sâu sắc về các thành phần bên trong của giải pháp mà bạn lựa chọn. Mỗi cách tiếp cận khác nhau đều có những điểm mạnh và điểm yếu, hãy cân nhắc.</p><h1 id="5-meo-de-viet-code-bat-dong-bo-vua-chac-chan-vua-de-bao-tri"><a href="#5-meo-de-viet-code-bat-dong-bo-vua-chac-chan-vua-de-bao-tri" class="headerlink" title="5 mẹo để viết code bất đồng bộ vừa chắc chắn vừa dễ bảo trì"></a>5 mẹo để viết code bất đồng bộ vừa chắc chắn vừa dễ bảo trì</h1><h3 id="1-Clean-code-code-sach"><a href="#1-Clean-code-code-sach" class="headerlink" title="1. Clean code (code sạch):"></a>1. <strong>Clean code (code sạch)</strong>:</h3><p>Sử dụng async/await cho phép bạn viết code ít hơn nhiều. Mỗi lần sử dụng async/await bạn có thể bỏ qua một số bước không cần thiết, ví dụ: .then(), viết hàm anonymous để xử lý responsive, đặt tên response từ callback…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `rp` là một hàm gọi promise</span></span><br><span class="line">rp(‘https:<span class="comment">//api.example.com/endpoint1').then(function(data) &#123;</span></span><br><span class="line"> <span class="comment">// …</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>…so với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `rp` là một hàm gọi promise</span></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> rp(‘https:<span class="comment">//api.example.com/endpoint1');</span></span><br></pre></td></tr></table></figure><h3 id="2-Xu-ly-loi"><a href="#2-Xu-ly-loi" class="headerlink" title="2. Xử lý lỗi:"></a>2. <strong>Xử lý lỗi</strong>:</h3><p>Async/await giúp chúng ta có thể xử lý cả lỗi đồng bộ và bất đồng bộ với cùng một cấu trúc code: chính là try/catch nổi tiếng. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// Catches synchronous errors.</span></span><br><span class="line">        getJSON().then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> parsed = <span class="built_in">JSON</span>.parse(response);</span><br><span class="line">            <span class="built_in">console</span>.log(parsed);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// Catches asynchronous errors</span></span><br><span class="line">            <span class="built_in">console</span>.log(e); </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…so với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">await</span> getJSON());</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Dieu-kien"><a href="#3-Dieu-kien" class="headerlink" title="3. Điều kiện:"></a>3. <strong>Điều kiện</strong>:</h3><p>Viết code điều kiện với async/await rõ ràng hơn rất nhiều:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response.needsAnotherRequest) &#123;</span><br><span class="line">        <span class="keyword">return</span> makeAnotherRequest(response)</span><br><span class="line">          .then(<span class="function"><span class="keyword">function</span>(<span class="params">anotherResponse</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(anotherResponse)</span><br><span class="line">            <span class="keyword">return</span> anotherResponse</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…so với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> response = <span class="keyword">await</span> getJSON();</span><br><span class="line">  <span class="keyword">if</span> (response.needsAnotherRequest) &#123;</span><br><span class="line">    <span class="keyword">var</span> anotherResponse = <span class="keyword">await</span> makeAnotherRequest(response);</span><br><span class="line">    <span class="built_in">console</span>.log(anotherResponse)</span><br><span class="line">    <span class="keyword">return</span> anotherResponse</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="keyword">return</span> response;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Stack-Frames"><a href="#4-Stack-Frames" class="headerlink" title="4. Stack Frames:"></a>4. <strong>Stack Frames</strong>:</h3><p>Không giống như async/await, stack lỗi trả về từ một chuỗi promise làm chúng ta không biết lỗi xuất phát từ đâu mà lần:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> callAPromise()</span><br><span class="line">    .then(callback1)</span><br><span class="line">    .then(callback2)</span><br><span class="line">    .then(callback3)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"boom"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">loadData()</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line"><span class="comment">// Error: boom at callAPromise.then.then.then.then (index.js:8:13)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>…so với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> callAPromise1()</span><br><span class="line">  <span class="keyword">await</span> callAPromise2()</span><br><span class="line">  <span class="keyword">await</span> callAPromise3()</span><br><span class="line">  <span class="keyword">await</span> callAPromise4()</span><br><span class="line">  <span class="keyword">await</span> callAPromise5()</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"boom"</span>);</span><br><span class="line">&#125;</span><br><span class="line">loadData()</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="comment">// Error: boom at loadData (index.js:7:9)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-Qua-trinh-Debug"><a href="#5-Qua-trinh-Debug" class="headerlink" title="5. Quá trình Debug:"></a>5. <strong>Quá trình Debug</strong>:</h3><p>Nếu bạn đã từng sử dụng promise, bạn sẽ biết rằng debug với chúng thực sự là ác mộng. Giả sử bạn đặt breakpoint bên trong .then() và dùng những lệnh debug như stop-over, debugger sẽ không đi đến .then() tiếp theo bởi vì nó “lỡ chân” bước vào code bất đồng bộ.<br>Với async/await bạn có thể duyệt qua những lời gọi await chính xác như những hàm đồng bộ thông thường.</p><p><strong>Viết code Javascript bất đồng bộ là rất quan trọng không chỉ cho app mà cả cho những thư viện nữa</strong>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chào các bạn đến với bài thứ 4 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.&lt;/p&gt;
&lt;p&gt;Lần này chúng ta sẽ mở rộng những gì có trong bài đầu tiên bằng cách đánh giá những nhược điểm của môi trường đơn luồng (single thread) và làm thế nào để vượt qua chúng nhằm xây dựng những Javascript UI ấn tượng. Và vẫn như cũ, cuối bài viết tác giả sẽ chia sẻ 5 mẹo nhỏ để viết code tốt hơn với async/await.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P3: Quản lý bộ nhớ &amp; 4 trường hợp memory leaks phổ biến</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P3-Quan-ly-bo-nho-4-truong-hop-memory-leaks-pho-bien.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P3-Quan-ly-bo-nho-4-truong-hop-memory-leaks-pho-bien.html</id>
    <published>2018-11-13T16:03:00.000Z</published>
    <updated>2018-11-13T16:05:48.137Z</updated>
    
    <content type="html"><![CDATA[<p>Mấy hôm trước chúng ta đã bắt đầu series bài viết đục khoét về Javascript và cách nó hoạt động như thế nào, bằng cách hiểu về những thành phần cơ bản và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và <em>ngon</em> hơn.</p><p>Bài đầu tiên là tổng quan về series, cung cấp cái nhìn toàn cảnh về engine, runtime &amp; callstack. Bài thứ 2 là một cái nhìn cụ thể hơn về những thành phần bên trong của bộ engine V8 của Google và một số mẹo vặt để tối ưu Javascript code.</p><p>Ở bài thứ 3 này, chúng ta sẽ thảo luận về một vấn đề không kém phần quan trọng nhưng lại thường bị các dev bỏ qua do sự phức tạp ngày càng gia tăng của các ngôn ngữ lập trình thường dùng: quản lý bộ nhớ. Chúng ta cũng sẽ tìm hiểu một số mẹo để có thể xử lý những trường hợp rò rì bộ nhớ của Javascript mà team SesstionStack đã áp dụng để tránh bị rò rỉ và không làm tốn bộ nhớ của webapp.<br><a id="more"></a></p><h1 id="Tong-quan"><a href="#Tong-quan" class="headerlink" title="Tổng quan"></a>Tổng quan</h1><p>Những ngôn ngữ như C có bộ quản lý bộ nhớ level thấp khá cơ bản là malloc() và free(). Những phương thức này được sử dụng để cấp phát một cách tường minh và giải phóng bộ nhớ trên hệ điều hành.</p><p>Một cách tương tự, Javascript cấp phát bộ nhớ khi object, string, … được tạo ra và <em>tự động</em> giải phóng nó mỗi khi không được sử dụng nữa bởi một tiến trình dọn rác (garbage collection). Quá trình giải phóng tài nguyên một cách <em>tự động hóa</em> như thế này gây ra sự nhầm lẫn và làm cho Javascript (và những ngôn ngữ bậc cao khác) developer cảm thấy “ấn tượng” nên họ thường bỏ qua vấn đề quản lý bộ nhớ. <strong>Đây là một sai lầm lớn.</strong></p><p>Kể cả khi làm việc với ngôn ngữ bậc cao, developer cũng nên hiểu về vấn đề quản lý bộ nhớ (ít nhất là những thứ cơ bản). Thỉnh thoảng có những vấn đề xảy ra với quản lý bộ nhớ tự động (bug hay sự giới hạn thực hiện trong GC…) mà developer cần phần hiểu để có thể xử lý một cách đúng đắn (hoặc tìm cách “đi đường vòng” vượt qua nó với ít thiệt hại nhất).</p><h1 id="Vong-doi-cua-bo-nho"><a href="#Vong-doi-cua-bo-nho" class="headerlink" title="Vòng đời của bộ nhớ"></a>Vòng đời của bộ nhớ</h1><p>Dù cho bạn đang dùng ngôn ngữ lập trình nào đi nữa thì vòng đời bộ nhớ hầu như đều giống nhau:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*slxXgq_TO38TgtoKpWa_jQ.png" alt=""></p><p>Đây là những gì xảy ra ở mỗi bước trong vòng đời:</p><ul><li><p><strong>Cấp phát bộ nhớ</strong>: bộ nhớ được cấp phát bởi hệ điều hành và cho phép chương trình sử dụng nó. Ở ngôn ngữ bậc thấp (như C), đây là một quá trình tường minh, rõ ràng mà developer phải xử lý. Trong các ngôn ngữ bậc cao thì phần này ngôn ngữ sẽ làm giúp bạn.</p></li><li><p><strong>Sử dụng bộ nhớ</strong>: Đây là thời điểm khi chương tình của bạn sử dụng những vùng nhớ đã được cấp phát trước đó. Các thao tác Đọc và Ghi được thực hiện khi chúng ta thực thi những biến đã được khai báo trong code.</p></li><li><p><strong>Giải phóng bộ nhớ</strong>: Giờ là lúc giải phóng toàn bộ những vùng nhớ mà bạn không còn dùng đến nữa để sử dụng lại về sau. Giống như phần cấp phát, bước này được thực hiện một cách tường minh trong các ngôn ngữ bậc thấp.</p></li></ul><p>Để hiểu thêm về các khái niệm của callstack và heap thì mời bạn xem lại <a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-1---Khai-quat-ve-engine--runtime-va-callstack" target="_blank" rel="noopener">Phần 1</a> của series.</p><h1 id="Bo-nho-la-gi"><a href="#Bo-nho-la-gi" class="headerlink" title="Bộ nhớ là gì?"></a>Bộ nhớ là gì?</h1><p>Trước khi đi sâu vào bộ nhớ của Javascript, chúng ta sẽ duyệt sơ qua bộ nhớ cơ bản và cách hoạt động của nó.</p><p>Ở phần cứng, bộ nhớ máy tính bao gồm một cơ số các <a href="https://vi.wikipedia.org/wiki/Flip-flop" target="_blank" rel="noopener">flip flops</a> (đại khái là 1 trạng thái đóng-mở). Mỗi flip-flop chứa một vài transistor và có thể lưu trữ 1 bit thông tin. Một flip-flop độc lập có thể được truy xuất bằng số định danh duy nhất (<strong>unique identifier</strong>), do đó chúng ta có thể đọc và ghi lên chúng. Và lẽ dĩ nhiên, về mặt ý tưởng chúng ta có thể công nhận rằng toàn bộ bộ nhớ máy tính là 1 mảng khổng lồ các bit có thể đọc &amp; ghi.</p><p>Về phần con người thì họ không giỏi làm việc với bit nên tổ chức chúng vào những nhóm lớn hơn, 8 bit thành 1 byte. Ngoài byte còn có word (16 hoặc 32 bit)</p><p>Có rất nhiều thứ được lưu trữ trong bộ nhớ:</p><ol><li>Tất cả các biến và dữ liệu được sử dụng trong các chương trình.</li><li>Code của chương trình chạy, kể cả code của hệ điều hành.</li></ol><p>Trình biên dịch và hệ điều hành làm việc với nhau để xử lý hầu như toàn bộ phần quản lý bộ nhớ nhưng chúng tôi khuyến cáo bạn nên có cái nhìn sơ lược về những gì xảy ra ở nội bộ bên trong.</p><p>Khi biên dịch code, trình biên dịch sẽ xem xét các kiểu dữ liệu nguyên thủy (string, number, boolean…) và tính toán trước bao nhiêu bộ nhớ mà chúng cần sử dụng. Lượng bộ nhớ cần thiết sau đó sẽ được cấp phát cho chương tình trong không gian callstack. Vùng không gian được cấp phát được gọi là stack space bởi vì khi gọi hàm, bộ nhớ của nó được thêm vào vị trí trên cùng của bộ nhớ hiện tại. Và khi hủy bỏ, chúng bị gỡ bỏ theo quy tắc LIFO (last-in-first-out, vào sau ra trước). Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n; <span class="comment">// 4 bytes</span></span><br><span class="line">int x[<span class="number">4</span>]; <span class="comment">// mảng 4 phần tử, mỗi phần tử 4 bytes</span></span><br><span class="line">double m; <span class="comment">// 8 bytes</span></span><br></pre></td></tr></table></figure><p>Trình biên dịch sẽ tính toán ngay lập tức đoạn code này cần 4 + 4 * 4 + 8 = 28 bytes</p><blockquote><p>Đó là cách hoạt động của kích thước vùng nhớ cho kiểu số integer và double. Khoảng 20 năm trước, integer là 2 byte và double là 4 byte. Code của bạn không phải phụ thuộc vào kích thước của các kiểu dữ liệu cơ bản.</p></blockquote><p>Trình biên dịch sẽ chèn code tương tác với hệ điều hành để yêu cầu số lượng byte cần thiết để lưu trữ các biến.</p><p>Trong ví dụ trên, trình biên dịch biết chính xác bao nhiêu bộ nhớ cần thiết cho mỗi biến. Thực tế thì mỗi khi ghi dữ liệu vào biến n, nó sẽ được dịch nội bộ thành mộ thứ đại loại như “địa chỉ vùng nhớ 4127963”</p><p>Để ý rằng nếu ta thử truy xuất x[4] thì ta sẽ truy xuất nhầm sang dữ liệu đang liên kết với m. Bởi vì chúng ta đang cố truy xuất vào một phần tử không tồn tại trong mảng: 4 byte này nằm ngoài vùng x[3] vốn là vùng nhớ được cấp phát cuối cùng của mảng (index đánh từ 0 :v), và vậy là có thể ta đọc/ghi nhầm sang các bit của biến m. Điều này có thể gây ra nhiều hậu quả không mong muốn cho toàn bộ chương trình. Xem hình cho rõ hơn nhé:</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*5aBou4onl1B8xlgwoGTDOg.png" alt=""></p><p>Khi một hàm gọi một hàm khác thì mỗi hàm sẽ chiếm một phần của stack. Phần đó sẽ lưu giữ tất cả những biến cục bộ cũng như một bộ đếm để ghi nhớ vị trí mà quá trình thực thi của hàm dừng lại. Khi hàm kết thúc thì vùng bộ nhớ lại được giải phóng cho thằng khác dùng.</p><h1 id="Cap-phat-dong"><a href="#Cap-phat-dong" class="headerlink" title="Cấp phát động"></a>Cấp phát động</h1><p>Thật không may là mọi thứ dường như không dễ như ta tưởng khi mà ta không biết bao nhiêu bộ nhớ 1 biến có thể cần tại thời điểm thực thi. Giả sử chúng ta muốn làm như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n = readInput(); <span class="comment">// đọc input từ người dùng</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// tạo 1 mảng với "n" phần tử</span></span><br></pre></td></tr></table></figure><p>Tại thời điểm biên dịch, trình biên dịch không biết mảng sẽ cần bao nhiêu bộ nhớ bởi vì nó được xác định bởi dữ liệu nhập vào từ phía người dùng.</p><p>Vì thế nó không thể cấp phát vùng nhớ cho biến trên stack. Thay vì thế, chương trình của chúng ta cần hỏi hệ điều hành về kích thước bộ nhớ phù hợp trong khi thực thi (run-time). Vùng nhớ này được gán từ không gian <em>heap</em>. Sự khác biệt giữa cấp phát bộ nhớ động và tĩnh được tổng kết trong bảng sau:</p><table><thead><tr><th>Cấp phát tĩnh</th><th>Cấp phát động</th></tr></thead><tbody><tr><td>Biết kích thước tại thời điểm biên dịch.</td><td>Không biết kích thức lúc biên dịch</td></tr><tr><td>Thực hiện lúc biên dịch</td><td>Thực hiện lúc thực thi (runtime)</td></tr><tr><td>Gán vào stack</td><td>Gán vào heap</td></tr><tr><td>Gán theo thứ tự FILO (first-in-last-out)</td><td>Gán không theo thứ tự cụ thể nào cả</td></tr></tbody></table><p>Để có thể có cái nhìn sâu sắc về cấp phát bộ nhớ động, có thể chúng ta cần dành thêm thời gian tìm hiểu về <strong>con trỏ</strong>, nhưng như vậy thì hơi bị lạc đề. Nếu bạn thấy có hứng thú với chủ đề này thì xin lỗi phải hẹn bạn trong 1 bài viết khác rồi.</p><h1 id="Cap-phat-trong-Javascript"><a href="#Cap-phat-trong-Javascript" class="headerlink" title="Cấp phát trong Javascript"></a>Cấp phát trong Javascript</h1><p>Javascript giúp developer giảm bớt trách nhiệm trong việc cấp phát bộ nhớ. JS tự làm hết mọi thứ.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">374</span>; <span class="comment">// cấp phát bộ nhớ cho số</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'sessionstack'</span>; <span class="comment">// cấp phát cho string </span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// cấp phát cho object và các thuộc tính của nó</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">'str'</span>];  <span class="comment">// (giống như object) cấp phát cho</span></span><br><span class="line">                           <span class="comment">// mảng và các giá tị của nó</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">3</span>;</span><br><span class="line">&#125; <span class="comment">// cấp phát cho hàm (là 1 object có thể thực thi)</span></span><br><span class="line"><span class="comment">// function expressions cũng cấp phát object</span></span><br><span class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>Một vài lời gọi hàm cũng trả về dạng cấp phát object:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// cấp phát Date object</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">// cấp phát 1 phần tử DOM</span></span><br></pre></td></tr></table></figure><p>Phương thức có thể cấp phát giá trị hoặc object:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'sessionstack'</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substr(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 là 1 string mới</span></span><br><span class="line"><span class="comment">// Bởi vì string là bất biến, </span></span><br><span class="line"><span class="comment">// JavaScript có thể chọn không cấp phát bộ nhớ</span></span><br><span class="line"><span class="comment">// mà lưu trữ phạm vi [0, 3]</span></span><br><span class="line"><span class="keyword">var</span> a1 = [<span class="string">'str1'</span>, <span class="string">'str2'</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="string">'str3'</span>, <span class="string">'str4'</span>];</span><br><span class="line"><span class="keyword">var</span> a3 = a1.concat(a2); </span><br><span class="line"><span class="comment">// mảng mới gồm 4 phần tử là</span></span><br><span class="line"><span class="comment">// sự kết hợp của mảng a1 và a2</span></span><br></pre></td></tr></table></figure><h1 id="Su-dung-bo-nho-trong-Javascript"><a href="#Su-dung-bo-nho-trong-Javascript" class="headerlink" title="Sử dụng bộ nhớ trong Javascript"></a>Sử dụng bộ nhớ trong Javascript</h1><p>Sử dụng bộ nhớ đã được cấp phát trong Javascript có thể gói gọn một cách đơn giản trong 2 chữ <strong>đọc/ghi</strong></p><p>Việc này có thể thực hiện bằng cách đọc/ghi giá trị của biến hoặc thuộc tính của object hoặc truyền đối số (argument) vào 1 hàm.</p><h1 id="Giai-phong-khi-khong-dung-bo-nho-nua"><a href="#Giai-phong-khi-khong-dung-bo-nho-nua" class="headerlink" title="Giải phóng khi không dùng bộ nhớ nữa"></a>Giải phóng khi không dùng bộ nhớ nữa</h1><p>Đa số các phần đề về quản lý bộ nhớ xảy ra ở giai đoạn này.</p><p>Công việc khó nhất ở đây là tìm hiểu khi nào bộ nhớ đã được cấp phát có còn được sử dụng hay không. Thường thì nó yêu cầu developer xác định vùng nhớ nào trong chương trình không dùng nữa và giải phóng nó.</p><p>Ngôn ngữ bậc cao thêm vào 1 chương tình gọi là bộ dọn rác (garbage collector - GC) thực hiện công việc đi tìm những vùng nhớ đã được cấp phát và tìm hiểu xem nó còn được sử dụng hay không, nếu không dùng nữa thì sẽ tự động giải phóng nó.</p><p>Điều hơi chuối là tiến trình này chỉ tương đối đúng, bởi vì vấn đề tổng quát về việc xác định một vùng nhớ có còn được sử dụng hay không là bất khả thi (không thể thực hiện bằng thuật toán).</p><p>Đa số GC hoạt động bằng cách thu thập những vùng nhớ không còn bị truy xuất đến, ví dụ: tất cả biến đang trỏ đến nó đều đi ra khỏi phạm vi thực thi. Tuy nhiên, điều này cũng lại không hẳn là chính xác vì tại bất kỳ thời điểm nào một địa chỉ vùng nhớ đều có thể được trỏ tới bởi 1 biến, nhưng biến đó lại không bao giờ được sử dụng nữa.</p><h1 id="Qua-trinh-don-rac"><a href="#Qua-trinh-don-rac" class="headerlink" title="Quá trình dọn rác"></a>Quá trình dọn rác</h1><p>Rõ ràng cách thức để tìm được vùng nhớ “không còn dùng nữa” là bất khả thi cho nên GC thực hiện một giải pháp hạn chế cho vấn đề chung. Phần này sẽ giải thích những khái niệm cần thiết để bạn có thể hiểu được những thuật toán GC và các giới hạn của chúng.</p><h2 id="Tham-chieu-bo-nho"><a href="#Tham-chieu-bo-nho" class="headerlink" title="Tham chiếu bộ nhớ"></a>Tham chiếu bộ nhớ</h2><p>Ý tưởng chính của những thuật toán GC dựa trên <strong>tham chiếu</strong></p><p>Trong ngữ cảnh quản lý bộ nhớ, một object A tham chiếu đến object B khác nếu như A có truy xuất đến B (có thể tường minh hoặc không tường minh). Ví dụ: một Javascript object có tham chiếu đến prototype của chính nó (<strong>không tường minh</strong>) và tham chiếu đến giá trị của thuộc tính của nó (<strong>tường minh</strong>).</p><p>Trong trường hợp này, khái niệm của 1 “object” được mở rộng thành một thứ gì đó hơn là JS object thông thường và bao trùm cả function scope (hoặc là lexical scope toàn cục).</p><blockquote><p>Lexical scoping định nghĩa cách mà những tên biến được phân giải trong các hàm lồng nhau: những hàm con chưa scope của hàm cha kể cả khi hàm cha đã được return.</p></blockquote><h2 id="Bo-dem-tham-chieu"><a href="#Bo-dem-tham-chieu" class="headerlink" title="Bộ đếm tham chiếu"></a>Bộ đếm tham chiếu</h2><p>Đây là thuật toán dọn rác đơn giản nhất. Một object được đánh giá là “rác có thể dọn” nếu như không có tham chiếu nào trỏ đến nó.</p><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  o2: &#123;</span><br><span class="line">    x: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Tạo 2 object</span></span><br><span class="line"><span class="comment">// 'o1' tham chiếu đến 'o2' vì nó là 1 thuộc tính của 'o1'</span></span><br><span class="line"><span class="comment">// Hiện tại không có rác để dọn.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o3 = o1; <span class="comment">// biến 'o3' đang tham chiếu tới cùng 1 object với 'o1'</span></span><br><span class="line"></span><br><span class="line">o1 = <span class="number">1</span>;      <span class="comment">// giờ thì object được tham chiếu trước đó bởi 'o1'         </span></span><br><span class="line">            <span class="comment">// chỉ còn lại 1 tham chiếu duy nhất là 'o3'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o4 = o3.o2; <span class="comment">// tham chiếu đến thuộc tính 'o2'</span></span><br><span class="line">                <span class="comment">// object này giờ có 2 tham chiếu: </span></span><br><span class="line">                <span class="comment">// một là thuộc tính của 'o3': o3.o2</span></span><br><span class="line">                <span class="comment">// hai là biến 'o4'</span></span><br><span class="line"></span><br><span class="line">o3 = <span class="string">'374'</span>; <span class="comment">// Giờ thì object trước đây là của o1 không còn tham chiếu nữa.</span></span><br><span class="line">            <span class="comment">// Nó có thể bị dọn dẹp bởi GC </span></span><br><span class="line">            <span class="comment">// Tuy nhiên thuộc tính 'o2' của nó thì vẫn còn</span></span><br><span class="line">            <span class="comment">// được tham chiếu bởi biến 'o4' nên chưa bị dọn</span></span><br><span class="line"></span><br><span class="line">o4 = <span class="literal">null</span>; <span class="comment">// thuộc tính 'o2' trước đây trong 'o1' giờ</span></span><br><span class="line">           <span class="comment">// đã không còn gì tham chiếu đến nó</span></span><br><span class="line">           <span class="comment">// lần này thì GC có thể dọn nó được rồi.</span></span><br></pre></td></tr></table></figure><h2 id="Van-de-tu-tham-chieu-vong-tron"><a href="#Van-de-tu-tham-chieu-vong-tron" class="headerlink" title="Vấn đề từ tham chiếu vòng tròn"></a>Vấn đề từ tham chiếu vòng tròn</h2><p>Có một số giới hạn liên quan đến tham chiếu vòng tròn. Trong ví dụ sau, 2 object được tạo ra và được tham chiếu lẫn nhau, tạo thành 1 vòng tròn. Chúng sẽ được đẩy ra ngoài scope sau khi hàm kết thúc nên về mặt lý thuyết thì chúng vô dụng và có thể được giải phóng. Tuy nhiên, thuật toán đếm tham chiếu xem xét rằng mỗi object đều đang có ít nhất 1 tham chiếu đến object đó nên thuật toán sẽ bỏ qua mà không dọn dẹp.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o1.p = o2; <span class="comment">// o1 tham chiếu đến o2</span></span><br><span class="line">  o2.p = o1; <span class="comment">// o2 tham chiếu đến o1\. </span></span><br><span class="line">            <span class="comment">// 2 thanh niên này tạo thành 1 vòng tròn tham chiếu.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1000/1*GF3p99CQPZkX3UkgyVKSHw.png" alt=""></p><h2 id="Thuat-toan-Danh-dau-va-don-dep-Mark-and-sweep"><a href="#Thuat-toan-Danh-dau-va-don-dep-Mark-and-sweep" class="headerlink" title="Thuật toán Đánh dấu và dọn dẹp (Mark-and-sweep)"></a>Thuật toán Đánh dấu và dọn dẹp (Mark-and-sweep)</h2><p>Để xác định xem object có còn cần thiết không thì thuật toán này thử xem object đó có thể truy cập tới hay không.</p><p>Thuật toán <strong>Mark-and-sweep</strong> có 3 bước:</p><ol><li><strong>Roots</strong>: Nhìn chung, <em>roots</em> là những biến toàn cục (global) được tham chiếu đến trong code. Với Javascript, một biến toàn cục có vai trò như 1 <em>root</em> chính là object <strong>window</strong>. Trong Node.js thì nó gọi là <strong>global</strong>. Danh sách hoàn chỉnh các <em>roots</em> được xây dựng bởi GC.</li><li>Thuật toán sẽ điều tra tất cả các <em>roots</em> và con cháu (children) của nó rồi đánh dấu chúng là đang hoạt động (active) (nghĩa là, chúng không phải rác). Thứ gì mà không phải con cháu của root, root không truy xuất đến được thì đều bị coi là <em>rác</em>.</li><li>Cuối cùng, GC sẽ giải phóng các vùng nhớ không được đánh dấu <em>active</em> và trả bộ nhớ lại cho hệ điều hành.</li></ol><p><img src="https://cdn-images-1.medium.com/max/1000/1*WVtok3BV0NgU95mpxk9CNg.gif" alt=""></p><p>Thuật toán này tốt hơn thuật toán trước vì “đối tượng không có tham chiếu” dẫn tới trường hợp đối tượng không thể truy cập, ở hướng ngược lại thì nó giải quyết được vấn đề của tham chiếu vòng tròn.</p><p>Năm 2012, tất cả trình duyệt hiện đại đều tích hợp sẵn bộ GC Mark-and-sweep. Những cải tiến dành cho bộ Javascript GC (như GC Thế hệ (Generational)/ Gia tăng (Incremental)/ Đồng thời (Concurrent)/ Song song (Parallel)) trong những năm gần đây đều là những nâng cấp của thuật toán Mark-and-sweep, nhưng không phải là cải tiến thuật toán GC, cũng không phải quyết định xem 1 object có thể truy cập được hay là không.</p><p><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">Trong bài viết này</a>, bạn có thể tìm hiểu chi tiết hơn về quá trình truy tìm rác, nó cũng bao gồm luôn cả thuật toán Mark-and-sweep và cách tối ưu hóa của nó.</p><h2 id="Tham-chieu-vong-tron-chi-la-muoi"><a href="#Tham-chieu-vong-tron-chi-la-muoi" class="headerlink" title="Tham chiếu vòng tròn chỉ là muỗi"></a>Tham chiếu vòng tròn chỉ là muỗi</h2><p>Trong ví dụ đầu tiên, sau khi hàm được trả về, 2 object đều không được tham chiếu đến bởi một object có thể truy cập được từ đối tượng toàn cục. Một lẽ dĩ nhiên, thì chúng sẽ bị GC đánh dấu và dọn sạch sẽ.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*FbbOG9mcqWZtNajjDO6SaA.png" alt=""></p><p>Mặc dù giữa 2 object đều có tham chiếu lẫn nhau nhưng chúng không thể truy cập được từ <em>root</em></p><h2 id="Hanh-vi-phan-truc-quan-cua-GC"><a href="#Hanh-vi-phan-truc-quan-cua-GC" class="headerlink" title="Hành vi phản trực quan của GC"></a>Hành vi phản trực quan của GC</h2><p>Mặc dù GC rất tiện lợi nhưng chúng cũng đi kèm với những khuyết điểm. Một trong số đó là sự <em>không xác định được</em>. Nói cách khác, GC là không thể đoán trước được. Ta không thể biết rõ khi nào thì GC được thực thi. Có nghĩa là trong một vài trường hợp chương trình sử dụng nhiều bộ nhớ hơn số lượng mà chúng cần. Trong trường hợp khác, những thời điểm tạm dừng ngắn hạn (short-pauses) có thể đáng được chú ý trong một số ứng dụng đặc biệt nhạy cảm.<br>Mặc dù <em>không xác định được</em> nghĩa là không biết khi nào GC sẽ chạy, đa số GC đều dùng chung một mô hình thu thập trong quá trình cấp phát. Nếu như cấp phát không chạy, hầu như GC cũng không chạy. Cần cân nhắc trường hợp sau:</p><ol><li>Cấp phát một số lược bộ nhớ lớn.</li><li>Đa số các phần tử này (hoặc toàn bộ) đều được đánh dấu là không thể truy cập (Giả sử chúng ta vô hiệu hóa một tham chiếu đang trỏ đến bộ nhớ cache mà chúng ta không cần nữa.)</li><li>Không có cấp phát nào được thực thi nữa.</li></ol><p>Trong trường hợp này, đa số các GC sẽ không chạy bất kỳ một thu gom nào. Nói cách khác, mặc dù có những tham chiếu không thể truy cập được đang tồn tại nhưng chúng lại không được GC “để mắt” đến. Đây không phải là một loại rò rỉ nghiêm trọng nhưng dĩ nhiên nó vẫn sử dụng bộ nhớ nhiều hơn bình thường.</p><h1 id="Ro-ri-bo-nho-la-gi"><a href="#Ro-ri-bo-nho-la-gi" class="headerlink" title="Rò rỉ bộ nhớ là gì ?"></a>Rò rỉ bộ nhớ là gì ?</h1><p>Nếu bạn đọc hết những phần ở trên thì cũng dễ hiểu thôi, rò rỉ bộ nhớ là những vùng nhớ được cấp phát và sử dụng trong chương trình nhưng sau đó, khi không còn dùng nữa, chúng vẫn không được giải phóng và trả về cho hệ điều hành hoặc là kho chứa bộ nhớ.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg" alt=""></p><p>Các ngôn ngữ lập trình có nhiều cách khác nhau để quản lý bộ nhớ. Tuy nhiên, một vùng nhớ cụ thể được dùng hay không thực sự là <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Release_when_the_memory_is_not_needed_anymore" target="_blank" rel="noopener">vấn đề khó đoán</a>. Nói cách khác, chỉ có developer mới biết khi nào thì một vùng nhớ nên được giải phóng và trả lại cho hệ điều hành.</p><p>Những ngôn ngữ lập trình cung cấp các tính năng giúp developer làm việc này. Trong khi một số ngôn ngữ khác muốn developer hiểu tường tận về việc khi nào thì 1 vùng nhớ không được sử dụng nữa. Wikipedia có bài viết hay về việc quản lý bộ nhớ <a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" target="_blank" rel="noopener">tự động</a> và <a href="https://en.wikipedia.org/wiki/Manual_memory_management" target="_blank" rel="noopener">bằng tay</a>, bạn có thể xem qua.</p><h2 id="4-loai-ro-ri-pho-bien-trong-Javascript"><a href="#4-loai-ro-ri-pho-bien-trong-Javascript" class="headerlink" title="4 loại rò rỉ phổ biến trong Javascript"></a>4 loại rò rỉ phổ biến trong Javascript</h2><h3 id="1-Bien-toan-cuc"><a href="#1-Bien-toan-cuc" class="headerlink" title="1. Biến toàn cục"></a>1. Biến toàn cục</h3><p>Javascript xử lý những biến không được khai báo một cách khá thú vị: khi một biến không được khai báo được tham chiếu đến thì một biến mới sẽ được tạo ra trong object toàn cục (global). Trên trình duyệt thì tên của nó là <strong>window</strong>, nghĩa là đoạn này</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    bar = <span class="string">"some text"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…tương đương với</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.bar = <span class="string">"some text"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Giả sử mục đích của bar chỉ để tham chiếu đến 1 biến trong hàm foo thì một biến toàn cục dư thừa lúc này đã được tạo ra bởi vì ta định nghĩa bar mà không dùng var. Ở ví dụ trên, nó không gây ra nhiều tổn hại, nhưng dĩ nhiên bạn có thể tưởng tượng ra bối cảnh đáng lo ngại hơn nhiều. Ví dụ như gán 1 object phức tạp trong bar chẳng hạn.</p><p>Thỉnh thoảng bạn cũng có thể vô tình tạo biến toàn cục bằng this:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.var1 = <span class="string">"potential accidental global"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// trong hàm foo() ở đây thì "this" đang trỏ tới biến toàn cục </span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>Bạn có thể tránh trường hợp đáng tiếc này bằng cách thêm dòng use strict vào đầu file Javascript, nó sẽ, nói nôm na, là bật chế độ “nghiêm túc” lên khi phân tích cú pháp (parse) code JS và sẽ ngăn chặn trường hợp vô tình tạo biến toàn cục.</p><p>Những biến toàn cục ngoài dự tính như trên rõ ràng là 1 vấn đề, tuy nhiên, thường thì code của bạn sẽ bị “nhiễm độc” bởi những biến toàn cục tường minh mà những biến đó lại không thể thu thập bởi GC. Đặc biệt chú ý đến các biến toàn cục thường được dùng để lưu trữ tạm thời và xử lý 1 số lượng lớn thông tin. Sử dụng biến toàn cục để lưu trữ dữ liệu nếu bạn <strong>phải</strong> làm thế, nhưng nhớ kỹ là gán nó bằng null hoặc gán lại 1 giá trị khác khi đã xong việc với nó.</p><h3 id="2-Timers-hoac-callbacks-bi-bo-quen"><a href="#2-Timers-hoac-callbacks-bi-bo-quen" class="headerlink" title="2. Timers hoặc callbacks bị bỏ quên"></a>2. Timers hoặc callbacks bị bỏ quên</h3><p>Lần này ta lấy setInterval làm ví dụ vì nó thường được dùng trong JS.</p><p>Những thư viện có dùng callback cung cấp observer và các công cụ tương tự thường đảm bảo tham chiếu đến callback sẽ không thể truy cập được một khi instance của nó không thể truy cập được. Ví dụ dưới đây không phải hiếm:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverData = loadData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> renderer = <span class="built_in">document</span>.getElementById(<span class="string">'renderer'</span>);</span><br><span class="line">    <span class="keyword">if</span>(renderer) &#123;</span><br><span class="line">        renderer.innerHTML = <span class="built_in">JSON</span>.stringify(serverData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>); <span class="comment">// hàm sẽ được thực thi sau mỗi 5 giây.</span></span><br></pre></td></tr></table></figure><p>Đoạn code trên cho thấy hậu quả của việc sử dụng timer có tham chiếu đến node hay dữ liệu cũ, không còn dùng nữa.</p><p>Object renderer có thể được thay thế hoặc gỡ bỏ ở đâu đó trong quá trình thực thi, điều này làm cho hàm callback trong setInterval trở nên thừa thãi. Nếu điều này xảy ra, dù cho callback hay những thứ bên trong có đủ điều kiện để được dọn dẹp thì trước hết cái interval đó phải dừng lại trước đã (bỏi vì nó vẫn đang hoạt động mà). Dĩ nhiên nếu như serverData đang chứa hay đang xử lý cả 1 đống dữ liệu thì cũng không thể bị thu dọn được.</p><p>Khi sử dụng observer, bạn cần đảm bảo phải có một câu lệnh tường minh để gỡ bỏ chúng mỗi khi xong việc (Dù là observer đó không cần dùng nữa hay object không thể truy cập được).</p><p>May mắn thay, đa số các trình duyệt hiện đại đều làm giúp bạn việc đó rồi: chúng sẽ tự động thu thập các observer mỗi khi object trong đó trở nên không thể truy cập được kể cả nếu như bạn quên gỡ các listener. Trước đây, một số trình duyệt không làm được điều này (IE6 chẳng hạn).</p><p>Nhưng cách tốt nhất vẫn là gỡ bỏ observer khi đã xong việc với nó. Bạn xem ví dụ dưới đây:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'launch-button'</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">   counter++;</span><br><span class="line">   element.innerHtml = <span class="string">'text '</span> + counter;</span><br><span class="line">&#125;</span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, onClick);</span><br><span class="line"><span class="comment">// Do stuff </span></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>, onClick);</span><br><span class="line">element.parentNode.removeChild(element);</span><br><span class="line"><span class="comment">// Giờ thì "element" đã được đưa ra khỏi phạm vi thực thi,</span></span><br><span class="line"><span class="comment">// Cả "element" và "onClick" sẽ được dọn dẹp kể cả trên các trình duyệt cũ</span></span><br></pre></td></tr></table></figure><p>Bạn không càn phải gọi hàm removeEventListener trước khi làm cho node không thể truy cập được vì các trình duyệt hiện đại hỗ trợ GC có thể tự động xác định và xử lý chúng một cách thích hợp.</p><p>Nếu bạn dùng jQuery APIs (có nhiều thư viện và frameworks khác cũng hỗ trợ), bạn cũng có thể gỡ bỏ các listener trước khi node bị đưa vào “dĩ vãng” và không dùng nữa. Những thư viện cũng đảm bảo không có rò rỉ bộ nhớ kể cả khi ứng dụng của bạn chạy trên những trình duyệt cũ.</p><h3 id="3-Closures"><a href="#3-Closures" class="headerlink" title="3. Closures"></a>3. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">Closures</a></h3><p>Một phần quan trọng của Javascript chính là closure: một hàm con có thể truy xuất đến biến của hàm bên ngoài nó. Trong quá tình triển khai chi tiết môi trường thực thi (runtime) của JS thì có thể xảy ra tình trạng rò rỉ bộ nhớ với closure như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing) <span class="comment">// một tham chiếu đến 'originalThing'</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>Một khi replaceThing được gọi, theThing sẽ trở thành một object mới chứa 1 mảng rất lớn và 1 closure someMethod. Tuy nhiên, originalThing được tham chiếu bởi 1 closure mà nó lại nằm trong biến unused (chính là biến theThing từ lời gọi đến replaceThing trước đó). Nhớ rằng ở đây một khi <strong>phạm vi (scope) của closure được tạo ra cho closure trong cùng parent scope thì scope đó được dùng chung</strong>.</p><p>Trong trường hợp này, scope tạo ra cho closure someMethod được chia sẻ với unused. unused có tham chiếu đến originalThing. Mặc dù unused không bao giờ được dùng, someMehod có thể được sử dụng thông qua theThing bên ngoài scope của replaceThing (ví dụ: ở 1 nơi toàn cục nào đó). Và khi someMethod chia sẻ closure với unused, tham chiếu đến originalThing trong unused ép nó phải ở trong trạng thái hoạt động (toàn bộ scope chia sẻ giữa 2 closure). Điều này ngăn chặn GC hoạt động.</p><p>Trong ví dụ trên, scope được tạo ra cho closure someMethod được chia sẻ với unused, trong khi unused tham chiếu tới originalThing. someMethod có thể được gọi thông qua theThing bên ngoài scope của replaceThing, mặc dù sự thật là unused không bao giờ được sử dụng. Rõ ràng unused tham chiếu đến originalThing yêu cầu nó phải giữ trạng thái đang hoạt động bởi vì someMethod chia sẻ closure scope với unused.</p><p>Tất cả những điều này có thể làm bộ nhớ bị rò rỉ đáng kể. Bạn có thể thấy biểu đồ sử dụng bộ nhớ dâng lên cao ngất khi đoạn code trên bị lặp đi lặp lại. Kích thước của nó không bị giảm đi khi GC hoạt động. Một danh sách liên kết các closure được tạo ra (root của nó là theThing) và mỗi closure scope lại chưa một tham chiếu gián tiếp tới mảng khổng lồ.</p><p>Vấn đề này được tìm thấy bởi Meteor team và họ có <a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" target="_blank" rel="noopener">1 bài viết cụ thể mô tả về nó ở đây</a>.</p><h3 id="4-Tham-chieu-ngoai-DOM"><a href="#4-Tham-chieu-ngoai-DOM" class="headerlink" title="4. Tham chiếu ngoài DOM"></a>4. Tham chiếu ngoài DOM</h3><p>Có những trường hợp mà developer lưu trữ DOM node bên trong cấu trúc dữ liệu. Giả sử bạn muốn cập nhật một cách nhanh chóng dữ liệu của nhiều row trong 1 table. Nếu bạn lưu tham chiếu đến mỗi DOM row trong 1 dictionary hay mảng, sẽ có 2 tham chiếu đến cùng 1 phần tử DOM: 1 là từ cây DOME, và 1 là từ dictionary. Nếu bạn chọn lựa xóa bỏ những row này, bạn cũng phải nhớ làm cho 2 tham chiếu trên không thể truy cập được.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">    button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</span><br><span class="line">    image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    elements.image.src = <span class="string">'http://example.com/image_name.png'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Cái ảnh là 1 node con trực tiếp của body</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'image'</span>));</span><br><span class="line">    <span class="comment">// Ở thời điểm này ta vẫn có 1 tham chiếu đến #button trong </span></span><br><span class="line">    <span class="comment">// biến toàn cục "element". Nói cách khác, "button" vẫn còn nằm</span></span><br><span class="line">    <span class="comment">// trong bộ nhớ và GC không thể dọn dẹp nó được.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cần phải xem xét kỹ lưỡng khi tham chiếu đến node con hay node lá bên trong cây DOME. Nếu bạn giữ tham chiếu đến 1 table cell (thẻ <td>) trong code và chọn xóa table khỏi DOM tuy nhiên vẫn giữ tham chiếu đến cell đó, bạn có thể sẽ phải đối mặt với 1 vụ rò rỉ lớn. Bạn nghĩ rằng GC sẽ giải phóng tất cả mọi thứ ngoại trừ cell đó. Tuy nhiên, điều này không dễ dàng như vậy. Bởi vì cell là 1 node con của table và những node con thì có tham chiếu đến parent của chúng, vì thế 1 tham chiếu đến 1 cell có thể giữ cả 1 table lớn trong bộ nhớ.</td></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mấy hôm trước chúng ta đã bắt đầu series bài viết đục khoét về Javascript và cách nó hoạt động như thế nào, bằng cách hiểu về những thành phần cơ bản và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và &lt;em&gt;ngon&lt;/em&gt; hơn.&lt;/p&gt;
&lt;p&gt;Bài đầu tiên là tổng quan về series, cung cấp cái nhìn toàn cảnh về engine, runtime &amp;amp; callstack. Bài thứ 2 là một cái nhìn cụ thể hơn về những thành phần bên trong của bộ engine V8 của Google và một số mẹo vặt để tối ưu Javascript code.&lt;/p&gt;
&lt;p&gt;Ở bài thứ 3 này, chúng ta sẽ thảo luận về một vấn đề không kém phần quan trọng nhưng lại thường bị các dev bỏ qua do sự phức tạp ngày càng gia tăng của các ngôn ngữ lập trình thường dùng: quản lý bộ nhớ. Chúng ta cũng sẽ tìm hiểu một số mẹo để có thể xử lý những trường hợp rò rì bộ nhớ của Javascript mà team SesstionStack đã áp dụng để tránh bị rò rỉ và không làm tốn bộ nhớ của webapp.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P2: Bên trong engine V8 &amp; 5 mẹo để tối ưu hóa code</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P2-Ben-trong-engine-V8-5-meo-de-toi-uu-hoa-code.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P2-Ben-trong-engine-V8-5-meo-de-toi-uu-hoa-code.html</id>
    <published>2018-11-13T15:52:00.000Z</published>
    <updated>2018-11-13T15:58:38.369Z</updated>
    
    <content type="html"><![CDATA[<p>Hôm trước chúng ta đã có bài bắt đầu một chuỗi series đào sâu nghiên cứu về Javascript và cách thức nó hoạt động: Chúng tôi nghĩ rằng, bằng cách hiểu được những thành phần của JS và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và <em>ngon</em> hơn</p><p>Bài đầu tiên của series đã cho chúng ta có một cái nhìn tổng quan về engine, runtime và callstack. Trong bài thứ 2 này, chúng ta sẽ <em>đục khoét</em> vào những thành phần bên trong của bộ engine V8 của Google. Tác giả cũng sẽ cung cấp một số mẹo vặt để có thể viết code Javascript tốt hơn - những thứ tốt nhất (best practices) mà team SessionStack đã và đang thực hiện để xây dựng những sản phẩm của họ.<br><a id="more"></a></p><h1 id="Tong-quan"><a href="#Tong-quan" class="headerlink" title="Tổng quan"></a>Tổng quan</h1><p>Javascript engine là một trình thông dịch thực thi mã Javascript. Một JS engine có thể được triển khai thực hiện như là 1 trình thông dịch độc lập, hoặc là một trình biên dịch tức thời (Just-In-Time Compiler) mà nó sẽ biên dịch code Javascript thành bytecode (chưa phải mã máy, nhưng gần như là mã máy).</p><p>Dưới đây là danh sách các dự án phổ biến đã triển khai cho Javascript engine:</p><ul><li><a href="https://en.wikipedia.org/wiki/V8_%28JavaScript_engine%29" target="_blank" rel="noopener">V8</a> - Nguồn mở, phát triển bởi Google trên nền C++</li><li><a href="https://en.wikipedia.org/wiki/Rhino_%28JavaScript_engine%29" target="_blank" rel="noopener">Rhino</a> - Được quản lý bởi quỹ Mozilla Foundation, nguồn mở, phát triển hoàn toàn bằng Java</li><li><a href="https://en.wikipedia.org/wiki/SpiderMonkey_%28JavaScript_engine%29" target="_blank" rel="noopener">SpiderMonkey</a> - Bộ JS engine đầu tiên, ngày xưa được hỗ trợ bởi Netscape Navigator, ngày nay là Firefox</li><li><a href="https://en.wikipedia.org/wiki/JavaScriptCore" target="_blank" rel="noopener">JavaScriptCore</a> - nguồn mở, còn được gọi là Nitro, được phát triển bởi Apple cho Safari</li><li><a href="https://en.wikipedia.org/wiki/KJS_%28KDE%29" target="_blank" rel="noopener">KJS</a> - Engine của KDE, phát triển bởi Harri Porten cho dự án trình duyệt Konqueror của KDE</li><li><a href="https://en.wikipedia.org/wiki/Chakra_%28JScript_engine%29" target="_blank" rel="noopener">Chakra (JScript9)</a> - Internet Explorer</li><li><a href="https://en.wikipedia.org/wiki/Chakra_%28JavaScript_engine%29" target="_blank" rel="noopener">Chakra (JavaScript)</a> -  Microsoft Edge</li><li><a href="https://en.wikipedia.org/wiki/Nashorn_%28JavaScript_engine%29" target="_blank" rel="noopener">Nashorn</a> - Nguồn mở và là 1 phần của OpenJDK, viết bằng Java bởi Oracle và Tool Group</li><li><a href="https://en.wikipedia.org/wiki/JerryScript" target="_blank" rel="noopener">JerryScript</a> - là 1 bộ engine nhẹ dành cho Vạn vật kết nối (Internet of Things)</li></ul><h1 id="Tai-sao-V8-duoc-tao-ra"><a href="#Tai-sao-V8-duoc-tao-ra" class="headerlink" title="Tại sao V8 được tạo ra?"></a>Tại sao V8 được tạo ra?</h1><p><em>Hỏi vớ vẩn</em> </p><p>V8 engine được xây dựng bởi Google bằng C++ và nó là phần mềm nguồn mở. Bộ engine này được dùng trong trình duyệt Google Chrome. Không giống như các engine khác, V8 còn được sử dụng trong môi trường runtime của Node.js</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*AKKvE3QmN_ZQmEzSj16oXg.png" alt=""></p><p>V8 đầu tiên được thiết kế nhằm gia tăng hiệu suất của tiến trình thực thi JavaScript bên trong trình duyệt. Để có thể đạt được tốc độ tốt, V8 dịch mã Javascript thành mã máy thay vì sử dụng trình thông dịch. Nó biên dịch mã JS thành mã máy ngay khi thực thi bằng bộ JIT compiler (Just-In-Time compiler) giống như đa số các JS engine hiện đại khác như SpiderMoney hay Rhino. Điểm khác biệt chính đó là V8 không sinh ra bytecode hay mã trung gian.</p><h1 id="V8-su-dung-2-trinh-bien-dich"><a href="#V8-su-dung-2-trinh-bien-dich" class="headerlink" title="V8 sử dụng 2 trình biên dịch"></a>V8 sử dụng 2 trình biên dịch</h1><p>Trước khi phát hành phiên bản 5.9 (đầu năm 2017), engine V8 sử dụng 2 trình biên dịch:</p><ul><li><strong>full-codegen</strong> - một trình biên dịch vừa đơn giản vừa cực nhanh, sinh mã máy đơn giản và tương đối chậm</li><li><strong>Crankshaft</strong> - một trình biên dịch tối ưu có hơi phức tạp (Just-In-Time) sinh mã đã được tối ưu tốt nhất.</li></ul><p>V8 engine còn sử dụng nhiều tiến trình nội bộ khác:</p><ul><li>Tiến trình chính thực hiện những gì bạn thường thấy: lấy code, biên dịch và thực thi nó.</li><li>Có một tiến trình riêng khác cho việc biên dịch, bằng cách này thì trong khi tiến trình chính biên dịch, tiến trình phụ tối ưu (optimize) code.</li><li>Một tiến trình Profiler (không biết dịch) sẽ thông báo cho runtime những phương thức nào đang chiếm dụng nhiều thời gian xử lý để cho Crankshaft có thể tối ưu chúng.</li><li>Một vài tiến trình khác để xử lý dọn rác (Garbage Collector)</li></ul><p>Khi lần đầu thực thi mã Javascript, V8 engine sẽ gọi <strong>full-codegen</strong> để dịch trực tiếp những đoạn code JS đã được phân tích thành mã máy mà không thông qua bước chuyển đổi (transformation). Điều này cho phép thực thi mã máy rất nhanh. Để ý rằng V8 không sử dụng bytecode trung gian, cho thấy rằng cách làm này loại bỏ sự không cần thiết của 1 trình thông dịch.</p><p>Khi code đã chạy được một thời gian thì tiến trình profiler đã thu thập đủ dữ liệu để có thể xác định phương thức nào cần được tối ưu hóa.</p><p>Ở bước tiếp theo, <strong>Crankshaft</strong> sẽ bắt đầu 1 tiến trình khác. Nó dịch cây cú pháp trừu tượng (Abstract Syntax Tree - AST, sẽ có 1 bài riêng để nói về cái này nhé) của Javascript thành một dạng cấp độ cao của <em>static single assignment</em> (SSA - vốn ngôn ngữ có hạn nên không biết dịch), còn được gọi là <em>Hydrogen</em>, và cố gắng tối ưu đồ thị Hydrogen đó. Đa số sự tối ưu hóa được hoàn thành là giai đoạn này.</p><h1 id="Inlining-Noi-tuyen"><a href="#Inlining-Noi-tuyen" class="headerlink" title="Inlining (Nội tuyến)"></a>Inlining (Nội tuyến)</h1><p>Bước tối ưu hóa đầu tiên là triển khai nội tuyến (<a href="https://vi.wikipedia.org/wiki/H%C3%A0m_n%E1%BB%99i_tuy%E1%BA%BFn" target="_blank" rel="noopener">Inlining</a>) nhiều code nhất có thể. Inlining là tiến trình thay thế một vị trí gọi (call site - dòng code nơi hàm được gọi) với thân (body) của hàm được gọi. Bước thực hiện đơn giản này cho phép những tối ưu hóa sau này được ý nghĩa hơn.</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*RRgTDdRfLGEhuR7U.png" alt=""></p><h1 id="Lop-an-Hidden-class"><a href="#Lop-an-Hidden-class" class="headerlink" title="Lớp ẩn (Hidden class)"></a>Lớp ẩn (Hidden class)</h1><p>Javascript là ngôn ngữ dựa trên các nguyên mẫu (prototype-based): không có các lớp (class) hay đối tượng (object) nào được tạo ra bằng tiến trình nhân bản (cloning process). Javascript cũng là ngôn ngữ động (dynamic), nghĩa là những thuộc tính (property) có thể được dễ dàng thêm vào hoặc xóa đi từ object sau khi object đó được khởi tạo.</p><p>Đa số các trình thông dịch JS sử dụng cấu trúc dạng như từ điển (<a href="http://en.wikipedia.org/wiki/Hash_function" target="_blank" rel="noopener">hash function based</a>) để lưu trữ vị trí của những giá trị của thuộc tính trong object trên bộ nhớ. Cấu trúc này làm cho quá trình lấy giá trị (get) trong JS trở nên tốn kém hơn nhiều so với những ngôn ngữ lập trình non-dynamic khác như Java hay C#.<br>Trong Java, tất cả các thuộc tính của object được xác định bởi cấu trúc object cố định trước khi biên dịch và không thể thêm hay bớt thuộc tính tại thời điểm thực thi (C# cũng có kiểu dynamic, nhưng cái đó hơi lạc đề rồi nên mình không đề cập).<br>Kết quả là, giá trị của thuộc tính (hay con trỏ đến thuộc tính đó) được lưu dưới dạng bộ đệm liên tục (continuous buffer) trên vùng nhớ với một offset cố định giữa các vùng nhớ. Độ dài của 1 offset có thể dễ dàng xác định dựa trên loại thuộc tính, trong khi đó điều này là bất khả thi đối với Javascript khi mà loại thuộc tính có thể bị thay đổi trong quá trình thực thi.</p><p>Bởi vì sử dụng cấu trúc từ điển để tìm vị trí của thuộc tính của object trong vùng nhớ là không hiệu quả nên V8 sử dụng một phương pháp khác: lớp ẩn (hidden class). Lớp ẩn hoạt động tương tự như một cấu trúc object (class) cố định trong Java, ngoại trừ việc nó được tạo ra ở quá trình thực thi (runtime). Giờ thì xem ví dụ bên dưới nhé:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>Khi câu lệnh new Point(1, 2) được gọi, V8 sẽ tạo ra 1 lớp ẩn, tạm gọi là C0</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*pVnIrMZiB9iAz5sW28AixA.png" alt=""></p><p>Không có thuộc tính nào được định nghĩa trong Point, vì thế tạm thời C0 đang rỗng.</p><p>Khi câu lệnh this.x = x được thực thi (bên trong hàm Point), V8 sẽ tạo ra 1 lớp ẩn thứ hai dựa trên C0, ta tạm gọi là C1. C1 mô tả lại vị trí trên vùng nhớ (tương tự như con trỏ) nơi mà thuộc tính x được lưu.<br>Trong trường hợp này, x sẽ nằm ở offset 0, nghĩa là khi chúng ta view một object Point trên vùng nhớ dưới dạng bộ đệm liên tục (continuous buffer) thì offset đầu tiên sẽ tương ứng với thuộc tính x.<br>V8 cũng sẽ cập nhật C0 với một sự chuyển đổi lớp (class transition) và tuyên bố rằng thuộc tính x được thêm vào trong object Point, lớp ẩn lúc này sẽ chuyển từ C0 sang C1.<br>Lớp ẩn cho object Point ở hình dưới lúc này là C1</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*QsVUE3snZD9abYXccg6Sgw.png" alt=""><br><em>Mỗi khi có thuộc tính mới được thêm vào object, lớp ẩn cũ được cập nhật và sẽ chuyển tiếp (transition) sang lớp ẩn mới. Sự chuyển tiếp lớp ẩn là rất quan trọng bởi vì chúng cho phép những object được tạo ra theo những cách giống nhau có thể cùng chia sẻ các lớp ẩn. Nếu 2 object cùng dùng chung 1 lớp ẩn và 1 thuộc tính được thêm vào cả 2 object đó, sự chuyển tiếp sẽ đảm bảo rằng cả 2 object đều nhận được cùng 1 lớp ẩn mới và sẽ được tối ưu cùng nhau.</em></p><p>Quá trình này được lặp lại khi câu lệnh tiếp theo this.y = y được thực thi (bên trong hàm Point, ngay sau dòng this.x = x).</p><p>Một lớp ẩn mới, tạm gọi là C2 được tạo ra, một lớp chuyển tiếp (class transition) được thêm vào C1 biểu thị rằng nếu thuộc tính y được thêm vào object Point (object đã chứa thuộc tính x) thì lớp ẩn sẽ được thay đổi sang C2, và lớp ẩn của object Point sẽ được cập nhật thành C2</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*spJ8v7GWivxZZzTAzqVPtA.png" alt=""></p><p>Sự chuyển tiếp lớp ẩn phụ thuộc vào thứ tự mà những thuộc tính được thêm vào 1 object. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">p1.a = <span class="number">5</span>;</span><br><span class="line">p1.b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">p2.b = <span class="number">7</span>;</span><br><span class="line">p2.a = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>Nhìn vào đoạn code trên, bạn sẽ nghĩ rằng cả p1 và p2 sẽ dùng chung lớp ẩn và sự chuyển tiếp giữa các lớp. Nhưng sự thật không phải như vậy. Đối với p1, thuộc tính thứ nhất là a sẽ được thêm vào và sau đó đến b. Với p2 thì ngược lại, b trước rồi mới đến a.<br>Vì vậy, p1 và p2 sẽ sinh ra 2 lớp ẩn khác nhau và có sự chuyển tiếp lớp ẩn cũng khác nhau. Trong trường hợp này, tốt nhất là nên giữ đúng thứ tự thuộc tính mỗi khi khởi tạo dữ liệu để lớp ẩn có thể được dùng lại:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">p1.a = <span class="number">5</span>;</span><br><span class="line">p1.b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">p2.a = <span class="number">8</span>;</span><br><span class="line">p2.b = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p><em>Phần diễn giải về hidden class này khá là rối và khó hiểu, để hiểu rõ hơn thì mời bạn tham khảo thêm <a href="https://thefullsnack.com/posts/javascript-v8-notes.html" target="_blank" rel="noopener">bài viết chi tiết</a> của tác giả thefullsnack</em></p><h1 id="Inline-caching-Bo-dem-noi-tuyen"><a href="#Inline-caching-Bo-dem-noi-tuyen" class="headerlink" title="Inline caching (Bộ đệm nội tuyến)"></a>Inline caching (Bộ đệm nội tuyến)</h1><p>V8 có một điểm mạnh trong kỹ thuật tối ưu hóa dành cho các ngôn ngữ với kiểu dữ liệu động, gọi là Inline caching (bộ đệm nội tuyến). Inline caching dựa trên sự quan sát những lời gọi được lặp lại nhiều lần đến cùng 1 phương thức có xu hướng xảy ra trên cùng 1 loại object. Diễn giải chi tiết hơn về inline caching có thể xem ở <a href="https://github.com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-caches" target="_blank" rel="noopener">đây</a></p><p>Giờ chúng ta sẽ duyệt sơ qua những khái niệm chung chung của inline caching (nếu như bạn không có thời gian đọc hết bài chi tiết ở trên)</p><p>Vậy thì nó hoạt động như thế nào? V8 duy trì bộ nhớ đệm về kiểu của các object được truyền qua dưới dạng tham số (parameter) trong những lần gọi method gần đây và sử dụng thông tin này để dự đoán về kiểu object sẽ được truyền trong tương lai. Nếu như V8 có thể dự đoán tương đối tốt về kiểu object sẽ được truyền vào thì nó có thể bỏ qua bước xử lý tìm hiểu về các thuộc tính của object đó, nó sẽ dùng những thông tin có sẵn đã được lưu từ lần trước và áp dụng cho lớp ẩn của object này.</p><p>Vậy thì lớp ẩn và inline caching liên quan với nhau như thế nào? Khi một phương thức được gọi trên một object cụ thể, V8 sẽ thực hiện tìm kiếm lớp ẩn của object đó để xác định offset nhằm phục vụ cho việc truy xuất thuộc tính. Sau 2 lần gọi thành công cùng 1 phương thức đến cùng 1 lớp ẩn, V8 sẽ bỏ qua việc tìm kiếm lớp ẩn đó và đơn giản là thêm offset của thuộc tính vào trong bản thân con trỏ của object. Về sau, cứ mỗi lần gọi phương thức, V8 sẽ giả định rằng lớp ẩn không thay đổi và nhảy trực tiếp vào trong địa chỉ vùng nhớ của thuộc tính và sử dụng offset đã được lưu từ lần tìm kiếm trước đó. Cách này có thể gia tăng đáng kể tốc độ thực thi.</p><p>Inline caching cũng là lý do quan trọng cho việc cùng kiểu object sẽ dùng chung lớp ẩn. Nếu bạn tạo ra 2 object có cùng 1 kiểu nhưng khác hidden class (như chúng ta đã làm ở trên), V8 sẽ không thể sử dụng inline caching bởi vì mặc dù 2 object có cùng kiểu nhưng lớp ẩn tương ứng của nó lại gán offset khác nhau cho mỗi thuộc tính.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*iHfI6MQ-YKQvWvo51J-P0w.png" alt=""><br>2 object về cơ bản là giống nhau nhưng thuộc tính a và b lại có thứ tự khác nhau.</p><h1 id="Bien-dich-thanh-ma-may"><a href="#Bien-dich-thanh-ma-may" class="headerlink" title="Biên dịch thành mã máy"></a>Biên dịch thành mã máy</h1><p>Một khi đồ thị Hydrogen đã được tối ưu hóa, Crankshaft chuyển nó xuống một tầng thấp hơn gọi là Lithium. Hầu như toàn bộ các Lithium này là kiến trúc cụ thể (architecture-specific, mình cũng không hiểu nữa, kiến thức chuyên sâu quá). Đăng ký cấp phát xảy ra ở tầng này.</p><p>Ở bước cuối cùng, Lithium được biên dịch thành mã máy. Sau đó, quá trình thay đổi trên ngăn xếp (on-stack replacement: OSR) sẽ diễn ra. Trước khi chúng ta bắt đầu biên dịch và tối ưu hóa một phương thức ngốn nhiều thời gian, chúng ta thường chạy nó trước. V8 sẽ không vứt hết những đoạn code chậm và chạy lại từ đầu đoạn code đã tối ưu. Thay vì thế, V8 sẽ chuyển hóa toàn bộ ngữ cảnh hiện tại (ngăn xếp, các thanh ghi), do đó ta có thể chuyển đổi sang phiên bản đã được tối ưu ngay giữa quá trình thực thi. Đây là một thao tác cực kỳ phức tạp, hãy nhớ rằng V8 đã <em>inline</em> toàn bộ code giữa quá trình tối ưu hóa (Đoạn này viết khó hiểu quá, nhưng mà cũng không quan tọng lắm đâu). Ngoài ra thì V8 không phải là engine duy nhất có thể làm được điều này.</p><p>Có một giải pháp an toàn đó là đảo ngược quá trình tối ưu hóa (deoptimization - phức tạp hóa ?) để chuyển đổi toàn bộ code về với trạng thái chưa được tối ưu trong trường hợp engine gặp trục trặc.</p><h1 id="Bo-don-rac-Garbage-collection-GC"><a href="#Bo-don-rac-Garbage-collection-GC" class="headerlink" title="Bộ dọn rác (Garbage collection - GC)"></a>Bộ dọn rác (Garbage collection - GC)</h1><p>Đối với GC thì V8 sử dụng phương pháp thế hệ theo kiểu truyền thống là đánh-dấu-và-quét (mark-and-sweep) để dọn dẹp những thứ cũ. Giả sử quá tình đánh dấu có thể làm ngưng sự thực thi Javascript. Để có thể điều hành GC hiệu quả và thực hiện một cách ổn định, V8 sử dụng đánh dấu gia tăng (incremental marking), thay vì duyệt qua toàn bộ heap và cố đánh dấu nhiều object nhất có thể, nó sẽ đi qua từng heap, sau đó quay lại với những thực thi bình thường.<br>Lần tiếp theo GC chạy sẽ tiếp tục từ vị trí heap mà trước đó nó đã dừng lại. Cách này cho phép một khoảng thời gian dừng rất ngắn giữa quá trình thực thi. Và như đã đề cập ở trước, quá tình quét dọn được xử lý bằng 1 tiến trình khác.</p><h1 id="Ignition-va-TurboFan"><a href="#Ignition-va-TurboFan" class="headerlink" title="Ignition và TurboFan"></a>Ignition và TurboFan</h1><p>Cùng với sự ra mắt của V8 bản 5.9 đầu năm 2017, có 2 pipeline thực thi mới được giới thiệu, mang lại khả năng cải thiện hiệu năng tốt hơn và tiết kiệm bộ nhớ đáng kể đối với những ứng dụng Javascript.</p><p>Bộ pipeline mới này được xây dựng trên trình thông dịch của V8 là <a href="https://github.com/v8/v8/wiki/Interpreter" target="_blank" rel="noopener">Ignition</a> và trình biên dịch tối ưu hóa mới nhất là <a href="https://github.com/v8/v8/wiki/TurboFan" target="_blank" rel="noopener">TurboFan</a>.</p><p>Bạn có thể xem thêm thông tin trong bài viết trên blog của V8 tại <a href="https://v8project.blogspot.bg/2017/05/launching-ignition-and-turbofan.html" target="_blank" rel="noopener">đây</a></p><p>Kể từ phiên bản 5.9 thì <em>full-codegen</em> và <em>Crankshaft</em> (những công nghệ đã xuất hiện trong V8 từ năm 2010) đã không còn được sử dụng cho quá trình thực thi Javascript nữa khi mà nhóm phát triển V8 đã phải vất vả để có thể theo kịp với những tính năng mới và sự tối ưu hóa cần thiết cho những tính năng này.</p><p>Điều này nghĩa là xét một cách tổng quát thì V8 sẽ đơn giản hơn và có kiến trúc dễ bảo trì hơn.</p><p><img src="https://cdn-images-1.medium.com/max/1000/0*pohqKvj9psTPRlOv.png" alt=""></p><p>Những cải tiến này chỉ là bước khởi đầu. Ignition và TurboFan sẽ lót đường cho những tối ưu hóa về sau, đẩy mạnh hiệu năng Javascript và tinh giản bớt V8 trong Chrome và Node.js trong những năm tới.</p><p>Cuối cùng, dưới đây là 1 số mẹo vặt để bạn có thể viết được bộ code Javascript một cách tối ưu. Bạn có thể dễ dàng rút ra được bài học từ những gì đã nêu ở trên, nhưng để dễ hiểu hơn thì mời bạn xẹm tổng kết:</p><h1 id="Lam-the-nao-de-toi-uu-hoa-Javascript"><a href="#Lam-the-nao-de-toi-uu-hoa-Javascript" class="headerlink" title="Làm thế nào để tối ưu hóa Javascript"></a>Làm thế nào để tối ưu hóa Javascript</h1><ol><li><strong>Thứ tự các thuộc tính của object</strong>: luôn luôn khởi tạo các thuộc tính của object sao cho chúng có cùng thứ tự để lớp ẩn và những code tối ưu có thể chia sẻ dùng chung.</li><li><strong>Thuộc tính động</strong> (Dynamic properties): thêm thuộc tính vào một object sau khi khởi tạo sẽ ép lớp ẩn phải thay đổi và làm chậm những phương thức đã được tối ưu cho lớp ẩn trước đó. Thay vì thế, ta có thể gán tất cả các thuộc tính của object trong hàm khởi tạo constructor.</li><li><strong>Phương thức</strong>: code thực thi cùng 1 phương thức nhưng nhiều lần sẽ chạy nhanh hơn code thực thi nhiều phương thức khác nhau nhưng mỗi phương thức chạy một lần (xem phần inline caching)</li><li><strong>Mảng</strong>: Tránh sử dụng mảng thưa (sparse arrays) mà key không phải là số tăng liên tục. Mảng thưa mà không có phần tử nào thì lại là bảng băm (hash table). Mỗi phần tử trong mảng như vậy sẽ gây ra sự tốn kém mỗi lần truy xuất. Ngoài ra cần tránh trường hợp cấp phát bộ nhớ trước cho những mảng lớn. Cứ để cho mảng “nở ra” một cách tự nhiên. Cuối cũng thì cũng đừng xóa các phần tử trong mảng (toán tử delete()) vì nó chỉ xóa phần từ chứ không đánh index lại mảng.</li><li><strong>Tagged values</strong>: Trong V8 thì object và số (number) là 32bits. Nó sử dụng 1 bit để phân biệt object (flag = 1) và số integer (flag = 0) gọi là SMI (SMall Integer). Vì thế nếu 1 giá trị số lớn hơn 31 bit thì V8 sẽ đóng gói số đó, chuyển nó thành kiểu double và tạo 1 object mới để lưu số. Chỉ nên sử dụng số nguyên có dấu 31 bit để tránh quá trình chuyển đổi không đáng có (lại tốn công xử lý) số thành object.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hôm trước chúng ta đã có bài bắt đầu một chuỗi series đào sâu nghiên cứu về Javascript và cách thức nó hoạt động: Chúng tôi nghĩ rằng, bằng cách hiểu được những thành phần của JS và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và &lt;em&gt;ngon&lt;/em&gt; hơn&lt;/p&gt;
&lt;p&gt;Bài đầu tiên của series đã cho chúng ta có một cái nhìn tổng quan về engine, runtime và callstack. Trong bài thứ 2 này, chúng ta sẽ &lt;em&gt;đục khoét&lt;/em&gt; vào những thành phần bên trong của bộ engine V8 của Google. Tác giả cũng sẽ cung cấp một số mẹo vặt để có thể viết code Javascript tốt hơn - những thứ tốt nhất (best practices) mà team SessionStack đã và đang thực hiện để xây dựng những sản phẩm của họ.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cách Javascript hoạt động P1: Khái quát về engine, runtime và callstack</title>
    <link href="http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P1-Khai-quat-ve-engine-runtime-va-callstack.html"/>
    <id>http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P1-Khai-quat-ve-engine-runtime-va-callstack.html</id>
    <published>2018-11-13T15:50:00.000Z</published>
    <updated>2018-11-13T15:51:06.078Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript càng ngày càng phổ biến, có nhiều nhóm các lập trình viên đã và đang nâng cấp cũng như hỗ trợ JS ở nhiều mức độ khác nhau: từ frontend đến backend, hybrid app, thiết bị nhúng và còn nhiều nữa.</p><p>Bài viết này mở đầu cho 1 series hướng tới mục đích đào sâu (aka <em>Đục Khoét</em>) vào trong Javascript và cách mà nó hoạt động như thế nào: Bằng cách hiểu rõ các thành phần của JS và cách mà chúng tương tác với nhau thì bạn có thể viết code tốt hơn và <em>ngon</em> hơn. Bên cạnh đó team SessionStack cũng chia sẻ một vài bí kíp trong khi xây dựng SessionStack - 1 ứng dụng Javascript nhẹ nhưng có chất lượng cao và mạnh mẽ.<br><a id="more"></a><br>Như ta thấy trong <a href="https://githut.info/" target="_blank" rel="noopener">GitHut stats</a>, Javascript đang là top đứng đầu trong các repo đang hoạt động (Active Repositories) và tổng số push (Total Pushes) ở GitHub. Và nó cũng không bị tụt lùi quá nhiều ở những hạng mục khác.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*Zf4reZZJ9DCKsXf5CSXghg.png" alt=""></p><p>(<a href="https://madnight.github.io/githut/" target="_blank" rel="noopener">Xem cập nhật mới nhất về GitHut stat</a>).</p><p>Nếu dự án phụ thuộc quá lớn vào Javascript thì có nghĩa rằng các lập trình viên phải tận dụng tối đa khả năng mà ngôn ngữ này cũng như hệ sinh thái (ecosystem) của nó cung cấp và thấu hiểu một cách triệt để về bản chất của nó để có thể xây dựng được những công trình vi diệu.</p><p>Và một cách hiển nhiên là có rất nhiều lập trình viên đang sử dụng Javascript hằng ngày nhưng lại không có kiến thức hoặc không biết gì về những thứ đang thực sự diễn ra bên trong JS.</p><h1 id="Tong-quan"><a href="#Tong-quan" class="headerlink" title="Tổng quan"></a>Tổng quan</h1><p>Hầu như mọi người ai cũng từng nghe qua bộ engine V8 và đa số mọi người biết rằng JS là một ngôn ngữ đơn luồng (single-thread) hoặc là nó sử dụng hàng đợi các callback (callback queue - không biết dịch sao cho đúng<br><img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f613.png" alt=""><br>)</p><p>Trong bài này, chúng ta sẽ đi lần lượt một cách chi tiết qua các khái niệm cơ bản và giải thích cụ thể Javascript chạy như thế nào. Bằng cách đó, chúng ta có thể viết code được tốt hơn, xây dựng app có khả năng xử lý API một cách mượt mà, không bị block lẫn nhau (non-blocking apps).</p><p>Nếu bạn là người mới học Javascript thì bài viết này sẽ giúp bạn hiểu tại sao Javascript lại “quái dị” khi so sánh với các ngôn ngữ khác.</p><p>Và nếu bạn là một dev có kinh nghiệm với JS thì hi vọng bài viết này sẽ giúp ích cho bạn hiểu thêm về cách hoạt động của JS Runtime - thứ mà bạn đang sử dụng mỗi ngày.</p><h1 id="JavaScript-Engine"><a href="#JavaScript-Engine" class="headerlink" title="JavaScript Engine"></a>JavaScript Engine</h1><p><em>Engine: Cỗ máy - mình sẽ không dịch từ mà để nguyên gốc tiếng Anh</em></p><p>Một ví dụ điển hình của JS Engine chính là bộ Google V8. Bộ engine V8 này được sử dụng trong Google Chrome và Node.js. Dưới đây là một mô hình đơn giản nhất của nó:<br><img src="https://cdn-images-1.medium.com/max/1000/1*OnH_DlbNAPvB9KLxUCyMsA.png" alt=""></p><p>Engine gồm 2 thành phần chính:</p><ul><li>Vùng nhớ heap (memory heap): khu vực cấp phát bộ nhớ</li><li>Ngăn xếp (call stack): đây là nơi chứa các khung stack khi bạn thực thi code.</li></ul><h1 id="Runtime-Moi-truong-thuc-thi"><a href="#Runtime-Moi-truong-thuc-thi" class="headerlink" title="Runtime (Môi trường thực thi)"></a>Runtime (Môi trường thực thi)</h1><p>Có những API trong trình duyệt đang được sử dụng bởi đa số JS developer hiện nay (ví dụ: setTimeout). Những API này lại không được cung cấp bởi các Engine.</p><p>Vậy thì chúng từ đâu tới ?</p><p>Sự thật có đôi chút phức tạp một tí.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4lHHyfEhVB0LnQ3HlhSs8g.png" alt=""></p><p>Chúng ta có JS Engine nhưng thực ra còn nhiều thứ hơn thế. Các browser thường cung cấp một hệ thống <em>Web APIs</em> bao gồm nhiều thành phần như DOM, AJAX, setTimeout, vân vân và mây mây.</p><p>Và rồi cả những thứ nổi tiếng như event loop và callback queue nữa.</p><h1 id="Ngan-xep-Call-Stack"><a href="#Ngan-xep-Call-Stack" class="headerlink" title="Ngăn xếp (Call Stack)"></a>Ngăn xếp (Call Stack)</h1><p>Javascript là ngôn ngữ lập trình đơn luồng (single-threaded), nghĩa là nó chỉ có 1 cái call stack. Vì thế nó chỉ có thể làm 1 công việc tại 1 thời điểm nhất định.</p><p>Call Stack là một cấu trúc dữ liệu mà về cơ bản thì nó ghi nhớ vị trí của chúng ta trong chương trình đang chạy. Nếu như chúng ta thực thi một hàm (function) thì khi đó ta sẽ đặt hàm đấy vào vị trí trên cùng của ngăn xếp (stack), sau khi xử lý xong và return từ hàm đó, vị trí trên cùng sẽ bị đẩy ra khỏi stack. Đó là cách hoạt động của Call Stack.</p><p>Để dễ hiểu hơn thì mời bạn xem ví dụ bên dưới:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = multiply(x, x);</span><br><span class="line">    <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line">printSquare(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>Khi engine bắt đầu thực thi code, Call Stack còn đang rỗng. Ngay sau đó, từng bước thực hiện sẽ giống như hình bên dưới:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Yp1KOt_UJ47HChmS9y7KXw.png" alt=""></p><p>Mỗi bản ghi trong Call Stack được gọi là khung của ngăn xếp (Stack Frame).</p><p>Và đây cũng là cách chính xác mà stack traces được xây dựng và in ra mỗi khi có xử lý biệt lệ (exception handling). Về cơ bản thì nó chính là trạng thái của Call Stack ngay tại thời điểm có biệt lệ xảy ra. Hãy nhìn vào đoạn code bên dưới:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'SessionStack will help you resolve crashes :)'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure><p>Nếu như chạy đoạn code đó trên Chrome console (giả sử toàn bộ code nằm trong 1 file foo.js), thì chúng ta sẽ có stack trace như sau:</p><p> <img src="https://cdn-images-1.medium.com/max/1600/1*T-W_ihvl-9rG4dn18kP3Qw.png" alt=""></p><p>Thổi tung ngăn xếp (<strong>Blowing the stack</strong>)  - Trường hợp này xảy ra khi chương trình thực thi đạt tới kích thước giới hạn tối đa của Call Stack. Và để có thể có được tình huống này một cách dễ dàng nhất, chỉ cần <em>vô tình</em> gọi đệ quy một cách không cẩn thận là được à:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>Khi engine bắt đầu thực thi code, nó gọi hàm foo đầu tiên. Hàm này lại gọi đệ quy chính bản thân nó để rồi rơi vào 1 vòng lặp vô hạn không có điều kiện dừng. Mỗi khi gọi hàm thì 1 bản ghi sẽ được đẩy vào Call Stack, và cứ thế, cứ thể đẩy vào làm cho tràn ngăn xếp (aka stackoverflow). Giống như hình bên dưới:</p><p> <img src="https://cdn-images-1.medium.com/max/1600/1*AycFMDy9tlDmNoc5LXd9-g.png" alt=""></p><p>Tại 1 thời điểm cụ thể nào đó khi số lần gọi hàm đạt tới ngưỡng giới hạn của Call Stack (call stack size) thì trình duyệt sẽ quyết định “giải cứu” bằng cách bắn ra 1 lỗi trông như thế này đây:</p><p> <img src="https://cdn-images-1.medium.com/max/1600/1*e0nEd59RPKz9coyY8FX-uw.png" alt=""></p><p>Chạy code đơn tiến trình có thể khá là dễ dàng bởi vì chúng ta không phải mất công đối phó với những tình huống phức tạp thường gặp trong môi trường đa tiến trình (chẳng hạn như deadlocks).</p><p>Tuy nhiên đơn tiến trình cũng có những giới hạn của nó. Bởi vì Javascript chỉ có 1 Call Stack, điều gì sẽ xảy ra khi có vài xử lý chậm chạp?</p><h1 id="Xu-ly-dong-thoi-Concurrency-amp-Vong-lap-su-kien-Event-Loop"><a href="#Xu-ly-dong-thoi-Concurrency-amp-Vong-lap-su-kien-Event-Loop" class="headerlink" title="Xử lý đồng thời (Concurrency) &amp; Vòng lặp sự kiện (Event Loop)"></a>Xử lý đồng thời (Concurrency) &amp; Vòng lặp sự kiện (Event Loop)</h1><p>Điều gì sẽ xảy ra nếu như bạn có 1 hàm xử lý đang ở trong Call Stack nhưng hàm đó lại tốn kha khá thời gian để chạy? Ví dụ như bạn muốn thực hiện một vài thuật toán chuyển đổi hình ảnh phức tạp bằng Javascript ngay trên trình duyệt.</p><p>Thế thì có vấn đề gì nào? Vấn đề ở đây là trong khi Call Stack đang bận tối tăm mặt mũi để xử lý thì trình duyệt lại rảnh không, ngồi chơi xơi nước vì không có gì để làm, đúng hơn là không thể làm gì được - trình duyệt đã bị block. Có nghĩa là trình duyệt không thể render, nó cũng không chạy được các câu lệnh khác, tóm lại là bị mắc kẹt. Điều này gây ảnh hưởng lớn đến sự mượt mà của UI trên app.</p><p>Đó cũng không phải vấn đề duy nhất đâu. Một khi trình duyệt bắt đầu xử lý quá nhiều thứ trong Call Stack, nó sẽ bị “đơ”, không thể tương tác được trong 1 khoảng thời gian dài. Đa số trình duyệt sẽ bắn ra lỗi, hỏi bạn xem có muốn hủy trang đang chạy không. Đại loại là giống như hình dưới:</p><p> <a href="https://cdn-images-1.medium.com/max/1600/1*WlMXK3rs_scqKTRV41au7g.jpeg" target="_blank" rel="noopener"><img src="https://cdn-images-1.medium.com/max/1600/1*WlMXK3rs_scqKTRV41au7g.jpeg" alt=""></a> <a></a></p><p>Rõ ràng điều này không phải là 1 trải nghiệm người dùng (User experience) tối ưu phải không nào?</p><p>Vậy thì làm thế nào để xử lý code vừa nhiều vừa nặng mà lại không làm UI bị kẹt cũng như trình duyệt bị đơ? Giải pháp đó là sử dụng callback bất đồng bộ (<strong>asynchronous callbacks</strong>).</p><p>Điều này sẽ được giải thích kỹ hơn trong Phần 2 của series: <strong>Bên trong engine V8 &amp; 5 mẹo để tối ưu hóa code</strong>. Các bạn đón xem nhé.</p><p>PS: Trong các bài sau mình sẽ trình bày chi tiết và kỹ hơn về cách hoạt động của Event Loop.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript càng ngày càng phổ biến, có nhiều nhóm các lập trình viên đã và đang nâng cấp cũng như hỗ trợ JS ở nhiều mức độ khác nhau: từ frontend đến backend, hybrid app, thiết bị nhúng và còn nhiều nữa.&lt;/p&gt;
&lt;p&gt;Bài viết này mở đầu cho 1 series hướng tới mục đích đào sâu (aka &lt;em&gt;Đục Khoét&lt;/em&gt;) vào trong Javascript và cách mà nó hoạt động như thế nào: Bằng cách hiểu rõ các thành phần của JS và cách mà chúng tương tác với nhau thì bạn có thể viết code tốt hơn và &lt;em&gt;ngon&lt;/em&gt; hơn. Bên cạnh đó team SessionStack cũng chia sẻ một vài bí kíp trong khi xây dựng SessionStack - 1 ứng dụng Javascript nhẹ nhưng có chất lượng cao và mạnh mẽ.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Một số nguyên tắc, định luật trong lập trình</title>
    <link href="http://nthung2112.github.io/2018/11/Mot-so-nguyen-tac-dinh-luat-trong-lap-trinh.html"/>
    <id>http://nthung2112.github.io/2018/11/Mot-so-nguyen-tac-dinh-luat-trong-lap-trinh.html</id>
    <published>2018-11-06T00:29:00.000Z</published>
    <updated>2018-11-06T00:41:54.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nguyen-tac-Demeter"><a href="#Nguyen-tac-Demeter" class="headerlink" title="Nguyên tắc Demeter"></a>Nguyên tắc Demeter</h2><p>Còn có tên gọi khác là nguyên tắc “càng biết ít càng tốt”.</p><p>Demeter là tên gọi của Nữ thần nông nghiệp, cũng là nữ thần phân phát trong thần thoại Hi Lạp. Tên bà được dùng để đánh dấu sự ra đời của nguyên tắc này, đây có thể xem là một triết lý nền tảng của việc lập trình được sinh ra từ một aspect-oriented programming (AOP) project cùng tên.<br><a id="more"></a><br>Quan điểm cơ bản của nguyên tắc này chính là : tối giản sự hiểu biết của 1 object về cấu trúc, thuộc tính của các object khác ngoài nó (bao gồm các thành phần con).</p><p><a href="http://en.wikipedia.org/wiki/Law_of_Demeter" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Law_of_Demeter</a></p><p>Nói một cách đơn giản là không được tiếp xúc với thuộc tính, method của các object khác một cách trực tiếp.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Vi phạm nguyên tắc Demeter</span><br><span class="line"><span class="built_in">console</span>.log(aStudent.class.grade)</span><br><span class="line"></span><br><span class="line">#Không vi phạm nguyên tắc Demeter</span><br><span class="line"><span class="built_in">console</span>.log(aStudent.getGrade())</span><br></pre></td></tr></table></figure><h2 id="Dinh-luat-Wirth"><a href="#Dinh-luat-Wirth" class="headerlink" title="Định luật Wirth"></a>Định luật Wirth</h2><p>“Software gets slower faster than hardware gets faster” – “Tốc độ tiến hóa của phần cứng không bằng tốc độ thoái hóa của phần mềm.”</p><p><a href="http://en.wikipedia.org/wiki/Wirth%E2%80%99s_law" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Wirth’s_law</a></p><p>Có lẽ ý chính của nó là : lập trình ngày càng dùng nhiều tài nguyên phong phú nên framework phải luôn tiến hóa để phục vụ cho việc đó. Suy ra, tốc độ phần cứng dù có tang lên đi nữa thì tốc độ phần mềm cũng chẳng hề thay đổi gì.</p><h2 id="Dinh-luat-Brook"><a href="#Dinh-luat-Brook" class="headerlink" title="Định luật Brook"></a>Định luật Brook</h2><p>Đây là một định luật dựa trên kinh nghiệm thực tế : “Đưa thêm người vào 1 project đang chậm, sẽ chỉ khiến nó càng chậm hơn.”</p><p>Hay có thể nói theo một cách khác nữa là “Tập hợp 9 bà bầu lại cũng không thể khiến đứa trẻ ra đời sau 1 tháng.”</p><p>Luận thuyết cơ bản của định luật này là</p><ul><li>Cần thời gian để quen với project </li><li>Công sức dành cho việc communication sẽ tăng </li></ul><p><a href="http://en.wikipedia.org/wiki/Brooks%27s_law" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Brooks’s_law</a></p><h2 id="Dinh-luat-Conway"><a href="#Dinh-luat-Conway" class="headerlink" title="Định luật Conway"></a>Định luật Conway</h2><p>“Organizations which design systems … are constrained to produce designs which are copies of the communication structures of these organizations.”</p><p>“Một công ty thiết kế hệ thống thế nào cũng sẽ làm ra những thiết kế giống y hệt với thiết kế hệ thống của chính công ty họ.”</p><p><a href="http://en.wikipedia.org/wiki/Conway%27s_law" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Conway’s_law</a></p><p>Nghiên cứu gần đây chỉ ra rằng hệ thống của công ty là nhân tố ảnh hưởng lớn nhất đến vấn đề phát sinh ra bug của sản phẩm.</p><p><a href="http://research.microsoft.com/apps/pubs/default.aspx?id=70535" target="_blank" rel="noopener">http://research.microsoft.com/apps/pubs/default.aspx?id=70535</a></p><h2 id="Nguyen-tac-bat-ngo-nho-nhat-least-astonishment"><a href="#Nguyen-tac-bat-ngo-nho-nhat-least-astonishment" class="headerlink" title="Nguyên tắc bất ngờ nhỏ nhất (least astonishment)"></a>Nguyên tắc bất ngờ nhỏ nhất (least astonishment)</h2><p>Trong trường hợp trên cùng 1 interface có 2 yếu tố hành xử mâu thuẫn với nhau, hoặc cách hành xử không rõ ràng thì cần phải chọn cách hành xử nào gây bất ngờ ít nhất cho người sử dụng.</p><p><a href="http://en.wikipedia.org/wiki/Principle_of_least_astonishment" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Principle_of_least_astonishment</a></p><p>Đây là 1 nguyên tắc về giao diện người dùng.</p><p>Một ví dụ đơn giản :</p><p>Trên 1 interface có 2 chức năng :</p><ul><li>Ấn ctrl+Q để thoát chương trình. </li><li>Nhập macro (lưu 1 tổ hợp phím mang 1 chức năng nào đó để tiện cho việc sử dụng về sau). </li></ul><p>Sẽ có trường hợp user muốn dùng Ctrl+Q cho macro của mình, nên hành xử đúng với nguyên tắc bất ngờ nhỏ nhất chính là : trong khi nhập macro thì ctrl+Q được coi như là tổ hợp phím bình thường, không phải là lệnh tắt chương trình. Đây chính là điều gây bất ngờ ít nhất cho người dùng.</p><h2 id="Nguyen-tac-Boy-Scout"><a href="#Nguyen-tac-Boy-Scout" class="headerlink" title="Nguyên tắc Boy Scout"></a>Nguyên tắc Boy Scout</h2><p>Nguyên tắc của các tổ chức Boy scout chính là : lúc đi phải sạch đẹp hơn lúc đến.</p><p>Trong lĩnh vực lập trình thì nguyên tắc đó sẽ được hiểu là “Khi bạn checkin 1 module thì lúc đó nó phải đẹp hơn lúc bạn checkout.”</p><h2 id="Nguyen-tac-YAGNI"><a href="#Nguyen-tac-YAGNI" class="headerlink" title="Nguyên tắc YAGNI"></a>Nguyên tắc YAGNI</h2><p>Viết tắt của “You ain’t gonna need it” – Cái (chức năng, phần) ấy rồi sẽ không cần thiết.</p><p>Đó là một câu khẩu ngữ nhắc nhở người lập trình rằng trong quy trình Extreme Programming (lập trình cực hạn) thì : “Chưa phải lúc cần thiết thì chưa được phép làm.”</p><h2 id="Nguyen-tac-DRY"><a href="#Nguyen-tac-DRY" class="headerlink" title="Nguyên tắc DRY"></a>Nguyên tắc DRY</h2><p>Viết tắt của “Don’t repeat yourself” – với ý nghĩa là “Đừng lặp lại những gì giống nhau”.</p><p><a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Don’t_repeat_yourself</a></p><p>Khi nguyên tắc này được áp dụng tốt, dù ta có thay đổi 1 phần thì những phần không liên quan cũng sẽ không bị thay đổi theo. Hơn nữa, những phần có liên quan sẽ được thay đổi cùng 1 lượt, giúp ích rất nhiều cho cả khâu estimate và khâu thực hiện.</p><h2 id="Nguyen-tac-KISS"><a href="#Nguyen-tac-KISS" class="headerlink" title="Nguyên tắc KISS"></a>Nguyên tắc KISS</h2><p>Viết tắt của “Keep it simple, stupid” – “Cứ đơn giản thôi, đồ ngu!”. Đây là 1 triết lí của Hải quân Mỹ.</p><p><a href="http://en.wikipedia.org/wiki/KISS_principle" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/KISS_principle</a></p><p>Những triết lý tương tự có thể kể đến là :</p><p><strong>Phương châm dao cạo Okham (Okham’s razor)</strong> – “Không đưa ra nhiều giả thiết nếu không cần thiết. Cái gì cần ít giả thiết để chứng minh sẽ không thể chứng minh được bằng nhiều giả thiết.”</p><p><strong>Albert Einstein</strong> – “Làm cái gì cũng nên đơn giản nhất có thể, nhưng đơn giản quá thì không được”.</p><p><strong>Leonardo da Vinci</strong> – “Đơn giản nhất chính là điêu luyện nhất”.</p><p><strong>Antoine de Saint- Exupéry</strong> – “Hoàn hảo, không phải là không thêm vào được nữa, mà là không thể bớt đi được nữa”.</p><h2 id="Nguyen-tac-SOLID"><a href="#Nguyen-tac-SOLID" class="headerlink" title="Nguyên tắc SOLID"></a>Nguyên tắc SOLID</h2><p>Tập hợp những nguyên tắc trong lập trình hướng đối tượng. Các chữ cái đầu hợp lại thành SOLID.</p><p><a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)</a>)</p><p><strong>SRP (Single Responsibility Principle)</strong> – “Một class chỉ được có 1 nhiệm vụ” hay nói cách khác, “nếu muốn chỉnh sửa class thì chỉ được phép có 1 và chỉ 1 lý do”.</p><p><strong>OCP (Open/closed principle)</strong> – “Mở class khi cần mở rộng nó, đóng class khi cần chỉnh sửa nó”.</p><p><strong>LSP (Liskov substitution principle)</strong> – “Subtype phải luôn có thể được thay thế bằng supertype”.</p><p><strong>ISP (Interface segregation principle)</strong> – “Việc dùng nhiều interface cho các client khác nhau, tốt hơn là việc chỉ dùng 1 interface cho cùng lúc nhiều mục đích” hay nói cách khác “Không được phép hạn chế access vào những method mà client không sử dụng”.</p><p><strong>DIP (Dependency inversion principle)</strong> – “Module tầng trên không được phụ thuộc vào module tầng dưới. Bất cứ module nào cũng phải phụ thuộc vào cái trừu tượng, không phải vào cái cụ thể”.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nguyen-tac-Demeter&quot;&gt;&lt;a href=&quot;#Nguyen-tac-Demeter&quot; class=&quot;headerlink&quot; title=&quot;Nguyên tắc Demeter&quot;&gt;&lt;/a&gt;Nguyên tắc Demeter&lt;/h2&gt;&lt;p&gt;Còn có tên gọi khác là nguyên tắc “càng biết ít càng tốt”.&lt;/p&gt;
&lt;p&gt;Demeter là tên gọi của Nữ thần nông nghiệp, cũng là nữ thần phân phát trong thần thoại Hi Lạp. Tên bà được dùng để đánh dấu sự ra đời của nguyên tắc này, đây có thể xem là một triết lý nền tảng của việc lập trình được sinh ra từ một aspect-oriented programming (AOP) project cùng tên.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Khi nào nên sử dụng PureComponent hoặc Component</title>
    <link href="http://nthung2112.github.io/2018/10/Khi-nao-nen-su-dung-PureComponent-hoac-Component.html"/>
    <id>http://nthung2112.github.io/2018/10/Khi-nao-nen-su-dung-PureComponent-hoac-Component.html</id>
    <published>2018-10-17T00:57:00.000Z</published>
    <updated>2018-11-07T01:00:18.161Z</updated>
    
    <content type="html"><![CDATA[<p>PureComponent tiền đề của nó là một phiên bản có hiệu suất cao hơn của Component. Điều này là đúng, nhưng hiệu suất đạt được đi cùng với một vài thứ đi kèm. Chúng ta hãy tìm hiểu về PureComponent và hiểu tại sao chúng ta nên sử dụng nó nhé.<br><a id="more"></a></p><h2 id="Component-va-PureComponent-co-mot-su-khac-biet"><a href="#Component-va-PureComponent-co-mot-su-khac-biet" class="headerlink" title="Component và PureComponent có một sự khác biệt"></a>Component và PureComponent có một sự khác biệt</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PureComponent chính xác giống như Component ngoại trừ việc đó là nó xử lý shouldComponentUpdate cho bạn.</span><br></pre></td></tr></table></figure><p>Khi props hoặc state thay đổi, PureComponent sẽ làm một <em>shallow comparison</em> (so sánh nông) trên cảm props và state. Component trên mặt khác sẽ không so sánh props và state của hiện tại với tương lai. Như vậy, component sẽ re-render bởi mặc định bất cứ khi nào shouldComponentUpdate gọi.</p><h2 id="Shallow-Comparison-101"><a href="#Shallow-Comparison-101" class="headerlink" title="Shallow Comparison 101"></a>Shallow Comparison 101</h2><p>Khi so sánh props và state trước và sau, một <em>shallow comparison</em> sẽ kiểm tra những giá trị nguyên thuỷ đó có cùng giá trị(ví dụ 1 bằng 1 hoặc <em>true</em> bằng với <em>true</em>) và rằng các <em>references value</em> là giống nhau giữa các giá trị javascript phức tạp như objects và arrays.</p><h2 id="Never-MUTATE"><a href="#Never-MUTATE" class="headerlink" title="Never MUTATE"></a>Never MUTATE</h2><p>Bạn có lẽ đã nghe không thay đổi objects và arrays trong props và state. Nếu bạn thay đổi object trong một component cha, component “pure” con của bạn sẽ không update. Mặc dù giá trị đã thay đổi ở component cha, component con sẽ so sánh <em>reference</em> tới props trước đó và không phát hiện ra sự khác biệt chúng vân cùng reference tới cùng một object.</p><p>Thay vào đó trả về một objects mới khi bạn làm một sự thay đổi bằng cách tận dụng es6 cho object và array <em>spreading</em> hoặc sử dụng một thư viện để thi hành <em>immutability</em>.</p><h2 id="Co-van-de-voi-hieu-nang-khong"><a href="#Co-van-de-voi-hieu-nang-khong" class="headerlink" title="Có vấn đề với hiệu năng không?"></a>Có vấn đề với hiệu năng không?</h2><p>So sánh primitives và object references là một hoặt động <strong>vô cùng rẻ tiền</strong>. Nếu bạn có một danh sách của object con và một trong đó update, làm một kiểm tra trên props và state của chúng là so sánh nhanh như ánh sáng so với chi phí của việc re-render từng cái một.</p><h1 id="Nhung-cach-khac-ban-co-the-lam-de-tang-hieu-nang"><a href="#Nhung-cach-khac-ban-co-the-lam-de-tang-hieu-nang" class="headerlink" title="Những cách khác bạn có thể làm để tăng hiệu năng"></a>Những cách khác bạn có thể làm để tăng hiệu năng</h1><h3 id="Dung-bind-gia-tri-vao-fuction-trong-render"><a href="#Dung-bind-gia-tri-vao-fuction-trong-render" class="headerlink" title="Đừng bind giá trị vào fuction trong render"></a>Đừng bind giá trị vào fuction trong render</h3><p>Bạn có một danh sách các items, mỗi lần chuyền một tham số độc nhất tới phương thức cha. Theo thứ tự bind parameter bạn có lẽ sẽ hoàn thành như thê này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CommentItem likeComment=&#123;() =&gt; <span class="keyword">this</span>.likeComment(user.id)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>vấn đề đó là mỗi lần component cha render method sẽ gọi, một function mới (với một reference mới) được tạo ra và chuyền xuống <strong>LikeComnent</strong>. Điều này có side effect của thay đổi props trên mỗi component con mà lần lượt sẽ là nguyên nhân tât cả chúng re-render, thậm chí tất cả dữ liệu là giống nhau.</p><p>Để giải quyết vấn đề này, chỉ cần chuyền function nguyên mẫu từ component cha tới con. prop của <strong>LikeComent</strong> sẽ luôn luôn có cùng reference và không bao giờ gây ra re-render không cần thiết.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CommentItem likeComment=&#123;<span class="keyword">this</span>.likeComment&#125; userID=&#123;user.id&#125; /&gt;</span><br></pre></td></tr></table></figure><p>Sau đó trong component con tạo ra một class method sẽ reference props của nó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentItem</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  handleLike() &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.likeComment(<span class="keyword">this</span>.props.userID)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dung-lay-du-lieu-trong-render"><a href="#Dung-lay-du-lieu-trong-render" class="headerlink" title="Đừng lấy dữ liệu trong render"></a>Đừng lấy dữ liệu trong render</h3><p>Xem xét một danh sách của các bài viết từ đó component hồ sơ của bạn sẽ hiển thị 10 người dùng bạn thích nhất.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; posts &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="keyword">const</span> topTen = [...posts].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> </span><br><span class="line">    b.likes - a.likes).slice(<span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TopTen</strong> sẽ có một <em>new reference</em> mỗi lần component re-render, mặc dù <strong>posts</strong> không có sự thay đổi và dữ liệu có cùng nguồn gốc. Điều này sau đó sẽ re-render list một cách không cần thiết.</p><p>Bạn có thể giải quyết điều này bởi <em>caching</em> dữ liệu gốc. Cho ví dụ, đặt dữ liệu gốc trong state của component và update chỉ khi <strong>posts</strong> có updated.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setTopTenPosts(<span class="keyword">this</span>.props.posts)</span><br><span class="line">&#125;</span><br><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.posts !== nextProps.posts) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setTopTenPosts(nextProps.posts)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTopTenPosts(posts) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    topTen: [...posts].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.likes - a.likes).slice(<span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nếu bạn sử dụng Redux, xem xét sử dụng <a href="https://github.com/reduxjs/reselect" target="_blank" rel="noopener">reselect</a> để tạo “selectors” để soạn và cache dữ liệu gốc.</p><h1 id="Tong-ket"><a href="#Tong-ket" class="headerlink" title="Tổng kết"></a>Tổng kết</h1><p>An toàn khi sử dụng pureComponent thay thế Component miễn là bạn theo hai quy tắc đơn giản sau:</p><ol><li>Thay đổi đột ngột <strong>reference value</strong> nhìn chung là không tốt. Nhưng vấn đề là phức tạp khi sử dụng PureComponent.</li><li>Nếu bạn tạo ra một function, object, array mới trong render bạn (có lẽ) làm nó sai.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PureComponent tiền đề của nó là một phiên bản có hiệu suất cao hơn của Component. Điều này là đúng, nhưng hiệu suất đạt được đi cùng với một vài thứ đi kèm. Chúng ta hãy tìm hiểu về PureComponent và hiểu tại sao chúng ta nên sử dụng nó nhé.&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://nthung2112.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Redux hay MobX: Lý giải sự nhầm lẫn</title>
    <link href="http://nthung2112.github.io/2018/09/Redux-hay-MobX-Ly-giai-su-nham-lan.html"/>
    <id>http://nthung2112.github.io/2018/09/Redux-hay-MobX-Ly-giai-su-nham-lan.html</id>
    <published>2018-09-06T00:18:00.000Z</published>
    <updated>2018-11-06T00:20:35.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chung-ta-can-giai-quyet-van-de-gi"><a href="#Chung-ta-can-giai-quyet-van-de-gi" class="headerlink" title="Chúng ta cần giải quyết vấn đề gì?"></a>Chúng ta cần giải quyết vấn đề gì?</h1><p>Tất cả chúng ta đều muốn có một cách nào đó để quản lý state trong một ứng dụng. Nhưng bạn đã bao giờ tự hỏi nó giải quyết được vấn đề gì cho chúng ta chưa? Hầu hết các lập trình viên đều sử dụng một thư viện quản lý state ngay cả đối với những ứng dụng nhỏ. Hiển nhiên thôi mà, khi tất cả những người khác đều nói về chúng, tất nhiên chúng ta cũng phải bắt kịp xu thế chứ? Redux này, MobX này. Thế nhưng hầu hết các ứng dụng lại không cần đến những công cụ quản lý state phức tạp đến vậy. Nó còn nguy hiểm hơn, vì hầu hết mọi người sẽ không bao giờ gặp những vấn đề mà những thư viện như Redux hay MobX cố gắng để giải quyết.<br><a id="more"></a><br>Ngày nay, một hiện trạng mà chúng ta dễ dàng thấy là việc mọi người đều viết ra những frontend app với các component. Component thì có state nội tại. Ví dụ trong React thì state nội tại đó được xử lý bằng this.state và this.setState(). Với những app lớn, vấn đề guản lý state có thể trở nên khó khăn với state nội bộ bởi vì:</p><ul><li>Một component cần phải chia sẻ state với một component khác.</li><li>Một component cần phải thay đổi state của một component khác.</li></ul><p>Đến một lúc nào đó, vấn đề này càng ngày càng trở nên khó giải quyết khi nó trở thành một đống hỗn loạn các state object và các thay đổi diễn ra chồng chéo nhau khắp các component và rất khó để chúng ta có thể quản lý tất cả một cách hiệu quả.</p><p>Suy ra để giải quyết vấn đề này, chúng ta có thể sử dụng thư viện như MobX hay Redux. Những thư viện này cung cấp cho chúng ta công cụ để lưu giữ state, thay đổi state và nhận những thay đổi của state. Bạn có một chỗ để tìm state, một chỗ để thay đổi nó và cũng một chỗ để nhận các thay đổi. Chúng tuân theo nguyên tắc single source of truth (chỉ một nơi để lưu trữ toàn bộ state). Nó làm cho việc quản lý state trở nên dễ dàng hơn vì nó được tách rời khỏi các component của bạn.</p><p>Các thư viện quản lý state như Redux hay MobX thường có các add-on đi kèm, như với React thì chúng ta có react-redux và mobx-react, để cung cấp cho các component cách để truy cập các state. Thường thì các component đó được gọi là container component, hay chính xác hơn là, connected component. Bạn có thể truy cập hoặc thay đổi state từ bất cứ đâu trong ứng dụng của bạn bằng cách biến các component thành các connected component.</p><h1 id="Redux-va-MobX-co-gi-khac-nhau"><a href="#Redux-va-MobX-co-gi-khac-nhau" class="headerlink" title="Redux và MobX có gì khác nhau?"></a>Redux và MobX có gì khác nhau?</h1><p>Trước khi chúng ta nói về những khác biệt, tôi muốn nói về một số điểm chung giữa MobX và Redux.</p><p>Cả 2 thư viện đều được dùng để quản lý state trong các ứng dụng Javascript. Chúng không nhất thiết phải đi kèm với một thư viện như React. Chúng cũng được dùng trong những thư viện khác như AngularJs hay VueJs nữa. Nhưng chúng kết hợp rất tốt với triết lý của React.</p><p>Nếu bạn chọn dùng một thư viện để quản lý state, bạn sẽ không bị ràng buộc bởi nó. Bạn có thể chuyển qua sử dụng một thư viện khác bất kỳ lúc nào. Bạn hoàn toàn có thể chuyển từ MobX sang Redux hoặc ngược lại.</p><p>Redux bởi Dan Abramov và Andrew Clark là một biến thể của kiến trúc flux. Trái ngược với flux, nó chỉ sử dụng duy nhất một store để lưu trữ state. Hơn nữa, thay vì sử dụng một dispatcher, nó dùng các pure function để thay đổi state. Redux bị ảnh hưởng rất nhiều bởi các nguyên tắc của functional programming (FP). Chúng ta có thể có FP trong Javascript, nhưng rất nhiều người đã quen với OOP như Java, và họ gặp rất nhiều khó khăn trong việc ứng dụng các nguyên tắc này. Điều này cũng lý giải tại sao MobX có thể sẽ dễ học hơn đối với người mới.</p><p>Bởi vì Redux áp dụng các nguyên tắc của FP, nó sử dụng hàm thuần khiết. Một hàm nhận input, trả về output và không có thêm bất cứ sự phụ thuộc nào khác. Một hàm thuần khiết luôn trả về cùng một output đối với cùng một input và không hề có side effect.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(state, action) =&gt; newState</span><br></pre></td></tr></table></figure><p>Redux state là <strong>immutable</strong>. Thay vì thay đổi state, bạn luôn trả về một state mới. Bạn không bao giờ trực tiếp thay đổi object state hay phụ thuộc vào tham chiếu đến object.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Đừng làm thế này trong Redux vì nó trực tiếp thay đổi array</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAuthor</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> state.authors.push(action.author);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Luôn giữ state immutable và trả về object mới</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAuthor</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [ ...state.authors, action.author ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Điều cuối cùng nhưng ko kém phần quan trọng, state của bạn được normalize như trong một database. Các entity chỉ tham chiếu đến nhau bằng id. Đó là cách làm tốt nhất. Mặc dù không phải tất cả mọi người đều làm vậy, bạn có thể sử dụng một thư viện như normalizr để đạt được state đã chuẩn hóa. Normalized state giúp cho chúng ta có một state phẳng và lưu giữ các entity như một nguồn duy nhất.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  post: &#123;</span><br><span class="line">    id: <span class="string">'a'</span>,</span><br><span class="line">    authorId: <span class="string">'b'</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  author: &#123;</span><br><span class="line">    id: <span class="string">'b'</span>,</span><br><span class="line">    postIds: [<span class="string">'a'</span>, ...],</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trong khi đó, MobX bởi Michel Weststrate lại chịu ảnh hưởng của lập trình hướng đối tượng, nhưng cũng một phần bởi lập trình phản ứng (Reactive programming). Nó đống gói state của bạn thành những observable. Vì thế bạn có mọi khả năng của một Observable trong state của bạn. Dữ liệu có thể chỉ cần có setter và getter thôi, nhưng observable làm cho chúng ta có khả năng nhận update khi dữ liệu thay đổi.</p><p>Trong MobX, state là <strong>mutable</strong>. Nghĩa là bạn thay đổi state trực tiếp:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAuthor</span>(<span class="params">author</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.authors.push(author);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thêm nữa, các entity tồn tại dưới một cấu trúc dữ liệu lồng nhau. Bạn không cần chuẩn hóa state. State được giữ không chuẩn hóa và có thể lồng nhiều tầng.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  post: &#123;</span><br><span class="line">    id: <span class="string">'a'</span>,</span><br><span class="line">    ...</span><br><span class="line">    author: &#123;</span><br><span class="line">      id: <span class="string">'b'</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-Store-va-nhieu-Store"><a href="#1-Store-va-nhieu-Store" class="headerlink" title="1 Store và nhiều Store"></a>1 Store và nhiều Store</h3><p>Trong Redux bạn giữ mọi state trong một global store/global state. State object này là nguồn dữ liệu duy nhất của bạn. Mặt khác, chúng ta sử dụng nhiều reducer để thay đổi state này.</p><p>Trái lại, MobX lại dùng nhiều store. Tương tự như reducer của Redux, bạn có thể áp dụng chia để trị bằng cách phân bổ chúng thành nhiều tầng dữ liệu. Bạn có thể muốn có các domain entity trong một store riêng nhưng vẫn có khả năng kiểm soát state của view trong một trong các store của bạn. Sau cùng thì bạn là người quyết định và định hướng lại cấu trúc state nào có lợi cho ứng dụng của bạn nhất.</p><p>Trên lý thuyết bạn cũng có thể có nhiều store trong Redux. Không có ai bắt bạn phải dùng chỉ một store cả. Nhưng đó không phải là cách người ta khuyên dùng Redux. Nó sẽ làm trái lại những best practice nếu bạn dùng nhiều store. Trong Redux bạn chỉ cần có một store thôi và phản ứng với những thay đổi thông qua reducer và các global event.</p><h3 id="Implementation-nhin-nhu-the-nao"><a href="#Implementation-nhin-nhu-the-nao" class="headerlink" title="Implementation nhìn như thế nào?"></a>Implementation nhìn như thế nào?</h3><p>Trong Redux, bạn sẽ cần đoạn code như dưới đây để thêm một user vào global state. Bạn có thể thấy chúng ta có thể sử dụng spread operator để trả về một state object mới. Bạn cũng có thể dùng Object.assign() để tạo ra một immutable object trong ES5.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  users: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Dan'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Michel'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">users</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'USER_ADD'</span>:</span><br><span class="line">    <span class="keyword">return</span> &#123; ...state, <span class="attr">users</span>: [ ...state.users, action.user ] &#125;;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// action</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'USER_ADD'</span>, <span class="attr">user</span>: user &#125;;</span><br></pre></td></tr></table></figure><p>Bạn sẽ cần phải gọi dispatch({ type: ‘USER_ADD’, user: user }); để thêm một user mới vào global state.</p><p>Trong MobX, một store sẽ chỉ quản lý một substate (như một reducer trong Redux quản lý một substate) nhưng bạn có thể thay đổi state một cách trực tiếp. Annotation @observable giúp cho chúng ta có khả năng nhận update khi state thay đổi.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserStore</span> </span>&#123;</span><br><span class="line">  @observable users = [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Dan'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Michel'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Giờ thì chúng ta có thể gọi userStore.users.push(user); vào một instance của store. Tuy vậy best practice đó là xử lý việc thay đổi state rõ ràng hơn với các action.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserStore</span> </span>&#123;</span><br><span class="line">  @observable users = [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Dan'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Michel'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  @action addUser = <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.users.push(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bạn có thể bắt buộc việc sử dụng action bằng cách cấu hình Mobx với configure({ enforceActions: true });. Giờ thì bạn có thể thay đổi state bằng cách gọi userStore.addUser(user); với một instance của store.</p><p>Bạn đã thấy cách chúng ta cập nhật state trong cả Redux và MobX. Chúng rất khác nhau. Trong Redux state của bạn là read-only. Bạn chỉ có thể thay đổi state bằng các action rõ ràng. Ngược lại, state trong MobX lại có thể vừa read và vừa write. Bạn có thể thay đổi state trực tiếp mà không cần dùng action, nhưng bạn cũng có thể bắt buộc sử dụng action với cấu hình đã nói ở trên.</p><h1 id="Learning-curve-cua-quan-ly-state-trong-React"><a href="#Learning-curve-cua-quan-ly-state-trong-React" class="headerlink" title="Learning curve của quản lý state trong React"></a>Learning curve của quản lý state trong React</h1><p>Cả Redux và MobX đều hầu hết được sử dụng trong các ứng dụng React. Nhưng bản chất của chúng thì là những thư viện quản lý state độc lập, và có thể được dùng mà không cần đến React. Chúng còn có những thư viện hỗ trợ tương thích để làm cho việc kết hợp với React component trở nên dễ dàng hơn, đó là react-redux cho Redux + React và mobx-react cho MobX + React.</p><p>Trong những thảo luận trên các diễn đàn công nghệ thì một vấn đề mà người ta hay nói đến đó là learning curve của Redux. Thường thì nó diễn ra trong bối cảnh mọi người bắt đầu học React nhưng đã muốn tìm hiểu là làm thế nào để quản lý state với Redux. Nhiều người sẽ cho rằng React và Redux nằm riêng thì có một learning curve khá tốt, nhưng kết hợp cả 2 lại thì chúng lại khó hiểu hơn nhiều. Vì thế MobX được coi là một giải pháp thay thế vì nó phù hợp hơn với những người mới học.</p><p>Tuy vậy, tôi muốn gợi ý một cách tiếp cận khác cho các bạn mới học React về vấn đề quản lý state, đó là bắt đầu với chính những tính năng quản lý state nội bộ của component. Trong một ứng dụng React, điều đầu tiên mà bạn sẽ học đó là các hàm nằm trong vòng đời của một component và làm thế nào để quản lý state bằng setState() và this.state. Đây là một cách học mà tôi đánh giá rất cao. Nếu không theo cách này, bạn sẽ rất dễ bị choáng ngợp bởi hệ sinh thái của React. Đến một thời điểm nào đó với cách học này, bạn sẽ nhận ra rằng việc quản lý các state nội bộ của component càng ngày càng trở nên khó hơn. Đó là lúc mà chúng ta trả lời câu hỏi: Vấn đề mà MobX và Redux giải quyết cho chúng ta là gì? Cả 2 đều cung cấp một cách để quản lý state của ứng dụng độc lập với các component. State được tách biệt hoàn toàn khỏi component. Component có thể truy cập state, thay đổi nó và nhận những cập nhật với state mới. State đó chính là single source of truth.</p><h3 id="Redux-hay-MobX-cho-nguoi-moi"><a href="#Redux-hay-MobX-cho-nguoi-moi" class="headerlink" title="Redux hay MobX cho người mới?"></a>Redux hay MobX cho người mới?</h3><p>Một khi bạn đã quen với việc sử dụng component và quản lý state nội bộ, bạn có thể chọn một thư viện để giải quyết vấn đề này. Sau khi đã dùng cả 2 thư viện, tôi cho rằng MobX rất phù hợp đối với người mới. Chúng ta đều đã thấy MobX cần ít code hơn, dù cho nó sử dụng vài loại annotation mà có lẽ chúng ta chưa cần hiểu về chúng.</p><p>Với MobX bạn không cần phải làm quen với lập trình hàm hay phải hiểu những thuật ngữ như immutability. Lập trình hàm là một mô hình đang phát triển rất nhanh, nhưng lại xa lạ với hầu hết các lập trình viên Javascript. Dù thế giới lập trình đang dần được đẩy theo xu hướng này nhưng không phải ai cũng có kinh nghiệm về nó, nên các nguyên lý của MobX sẽ dễ dàng để hiểu hơn đối với những người đã biết về hướng đối tượng.</p><h3 id="Mot-ung-dung-dang-phat-trien"><a href="#Mot-ung-dung-dang-phat-trien" class="headerlink" title="Một ứng dụng đang phát triển"></a>Một ứng dụng đang phát triển</h3><p>Trong MobX, bạn thay đổi object có annotation và component của bạn sẽ tự động render lại. MobX đem đến nhiều xử lý nội bộ hơn là Redux, nên sẽ làm cho nó dễ dùng hơn lúc đầu vì bạn phải viết ít code hơn. Nếu bạn đã biết Angular thì sẽ thấy dùng MobX giống như là two-way data binding vậy. Bạn giữ một vài state ở đâu đó, theo dõi state bằng annotation và để cho component tự update một khi state thay đổi.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// component</span></span><br><span class="line">&lt;button onClick=&#123;() =&gt; store.users.push(user)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>Cách tốt hơn để làm điều này đó là sử dụng <a href="https://viblo.asia/u/action" target="_blank" rel="noopener">@action</a> trong store.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// component</span></span><br><span class="line">&lt;button onClick=&#123;() =&gt; store.addUser(user)&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store</span></span><br><span class="line">@action addUser = <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.users.push(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nó sẽ làm cho việc thay đổi state trở nên minh bạch hơn với các action. Hơn nữa chúng ta cũng có thể bắt buộc việc sử dụng action để thay đổi state bằng cách mà tôi đã nói ở trên.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root file</span></span><br><span class="line"><span class="keyword">import</span> &#123; configure &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"></span><br><span class="line">configure(&#123; <span class="attr">enforceActions</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>Việc thay đổi state trực tiếp trong store như chúng ta đã làm ở ví dụ thứ nhất sẽ không còn hoạt động nữa. Việc sử dụng action là một trong các best practice của MobX. Hơn nữa một khi bạn chỉ dùng action, bạn đã áp dụng các ràng buộc của Redux.</p><p>Tôi xin gợi ý rằng chúng ta nên sử dụng MobX để bắt đầu một dự án. Một khi ứng dụng đã bắt đầu to lên, đó cũng là điều dễ hiểu khi chúng ta bắt buộc việc sử dụng các action. Điều này cũng đi theo đường lối của Redux đó là chúng ta không bao giờ thay đổi trực tiếp state mà lúc nào cũng phải thông qua các action.</p><h3 id="Chuyen-sang-Redux"><a href="#Chuyen-sang-Redux" class="headerlink" title="Chuyển sang Redux"></a>Chuyển sang Redux</h3><p>Khi mà ứng dụng của bạn lớn dần và có thêm nhiều dev cùng làm việc, bạn nên chuyển qua dùng Redux. Bản chất của nó là việc nó bắt buộc sử dụng action để thay đổi state chứ không thông qua config như MobX. Action bao gồm kiểu và một payload và reducer có thể dùng để thay đổi state.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducer</span></span><br><span class="line">(state, action) =&gt; newState</span><br></pre></td></tr></table></figure><p>Redux cung cấp cho bạn cả một cấu trúc để quản lý state với những ràng buộc rõ ràng. Đó là <a href="https://www.youtube.com/watch?v=uvAXVMwHJXU" target="_blank" rel="noopener">lý do mà Redux rất thành công.</a></p><p>Một điểm mạnh khác của Redux đó là việc sử dụng nó ở server side. Bởi vì chúng ta đang làm việc với Javascript object, bạn có thể gửi state qua mạng được. Serialize và deserialize các state object hoạt động một cách tự động mà bạn không cần làm thêm gì cả. Bạn cũng có thể làm như thế với MobX nữa.</p><p>MobX thì không có nhiều ràng buộc nhưng bạn cũng có thể tự tạo ra chúng bằng các config. Đó là lí do tại sao tôi không nói là bạn không thể dùng MobX với những ứng dụng lớn, nhưng Redux thì giúp chúng ta có một cách làm nhất quán hơn. Doc của MobX cũng có nói là: “MobX không hướng dẫn cho bạn cách bạn cấu trúc code, lưu state ở đâu hay xử lý các event như thế nào.” Team của bạn cần phải tự cấu trúc việc quản lý state nếu sử dụng thư viện này.</p><p>Cuối cùng thì việc học quản lý state không khó như chúng ta nghĩ. Để tóm gọn lại vấn đề, một người mới học React đầu tiên sẽ học cách sử dụng setState() và this.state. Sau một thời gian thì họ sẽ thấy khó khăn với việc chỉ dùng setState() để quản lý state cho cả ứng dụng. Khi đi tìm giải pháp, họ gặp được những thư viện như MobX hay Redux. Nhưng nên chọn cái nào bây giờ? Bởi vì MobX có ít ràng buộc hơn, cần ít code hơn và dùng cũng tương tự như setState(), tôi nghĩ nó rất thích hợp với các ứng dụng vừa và nhỏ. Một khi ứng dụng đã to dần lên, bạn nên xem xét việc tạo ra thêm ràng buộc bằng config trong MobX hoặc chuyển sang dùng Redux.</p><h1 id="Loi-ket"><a href="#Loi-ket" class="headerlink" title="Lời kết"></a>Lời kết</h1><p>Mỗi khi tôi đọc comment về tranh luận giữa Redux và MobX, luôn luôn có 1 comment kiểu này: “Redux có quá nhiều code thừa, bạn nên dùng MobX đi. Tôi đã bỏ được XXX dòng code đấy.” Comment này có thể đúng, nhưng họ chưa xem xét đến những sự đánh đổi. Redux có nhiều code thừa hơn MobX, vì nó được thêm vào vì những ràng buộc cụ thể trong thiết kế. Nó cho phép bạn có cái nhìn tổng quan hơn về state của ứng dụng dù ứng dụng đó lớn thế nào. Không phải tự nhiên mà nó là một trong những thư viện phổ biến nhất đâu.</p><p>Thư viện Redux có kích thước khá là nhỏ. Hầu hết thời gian bạn sẽ dành để xử lý Javascript object và array. Nó giống với Javascript thuần hơn là MobX. Trong MobX, chúng ta gói object và array vào trong observable object và điều này giấu đi hầu hết các boilerplate code. Nó được xây dựng dựa trên tính trừu tượng ẩn. Nó sẽ thực hiện một phép thuật nào đó và code bạn tự nhiên chạy được, nhưng đồng thời cũng làm cho các cơ chế ở tầng dưới trở nên khó hiểu hơn nhiều. Với Redux thì chúng ta test và debug ứng dụng dễ hơn vì nó chỉ sử dụng Javascript thuần.</p><p>Trong khi với Redux, chúng ta có một cách nhất định để làm mọi thứ thì MobX lại ít ràng buộc hơn. Nhưng dù vậy chúng ta vẫn nên tuân theo các best practice trong MobX, vì như thế sẽ dễ dàng hơn trong việc lí giải thay đổi của state.</p><p>Cả 2 thư viện đều rất tốt. Trong khi Redux đã được chứng minh trong thế giới React, MobX đang dần trở thành một giải pháp thay thế đáng chú ý.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Chung-ta-can-giai-quyet-van-de-gi&quot;&gt;&lt;a href=&quot;#Chung-ta-can-giai-quyet-van-de-gi&quot; class=&quot;headerlink&quot; title=&quot;Chúng ta cần giải quyết vấn đề gì?&quot;&gt;&lt;/a&gt;Chúng ta cần giải quyết vấn đề gì?&lt;/h1&gt;&lt;p&gt;Tất cả chúng ta đều muốn có một cách nào đó để quản lý state trong một ứng dụng. Nhưng bạn đã bao giờ tự hỏi nó giải quyết được vấn đề gì cho chúng ta chưa? Hầu hết các lập trình viên đều sử dụng một thư viện quản lý state ngay cả đối với những ứng dụng nhỏ. Hiển nhiên thôi mà, khi tất cả những người khác đều nói về chúng, tất nhiên chúng ta cũng phải bắt kịp xu thế chứ? Redux này, MobX này. Thế nhưng hầu hết các ứng dụng lại không cần đến những công cụ quản lý state phức tạp đến vậy. Nó còn nguy hiểm hơn, vì hầu hết mọi người sẽ không bao giờ gặp những vấn đề mà những thư viện như Redux hay MobX cố gắng để giải quyết.&lt;br&gt;
    
    </summary>
    
    
      <category term="mobx" scheme="http://nthung2112.github.io/tags/mobx/"/>
    
      <category term="redux" scheme="http://nthung2112.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>Cách tối ưu trang web của bạn với nén Gzip</title>
    <link href="http://nthung2112.github.io/2018/08/Cach-toi-uu-trang-web-cua-ban-voi-nen-Gzip.html"/>
    <id>http://nthung2112.github.io/2018/08/Cach-toi-uu-trang-web-cua-ban-voi-nen-Gzip.html</id>
    <published>2018-08-07T13:45:00.000Z</published>
    <updated>2018-09-07T13:53:33.634Z</updated>
    
    <content type="html"><![CDATA[<p>Nén là một phương pháp đơn giản, hiệu quả để tiết kiệm băng thông và tăng tốc trang web của bạn. Tôi đã ngần ngại khi gợi ý sử dụng nén gzip khi <a href="https://betterexplained.com/articles/speed-up-your-javascript-load-time/" target="_blank" rel="noopener">tăng tốc tải file javascript của bạn</a> vì một vài vấn đề ở trình duyệt cũ.</p><p>Nhưng giờ là thế kỷ 21. Hầu hết các truy cập đến trang của tôi đều từ các trình duyệt hiện đại, và thẳng thắn mà nói, hầu hết người dùng của tôi đều am hiểu công nghệ. Tôi không muốn làm mọi người chậm lại vì một vài người đang bám lấy IE 4 trên Windows 95. Google và Yahoo dùng nén gzip. Một trình duyệt hiện đại cần được tận hưởng nội dung và tốc độ của web hiện đại - vậy thì sử dụng gzip mã hóa nó. Dưới đây là cách cài đặt.<br><a id="more"></a></p><h2 id="Khoan-khoan-khoan-tai-sao-chung-ta-lai-lam-dieu-nay"><a href="#Khoan-khoan-khoan-tai-sao-chung-ta-lai-lam-dieu-nay" class="headerlink" title="Khoan, khoan, khoan: tại sao chúng ta lại làm điều này?"></a>Khoan, khoan, khoan: tại sao chúng ta lại làm điều này?</h2><p>Trước khi chúng ta bắt đầu, tôi nên giải thích nội dung được mã hóa là gì. Khi bạn yêu cầu một file, ví dụ như <code>http://www.yahoo.com/index.html</code>, trình duyệt của bạn nói chuyện với một web server. Đoạn hội thoại sẽ diễn ra kiểu như sau:</p><p><img src="https://betterexplained.com/wp-content/uploads/compression/HTTP_request.png" alt=""></p><ol><li>Trình duyệt: Này, <strong>GET</strong> cho tôi /index.html</li><li>Server: Ok, để tôi tìm xem index.html có không</li><li>Server: Tìm thấy rồi! Mã phản hồi của anh đây (200 OK) và tôi đang gửi file.</li><li>Trình duyệt: 100KB? Ôi… chờ tí, chờ tí… ok, tải được rồi nhé.</li></ol><p>Dĩ nhiên, header và giao thức thực tế sẽ hình thức hơn nhiều (quan sát chúng với <a href="https://betterexplained.com/articles/how-to-debug-web-applications-with-firefox/" target="_blank" rel="noopener">Live HTTP Headers</a> nếu bạn muốn).</p><p>Nhưng nó hoạt động, và bạn nhận được file.</p><h2 id="The-van-de-la-gi"><a href="#The-van-de-la-gi" class="headerlink" title="Thế vấn đề là gì?"></a>Thế vấn đề là gì?</h2><p>Chà, hệ thống hoạt động, nhưng không hiệu quả. 100KB là <strong>một đống text</strong>, và thành thật thì, HTML khá là trùng lặp. Mỗi thẻ <html>, <table> và <div> đều có một thẻ đóng gần như tương tự. Các từ lặp đi lặp lại trong cả document. Bạn chia nó ra như thế nào thì HTML (và người anh em mạnh mẽ của nó, XML) đều không tinh gọn.</div></table></html></p><p>Và xử lý thế nào với một file quá lớn? Nén nó!</p><p>Nếu chúng ta có thể gửi một file .zip đến trình duyệt (index.html.zip) thay vì index.html thông thường, chúng ta sẽ tiết kiệm được băng thông và thời gian tải. Trình duyệt có thể tải file đã nén, giải nén nó, và sau đó hiển thị cho người dùng, người đang có tâm trạng tốt vì trang tải nhanh. Đoạn hội thoại giữa trình duyệt và server sẽ trông như sau:</p><p><img src="https://betterexplained.com/wp-content/uploads/compression/HTTP_request_compressed.png" alt=""></p><ol><li>Trình duyệt: Này, tôi có thể <strong>GET</strong> index.html không? Tôi sẽ lấy phiên bản nén của nó nếu anh có.</li><li>Server: Để tôi tìm… ừ, có đây. Và anh sẽ lấy bản nén? Tuyệt.</li><li>Server: Ok, tôi tìm thấy index.html (200 OK), và tôi đang nén và gửi nó qua cho anh.</li><li>Trình duyệt: Tuyệt! Chỉ có mỗi 10KB. Tôi sẽ giải nén và hiển thị cho người dùng.</li></ol><p>Công thức rất đơn giản: File nhỏ hơn = tải nhanh hơn = <strong>người dùng hạnh phúc</strong>.</p><p>Không tin tôi à? Phần HTML của trang chủ của Yahoo giảm từ 101KB xuống còn 15KB sau khi nén:</p><p><img src="https://betterexplained.com/wp-content/uploads/compression/yahoo.png" alt=""></p><h2 id="Chi-tiet-khong-qua-lang-nhang"><a href="#Chi-tiet-khong-qua-lang-nhang" class="headerlink" title="Chi tiết (không quá) lằng nhằng"></a>Chi tiết (không quá) lằng nhằng</h2><p>Phần khó trong quá trình trao đổi này là trình duyệt và server phải biết rằng việc gửi nhận file nén là được chấp nhận. Việc đồng ý này bao gồm 2 phần</p><ul><li><strong>Trình duyệt gửi một header</strong> nói với server rằng nó chấp nhận nội dung được nén (gzip và deflate là 2 cách nén): <code>Accept-Encoding: gzip, deflate</code></li><li><strong>Server gửi một phản hồi</strong> nếu nội dung thực sự được nén: <code>Content-Encoding: gzip</code></li></ul><p>Nếu server không gửi content-encoding trong header của phản hồi, điều đó có nghĩa là file không được nén (điều mặc định ở nhiều server). Header “Accept-Encoding” chỉ là một yêu cầu từ trình duyệt, không phải mệnh lệnh. Nếu server không muốn gửi về nội dung được nén, trình duyệt sẽ phải tải về phiên bản nặng nề thông thường.</p><h2 id="Thiet-lap-server"><a href="#Thiet-lap-server" class="headerlink" title="Thiết lập server"></a>Thiết lập server</h2><p>“Tin tốt” là chúng ta không thể kiểm soát được trình duyệt. Nó sẽ gửi header <code>Accept-Encoding: gzip, deflate</code> hoặc là không.</p><p>Công việc của chúng ta là cấu hình server để nó trả về nội dung được nén nếu trình duyệt có thể xử lý, tiết kiệm băng thông cho mọi người (và đem lại một người dùng hạnh phúc).</p><p>Đối với IIS, <a href="https://technet.microsoft.com/en-us/library/cc771003(WS.10" target="_blank" rel="noopener">bật cấu hình nén</a>.aspx) ở trong cài đặt.</p><p>Trong Apache, <a href="https://httpd.apache.org/docs/2.0/mod/mod_deflate.html" target="_blank" rel="noopener">bật cấu hình nén nội dung xuất</a> khá là đơn giản. Thêm các dòng sau vào file .htaccess:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># compress text, html, javascript, css, xml:</span><br><span class="line">AddOutputFilterByType DEFLATE text/plain</span><br><span class="line">AddOutputFilterByType DEFLATE text/html</span><br><span class="line">AddOutputFilterByType DEFLATE text/xml</span><br><span class="line">AddOutputFilterByType DEFLATE text/css</span><br><span class="line">AddOutputFilterByType DEFLATE application/xml</span><br><span class="line">AddOutputFilterByType DEFLATE application/xhtml+xml</span><br><span class="line">AddOutputFilterByType DEFLATE application/rss+xml</span><br><span class="line">AddOutputFilterByType DEFLATE application/javascript</span><br><span class="line">AddOutputFilterByType DEFLATE application/x-javascript</span><br><span class="line"></span><br><span class="line"># Or, compress certain file types by extension:</span><br><span class="line">&lt;files *.html&gt;</span><br><span class="line">SetOutputFilter DEFLATE</span><br><span class="line">&lt;<span class="regexp">/files&gt;</span></span><br></pre></td></tr></table></figure><p>Apache có 2 tùy chọn nén:</p><ul><li><strong>mod_deflate</strong> dễ dàng cài đặt và là chuẩn.</li><li><strong>mod_gzip</strong> có vẻ mạnh hơn: bạn có thể nén trước nội dung.</li></ul><p>Deflate nhanh và hoạt động được, nên tôi sử dụng nó; dùng mod_gzip nếu bạn thấy thích. Trong cả 2 trường hợp, Apache đều kiểm tra xem trình duyệt có gửi header “Accept-Encoding” không và gửi lại phiên bản nén hoặc phiên bản thường của file. tuy nhiên, một số trình duyệt cũ sẽ phát sinh vấn đề (chi tiết bên dưới) và có một số chỉ lệnh đặc biệt mà bạn có thể thêm vào để sửa.</p><p>Nếu bạn không thể thay đổi file .htaccess, bạn có thể <a href="https://perishablepress.com/press/2007/03/26/fast-effective-php-compression/" target="_blank" rel="noopener">dùng PHP</a> để trả về nội dung nén. Thêm phần mở rộng .php vào file html của bạn và thêm đoạn code này ở đầu file:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (substr_count($_SERVER[‘HTTP_ACCEPT_ENCODING’], ‘gzip’))</span><br><span class="line">   ob_start(“ob_gzhandler”);</span><br><span class="line"><span class="keyword">else</span> ob_start();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>Chúng ta kiểm tra header “Accept-Encoding” và trả về phiên bản nén gzip của file (ngược lại là phiên bản thường). Việc này gần như là tự xây dựng webserver của bạn (rất thú vị!). Nhưng thực sự thì, hãy thử sử dụng Apache để nén nội dung trả về nến bạn có thể. Bạn không muốn nghịch ngợm mấy file của mình đâu.</p><h2 id="Xac-minh-noi-dung-nen-cua-ban"><a href="#Xac-minh-noi-dung-nen-cua-ban" class="headerlink" title="Xác minh nội dung nén của bạn"></a>Xác minh nội dung nén của bạn</h2><p>Khi bạn đã cấu hình xong server của mình, hãy kiểm tra để đảm bảo rằng bạn thực sự trả về nội dung nén.</p><ul><li><strong>Online</strong>: sử dụng <a href="http://www.gidnetwork.com/tools/gzip-test.php" target="_blank" rel="noopener">công cụ kiểm tra gzip online</a> để kiểm tra liệu trang của bạn có được nén không.</li><li><strong>Trên trình duyệt</strong>: trong Chrome, mở Developer Tools &gt; Network (Firefox/IE sẽ tương tự). Tải lại trang, và nhấn vào dòng network tương ứng với trang (ví dụ <a href="http://www.google.com)" target="_blank" rel="noopener">www.google.com)</a>. Header <code>Content-Encoding: gzip</code> nghĩa là nội dung trả về đã được nén.</li></ul><p><img src="https://betterexplained.com/wp-content/uploads/2007/04/chrome-gzip-header.png" alt=""></p><p>Nhấn biểu tượng “Use large rows” để hiển thị thêm thông tin, bao gồm cả kích cỡ file nén và kích cõ thực.</p><p><img src="https://betterexplained.com/wp-content/uploads/2007/04/request-size.png" alt=""></p><p>Hãy chuẩn bị cho điều kỳ diệu ở kết quả. <a href="http://instacalc.com/" target="_blank" rel="noopener">Trang chủ của instacalc</a> thu lại từ 36k xuống còn 10k, giảm 75% kích cỡ.</p><h2 id="Thu-mot-so-vi-du"><a href="#Thu-mot-so-vi-du" class="headerlink" title="Thử một số ví dụ"></a>Thử một số ví dụ</h2><p>Tôi đã làm một số trang và một <a href="https://betterexplained.com/examples/compressed/compression-example.zip" target="_blank" rel="noopener">ví dụ cho phép tải về</a>:</p><ul><li><a href="https://betterexplained.com/examples/compressed/index.html" target="_blank" rel="noopener">index.html</a> - không nén (trên server này, tôi mặc định sử dụng nén)</li><li><a href="https://betterexplained.com/examples/compressed/index.htm" target="_blank" rel="noopener">index.htm</a> - nén với Apache .htaccess sử dụng luật *.htm</li><li><a href="https://betterexplained.com/examples/compressed/index.php" target="_blank" rel="noopener">index.php</a> - nén sử dụng PHP header</li></ul><p>Cứ thoải mái tải file, để chúng trong server của bạn và chỉnh sửa các cài đặt.</p><h2 id="Luu-y"><a href="#Luu-y" class="headerlink" title="Lưu ý"></a>Lưu ý</h2><p>Dù khá thú vị nhưng HTTP Compression cũng chứa một số vấn đề. Dưới đây là những thứ cần phải coi chừng:</p><ul><li><strong>Trình duyệt cũ</strong>: Phải, một số trình duyệt vẫn còn có rắc rối với nội dung nén (chúng nói rằng có thể chấp nhận nội dung nén, nhưng thực sự thì không thể). Nếu trang của bạn bắt buộc phải hoạt động với Netscape 1.0 trên Windows 95, bạn có lẽ sẽ không muốn dùng HTTP Compression. Apache mod_deflate có <a href="https://httpd.apache.org/docs/2.0/mod/mod_deflate.html#recommended" target="_blank" rel="noopener">một số luật</a> cho phép tránh việc nén trên một số trình duyệt cũ.</li><li><strong>Nội dung đã nén</strong>: Hầu hết ảnh, nhạc và video đều đã được nén. Đừng tốn thời gian nén chúng lần nữa. Trên thực tế, bạn sẽ chỉ muốn nén “big 3” (HTML, CSS và Javascript).</li><li><strong>CPU-load</strong>: nén nội dung khi nhận được yêu cầu sẽ tiêu tốn thời gian của CPU và tiết kiệm băng thông. Thường thì đây là sự đánh đổi tốt nếu biết tốc độ nén. Có nhiều cách để nén trước các nội dung tĩnh và gửi các bản nén này. Việc này cần được cấu hình thêm; cho dù không thể thì việc nén nội dung trả về vẫn là điều tốt. Sử dụng CPU cho người dùng có trải nghiệm nhanh hơn cũng khá là đáng, khi sự chú ý không đáng kể.</li></ul><p>Nén là một trong những cách nhanh nhất để cải thiện hiệu năng cho trang web của bạn. Hãy đi, cài đặt, và để cho người dùng của bạn thận hưởng lợi ích nó mang lại.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nén là một phương pháp đơn giản, hiệu quả để tiết kiệm băng thông và tăng tốc trang web của bạn. Tôi đã ngần ngại khi gợi ý sử dụng nén gzip khi &lt;a href=&quot;https://betterexplained.com/articles/speed-up-your-javascript-load-time/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tăng tốc tải file javascript của bạn&lt;/a&gt; vì một vài vấn đề ở trình duyệt cũ.&lt;/p&gt;
&lt;p&gt;Nhưng giờ là thế kỷ 21. Hầu hết các truy cập đến trang của tôi đều từ các trình duyệt hiện đại, và thẳng thắn mà nói, hầu hết người dùng của tôi đều am hiểu công nghệ. Tôi không muốn làm mọi người chậm lại vì một vài người đang bám lấy IE 4 trên Windows 95. Google và Yahoo dùng nén gzip. Một trình duyệt hiện đại cần được tận hưởng nội dung và tốc độ của web hiện đại - vậy thì sử dụng gzip mã hóa nó. Dưới đây là cách cài đặt.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Functional trong Javascript với ES6 Recursive Patterns</title>
    <link href="http://nthung2112.github.io/2018/07/Functional-trong-Javascript-voi-ES6-Recursive-Patterns.html"/>
    <id>http://nthung2112.github.io/2018/07/Functional-trong-Javascript-voi-ES6-Recursive-Patterns.html</id>
    <published>2018-07-24T05:28:00.000Z</published>
    <updated>2018-09-07T13:27:14.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What’s-the-deal-here"><a href="#What’s-the-deal-here" class="headerlink" title="What’s the deal here?"></a>What’s the deal here?</h3><p>Functional programming has been on the rise and is a topic that is very exciting to me. It allows me to write terse, declarative code that is easy to test and reason about. What is functional programming? I’ll defer that answer to someone with more knowledge on the subject, <a href="https://medium.com/@_ericelliott" target="_blank" rel="noopener">Eric Elliot</a>:</p><blockquote><p><strong>Functional programming</strong> (often abbreviated FP) is the process of building software by composing <strong>pure functions</strong>, avoiding <strong>shared state,</strong> <strong>mutable data</strong>,and <strong>side-effects</strong>. Functional programming is <strong>declarative</strong> rather than <strong>imperative</strong>, and application state flows through pure functions. Contrast with object oriented programming, where application state is usually shared and colocated with methods in objects.</p></blockquote><a id="more"></a><p>ES6 brings many features that allow us to easily write pure functions, rest/spread being one of the most powerful. Using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="noopener">rest params</a>, we’re able to “loop without loops” with <a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29" target="_blank" rel="noopener">recursion</a>. In this article, we’re going to rewrite many commonly used JavaScript methods/functions that allow for functional patterns.</p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>The following functions are for demonstration and learning purposes. Many functions below are tail-recursive and should be optimized further. Fixing tail-recursion is not the subject of this article. ES6 brings tail-call optimization, but must be used in conjunction with <code>&#39;use strict&#39;</code> .</p><h3 id="Head"><a href="#Head" class="headerlink" title="Head"></a>Head</h3><p>Return the first item in an array. Is useful when you need to separate the first item from the rest of the array items. To do this, we make use of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">destructuring assignment</a>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> head = <span class="function">(<span class="params">[x]</span>) =&gt;</span> x</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">head(array) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="Tail"><a href="#Tail" class="headerlink" title="Tail"></a>Tail</h3><p>Return all but the first item in an array.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tail = <span class="function">(<span class="params">[, ...xs]</span>) =&gt;</span> xs</span><br></pre></td></tr></table></figure><p>Which is essentially the same as writing:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tail = <span class="function">(<span class="params">[x, ...xs]</span>) =&gt;</span> xs</span><br></pre></td></tr></table></figure><p>Since we don’t need to use <code>x</code> in the returned output, we can drop it, but keep the comma to get the rest of the items in the array.</p><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">tail(array) <span class="comment">// [2,3,4,5]</span></span><br></pre></td></tr></table></figure><h3 id="Def"><a href="#Def" class="headerlink" title="Def"></a>Def</h3><p>Return if argument supplied is defined.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> def = <span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">typeof</span> x !== <span class="string">'undefined'</span></span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defined = <span class="string">'this is defined'</span></span><br><span class="line">def(defined) <span class="comment">// true</span></span><br><span class="line">def(doesntExist) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Undef"><a href="#Undef" class="headerlink" title="Undef"></a>Undef</h3><p>Return if argument supplied is undefined.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> undef = <span class="function"><span class="params">x</span> =&gt;</span> !def(x)</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defined = <span class="string">'this is defined'</span></span><br><span class="line">undef(defined) <span class="comment">// false</span></span><br><span class="line">undef(doesntExist) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h3><p>Returns a copy of an array without using <code>Array.slice()</code>. Makes use of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="noopener">spread</a>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> copy = <span class="function"><span class="params">array</span> =&gt;</span> [...array]</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> copied = copy(array)</span><br><span class="line">copied.push(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">array <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">copied <span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><h3 id="Length"><a href="#Length" class="headerlink" title="Length"></a>Length</h3><p>Return the length of an array. This is a very simple form of looping through an array with recursion, even though the values of the array don’t matter in this case (increments up starting at 1 for every item in array). We include the <strong>len</strong> param to avoid <a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener">tail recursion</a>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> length = <span class="function">(<span class="params">[x, ...xs], len = <span class="number">0</span></span>) =&gt;</span> def(x) ? length(xs, len + <span class="number">1</span>) : len</span><br></pre></td></tr></table></figure><p>If we don’t care about tail recursion, we can write it as:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> length = <span class="function">(<span class="params">[x, ...xs]</span>) =&gt;</span> def(x) ? <span class="number">1</span> + length(xs) : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>This would add a stack frame for each item in the array, whereas the version that avoids tail recursion, replaces a single stack frame. If the array passed in is large enough, it will throw “Maximum call stack size exceeded”.</p><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">length(array) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><p>Return a reversed array.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverse = <span class="function">(<span class="params">[x, ...xs]</span>) =&gt;</span> def(x) ? [...reverse(xs), x] : []</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">reverse(array) <span class="comment">// [5,4,3,2,1]</span></span><br></pre></td></tr></table></figure><p><code>Array.reverse()</code> is okay, but it modifies the value in place which is a side-effect. Consider the following:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newArray = array.reverse() <span class="comment">// [5,4,3,2,1]</span></span><br><span class="line">array <span class="comment">// [5,4,3,2,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using the reverse method we just created</span></span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newArray2 = reverse(array2) <span class="comment">// [5,4,3,2,1]</span></span><br><span class="line">array2 <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><h3 id="First"><a href="#First" class="headerlink" title="First"></a>First</h3><p>Returns a new array that contains the first n items of the given array.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function">(<span class="params">[x, ...xs], n = <span class="number">1</span></span>) =&gt;</span> def(x) &amp;&amp; n ? [x, ...first(xs, n - <span class="number">1</span>)] : []</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">first(array, <span class="number">3</span>) <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h3><p>Returns a new array that contains the last n items of the given array.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> last = <span class="function">(<span class="params">xs, n = <span class="number">1</span></span>) =&gt;</span> reverse(first(reverse(xs), n))</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">last(array, <span class="number">3</span>) <span class="comment">// [3,4,5]</span></span><br></pre></td></tr></table></figure><h3 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h3><p>Returns a new array with value inserted at given index.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> slice = <span class="function">(<span class="params">[x, ...xs], i, y, curr = <span class="number">0</span></span>) =&gt;</span> def(x)</span><br><span class="line">  ? curr === i</span><br><span class="line">    ? [y, x, ...slice(xs, i, y, curr + <span class="number">1</span>)]</span><br><span class="line">    : [x, ...slice(xs, i, y, curr + <span class="number">1</span>)]</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">slice(array, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><h3 id="isArray"><a href="#isArray" class="headerlink" title="isArray"></a>isArray</h3><p>Returns if the value supplied is an array. Allows us to write <code>Array.isArray()</code> in a more functional manner.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isArray = <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Array</span>.isArray(x)</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">isArray(array) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Flatten"><a href="#Flatten" class="headerlink" title="Flatten"></a>Flatten</h3><p>Combines nested arrays into a single array.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">[x, ...xs]</span>) =&gt;</span> def(x)</span><br><span class="line">    ? isArray(x) ? [...flatten(x), ...flatten(xs)] : [x, ...flatten(xs)]</span><br><span class="line">    : []</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="number">4</span>,[<span class="number">5</span>,[<span class="number">6</span>]]]</span><br><span class="line">flatten([array1, array2]) <span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>Return a new array with 2 items swapped based on their index.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">a, i, j</span>) =&gt;</span> (</span><br><span class="line">  map(a, (x,y) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(y === i) <span class="keyword">return</span> a[j]</span><br><span class="line">    <span class="keyword">if</span>(y === j) <span class="keyword">return</span> a[i]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">swap(array, <span class="number">0</span>, <span class="number">4</span>) <span class="comment">// [5,2,3,4,1]</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>From MDN: “…creates a new array with the results of calling a provided function on every element in this array.”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function">(<span class="params">[x, ...xs], fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (undef(x)) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">return</span> [fn(x), ...map(xs, fn)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Which can be simplified as:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function">(<span class="params">[x, ...xs], fn</span>) =&gt;</span> def(x) ? [fn(x), ...map(xs, fn)] : []</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span></span><br><span class="line">map([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], double) <span class="comment">// [2,4,6]</span></span><br></pre></td></tr></table></figure><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>From MDN: “…creates a new array with all elements that pass the test implemented by the provided function.”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filter = <span class="function">(<span class="params">[x, ...xs], fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (undef(x)) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">if</span> (fn(x)) &#123;</span><br><span class="line">    <span class="keyword">return</span> [x, ...filter(xs, fn)]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...filter(xs, fn)]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Which can be simplified as:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filter = <span class="function">(<span class="params">[x, ...xs], fn</span>) =&gt;</span> def(x) </span><br><span class="line">    ? fn(x)</span><br><span class="line">        ? [x, ...filter(xs, fn)] : [...filter(xs, fn)]</span><br><span class="line">    : []</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> even = <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> odd = x = !even(x)</span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">filter(array, even) <span class="comment">// [2,4]</span></span><br><span class="line">filter(array, odd) <span class="comment">// [1,3,5]</span></span><br></pre></td></tr></table></figure><h3 id="Reject"><a href="#Reject" class="headerlink" title="Reject"></a>Reject</h3><p>The opposite of filter, returns an array that does not pass the filter function.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reject = <span class="function">(<span class="params">[x, ...xs], fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (undef(x)) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">if</span> (!fn(x)) &#123;</span><br><span class="line">    <span class="keyword">return</span> [x, ...reject(xs, fn)]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...reject(xs, fn)]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> even = <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">reject(array, even) <span class="comment">// [1,3,5]</span></span><br></pre></td></tr></table></figure><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>Splits an array into two arrays. One whose items pass a filter function and one whose items fail.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> partition = <span class="function">(<span class="params">xs, fn</span>) =&gt;</span> [filter(xs, fn), reject(xs, fn)]</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> even = <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">partition(array, even) <span class="comment">// [[0,2,4], [1,3,5]]</span></span><br></pre></td></tr></table></figure><h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p>From MDN: “…applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reduce = <span class="function">(<span class="params">[x, ...xs], fn, memo, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (undef(x)) <span class="keyword">return</span> memo</span><br><span class="line">  <span class="keyword">return</span> reduce(xs, fn, fn(memo, x, i), i + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Which can be simplified as:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reduce = <span class="function">(<span class="params">[x, ...xs], fn, memo, i = <span class="number">0</span></span>) =&gt;</span> def(x)</span><br><span class="line">    ? reduce(xs, fn, fn(memo, x, i), i + <span class="number">1</span>) : memo</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">memo, x</span>) =&gt;</span> memo + x</span><br><span class="line">reduce([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], sum, <span class="number">0</span>) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">memo, x</span>) =&gt;</span> memo.concat(x)</span><br><span class="line">reduce([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], flatten, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><h3 id="ReduceRight"><a href="#ReduceRight" class="headerlink" title="ReduceRight"></a>ReduceRight</h3><p>Similar to reduce, but applies the function from right-to-left.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reduceRight = <span class="function">(<span class="params">xs, fn, memo</span>) =&gt;</span> reduce(reverse(xs), fn, memo)</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">memo, x</span>) =&gt;</span> memo.concat(x)</span><br><span class="line"></span><br><span class="line">reduceRight([[<span class="number">0</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>]], flatten, []) <span class="comment">// [4, 5, 2, 3, 0, 1]</span></span><br></pre></td></tr></table></figure><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p>Partially apply a function by filling in any number of its arguments.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> (...newArgs) =&gt; fn(...args, ...newArgs)</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x + y</span><br><span class="line"><span class="keyword">const</span> add5to = partial(add, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">add5to(<span class="number">10</span>) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><h3 id="SpreadArg"><a href="#SpreadArg" class="headerlink" title="SpreadArg"></a>SpreadArg</h3><p>Convert function that takes an array to one that takes multiple arguments. This is useful when partially applying.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spreadArg = <span class="function">(<span class="params">fn</span>) =&gt;</span> (...args) =&gt; fn(args)</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">[x, ...xs]</span>) =&gt;</span> def(x) ? <span class="built_in">parseInt</span>(x + add(xs)) : []</span><br><span class="line">add([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spreadAdd = spreadArg(add)</span><br><span class="line">spreadAdd(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>If you only want to define a single function you can write it as:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = spreadArg(<span class="function">(<span class="params">[x, ...xs]</span>) =&gt;</span> def(x) ? <span class="built_in">parseInt</span>(x + add(...xs)) : [])</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>In the above, you need to remember to spread the array you are sending into the function recursively, since you are spreading the argument.</p><h3 id="ReverseArgs"><a href="#ReverseArgs" class="headerlink" title="ReverseArgs"></a>ReverseArgs</h3><p>Reverse function argument order.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseArgs = <span class="function">(<span class="params">fn</span>) =&gt;</span> (...args) =&gt; fn(...reverse(args))</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divide = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x / y</span><br><span class="line">divide(<span class="number">100</span>,<span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverseDivide = reverseArgs(divide)</span><br><span class="line">reverseDivide(<span class="number">100</span>,<span class="number">10</span>) <span class="comment">// 0.1</span></span><br></pre></td></tr></table></figure><p>Reversing arguments can be useful when partially applying arguments. Sometimes you want to partially apply arguments at the end of the list, not those at the beginning. Reversing the arguments allows us to do that.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> percentToDec = partial(reverseDivide, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">percentToDec(<span class="number">25</span>) <span class="comment">// 0.25</span></span><br></pre></td></tr></table></figure><h3 id="Pluck"><a href="#Pluck" class="headerlink" title="Pluck"></a>Pluck</h3><p>Extract property value from array. Useful when combined with the <strong>map</strong> function.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pluck = <span class="function">(<span class="params">key, object</span>) =&gt;</span> object[key]</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> product = &#123;<span class="attr">price</span>: <span class="number">15</span>&#125;</span><br><span class="line">pluck(<span class="string">'price'</span>, product) <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPrices = partial(pluck, <span class="string">'price'</span>)</span><br><span class="line"><span class="keyword">const</span> products = [</span><br><span class="line">  &#123;<span class="attr">price</span>: <span class="number">10</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">price</span>: <span class="number">5</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">price</span>: <span class="number">1</span>&#125;</span><br><span class="line">]</span><br><span class="line">map(products, getPrices) <span class="comment">// [10,5,1]</span></span><br></pre></td></tr></table></figure><h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><p>Each function consumes the return value of the function that came before.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flow = <span class="function">(<span class="params">...args</span>) =&gt;</span> init =&gt; reduce(args, (memo, fn) =&gt; fn(memo), init)</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getPrice = partial(pluck, <span class="string">'price'</span>)</span><br><span class="line"><span class="keyword">const</span> discount = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">0.9</span></span><br><span class="line"><span class="keyword">const</span> tax = <span class="function"><span class="params">x</span> =&gt;</span> x + (x * <span class="number">0.075</span>)</span><br><span class="line"><span class="keyword">const</span> getFinalPrice = flow(getPrice, discount, tax)</span><br><span class="line"></span><br><span class="line"><span class="comment">// looks like: tax(discount(getPrice(x)))</span></span><br><span class="line"><span class="comment">// -&gt; get price</span></span><br><span class="line"><span class="comment">// -&gt; apply discount</span></span><br><span class="line"><span class="comment">// -&gt; apply taxes to discounted price</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> products = [</span><br><span class="line">  &#123;<span class="attr">price</span>: <span class="number">10</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">price</span>: <span class="number">5</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">price</span>: <span class="number">1</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">map(products, getFinalPrice) <span class="comment">// [9.675, 4.8375, 0.9675]</span></span><br></pre></td></tr></table></figure><h3 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h3><p>The same as flow, but arguments are applied in the reverse order. Compose matches up more naturally with how functions are written. Using the same data as defined for the <strong>flow</strong> function:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...args</span>) =&gt;</span> flow(...reverse(args))</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getFinalPrice = compose(tax, discount, getPrice)</span><br><span class="line"></span><br><span class="line"><span class="comment">// looks like: tax(discount(getPrice(x)))</span></span><br><span class="line"></span><br><span class="line">map(products, getFinalPrice) <span class="comment">// [9.675, 4.8375, 0.9675]</span></span><br></pre></td></tr></table></figure><h3 id="Min"><a href="#Min" class="headerlink" title="Min"></a>Min</h3><p>Return the smallest number in an array. Returns <strong>Infinity</strong> if array supplied is empty.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> min = <span class="function">(<span class="params">[x, ...xs], result = <span class="literal">Infinity</span></span>) =&gt;</span> def(x)</span><br><span class="line">    ? x &lt; result</span><br><span class="line">        ? min(xs, x)</span><br><span class="line">        : result</span><br><span class="line">    : result</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">min(array) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="Max"><a href="#Max" class="headerlink" title="Max"></a>Max</h3><p>Return the largest number in an array. Returns <strong>-Infinity</strong> if array supplied is empty.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="function">(<span class="params">[x, ...xs], result = -<span class="literal">Infinity</span></span>) =&gt;</span> def(x)</span><br><span class="line">    ? x &gt; result</span><br><span class="line">        ? max(xs, x)</span><br><span class="line">        : max(xs, result)</span><br><span class="line">    : result</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">max(array) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="Factorial"><a href="#Factorial" class="headerlink" title="Factorial"></a>Factorial</h3><p>Returns the factorial of a number. Uses an accumulator to allow replacing of stack frames to allow larger factorials to be returned.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="function">(<span class="params">x, acum = <span class="number">1</span></span>) =&gt;</span> x ? factorial(x - <span class="number">1</span>, x * acum) : acum</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><h3 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h3><p>Returns the Fibonacci number at the given place.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fib = <span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">2</span> ? fib(x - <span class="number">1</span>) + fib(x - <span class="number">2</span>) : <span class="number">1</span></span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib(<span class="number">15</span>) <span class="comment">// 610</span></span><br></pre></td></tr></table></figure><h3 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h3><p>Sort an array from smallest to largest. This is done by re-ordering the array so that it contains two sub-arrays, one with smaller values, the other with larger values. The above steps are recursively applied to each sub-array until there are no arrays left, which is flatten to return a sorted array.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quicksort = <span class="function">(<span class="params">xs</span>) =&gt;</span> length(xs)</span><br><span class="line">  ? flatten([</span><br><span class="line">    quicksort(filter(tail(xs), x =&gt; x &lt;= head(xs))),</span><br><span class="line">    head(xs),</span><br><span class="line">    quicksort(filter(tail(xs), x =&gt; x &gt; head(xs)))</span><br><span class="line">  ])</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure><p>This can also be implemented using <strong>partition</strong>, but requires variable assignment.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quicksort = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!length(array)) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">const</span> [less, more] = partition(tail(array), x =&gt; x &lt; head(array))</span><br><span class="line">  <span class="keyword">return</span> flatten([quicksort(less), head(array), quicksort(more)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">quicksort(array) <span class="comment">// [1,2,4,6,8]</span></span><br></pre></td></tr></table></figure><h3 id="Everything-as-a-Reduction"><a href="#Everything-as-a-Reduction" class="headerlink" title="Everything as a Reduction"></a>Everything as a Reduction</h3><p>Many of the functions above can be converted into reductions, which should increase performance in most, if not all cases. This also shows the flexibility of the <strong>reduce</strong> function.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reduce = <span class="function">(<span class="params">[x, ...xs], f, memo, i = <span class="number">0</span></span>) =&gt;</span> def(x)</span><br><span class="line">    ? reduce(xs, f, f(memo, x, i), i + <span class="number">1</span>) : memo</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function"><span class="params">xs</span> =&gt;</span> reduce(xs, (memo, x) =&gt; [x, ...memo], [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> length = <span class="function"><span class="params">xs</span> =&gt;</span> reduce(xs, (memo, x) =&gt; memo + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="function">(<span class="params">xs, fn</span>) =&gt;</span> reduce(xs, (memo, x) =&gt; [...memo, fn(x)], [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filter = <span class="function">(<span class="params">xs, fn</span>) =&gt;</span> reduce(xs, (memo, x) =&gt; fn(x)</span><br><span class="line">    ? [...memo, x] : [...memo], [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reject = <span class="function">(<span class="params">xs, fn</span>) =&gt;</span> reduce(xs, (memo, x) =&gt; fn(x)</span><br><span class="line">    ? [...memo] : [...memo, x], [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> first = <span class="function">(<span class="params">xs, n</span>) =&gt;</span> reduce(xs, (memo, x, i) =&gt; i &lt; n</span><br><span class="line">    ? [...memo, x] : [...memo], [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> last = <span class="function">(<span class="params">xs, n</span>) =&gt;</span> reduce(xs, (memo, x, i) =&gt; i &gt;= (length(xs) - n)</span><br><span class="line">    ? [...memo, x] : [...memo], [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge = spreadArg(<span class="function"><span class="params">xs</span> =&gt;</span> reduce(xs, (memo, x) =&gt; [...memo, ...x], []))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="params">xs</span> =&gt;</span> reduce(xs, (memo, x) =&gt; x</span><br><span class="line">    ? isArray(x) ? [...memo, ...flatten(x)] : [...memo, x] : [], [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = spreadArg(<span class="function">(<span class="params">[x, ...xs]</span>) =&gt;</span> reduce(xs, (memo, y) =&gt; memo + y, x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> divide = spreadArg(<span class="function">(<span class="params">[x, ...xs]</span>) =&gt;</span> reduce(xs, (memo, y) =&gt; memo / y, x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiply = spreadArg(<span class="function">(<span class="params">[x, ...xs]</span>) =&gt;</span> reduce(xs, (memo, y) =&gt; memo * y, x))</span><br></pre></td></tr></table></figure><p>Example usage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">reverse([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// [3,2,1]</span></span><br><span class="line">length([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// 3</span></span><br><span class="line">map([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], double) <span class="comment">// [2,3,4]</span></span><br><span class="line">filter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], even) <span class="comment">// [2,4]</span></span><br><span class="line">reject([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], even) <span class="comment">// [1,3]</span></span><br><span class="line">first([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="number">3</span>) <span class="comment">// [1,2,3]</span></span><br><span class="line">last([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="number">2</span>) <span class="comment">// [3,4]</span></span><br><span class="line">merge([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]) <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line">flatten([<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>,[[<span class="number">6</span>]]]]]]) <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">// 15</span></span><br><span class="line">multiply(<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>) <span class="comment">// 100</span></span><br><span class="line">divide(<span class="number">100</span>,<span class="number">2</span>,<span class="number">5</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/800/1*4877k4Hq9dPdtmvg9hnGFA.jpeg" alt=""></p><h3 id="Wrapping-Up"><a href="#Wrapping-Up" class="headerlink" title="Wrapping Up"></a>Wrapping Up</h3><p>I hope this article helps shed insight on some of the patterns made available with JavaScript and ES6. Many problems that can be solved with iteration/loops, can also be solved functionally through recursion. I hope this article was also able to show you the flexibility of the reduce function.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What’s-the-deal-here&quot;&gt;&lt;a href=&quot;#What’s-the-deal-here&quot; class=&quot;headerlink&quot; title=&quot;What’s the deal here?&quot;&gt;&lt;/a&gt;What’s the deal here?&lt;/h3&gt;&lt;p&gt;Functional programming has been on the rise and is a topic that is very exciting to me. It allows me to write terse, declarative code that is easy to test and reason about. What is functional programming? I’ll defer that answer to someone with more knowledge on the subject, &lt;a href=&quot;https://medium.com/@_ericelliott&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Eric Elliot&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Functional programming&lt;/strong&gt; (often abbreviated FP) is the process of building software by composing &lt;strong&gt;pure functions&lt;/strong&gt;, avoiding &lt;strong&gt;shared state,&lt;/strong&gt; &lt;strong&gt;mutable data&lt;/strong&gt;,and &lt;strong&gt;side-effects&lt;/strong&gt;. Functional programming is &lt;strong&gt;declarative&lt;/strong&gt; rather than &lt;strong&gt;imperative&lt;/strong&gt;, and application state flows through pure functions. Contrast with object oriented programming, where application state is usually shared and colocated with methods in objects.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="http://nthung2112.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>Object, Function, Method, Constructor in JavaScript</title>
    <link href="http://nthung2112.github.io/2018/07/Object-Function-Method-Constructor-in-JavaScript.html"/>
    <id>http://nthung2112.github.io/2018/07/Object-Function-Method-Constructor-in-JavaScript.html</id>
    <published>2018-07-24T05:02:00.000Z</published>
    <updated>2018-09-07T13:27:14.724Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong></p><p>Lưu ý một chút về cách trình bày:<br><code>.propname</code> tức là public property có tên là “propname” của một đối tượng</p><h2 id="Bat-dau-voi-Object-Function-va-Method"><a href="#Bat-dau-voi-Object-Function-va-Method" class="headerlink" title="Bắt đầu với Object, Function và Method"></a>Bắt đầu với Object, Function và Method</h2><a id="more"></a><ul><li>JavaScript’s object giống như một cái túi (hay một vùng nhớ) chứa các property (thuộc tính) ở bên trong nó. Những property trong JavaScript đều public và được lưu trữ theo cấu trúc <strong>Mapping (tức key-value pair)</strong>.</li><li>Function trong JavaScript được xem là first-class object (cũng tương tự như object và ta sẽ gọi nó là <strong>functionObject</strong>).</li><li>Chính vì JavaScript’s function được xem như object nên ta có thể return (trả về), pass to parameter (truyền vào function khác thông qua đối số), store in variable (lưu trữ trong biến) or store in Object’s property (lưu trữ trong property của Object =&gt; lúc đó function được gọi là method),…</li></ul><h2 id="Prototypes"><a href="#Prototypes" class="headerlink" title="Prototypes"></a>Prototypes</h2><ul><li><p>Prototype của object là một internal property (có thể hiểu là một property nội tại ẩn bên trong), ta sẽ gọi nó là {Prototype}. JavaScript standard không cung cấp cách thức để truy xuất <strong>{Prototype}</strong> property từ một object. <strong>Lưu ý {Prototype} bản thân nó cũng là một object</strong>.</p></li><li><p>Giống như bao ngôn ngữ lập trình OOP khác, JavaScript có thể tạo object từ một function được gọi là <strong>constructor</strong>.</p></li><li><p>Vì constructor là function và là functionObject nên nó cũng có {Prototype} property.</p></li><li><p>JavaScript standard cung cấp một public property cho functionObject là <code>.prototype</code> để truy xuất prototype của function.<strong>Lưu ý đối tượng được truy xuất thông qua public property <code>.prototype</code> không phải là {Prototype} property của functionObject</strong>.</p></li></ul><h3 id="Properties-lookup"><a href="#Properties-lookup" class="headerlink" title="Properties lookup"></a>Properties lookup</h3><ul><li>JavaScript’s object có thể ủy thác một số property của nó cho {Prototype}. Và bản thân {Prototype} cũng làm tương tự; Tất cả đều hướng đến Build-in Object.prototype. <strong>Lưu ý Build-in Object.prototype bằng <em>null</em></strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object --chứa--&gt; &#123;Prototype&#125;</span><br><span class="line">và bản thân &#123;Prototype&#125; cũng là object</span><br><span class="line">&#123;Prototype&#125; --chứa--&gt; &#123;Prototype&#125;&apos;s &#123;Prototype&#125;</span><br><span class="line">và bản thân &#123;Prototype&#125;&apos;s &#123;Prototype&#125; cũng là object</span><br><span class="line">&#123;Prototype&#125;&apos;s &#123;Prototype&#125; --chứa--&gt; &#123;Prototype&#125;&apos;s &#123;Prototype&#125;&apos;s &#123;Prototype&#125;</span><br><span class="line">.....</span><br><span class="line">..... --chứa--&gt; Build-in Object.prototype</span><br><span class="line">(end)</span><br></pre></td></tr></table></figure><ul><li>Hiện tượng trên người ta gọi là Inheritance (kế thừa) trong JavaScript thông qua prototype. Do đó JavaScript là một <strong>prototype-base OOP language</strong></li><li>Ở ví dụ trên, ta thấy xảy ra đệ quy, người ta gọi là <strong>{Prototype} chain</strong>. tức duyệt xuyên suốt các {Prototype}</li><li>Khi gọi một property ra từ object thì đầu tiên hệ thống sẽ kiểm tra xem property đó có nằm trong object đó không. Nếu không, chúng sẽ chuyển hướng qua tìm property đó trong object’s {Prototype}. Quá trình đệ quy cứ thế được thực hiện cho đến khi tìm đến Build-in Object.prototype thì dừng lại.</li></ul><h3 id="Setting-properties"><a href="#Setting-properties" class="headerlink" title="Setting properties"></a>Setting properties</h3><ul><li>Khi một property được set giá trị, property đó không có trong object thì nó sẽ được tạo mới, hệ thống tự động bỏ qua việc tìm kiếm nó trong {Prototype}. Property mới được thêm vào object sẽ làm mờ nhạt property trùng tên (nếu có) trong {Prototype} chain</li><li>{Prototype} của object bị ảnh hưởng khá mạnh bởi public property <code>.prototype</code> của constructor. Ta có thể quyết định {Prototype} của một object thông qua việc điều chỉnh <code>.prototype</code> property của constructor.</li><li>Khi constructor được gọi thực thi (hay nói cách khác function được gọi theo Constructor Format) (xem phần <strong>footnotes</strong>) thì một object mới được sinh ra. {Prototype} của object mới và public property <code>.prototype</code> của constructor sẽ tham chiếu cùng một đối tượng.</li></ul><h2 id="Tiep-theo-se-la-gi-Ta-cung-hinh-dung"><a href="#Tiep-theo-se-la-gi-Ta-cung-hinh-dung" class="headerlink" title="Tiếp theo sẽ là gì? Ta cùng hình dung"></a>Tiếp theo sẽ là gì? Ta cùng hình dung</h2><p>Trước tiên sẽ là mối liên quan giữa public property <code>.prototype</code> và {Prototype}. hình ellipse biểu diễn object, mũi tên biểu diễn property của object đó tham chiếu đến một object khác. {Prototype} chain sẽ được tô mũi tên mày xanh lá.</p><h3 id="1-Define-constructor"><a href="#1-Define-constructor" class="headerlink" title="1: Define constructor:"></a>1: Define constructor:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params"></span>) </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/rkuzvvigqw_1.png" alt="alt text"></p><p>Ta dễ dàng thấy MyConstructor được biểu diễn trong hình Ellipse, tức nó là function và là functionObject và sẽ được dùng như constructor.</p><p><strong>Ghi nhớ rằng</strong>: chỉ những public property <code>.prototype</code> của functionObject, là những object mặc định sở hữu public property <code>.constructor</code><br>Tức là theo ví dụ trên: MyConstructor.prototype là giá trị mặc định cho property <code>.prototype</code> của MyConstructor. Và nó mặc định sở hữu property <code>.constructor</code> trỏ ngược về MyConstructor</p><p>Phần còn lại trong bức ảnh minh họa rõ ràng những khái niệm đã đề cập ở phần đầu bài viết</p><p>Bước kế tiếp ta sẽ bỏ qua phần {Prototype} chain của MyConstructor cho gọn, vì chúng không thay đổi và cũng không liên quan đến những gì được trình kế tiếp sau đây.</p><h3 id="2-Assign-new-prototype-property"><a href="#2-Assign-new-prototype-property" class="headerlink" title="2: Assign new prototype property:"></a>2: Assign new prototype property:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyConstructor.prototype = &#123; &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/iafa0yzffc_2.png" alt="alt text"></p><p>Ta thay <code>.prototype</code> mặc định của MyConstructor bằng một đối tượng mới. Đặc biệt đối tượng này không có property <code>.constructor</code></p><h3 id="3-Call-constructor-to-create-new-object"><a href="#3-Call-constructor-to-create-new-object" class="headerlink" title="3: Call constructor to create new object:"></a>3: Call constructor to create new object:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myobject = <span class="keyword">new</span> MyConstructor();</span><br></pre></td></tr></table></figure><p><img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/1j0lr35ama_3.png" alt="alt text"></p><p>Như đã trình bày ở mục <strong>setting propertites</strong> của bài viết, ta dễ dàng thấy được {Prototype} của myobject và property <code>.prototype</code> của MyConstructor tham chiếu đến cùng một đối tượng.</p><p>Vậy bây giờ dựa theo mục <strong>properties lookup</strong>, ta thử truy xuất một property bất kì từ myobject. Ta chọn property có tên là constructor, chuyện gì sẽ xảy ra</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myobject.constructor = ?</span><br></pre></td></tr></table></figure><p>Đơn giản, áp dụng {Property} chain, ta sẽ có ngay đáp án. Bây giờ cùng thu gọn tất cả những đoạn code ta viết lại:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">MyConstructor.prototype = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> myobject = <span class="keyword">new</span> MyConstructor();</span><br><span class="line"></span><br><span class="line">myobject.constructor == <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">myobject.constructor.prototype == <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>Ghi chú</strong>: Nếu nhìn lại ta sẽ hiểu vì sao ngay từ bước <strong>#2</strong> ta lược bỏ đi phần {Prototype} của MyConstructor là đúng đắn</p><h3 id="The-neu-dung-instanceof-ket-qua-nhu-the-nao"><a href="#The-neu-dung-instanceof-ket-qua-nhu-the-nao" class="headerlink" title="Thế nếu dùng instanceof kết quả như thế nào?"></a>Thế nếu dùng instanceof kết quả như thế nào?</h3><p>Viết lại nguyên văn:<br>    “Javascript provides the instanceof operator that’s intended to check the prototype chain of the object you’re dealing with.”</p><p>Từ những bước ở trên, ta có thể nghĩ rằng đoạn code sau sẽ trả về false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">MyConstructor.prototype = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> myobject = <span class="keyword">new</span> MyConstructor();</span><br><span class="line"></span><br><span class="line">myobject <span class="keyword">instanceof</span> MyConstructor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>nhưng thực chất, nó chạy ổn và còn hơn thế nữa:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">MyConstructor.prototype = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> myobject = <span class="keyword">new</span> MyConstructor();</span><br><span class="line"></span><br><span class="line">myobject <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Khi instanceof được gọi, nó <strong>hoạt động dựa trên {Prototype} chain. Và nó chẳng đá động hay lệ thuộc vào property</strong> <code>.constructor</code></p><p>cùng nhìn lại hình ở bước <strong>#3</strong></p><p><img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/38d3vbr9vo_4.png" alt="alt text"></p><p>Cứ tới một “trạm” tức đối tượng tham chiếu bởi {Prototype}, nó check xem đối tượng này được tham chiếu thông qua <code>.prototype</code> property của ai.<br>Đầu tiên dừng tại đối tượng {}, nó check và phát hiện ra {} được tham chiếu thông qua <code>.prototype</code> property của MyConstructor, suy ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myobject <span class="keyword">instanceof</span> MyConstructor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Tiếp theo dừng tại đối tượng Object.prototype nó phát hiện ra Object.protoype tham chiếu thông qua <code>.prototype</code> property của build-in Object, suy ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myobject <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Có ổn rồi, nhưng ta vẫn có thể tìm ra những điều bất thường nếu chịu khó mò mẫm:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> myobject = <span class="keyword">new</span> MyConstructor();</span><br><span class="line">MyConstructor.prototype = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">[ myobject <span class="keyword">instanceof</span> MyConstructor,     <span class="comment">// false !</span></span><br><span class="line">  myobject.constructor == MyConstructor, <span class="comment">// true !</span></span><br><span class="line">  myobject <span class="keyword">instanceof</span> <span class="built_in">Object</span> ]           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>ở đoạn code trên ta đổi thứ tự của hai dòng code, myobject được tạo ra trước sau đó MyConstructor mới đổi giá trị của <code>.prototype</code> property.<br>Do đó {Prototype} chain sẽ trông như vầy:</p><p><img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hh0v85pb9l_5.png" alt="alt text"></p><p>Đúng như dự đoán {Prototype} của object sẽ tham chiếu đến đối tượng cũ mà <code>.prototype</code> property của MyConstructor từng tham chiếu.</p><p>Điều này làm thay đổi {Prototype} chain và có thêm sự xuất hiện của <code>.constructor</code> property của old MyConstructor.prototype dẫn đến {Prototype} của object và <code>.prototype</code> property của MyConstructor không tham chiếu đến cùng một đối tượng.<br>Dừng tại {Prototype} đầu tiên là đối tượng old MyConstructor.prototype, nó không phát hiện ra đối tượng đó được tham chiếu thông qua <code>.prototype</code> property của ai cả. Tiếp tục {Prototype} thứ hai, là Object.prototype thì quá rõ ràng, suy ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myobject <span class="keyword">instanceof</span> MyConstructor,     <span class="comment">// false !</span></span><br><span class="line">myobject <span class="keyword">instanceof</span> <span class="built_in">Object</span>            <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Ngoài ra, thông qua {Prototype} chain (xem lại mục <strong>properties lookup</strong>), thì ta thấy <code>.constructor</code> property đầu tiên được bắt gặp trong old MyConstructor.prototype nên</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myobject.constructor == MyConstructor, <span class="comment">// true !</span></span><br></pre></td></tr></table></figure><p>là điều dễ hiểu.</p><h2 id="Mot-so-nhan-dinh"><a href="#Mot-so-nhan-dinh" class="headerlink" title="Một số nhận định"></a>Một số nhận định</h2><h4 id="Constructors-khong-phai-classes"><a href="#Constructors-khong-phai-classes" class="headerlink" title="Constructors không phải classes"></a>Constructors không phải classes</h4><p>Nhìn lại các class-based OOP language (như Java, C#,…), các classes kế thừa từ những classes khác, và object là instance của những classes đó. Các properties và methods được chia sẻ giữa các instances. Và việc chia sẻ đó bị chi phối bởi <strong>access modifier</strong> (public, private, internal, protected,……)</p><p>Javascript cũng có khái niệm kế thừa, chia sẻ properties và methods thông qua prototype. Nhưng thực tế {Prototype} của constructor và {Prototype} chain của object được tạo ra từ constructor đó, lại hoàn toàn khác biệt, không liên quan đến nhau.</p><h4 id="Constructors-khong-hoat-dong-nhu-class-based-initializer"><a href="#Constructors-khong-hoat-dong-nhu-class-based-initializer" class="headerlink" title="Constructors không hoạt động như class-based initializer"></a>Constructors không hoạt động như class-based initializer</h4><p>Để có được khái niệm kế thừa thông qua prototype, Khi constructor được gọi nó tiến hành liên kết {Prototype} property của object với <code>.prototype</code> property của chính nó. Những gì còn lại là việc constructor thêm vào một số properties, methods khác cho object</p><h4 id="Constructors-chi-la-functions"><a href="#Constructors-chi-la-functions" class="headerlink" title="Constructors chỉ là functions"></a>Constructors chỉ là functions</h4><p>Xem lại bước <strong>#1</strong>, ta thấy MyConstructor chẳng khác gì một function bình thường. Vì vậy bất kì user-defined function nào trong Javascript cũng tự động có <code>.prototype</code> property tham chiếu đến một đối tượng sở hữu <code>.constructor</code> property tham chiếu ngược về function đó</p><p>Bất cứ user-defined function nào cũng được gọi thực thi như một constructor bằng cách thêm vào từ khóa new. Cách làm đó sẽ truyền object mới được tạo bởi từ khóa new vào trong constructor function, và phần việc còn lại của constructor thì như đã nói ở bên trên</p><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><p>(tham khảo từ <a href="https://zeekat.nl/articles/constructors-considered-mildly-confusing.html" target="_blank" rel="noopener">bài viết của zeekat/articles</a> với một số chỉnh sửa theo hiểu biết của bản thân và để phù hợp với Tiếng Việt)<br>(xem thêm <a href="https://stackoverflow.com/questions/1114024/constructors-in-javascript-objects" target="_blank" rel="noopener">constructor in Javascript object</a>)<br>(xem thêm <a href="https://stackoverflow.com/questions/8093057/javascript-inheritance-and-the-constructor-property/8096017#8096017" target="_blank" rel="noopener">Javascript inheritance and the constructor property</a>)<br>(xem thêm <a href="https://tc39.github.io/ecma262/#sec-fundamental-objects" target="_blank" rel="noopener">ECMA-262 lastest version</a>)</p><h4 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h4><p>[1]<br>John G Harris từng viết trong comp.lang.javascript rằng những gì trình bày ở bên trên cũng tương đối chưa đúng hoàn toàn. Về mặt lý thuyết, host system có thể sẽ đổi Object.prototype property bằng một thứ gì đó khác. Một số thảo luận chấp thuận rằng Object.prototype chỉ được read-only. Nhưng ở một số browser (firefox) thì ta có thể gán giá trị mới cho Object.prototype mà không có lỗi nào xảy ra.</p><p>[2]<br>có 4 cách để gọi thực thi (invocation) một function trong JavaScript<br>(<em>giữ nguyên văn cho dễ hiểu</em>)</p><p><strong>Function form:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionObject(<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure><p>When a function is called in the function form, this is set to the global object.</p><ul><li>that is not very useful (fixed in ES5/Strict)</li><li>an inner function does not get access to the outer this</li></ul><p><strong>Method form:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thisObject.methodName(agurments);</span><br><span class="line">thisObject[<span class="string">"methodName"</span>](<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure><p>When a function is called in the method form, this is set to thisObject, the object containning the function.<br>this allows method to have a reference to the object of interest</p><p><strong>Constructor form:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> functionObject(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure><ul><li>When a function is called with the new operator, a new object is created and assigned to this.</li><li>If there is not an explicit return value, then this will be returned.</li><li>Used in the Pseudoclassical style</li></ul><p><strong>Apply form:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">functionObject.apply(thisObject, [<span class="built_in">arguments</span>]);</span><br><span class="line">functionObject.call(thisObject, <span class="built_in">arguments</span>....);</span><br></pre></td></tr></table></figure><ul><li>A function’s apply or call method allows for calling the function,explicitly specifying thisObject.</li><li>It can also take an array of parameters or a sequence of paramenters.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the definition of call method</span></span><br><span class="line"></span><br><span class="line">Funtion.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params">thisObject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.apply(thisObject, <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>, [<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/dnry2vj88r_this.png" alt="alt text"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lưu ý một chút về cách trình bày:&lt;br&gt;&lt;code&gt;.propname&lt;/code&gt; tức là public property có tên là “propname” của một đối tượng&lt;/p&gt;
&lt;h2 id=&quot;Bat-dau-voi-Object-Function-va-Method&quot;&gt;&lt;a href=&quot;#Bat-dau-voi-Object-Function-va-Method&quot; class=&quot;headerlink&quot; title=&quot;Bắt đầu với Object, Function và Method&quot;&gt;&lt;/a&gt;Bắt đầu với Object, Function và Method&lt;/h2&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Memory Leaks trong Javascript</title>
    <link href="http://nthung2112.github.io/2018/07/Memory-Leaks-trong-Javascript.html"/>
    <id>http://nthung2112.github.io/2018/07/Memory-Leaks-trong-Javascript.html</id>
    <published>2018-07-24T04:41:00.000Z</published>
    <updated>2018-09-07T13:27:14.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu"></a>Giới thiệu</h2><p>Memory leaks là vấn đề mà mọi deveploper đều sẽ gặp phải khi code. Memory leaks sẽ dấn đến việc ứng dụng sẽ chạy chậm hơn, crashes, hay có thể ảnh hưởng đến các ứng dụng khác. Vậy memory leaks là gì?<br><a id="more"></a><br>Memory leaks có thể được định nghĩa là một bộ nhớ (memory) không được sử dụng trong ứng dụng nữa nhưng vì một lý do nào đó mà nó chưa được giải phóng và trả về hệ điều hành hoặc một cái pool chứa các bộ nhớ (memory) chưa sử dụng. Các ngôn ngữ lập trình khác nhau sẽ có các cách khác nhau để quản lý bộ nhớ. Những cách quản lý bộ nhớ này sẽ giúp giảm thiểu khả năng bị memory leaks của chương trình. Tuy nhiên, việc xác định một vùng bộ nhớ có còn được sử dụng hay không lại là một vấn đề khó có thể xác định. Chỉ có developer mới có khả năng quyết định xem là vùng nhớ này nên được giải phóng hay không. Một số ngôn ngữ (như javascript) cung cấp tính năng tự động giải phóng bộ nhớ cho developer, một số khác thì developer cần phải tự mình giải phóng bộ nhớ khi không sử dụng đến nó nữa.</p><h4 id="Quan-ly-bo-nho-trong-JS"><a href="#Quan-ly-bo-nho-trong-JS" class="headerlink" title="Quản lý bộ nhớ trong JS"></a>Quản lý bộ nhớ trong JS</h4><p>Javascript là một trong những ngôn ngữ có <em>garbage collection</em>. Những ngôn ngữ lập trình như Javascript thế này sẽ thay developer quản lý bộ nhớ bằng cách kiểm tra định kỳ các vùng nhớ được cấp phát trước đó có có thể được “với tới” bởi các phần khác trong ứng dụng. Có thể nói cách khác là những ngôn ngữ như Javascript sẽ giúp biến vấn đề từ <em>“những vùng nhớ nào vẫn còn cần trong ứng dụng”</em> thành <em>“những vùng nhớ nào có thể được ứng dụng access đến”</em>. Sự khác biệt của 2 vấn đề là không nhiều nhưng lại rất quan trọng: chỉ developer mới có thể biết được là vùng nhớ nào còn cần để chạy tuy nhiên, việc xác định xem một vùng nhớ có thể vươn tới không trong ứng dụng thì có thể làm tự động bởi thuật toán.</p><h2 id="Memory-leaks-trong-JS"><a href="#Memory-leaks-trong-JS" class="headerlink" title="Memory leaks trong JS"></a>Memory leaks trong JS</h2><p>Lý do chính của memory leaks trong các ngôn ngữ có garbage collection là các reference không mong muốn vào bộ nhớ (unwanted references), tức là một vùng nhớ được trỏ đến mà lại không được sử dụng trong ứng dụng. Để có thể hiểu rõ hơn về nó, trước hết ta cần tìm hiểu các hoạt động của garbage collector, cách nó xác định một vùng nhớ có thể được “với tới” (reach) bởi ứng dụng.</p><h4 id="Mark-and-sweep"><a href="#Mark-and-sweep" class="headerlink" title="Mark and sweep"></a>Mark and sweep</h4><p>Hầu hết các garbage collector đều sử dụng thuật toán <code>mark-and-sweep</code> để thực hiện việc giải phóng bộ nhớ. Thuật toán này bao gồm các bước sau:</p><ol><li><p>Đầu tiên, garbage collector sẽ xây dựng một danh sách các <code>roots</code>. <code>Roots</code> thực chất là các biến toàn cục mà có reference được lưu trong code. Trong Javascript, <code>window</code> chính là một biến toàn cục như vậy. <code>Window</code> sẽ luôn hiện hữu trong chương trình nên garbage collector có thể coi nó và tất cả các con của nó luôn hiện hữu.</p></li><li><p>Tất cả <code>roots</code> và con của chúng sẽ được đánh dẫu là đang hoạt động. Tất cả những vùng nhớ mà có thể được vươn tới từ <code>roots</code> thì đều được coi là đang hoạt động và không đánh dấu là rác (garbage).</p></li><li><p>Tất cả các vùng nhớ mà không được đánh dẫu là rác (garbage) thì bây giớ đều sẽ được coi là rác. Bây giờ thì các collector có thể giải phóng các vùng nhớ này.</p></li></ol><p>Mặc dù thuật toán này được tối ưu bởi các GC (garbage collector) hiện đại tuy nhiên cơ chế của nó vẫn không đổi: những vùng nhớ vươn tói được thì được coi là đang hoạt động, những vùng nhớ khác sẽ được coi là rác.</p><p>Những tham chiếu không mong muốn (Unwanted references) là những tham chiếu đến các vùng bộ nhớ mà developer biết là nó không được cần đến nữa nhưng vì lý do nào đó mà nó vẫn được giữ lại trong hệ thống. Trong JS, những tham chiếu không mong muốn này là các biến (variables) được giữ đâu đó trong code mà nó sẽ không được sử dụng đến nữa nhưng lại trỏ đến một vùng nhớ mà cần được giải phóng.</p><p>Để hiểu được memory leaks trong JS, ta cần biết được là khi nào thì một tham chiếu bị lãng quên.</p><h2 id="3-loai-memory-leaks-trong-JS"><a href="#3-loai-memory-leaks-trong-JS" class="headerlink" title="3 loại memory leaks trong JS"></a>3 loại memory leaks trong JS</h2><h3 id="1-Bien-toan-cuc"><a href="#1-Bien-toan-cuc" class="headerlink" title="1: Biến toàn cục"></a>1: Biến toàn cục</h3><p>Javascript có một cơ chế là đặt biến mà không cần khai báo. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"value"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//"a"</span></span><br></pre></td></tr></table></figure><p>Khi một biến được khai báo như trên thì JS sẽ tự động gán nó vào <code>global</code> object (<code>window</code> trên browser). Nếu như biến này chỉ hoạt động trên phạm vi toàn cục (global scope) thì cũng không có sự khác biệt cho lắm. Tuy nhiên, nếu nó được định nghĩa trong một hàm thì đó lại là chuyện khác. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  bar = <span class="string">"đây là biến toàn cục ẩn"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đoạn code trên sẽ tương đương với đoạn code sau trên browser:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.bar = <span class="string">"đây là biến toàn cục"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nếu khai báo <code>bar</code> trong phạm vi của hàm <code>foo</code> mà lại không sử dụng <code>var</code> để khai báo thì biến <code>bar</code> sẽ được tạo với phạm vi toàn cục, và đây là một ví dụ điển hình về memory leaks.</p><p>Một cách khác mà có thể vô tình tạo ra biến toàn cục đó là thông qua <code>this</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.variable = <span class="string">"có thể là biến toàn cục"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>Vì <code>this</code> trong hàm sẽ trỏ đến biến root toàn cục (<code>window</code>) nếu hàm đó được gọi trực tiếp không thông qua object nào khác nên ở ví dụ trên, biến <code>variable</code> sẽ được gắn vào phạm vi toàn cục.</p><p>Một cách để giảm thiểu những lỗi trên đó là thêm <code>&quot;use strict;&quot;</code> vào dòng đầu tiên của file JS. Nó sẽ giúp ngăn chặn việc khai báo biến toàn cục như trên.</p><p><strong>Chú ý khi làm việc với biến toàn cục</strong></p><p>Biến toàn cục không bao giờ được giải phóng bộ nhớ tự động theo thuật toán <code>mark-and-sweep</code> ở trên. Vì thế, biến toàn cục chỉ nên được sử dụng để lưu tạm dữ liệu để xử lý. Nếu cần lưu một lượng lớn dữ liệu vào biến toàn cục thì cần đảm bạo là nó sẽ bị gán về null hoặc gán lại dữ liệu khi mà bạn đã sử dụng xong nó.</p><h3 id="2-Callback-va-timer-bi-lang-quen"><a href="#2-Callback-va-timer-bi-lang-quen" class="headerlink" title="2: Callback và timer bị lãng quên"></a>2: Callback và timer bị lãng quên</h3><p>Sau đây là một ví dụ dẫn đến memory leak khi sử dụng <code>setInterval</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = getData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">"Node"</span>);</span><br><span class="line">  <span class="keyword">if</span>(node)&#123;</span><br><span class="line">node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>Đây là một ví dụ về một timer bị treo. Timẻ bị treo tức là khi timer tham chiếu đến các node hoặc dữ liệu mà không còn được sử dụng nữa. Ở ví dụ trên, nếu như <code>node</code> bị xóa ở một lúc nào đấy thì toàn bộ đoạn code xử lý trong hàm callback của interval sẽ không cần đến nữa. Tuy nhiên, vì interval vẫn còn hoạt động nên các vùng nhớ được sử dụng trong hàm callback của interval cũng không được giải phóng (muốn giải phóng cần dừng interval lại). Tiếp đó, các object từ bên ngoài mà được hàm callback của interval tham chiếu đến cũng không thể được giải phóng vì vẫn có thể vươn tới được thông qua hàm callback kia. Theo ví dụ trên thì đó là <code>data</code>.</p><p>Một trường hợp có thể dẫn đến leaks đó là do các observers object (DOM và event listener của chúng). Điều này chỉ ảnh hưởng đến các trình duyệt cũ (vd: IE6) vì các trình duyệt mới sẽ tự động làm điều này cho chúng ta. Đây là một bug của GC của IE6 và dẫn đến việc tham chiếu quay vòng.</p><h3 id="3-Tham-chieu-toi-cac-DOM-da-bi-xoa"><a href="#3-Tham-chieu-toi-cac-DOM-da-bi-xoa" class="headerlink" title="3: Tham chiếu tới các DOM đã bị xóa"></a>3: Tham chiếu tới các DOM đã bị xóa</h3><p>Có những lúc bạn muốn lưu các DOM vào một số cấu trúc dữ liệu như mảng hoặc object trong JS code để làm một loạt các tác vụ nào đấy. Ví dụ bạn muốn update dữ liệu của một vài element nào đấy thì việc lưu các element này vào một mảng là hoàn toàn hợp lý. Khi điều này xảy ra thì sẽ có 2 tham chiếu đên DOM element này: một là từ DOM tree, hai là từ đối tượng mảng của JS. Nếu bạn muốn xóa các element này thì bạn cần phải xóa toàn bộ các tham chiếu tới chúng để có thể giải phóng bộ nhớ.</p><p>Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">  button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</span><br><span class="line">  image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>),</span><br><span class="line">  text: <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">image.src = <span class="string">'http://some.url/image'</span>;</span><br><span class="line">button.click();</span><br><span class="line"><span class="built_in">console</span>.log(text.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// button là con của body.</span></span><br><span class="line"><span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ở đây thì button vẫn được tham chiểu đến bởi elements. Nói cách khác là</span></span><br><span class="line"><span class="comment">// nó vẫn nằm trong bộ nhớ và không thể được giải phóng.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Còn một vấn đề quan trọng nữa là khi tham chiếu đến một node lá hoặc một inner node của DOM tree, ví dụ như một ô trong bảng (<code>&lt;td&gt;</code> của <code>&lt;table&gt;</code>). Nếu bạn tham chiếu đến <code>&lt;td&gt;</code> này trong JS code thì khi bạn xóa <code>&lt;table&gt;</code> chứa node này thì GC sẽ không giải phóng được cả table chứ không phải là chỉ mỗi <code>&lt;td&gt;</code> node không được giải phóng. Vì node con còn tham chiếu đến node cha nên nó sẽ được GC coi là vẫn được tham chiếu và bỏ qua nó. Vì thế nên cẩn thận khi tham chiếu đến các DOM.</p><h3 id="4-Closures"><a href="#4-Closures" class="headerlink" title="4: Closures"></a>4: Closures</h3><p>Closures có nghĩa đơn giản là hàm nằm trong phạm vi của một hàm khác có thể tham chiếu tới các biến của hàm bao nó. Vì sao <code>Closures</code> có thể gây ra leak, hãy xem ví dụ sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (originalThing)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(someMessage);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>Ví dụ này cho ta thấy mỗi khi <code>replaceThing</code> được gọi, <code>theThing</code> sẽ tạo ra một object mới chứa một mảng và một closures (<code>someMethod</code>). Cùng lúc đó, biến <code>unused</code> cũng lưu một closures tham chiếu đên <code>originalThing</code> (là object <code>theThing</code> được tạo ra từ việc gọi <code>replaceThing</code> ở bước trước đó). Một điều quan trọng nữa là khi một scope được tạo ra cho các closures mà có cùng scope cha, chúng sẽ cùng chia sẻ scope đó. Trong ví dụ này thì <code>someMethod</code> và <code>unused</code> đều chia sẻ cùng một scope. Mặc dù <code>unused</code> không được gọi đến nhưng vì nó có tham chiếu đến <code>originalThing</code> nên nó sẽ được GC coi là vẫn đang hoạt động. Khi đoạn code này chạy thì bộ nhớ của chương trình sẽ tăng đều đặn và có thể nhìn thấy ngay được. Về bản chất, một linked-list của closures được tạo (với root là <code>theThing</code>) khi đoạn code trên được chạy và đó là lý do bộ nhớ bị tăng dần theo thời gian.</p><h2 id="Garbage-Collectors-bo-don-rac"><a href="#Garbage-Collectors-bo-don-rac" class="headerlink" title="Garbage Collectors (bộ dọn rác)"></a>Garbage Collectors (bộ dọn rác)</h2><p>Mặc dù GCs giúp chúng ta không phải quản lý bộ nhớ bằng tay nữa, tuy nhiên ta cũng sẽ phải đánh đổi lại một vài thứ. Một trong số đó là việc các GCs hoạt động theo một cách khó đoán biết. Thông thường rất khó có thể chắc chắn rằng một hoạt động thu thập các vùng nhớ không được sử dụng được thực thi hay không. Điều này cũng có nghĩa là trong một số trường hợp, số lượng vùng nhớ của một chương trình nhiều hơn số bộ nhớ mà chương trình đó cần. Trong một số trường hợp khác, ứng dụng sẽ bị ảnh hưởng bởi một khoảng thời gian nhỏ chương trình bị delay để thực hiện công việc thu thập bộ nhớ. Hiện nay, hầu hết GC đều hoạt động theo cách là chỉ thực hiện việc thu thập bộ nhớ khi cấp phát bộ nhớ cho chương trình. Nếu không cần cấp phát bộ nhớ, GCs sẽ không hoạt động. Chúng ta sẽ xem xét các tình huống sau:</p><ol><li><p>Chương trình đã cấp phát một số lượng nhỏ bộ nhớ.</p></li><li><p>Sau đó, hầu hết (hoặc toàn bộ) các phần tử được đánh dấu là không thể vươn tới nữa.</p></li><li><p>Chương trình không thực hiện việc cấp phát bộ nhớ nữa.</p></li></ol><p>Trong tình huống này, hầu như tất cả các GC sẽ không thực hiện việc thu thập bộ nhớ nữa. Nói cách khác, mặc dù có những phần tử không thể vươn tới được nữa trong chương trình, chúng sẽ không được thu hồi lại bộ nhớ. Đây không hẳn là leaks, tuy nhiên nó vẫn dẫn đến việc chương trình ngốn bộ nhớ.</p><h2 id="Chrome-Memory-Profiling-Tools"><a href="#Chrome-Memory-Profiling-Tools" class="headerlink" title="Chrome Memory Profiling Tools"></a>Chrome Memory Profiling Tools</h2><p><code>Chrome</code> cung cấp một tập các công cụ để kiểm tra tình trạng sử dụng bộ nhớ của code JS. Có 2 view quan trọng liên quan đến bộ nhớ đó là: <em>timeline</em> và <em>profiles</em>.</p><h4 id="Timeline-View"><a href="#Timeline-View" class="headerlink" title="Timeline View"></a>Timeline View</h4><p><code>Timeline View</code> có thể giúp ta biết được mô hình sử dụng bộ nhớ của chương trình. Từ đây ta có thể nhìn được việc rò rỉ bộ nhớ, việc bộ nhớ sử dụng tăng liên tục theo thời gian mà không giảm xuống sau mỗi lần GC được chạy. Ví dụ:</p><p><img src="https://cdn.auth0.com/blog/jsleaks/timeline.png" alt="timeline"></p><p>Ta có thể thấy được việc bộ nhớ rò rỉ được thể hiện thông qua việc JS heap tăng dần theo thời gian. Mặc dù sau khi được thu thập với một số lượng lớn tại đoạn cuối thì chương trình vẫn sử dụng số lượng bộ nhớ nhiều hơn so với lúc bắt đầu. Số lượng Node cũng cao hơn. Đây là dấu hiệu của việc các node DOM bị rò rỉ đâu đó trong code.o</p><h4 id="Profiles-view"><a href="#Profiles-view" class="headerlink" title="Profiles view"></a>Profiles view</h4><p><img src="https://cdn.auth0.com/blog/jsleaks/profiles.png" alt="profiles"></p><p>Đây là công cụ sẽ luôn gắn bó với bạn khi phải điều tra về rò rỉ bộ nhớ. <code>Profiles view</code> cho phép bạn lấy ảnh chụp (snapshot) về việc sử dụng bộ nhớ của một chương trình Javascript. Nó cũng cho phép bạn ghi lại những lần cấp phát bộ nhớ theo thời gian. Mỗi một loại kết quả sẽ có các danh sách liệt kê khác nhau được đưa ra, tuy nhiên những thứ mà bạn cần quan tâm đó là danh sách tổng hợp (summary list) và danh sách so sánh (comparision list).</p><p><code>Summary View</code> sẽ cho ta thấy được tổng quan về các loại objects được khởi tạo và cấp phát cùng với các kích thước tổng hợp (aggregated size): kich thước nông (Shallow size) là tổng kích thước của tất cả các object của một loại cụ thể nào đó và kích thước giữ lại (retained size) bao gồm <code>shallow size</code> và kích thước của các object được lưu lại bởi object này. Nó cũng cho ta một thông tin về khoảng cách giữa một object với root.</p><p><code>Comparision View</code> cũng cung cấp cùng một thông tin như <code>summary view</code> nhưng nó cho phép ta so sánh giữa các snapshot khác nhau.</p><h2 id="Vi-du-Tim-kiem-ro-ri-du-lieu-trong-Chrome"><a href="#Vi-du-Tim-kiem-ro-ri-du-lieu-trong-Chrome" class="headerlink" title="Ví dụ: Tìm kiếm rò rỉ dữ liệu trong Chrome"></a>Ví dụ: Tìm kiếm rò rỉ dữ liệu trong Chrome</h2><p>Có 2 kiểu rò rỉ dữ liệu chủ yếu là: rỏ rỉ dẫn đến việc bộ nhớ bị tăng một cách đều đặn theo thời gian và rò rỉ chỉ xảy ra một lần duy nhất và không gây ra việc bộ nhớ bị tăng trong tương lai nữa. Việc tìm rò rỉ dữ liệu mà bộ nhớ bị tăng dần theo thời gian khá là đơn giản và rõ ràng (sử dụng <code>timeline view</code>). Tuy nhiên thì đây lại là rò rỉ gây ra nhiều rắc rối nhất: nếu bộ nhớ cứ tăng dần theo thời gian, nó sẽ khiến trình duyệt chạy chậm dận và cuối cùng sẽ dẫn đến việc script bị ngừng chạy. Rò rỉ mà không dẫn đến việc bộ nhớ bị tăng theo thời gian có thể dễ dàng được tìm ra khi bộ nhớ lớn đến một mức độ nào đó. Thông thường những rò rỉ kiểu này không được chú ý quả nhiều. Nói theo một cách khác, những rò rỉ nhỏ mà chỉ xảy ra một lần thường được coi là một vấn đề để tối ưu code. Tuy nhiên, những rò rỉ mà làm bộ nhớ tăng dần theo thời gian thì được coi là bug và nó cần được fix.</p><p>Ở đây ta sẽ sử dụng một ví dụ từ <a href="https://developer.chrome.com/devtools/docs/demos/memory/example1" target="_blank" rel="noopener">Chrome</a>. Toàn bộ đoạn code như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [];</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSomeNodes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div,</span><br><span class="line">        i = <span class="number">100</span>,</span><br><span class="line">        frag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">for</span> (;i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">        div.appendChild(<span class="built_in">document</span>.createTextNode(i + <span class="string">" - "</span>+ <span class="keyword">new</span> <span class="built_in">Date</span>().toTimeString()));</span><br><span class="line">        frag.appendChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"nodes"</span>).appendChild(frag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">grow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    x.push(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'x'</span>));</span><br><span class="line">    createSomeNodes();</span><br><span class="line">    setTimeout(grow,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Khi <code>grow</code> được gọi, nó sẽ bắt đầu tạo một <code>div</code> và gán nó vào DOM. Nó cũng sẽ khởi tạo một mảng lớn (1 triệu phần tử) và gán nó vào một mảng được tham chiếu bỏi một biến toàn cục (<code>x</code>). Việc này sẽ dẫn đến việc bộ nhớ bị tăng đều đặn và có thể nhận biết được với <code>Timeline view</code>.</p><h4 id="Phat-hien-viec-bo-nho-bi-tang-deu-dan-trong-Chrome"><a href="#Phat-hien-viec-bo-nho-bi-tang-deu-dan-trong-Chrome" class="headerlink" title="Phát hiện việc bộ nhớ bị tăng đều đặn trong Chrome"></a>Phát hiện việc bộ nhớ bị tăng đều đặn trong Chrome</h4><p>Ta sẽ bắt đầu với <a href="https://developer.chrome.com/devtools/docs/demos/memory/example1" target="_blank" rel="noopener">ví dụ sau của chrome</a>. Sau khi click vào ví dụ của Chrome, mở Dev Tools, click vào tab <code>timeline</code>, tích chọn <code>memory</code> và click vào nút <code>record</code>. Tiếp đó quay lại trang ví dụ và click vào <code>The Button</code> để bắt đầu việc rò rỉ bộ nhớ. Sau một khoảng thời gian thì dừng lại việc record và xem kết quả:</p><p><img src="https://cdn.auth0.com/blog/jsleaks/example-timeline.png" alt="example-timeline"></p><p><strong>Note</strong>: Ví dụ này sẽ khiến bộ nhớ bị tăng mỗi giây. Sau khi dừng việc record thì các bạn có thể đặt breakpoint vào <code>grow</code> để dừng việc thực thi script.</p><p>Có 2 dấu hiệu lớn trong bức ảnh trên cho thấy việc rò rỉ bộ nhớ: biểu đồ cho <code>nodes</code> (đường kẻ màu xanh lá) và biểu đồ cho JS heap (đường kẻ màu xanh đậm). Số lượng node luôn luôn tăng và không bao giờ giảm. Đây là dấu hiệu cảnh báo lớn.</p><p>JS heap cũng tăng dần theo thời gian tuy nhiên điều này khó nhìn ra hơn do hiệu ứng từ GC. Các bạn có thể thấy là bộ nhớ tăng sau lại giảm một cách liên tục. Điểm quan trọng cần chú ý ỏ đây là sau mỗi lần bộ nhớ được giảm thì kích thước của JS heap vẫn lớn hơn so với lần giảm trước đấy. Nói cách khác, mặc dù GC đã thành công thu thập được rất nhiều bộ nhớ, một vài trong số đó bị rò rỉ.</p><p>Bây giờ ta đã chắc chắn chương trình của mình bị rò rỉ bộ nhớ, ta cần phải tìm ra nguyên nhân của nó.</p><h4 id="Tao-2-snapshot"><a href="#Tao-2-snapshot" class="headerlink" title="Tạo 2 snapshot"></a>Tạo 2 snapshot</h4><p>Để tìm ra nguyên nhân rò rỉ, ta sẽ sử dụng đến công cụ <code>profiles</code> của Chrome. Cụ thể hơn, ta sẽ sử dụng tính năng <code>Take Heap Snapshot</code>.</p><p>Đầu tiên, reload lại trang và tạo một snapshot ngay sau khi load xong trang. Ta sẽ sử dụng snapshot này làm cơ sở. Sau đó, click vào <code>The Button</code> một lần nũa, chờ khoảng một vài giây, tạo một snapshot khác. Sau đó tạo breakpoint để dừng việc rò rỉ bộ nhớ lại.</p><p>Có 2 cách mà ta có thể sử dụng để kiểm tra sự khác nhau giữa 2 snapshot. Thứ nhất là sử dụng chức năng <code>Summary</code> rồi bắt đầu từ phía bên phải chọn <code>Objects allocated between Snapshot 1 and Snapshot 2</code>. Hoặc chọn <code>Comparision</code> thay cho <code>Summary</code>. Trong cả 2 trường hợp, ta sẽ thấy một danh sách các object được khởi tạo giữa 2 snapshot.</p><p><img src="https://cdn.auth0.com/blog/jsleaks/example-snapshots-1.png" alt="example-snapshots"></p><p>Trong trường hợp này thì việc tìm ra leaks rất đơn giản. Hãy xem <code>Size Delta</code> của <code>(string)</code>. 8MB với 58 object mới. Điều này rất đáng nghi ngờ: object mới được tạo nhưng không được giải phóng và 8MB bị chiếm mất.</p><p>Nếu ta mở danh sách khởi tạo của <code>(string)</code> ta sẽ thấy có một vài object lớn được khởi tạo bên cạnh các object nhỏ. Nếu ta chọn một trong số các object lớn này thì ta sẽ thấy một vài điểm thú vị trong mục <code>retainers</code>:</p><p><img src="https://cdn.auth0.com/blog/jsleaks/example-snapshots-2.png" alt="example-snapshots"></p><p>Ta thấy rằng object được chọn là một phần tử của mảng. Tiếp đó ta biết được mảng này được tham chiếu bởi biến <code>x</code> nằm ở trong <code>window</code>. Điều này cho ta thấy được toàn bộ con đường từ object lớn của chúng ta liên kết thế nào với root (<code>window</code>). Ta đã tìm được một nguyên nhân dẫn đến rò rỉ và nơi nó được tham chiếu.</p><p>Vi dụ này khá đơn giản: object lớn được khỏi tạo thế này không thường xuyên xuất hiện trong chương trinh. Tuy nhiên trong chương trình này cũng có xuất hiện việc rò rỉ DOM có kích cỡ nhỏ hơn. Những node này có thể tìm thấy đươc thông qua snapshot tuy nhiên đối với những site lớn, mọi chuyện sẽ trở nên rắc rối hơn nhiều. Các phiên bản Chrome hiên tại có cung cấp một tính năng đó là: <code>Record Heap Allocations</code></p><h4 id="Record-Heap-Allocations"><a href="#Record-Heap-Allocations" class="headerlink" title="Record Heap Allocations"></a>Record Heap Allocations</h4><p>Ta se bắt đầu với viêc để cho đoạn script tiếp tục được chạy và quay lại tab <code>Profiles</code> của Chrome Dev Tools. Ấn nút <code>Record Heap Allocations</code>. Khi mà tool đang chạy, các bạn sẽ thấy một vài vạch xanh trên biểu đồ ở phía trên đầu. Nó thể hiện việc khởi tạo object khi chạy chương trình.</p><p><img src="https://cdn.auth0.com/blog/jsleaks/example-recordedallocs-overview.png" alt="example-recordedallocs-overview"></p><p>Ta có thể thấy được tính năng của công cụ này: chọn một khoảng thời gian để xem object nào được khởi tạo trong khoảng thời gian này. Ta đặt khoảng thời gian này gần các vạch xanh đậm nhất có thể. Chỉ có 3 hàm khởi tạo được show trong danh sách: một trong số đó liên quan đến rò rỉ do <code>(string)</code> ở phía trên, tiếp theo là liên quan đến việc khởi tạo DOM và cái cuối cùng là khởi tạo <code>Text</code>.</p><p>Chon một trong những hàm khởi tạo của <code>HTMLDivElement</code> trong danh sách và chọn <code>Allocation stack</code>.</p><p><img src="https://cdn.auth0.com/blog/jsleaks/example-recordedallocs-selected.png" alt="example-recordedallocs-selected"></p><p>Từ ảnh trên ta thấy được là phần tử được khởi tạo bởi <code>grow</code> -> <code>createSomeNodes</code>. Nếu ta để ý kỹ mỗi vạch trên biểu đồ, ta sẽ thấy là hàm khởi tạo <code>HTMLDivElement</code> được gọi nhiều lần. Nếu ta quay trở lại với snapshot <code>comparision view</code>, ta sẽ thấy là nó chỉ khởi tạo object mà không xóa chúng đi. Nói cách khác là nó luôn khởi tạo object mà không cho phép GC thu thập một vài trong số chúng. Giờ khi ta đã biết objects bị rò rỉ ở đâu (<code>createSomeNodes</code>), ta có thể quay trở lại code để sửa lại nó.</p><h4 id="Cac-tinh-nang-huu-ich-khac"><a href="#Cac-tinh-nang-huu-ich-khac" class="headerlink" title="Các tính năng hữu ích khác"></a>Các tính năng hữu ích khác</h4><p>Thay vì sử dụng <code>Summary view</code>, ta có thể sử dụng <code>Allocation view</code>:</p><p><img src="https://cdn.auth0.com/blog/jsleaks/example-recordedallocs-list.png" alt="example-recordedallocs-list"></p><p>Giao diện này cho ta thấy một danh sách các hàm và bộ nhớ khởi tạo liên quan đến chúng. Ta có thể thấy ngay là <code>grow</code> và <code>createSomeNodes</code> là nổi bật hơn cả. Khi chọn <code>grow</code> ta sẽ thấy đối tượng khởi tạo liên quan được gọi đến. Ta có thể để ý thấy <code>(string)</code> <code>HTMLDivElement</code> và <code>Text</code> là những hàm khởi tạo của các đối tượng bị rò rỉ.</p><p><strong>Note</strong>: để sử dụng được tính năng này, vào <code>Dev Tools</code> -> Settings và enable <code>record heap allocation stack traces</code> trước khi record.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Gioi-thieu&quot;&gt;&lt;a href=&quot;#Gioi-thieu&quot; class=&quot;headerlink&quot; title=&quot;Giới thiệu&quot;&gt;&lt;/a&gt;Giới thiệu&lt;/h2&gt;&lt;p&gt;Memory leaks là vấn đề mà mọi deveploper đều sẽ gặp phải khi code. Memory leaks sẽ dấn đến việc ứng dụng sẽ chạy chậm hơn, crashes, hay có thể ảnh hưởng đến các ứng dụng khác. Vậy memory leaks là gì?&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Làm thế nào để thành thạo CSS Grid trong nháy mắt</title>
    <link href="http://nthung2112.github.io/2018/07/Lam-the-nao-de-thanh-thao-CSS-Grid-trong-nhay-mat.html"/>
    <id>http://nthung2112.github.io/2018/07/Lam-the-nao-de-thanh-thao-CSS-Grid-trong-nhay-mat.html</id>
    <published>2018-07-10T01:10:00.000Z</published>
    <updated>2018-07-10T02:08:58.475Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu"></a>Giới thiệu</h3><p>Đây KHÔNG phải là một bài viết để học “mọi thứ” về css grid.<br>Bài viết này hướng đến những người muốn có kết quả nhanh chóng và hiệu quả.<br>Trong bốn phần của bài viết này, tôi sẽ chỉ cho bạn 20% cần thiết để làm được 80% những gì bạn có thể làm với CSS Grid layout.</p><p>Hãy cùng tìm hiểu!</p><a id="more"></a><h3 id="Tai-sao-chi-20"><a href="#Tai-sao-chi-20" class="headerlink" title="Tại sao chỉ 20%?"></a>Tại sao chỉ 20%?</h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*LPf5rSOWKaSKTOUwkqfK0w.png" alt=""></p><p>Bất cứ khi nào, một lập trình viên tìm kiếm sự hiệu quả - sự lười biếng sẽ giúp anh ta.</p><p>CSS Grid layout rất phức tạp. Theo ý kiến của tôi, nó phức tạp hơn Flexbox. (tôi đã mất vài tuần để tìm hiểu flexbox)</p><p>Không hẳn bởi vì nó “khó” mà do CSS Grid có tới 18 thuộc tính mới cộng với những khái niệm mà bạn chưa bao giờ nghe tới trước đó.</p><p>Vậy, bạn cần biết tất cả những thuộc tính mới này ngay bây giờ? Ngay lập tức?</p><p>Không, bạn không cần!</p><p>Bạn chỉ cần học một vài thuộc tính cần thiết ngay lúc này để tạo ra kết quả mong muốn. Những thuộc tính khác có thể học sau. Đó là định nghĩa về “hiệu quả” của tôi.</p><hr><h3 id="1-CSS-Grid-layout-la-gi"><a href="#1-CSS-Grid-layout-la-gi" class="headerlink" title="1. CSS Grid layout là gì ?"></a>1. CSS Grid layout là gì ?</h3><p>Nếu bạn mới học bố cục trong CSS, CSS Grid có thể khá xa lạ với bạn.</p><p>Bạn đã nghe nói tới Flexbox chưa?</p><p>Tôi thích coi CSS Grid như là một người anh (hoặc cha) của Flexbox.</p><p>Xử lý các bố cục trong CSS được coi là một công việc khó khăn và không hấp dẫn. Flexbox đã làm cho mọi thứ dễ dàng hơn - nhưng CSS Grid thậm chí còn tốt hơn.</p><h3 id="Cai-chung-ta-se-xay-dung"><a href="#Cai-chung-ta-se-xay-dung" class="headerlink" title="Cái chúng ta sẽ xây dựng."></a>Cái chúng ta sẽ xây dựng.</h3><p>Chúng ta sẽ học cách áp dụng 20% kiến thức học được để xây dựng bố cục responsive của một ứng dụng âm nhạc</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*ripUP4LuXPQ851Zlq79bWQ.gif" alt="a responsive music app, catty music"></p><h3 id="Phan-1-10-ban-can-biet-Cac-thuat-ngu-co-ban"><a href="#Phan-1-10-ban-can-biet-Cac-thuat-ngu-co-ban" class="headerlink" title="Phần 1: 10% bạn cần biết - Các thuật ngữ cơ bản"></a>Phần 1: 10% bạn cần biết - Các thuật ngữ cơ bản</h3><p>Chúng ta hãy nhìn vào những điều đầu tiên bạn bắt buộc phải biết.</p><hr><h4 id="Grid-Container-la-gi"><a href="#Grid-Container-la-gi" class="headerlink" title="Grid Container là gì?"></a>Grid Container là gì?</h4><p>Mỗi bố cục các trang web hoặc ứng dụng bạn tạo ra (hoặc thấy) về bản chất là những chiếc hộp được đặt trong những đường ranh giới xác định.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*uFGh3Vo2i9MneYvjqJNhRw.gif" alt="gif by chris bannister"></p><p>Hiểu đơn giản, grid chỉ là “những đường kẻ”. Những đường kẻ ngang và dọc xác định vị trí của các phần tử được thiết kế khác nhau.</p><p>Bạn sẽ quen với grid nếu bạn đã sử dụng các phần mềm thiết kế như photoshop hoặc sketch.</p><p>Trong bối cảnh của CSS Grid layout, một Grid container là phần tử cha chứa tất cả các phần tử nằm trong grid. Grid container xác định vị trí ban đầu của các đường kẻ trong grid, cả dọc và ngang.</p><h4 id="Grid-Line-la-gi"><a href="#Grid-Line-la-gi" class="headerlink" title="Grid Line là gì?"></a>Grid Line là gì?</h4><p>Giả sử bạn có một bố cục như thế này:</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*xcID2GAZoYqhb4LYjN6Qug.png" alt="supposed grid layout"></p><p>Bố cục bao gồm một grid container với các phần tử ở bên trong</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*9K74dULhLERm5_3a37Byqw.png" alt="a bit of explanation"></p><p>Grid lines chính là những đường kẻ ngang và dọc phân chia grid thành các ô.</p><h4 id="Grid-Cell-la-gi"><a href="#Grid-Cell-la-gi" class="headerlink" title="Grid Cell là gì?"></a>Grid Cell là gì?</h4><p>Grid cell là đơn vị nhỏ nhất trong grid layout. Bất kỳ khoảng trống nào được xác định bởi 4 đường grid line.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*7X_NTZG0ikpVwsaB0qfdAw.png" alt="The “small boxes” of grid items may be referred to as grid cells."></p><h4 id="Grid-Area"><a href="#Grid-Area" class="headerlink" title="Grid Area"></a>Grid Area</h4><p>Một grid area có thể giống như một grid cell (giống như ở phần trước). Hoặc cũng có thể trải rộng trên nhiểu hoặc tất cả grid cell trong grid.</p><p>Trong hình vẽ dưới đây, grid area trải rộng trên 4 ô.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*_4ZnWO3zlt82VMHQ_3VNXA.png" alt=""></p><h4 id="Grid-Track-la-gi"><a href="#Grid-Track-la-gi" class="headerlink" title="Grid Track là gì?"></a>Grid Track là gì?</h4><p>Một grid track có thể xem như một tên gọi khác cho các cột và các dòng. Nó là khoảng trống giữa 2 grid line bất kỳ.</p><p>Hình dưới đây là ví dụ về grid tracks</p><p><img src="https://cdn-images-1.medium.com/max/800/1*oan28239S-v0oJZECQPKIA.png" alt=""></p><p><img src="https://cdn-images-1.medium.com/max/800/1*-tby4L7UaQavuy6uc0H1LQ.png" alt=""></p><p><img src="https://cdn-images-1.medium.com/max/800/1*xkbT0CjkBWb-5S_hxcBvGw.png" alt="grid tracks"></p><p>Vì vậy, chúng tôi đã phân loại được tất cả trong phần đầu tiên.</p><h3 id="Phan-2-10-con-lai-ma-ban-can-biet-ve-CSS-grid"><a href="#Phan-2-10-con-lai-ma-ban-can-biet-ve-CSS-grid" class="headerlink" title="Phần 2: 10% còn lại mà bạn cần biết về CSS grid."></a>Phần 2: 10% còn lại mà bạn cần biết về CSS grid.</h3><p>Bây giờ bạn đã hiểu các thuật ngữ cơ bản, giống như một đứa trẻ mạo hiểm, hãy bắt đầu!</p><h4 id="Lam-the-nao-de-dinh-nghia-mot-Grid"><a href="#Lam-the-nao-de-dinh-nghia-mot-Grid" class="headerlink" title="Làm thế nào để định nghĩa một Grid?"></a>Làm thế nào để định nghĩa một Grid?</h4><p>Giống như Flexbox, mọi thứ bắt đầu với display: grid hoặc display: inline-grid cho phiên bản inline.</p><p>Ví dụ, để biến một div thành một grid container:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lam-the-nao-de-tao-cac-cot-va-dong"><a href="#Lam-the-nao-de-tao-cac-cot-va-dong" class="headerlink" title="Làm thế nào để tạo các cột và dòng?"></a>Làm thế nào để tạo các cột và dòng?</h4><p>Để tạo các cột và các dòng trong một grid container, chúng ta sẽ sử dụng 2 thuộc tính mới: <code>grid-template-columns</code> và <code>grid-template-rows</code>.</p><p>Vậy sử dụng chúng như thế nào? Khá đơn giản.</p><p><code>grid-template-columns</code> định nghĩa vị trí của các cột. <code>grid-template-rows</code> định nghĩa vị trí của các dòng.</p><p>Bạn truyền giá trị vào các thuộc tính này, và chúng tạo ra các dòng và các cột.</p><p>Xem ví dụ:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 100<span class="selector-tag">px</span> 200<span class="selector-tag">px</span> 300<span class="selector-tag">px</span></span><br></pre></td></tr></table></figure><p>Đoạn code này sẽ tạo thành 3 cột mới trong grid container. Cột đầu tiên có độ rộng 100px, cột tiếp theo 200px và cột cuối 300px.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*OGJmxXekTwSlW-aoTeSXEw.png" alt="grid-template-columns: 100px 200px 300px"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-rows</span>: 100<span class="selector-tag">px</span> 200<span class="selector-tag">px</span> 300<span class="selector-tag">px</span></span><br></pre></td></tr></table></figure><p>Đoạn code này sẽ tạo 3 dòng mới trong grid container như hình dưới đây:</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*TcGMy7iMxXoRbqs8hL0NHw.png" alt="grid-template-rows: 100px 200px 300px"></p><p>Bây giờ đặt chúng cùng nhau, bạn sẽ có một grid hoàn chỉnh với các dòng và cột đã được định nghĩa.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 100<span class="selector-tag">px</span> 200<span class="selector-tag">px</span> 300<span class="selector-tag">px</span></span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: 100<span class="selector-tag">px</span> 200<span class="selector-tag">px</span> 300<span class="selector-tag">px</span></span><br></pre></td></tr></table></figure><h3 id="Phan-3-Bat-tay-vao-Code-CSS-Grid"><a href="#Phan-3-Bat-tay-vao-Code-CSS-Grid" class="headerlink" title="Phần 3: Bắt tay vào Code - CSS Grid"></a>Phần 3: Bắt tay vào Code - CSS Grid</h3><p>Bây giờ chúng ta hãy thực hiện các bước để xây dựng bản sao của ứng dụng âm nhạc nổi tiếng, nhạc catty</p><p>Để phát triển nhanh chóng, tôi sẽ sử dụng <a href="http://www.codepen.io" target="_blank" rel="noopener">Codepen</a>. Tạo một dự án mới và hãy bắt đầu.</p><h3 id="Lam-the-nao-de-tao-ra-bo-khung-cho-ung-dung-Catty-Music"><a href="#Lam-the-nao-de-tao-ra-bo-khung-cho-ung-dung-Catty-Music" class="headerlink" title="Làm thế nào để tạo ra bộ khung cho ứng dụng Catty Music"></a>Làm thế nào để tạo ra bộ khung cho ứng dụng Catty Music</h3><p>Sau khi đã tạo một project trên codepen. Chúng ta sẽ tạo một tài liệu html cơ bản:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Có mục đích khi chọn cấu trúc này. Bạn sẽ sớm nhận ra điều đó.</p><p>Bây giờ style tài liệu.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   <span class="attribute">display</span>: grid;</span><br><span class="line">   <span class="attribute">min-height</span>: <span class="number">100%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đoạn code này sẽ biến body thành một grid-container.</p><p>Bây giờ chúng ta cần tạo cấu trúc các dòng và cột trong grid.</p><h3 id="Lam-the-nao-de-tao-ra-cac-dong-va-cac-cot-cho-ung-dung-Catty-Music"><a href="#Lam-the-nao-de-tao-ra-cac-dong-va-cac-cot-cho-ung-dung-Catty-Music" class="headerlink" title="Làm thế nào để tạo ra các dòng và các cột cho ứng dụng Catty Music"></a>Làm thế nào để tạo ra các dòng và các cột cho ứng dụng Catty Music</h3><p>Tạo các dòng và cột là khá dễ dàng.</p><p>Kết quả cuối cùng chúng cần đạt được là:</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*VFkE679czY0Tb49R9GNvyg.png" alt="final layout we seek."></p><p>Tuy nhiên, ban đầu khi thiết lập grid chúng ta cần 2 dòng và 2 cột.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*80Qn4c32kqbQzMVh-AcAoQ.png" alt="initial grid setup"></p><h4 id="Day-la-mot-vai-thu-can-chu-y-ve-thiet-lap-Grid"><a href="#Day-la-mot-vai-thu-can-chu-y-ve-thiet-lap-Grid" class="headerlink" title="Đây là một vài thứ cần chú ý về thiết lập Grid"></a>Đây là một vài thứ cần chú ý về thiết lập Grid</h4><p><strong>Columns:</strong></p><ol><li>Cột đầu tiên phải có độ rộng cố định là 50px.</li><li>Cột thứ 2 phải chiếm toàn bộ độ rộng còn lại của dòng.</li></ol><p><strong>Rows:</strong></p><ol><li>Dòng thứ 2 phải có chiều cao cố định là 100px.</li><li>Dòng đầu tiên phải chiếm toàn bộ chiều còn lại của grid.</li></ol><h4 id="Giai-phap-cua-mot-nguoi-it-kinh-nghiem"><a href="#Giai-phap-cua-mot-nguoi-it-kinh-nghiem" class="headerlink" title="Giải pháp của một người ít kinh nghiệm."></a>Giải pháp của một người ít kinh nghiệm.</h4><p>Nếu bạn KHÔNG có kinh nghiệm với CSS, bạn có thể viết như thế này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   ...   </span><br><span class="line">   <span class="selector-tag">grid-template-rows</span>: 100% 100<span class="selector-tag">px</span>;</span><br><span class="line">   <span class="selector-tag">grid-template-columns</span>: 50<span class="selector-tag">px</span> 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vấn đề với giải pháp này là bạn đã vô tình tạo ra một grid với chiều rộng là 100% + 50px và chiều cao là 100% + 100px.</p><p>Cái chúng ta muốn là chiều rộng và chiều cao là 100%. Vì thế hướng tiếp cần này là sai.</p><h4 id="Giai-phap-cua-nguoi-da-co-kinh-nghiem"><a href="#Giai-phap-cua-nguoi-da-co-kinh-nghiem" class="headerlink" title="Giải pháp của người đã có kinh nghiệm"></a>Giải pháp của người đã có kinh nghiệm</h4><p>Nếu đã có một vài kinh nghiệm với CSS, bạn có thể làm một vài thứ thông minh hơn như thế này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="selector-tag">grid-template-rows</span>: <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 100<span class="selector-tag">px</span>) 100<span class="selector-tag">px</span>;</span><br><span class="line">   <span class="selector-tag">grid-template-columns</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">calc</span>(100%<span class="selector-tag">-50px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cách này khá thông minh. Nhưng có một vấn đề - nó rất khó để bảo dưỡng.</p><p>Ví dụ, nếu vì một lý do nào đó bạn phải thay đổi độ rộng cố định, bạn cũng phải thay đổi định nghĩa calc.</p><h4 id="Giai-phap-hieu-qua-nhat"><a href="#Giai-phap-hieu-qua-nhat" class="headerlink" title="Giải pháp hiệu quả nhất"></a>Giải pháp hiệu quả nhất</h4><p>May mắn là CSS Grid có một đơn vị mới giúp chúng ta giải quyết vấn đề ở trên một cách dễ dàng đó là đơn vị. <a href="https://medium.com/flexbox-and-grids/the-css-fractional-unit-fr-in-approachable-plain-language-fdc47bd387f7" target="_blank" rel="noopener">factional(fr)</a></p><p>Đơn vị fractional giải quyết vấn đề tự động phân bố khoảng trống.</p><p>Nếu bạn có grid với 3 cột như ở dưới, đơn vị fractional sẽ tự động phân bổ các khoảng trống bằng nhau.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*1TWb0kZ4nn6uvykRLMGtOw.png" alt=""></p><p>INếu vì một vài lý do bạn thêm nhiều phần tử hơn - đừng lo lắng. Đơn vị fr sẽ phân bổ lại các khoảng trống bằng nhau.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*D5ILayU5dx_la2wnyn6ZYw.png" alt=""></p><p>Cuối cùng, nếu bạn đã có một phần tử với độ rộng cố định, bạn có thể lấy toàn bộ khoảng trống còn lại với đơn vị fr. Như thế này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="selector-tag">grid-template-rows</span>: 1<span class="selector-tag">fr</span> 100<span class="selector-tag">px</span>;</span><br><span class="line">   <span class="selector-tag">grid-template-columns</span>: 50<span class="selector-tag">px</span> 1<span class="selector-tag">fr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And that is it — done!</p><h3 id="Dat-ten-va-xac-dinh-vi-tri-boi-Grid-Areas"><a href="#Dat-ten-va-xac-dinh-vi-tri-boi-Grid-Areas" class="headerlink" title="Đặt tên và xác định vị trí bởi Grid Areas"></a>Đặt tên và xác định vị trí bởi Grid Areas</h3><p>Chúng ta đã tạo ra hệ thống grid. Bây giờ là lúc để sử dụng nó.</p><p>Mục đích của phần này học cách xác định vị trí các phần tử trong grid sử dụng grid areas.</p><p>Nhắc lại một chút, một grid area là bất kỳ khoảng trống được bao bởi 4 grid line.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*7X_NTZG0ikpVwsaB0qfdAw.png" alt="The “small boxes” of grid items may be referred to as grid cells."></p><h4 id="Lam-the-nao-de-su-dung-grid-areas"><a href="#Lam-the-nao-de-su-dung-grid-areas" class="headerlink" title="Làm thế nào để sử dụng grid areas?"></a>Làm thế nào để sử dụng grid areas?</h4><p>Nơi hợp lý để bắt đầu là đặt tên grid areas<br>Hãy để tôi giải thích.<br>Xem xét khối lệnh dưới đây:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3 divs - đơn giản. Bằng cách này, Nó là ngữ nghĩa tốt hơn để sử dụng tags aside main và footer. Tôi sẽ giữ mọi thứ đơn giản.</p><p>Bây giờ hãy xem đoạn code này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Chuyen-gi-dang-xay-ra-o-day"><a href="#Chuyen-gi-dang-xay-ra-o-day" class="headerlink" title="Chuyện gì đang xảy ra ở đây"></a>Chuyện gì đang xảy ra ở đây</h4><p>Nếu biết một chút về Javascript, hay bất kỳ ngôn ngữ lập trình nào khác, thì khái niệm về biến sẽ không phải là mới với bạn.</p><p>Trong Javascript, chúng ta có thể nói:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gridArea = <span class="string">"content"</span></span><br></pre></td></tr></table></figure><p>Cái chúng ta làm ở phía trên là, lưu chuỗi <code>content</code> vào biến <code>gridArea</code></p><p>Khai báo CSS ở phần trước tương tự như vậy.</p><blockquote><p>Mọi phần tử trong grid có thể được gán tới một vùng trong grid container.</p></blockquote><p>Tuy nhiên, trước khi làm điều đó, chúng ta bắt buộc phải gán mỗi phần tử trong grid với một tên gọi. Giống như các biến trong Javascript.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đoạn code ở trên nói rằng, class <code>.main</code> có tên là <code>content</code>. Class <code>.footer</code> có tên là <code>footer</code>. Cuối cùng, class <code>.aside</code> có tên là <code>sidebar</code></p><p>Bây giờ các grid items được gán tên cho mỗi vùng.</p><p>Trong lập trình, các biến được thiết lập để được sử dụng ở nơi khác. Bây giờ, hãy sử dụng tên grid area.</p><h4 id="Vi-tri-Grid-area"><a href="#Vi-tri-Grid-area" class="headerlink" title="Vị trí Grid area"></a>Vị trí Grid area</h4><p>Một người đàn ông trẻ có một cái bánh nướng. Anh ta có 3 đứa con và phải chia cho mỗi đứa một phần. Ai là người chia bánh thì hợp lý nhất?</p><p>Chính người đàn ông đó!</p><p>Người đàn ông trẻ cắt bánh và chia cho mỗi đứa trẻ một phần.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*xN-041OZXzMZvCJ76WRtfQ.jpeg" alt="yummy!"></p><p>Đây là lý do tôi kể câu chuyện này.</p><p>Giống như chiếc bánh, toàn bộ khoảng trống trong grid là của ai?</p><p>Chính là grid container!</p><p>Giống như người đàn ông trẻ, grid container có 3 đứa con <code>.aside</code> <code>.main</code> và <code>.footer</code>. Bây giờ grid container phải chọn cách chia toàn bộ khoảng trống trong grid cho 3 đứa con này.</p><p>Và một điều nữa.</p><p>Vì tất cả những đứa trẻ đều có tên, người đàn ông trẻ có thể nói: “hey Brian đây là phần của con hoặc hey Emma của con là phần này.”</p><p>Dễ dàng để xác định ai sở hữu phần nào của chiếc bánh, bằng cách gán mỗi phần với tên của mỗi người.</p><p>Mỗi phần tử trong grid đều đã có tên bằng cách sử dụng thuộc tính grid-area.</p><p>Bây giờ, hãy chia bánh!</p><h4 id="Thuoc-tinh-grid-template-areas"><a href="#Thuoc-tinh-grid-template-areas" class="headerlink" title="Thuộc tính grid-template-areas"></a>Thuộc tính grid-template-areas</h4><p>Bây giờ grid container phải chia “bánh”. Gán mỗi vùng tới mỗi phần tử tương ứng.</p><p>Có nhiều cách để làm điều đó, nhưng thuộc tính <code>grid-template-areas</code> là cách dễ dàng nhất để làm đó. nó chính là cái bạn cần biết để làm việc hiệu quả.</p><h4 id="Thuoc-tinh-grid-template-areas-lam-viec-nhu-the-nao"><a href="#Thuoc-tinh-grid-template-areas-lam-viec-nhu-the-nao" class="headerlink" title="Thuộc tính grid-template-areas làm việc như thế nào?"></a>Thuộc tính grid-template-areas làm việc như thế nào?</h4><p>Hãy xem đoạn code dưới đây:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">      <span class="attribute">grid-template-areas</span>: <span class="string">"sidebar  content"</span></span><br><span class="line">                           <span class="string">"footer   footer"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Cái quái gì vậy?</p><p>Không cần phải bị choáng ngợp. Trong phần này, tôi sẽ giải thích nó hoạt động như thế nào - theo thuật ngữ rõ ràng.</p><p>Thuộc tính grid-template-areas cung cấp một cấu trúc rất trực quan của grid.</p><p>Hãy xem lại đoạn code trên một lần nữa:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">      <span class="attribute">grid-template-areas</span>: <span class="string">"sidebar  content"</span></span><br><span class="line">                           <span class="string">"footer   footer"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Bạn có thể thấy toàn bộ giá trị của thuộc tính là tên của các phần tử trong grid!</p><p><code>sidebar</code> <code>content</code> và <code>footer</code> là tên của các phần tử trong grid. Khai báo ở trên gán mỗi vùng trong grid với một phần tử tương ứng.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*NjMwDa_1b1vHkAbpXI_f7w.png" alt=""></p><p>Hình ảnh trên sẽ giúp bạn hiểu grid được chia như thế nào.</p><p><code>footer</code> sẽ chiếm toàn bộ dòng bên dưới. <code>sidebar</code> và <code>content</code> sẽ chiếm cột đầu tiên và thứ 2 của dòng bên bên.</p><p>Đến đây chúng ta có:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: grid;</span><br><span class="line">      <span class="attribute">grid-template-columns</span>: <span class="number">40px</span> <span class="number">1</span>fr;</span><br><span class="line">      <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">90px</span>;</span><br><span class="line">      <span class="attribute">grid-template-areas</span>: <span class="string">"sidebar  content"</span></span><br><span class="line">                           <span class="string">"footer  footer"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Kết quả sẽ như dưới đây:</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*LNfazbNhUOy6YBEE7Sr_Uw.png" alt="STEP 1: https://codepen.io/ohansemmanuel/pen/bRWrPE"></p><p>Tôi đã thêm màu sắc để hỗ trợ hình ảnh. Phần màu đỏ đại diện cho <code>.footer</code>, hai phần còn lại, phần <code>.main</code> và <code>.sidebar</code>.</p><h3 id="Lam-cho-bo-cuc-responsive-Dinh-nghia-lai-Grid-areas-voi-Media-Queries"><a href="#Lam-cho-bo-cuc-responsive-Dinh-nghia-lai-Grid-areas-voi-Media-Queries" class="headerlink" title="Làm cho bố cục responsive - Định nghĩa lại Grid areas với Media Queries"></a>Làm cho bố cục responsive - Định nghĩa lại Grid areas với Media Queries</h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*9H_Ylq3VVHRLQRTZZLYbQQ.gif" alt="gif by Muharrem Senyil"></p><p>Các Grid area mà bạn đã tạo trong grid container có thể thay đổi tùy theo kích thước màn hình của người sử dụng.</p><p>Dưới đây là hình ảnh ứng dụng trên màn hình điện thoại.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*Gd8H2uQF3-TVi4lq7g1UAw.png" alt="Catty Music, on mobile"></p><p>Chúng ta sẽ refactor lại code theo hướng tiếp cận mobile first.</p><p>Mobile first đơn giản là làm cho style mặc định của bạn là dành cho các thiết di động. Sau đó bạn sẽ tạo ra các thay đổi cho các màn hình lớn hơn thông qua các media query.</p><p>Đặt một phần code hiện nay trong một định nghĩa media query. Như dưới đây:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">1</span>fr;</span><br><span class="line">        <span class="attribute">grid-template-areas</span>: <span class="string">"sidebar  content"</span></span><br><span class="line">                             <span class="string">"footer   footer"</span>;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bạn sẽ để đoạn code mặc định bên ngoài media query</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tại sao chúng ta đặt grid-template-rows: 1fr 100px; bên ngoài media query?</p><p>Bởi vì cả màn hình di động và desktop chúng ta đều có 2 dòng.</p><p>Tuy nhiên, trên màn hình desktop. Sidebar là 50px trong định nghĩa grid-template-columns. Còn trên các thiết bị di động sidebar không tồn tại.</p><p>Vì thế, chúng ta sẽ định nghĩa lại khai báo <code>grid-template-columns</code> cho di động.</p><p>Bây giờ với các thiết bị di động chúng ta sẽ sử dụng style này là mặc định:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   <span class="attribute">grid-template-areas</span>: <span class="string">"content"</span></span><br><span class="line">                        <span class="string">"footer"</span></span><br></pre></td></tr></table></figure><p>Khá đơn giản phải không? Hãy để tôi giải thích.</p><h3 id="Dong-chay-huong-cua-Grid"><a href="#Dong-chay-huong-cua-Grid" class="headerlink" title="Dòng chảy (hướng) của Grid"></a>Dòng chảy (hướng) của Grid</h3><p>Đoạn code cho di động như thế này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   <span class="attribute">grid-template-areas</span>: <span class="string">"content"</span></span><br><span class="line">                        <span class="string">"footer"</span></span><br></pre></td></tr></table></figure><p>Bởi mặc định, một grid sẽ sắp xếp các phần tử trên các dòng.</p><p>Vì thế khai báo ở phía trên sẽ sắp xếp content trên một dòng và footer trên một dòng khác.</p><p>Dưới đây là kết quả - sidebar sẽ ẩn trên màn hình di động:</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*WeVXg_bAwa5UKqdZHiwQ7w.gif" alt="STEP 2: https://codepen.io/ohansemmanuel/pen/qjVvjJ?editors=1100"></p><p>Với rào cản ban đầu của sự hiểu biết cách hoạt động của grids và thiết lập responsive grid, chúng ta đã xong bố cục ứng dụng!</p><h3 id="Them-noi-dung-vao-trong-Grid"><a href="#Them-noi-dung-vao-trong-Grid" class="headerlink" title="Thêm nội dung vào trong Grid"></a>Thêm nội dung vào trong Grid</h3><p>Khi kết thúc phần này chúng ta sẽ có một bố cục ứng dụng âm nhạc hoàn chỉnh. Bây giờ hãy tập trung và việc sắp xếp nội dung trong grid.</p><h4 id="1-The-Sidebar"><a href="#1-The-Sidebar" class="headerlink" title="1. The Sidebar"></a>1. The Sidebar</h4><p>Điều này có vẻ dễ nhất để bắt đầu. Hãy đi tìm nó.</p><p>Sidebar bao gồm 8 icon cách đều nhau dọc theo toàn bộ chiều dài của sidebar.</p><p>Hãy chèn các icon vào sidebar:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-bars"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-home"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-search"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-volume-up"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-spotify"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-cog"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-soundcloud"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Kết quả sẽ như thế này: </p><p><img src="https://cdn-images-1.medium.com/max/2000/1*DY1tA49VLEOy0I5Fb_HmlQ.png" alt="https://codepen.io/ohansemmanuel/pen/BZmbza"></p><p>Các icon cũng sẽ ẩn trên màn hình di động. Và chỉ hiển thị trên các màn hình lớn hơn. Đây là hướng tiếp cận mobile first.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.aside</span> <span class="selector-tag">i</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> only screen and (min-width:<span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.aside</span> <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Các biểu tượng được hiển thị, nhưng được căn chỉnh chưa đều.</p><h4 id="Sap-xep-cac-icon"><a href="#Sap-xep-cac-icon" class="headerlink" title="Sắp xếp các icon"></a>Sắp xếp các icon</h4><p>Các thẻ <code>i</code> là các phần tử <code>inline</code> – điều đó giải thích tại sao 2 icon lại hiển thị cạnh nhau trên một dòng.</p><p>Hãy sắp xếp chúng.</p><blockquote><p>Các phần tử con của grid container cũng có thể trở thành các grid container. Tại sao không?</p></blockquote><h4 id="Buoc-1-Bien-Sidebar-thanh-mot-Grid-Container"><a href="#Buoc-1-Bien-Sidebar-thanh-mot-Grid-Container" class="headerlink" title="Bước 1: Biến Sidebar thành một Grid Container"></a>Bước 1: Biến Sidebar thành một Grid Container</h4><p>Điều này sẽ cung các tính năng căn chỉnh của grid.</p><p>Khi sidebar chỉ hiển thị trên các màn hình lớn hơn, đừng quên đặt nó trong media query.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (min-width:<span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.aside</span> &#123;</span><br><span class="line">     <span class="attribute">display</span>: grid; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="selector-class">.aside</span> <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tôi thêm border cho mỗi icon - để chúng ta dễ phân biệt.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*QcpsRWdU5Q01YC-C2Et11w.png" alt=""></p><p>Chuyện gì đang xảy ra ở đây?</p><p>Chúng ta KHÔNG thiết lập bất kỳ dòng hay cột trong sidebar. Nhưng chúng ta thấy các icon được sắp xếp khá tốt. Grid tự động thiết lập điều đó.</p><p>Đây là vị trí mặc định của các item trong một grid – trên cùng một dòng.</p><p>Một grid cũng có thể sắp xếp các phần tử sử dụng <code>justify-items</code> hay <code>align-items</code>.</p><p><code>justify-items</code> sẽ sắp xếp các phần tử theo chiều ngang.</p><p><code>align-items</code> sẽ sắp xếp các phần tử theo chiều dọc.</p><p>Áp dụng điều này cho sidebar, và chúng ta có một bổ cục các icon hoàn hảo:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="selector-tag">justify-items</span>: <span class="selector-tag">center</span>;</span><br><span class="line">     <span class="selector-tag">align-items</span>: <span class="selector-tag">center</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Bạn vẫn cảm thấy khó hiểu, hãy xem video dưới đây:</p><div class="video-container"><iframe src="//www.youtube.com/embed/pN2rGbEfNw8" frameborder="0" allowfullscreen></iframe></div><p>Bây giờ chúng ta đã một bố cục hoàn hảo dành cho các icon trong sidebar.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*gwdH9pKxjMw7MnO8vPmTgw.png" alt="https://codepen.io/ohansemmanuel/pen/MorYJq?editors=1100"></p><p><code>justify-items</code> hay <code>align-items</code> có thể có các giá trị:</p><ul><li>stretch</li><li>start</li><li>end</li><li>center</li></ul><p>Nếu đã từng làm việc với Flexbox, bạn sẽ quen với chúng.</p><p>Chúng ta sẽ thêm nhiều nội dung hơn vào thiết kế hiện tại.</p><p>Thêm 2 thẻ div vào main section:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main__header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main__body"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>NB:</strong></p><ol><li><code>main__header</code> sẽ chứa music art và playbacks:</li></ol><p><img src="https://cdn-images-1.medium.com/max/2000/1*K2ikIxNuiWo8tfY-5RvBXg.png" alt=".main__header"></p><ol><li><code>main__body</code>sẽ chứa chi tiết:</li></ol><p><img src="https://cdn-images-1.medium.com/max/2000/1*hc80JsuD3IsxxwrAijFWzQ.png" alt=".main__body"></p><p>Trong phần này chúng ta sẽ tập trung vào <code>main__header</code></p><p>Đầu tiên, thêm đoạn code html này:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main__header"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://bit.ly/2sc2NJd"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"details"</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span>CattyBoard Top 100 Single Charts (11.06.36)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sm--hide"</span>&gt;</span>Unknown Artist<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sm--hide"</span>&gt;</span>2016 . Charts . 100 songs<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">               <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-play"</span>&gt;</span> &amp;nbsp;Play all<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-plus"</span>&gt;</span> &amp;nbsp;Add to<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-ellipsis-h"</span>&gt;</span>&amp;nbsp;&amp;nbsp;More<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Chú ý cấu trúc của tài liệu</p><p><code>main__header</code> có hai con trực tiếp. Một <code>div</code> chứa một hình ảnh và <code>section</code> chứa thông tin chi tiết của album.</p><p>Kết quả của đoạn code trên khá xấu xí:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*uhNqMg2RUv_bo5371BrOfQ.png" alt="incomplete header"></p><p>Hãy làm cho nó đẹp hơn.</p><p>Cái chúng ta cần là một grid với các phần tử được sắp xếp phù hợp.</p><p>Hãy sử dụng những kiến thức về grid areas</p><p>Đầu tiên, định nghĩa grid area:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main__header</span> &gt; <span class="selector-class">.img</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: img;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main__header</span> &gt; <span class="selector-class">.details</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: dtls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>div</code> chứa hình ảnh được đặt tên là <code>img</code>. Phần chứa thông tin chi tiết của album được đặt tên là <code>dtls</code>.</p><p>Bây giờ, định nghĩa grid:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main__header</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">"img"</span></span><br><span class="line">                       <span class="string">"dtls"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>.main__header</code> trở thành một grid container, có 2 phần tử xếp chồng lên nhau đầu tiên là <code>img</code> tiếp theo là <code>dtls</code>. Bởi vì chúng ta đang theo hướng tiếp cận mobile first.</p><p>Tại thời điểm này, không có nhiều thay đổi.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*h60PmaHUtZAMZrC5xrRtbA.png" alt="I have included borders and made the text whitish for visual aid."></p><p>Đây không phải là cái chúng ta muốn trên di động.</p><p>Với màn hình di động, các phần tử nên được căn giữa.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.main__header</span> &#123;</span><br><span class="line">    <span class="attribute">justify-items</span>: center;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kết quả sẽ như dưới đây:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*9Yi3TudvNbbTdYtDBsqL1w.png" alt=""></p><p>Tiếp theo hãy làm cho text trong <code>.details</code> căn giữa:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.main__header</span> &gt; <span class="selector-class">.details</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1600/1*Dj_iJrYWYA4lpQdxuzx4Cw.png" alt=""></p><p>Đã khá gần với mục tiêu chỉ cần thêm một vài điều chỉnh.</p><p>Đoạn text <code>Unknown Artist</code> và <code>2016</code> . <code>Charts</code> . <code>100 songs</code> nên ẩn trên di động. Ảnh cũng nên nhỏ hơn.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.sm--hide</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="selector-class">.img</span> &gt; <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class <code>.sm--hide</code> sẽ ẩn trên di động. Chỉ cần thêm class tới phần tử mong muốn. Như thế này:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sm--hide"</span>&gt;</span>Unknown Artist<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sm--hide"</span>&gt;</span>2016 . Charts . 100 songs<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Và chúng ta có:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*3EldPliJB9kqZmu9B1UaRg.png" alt=""></p><p>Màn hình di động đã xong. Giờ hãy thêm style cho những màn hình lớn hơn.</p><p>Với màn hình lớn hơn, chúng ta cần một grid 2 cột. Style sẽ như thế này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (min-width:<span class="number">600px</span>) &#123;</span><br><span class="line">   <span class="selector-class">.main__header</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">250px</span> <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: <span class="string">"img dtls"</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Grid đã được định nghĩa lại với 2 cột. Một có độ rộng cố định là 250px và cột kia chiếm toàn bộ khoảng trống còn lại.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*iFRIMSqQYAl2AhHBgsCjdw.gif" alt="https://codepen.io/ohansemmanuel/pen/gReOQJ?editors=1100"></p><p>Tiến trình hiện tại của chúng ta <a href="https://codepen.io/ohansemmanuel/pen/gReOQJ?editors=1100" target="_blank" rel="noopener">here</a>.</p><h3 id="Phan-4-Ket-hop-CSS-Grid-voi-Flexbox"><a href="#Phan-4-Ket-hop-CSS-Grid-voi-Flexbox" class="headerlink" title="Phần 4: Kết hợp CSS Grid với Flexbox"></a>Phần 4: Kết hợp CSS Grid với Flexbox</h3><p>Trong phần này bạn sẽ học cách sử dụng Flexbox và Grid cùng nhau.</p><p>Hai module này đã thay đổi cách xử lý bố cục trong CSS. Và cách hiệu quả nhất là sử dụng cả 2 module cùng nhau.</p><p>Hãy đi vào chi tiết.</p><p>Với phần hiển thị thông tin chi tiết của album chúng ta sẽ sử dụng flexbox.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*hc80JsuD3IsxxwrAijFWzQ.png" alt=""></p><h4 id="Lam-sao-de-biet-cho-nao-se-su-dung-Flexbox"><a href="#Lam-sao-de-biet-cho-nao-se-su-dung-Flexbox" class="headerlink" title="Làm sao để biết chỗ nào sẽ sử dụng Flexbox?"></a>Làm sao để biết chỗ nào sẽ sử dụng Flexbox?</h4><p>Quy tắc chung là sử dụng Grid cho bố cục toàn bộ trang, còn Flexbox dành cho UI bên trong các phần tử con.</p><p>Một phần tử con có thể là một flex container. Một phần tử con của flex container cũng có thể là một grid container.</p><p>Tôi giả sử rằng bạn đã biết về <a href="https://medium.freecodecamp.org/understanding-flexbox-everything-you-need-to-know-b4013d4dc9af" target="_blank" rel="noopener">flexbox</a>.</p><p>Như thường lệ, hãy bắt đầu bằng html</p><p>Dưới đây là một div, với một danh sách các bài hát. Danh sách các bài hát có các đoạn có chứa tên bài hát, nghệ sĩ, thời lượng của bài hát và “catty cloud sync”.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main__body"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>1. One Dance<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Crake feat CatKid &amp;amp; Cyla<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>2:54<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>CATTY CLOUD SYNC<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>2. Panda<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Cattee<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>4:06<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>CATTY CLOUD SYNC<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>3. Can't Stop the Feeling!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Catin Cimberlake<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>3:56<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>CATTY CLOUD SYNC<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>4. Work From Home<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Cat Harmony feat Colla<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>3:34<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>CATTY CLOUD SYNC<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Đây là cái chúng ta có:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*lz7cE6DLCPeX-S6bwCVRJw.gif" alt=""></p><p><code>main__body</code> là một phần tử của grid. Chúng ta có thể biến nó thành flex container nếu điều đó hữu ích.</p><p>Trong trường hợp của chúng ta, mỗi thẻ div là con trực tiếp của <code>main__body</code> cần trở thành một flex container. Chúng chứa tên bài hát, nghệ sĩ, thời gian và “catty cloud sync”.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main__body</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bây giờ chia chiều rộng cho các phần tử con:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main__body</span> &gt; <span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">25%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1600/1*F7_nB62n6q9TV9aDJJ23tA.png" alt="https://codepen.io/ohansemmanuel/full/pwLEBL/"></p><p>Bạn sẽ đồng ý với tôi rằng tại thời điểm này, các yếu tố cần thiết cho bố cục đã hoàn thành.</p><p>Tuy nhiên, tôi đã thực hiện một vài thay đổi. Bạn có thể xem kết quả cuối cùng <a href="https://codepen.io/ohansemmanuel/full/QgxEqz/" target="_blank" rel="noopener">here</a></p><p>Bạn sẽ nhận thấy rằng tôi vẫn để trống footer. Đó là bài tập cho bạn. Lời khuyên của tôi là sử dụng flexbox. Nó sẽ giúp bạn hiểu cách cả hai module này làm việc cùng nhau.</p><hr><p>Với một vài thuộc tính của grid, bạn đã xây dựng một bố cục thực sự. Khá ấn tượng. Bạn cũng học được kỹ năng vô giá khi kết hợp CSS Grid với Flexbox.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Gioi-thieu&quot;&gt;&lt;a href=&quot;#Gioi-thieu&quot; class=&quot;headerlink&quot; title=&quot;Giới thiệu&quot;&gt;&lt;/a&gt;Giới thiệu&lt;/h3&gt;&lt;p&gt;Đây KHÔNG phải là một bài viết để học “mọi thứ” về css grid.&lt;br&gt;Bài viết này hướng đến những người muốn có kết quả nhanh chóng và hiệu quả.&lt;br&gt;Trong bốn phần của bài viết này, tôi sẽ chỉ cho bạn 20% cần thiết để làm được 80% những gì bạn có thể làm với CSS Grid layout.&lt;/p&gt;
&lt;p&gt;Hãy cùng tìm hiểu!&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://nthung2112.github.io/tags/css/"/>
    
      <category term="grid" scheme="http://nthung2112.github.io/tags/grid/"/>
    
  </entry>
  
  <entry>
    <title>Tìm hiểu về Proxy trong ES6</title>
    <link href="http://nthung2112.github.io/2018/07/Tim-hieu-ve-Proxy-trong-ES6.html"/>
    <id>http://nthung2112.github.io/2018/07/Tim-hieu-ve-Proxy-trong-ES6.html</id>
    <published>2018-07-08T08:57:00.000Z</published>
    <updated>2018-07-08T08:59:57.977Z</updated>
    
    <content type="html"><![CDATA[<p>Nói về ES6 có lẽ chúng ta đã quá quen thuộc với các khái niệm như const và let, hàm mũi tên, class hay <a href="https://ehkoo.com/bai-viet/tong-hop-tinh-nang-noi-bat-es6" target="_blank" rel="noopener">những tính năng hay ho hấp dẫn khác</a>. Ngoài ra, ES6 cũng kèm theo những tính năng ít người biết hơn nhưng cũng rất thú vị, và một trong số đó là Proxy.<br><a id="more"></a></p><h3 id="Proxy-la-gi"><a href="#Proxy-la-gi" class="headerlink" title="Proxy là gì?"></a>Proxy là gì?</h3><p>Proxy là một class được giới thiệu từ ES6, cho phép bạn can thiệp và thay đổi hành vi của một đối tượng (object). Các hành vi này bao gồm: truy xuất/thiết lập thuộc tính của một đối tượng, thay đổi prototype, gọi hàm, khởi tạo đối tượng bằng từ khóa new… Để hiểu rõ hơn về khái niệm, bạn có thể xem qua ví dụ sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> u = &#123; <span class="attr">name</span>: <span class="string">'Công Tằng Tôn Nữ Tạ Thị Tòn Ten'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thiết lập proxy cho đối tượng `u`</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(u, &#123;</span><br><span class="line">  <span class="comment">// `get` là một trap, sẽ được gọi khi truy xuất đến thuộc tính</span></span><br><span class="line">  <span class="comment">// của đối tượng</span></span><br><span class="line">  get(target, prop, receiver) &#123;</span><br><span class="line">    <span class="comment">// Thay đổi hành vi khi truy xuất đến một thuộc tính: Nếu là</span></span><br><span class="line">    <span class="comment">// chuỗi, chuyển sang chữ hoa</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target[prop] === <span class="string">'string'</span>) <span class="keyword">return</span> target[prop].toUpperCase()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target[prop]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// CÔNG TẰNG TÔN NỮ TẠ THỊ TÒN TEN</span></span><br><span class="line">p.email = <span class="string">'ta.thi@ton.ten'</span></span><br><span class="line"><span class="built_in">console</span>.log(p.email) <span class="comment">// TA.THI@TON.TEN</span></span><br></pre></td></tr></table></figure><p>Chúng ta có thể áp dụng Proxy cho bất cứ object nào trong JavaScript, kể cả mảng, hàm hay một proxy khác.</p><blockquote><p><strong>Có thể bạn thừa biết</strong><br>Một hàm trong JavaScript là một thể hiện của lớp Function.</p></blockquote><p>Hiện tại Proxy đã được hỗ trợ bởi các trình duyệt xịn (nghĩa là không có IE đó) và node.js v6 trở đi.</p><blockquote><p><strong>Tin vắn</strong><br>Phiên bản 5.0 của <a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">MobX</a> đã hoàn toàn sử dụng ES6 Proxy.</p></blockquote><h3 id="Su-dung-nhu-the-nao"><a href="#Su-dung-nhu-the-nao" class="headerlink" title="Sử dụng như thế nào?"></a>Sử dụng như thế nào?</h3><p>Trước hết, hãy xem qua những thuật ngữ thông dụng khi làm việc với Proxy:</p><ul><li><strong>target</strong>: là đối tượng sẽ được áp dụng proxy vào</li><li><strong>traps</strong>: là những phương thức giúp bạn thay đổi hành vi của đối tượng</li><li><strong>handler</strong>: là một object chứa các traps, được đưa vào hàm dựng của lớp Proxy</li></ul><p>Để khởi tạo proxy, bạn dùng new Proxy(target, handler) như bên dưới:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><p>Chúng ta sẽ cùng đi qua những traps thông dụng.</p><h4 id="handler-get-va-handler-set"><a href="#handler-get-va-handler-set" class="headerlink" title="handler.get() và handler.set()"></a>handler.get() và handler.set()</h4><p>Như tên gọi, handler.get() và handler.set() cho phép bạn can thiệp khi truy xuất và thiết lập giá trị một thuộc tính của đối tượng.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// property: tên của thuộc tính được truy xuất</span></span><br><span class="line"><span class="comment">// receiver: đối tượng sau khi đã được gắn proxy</span></span><br><span class="line">handler.get(target, property, receiver)</span><br><span class="line"></span><br><span class="line"><span class="comment">// value: giá trị sẽ được thiết lập cho thuộc tính</span></span><br><span class="line"><span class="comment">// handler.set() phải trả về một giá trị boolean. Nếu là true thì xem như thiết lập</span></span><br><span class="line"><span class="comment">// thành công, ngược lại nếu là false thì xảy ra lỗi TypeError.</span></span><br><span class="line">handler.set(target, property, value, receiver)</span><br></pre></td></tr></table></figure><p>Chúng ta có thể dùng handler.set() để kiểm tra tính đúng đắn dữ liệu (data validation) trên thuộc tính của đối tượng. Chẳng hạn như:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> u = &#123; <span class="attr">age</span>: <span class="literal">null</span> &#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(u, &#123;</span><br><span class="line">  set(target, prop, val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'age'</span> &amp;&amp; <span class="keyword">typeof</span> val !== <span class="string">'number'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Age must be a number'</span>)</span><br><span class="line"></span><br><span class="line">    target[prop] = val</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.age = <span class="string">'10'</span> <span class="comment">// Error: Age must be a number</span></span><br><span class="line">p.age = <span class="number">10</span>   <span class="comment">// OK!</span></span><br></pre></td></tr></table></figure><h4 id="handler-defineProperty-va-handler-deleteProperty"><a href="#handler-defineProperty-va-handler-deleteProperty" class="headerlink" title="handler.defineProperty() và handler.deleteProperty()"></a>handler.defineProperty() và handler.deleteProperty()</h4><p>handle.defineProperty(target, property, descriptor) là trap được kích hoạt khi sử dụng Object.defineProperty(). Phương thức này đòi hỏi phải trả về một giá trị boolean. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;, &#123;</span><br><span class="line">  defineProperty(target, property, descriptor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property.startsWith(<span class="string">'_'</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Properties starting with _ are not allowed'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperty(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p._hello = <span class="number">1</span> <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(p, <span class="string">'_hello'</span>, &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;) <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">p.hello = <span class="number">1</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(p, <span class="string">'hello'</span>, &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>descriptor là một object quy định hành vi của thuộc tính được khai báo. Chi tiết về descriptor bạn có thể xem ở trang <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">MDN</a> hoặc hóng bài viết tiếp theo của Ehkoo.</p></blockquote><p>handle.deleteProperty(target, property) sẽ được kích hoạt khi thực hiện delete một thuộc tính. Phương thức này phải trả về true nếu quá trình xóa được chấp nhận. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;, &#123;</span><br><span class="line">  deleteProperty(target, property) &#123;</span><br><span class="line">    <span class="keyword">delete</span> target[property]</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;property&#125;</span> was removed`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p.foo <span class="comment">// foo was removed</span></span><br><span class="line"><span class="keyword">delete</span> p.bar <span class="comment">// bar was removed</span></span><br></pre></td></tr></table></figure><h4 id="handler-has"><a href="#handler-has" class="headerlink" title="handler.has()"></a>handler.has()</h4><p>handler.has() sẽ được kích hoạt khi sử dụng in. Phương thức này cũng đòi hỏi phải trả về một giá trị boolean. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; <span class="attr">_foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;, &#123;</span><br><span class="line">  has(target, property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property.startsWith(<span class="string">'_'</span>)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> property <span class="keyword">in</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'bar'</span> <span class="keyword">in</span> p) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'_foo'</span> <span class="keyword">in</span> p) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="handler-apply"><a href="#handler-apply" class="headerlink" title="handler.apply()"></a>handler.apply()</h4><p>handler.apply(target, thisArg, args) là trap dành cho các hàm, sẽ được khởi động khi hàm được gọi. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, &#123;</span><br><span class="line">  apply(target, thisArg, args) &#123;</span><br><span class="line">    <span class="keyword">const</span> [a, b] = args</span><br><span class="line">    <span class="keyword">return</span> target.call(thisArg, a * <span class="number">2</span>, b * <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h4 id="handler-construct"><a href="#handler-construct" class="headerlink" title="handler.construct()"></a>handler.construct()</h4><p>handler.construct(target, args) là trap sẽ được gọi khi khởi tạo đối tượng bằng new. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(username) &#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PUser = <span class="keyword">new</span> <span class="built_in">Proxy</span>(User, &#123;</span><br><span class="line">  construct(target, args) &#123;</span><br><span class="line">    <span class="keyword">const</span> [username] = args</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> target(username.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> u = <span class="keyword">new</span> PUser(<span class="string">'pikalong'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(u.username) <span class="comment">// PIKALONG</span></span><br></pre></td></tr></table></figure><h4 id="handler-getPrototypeOf-va-handler-setPrototypeOf"><a href="#handler-getPrototypeOf-va-handler-setPrototypeOf" class="headerlink" title="handler.getPrototypeOf() và handler.setPrototypeOf()"></a>handler.getPrototypeOf() và handler.setPrototypeOf()</h4><p>Như tên gọi, hai traps này sẽ được kích hoạt khi sử dụng Object.getPrototypeOf() và Object.setPrototypeOf() trên đối tượng.</p><blockquote><p><strong>Ghi chú</strong><br>Bên cạnh những traps được giới thiệu ở đây, còn có một số traps khác mà bạn có thể tham khảo ở trang <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">MDN</a>.</p></blockquote><h3 id="Viet-thu-nao"><a href="#Viet-thu-nao" class="headerlink" title="Viết thử nào"></a>Viết thử nào</h3><p>Bạn có dùng thử <a href="http://www.chaijs.com/" target="_blank" rel="noopener">chai</a> chưa? Thư viện này hỗ trợ viết kiểm chứng (assertion) theo phong cách BDD/TDD, giống như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chai.expect</span></span><br><span class="line">expect(foo).to.be.a(<span class="string">'string'</span>)</span><br><span class="line">expect(foo).to.equal(<span class="string">'bar'</span>)</span><br><span class="line">expect(foo).to.have.lengthOf(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hoặc chai.should</span></span><br><span class="line">foo.should.be.a(<span class="string">'string'</span>)</span><br><span class="line">foo.should.equal(<span class="string">'bar'</span>)</span><br><span class="line">foo.should.have.lengthOf(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>Cách thiết kế này rõ ràng giúp cho chương trình trở nên mạch lạc và dễ theo dõi vì câu kiểm chứng được viết như một câu tiếng Anh vậy. Chúng ta có thể bắt chước chai và thử viết một lớp Thing có những khả năng sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Khởi tạo một đối tượng của lớp Thing với tên là "Phương"</span></span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Thing(<span class="string">'Phương'</span>)</span><br><span class="line">t.name <span class="comment">// 'Phương'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Khai báo các thuộc tính boolean</span></span><br><span class="line">t.is_a.singer</span><br><span class="line">t.is_not_a.man</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kiểm tra thuộc tính</span></span><br><span class="line">t.is_a_singer <span class="comment">// true</span></span><br><span class="line">t.is_a_man <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Khai báo phương thức</span></span><br><span class="line">t.can.sing(<span class="string">'Yêu hay không yêu không yêu hay yêu nói một lời'</span>)</span><br><span class="line">t.sing() <span class="comment">// Phương sings: Yêu hay không yêu không yêu hay yêu nói một lời</span></span><br></pre></td></tr></table></figure><blockquote><p>Đây là một phần trong bài <a href="https://www.codewars.com/kata/5571d9fc11526780a000011a" target="_blank" rel="noopener">The builder of things</a> được lấy từ Codewars. Sau khi đọc hết bài viết này thì bạn hãy thử giải thử thách trên xem sao, bảo đảm kết quả không làm bạn thất vọng đâu.<br>Ngoài ra nếu bạn có tham gia Codewars thì đừng quên gia nhập clan Ehkoo nhé ;)</p></blockquote><p>Đầu tiên, để truy xuất thuộc tính name, chúng ta có thể nghĩ đến giải pháp “vô cùng rõ ràng và ngây thơ” sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đoạn code trên hoàn toàn hợp lý, nhưng sẽ không giúp chúng ta giải quyết những yêu cầu tiếp theo của bài toán. Phân tích kỹ một chút ta có thể thấy việc dùng Proxy là không thể tránh khỏi. Do đó để cài đặt t.name bằng Proxy, ta có thể viết lại thành:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; name &#125;</span><br><span class="line">    <span class="keyword">return</span> proxify(<span class="keyword">this</span>, <span class="keyword">this</span>.state)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hàm proxify() nhận vào một target và một object chứa state.</span></span><br><span class="line"><span class="comment">// State này sẽ được sử dụng để giải quyết những yêu cầu tiếp theo.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxify</span>(<span class="params">target, state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    get(target, prop, receiver) &#123;</span><br><span class="line">      <span class="comment">// Nếu truy xuất đến thuộc tính `name`, lấy ra dữ liệu trong state</span></span><br><span class="line">      <span class="keyword">if</span> (prop === <span class="string">'name'</span>) <span class="keyword">return</span> state[prop]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Còn lại thì sử dụng hành vi mặc định</span></span><br><span class="line">      <span class="keyword">return</span> target[prop]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Thing(<span class="string">'Phương'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(t.name) <span class="comment">// Phương</span></span><br><span class="line"><span class="built_in">console</span>.log(t.age)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>Vậy là tạm ổn phần lấy name. Chúng ta xem tiếp đến hành vi tiếp theo của lớp Thing.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t.is_a.singer</span><br><span class="line">t.is_not_a.man</span><br><span class="line"></span><br><span class="line">t.is_a_singer <span class="comment">// true</span></span><br><span class="line">t.is_a_man <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Hành vi này cho phép khai báo thuộc tính boolean trên đối tượng bằng cách sử dụng is_a cho giá trị true và is_not_a cho giá trị false. Sau đó ta có thể kiểm tra thuộc tính bằng cách truy xuất đến is_a_${prop}. Để cài đặt hành vi này, chúng ta có thể làm như sau:</p><ol><li>Khai báo thêm một khóa booleans: {} cho state. Khóa này đóng vai trò như một bảng tham chiếu giữa tên thuộc tính boolean và giá trị của nó, chẳng hạn như { singer: true, man: false }. Ngoài ra chúng ta cũng cần thêm vào state một cờ inBooleanMode: false.</li><li>Nếu prop là is_a hoặc is_not_a, bật cờ inBooleanMode: true</li><li>Nếu cờ inBooleanMode đang bật, thuộc tính tiếp theo sẽ là thuộc tính boolean. Do đó ta cập nhật booleans của state thành { …booleans, [prop]: state.booleanValue }</li></ol><p><img src="https://res.cloudinary.com/duqeezi8j/image/upload/v1530343401/ehkoo/proxy_iah0182.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enterBooleanMode</span>(<span class="params">receiver, state, booleanValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Bật cờ</span></span><br><span class="line">  state.inBooleanMode = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// Lưu lại giá trị boolean tùy thuộc vào là `is_a` hay `is_not_a`</span></span><br><span class="line">  state.booleanValue = booleanValue</span><br><span class="line">  <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setBoolean</span>(<span class="params">receiver, state, prop</span>) </span>&#123;</span><br><span class="line">  state.booleans = &#123;...state.booleans, [prop]: state.booleanValue &#125;</span><br><span class="line">  <span class="comment">// Reset lại các giá trị</span></span><br><span class="line">  state.inBooleanMode = <span class="literal">false</span></span><br><span class="line">  state.booleanValue = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get(target, prop, receiver) &#123;</span><br><span class="line">  <span class="comment">// Đặt ở đây để tránh trường hợp gọi t.is_a.is_a</span></span><br><span class="line">  <span class="keyword">if</span> (state.inBooleanMode) <span class="keyword">return</span> setBoolean(<span class="keyword">this</span>, state, prop)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prop === <span class="string">'name'</span>) <span class="keyword">return</span> state[prop]</span><br><span class="line">  <span class="keyword">if</span> (prop === <span class="string">'is_a'</span>) <span class="keyword">return</span> enterBooleanMode(receiver, state, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">if</span> (prop === <span class="string">'is_not_a'</span>) <span class="keyword">return</span> enterBooleanMode(receiver, state, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">if</span> (prop.startsWith(<span class="string">'is_a_'</span>)) <span class="keyword">return</span> state.booleans[prop.replace(<span class="string">'is_a_'</span>, <span class="string">''</span>)]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target[prop]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kiểm tra thử.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Thing(<span class="string">'Phương'</span>)</span><br><span class="line"></span><br><span class="line">t.is_a.singer</span><br><span class="line">t.is_not_a.man</span><br><span class="line"><span class="built_in">console</span>.log(t.is_a_singer) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(t.is_a_man)    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Để cài đặt hành vi tiếp theo, chúng ta cũng có thể làm tương tự như khai báo thuộc tính boolean bằng cách đặt thêm một cờ inDefineMethodMode và bật/tắt cờ này tương ứng. Bên cạnh đó chúng ta cũng đặt thêm một khóa methods trong state để chứa các phương thức được khai báo thông qua can.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">get(target, prop, receiver) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (state.inDefineMethodMode) <span class="keyword">return</span> setMethod(receiver, state, prop)</span><br><span class="line">  <span class="keyword">if</span> (prop === <span class="string">'can'</span>) <span class="keyword">return</span> enterDefineMethodMode(receiver, state)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lấy ra phương thức được khai báo bởi `t.can`</span></span><br><span class="line">  <span class="keyword">if</span> (state.methods[prop]) <span class="keyword">return</span> state.methods[prop]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ở đây có một chút khó khăn. Có thể thấy trong t.can.sing(phrase), sing phải là một hàm. Do đó giá trị trả về của setMethod() có thể được viết như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setMethod</span>(<span class="params">receiver, state, prop</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Đừng quên tắt cờ sau khi cài đặt method</span></span><br><span class="line">  state.inDefineMethodMode = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">phrase</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Tạo ra hàm mới</span></span><br><span class="line">    <span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;state.name&#125;</span> <span class="subst">$&#123;prop&#125;</span>: <span class="subst">$&#123;phrase&#125;</span>`</span></span><br><span class="line">    <span class="comment">// Lưu vào danh sách các phương thức được khai báo bởi `t.can`</span></span><br><span class="line">    state.methods = &#123; ...state.methods, [prop]: f &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.can.sing(<span class="string">'Yêu hay không yêu không yêu hay yêu nói một lời'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(t.sing()) <span class="comment">// Phương sing: Yêu hay không yêu không yêu hay yêu nói một lời</span></span><br></pre></td></tr></table></figure><p>Vậy là được rồi. Chúng ta chỉ còn một bước nữa là chia “sing” sang ngôi thứ ba số ít “sings”, nhưng thôi cái này để bạn tự làm nhé. Bạn có thể xem đầy đủ mã nguồn <a href="https://repl.it/repls/MiniCornyEditors" target="_blank" rel="noopener">ở đây</a>.</p><h3 id="Ket"><a href="#Ket" class="headerlink" title="Kết"></a>Kết</h3><p>Proxy là một công cụ mạnh mẽ, giúp cho việc lập trình meta trong JavaScript trở nên dễ dàng hơn. Hi vọng bài viết này đã giúp bạn hiểu rõ hơn về Proxy và có thể ứng dụng nó trong công việc.</p><h4 id="Tham-khao"><a href="#Tham-khao" class="headerlink" title="Tham khảo"></a>Tham khảo</h4><p><em>Proxy - MDN</em> - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p><p><em>ES6 Proxies in Depth</em> - <a href="https://ponyfoo.com/articles/es6-proxies-in-depth" target="_blank" rel="noopener">https://ponyfoo.com/articles/es6-proxies-in-depth</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nói về ES6 có lẽ chúng ta đã quá quen thuộc với các khái niệm như const và let, hàm mũi tên, class hay &lt;a href=&quot;https://ehkoo.com/bai-viet/tong-hop-tinh-nang-noi-bat-es6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;những tính năng hay ho hấp dẫn khác&lt;/a&gt;. Ngoài ra, ES6 cũng kèm theo những tính năng ít người biết hơn nhưng cũng rất thú vị, và một trong số đó là Proxy.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Tìm hiểu Map và Set trong Javascript</title>
    <link href="http://nthung2112.github.io/2018/07/Tim-Hieu-Map-Va-Set-Trong-Javascript.html"/>
    <id>http://nthung2112.github.io/2018/07/Tim-Hieu-Map-Va-Set-Trong-Javascript.html</id>
    <published>2018-07-08T08:12:00.000Z</published>
    <updated>2018-07-08T08:57:25.234Z</updated>
    
    <content type="html"><![CDATA[<p>Được giới thiệu từ ES6, Map, Set, WeakMap, và WeakSet là những cấu trúc dữ liệu giúp thao tác trên tập hợp. Bài viết này sẽ giới thiệu cách hoạt động cũng như các ứng dụng của chúng.<br><a id="more"></a></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><em>Map</em>, <em>mảng kết hợp</em> (associate arrays) hay <em>từ điển</em> (dictionary/dict) là những thuật ngữ dùng để chỉ một cấu trúc dữ liệu, cho phép bạn ánh xạ từ một <em>khóa</em> (key) tương ứng với một <em>giá trị</em> (value). Trong JavaScript, chúng ta có thể sử dụng <em>object</em> để thể hiện cấu trúc này.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dict = &#123;</span><br><span class="line">  hello: <span class="string">'Xin chào'</span>,</span><br><span class="line">  bye: <span class="string">'Tạm biệt'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dict[<span class="string">'hello'</span>]) <span class="comment">// Xin chào</span></span><br></pre></td></tr></table></figure><p>Tuy nhiên, nếu dùng <em>object</em> thì bạn chỉ có thể dùng <em>chuỗi</em> làm <em>khóa</em>. Ngoài ra, cách này cũng có một số <a href="http://speakingjs.com/es5/ch17.html#_pitfalls_using_an_object_as_a_map" target="_blank" rel="noopener">hạn chế khác</a>. Lớp Map do ES6 giới thiệu sẽ giúp giải quyết những vấn đề này. Với Map, bạn có thể sử dụng bất cứ dạng dữ liệu nào để làm <em>khóa</em>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">dict</span><br><span class="line"> .set(<span class="string">'foo'</span>, <span class="number">123</span>)</span><br><span class="line"> .set(obj, <span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line">dict.get(<span class="string">'foo'</span>) <span class="comment">// 123</span></span><br><span class="line">dict.get(obj)   <span class="comment">// 'hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lấy giá trị của một khóa không tồn tại</span></span><br><span class="line">dict.get(<span class="string">'wat'</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>Bạn cũng có thể truyền vào hàm dựng của Map một mảng các cặp giá trị dạng [key, value], ví dụ như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="number">123</span>],</span><br><span class="line">  [obj, <span class="string">'hello world'</span>]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>Như đã nói ở trên, bạn có thể dùng bất cứ dạng dữ liệu gì để làm <em>khóa</em> cho Map, kể cả mảng, object, hàm, hay NaN.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">dict</span><br><span class="line"> .set(arr, <span class="string">'an array'</span>)</span><br><span class="line"> .set(f, <span class="string">'a function'</span>)</span><br><span class="line"> .set(<span class="literal">NaN</span>, <span class="string">'not a number'</span>)</span><br></pre></td></tr></table></figure><p>Bản thân Map sử dụng phương thức so sánh <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#A_model_for_understanding_equality_comparisons" target="_blank" rel="noopener">SameValueZero</a> để tìm <em>khóa</em> và giá trị tương ứng. SameValueZero hoạt động tương tự như ===, nhưng xem các giá trị NaN bằng nhau, cũng như +0 bằng -0.</p><blockquote><p><strong>Đố-hẻm-vui</strong>: Đố bạn kết quả của các biểu thức sau là gì?</p><p>NaN == NaN<br>NaN === NaN<br>Object.is(NaN, NaN)</p></blockquote><p>Do SameValueZero nên hai <em>object</em> khác nhau sẽ là hai <em>khóa</em> riêng biệt.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">dict.set(o1, <span class="string">'Ô Một'</span>).set(o2, <span class="string">'Ô Hai'</span>)</span><br><span class="line">dict.get(o2) <span class="comment">// Ô Hai</span></span><br><span class="line">dict.get(&#123;&#125;) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>Nếu trong map đã có sẵn <em>khóa</em>, dữ liệu mới sẽ bị ghi đè lên.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(<span class="string">'foo'</span>, <span class="number">1</span>)</span><br><span class="line">m.set(<span class="string">'foo'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">m.get(<span class="string">'foo'</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>Để duyệt qua các <em>khóa</em> và giá trị trong Map, bạn có thể dùng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="number">1</span>], [<span class="string">'bar'</span>, <span class="number">2</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">dict.keys()    <span class="comment">// ['foo', 'bar']</span></span><br><span class="line">dict.values()  <span class="comment">// [1, 2]</span></span><br><span class="line">dict.entries() <span class="comment">// [ ['foo', 1], ['bar', 2] ]</span></span><br><span class="line">dict.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> has <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;, <span class="comment">/* thisArgs bạn có thể truyền vào tham chiếu cho `this` ở đây */</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sử dụng for..of cùng với destructuring</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> dict) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> has <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bạn cũng có thể dùng toán tử spread … với Map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="number">1</span>], [<span class="string">'bar'</span>, <span class="number">2</span>]</span><br><span class="line">])</span><br><span class="line"><span class="built_in">console</span>.log([</span><br><span class="line">  [<span class="string">'wut'</span>, <span class="number">3</span>],</span><br><span class="line">  ...dict</span><br><span class="line">])</span><br><span class="line"><span class="comment">// [ [ 'wut', 3 ], [ 'foo', 1 ], [ 'bar', 2 ] ]</span></span><br></pre></td></tr></table></figure><p>Một số thao tác khác với Map.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="number">1</span>], [<span class="string">'bar'</span>, <span class="number">2</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Đếm số cặp giá trị trong map</span></span><br><span class="line">dict.size <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kiểm tra trong map có khóa "foo" hay không</span></span><br><span class="line">dict.has(<span class="string">'foo'</span>) <span class="comment">// true</span></span><br><span class="line">dict.has(<span class="string">'wut'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Xóa một khóa, trả về boolean nếu thành công, false nếu thất bại</span></span><br><span class="line">dict.delete(<span class="string">'wut'</span>) <span class="comment">// false</span></span><br><span class="line">dict.delete(<span class="string">'foo'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Xóa hết các cặp giá trị của map</span></span><br><span class="line">dict.clear()</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tại sao lại là size mà không phải length?</strong><br>Một số độc giả tinh ý sẽ nhận ra chúng ta dùng size thay vì length để đếm số cặp giá trị trong map. Lý do là vì: length dùng cho những chuỗi có thể index (đánh số) được, ví dụ với <em>mảng</em> ta có thể arr[3]. Ngược lại, size dành cho những cấu trúc không có thứ tự như Map và Set.</p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set là tập hợp các giá trị không bị trùng lặp, nghĩa là trong một <em>set</em> không thể có hai giá trị bằng nhau.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">set</span><br><span class="line">  .add(<span class="string">'red'</span>)</span><br><span class="line">  .add(<span class="string">'blue'</span>)</span><br><span class="line">  .add(<span class="string">'sweet'</span>)</span><br><span class="line">  .add(<span class="string">'you'</span>)</span><br><span class="line"></span><br><span class="line">s.size <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>Bạn cũng có thể truyền một <em>mảng</em> vào hàm dựng của Set.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'sweet'</span>, <span class="string">'red'</span>, <span class="string">'you'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(s) <span class="comment">// Set (4) &#123;'red', 'blue', 'sweet', 'you'&#125;</span></span><br></pre></td></tr></table></figure><p>Bạn cũng có thể thấy giá trị ‘red’ bị trùng lặp đã được loại bỏ. Chúng ta có thể áp dụng Set để tạo ra một <em>mảng</em> chứa những phần tử duy nhất.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'sweet'</span>, <span class="string">'red'</span>, <span class="string">'you'</span>]</span><br><span class="line"><span class="keyword">const</span> b = [...new <span class="built_in">Set</span>(a)]</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [ 'red', 'blue', 'sweet', 'you' ]</span></span><br></pre></td></tr></table></figure><p>Cũng tương tự như Map, Set sử dụng SameZeroValue để so sánh các phần tử với nhau.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="literal">NaN</span>, &#123;&#125;, obj])</span><br><span class="line">s.has(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">s.has(obj) <span class="comment">// true</span></span><br><span class="line">s.has(&#123;&#125;)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Để duyệt qua các phần tử của Set, bạn có thể dùng các phương thức như với Map.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vì Set không có khái niệm keys nên kết quả của `s.keys()` và `s.values()` là như nhau.</span></span><br><span class="line">s.keys()</span><br><span class="line">s.values()</span><br><span class="line"></span><br><span class="line">s.entries()</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, setReference</span>) </span>&#123;</span><br><span class="line">&#125;, thisArg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Một số thao tác khác trên Set.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Xóa một phần tử trong set</span></span><br><span class="line">s.delete(<span class="number">3</span>) <span class="comment">// Set (4) &#123;1, 2, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Xóa hết phần tử trong set</span></span><br><span class="line">s.clear()</span><br></pre></td></tr></table></figure><h3 id="WeakMap-va-WeakSet"><a href="#WeakMap-va-WeakSet" class="headerlink" title="WeakMap và WeakSet"></a>WeakMap và WeakSet</h3><p>ES6 cũng giới thiệu hai lớp WeakMap và WeakSet. So với Map, các <em>khóa</em> của WeakMap bắt buộc phải là <em>object</em>, và chúng sẽ bị giải phóng khỏi bộ nhớ (garbage-collecting – “hốt rác”) đầu tiên nếu không có tham chiếu nào.</p><p>WeakMap có các phương thức tương tự như Map, ngoại trừ việc bạn không thể duyệt qua WeakMap bằng .keys(), .values(), .entries() hay for..of. Bạn cũng không thể .clear(), vì lý do an toàn dữ liệu.</p><p>Một ứng dụng của WeakMap là dùng để chứa dữ liệu private mà không gây ra rò rỉ bộ nhớ.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privates = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123; <span class="attr">phoneNumber</span>: <span class="number">123</span> &#125;</span><br><span class="line">    privates.set(<span class="keyword">this</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPhoneNumber() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = privates.get(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> data.phoneNumber</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> u = <span class="keyword">new</span> User()</span><br><span class="line"><span class="built_in">console</span>.log(u) <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(u.getPhoneNumber()) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>Tương tự như WeakMap, WeakSet cũng chỉ có thể chứa <em>object</em>, và nếu một phần tử trong WeakSet không có tham chiếu tới, nó sẽ bị giải phóng khỏi bộ nhớ.</p><h3 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h3><p>Với những cải tiến so với <em>object</em> thông thường, Map sẽ là công cụ hữu hiệu để lưu trữ dữ liệu dạng (khóa, giá trị). Trong khi đó, Set giúp bạn lưu trữ chuỗi dữ liệu mà không lo lắng về việc trùng lắp giá trị.</p><h4 id="Tham-khao"><a href="#Tham-khao" class="headerlink" title="Tham khảo"></a>Tham khảo</h4><p>[1] Axel Rauschmayer. ECMAScript 6: maps and sets. <a href="http://2ality.com/2015/01/es6-maps-sets.html" target="_blank" rel="noopener">http://2ality.com/2015/01/es6-maps-sets.html</a></p><p>[2] Keyed Collections - JavaScript | MDN. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections</a></p><p>[3] Steve Brownlee. WeakMap for JavaScript Private Data. <a href="https://www.stevebrownlee.com/weakmap-javascript-private-data/" target="_blank" rel="noopener">https://www.stevebrownlee.com/weakmap-javascript-private-data/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Được giới thiệu từ ES6, Map, Set, WeakMap, và WeakSet là những cấu trúc dữ liệu giúp thao tác trên tập hợp. Bài viết này sẽ giới thiệu cách hoạt động cũng như các ứng dụng của chúng.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Tổng hợp những tính năng ES6 nổi bật</title>
    <link href="http://nthung2112.github.io/2018/07/Tong-hop-nhung-tinh-nang-ES6-noi-bat.html"/>
    <id>http://nthung2112.github.io/2018/07/Tong-hop-nhung-tinh-nang-ES6-noi-bat.html</id>
    <published>2018-07-08T01:08:00.000Z</published>
    <updated>2018-07-08T09:09:59.591Z</updated>
    
    <content type="html"><![CDATA[<p>Việc hầu hết những tính năng hay ho hấp dẫn của ES6 đều đã được <a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">các trình duyệt hỗ trợ</a> quả là tin vui cho giới lập trình web. Nhờ nó mà nhà phát triển có thể xây dựng ứng dụng trực tiếp bằng ES6, không cần phải thông qua các công cụ chuyển đổi như <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a> hay <a href="https://buble.surge.sh/guide/" target="_blank" rel="noopener">Bublé</a> nữa, giúp ứng dụng trở nên gọn nhẹ hơn, giảm thiểu kích thước tập tin khi chuyển đến người sử dụng.</p><a id="more"></a><h3 id="Noi-dung"><a href="#Noi-dung" class="headerlink" title="Nội dung"></a>Nội dung</h3><ol><li>let và const</li><li>Hàm mũi tên (arrow functions)</li><li>Chuỗi bản mẫu (template strings)</li><li>Object chân phương (object literals)</li><li>Phân rã biến (destructuring)</li><li>Rest và Spread</li><li>Giá trị mặc định cho tham số</li><li>Lớp (class)</li><li>Promise</li></ol><h3 id="1-let-va-const"><a href="#1-let-va-const" class="headerlink" title="1. let và const"></a>1. let và const</h3><p>Ngày xa xưa ấy, bạn khai báo biến trong JavaScript bằng var, giống như ví dụ dưới đây.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFoo</span>(<span class="params">shouldDo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldDo) &#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(printFoo(<span class="literal">false</span>)) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(printFoo(<span class="literal">true</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>Biến được khai báo với var sẽ có tầm vực bên trong hàm gần nhất (function scope), và sẽ được đẩy lên đầu của tầm vực (hoisting). Đó là lý do tại sao foo lại có giá trị undefined trong dòng console.log đầu tiên.</p><p>ES6 giới thiệu let và const như hai cách khai báo biến mới, hỗ trợ tầm vực theo khối (block scope) và không thực hiện hoisting.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFoo</span>(<span class="params">shouldDo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldDo) &#123;</span><br><span class="line">    <span class="keyword">let</span> foo = <span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Value of foo in scope'</span>, foo) <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo is out of block scope'</span>, foo) <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(printFoo(<span class="literal">false</span>)) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(printFoo(<span class="literal">true</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>Điểm khác biệt giữa let và const là với const, bạn không thể gán giá trị mới cho biến sau khi khai báo, trong khi điều này lại có thể với let.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">2</span></span><br><span class="line">foo = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="number">2</span></span><br><span class="line">baz = <span class="number">3</span> <span class="comment">// Error: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>const mang ý nghĩa “constant” chứ không phải “immutability”. Nghĩa là với các biến là object hay array, bạn vẫn có thể thay đổi giá trị bên trong của chúng.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">2</span> &#125;</span><br><span class="line">obj.foo = <span class="number">5</span></span><br><span class="line">obj.bar = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; foo: 5, bar: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>]</span><br><span class="line">arr.push(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tuy vậy bạn không thể gán một đối tượng khác cho obj/arr</span></span><br><span class="line">obj = &#123; <span class="attr">baz</span>: <span class="number">4</span> &#125; <span class="comment">// Error: Assignment to constant variable.</span></span><br><span class="line">arr = [] <span class="comment">// Error: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> <a href="http://caniuse.com/#feat=let,const" target="_blank" rel="noopener">Được hỗ trợ</a> trên tất cả trình duyệt, kể cả IE11.<br><strong>Lời khuyên:</strong> Dùng const cho tất cả khai báo biến vì nó sẽ giúp bạn hạn chế trường hợp “vô tình” thay đổi giá trị của biến. Chỉ dùng let trong trường hợp bất khả kháng, và tránh xa var.</p></blockquote><h3 id="2-Ham-mui-ten"><a href="#2-Ham-mui-ten" class="headerlink" title="2. Hàm mũi tên"></a>2. Hàm mũi tên</h3><p>Hàm mũi tên – (fat) arrow functions – là một kiểu cú pháp rút gọn cho khai báo hàm trong JavaScript. Trước ES6, bạn khai báo một hàm trong JavaScript với từ khóa function.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hàm add() ở trên là syntactic sugar cho...</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“Syntactic sugar” là cú pháp làm cho ngôn ngữ trở nên dễ đọc và dễ hiểu hơn, theo kiểu nó làm cho ngôn ngữ “ngọt ngào hơn” (sweeter) với lập trình viên.</p></blockquote><p>Với hàm mũi tên trong ES6, bạn có thể viết lại thành:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bạn cũng có thể viết dưới dạng biểu thức (expression), hàm mũi</span></span><br><span class="line"><span class="comment">// tên sẽ tự động trả giá trị về (auto-return).</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br></pre></td></tr></table></figure><p>Hàm mũi tên cũng hữu dụng để giải quyết vấn đề muôn thuở trong JavaScript: “which this is this?” – khái niệm con trỏ this. Với ES5, bạn hay gặp trường hợp giống như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.count++)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> App()</span><br></pre></td></tr></table></figure><p>Trước ES6, mỗi khai báo hàm đều có một giá trị this tách biệt. Điều này làm cho đoạn code ở trên không hoạt động, vì this.count bên trong hàm của setInterval mang giá trị undefined. Cách giải quyết thông thường là đặt một biến self, that hay _this để giữ reference, hoặc sử dụng Function.prototype.bind.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(self.count++)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hoặc</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.count++)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setInterval(counter.bind(<span class="keyword">this</span>), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Với hàm mũi tên trong ES6, giá trị của this chính là this trong tầm vực gần nhất với nó (lexical this). Do đó chúng ta không cần phải khai báo biến tạm hay dùng .bind nữa.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.count++), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hàm mũi tên cũng rất hữu ích khi thao tác trên mảng và tiến hành chuyển đổi dữ liệu, giúp mã nguồn dễ đọc và rõ ràng hơn.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subtotal = products.filter(<span class="function"><span class="params">product</span> =&gt;</span> product.price &gt; <span class="number">500</span>).reduce(<span class="function">(<span class="params">acc, product</span>) =&gt;</span> acc + product.price, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ.<br><strong>Lời khuyên:</strong> Nếu có dùng đến this thì hàm mũi tên rất hữu dụng. Trường hợp không dùng thì…cũng hữu dụng luôn vì mã nguồn gọn gàng dễ đọc hơn. Với những trường hợp bạn muốn bao đóng giá trị của this chỉ gói gọn trong hàm của nó, dùng function.</p></blockquote><h3 id="3-Chuoi-ban-mau"><a href="#3-Chuoi-ban-mau" class="headerlink" title="3. Chuỗi bản mẫu"></a>3. Chuỗi bản mẫu</h3><p>Chuỗi bản mẫu (template strings) là chuỗi chân phương (string literals) nhưng cho phép đính kèm biểu thức. Nó cũng cho phép khai báo chuỗi trên nhiều dòng. Để sử dụng, bạn dùng ký tự backtick ` (dấu huyền). Ví dụ như là:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'John'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greetings = <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>,</span></span><br><span class="line"><span class="string">The result of 1 + 1 is <span class="subst">$&#123;<span class="number">1</span> + <span class="number">1</span>&#125;</span>, and the time is now <span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>.`</span></span><br></pre></td></tr></table></figure><p>Vì chuỗi bản mẫu cũng chỉ là chuỗi nên bạn có thể gọi đến những phương thức của String.prototype.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="string">`Hello World`</span>.substr(<span class="number">0</span>, <span class="number">5</span>).toUpperCase()</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ.<br><strong>Lời khuyên:</strong> Dùng chuỗi bản mẫu khi bạn cần gắn biểu thức hay chuỗi có nội dung ở nhiều dòng. Còn lại thì vẫn dùng chuỗi bình thường với ‘ hay “.</p></blockquote><h3 id="4-Object-chan-phuong-object-literals"><a href="#4-Object-chan-phuong-object-literals" class="headerlink" title="4. Object chân phương (object literals)"></a>4. Object chân phương (object literals)</h3><p>Object chân phương (object literals) chỉ đơn giản là khai báo một object trong JavaScript như bạn đã làm bao năm nay.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> birthYear = <span class="number">2000</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  birthYear: birthYear,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span>(<span class="params">currentYear</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentYear - obj.birthYear</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 nâng cấp object chân phương, cho phép bạn khai báo tắt thuộc tính của object với biến cùng tên, và khai báo phương thức cho object.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> birthYear = <span class="number">2000</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  birthYear, <span class="comment">// khai báo tắt birthYear: birthYear</span></span><br><span class="line">  getAge(currentYear) &#123;</span><br><span class="line">    <span class="comment">// `this` được gán trực tiếp vào bản thân object</span></span><br><span class="line">    <span class="keyword">return</span> currentYear - <span class="keyword">this</span>.birthYear</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Một lưu ý với this là khi bạn dùng hàm mũi tên, this sẽ được lấy từ this trong tầm vực gần với nó nhất, chứ không trỏ đến đối tượng hiện tại. Do đó…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  getAge: <span class="function"><span class="params">currentYear</span> =&gt;</span> currentYear - <span class="keyword">this</span>.birthYear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…sẽ không chạy như mong muốn, vì có thể this.birthYear mang giá trị undefined. Để sử dụng hàm mũi tên bạn phải viết lại như trước ES6.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  getAge: <span class="function"><span class="params">currentYear</span> =&gt;</span> currentYear - obj.birthYear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ngoài ra từ ES6 bạn cũng có thể khai báo thuộc tính cho object một cách linh động bằng cách sử dụng cú pháp [].</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> attr = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">const</span> year = <span class="number">2017</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; [attr]: <span class="number">1</span>, [<span class="string">'now'</span> + year]: <span class="string">'wow'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; foo: 1, now2017: 'wow' &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> Được hỗ trợ bởi tất cả trình duyệt<br><strong>Lời khuyên:</strong> Tính năng khai báo tắt thuộc tính của object cực ký hữu dụng =&gt; nên dùng. Nếu không bận tâm đến this thì bạn có thể dùng hàm mũi tên khi khai báo phương thức cho object để mã nguồn gọn gàng sạch đẹp hơn.</p></blockquote><h3 id="5-Phan-ra-bien"><a href="#5-Phan-ra-bien" class="headerlink" title="5. Phân rã biến"></a>5. Phân rã biến</h3><p>Phân rã biến – destructuring – theo mình là tính năng tiện dụng nhất của ES6. Tính năng này giúp bạn tách biến từ thuộc tính của đối tượng hay phần tử trong các đối tượng có thể duyệt với for, như mảng hoặc chuỗi. Chẳng hạn như:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = user</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// 'John'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> [first, second] = arr</span><br><span class="line"><span class="built_in">console</span>.log(first, second) <span class="comment">// 1, 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'Hello'</span></span><br><span class="line"><span class="keyword">const</span> [first, second] = str</span><br><span class="line"><span class="built_in">console</span>.log(first, second) <span class="comment">// 'H', 'e'</span></span><br></pre></td></tr></table></figure><p>Bạn cũng có thể phân rã các thuộc tính lồng nhau.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'John'</span>,</span><br><span class="line">    age: <span class="number">21</span>,</span><br><span class="line">    products: [&#123; <span class="attr">name</span>: <span class="string">'Creamy Crustacean Omelette'</span>, <span class="attr">price</span>: <span class="number">1200</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'Galdin Gratin'</span>, <span class="attr">price</span>: <span class="number">2300</span> &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [&#123; <span class="attr">products</span>: [&#123; price &#125;] &#125;] = userList</span><br><span class="line"><span class="built_in">console</span>.log(price) <span class="comment">// 1200</span></span><br></pre></td></tr></table></figure><p>Với mảng hay chuỗi, bạn có thể bỏ qua phần tử không mong muốn khi phân rã.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> [first, , third] = arr</span><br><span class="line"><span class="built_in">console</span>.log(first, third) <span class="comment">// 1, 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'Hello'</span></span><br><span class="line"><span class="keyword">const</span> [fst, , , , lst] = str</span><br><span class="line"><span class="built_in">console</span>.log(fst, lst) <span class="comment">// 'H', 'o'</span></span><br></pre></td></tr></table></figure><p>Phân rã biến cũng rất thường gặp khi bạn sử dụng ES6 module.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ.</p></blockquote><h3 id="6-Rest-va-spread"><a href="#6-Rest-va-spread" class="headerlink" title="6. Rest và spread"></a>6. Rest và spread</h3><p>Rest – phần còn lại – là một bổ sung của phân rã biến mảng ở trên. Bạn dùng ba dấu chấm … để biểu thị rest.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, second, ...others] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(first, second, others)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// [3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>Rest cũng được dùng khi khai báo hàm có thể nhận nhiều tham số</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'You passed'</span>, args)</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// You passed[ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="function">(<span class="params">x, y, ...rest</span>) =&gt;</span> <span class="built_in">console</span>.log(rest, x, y)</span><br></pre></td></tr></table></figure><p>Bạn lưu ý biến args ở trên khác với biến đặc biệt arguments vốn có sẵn bên trong hàm. arguments là một đối tượng giống Array, với những thuộc tính đặc biệt như callee, trong khi args chỉ là một mảng bình thường.</p><p>Spread – rải – là thao tác ngược lại với rest, giúp bạn kết hợp một mảng đã có sẵn thành mảng mới.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = [<span class="number">1</span>, <span class="number">2</span>, ...arr, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>Spread rất hữu ích để thay thế các thao tác thên mảng, như .concat().</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> head = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> tail = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log([...head, ...tail]) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>Spread cũng rất ngon khi thay thế cho Function.prototype.apply.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mul = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> x * y * z</span><br><span class="line"><span class="keyword">const</span> params = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thay thế cho</span></span><br><span class="line"><span class="comment">// mul.prototype.apply(null, params)</span></span><br><span class="line">mul(...params)</span><br></pre></td></tr></table></figure><p>Rest/spread cũng có thể hoạt động trên object, tương tự như Object.assign(), nhưng bạn lưu ý tính năng vẫn đang được <a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">đề xuất</a> (proposal). Về phía trình duyệt, có Firefox và Chrome là hỗ trợ, trong khi Edge và Safari hoàn toàn không hoạt động.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">'John'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">const</span> userWithAgeEs5 = <span class="built_in">Object</span>.assign(&#123;&#125;, user, &#123; <span class="attr">age</span>: <span class="number">21</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thời đại mới với spread</span></span><br><span class="line"><span class="keyword">const</span> userWithAge = &#123; ...user, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(userWithAge) <span class="comment">// &#123; name: 'John', age: 21 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Và rest</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, ...others &#125; = userWithAge</span><br><span class="line"><span class="built_in">console</span>.log(others) <span class="comment">// &#123; age: 21 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ rest và spread với mảng hay chuỗi. Với spread object, Edge và Safari chưa hỗ trợ.</p></blockquote><h3 id="7-Gia-tri-mac-dinh-cho-tham-so"><a href="#7-Gia-tri-mac-dinh-cho-tham-so" class="headerlink" title="7. Giá trị mặc định cho tham số"></a>7. Giá trị mặc định cho tham số</h3><p>Khi khai báo hàm, tính năng này cho phép bạn thiết lập giá trị mặc định của tham số khi nó không được truyền giá trị hoặc có giá trị undefined.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDiscountedPrice</span>(<span class="params">price, discountRate = <span class="number">0.1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * (<span class="number">1</span> + discountRate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dĩ nhiên bạn có thể dùng bất cứ giá trị nào làm giá trị mặc định.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processItems</span>(<span class="params">items = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.map(transformItemData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hoặc dùng biến</span></span><br><span class="line"><span class="keyword">const</span> DISCOUNT_RATE = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">const</span> getDiscountedPrice = <span class="function">(<span class="params">price, discountRate = DISCOUNT_RATE</span>) =&gt;</span> price * (<span class="number">1</span> + discountRate)</span><br></pre></td></tr></table></figure><h3 id="8-Lop-class"><a href="#8-Lop-class" class="headerlink" title="8. Lớp (class)"></a>8. Lớp (class)</h3><p>Với ES5, chúng ta sử dụng function để tạo lớp và thêm các phương thức vào lớp bằng cách mở rộng prototype.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(f.add(<span class="number">2</span>)) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>ES6 mang đến cú pháp mới giúp tạo lớp trực tiếp và dễ dàng hơn.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Khai báo phương thức tĩnh (static method)</span></span><br><span class="line">  <span class="keyword">static</span> whoAmI() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'I am a Foo class'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Foo(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(f.add(<span class="number">2</span>)) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo.whoAmI()) <span class="comment">// I am a Foo class</span></span><br></pre></td></tr></table></figure><p>Bạn cũng có thể kế thừa từ lớp khác bằng từ khóa extends.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="comment">// Gọi đến hàm dựng của lớp cha</span></span><br><span class="line">    <span class="keyword">super</span>(x)</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  calculate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.add(<span class="number">4</span>) + <span class="keyword">this</span>.y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Bar(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(f.calculate()) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>Ngoài ra với bạn cũng có thể dùng hàm mũi tên khi khai báo phương thức trong lớp. Điều này giúp đảm bảo this luôn trỏ đến đối tượng hiện tại. Cú pháp này đặc biệt thông dụng trong các ứng dụng React, tuy nhiên <strong>vẫn chưa được hỗ trợ mặc định</strong> bởi các trình duyệt, nên bạn phải dùng Babel để chuyển đổi mã nguồn.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">name</span>: <span class="string">'Fabulous button'</span> &#125;</span><br><span class="line"></span><br><span class="line">  doClick = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    <span class="comment">// 'You clicked Fabulous button'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.doClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ lớp căn bản.</p></blockquote><h3 id="9-Promise"><a href="#9-Promise" class="headerlink" title="9. Promise"></a>9. Promise</h3><p>Nếu bạn chưa biết Promise là gì thì <a href="https://kipalog.com/posts/Promise-la-khi-gi-" target="_blank" rel="noopener">click vào đây</a>.</p><p>Vì Promise đã được công nhận như một phần của đặc tả ECMAScript 6 nên các trình duyệt có nghĩa vụ phải hỗ trợ mặc định. So với những thư viện chuyên biệt như <a href="http://bluebirdjs.com" target="_blank" rel="noopener">bluebird</a> hay <a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">q</a> thì phiên bản mặc định có ít tính năng hơn, nhưng cũng vừa đủ để dùng. Quan trọng là không cần thư viện thứ ba.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> showUser = <span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Your name is <span class="subst">$&#123;user.name&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserData = <span class="function"><span class="params">userId</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> RemoteApi.get(<span class="string">`/users/<span class="subst">$&#123;userId&#125;</span>`</span>, (err, response) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err)</span><br><span class="line">      resolve(response)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">getUserData(<span class="number">123</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> response.data)</span><br><span class="line">  .then(showUser)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Oh no'</span>, err))</span><br></pre></td></tr></table></figure><p>Promise còn có các hàm tĩnh khác:</p><h5 id="Promise-all-iterator"><a href="#Promise-all-iterator" class="headerlink" title="Promise.all(iterator)"></a>Promise.all(iterator)</h5><p>Nhận vào một mảng các promises và chỉ resolve khi tất cả promises trong mảng được resolve.</p><h5 id="Promise-race-iterator"><a href="#Promise-race-iterator" class="headerlink" title="Promise.race(iterator)"></a>Promise.race(iterator)</h5><p>Nhận vào một mảng các promises và resolve/reject ngay khi một trong các promises trong mảng resolve/reject.</p><h5 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h5><p>Trả về một promise được tự động resolve.</p><h5 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h5><p>Trả về một promise được tự động reject.</p><blockquote><p><strong>Tính tương thích:</strong> Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ.</p></blockquote><h3 id="Ket"><a href="#Ket" class="headerlink" title="Kết"></a>Kết</h3><p>ES6 mang đến những tính năng tuyệt vời cho lập trình viên, giúp cho làm việc với JavaScript trở nên dễ thở hơn, đồng thời nâng cao hiệu suất, cải thiện mã nguồn và giảm dung lượng tập tin khi truyền tải trên mạng. Nếu ứng dụng của bạn hướng đến các trình duyệt hiện đại, đừng chần chờ gì, hãy dùng ES6 ngay hôm nay.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Việc hầu hết những tính năng hay ho hấp dẫn của ES6 đều đã được &lt;a href=&quot;https://kangax.github.io/compat-table/es6/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;các trình duyệt hỗ trợ&lt;/a&gt; quả là tin vui cho giới lập trình web. Nhờ nó mà nhà phát triển có thể xây dựng ứng dụng trực tiếp bằng ES6, không cần phải thông qua các công cụ chuyển đổi như &lt;a href=&quot;http://babeljs.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Babel&lt;/a&gt; hay &lt;a href=&quot;https://buble.surge.sh/guide/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bublé&lt;/a&gt; nữa, giúp ứng dụng trở nên gọn nhẹ hơn, giảm thiểu kích thước tập tin khi chuyển đến người sử dụng.&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Chi phí của Javascript</title>
    <link href="http://nthung2112.github.io/2018/07/Chi-phi-cua-Javascript.html"/>
    <id>http://nthung2112.github.io/2018/07/Chi-phi-cua-Javascript.html</id>
    <published>2018-07-07T08:01:00.000Z</published>
    <updated>2018-07-08T09:31:29.960Z</updated>
    
    <content type="html"><![CDATA[<p>Khi các website chúng ta xây dựng ngày càng phụ thuộc vào JavaScript, thỉnh thoảng chúng ta cũng phải trả giá cho những gì được gửi về phía người dùng, theo những cách không dễ nhìn thấy . Trong bài viết này, tôi sẽ nói về lý do tại sao một chút <strong>kỷ luật</strong> có thể giúp nếu bạn muốn website của mình có thể tải và phản ứng một cách nhanh chóng trên các thiết bị di động.<br><a id="more"></a></p><blockquote><p>tl;dr: less code = less parse/compile + less transfer + less to decompress</p><p>Dài quá ngại đọc: ít mã lệnh = ít thời gian phân tách/biên dịch + ít dung lượng trao đổi + ít phải giải nén</p></blockquote><h3 id="1-Ket-noi-mang"><a href="#1-Ket-noi-mang" class="headerlink" title="1. Kết nối mạng"></a>1. Kết nối mạng</h3><p>Khi nghĩ về chi phí cho JavaScript, hầu hết các lập trình viên nghĩ về mặt <strong>chi phí tải và thực thi mã lệnh</strong>. Kết nối Internet của người dùng càng chậm thì gửi nhiều bytes JavaScript về phía họ càng lâu.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*U00XcnhqoczTuJ8NH8UhOw.png" alt=""></p><p>Điều này cũng có thể là một vấn đề với cả những nước đã phát triển, vì <strong>kết nối mạng đang sử dụng</strong> của một người dùng có thể không thật sự là 3G, 4G hay WiFi. Bạn có thể đang vào mạng WiFi của một quán cà phê, nhưng đang kết nối với một hotspot di động với tốc độ 2G.</p><p>Bạn có thể <strong>giảm</strong> chi phí truyền tải JavaScript bằng cách:</p><ul><li><strong>Chỉ chuyển đến người dùng phần mã lệnh cần thiết</strong>. Kỹ thuật chia mã (code-splitting) có thể hữu ích ở đây.</li><li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer" target="_blank" rel="noopener"><strong>Tối giản hóa</strong></a> mã lệnh (sử dụng Uglify cho ES5, <a href="https://github.com/babel/minify" target="_blank" rel="noopener">babel-minify</a> hay <a href="https://www.npmjs.com/package/uglify-es" target="_blank" rel="noopener">uglify-es</a> cho ES2015)</li><li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer" target="_blank" rel="noopener"><strong>Nén mã lệnh</strong></a> tới mức tối đa, bằng cách dùng <a href="https://www.smashingmagazine.com/2016/10/next-generation-server-compression-with-brotli/" target="_blank" rel="noopener">Brotli</a> ~ <a href="https://twitter.com/paulcalvano/status/924660429846208514" target="_blank" rel="noopener">q11</a>, Zopfli hay gzip. Brotli hoàn toàn qua mặt gzip khi xét về tỉ lệ nén. Giải thuật này đã giúp cho CertSimple giảm 17% dung lượng nén tập tin JS, và LinkedIn tiết kiệm 4% thời gian tải.</li><li><strong>Xóa mã lệnh không dùng tới</strong>. Với <a href="https://developers.google.com/web/updates/2017/04/devtools-release-notes" target="_blank" rel="noopener">DevTools code coverage</a>, bạn có thể nhận dạng phần mã nào không được thực thi. Để loại bỏ mã nguồn không cần thiết, bạn có thể sử dụng kỹ thuật <a href="https://webpack.js.org/guides/tree-shaking/" target="_blank" rel="noopener">“rung cây”</a> (tree-shaking) của Webpack, các kỹ thuật tối ưu hóa nâng cao của <a href="https://developers.google.com/closure/compiler/" target="_blank" rel="noopener">Closure Compiler</a>, và các plugin hỗ trợ tỉa tót mã lệnh như lodash-babel-plugin hay ContextReplacementPlugin của Webpack dành cho các thư viện như moment.js. Sử dụng babel-preset-env và browserlist để tránh tình trạng chuyển đổi những tính năng ES2015 đã được hỗ trợ mặc định trong các trình duyệt. Những lập trình viên nhiều kinh nghiệm có thể phân tích các bản đóng gói (bundles) của Webpack và tìm cách bỏ đi những thư viện phụ thuộc không cần thiết.</li><li><strong>Lưu bộ đệm để giảm tải các yêu cầu mạng</strong>. Xác định thời gian sống tối ưu cho các tập tin JS (max-age) và cung cấp các token thẩm định (ETag) để tránh phải truyền tải những bytes không cần thiết. Lưu bộ đệm bằng Service Worker có thể giúp ứng dụng của bạn trở nên chủ động hơn trong trường hợp mất kết nối, đồng thời cho phép bạn truy xuất đến những tính năng đặc biệt, chẳng hạn như <a href="https://v8project.blogspot.com/2015/07/code-caching.html" target="_blank" rel="noopener">bộ đệm lưu trữ mã trong V8</a>. Hãy tìm hiểu về lưu đệm dài hạn với kỹ thuật băm tên tập tin (filename hashing).</li></ul><p><img src="https://cdn-images-1.medium.com/max/2000/1*8Spf9To8dzTG3Xy9s57oVA.png" alt=""></p><h3 id="2-Phan-tach-Bien-dich"><a href="#2-Phan-tach-Bien-dich" class="headerlink" title="2. Phân tách/Biên dịch"></a>2. Phân tách/Biên dịch</h3><p>Sau khi đã tải, một trong những chi phí JavaScript <strong>nặng nề</strong> nhất là thời gian để một trình xử lý JS tiến hành phân tách/biên dịch mã nguồn. Trong Chrome DevTools, phân tách và biên dịch là những phần trong thời gian “Scripting” màu vàng, có thể thấy trong bảng Performance.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*_4gNDmBlXxOF2-KmsOrKkw.png" alt=""></p><p>Phần Bottom-Up/Call Tree cho phép xem chính xác thời gian phân tách và biên dịch mã:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*GdrVt_BTTzzBOIoyZZsQZQ.png" alt=""></p><p><em>Trong bản Performance của Chrome DevTools, tìm đến phần Bottom-Up. Khi Runtime Call Stats trong V8 được kích hoạt, chúng ta có thể thấy thời gian cần thiết của những tiến trình như Phân Tách và Biên Dịch</em></p><p>Nhưng mà, tại sao điều này lại quan trọng?</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Dirw7RdQj9Dktc-Ny6-xbA.png" alt=""></p><p><strong>Mất nhiều thời gian để phân tách/biên dịch mã nguồn có thể làm chậm đi đáng kể thời gian người dùng có thể tương tác với website. Bạn càng gửi xuống nhiều tập tin JavaScript, trình duyệt càng tốn thời gian để phân tách và biên dịch trước khi website của bạn có thể tương tác được.</strong></p><p><img src="https://cdn-images-1.medium.com/max/1600/1*6Y665hpxfWNMu2EXu3VGlw.png" alt=""></p><blockquote><p>Ăn byte nào trả byte đó, <strong>JavaScript ngày càng trở nên đắt đỏ cho trình duyệt để xử lý hơn là một bức hình hay web font có cùng dung lượng tương ứng</strong> – <em>Tom Dale - tác giả của Ember.js</em></p></blockquote><p>So với JavaScript, cũng có nhiều chi phí tham gia vào quá trình xử lý một bức ảnh có dung lượng tương tự (chúng vẫn cần phải được giải mã!) nhưng đối với phần cứng của thiết bị di động trung bình, có vẻ như tác động của JS có phần tiêu cực hơn đến khả năng tương tác của website.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*PRVzNizF9jQ_QADF5lQHpA.png" alt=""></p><p><small><em>Các byte của JavaScript và hình ảnh cần đến những chi phí rất khác nhau. Hình ảnh thường không chặn luồng chính (main thread) hay ngăn cản tương tác với các giao diện trong quá trình giải mã và hiển thị lên màn hình (rasterization). Ngược lại JS có thể làm chậm quá trình tương tác vì các chi phí phân tách, biên dịch và thực thi.</em></small></p><p>Khi chúng ta nói về phân tách và biên dịch bị chậm, ngữ cảnh rất quan trọng – vì ở đây chúng ta đang nói về những chiếc điện thoại ở phân khúc trung bình. Người dùng bình dân có thể dùng những thiết bị với CPUs và GPUs chậm chạp, hoàn toàn không có bộ đệm L2/L3 và thậm chí còn bị giới hạn bộ nhớ.</p><blockquote><p>Năng lực mạng và năng lực của thiết bị thường không đi chung với nhau. Một người dùng sử dụng kết nối Fiber siêu tốc không nhất thiết phải có CPU tốt nhất để phân tách và thực thi JavaScript được gửi đến. Điều ngược lại cũng chính xác…kết nối cùi mía, nhưng CPU lại nhanh như điện. – Kristofer Baxter, LinkedIn.</p></blockquote><p>Trong bài <a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201" target="_blank" rel="noopener">JavaScript Start-up Performance</a>, tôi có lưu ý về chi phí phân tách một tập tin JavaScript (đơn giản) đã được giải nén có dung lượng khoảng 1MB trên phần cứng bình dân và cao cấp. <strong>Thời gian phân tách/biên tịch mã lệnh giữa chiếc điện thoại nhanh nhất với chiếc điện thoại trung bình khác nhau từ 2 đến 5 lần.</strong></p><p><img src="https://cdn-images-1.medium.com/max/2000/1*8BQ3bCYu1AVvJWPR1x8Yig.png" alt=""></p><p><small><em><strong>Thời gian phân tách một bản đóng gói JavaScript có dung lượng 1MB (~250KB gzipped)</strong> giữa các thiết bị máy tính cá nhân và di động thuộc nhiều dòng khác nhau. Khi nhìn vào chi phí cho việc phân tách, chúng ta phải xem xét khi tập tin đã <strong>được giải nén</strong>, chẳng hạn như ~250KB gzipped khi giải nén thì khoảng 1MB.</em></small></p><p>Đối với những trang trong thực tế, như CNN.com thì sao?</p><p><strong>Trên một chiếc iPhone 8 cao cấp thì mất khoảng 4 giây để phân tách/biên dịch JS trên CNN.com, so với khoảng 13 giây cho một chiếc điện thoại bình dân (Moto G4)</strong>. Điều này có thể tác động rõ ràng đến khả năng tương tác của người dùng với website.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*7ysArXJ4nN0rQEMT9yZ_Sg.png" alt=""></p><p><small><em>So sánh thời gian phân tách mã nguồn trên chip A11 Bionic của Apple với Snapdragon 617 trên các thiết bị Android bình dân</em></small></p><p>Điều này nêu bật tầm quan trọng của việc kiểm thử ứng dụng trên các phần cứng <strong>trung bình</strong> (như chiếc Moto G4) thay vì chiếc điện thoại trong túi của bạn. Nói gì thì nói, ngữ cảnh cũng quan trọng: <strong>tối ưu hóa cho thiết bị và điều kiện kết nối mà người dùng <em>của bạn</em> có.</strong></p><p><img src="https://cdn-images-1.medium.com/max/1600/1*6oEpMEi_pjRNjmtN9i2TCA.png" alt=""></p><p>Các ứng dụng phân tích thống kê (analytics) có thể đưa ra một cái nhìn về <a href="https://crossbrowsertesting.com/blog/development/use-google-analytics-find-devices-customers-use/" target="_blank" rel="noopener">dòng thiết bị di động</a> mà người dùng thực tế của bạn đang sử dụng. Thông tin này đem đến cơ hội để hiểu hơn về các điều kiện giới hạn của CPU/GPU trên các thiết bị đó.</p><p><strong>Mà có thật là chúng ta đang gửi xuống người dùng quá nhiều JavaScript không? Hên xui :)</strong></p><p>Bằng cách sử dụng HTTP Archive (với khoảng 500K websites) để phân tích hiện trạng JavaScript trên các thiết bị di động, chúng ta có thể thấy rằng 50% website cần đến hơn 14 giây để có thể tương tác. Những trang này bỏ ra đến hơn 4 giây chỉ để phân tách và biên dịch JS.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*sVgunAoet0i5FWEI9NSyMg.png" alt=""></p><p>Thời gian để tải và xử lý JS và các tài nguyên khác đóng một vai trò ở đây, và có lẽ không quá ngạc nhiên khi người dùng phải chờ một lúc trước khi cảm giác website đã có thể sử dụng. Rõ ràng chúng ta có thể làm tốt hơn.</p><p><strong>Loại bỏ những phần JavaScript không quan trọng trong trang có thể giảm thiểu thời gian truyền tải, quá trình phân tách và biên dịch vốn ngốn CPU, và cả việc ngốn bộ nhớ. Nó cũng làm cho website trở nên có thể tương tác được nhanh hơn.</strong></p><h3 id="3-Thoi-gian-thuc-thi"><a href="#3-Thoi-gian-thuc-thi" class="headerlink" title="3. Thời gian thực thi"></a>3. Thời gian thực thi</h3><p>Chi phí không chỉ nằm ở quá trình phân tách và biên dịch. <strong>Quá trình thực thi JavaScript</strong> (chạy mã lệnh sau khi đã phân tách/biên dịch) là một trong những thao tác phải xảy ra trong luồng chính. Thời gian thực thi quá lâu có thể làm trì hoãn thời gian người dùng có thể tương tác với website.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*ec0wEKKVl7iQidBks3oDKg.png" alt=""></p><blockquote><p>If script executes for more than 50ms, time-to-interactive is delayed by the entire amount of time it takes to download, compile, and execute the JS — Alex Russell</p><p>Nếu một đoạn mã phải thực thi trong hơn 50ms, thời gian để tương tác bị trì hoãn bằng nguyên cả thời gian cần thiết để tải, biên dịch và thực thi JS – Alex Russell</p></blockquote><p>Để giải quyết vấn đề này, JavaScript tận dụng khả năng chia nhỏ thành từng phần (small chunks) để tránh không khóa hoàn toàn luồng chính. Bạn hãy tìm hiểu để xem có thể giảm thiểu công việc trong quá trình thực thi hay không.</p><h3 id="4-Mot-so-khuon-mau-de-giam-thieu-chi-phi-truyen-tai-JavaScript"><a href="#4-Mot-so-khuon-mau-de-giam-thieu-chi-phi-truyen-tai-JavaScript" class="headerlink" title="4. Một số khuôn mẫu để giảm thiểu chi phí truyền tải JavaScript"></a>4. Một số khuôn mẫu để giảm thiểu chi phí truyền tải JavaScript</h3><p>Khi bạn đang tìm cách để giảm thiểu thời gian truyền tải, phân tách và biên dịch JavaScript, có vài khuôn mẫu có thể hữu ích, như kỹ thuật chia nhỏ theo định tuyến (route-based chunking) hay còn gọi là <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" target="_blank" rel="noopener">PRPL</a>.</p><p>PRPL là một kỹ thuật để tối ưu hóa khả năng tương tác trên website bằng cách chia nhỏ mã nguồn và lưu bộ đệm một cách quyết liệt.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*VgdNbnl08gcetpqE1t9P9w.png" alt=""></p><p>Hãy xem những tác động nó có thể mang lại.</p><p>Chúng ta phân tính thời gian tải của những trang web di động thông dụng và các ứng dụng web tăng tiến (Progressive Web Apps – PWAs) bằng cách sử dụng Runtime Call Stats trong V8. Như chúng ta có thể thấy, thời gian phân tách (phần màu cam) chiếm một phần lớn trong tổng thời gian của các website này.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*9BMRW5i_bS4By_JSESXX8A.png" alt=""></p><p><a href="https://wego.com/" target="_blank" rel="noopener">Wego</a>, một trang sử dụng PRPL, xoay xở để giữ cho thời gian phân tách ở mức thấp, giúp cho website có thể tương tác nhanh hơn. Những trang còn lại cũng đã thực hiện kỹ thuật chia mã và dự toán hiệu suất (performance budgeting) để giảm chi phí JS.</p><h3 id="5-Nhung-chi-phi-khac"><a href="#5-Nhung-chi-phi-khac" class="headerlink" title="5. Những chi phí khác"></a>5. Những chi phí khác</h3><p>JavaScript cũng có thể tác động đến hiệu suất của website theo những hướng khác:</p><ul><li>Bộ nhớ. Website có thể cảm thấy bị giựt (jank) hay tạm dừng thường xuyên do bộ gom rác (garbage collector - GC) hoạt động. Khi trình duyệt tiến hành thu hồi bộ nhớ, quá trình thực thi JS bị tạm dừng. Do đó khi trình duyệt thu hồi bộ nhớ quá thường xuyên, tiến trình JS cũng bị dừng liên tục hơn chúng ta mong muốn. Lập trình viên cần tránh bị rò rỉ bộ nhớ và tiến trình dừng của GC để website có thể hoạt động ổn định hơn.</li><li>Trong quá trình chạy, mã JavaScript chạy quá lâu có thể khóa luồng chính, làm cho website trở nên không tương tác được. Bằng cách chia nhỏ công việc ra thành từng phần (sử dụng requestAnimationFrame() hay requestIdleCallback() để phân lịch) có thể giúp giảm thiểu các vấn đề về tương tác.</li></ul><h3 id="6-Ky-thuat-Khoi-dong-Tang-tien-progressive-bootstrapping"><a href="#6-Ky-thuat-Khoi-dong-Tang-tien-progressive-bootstrapping" class="headerlink" title="6. Kỹ thuật Khởi động Tăng tiến (progressive bootstrapping)"></a>6. Kỹ thuật Khởi động Tăng tiến (progressive bootstrapping)</h3><p>Nhiều website xem tính ẩn hiện của nội dung trên trang là một chi phí đắt đỏ khi tối ưu hóa tính tương tác. Để có thể thực hiện tiến trình vẽ đầu tiên (first paint) một cách nhanh chóng, lập trình viên thường sử dụng kỹ thuật tạo nội dung trước ở phía server (server-side rendering - SSR), sau đó “nâng cấp” bằng cách gắn các hàm xử lý sự kiện sau khi JavaScript đã được tải về.</p><p>Nhưng hãy cẩn thận – kỹ thuật này cũng có chi phí riêng của nó. Bạn 1) nhìn chung sẽ gửi xuống một tập tin HTML <em>nặng ký hơn</em> và có thể ảnh hưởng đến tính tương tác của site, hoặc 2) có thể đưa người dùng vào một vùng thung lũng huyền bí (uncanny valley) nơi một nửa trải nghiệm không thật sự có thể tương tác được, cho đến khi JavaScript hoàn tất quá trình xử lý.</p><p>Kỹ thuật Khởi động Tăng tiến có thể là một hướng tiếp cận tốt hơn. Bạn chỉ cần gửi xuống một trang vừa đủ có thể hoạt động, bao gồm chỉ HTML/JS/CSS cần thiết cho định tuyến hiện tại. Khi các tài nguyên khác đã được tải xong, ứng dụng có thể lazy-load vào và mở ra các chức năng khác.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*zY03Y5nVEY21FXA63Qe8PA.png" alt="Kỹ thuật Khởi động Tăng tiến"></p><p><strong>Kỹ thuật tải mã lệnh tương ứng với những gì đang được hiển thị chính là cứu cánh. PRPL và Khởi động Tăng tiến là hai khuôn mẫu giúp đạt được mục tiêu này.</strong></p><h3 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h3><p><strong>Kích thước tập tin khi truyền tải rất quan trọng đối với những kết nối mạng cấp thấp. Thời gian phân tách mã nguồn lại quan trọng đối với những thiết bị có giới hạn về CPU. Chúng ta cần phải giữ cho các chỉ số này ở mức thấp.</strong></p><p>Nhiều nhóm phát triển đã thành công trong việc làm theo các dự toán hiệu suất nghiêm ngặt, để giảm thiểu thời gian truyền tải và phân tách/biên dịch. Bạn có thể xem hướng dẫn “<a href="https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/" target="_blank" rel="noopener">Can You Afford It?: Real-world Web Performance Budgets</a>” của Alex Russell về dự toán hiệu suất cho các thiết bị di động.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*U8PJVNrA_tYADQ6_S4HUYw.png" alt=""></p><p>Nếu bạn đang phát triển một website hướng đến các thiết bị di động, hãy cố gắng hết sức để xây dựng nó trên phần cứng tiêu biểu, giữ cho thời gian phân tách/biên dịch JavaScript ở mức thấp, và thu nhận một dự toán hiệu suất để chắc chắn rằng nhóm của bạn luôn theo sát chi phí JavaScript.</p><h3 id="Tim-hieu-them"><a href="#Tim-hieu-them" class="headerlink" title="Tìm hiểu thêm"></a>Tìm hiểu thêm</h3><div class="video-container"><iframe src="//www.youtube.com/embed/_srJ7eHS3IM" frameborder="0" allowfullscreen></iframe></div><p><small><em>Bài nói chuyện của tôi ở Chrome Dev Summit 2017 về chi phí cho JavaScript. Phần sau của bài nói có nhắc đến những ví dụ thực tế từ các trang như Pinterest hay Tinder.</em></small></p><ul><li><a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201" target="_blank" rel="noopener">JavaScript Start-up Performance</a></li><li><a href="https://nolanlawson.github.io/frontendday-2016/" target="_blank" rel="noopener">Solving the web performance crisis </a> —  Nolan Lawson</li><li><a href="https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/" target="_blank" rel="noopener">Can you afford it? Real-world performance budgets</a>  —  Alex Russell</li><li><a href="https://twitter.com/kristoferbaxter/status/908144931125858304" target="_blank" rel="noopener">Evaluating web frameworks and libraries </a> —  Kristofer Baxter</li><li><a href="https://blog.cloudflare.com/results-experimenting-brotli/" target="_blank" rel="noopener">Kết quả thử nghiệm của Cloudflare cho giải thuật nén Brotli</a> (lưu ý là nén Brotli động ở chất lượng cao có thể làm chậm quá trình hiển thị trang lần đầu tiên nên bạn cần đánh giá một cách thận trọng. Có khi bạn sẽ muốn nén theo phương pháp tĩnh hơn.)</li><li><a href="https://medium.com/@samccone/performance-futures-bundling-281543d9a0d5" target="_blank" rel="noopener">Performance Futures </a> —  Sam Saccone</li></ul><p><em>Chân thành cám ơn Nolan Lawson, Kristofer Baxter và Jeremy Wagner vì những phản hồi của mọi người.</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Khi các website chúng ta xây dựng ngày càng phụ thuộc vào JavaScript, thỉnh thoảng chúng ta cũng phải trả giá cho những gì được gửi về phía người dùng, theo những cách không dễ nhìn thấy . Trong bài viết này, tôi sẽ nói về lý do tại sao một chút &lt;strong&gt;kỷ luật&lt;/strong&gt; có thể giúp nếu bạn muốn website của mình có thể tải và phản ứng một cách nhanh chóng trên các thiết bị di động.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>10 mẹo CSS hữu ích bạn nên biết</title>
    <link href="http://nthung2112.github.io/2018/06/10-meo-CSS-huu-ich-ban-nen-biet.html"/>
    <id>http://nthung2112.github.io/2018/06/10-meo-CSS-huu-ich-ban-nen-biet.html</id>
    <published>2018-06-27T01:01:00.000Z</published>
    <updated>2018-06-27T01:11:20.866Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Pagespeed Optimization</strong> (tối ưu hóa tốc độ trang) là một công việc mà hầu như mọi Web developer đều quan tâm và nên biết, mục đích của nó là đưa nội dung website đến với người xem nhanh nhất có thể.</p><p>Front-end developer thường làm việc với HTML, CSS, Javascript và các hình ảnh. Do đó, đây cũng là các đối tượng chính để chúng ta tối ưu tốc độ tải trang cho website. Tốc độ tải trang của website ngoài các yếu tố liên quan do server thì còn phụ thuộc vào kích thước và số lượng file phải tải về, do đó càng giảm được kích thước file lẫn số lượng file cần phải tải về thì cũng đồng thời tăng tốc độ tải file và giảm số lượng request lên server.<br><a id="more"></a><br>Ở bài này mình sẽ giới thiệu với các bạn 10 mẹo CSS hữu ích giúp giảm kích thước, số lượng file CSS, tối ưu file CSS và phát triển CSS dễ dàng hơn, nội dung bài gồm những phần sau:</p><ol><li><a href="#01-han-che-su-dung-import">Hạn chế sử dụng @import</a></li><li><a href="#02-su-dung-cach-viet-ngan-gon">Sử dụng cách viết ngắn gọn (shorthand properties)</a></li><li><a href="#03-khai-bao-class-bo-tro">Khai báo class bổ trợ (Helper classes)</a></li><li><a href="#04-han-che-su-dung-inline-css-trong-elements">Hạn chế sử dụng CSS trong element của HTML (inline CSS attributes in HTML elements)</a></li><li><a href="#05-giam-so-luong-file-css">Giảm số lượng file CSS (Combine external CSS)</a></li><li><a href="#06-giam-kich-thuoc-file-css">Giảm kích thước file CSS</a></li><li><a href="#07-ap-dung-ky-thuat-oocss">Áp dụng OOCSS (Object Oriented CSS)</a></li><li><a href="#08-to-chuc-class-va-id-mot-cach-khoa-hoc">Đặt tên class và id một cách khoa học</a></li><li><a href="#09-ngon-ngu-tien-xu-ly-css">Ngôn ngữ tiền xử lý CSS (CSS Preprocessor)</a></li><li><a href="#10-gioi-thieu-so-luoc-koala-app">Sử dụng Koala-app khi làm việc với CSS</a></li></ol><h2 id="1-Han-che-su-dung-import"><a href="#1-Han-che-su-dung-import" class="headerlink" title="1. Hạn chế sử dụng @import"></a>1. Hạn chế sử dụng @import</h2><p>Hạn chế sử dụng @import hoặc tốt nhất là không nên sử dụng @import trong file CSS, vì nó sẽ <strong>làm chậm quá trình tải</strong> và <strong>không sử dụng được khả năng tải file đồng thời của browser</strong>. Để dễ hiểu bạn hãy xem ví dụ sau:</p><p>Mình có 2 file CSS là a.css và b.css được nhúng vào trang web như sau:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'a.css'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'b.css'</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Trong file b.css, bạn import file c.css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(c.css);</span><br></pre></td></tr></table></figure><p>Kết quả khi browser tải trang sẽ như thế này:</p><p>HTML downloada.cssb.cssc.css</p><p>Chú thích:</p><ul><li>Request 1: browser gửi request để lấy HTML về</li><li>Request 2: browser gửi request để lấy a.css</li><li>Request 3: browser gửi request để lấy b.css</li><li>Request 4: browser gửi request để lấy c.css</li></ul><p>Như các bạn thấy ở hình trên, để tải được c.css thì browser phải chờ để tải xong a.css.</p><p><strong>Lý do</strong>: Vì browser khi đã tải xong b.css và bắt đầu đọc nội dung bên trong thì thấy <strong>@import</strong> yêu cầu phải tải thêm c.css, lúc này browser phải đứng chờ cho nhóm proccess trước đó chạy xong (trong trường hợp này là chờ a.css) thì mới bắt đầu tải tiếp c.css và tiếp tục render sau khi đã tải xong.</p><p>Trong khi đó nếu bạn loại bỏ @import url(c.css) trong b.css đi và nhúng trực tiếp c.css vào trang HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'a.css'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'b.css'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'c.css'</span>&gt;</span></span><br></pre></td></tr></table></figure><p>thì bạn sẽ có kết quả như sau:</p><p>HTML downloada.cssb.cssc.css</p><p>Lúc này browser sẽ bắt đầu tải file đồng thời không cần phải chờ cho a.css tải xong, sẽ rút ngắn được thời gian tải file xuống.</p><p>Như tiêu đề mình nói rằng nên <strong>Hạn chế</strong> sử dụng @import, vậy một câu hỏi nhỏ đặt ra là <strong>khi nào thì nên dùng @import?</strong>.</p><p>Theo mình thì khi <strong>những định nghĩa CSS cần lệ thuộc vào một định nghĩa ở file CSS khác trước – thì khi đó nên dùng @import</strong>, ví dụ bạn sử dụng các bộ thư viện reset CSS như <a href="https://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a>, bạn cần reset tất cả các định nghĩa CSS về một chuẩn chung trước khi viết định nghĩa CSS tiếp theo – lúc này bạn sẽ dùng @import để import file Normalize.css vào trong file định nghĩa CSS của bạn, lý do sử dụng @import ở đây là để tránh cơ chế tải file đồng thời của browser và bắt buộc browser phải tải và áp định nghĩa CSS của Normalize.css trước rồi mới đến các định nghĩ CSS ở bên dưới @import.</p><p>Một câu hỏi tiếp theo <strong>Nếu nhất thiết phải dùng @import như ví dụ trên, thì các nào khác để giải quyết thay vì dùng @import hay không?</strong>.</p><p>Tất nhiên là có cách, đó là bạn copy toàn bộ nội dung của file Normalize.css vào trong file CSS của bạn, hay còn gọi là <strong>Combine external CSS</strong> mình sẽ giới thiệu phía bên dưới.</p><h2 id="2-Su-dung-cach-viet-ngan-gon"><a href="#2-Su-dung-cach-viet-ngan-gon" class="headerlink" title="2. Sử dụng cách viết ngắn gọn"></a>2. Sử dụng cách viết ngắn gọn</h2><p>Sử dụng cách viết ngắn gọn (shorthand properties) để dễ dàng thiết lập một số thuộc tính chỉ trên một dòng, đây cũng là một cách để bạn dễ dàng kiểm soát – theo dõi code của mình, đồng thời cũng hỗ trợ giảm số lượng ký tự trong file css và giảm kích thước file.</p><p>Lấy ví dụ đơn giản về cách thiết lập thuộc tính hình ảnh cho background</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>:<span class="selector-id">#000</span>;</span><br><span class="line"><span class="selector-tag">background-image</span><span class="selector-pseudo">:url(bg-image.jpg)</span>;</span><br><span class="line"><span class="selector-tag">background-repeat</span><span class="selector-pseudo">:no-repeat</span>;</span><br><span class="line"><span class="selector-tag">background-attachment</span><span class="selector-pseudo">:fixed</span>;</span><br><span class="line"><span class="selector-tag">background-position</span><span class="selector-pseudo">:center</span> <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure><p>Bạn có thể viết thành</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>:<span class="selector-id">#000</span> <span class="selector-tag">url</span>(<span class="selector-tag">bg-image</span><span class="selector-class">.jpg</span>) <span class="selector-tag">no-repeat</span> <span class="selector-tag">fixed</span> <span class="selector-tag">center</span> <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure><p>Cấu trúc shorthand của thuộc tính background như sau</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: &lt;<span class="selector-tag">color</span>&gt; &lt;<span class="selector-tag">image</span>&gt; &lt;<span class="selector-tag">repeat</span>&gt; &lt;<span class="selector-tag">attachment</span>&gt; &lt;<span class="selector-tag">position</span>&gt;;</span><br></pre></td></tr></table></figure><p>Ngoài background thì còn có một số thuộc tính khác cũng có thể sử dụng shorthand như margin, padding, border, outline, … bạn có thể tham khảo thêm trên <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Shorthand_properties" target="_blank" rel="noopener">Mozilla Developer Network (MDN)</a>. Ở cuối trang này có danh sách các thuộc tính có thể áp dụng shorthand.</p><p>Bên cạnh đó, nếu bạn thích khai báo mã màu HEX thì đối với một số mã màu thông dụng bạn cũng có thể viết ngắn gọn lại ví dụ như #FFF thay cho #FFFFFF hay #000 thay cho #000000. Bạn có thể tham khảo cách chuyển đổi tại <a href="http://maettig.com/?page=PHP/CSS_Color_Converter" target="_blank" rel="noopener">CSS Color Converter</a>.</p><h2 id="3-Khai-bao-class-bo-tro"><a href="#3-Khai-bao-class-bo-tro" class="headerlink" title="3. Khai báo class bổ trợ"></a>3. Khai báo class bổ trợ</h2><p>Class bổ trợ (Helper classes) là những class được định nghĩa sẵn một số thuộc tính đơn giản và thường hay sử dụng. Ví dụ như text-align, font-weight, color… Class bổ trợ trong quá trình viết HTML các bạn chỉ cần thêm class đó vào mà không cần phải định nghĩa lại thuộc tính. Cách làm này khá hữu dụng khi bạn sử dụng một CSS framework và cần custom “rất ít” thuộc tính, hoặc bạn không chọn được tên class phù hợp cho element đó, hay element đó không cần xác định class để làm gì đó với javascript.</p><p>Điểm lợi của việc này ngoài việc bạn không cần định nghĩa lại một số thuộc tính không cần thiết, thì nếu CSS càng nhiều thì bạn sẽ tiết kiệm được khá nhiều thuộc tính cần khai báo lại và sẽ giảm được kích thước file CSS. Ví dụ:</p><p>Mình có các element sau cần viết CSS và mình đang dùng framework bootstrap:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-success btn-md text-uppercase"</span>&gt;</span></span><br><span class="line">    Show More</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Thay vì mình cần phải viết CSS như sau để custom lại theo ý mình</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">text-align</span>: center; <span class="attribute">padding-top</span>: <span class="number">20px</span>; &#125;</span><br><span class="line"><span class="selector-tag">p</span> &gt; <span class="selector-tag">button</span> &#123; <span class="attribute">background-color</span>: <span class="number">#fff</span>; <span class="attribute">padding-right</span>: <span class="number">30px</span>; <span class="attribute">padding-left</span>: <span class="number">30px</span> &#125;</span><br></pre></td></tr></table></figure><p>Thì mình sẽ khai báo class bổ trợ để có thể tái sử dụng cho nhiều trường hợp khác về sau ( Những class có sẵn của bootstrap mình sẽ không liệt kê vào, vì hiện giờ mình cần custom các element này )</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.padding-top-20</span> &#123; <span class="attribute">padding-top</span>: <span class="number">20px</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-30</span> &#123; <span class="attribute">padding-right</span>: <span class="number">30px</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-30</span> &#123; <span class="attribute">padding-left</span>: <span class="number">30px</span>; &#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.btn-bg-white</span> &#123; <span class="attribute">background-color</span>: <span class="number">#fff</span>; &#125;</span><br></pre></td></tr></table></figure><p>Như vậy trong HTML mình sẽ khai báo như sau</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-center padding-top-20"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-success btn-md btn-bg-white text-uppercase padding-right-30 padding-left-30"</span>&gt;</span>Show More<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Như vậy thì về sau những class này mình có thể tái sử dụng rất nhiều lần ở rất nhiều element, và mình có thể bỏ đi khá nhiều công đoạn phải gõ lại code CSS khi có phát sinh thêm element mới.</p><p>Điều này mình học hỏi từ bootstrap và cảm thấy nó khá là hay. Bạn có thể tham khảo thêm các <a href="https://getbootstrap.com/css/#helper-classes" target="_blank" rel="noopener">helper class</a> hoặc <a href="https://getbootstrap.com/css/#type" target="_blank" rel="noopener">typography</a> của bootstrap để hiểu rõ hơn.</p><h2 id="4-Han-che-su-dung-Inline-CSS-trong-cac-elements"><a href="#4-Han-che-su-dung-Inline-CSS-trong-cac-elements" class="headerlink" title="4. Hạn chế sử dụng Inline CSS trong các elements"></a>4. Hạn chế sử dụng Inline CSS trong các elements</h2><p>Ở đây, mình chỉ khuyên các bạn nên hạn chế sử dụng, vì điều này sẽ làm các bạn khó kiểm soát code CSS của mình. “Vạn bất đắc dĩ” cần giải quyết nhanh (hotfix) thì hãy dùng hoặc nếu chỉ dùng một lần hoặc là CSS động từ javascript thì có thể chấp nhận được.</p><p>Theo như <a href="https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery#CSSattributes" target="_blank" rel="noopener">Google Pagespeed Insights</a> thì việc này sẽ làm code bị lặp lại không cần thiết và vi phạm <a href="https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery#CSSattributes" target="_blank" rel="noopener">Chính sách Bảo mật Nội dung của W3</a>, trong một số trường hợp thì các attribute này sẽ bị chặn.</p><h2 id="5-Giam-so-luong-file-CSS"><a href="#5-Giam-so-luong-file-CSS" class="headerlink" title="5. Giảm số lượng file CSS"></a>5. Giảm số lượng file CSS</h2><p>Gom các file CSS lại với nhau (Combine external CSS) là việc dễ làm nhất, thay vì phải viết thành nhiều file như header.css, navigation.css, footer.css… vào trong văn bản HTML thì bạn hãy gom các file này thành một file duy nhất. Nội dung file này sẽ chứa toàn bộ nội dung của các file trên, như vậy bạn sẽ giảm được nhiều request đến server và giảm tải cho server khá nhiều.</p><p>Thay vì sử dụng như vầy</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/header.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/navigation.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/footer.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Nên gom chúng lại thành</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/style.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-Giam-kich-thuoc-file-CSS"><a href="#6-Giam-kich-thuoc-file-CSS" class="headerlink" title="6. Giảm kích thước file CSS"></a>6. Giảm kích thước file CSS</h2><p>Giảm kích thước file CSS được thực hiện bằng cách loại bỏ các khoảng trắng không cần thiết, dấu xuống hàng, dấu chấm phẩy cuối cùng trong class hoặc id… Công đoạn này còn được gọi là <strong>minify</strong>. Để tiện phân biệt giữa file chưa minify và file đã minify thì bạn nên thêm <strong>.min</strong> vào tên file đã minify. Ví dụ style.css sau khi minify sẽ thành style.min.css.</p><p>Bạn có thể truy cập vào <a href="http://www.cleancss.com/css-minify/" target="_blank" rel="noopener">Clean CSS</a> để thực hiện minify css hoặc sử dụng tool Koala-app mình sẽ giới thiệu bên dưới để tự động xuất file minify trong quá trình viết code.</p><h2 id="7-Ap-dung-ky-thuat-OOCSS"><a href="#7-Ap-dung-ky-thuat-OOCSS" class="headerlink" title="7. Áp dụng kỹ thuật OOCSS"></a>7. Áp dụng kỹ thuật OOCSS</h2><p><strong>OOCSS</strong> (Object Oriented CSS) – CSS hướng đối tượng, thật ra hướng đối tượng ở đây có nghĩa là bạn gom các thuộc tính giống nhau của 2 class cùng áp dụng cho một element thành một class để giảm thiểu sự lặp lại. Ví dụ:</p><p>Thay vì khai báo 2 class cho button như sau</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.42857143</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#337ab7</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#2e6da4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.btn-success</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.42857143</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mình sẽ gom một số thuộc tính của 2 class này thành một class khác có tên là btn:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.42857143</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#337ab7</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#2e6da4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.btn-success</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Như vậy nếu sau này có thay đổi gì về một số thuộc tính chung của 2 class thì mình chỉ cần thay đổi class btn thì sẽ dễ dàng và nhanh hơn.</p><h2 id="8-To-chuc-class-va-id-mot-cach-khoa-hoc"><a href="#8-To-chuc-class-va-id-mot-cach-khoa-hoc" class="headerlink" title="8. Tổ chức class và id một cách khoa học"></a>8. Tổ chức class và id một cách khoa học</h2><p>Việc này để hỗ trợ bạn sau này khi xem lại code của mình dễ dàng hơn và không bị rối với cách đặt tên của mình, đồng thời cũng dễ dàng nếu có áp dụng một số CSS preprocessor hay BEM.</p><p>Thay vì đặt tên</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.titlepost</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.headerpost</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.contentpost</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>thì nên đặt thành</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post-title</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post-header</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post-content</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>hoặc tổ chức thành</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post</span> &gt; <span class="selector-class">.title</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post</span> &gt; <span class="selector-class">.header</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post</span> &gt; <span class="selector-class">.content</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="9-Ngon-ngu-tien-xu-ly-CSS"><a href="#9-Ngon-ngu-tien-xu-ly-CSS" class="headerlink" title="9. Ngôn ngữ tiền xử lý CSS"></a>9. Ngôn ngữ tiền xử lý CSS</h2><p><strong>Tiền xử lý CSS</strong> (CSS Preprocessor) – là một cách mở rộng của CSS hoặc cũng có thể coi nó là một ngôn ngữ riêng. Mục đích của CSS preprocessor là để bạn dễ dàng cấu trúc các đoạn code CSS, giảm thời gian phải viết đi viết lại một đoạn code, dễ dàng áp dụng OOCSS… Nói cách khác bạn có thể hiểu CSS preprocessor gần như là một ngôn ngữ lập trình vì nó cũng có biến, kế thừa class, và dễ dàng tạo ra một thư viện riêng cho bạn quản lý, kế thừa và tái sử dụng ở những dự án khác.</p><p>CSS preprocessor hiện nay có rất nhiều nhưng phổ biến nhất hiện nay là <a href="http://lesscss.org/" target="_blank" rel="noopener"><strong>Less</strong></a> và <a href="http://sass-lang.com/" target="_blank" rel="noopener"><strong>Sass.</strong></a> Ở đây mình giới thiệu các bạn về Sass vì mình đang sử dụng nó thay cho Less, và CSS framework phổ biến – <a href="https://blog.getbootstrap.com/2015/08/19/bootstrap-4-alpha/" target="_blank" rel="noopener">Bootstrap, kể từ phiên bản 4 đã chuyển từ Less qua Sass</a>. Về Sass các bạn xem <a href="http://sass-lang.com/install" target="_blank" rel="noopener">hướng dẫn cài đặt trên trang chủ</a>.</p><p>Khi bắt đầu với một dự án có áp dụng Sass, việc đầu tiên mình thường làm là cấu trúc CSS thành nhiều file nhỏ để tránh nhồi nhét CSS vào một file và dễ dàng cho việc quản lý, tìm kiếm khi cần thiết. Mình thường cấu trúc các file Sass như sau:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scss</span><br><span class="line">|-- style.scss</span><br><span class="line">|-- _variable.scss</span><br><span class="line">|-- _helper.scss</span><br><span class="line">|-- _mixins.scss</span><br><span class="line">|-- components</span><br><span class="line">|-- -- _header.scss</span><br><span class="line">|-- -- _footer.scss</span><br><span class="line">|-- mixins</span><br><span class="line">|-- -- button.scss</span><br><span class="line">|-- -- label.scss</span><br></pre></td></tr></table></figure><p>Trong file style.scss nội dung như sau:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"variable"</span>;</span><br><span class="line">@impprt <span class="string">"helper"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"mixins"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Components</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"components/header"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"components/footer"</span>;</span><br></pre></td></tr></table></figure><p>Chú thích:</p><ul><li>_variable.scss: variable chứa các thông tin về các biến dùng chung</li><li>_helper.scss: helper sẽ chứa/import các class helper</li><li>_mixins.scss: mixins sẽ chứa/import các class custom hoặc class được tái sử dụng nhiều lần</li></ul><p>Nội dung file _helper.scss như mình đã nói sẽ tạo ra các class helper, nhưng ở đây mình áp dụng tính chất của Scss để tạo ra các class với ít dòng code nhất:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$numbersPX</span>:</span><br><span class="line">  <span class="string">"10"</span> <span class="number">10px</span>,</span><br><span class="line">  <span class="string">"15"</span> <span class="number">15px</span>,</span><br><span class="line">  <span class="string">"20"</span> <span class="number">20px</span>,</span><br><span class="line">  <span class="string">"25"</span> <span class="number">25px</span>,</span><br><span class="line">  <span class="string">"30"</span> <span class="number">30px</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// padding</span></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$i</span> in <span class="variable">$numbersPX</span>&#123;</span><br><span class="line">  <span class="selector-class">.padding-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.padding-top-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.padding-bottom-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.padding-right-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-right</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.padding-left-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>khi Sass complier ra file CSS thì mình sẽ thu được kết quả như sau</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.padding-10</span> &#123; <span class="attribute">padding</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-10</span> &#123; <span class="attribute">padding-top</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-10</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-10</span> &#123; <span class="attribute">padding-right</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-10</span> &#123; <span class="attribute">padding-left</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-15</span> &#123; <span class="attribute">padding</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-15</span> &#123; <span class="attribute">padding-top</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-15</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-15</span> &#123; <span class="attribute">padding-right</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-15</span> &#123; <span class="attribute">padding-left</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-20</span> &#123; <span class="attribute">padding</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-20</span> &#123; <span class="attribute">padding-top</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-20</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-20</span> &#123; <span class="attribute">padding-right</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-20</span> &#123; <span class="attribute">padding-left</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-25</span> &#123; <span class="attribute">padding</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-25</span> &#123; <span class="attribute">padding-top</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-25</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-25</span> &#123; <span class="attribute">padding-right</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-25</span> &#123; <span class="attribute">padding-left</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-30</span> &#123; <span class="attribute">padding</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-30</span> &#123; <span class="attribute">padding-top</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-30</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-30</span> &#123; <span class="attribute">padding-right</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-30</span> &#123; <span class="attribute">padding-left</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="10-Gioi-thieu-so-luoc-Koala-App"><a href="#10-Gioi-thieu-so-luoc-Koala-App" class="headerlink" title="10. Giới thiệu sơ lược Koala App"></a>10. Giới thiệu sơ lược Koala App</h2><p><a href="http://koala-app.com" target="_blank" rel="noopener">Koala app</a> là một ứng dụng GUI hỗ trợ biên dịch Less, Sass, Compass và CoffeeScript sang CSS và JS. Koala App chạy được trên cả 3 môi trường Mac OS, Linux và Windows nên rất tiện nếu bạn cần thay đổi qua lại giữa các hệ điều hành. Ngoài ra, Koala App còn hỗ trợ minify cho cả CSS và JS.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2016/01/image01-700x453.png" alt=""></p><p>Sử dụng Koala App rất đơn giản, bạn chỉ cần mở lên và ấn dấu + trên đầu chương trình để chọn thư mục chứa các file cần xử lý, và Koala App sẽ tự động scan toàn bộ các folder bên trong và theo dõi khi có thay đổi.</p><p>Nếu bạn “siêng” thì có thể tham khảo cách để tự cấu hình project để Koala-app hoạt động theo ý mình <a href="https://github.com/oklai/koala/wiki/Using-project-settings" target="_blank" rel="noopener">tại đây</a>.</p><p>Trên đây là những mẹo CSS rút ra từ kinh nghiệm làm việc của mình. Nếu bạn còn những mẹo hay khác thì đừng ngại chia sẻ bên dưới nhé.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Pagespeed Optimization&lt;/strong&gt; (tối ưu hóa tốc độ trang) là một công việc mà hầu như mọi Web developer đều quan tâm và nên biết, mục đích của nó là đưa nội dung website đến với người xem nhanh nhất có thể.&lt;/p&gt;
&lt;p&gt;Front-end developer thường làm việc với HTML, CSS, Javascript và các hình ảnh. Do đó, đây cũng là các đối tượng chính để chúng ta tối ưu tốc độ tải trang cho website. Tốc độ tải trang của website ngoài các yếu tố liên quan do server thì còn phụ thuộc vào kích thước và số lượng file phải tải về, do đó càng giảm được kích thước file lẫn số lượng file cần phải tải về thì cũng đồng thời tăng tốc độ tải file và giảm số lượng request lên server.&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://nthung2112.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Tối ưu hiệu suất render để website mượt hơn</title>
    <link href="http://nthung2112.github.io/2018/06/Toi-uu-hieu-suat-render-de-website-muot-hon.html"/>
    <id>http://nthung2112.github.io/2018/06/Toi-uu-hieu-suat-render-de-website-muot-hon.html</id>
    <published>2018-06-26T00:50:00.000Z</published>
    <updated>2018-06-27T01:12:25.692Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Optimizing Performance</strong> (tối ưu hóa hiệu suất) cho website là một công việc mà bất kỳ front-end developer nào cũng nên biết, mục đích là để trang web đáp ứng được 3 tiêu chí:</p><ol><li><strong>NHẸ</strong>: Giảm kích thước trang web và các thành phần đi kèm như javascript, css, hình ảnh… nhằm đảm bảo <strong>thời gian tải xuống ngắn hơn</strong>. Chúng ta có thể dùng các bộ minify cho javascript, css…, nén các tập tin hình ảnh, font chữ, svg… ngoài ra còn có các kĩ thuật như code splitting, browser caching, HTTP caching…</li><li><strong>NHANH</strong> <strong>Hiển thị nội dung trang web càng sớm càng tốt</strong> bằng cách: chia cấu trúc DOM hợp lý, hạn chế blocking CSS/JS, hạn chế chỉnh sửa DOM tree, chia các file ra thành nhiều module, tải resource bất đồng bộ, tối ưu hóa các selector của CSS và JS…</li><li><strong>MƯỢT</strong>: Sau khi nội dung trang web đã được tải về và hiển thị thì việc tiếp theo là <strong>bảo đảm các hiệu ứng animation, transition, scrolling… phải mượt</strong>, không bị lag và giật (jank).</li></ol><a id="more"></a><p>Trong 3 tiêu chí này, có 2 tiêu chí mà front-end developer chúng ta hằng ngày đều thực hiện là <strong>nhẹ và nhanh</strong>. Bằng cách sử dụng các framework (angularjs, reactjs…) và các bộ build tool (grunt, gulp, webpack…), các resource trong project ở môi trường production lúc nào cũng được minify và đóng gói đầy đủ, gọn gàng.</p><p>Do đó, trong bài này tôi sẽ hướng dẫn cho bạn cách đáp ứng được tiêu chí thứ 3, đó là <strong>MƯỢT</strong>, thứ mà ít có framework hay công cụ nào có thể hỗ trợ bạn được.</p><p> <a href="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image05.png" target="_blank" rel="noopener"><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image05-700x455.png" alt=""></a> </p><p>Trên thực tế, các web page yêu cầu độ mượt cao thường là các webpage có nhiều hiệu ứng, chuyển động, ví dụ như các trang landing page, giới thiệu sản phẩm, HTML5 game, hoặc các ứng dụng có animation chạy trên các thiết bị có cấu hình thấp. Bạn có thể xem qua một số trang sau:</p><ul><li><a href="http://world.mathigon.org/" target="_blank" rel="noopener">http://world.mathigon.org/</a></li><li><a href="http://matthew.wagerfield.com/parallax/" target="_blank" rel="noopener">http://matthew.wagerfield.com/parallax/</a></li></ul><h2 id="Lam-the-nao-de-web-page-“muot”"><a href="#Lam-the-nao-de-web-page-“muot”" class="headerlink" title="Làm thế nào để web page “mượt”?"></a>Làm thế nào để web page “mượt”?</h2><p>Mượt ở đây chính là “Rendering Performance”, để tối ưu hiệu suất render chúng ta phải hiểu được quá trình render của browser.</p><h3 id="60"><a href="#60" class="headerlink" title="60"></a>60</h3><p>… là số khung hình trên một giây mà các thiết bị phổ biến hiện nay hỗ trợ (60fps). Để cho trang web mượt thì tốc độ render phải đáp ứng được con số này. Tức là trong <strong>1 giây</strong> chúng ta phải cho ra <strong>60 khung hình</strong>. Với mỗi khung hình, chúng ta có 1 / 60 = 16,66 mili giây. Trên thực tế, browser còn có một số tác vụ khác phải làm bên cạnh việc render, vì thế chúng ta trừ hao còn lại khoảng 16ms.</p><p>Bất cứ animation hay transition nào, muốn đảm bảo được tốc độ 60fps thì phải cũng phải đảm bảo trong vòng <strong>16ms phải render được một khung hình</strong>, nếu không thì sẽ bị hiện tượng “frame skip”, hiệu ứng sẽ bị giật, lag.</p><h3 id="Can-phai-lam-nhung-gi-trong-16ms-do"><a href="#Can-phai-lam-nhung-gi-trong-16ms-do" class="headerlink" title="Cần phải làm những gì trong 16ms đó?"></a>Cần phải làm những gì trong 16ms đó?</h3><p>Để cho ra được 1 khung hình, đây là các việc mà browser phải thực hiện (<strong>the pixel pipeline</strong>):</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image19-700x107.png" alt=""></p><p>Giải thích ngắn gọn:</p><p><strong>1. JavaScript</strong>: là hoạt động execute code của javascript.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'my-element'</span>).style.width = <span class="string">'300px'</span>;</span><br></pre></td></tr></table></figure><p><strong>2. Style calculation</strong>: tính toán các thuộc tính theo các quy tắc từ file CSS (hoặc thẻ <code>&lt;style&gt;</code>, thuộc tính style).</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'my-element'</span> <span class="attr">style</span>=<span class="string">'width: 300px'</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3. Layout</strong>: browser thực hiện “chia vùng” cho các element khi hiển thị trên màn hình, dựa trên các thuộc tính đã tính toán được từ bước Style.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image28.png" alt=""></p><p><strong>4. Paint</strong>: tô màu cho từng pixel, bao gồm việc: vẽ chữ (render font), hình ảnh, màu, vẽ các hiệu ứng CSS như border, box-shadow… Việc tô màu này được thực hiện trên nhiều “layer” cùng một lúc (phần sau sẽ giải thích rõ hơn về layer). Đây là bước chiếm nhiều thời gian nhất.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image23.png" alt=""></p><p><strong>5. Composite</strong>: gộp các layer đã được vẽ (ở bước Paint) và hiển thị lên màn hình theo đúng thứ tự của các layer đó.</p><p>Như vậy, chỉ với 16ms browser phải thực hiện 5 bước như trên để có thể render ra được 1 khung hình. Vậy để đảm bảo mọi thứ đều hoàn thành dưới 16ms, việc chúng ta cần làm là tối ưu từng bước. Cụ thể là:</p><ul><li><p><strong>JavaScript:</strong></p><ul><li>Dùng requestAnimationFrame.</li><li>Dùng Web workers, Micro-task cho các tác vụ nặng.</li><li>Profiling with Chrome DevTools.</li></ul></li><li><p><strong>Style:</strong></p><ul><li>Giảm độ phức tạp của selector</li><li>Giảm số lượng element bị ảnh hưởng</li></ul></li><li><p><strong>Layout:</strong></p><ul><li>Hạn chế kích hoạt layout</li><li>Sử dụng Flexbox</li><li>Hạn chế forced synchronous layout.</li></ul></li><li><p><strong>Paint:</strong></p><ul><li>Paint là tác vụ xử lý lâu nhất</li><li>Box-shadow, large image không tốt cho paint</li><li>Tạo và quản lý layer hợp lý</li></ul></li><li><p><strong>Composite:</strong></p><ul><li>Sử dụng transform và opacity</li><li>Quản lý các layer bằng Chrome DevTools</li></ul></li></ul><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image22-250x203.png" alt=""></p><h2 id="Tung-buoc-toi-uu-hieu-suat-render"><a href="#Tung-buoc-toi-uu-hieu-suat-render" class="headerlink" title="Từng bước tối ưu hiệu suất render"></a>Từng bước tối ưu hiệu suất render</h2><h3 id="Buoc-1-Javascript"><a href="#Buoc-1-Javascript" class="headerlink" title="Bước 1: Javascript"></a>Bước 1: Javascript</h3><h4 id="1-1-Su-dung-requestAnimationFrame-de-thuc-hien-cac-thay-doi-tren-UI"><a href="#1-1-Su-dung-requestAnimationFrame-de-thuc-hien-cac-thay-doi-tren-UI" class="headerlink" title="1.1. Sử dụng requestAnimationFrame để thực hiện các thay đổi trên UI."></a>1.1. Sử dụng requestAnimationFrame để thực hiện các thay đổi trên UI.</h4><p>Khi thực hiện các thay đổi trên UI bằng JavaScript, bạn sẽ muốn thực hiện nó ngay vào lúc bắt đầu của frame, lúc đó browser sẽ có được toàn bộ 16ms để thực hiện các thay đổi (JavaScript ⇒ Style ⇒ Layout ⇒ Paint ⇒ Composite). Để làm được điều này bạn cần dùng hàm requestAnimationFrame. Hàm này có chức năng “hẹn giờ” chạy vào đúng thời điểm của frame tiếp theo.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If run as a requestAnimationFrame callback, this</span></span><br><span class="line"><span class="comment"> * will be run at the start of the frame.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateScreen</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Make visual updates here.</span></span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(updateScreen);</span><br></pre></td></tr></table></figure><p>Một số đoạn code trên mạng hoặc trong các framework thường sử dụng hàm setTimeout, tuy nhiên hàm được gọi bởi setTimeout sẽ không khởi chạy lúc bắt đầu frame, dẫn đến việc không tận dụng hết được khoảng thời gian 16ms, do đó gây ra hiện tượng frame skip, gây giật, lag.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image071-700x300.png" alt=""></p><h4 id="1-2-Chuyen-cac-tac-vu-nang-sang-Web-workers"><a href="#1-2-Chuyen-cac-tac-vu-nang-sang-Web-workers" class="headerlink" title="1.2. Chuyển các tác vụ nặng sang Web workers"></a>1.2. Chuyển các tác vụ nặng sang Web workers</h4><p>Đối với các tác vụ nặng như encode/decode, xử lý dữ liệu lớn… chúng ta nên chuyển tác vụ đó sang <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage" target="_blank" rel="noopener">Web Workers</a>. Web Workers hoạt động trên một thread riêng biệt, sẽ giúp giảm tải cho UI Thread và giúp tiết kiệm được thời gian xử lý.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSortWorker = <span class="keyword">new</span> Worker(<span class="string">"sort-worker.js"</span>);</span><br><span class="line">dataSortWorker.postMesssage(dataToSort);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The main thread is now free to continue working on other things...</span></span><br><span class="line"> </span><br><span class="line">dataSortWorker.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sortedData = evt.data;</span><br><span class="line">  <span class="comment">// Update data on screen...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Tuy nhiên, Web Workers không thể tương tác với DOM tree, do đó một số tác vụ không thể chuyển qua Web Workers được. Trong trường hợp này ta có thể áp dụng phương pháp “micro-task”: chia nhỏ task ra, sau đó sử dụng requestAnimationFrame để cập nhật UI. Lúc này, nếu mỗi task nhỏ có thời gian thực thi bé hơn 16ms thì sẽ tránh được hiện tượng giật, lag như khi chạy cả task lớn.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskList = breakBigTaskIntoMicroTasks(monsterTaskList);</span><br><span class="line">requestAnimationFrame(processTaskList);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processTaskList</span>(<span class="params">taskStartTime</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> taskFinishTime;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">   <span class="comment">// Assume the next task is pushed onto a stack.</span></span><br><span class="line">   <span class="keyword">var</span> nextTask = taskList.pop();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Process nextTask.</span></span><br><span class="line">   processTask(nextTask);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Go again if there’s enough time to do the next task.</span></span><br><span class="line">   taskFinishTime = <span class="built_in">window</span>.performance.now();</span><br><span class="line"> &#125; <span class="keyword">while</span> (taskFinishTime - taskStartTime &lt; <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (taskList.length &gt; <span class="number">0</span>)</span><br><span class="line">   requestAnimationFrame(processTaskList);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Su-dung-Chrome-DevTools-de-“dieu-tra”-JavaScript-execution"><a href="#1-3-Su-dung-Chrome-DevTools-de-“dieu-tra”-JavaScript-execution" class="headerlink" title="1.3. Sử dụng Chrome DevTools để “điều tra” JavaScript execution"></a>1.3. Sử dụng Chrome DevTools để “điều tra” JavaScript execution</h4><p>Chrome DevTools là công cụ cực kỳ hữu ích. Ở tab “Timeline” của Chrome DevTools, bạn có thể kiểm tra được độ mượt của web page bằng cách:</p><ol><li>Nhấn nút Record (hoặc Ctrl + R trên Windows, Command + R trên Mac)</li><li>Thực hiện animation / transition trên trang web chính</li><li><p>Nhấn nút Stop Record.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image24-700x515.png" alt=""></p></li></ol><p>Chrome DevTools sẽ hiển thị toàn bộ các thông tin liên quan đến các tác vụ JavaScript ⇒ Style ⇒ Layout ⇒ Paint ⇒ Composite. Bạn có thể kiếm tra để xem tác vụ nào chiếm nhiều thời gian nhất và gây ra frame skip.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image06.png" alt=""></p><h3 id="Buoc-2-Style-calculation"><a href="#Buoc-2-Style-calculation" class="headerlink" title="Bước 2: Style calculation"></a>Bước 2: Style calculation</h3><p>Cố gắng giữ cho selector của bạn càng đơn giản càng tốt, và giảm số lượng element bị ảnh hưởng bởi selector, ví dụ:</p><p>Nên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123; <span class="comment">/* styles */</span> &#125;</span><br></pre></td></tr></table></figure><p>Không nên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:nth-last-child(-n+1)</span> <span class="selector-class">.title</span> &#123; <span class="comment">/* styles */</span> &#125;</span><br></pre></td></tr></table></figure><p>Không nên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*, *<span class="selector-pseudo">:before</span>, *<span class="selector-pseudo">:after</span> &#123; <span class="comment">/* styles */</span> &#125;</span><br></pre></td></tr></table></figure><p>Nên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="comment">/* styles */</span> &#125;</span><br></pre></td></tr></table></figure><p>Việc sử dụng các selector này cần phải cân bằng giữa việc code gọn gàng đẹp đẽ và hiệu suất. Khi sử dụng các selector phức tạp thì browser cần phải thực hiện nhiều tính toán, nhưng nếu chỉ sử dụng các selector đơn giản thì lại khiến code của chúng ta khó quản lý.</p><p>Giải pháp ở đây là chúng ta nên sử dụng một số kỹ thuật quản lý style như: <a href="https://bem.info/" target="_blank" rel="noopener">BEM (Block, Element, Modifier)</a>, <a href="https://github.com/postcss/postcss" target="_blank" rel="noopener">PostCSS</a>. Các công cụ này sẽ giúp chúng ta vừa dễ quản lý code CSS ở môi trường dev, và cũng vừa đảm bảo hiệu suất ở môi trường production sau khi build.</p><h3 id="Buoc-3-Layout"><a href="#Buoc-3-Layout" class="headerlink" title="Bước 3: Layout"></a>Bước 3: Layout</h3><h4 id="3-1-Han-che-kich-hoat-tinh-toan-layout"><a href="#3-1-Han-che-kich-hoat-tinh-toan-layout" class="headerlink" title="3.1. Hạn chế kích hoạt tính toán layout"></a>3.1. Hạn chế kích hoạt tính toán layout</h4><p>Việc thay đổi một số thuộc tính CSS của element có thể kích hoạt browser tính toán lại layout của element đó.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Changing width and height</span></span><br><span class="line"><span class="comment"> * triggers layout.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-class">.box--expanded</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">350px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Khi một element bị thay đổi layout thì thường là các element khác cũng sẽ bị thay đổi theo (kích thước, vị trí…). Do đó nếu trang của bạn có nhiều element và việc kích hoạt layout diễn ra quá thường xuyên thì hoàn toàn không tốt cho performance.</p><p>Bạn có thể sử dụng Chrome DevTools để kiểm tra xem web page của bạn có bị kích hoạt layout quá nhiều hay không.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image02-700x489.png" alt=""></p><p>Ví dụ trong hình này, bạn có thể thấy sự kiện Layout chiếm tới 20.636ms, vượt qua con số 16ms và tất nhiên là sẽ dẫn đến frame skip, số lượng element cần tính toán lại layout là 1618 (rất nhiều).</p><p>Để biết được những thuộc tính nào sẽ kích hoạt Layout (và lý do vì sao), bạn có thể tra cứu ở trang <a href="http://csstriggers.com/" target="_blank" rel="noopener">http://csstriggers.com/</a> – công cụ do một Googler viết cho mục đích tra cứu.</p><h4 id="3-2-Su-dung-cac-thuoc-tinh-moi-cua-CSS3"><a href="#3-2-Su-dung-cac-thuoc-tinh-moi-cua-CSS3" class="headerlink" title="3.2. Sử dụng các thuộc tính mới của CSS3"></a>3.2. Sử dụng các thuộc tính mới của CSS3</h4><p>CSS3 có cung cấp một số thuộc tính mới không những giúp chúng ta canh chỉnh layout dễ hơn mà còn giúp tăng hiệu suất rất nhiều. Điển hình là Flexbox, việc sử dụng flexbox để canh chỉnh layout sẽ dễ hơn so với cách dùng float truyền thống.</p><p>Xem bài hướng dẫn tuyệt vời về Flexbox: <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">http://css-tricks.com/snippets/css/a-guide-to-flexbox/</a></p><p>Về hiệu suất, dưới đây là 2 hình ảnh đo hiệu suất của việc kích hoạt layout trên 1300 elements.</p><p>Sử dụng Float:</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image16-700x476.png" alt=""></p><p>Sử dụng Flexbox:</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image14-700x454.png" alt=""></p><p>Có thể thấy con số “Self Time” giảm từ <strong>~14ms</strong> chỉ còn <strong>~3.5ms</strong>, đó là một sự thay đổi rất đáng kể.</p><h4 id="3-3-Han-che-kich-hoat-layout-som"><a href="#3-3-Han-che-kich-hoat-layout-som" class="headerlink" title="3.3. Hạn chế kích hoạt layout sớm"></a>3.3. Hạn chế kích hoạt layout sớm</h4><p>Hãy xem xét đoạn code sau: thay đổi kích thước của 3 elements</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> h1 = element1.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write (invalidates layout)</span></span><br><span class="line">element1.style.height = (h1 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Read (triggers layout)</span></span><br><span class="line"><span class="keyword">var</span> h2 = element2.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write (invalidates layout)</span></span><br><span class="line">element2.style.height = (h2 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Read (triggers layout)</span></span><br><span class="line"><span class="keyword">var</span> h3 = element3.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write (invalidates layout)</span></span><br><span class="line">element3.style.height = (h3 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure><p>Khi một element (DOM) được ghi giá trị mới thì layout sẽ bị đánh dấu <strong>giá trị hết hiệu lực</strong> (invalidates) và sẽ được tính toán lại tại một thời điểm nào đó. Để đảm bảo performance, browser sẽ thực hiện tính toán lại layout vào <strong>thời điểm bắt đầu của frame tiếp theo</strong>.</p><p>Tuy nhiên nếu trong thời gian <strong>frame hiện tại chưa kết thúc</strong>, ta muốn lấy giá trị kích thước của element thì lúc này browser buộc phải thực hiện <strong>tính toán layout lại sớm hơn</strong> so với thông thường để có thể trả về kết quả. Hiện tượng này gọi là “forced synchronous layout” – tạm dịch “kích hoạt layout sớm”, và nó gây ra vấn đề về performance khi ta phải thực hiện nhiều tác vụ hơn trong 1 frame.</p><p>Để giải quyết, cách nhanh nhất là chúng ta sẽ “đọc trước, ghi sau”.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> h1 = element1.clientHeight;</span><br><span class="line"><span class="keyword">var</span> h2 = element2.clientHeight;</span><br><span class="line"><span class="keyword">var</span> h3 = element3.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write (invalidates layout)</span></span><br><span class="line">element1.style.height = (h1 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">element2.style.height = (h2 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">element3.style.height = (h3 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Document reflows at end of frame</span></span><br></pre></td></tr></table></figure><p>Hoặc sử dụng requestAnimationFrame để “hẹn giờ” cho cả 3 thao tác ghi vào frame tiếp theo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> h1 = element1.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write</span></span><br><span class="line">requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> element1.style.height = (h1 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> h2 = element2.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write</span></span><br><span class="line">requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> element2.style.height = (h2 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Bằng cách này, cả 3 thao tác ghi đều sẽ được thực hiện một lần trong frame tiếp theo, tốt hơn cho hiệu suất.</p><p>Bạn sẽ thấy rõ tác dụng của việc hạn chế layout sớm trong một số trường hợp thực tế như sau “Layout thrashing”:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Puts the browser into a read-write-read-write cycle.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">  paragraphs[i].style.width = box.offsetWidth + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Như đoạn code trên, layout sẽ liên tục bị trigger và kích hoạt sớm ở trong vòng lặp (read: box.offsetWidth, và write: paragraphs[i].style.width) điều này là thảm họa cho browser</p><p>(hình: dấu chấm than vàng là báo hiệu <strong>forced synchronous layout</strong>).</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image17.png" alt=""></p><p>Nếu đã biết về vấn đề forced synchronous layout, đoạn code trên nên được viết lại như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read.</span></span><br><span class="line"><span class="keyword">var</span> width = box.offsetWidth;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeAllParagraphsToMatchBlockWidth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">   <span class="comment">// Now write.</span></span><br><span class="line">   paragraphs[i].style.width = width + <span class="string">'px'</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nếu cảm thấy việc quản lý layout quá phức tạp, bạn có thể tham khảo sử dụng thư viện <a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">FastDOM</a>, thư viện này giúp bạn quản lý các tác vụ read/write để đảm bảo không gây ra forced synchronous layout.</p><h3 id="Buoc-4-Paint"><a href="#Buoc-4-Paint" class="headerlink" title="Bước 4: Paint"></a>Bước 4: Paint</h3><h4 id="4-1-Dung-Chrome-Developer-Tools-de-phat-hien-van-de-performance-khi-paint"><a href="#4-1-Dung-Chrome-Developer-Tools-de-phat-hien-van-de-performance-khi-paint" class="headerlink" title="4.1. Dùng Chrome Developer Tools để phát hiện vấn đề performance khi paint"></a>4.1. Dùng Chrome Developer Tools để phát hiện vấn đề performance khi paint</h4><p>Bất kỳ sự thay đổi nào trên màn hình browser đều yêu cầu quá trình paint, animation, transition, lúc bôi đen đoạn text hay cả con trỏ nhấp nháy ở textbox.</p><p>Để biết được browser phải vẽ lại những phần nào trên màn hình, bạn có thể bật chức năng “Show paint rectangles” ở tab “Rendering” trong Chrome Developer Tools.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image18.png" alt=""></p><p>Những vùng bị vẽ lại sẽ được tô và hiển thị màu xanh lá cây trên màn hình.</p><p> <img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image21-700x454.png" alt=""></p><p>Bạn có thể xem chi tiết hoạt động vẽ của browser bằng cách kích hoạt chế độ “Paint profiler” ở tab “Timeline” khi record.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image03.png" alt=""></p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image04.png" alt=""></p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image15-700x454.png" alt=""></p><p>Ở chế độ này, bạn có thể kiểm tra <strong>quá trình vẽ của tất cả các element</strong> trong web page. Dựa vào các thông tin này bạn có thể phân tích và đưa ra hướng giải quyết phù hợp nếu quá trình paint mất quá nhiều thời gian. Một số yếu tố khiến quá trình paint diễn ra chậm:</p><ul><li>Các hiệu ứng CSS phức tạp: box-shadow, gradient, curves</li><li>Các element chồng đè lên nhau.</li><li>Các hình ảnh có kích thước quá lớn</li><li>…</li></ul><h4 id="4-2-Su-dung-hop-ly-cac-layer"><a href="#4-2-Su-dung-hop-ly-cac-layer" class="headerlink" title="4.2. Sử dụng hợp lý các layer"></a>4.2. Sử dụng hợp lý các layer</h4><p>Trên thực tế, quá trình vẽ diễn ra song song trên nhiều các layer khác nhau, việc phân chia các layer hợp lý sẽ giúp tiết kiệm được thời gian vẽ rất nhiều.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image27-700x602.png" alt=""></p><p>Ví dụ trong trường hợp này, khi bạn cuộn trang thì browser phải vẽ lại layer trên cùng (text), còn layer hình bên dưới có vị trí cố định, không có gì thay đổi nên không cần phải vẽ lại nữa. Các layer này sẽ được gộp lại (ở bước cuối cùng – composite) và hiển thị lên màn hình.</p><p><strong>Làm sao để tạo layer?</strong></p><p>Vẽ – Paint – là tác vụ nặng nhất, chiếm nhiều thời gian nhất trong các bước, do đó bạn có thể thấy rõ được lợi ích của việc <strong>phân chia các layer làm sao cho browser ít phải vẽ lại nhất</strong>.</p><p>Một layer (compositor layer) sẽ được tạo khi bạn sử dụng thuộc tính will-change (trên Chrome, Opera, Firefox) thuộc tính này báo hiệu cho browser biết element sẽ có sự thay đổi, do đó sẽ đưa element này vào một layer mới.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moving-element</span> &#123; <span class="attribute">will-change</span>: transform; &#125;</span><br></pre></td></tr></table></figure><p>Đối với các browser không hỗ trợ will-change bạn có thể sử dụng thuộc tính 3D transform để “ép buộc” tạo layer mới:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moving-element</span> &#123; <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0); &#125;</span><br></pre></td></tr></table></figure><p>Cần lưu ý, việc tạo layer mới sẽ yêu cầu thêm bộ nhớ và tác vụ để quản lý các layer, do đó bạn không nên tạo quá nhiều layer, và chiến lược tao layer ở đây không cố định mà còn tùy thuộc vào tính chất của các animation, transition có trên website của bạn.</p><p><strong>Không nên:</strong> (layer explosions – tạo ra quá nhiều layer không cần thiết)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123; </span><br><span class="line"> <span class="attribute">will-change</span>: transform;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Buoc-5-Composite"><a href="#Buoc-5-Composite" class="headerlink" title="Bước 5: Composite"></a>Bước 5: Composite</h2><p>Tại bước này, browser sẽ tiến hành gộp các compositor layer đã được vẽ (ở bước 4) và hiển thị lên màn hình.</p><p>Trường hợp lý tưởng nhất cho performance là bỏ qua 2 bước Layout và Paint, công việc của browser chỉ là thay đổi các compositor layer để tạo ra một frame.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image20-700x107.png" alt=""></p><p>Để làm được điều đó, bạn chỉ được thay đổi các thuộc tính mà Compositor có thể xử lý độc lập (mà không cần phải kích hoạt Layout và Paint). Các thuộc tính đó là <strong>transform</strong> và <strong>opacity</strong>.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image12-700x525.png" alt=""></p><p>Tuy nhiên trên thực tế chúng ta cần phải thay đổi nhiều thuộc tính hơn nữa để đáp ứng được yêu cầu khi animate các hiệu ứng. Do đó, giải pháp chính là phải <strong><span class="c0">tạo và quản lý được các layer một cách hợp lý</span></strong>. Để quản lý được các layer, bạn có thể sử dụng công cụ Chrome Developer Tools.</p><p>Trong tab “Timeline” đánh dấu vào mục Paint</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image26.png" alt=""></p><p>Tiến hành record và chọn phần Paint trên kết quả hiển thị</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image08.png" alt=""></p><p>Ở đây bạn sẽ thấy thẻ “Layer” trong phần thông tin của frame</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image001.png" alt=""></p><p>Từ đây bạn có thể tra cứu toàn bộ các frame mà web page đang có.</p><p> <img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image13-700x525.png" alt=""></p><p>Danh sách các layer được liệt kê dưới dạng cây (layer tree), preview dạng 3D, có thông tin về kích thước, bộ nhớ, lý do layer được tạo…</p><h2 id="Tong-ket"><a href="#Tong-ket" class="headerlink" title="Tổng kết"></a>Tổng kết</h2><p>Như vậy là ta đã đi từng bước để có thể tối ưu hiệu suất render cho web page:</p><ul><li><p><strong>JavaScript</strong><br>   – Dùng requestAnimationFrame<br>   – Dùng Web workers, Micro-task cho tác vụ nặng<br>   – Profiling with Chrome DevTools</p></li><li><p><strong>Style</strong><br>   – Giảm độ phức tạp của selector<br>   – Giảm số lượng element bị ảnh hưởng</p></li><li><p><strong>Layout</strong><br>   – Hạn chế kích hoạt layout<br>   – Sử dụng Flexbox<br>   – Hạn chế forced synchronous layout.</p></li><li><p><strong>Paint</strong><br>   – Paint là tác vụ xử lý lâu nhất<br>   – Box-shadow, large image không tốt cho paint<br>   – Tạo và quản lý layer hợp lý</p></li><li><p><strong>Composite</strong><br>   – Sử dụng transform và opacity<br>   – Quản lý các layer bằng Chrome DevTools</p></li></ul><p>Sau khi đã thực hiện những bước trên, web page của bạn sẽ hoạt động mượt mà, trơn tru với 60fps. Chúc bạn thành công!</p><p>60FPS FOR THE WIN!</p><h1 id="Chuyen-ngoai-le"><a href="#Chuyen-ngoai-le" class="headerlink" title="Chuyện ngoài lề"></a>Chuyện ngoài lề</h1><p>Ở Silicon Straits Saigon, chúng tôi có một bài test dành cho Front-end Developer, đó là implement hiệu ứng scrolling sau (ảnh động, load hơi lâu): <a href="https://bit.ly/1CCYx9y" target="_blank" rel="noopener">http://bit.ly/1CCYx9y</a></p><p>Các bạn có thể vận dụng những kiến thức có được trong bài viết này để “thử sức” với hiệu ứng trên.</p><p>Đây là bài làm của tôi, mặc dù không được hoàn hảo nhưng có thể dùng được cho mục đích tham khảo.</p><p>Link: <a href="https://trungdq88.github.io/css-stuffs/delay-scroll/" target="_blank" rel="noopener">http://trungdq88.github.io/css-stuffs/delay-scroll/</a></p><p>Timeline Record:</p><p> <img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image05-700x455.png" alt=""></p><p>Layers (một phần):</p><p> <img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image10-700x299.png" alt=""></p><h2 id="Cac-nguon-tham-khao-trong-bai-viet"><a href="#Cac-nguon-tham-khao-trong-bai-viet" class="headerlink" title="Các nguồn tham khảo trong bài viết:"></a>Các nguồn tham khảo trong bài viết:</h2><p>Một số hình ảnh và code mẫu:</p><ul><li>Google Developer: <a href="https://developers.google.com/web/fundamentals/performance/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/</a></li><li>Preventing Layout Thrashing:<a href="http://wilsonpage.co.uk/preventing-layout-thrashing/" target="_blank" rel="noopener">http://wilsonpage.co.uk/preventing-layout-thrashing/</a></li></ul><p>Các trang web có hiệu ứng đẹp:</p><ul><li><a href="http://world.mathigon.org/" target="_blank" rel="noopener">http://world.mathigon.org/</a></li><li><a href="http://matthew.wagerfield.com/parallax/" target="_blank" rel="noopener">http://matthew.wagerfield.com/parallax/</a></li></ul><p>Khóa học:</p><ul><li>Udacity Course: Browser Rendering Optimization – Building 60 FPS Web Apps: <a href="https://www.udacity.com/course/browser-rendering-optimization--ud860" target="_blank" rel="noopener">https://www.udacity.com/course/browser-rendering-optimization–ud860</a></li></ul><p>Các nguồn khác:</p><ul><li>Web Workers: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage</a></li><li>BEM: <a href="https://bem.info/" target="_blank" rel="noopener">https://bem.info/</a></li><li>PostCSS: <a href="https://github.com/postcss/postcss" target="_blank" rel="noopener">https://github.com/postcss/postcss</a></li><li>CSS Trigger: <a href="http://csstriggers.com/" target="_blank" rel="noopener">http://csstriggers.com/</a></li><li>Guide to Flexbox: <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">http://css-tricks.com/snippets/css/a-guide-to-flexbox/</a></li><li>FastDOM: <a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">https://github.com/wilsonpage/fastdom</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Optimizing Performance&lt;/strong&gt; (tối ưu hóa hiệu suất) cho website là một công việc mà bất kỳ front-end developer nào cũng nên biết, mục đích là để trang web đáp ứng được 3 tiêu chí:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;NHẸ&lt;/strong&gt;: Giảm kích thước trang web và các thành phần đi kèm như javascript, css, hình ảnh… nhằm đảm bảo &lt;strong&gt;thời gian tải xuống ngắn hơn&lt;/strong&gt;. Chúng ta có thể dùng các bộ minify cho javascript, css…, nén các tập tin hình ảnh, font chữ, svg… ngoài ra còn có các kĩ thuật như code splitting, browser caching, HTTP caching…&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NHANH&lt;/strong&gt; &lt;strong&gt;Hiển thị nội dung trang web càng sớm càng tốt&lt;/strong&gt; bằng cách: chia cấu trúc DOM hợp lý, hạn chế blocking CSS/JS, hạn chế chỉnh sửa DOM tree, chia các file ra thành nhiều module, tải resource bất đồng bộ, tối ưu hóa các selector của CSS và JS…&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MƯỢT&lt;/strong&gt;: Sau khi nội dung trang web đã được tải về và hiển thị thì việc tiếp theo là &lt;strong&gt;bảo đảm các hiệu ứng animation, transition, scrolling… phải mượt&lt;/strong&gt;, không bị lag và giật (jank).&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>10 câu hỏi phỏng vấn mà Javascript Developer nên biết</title>
    <link href="http://nthung2112.github.io/2018/06/10-cau-hoi-phong-van-ma-Javascript-Developer-nen-biet.html"/>
    <id>http://nthung2112.github.io/2018/06/10-cau-hoi-phong-van-ma-Javascript-Developer-nen-biet.html</id>
    <published>2018-06-23T15:11:00.000Z</published>
    <updated>2018-06-23T15:28:47.131Z</updated>
    
    <content type="html"><![CDATA[<p>Tại hầu hết các công ty, người quản lý phải tin tưởng các developers, cho họ tham gia các cuộc phỏng vấn kỹ thuật để đánh giá các kỹ năng ứng cử viên. Nếu bạn làm tốt như một ứng cử viên, bạn sẽ cần phải phỏng vấn. Đây là cách làm.</p><a id="more"></a><h3 id="It-Starts-With-People"><a href="#It-Starts-With-People" class="headerlink" title="It Starts With People"></a>It Starts With People</h3><p>In <a href="https://medium.com/javascript-scene/how-to-build-a-high-velocity-development-team-4b2360d34021" target="_blank" rel="noopener">“How to Build a High Velocity Development Team”</a>, Tôi đã nêu một vài điểm đáng để lặp lại:</p><blockquote><p>“Nothing predicts business outcomes better than an exceptional team. If you’re going to beat the odds, you need to invest here, first.”</p></blockquote><p>Như Marcus Lemonis đã nói, cần tập trung vào 3 P’s:</p><hr><blockquote><p>“People, Process, Product”</p></blockquote><hr><div class="video-container"><iframe src="//www.youtube.com/embed/37rMZSA6oLk" frameborder="0" allowfullscreen></iframe></div><p>Your early hires should be very strong, senior-level candidates. People who can hire and mentor other developers, and help the mid-level and junior developers you’ll eventually want to hire down the road.</p><p>Read <a href="https://medium.com/javascript-scene/why-hiring-is-so-hard-in-tech-c462c3230017" target="_blank" rel="noopener">“Why Hiring is So Hard in Tech”</a> for a good breakdown of the general do’s and don’ts of candidate evaluation.</p><hr><blockquote><p>The best way to evaluate a candidate is a pair programming exercise.</p></blockquote><hr><p>Pair program with the candidate. Let the candidate drive. Watch and listen more than you talk. A good project might be to pull tweets from the Twitter API and display them on a timeline.</p><p>That said, no single exercise will tell you everything you need to know. An interview can be a very useful tool as well, but don’t waste time asking about syntax or language quirks. You need to see the big picture. Ask about architecture and paradigms — the big decisions that can have a major impact on the whole project.</p><p>Syntax and features are easy to Google. It’s much harder to Google for software engineering wisdom or the common paradigms and idioms JavaScript developers pick up with experience.</p><p>JavaScript is special, and it plays a critical role in almost every large application. What is it about JavaScript that makes it meaningfully different from other languages?</p><p>Here are some questions that will help you explore the stuff that really matters:</p><h4 id="1-Can-you-name-two-programming-paradigms-important-for-JavaScript-app-developers"><a href="#1-Can-you-name-two-programming-paradigms-important-for-JavaScript-app-developers" class="headerlink" title="1. Can you name two programming paradigms important for JavaScript app developers?"></a>1. Can you name two programming paradigms important for JavaScript app developers?</h4><p>JavaScript is a multi-paradigm language, supporting <strong>imperative/procedural</strong> programming along with <strong>OOP</strong> (Object-Oriented Programming) and <strong>functional programming</strong>. JavaScript supports OOP with <strong>prototypal inheritance</strong>.</p><p><strong>Good to hear:</strong></p><ul><li>Prototypal inheritance (also: prototypes, OLOO).</li><li>Functional programming (also: closures, first class functions, lambdas).</li></ul><p><strong>Red flags:</strong></p><ul><li>No clue what a paradigm is, no mention of prototypal oo or functional programming.</li></ul><h4 id="2-What-is-functional-programming"><a href="#2-What-is-functional-programming" class="headerlink" title="2. What is functional programming?"></a>2. What is functional programming?</h4><p>Functional programming produces programs by composing mathematical functions and avoids shared state &amp; mutable data. Lisp (specified in 1958) was among the first languages to support functional programming, and was heavily inspired by lambda calculus. Lisp and many Lisp family languages are still in common use today.</p><p>Functional programming is an essential concept in JavaScript (one of the two pillars of JavaScript). Several common functional utilities were added to JavaScript in ES5.</p><p><strong>Good to hear:</strong></p><ul><li>Pure functions / function purity.</li><li>Avoid side-effects.</li><li>Simple function composition.</li><li>Examples of functional languages: Lisp, ML, Haskell, Erlang, Clojure, Elm, F Sharp, OCaml, etc…</li><li>Mention of features that support FP: first-class functions, higher order functions, functions as arguments/values.</li></ul><p><strong>Red flags:</strong></p><ul><li>No mention of pure functions / avoiding side-effects.</li><li>Unable to provide examples of functional programming languages.</li><li>Unable to identify the features of JavaScript that enable FP.</li></ul><h4 id="3-What-is-the-difference-between-classical-inheritance-and-prototypal-inheritance"><a href="#3-What-is-the-difference-between-classical-inheritance-and-prototypal-inheritance" class="headerlink" title="3. What is the difference between classical inheritance and prototypal inheritance?"></a>3. What is the difference between classical inheritance and prototypal inheritance?</h4><p><strong>Class Inheritance:</strong> instances inherit from classes (like a blueprint — a description of the class), and create sub-class relationships: hierarchical class taxonomies. Instances are typically instantiated via constructor functions with the <em><code>new</code></em> keyword. Class inheritance may or may not use the <em><code>class</code></em> keyword from ES6.</p><p><strong>Prototypal Inheritance:</strong> instances inherit directly from other objects. Instances are typically instantiated via factory functions or <em><code>Object.create()</code>.</em> Instances may be composed from many different objects, allowing for easy selective inheritance.</p><hr><blockquote><p>In JavaScript, prototypal inheritance is simpler &amp;<br>more flexible than class inheritance.</p></blockquote><hr><p><strong>Good to hear:</strong></p><ul><li>Classes: create tight coupling or hierarchies/taxonomies.</li><li>Prototypes: mentions of concatenative inheritance, prototype delegation, functional inheritance, object composition.</li></ul><p><strong>Red Flags:</strong></p><ul><li>No preference for prototypal inheritance &amp; composition over class inheritance.</li></ul><h4 id="4-What-are-the-pros-and-cons-of-functional-programming-vs-object-oriented-programming"><a href="#4-What-are-the-pros-and-cons-of-functional-programming-vs-object-oriented-programming" class="headerlink" title="4. What are the pros and cons of functional programming vs object-oriented programming?"></a>4. What are the pros and cons of functional programming vs object-oriented programming?</h4><p><strong>OOP Pros:</strong> It’s easy to understand the basic concept of objects and easy to interpret the meaning of method calls. OOP tends to use an imperative style rather than a declarative style, which reads like a straight-forward set of instructions for the computer to follow.</p><p><strong>OOP Cons:</strong> OOP Typically depends on shared state. Objects and behaviors are typically tacked together on the same entity, which may be accessed at random by any number of functions with non-deterministic order, which may lead to undesirable behavior such as race conditions.</p><p><strong>FP Pros:</strong> Using the functional paradigm, programmers avoid any shared state or side-effects, which eliminates bugs caused by multiple functions competing for the same resources. With features such as the availability of point-free style (aka tacit programming), functions tend to be radically simplified and easily recomposed for more generally reusable code compared to OOP.</p><p>FP also tends to favor declarative and denotational styles, which do not spell out step-by-step instructions for operations, but instead concentrate on <strong>what</strong> to do, letting the underlying functions take care of the <strong>how</strong>. This leaves tremendous latitude for refactoring and performance optimization, even allowing you to replace entire algorithms with more efficient ones with very little code change. (e.g., memoize, or use lazy evaluation in place of eager evaluation.)</p><p>Computation that makes use of pure functions is also easy to scale across multiple processors, or across distributed computing clusters without fear of threading resource conflicts, race conditions, etc…</p><p><strong>FP Cons:</strong> Over exploitation of FP features such as point-free style and large compositions can potentially reduce readability because the resulting code is often more abstractly specified, more terse, and less concrete.</p><p>More people are familiar with _OO_ and imperative programming than functional programming, so even common idioms in functional programming can be confusing to new team members.</p><p>FP has a much steeper learning curve than OOP because the broad popularity of OOP has allowed the language and learning materials of OOP to become more conversational, whereas the language of FP tends to be much more academic and formal. FP concepts are frequently written about using idioms and notations from lambda calculus, algebras, and category theory, all of which requires a prior knowledge foundation in those domains to be understood.</p><p><strong>Good to hear:</strong></p><ul><li>Mentions of trouble with shared state, different things competing for the same resources, etc…</li><li>Awareness of FP’s capability to radically simplify many applications.</li><li>Awareness of the differences in learning curves.</li><li>Articulation of side-effects and how they impact program maintainability.</li><li>Awareness that a highly functional codebase can have a steep learning curve.</li><li>Awareness that a highly OOP codebase can be extremely resistant to change and very brittle compared to an equivalent FP codebase.</li><li>Awareness that immutability gives rise to an extremely accessible and malleable program state history, allowing for the easy addition of features like infinite undo/redo, rewind/replay, time-travel debugging, and so on. Immutability can be achieved in either paradigm, but a proliferation of shared stateful objects complicates the implementation in OOP.</li></ul><p><strong>Red flags:</strong></p><ul><li>Unable to list disadvantages of one style or another — Anybody experienced with either style should have bumped up against some of the limitations.</li></ul><p><strong>Learn More:</strong></p><ul><li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 1</a> — Prototypal OO.</li><li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 2</a> — Functional Programming.</li></ul><h4 id="5-When-is-classical-inheritance-an-appropriate-choice"><a href="#5-When-is-classical-inheritance-an-appropriate-choice" class="headerlink" title="5. When is classical inheritance an appropriate choice?"></a>5. When is classical inheritance an appropriate choice?</h4><p>The answer is never, or almost never. Certainly never more than one level. Multi-level class hierarchies are an anti-pattern. I’ve been issuing this challenge for years, and the only answers I’ve ever heard fall into one of several <a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a" target="_blank" rel="noopener">common misconceptions</a>. More frequently, the challenge is met with silence.</p><blockquote><p>“If a feature is sometimes useful<br>and sometimes dangerous<br>and if there is a better option<br>then <strong>always use the better option</strong>.”<br>~ Douglas Crockford</p></blockquote><p><strong>Good to hear:</strong></p><ul><li>Rarely, almost never, or never.</li><li>A single level is sometimes OK, from a framework base-class such as React.Component.</li><li>“Favor object composition over class inheritance.”</li></ul><h4 id="6-When-is-prototypal-inheritance-an-appropriate-choice"><a href="#6-When-is-prototypal-inheritance-an-appropriate-choice" class="headerlink" title="6. When is prototypal inheritance an appropriate choice?"></a>6. When is prototypal inheritance an appropriate choice?</h4><p>There is more than one type of prototypal inheritance:</p><ul><li><strong>Delegation</strong> (i.e., the prototype chain).</li><li><strong>Concatenative</strong> (i.e. mixins, <em><code>Object.assign()</code></em>).</li><li><strong>Functional</strong> (Not to be confused with functional programming. A function used to create a closure for private state/encapsulation).</li></ul><p>Each type of prototypal inheritance has its own set of use-cases, but all of them are equally useful in their ability to enable <strong>composition,</strong> which creates <strong>has-a</strong> or <strong>uses-a</strong> or <strong>can-do</strong> relationships as opposed to the <strong>is-a</strong> relationship created with class inheritance.</p><p><strong>Good to hear</strong>:</p><ul><li>In situations where modules or functional programming don’t provide an obvious solution.</li><li>When you need to compose objects from multiple sources.</li><li>Any time you need inheritance.</li></ul><p><strong>Red flags:</strong></p><ul><li>No knowledge of when to use prototypes.</li><li>No awareness of mixins or <em><code>Object.assign()</code>.</em></li></ul><h4 id="7-What-does-“favor-object-composition-over-class-inheritance”-mean"><a href="#7-What-does-“favor-object-composition-over-class-inheritance”-mean" class="headerlink" title="7. What does “favor object composition over class inheritance” mean?"></a>7. What does “favor object composition over class inheritance” mean?</h4><p>This is a quote from <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="noopener">“Design Patterns: Elements of Reusable Object-Oriented Software”</a>. It means that code reuse should be achieved by assembling smaller units of functionality into new objects instead of inheriting from classes and creating object taxonomies.</p><p>In other words, use <strong>can-do, has-a,</strong> or <strong>uses-a</strong> relationships instead of <strong>is-a</strong> relationships.</p><p><strong>Good to hear:</strong></p><ul><li>Avoid class hierarchies.</li><li>Avoid brittle base class problem.</li><li>Avoid tight coupling.</li><li>Avoid rigid taxonomy (forced is-a relationships that are eventually wrong for new use cases).</li><li>Avoid the gorilla banana problem (“what you wanted was a banana, what you got was a gorilla holding the banana, and the entire jungle”).</li><li>Make code more flexible.</li></ul><p><strong>Red Flags:</strong></p><ul><li>Fail to mention any of the problems above.</li><li>Fail to articulate the difference between composition and class inheritance, or the advantages of composition.</li></ul><h4 id="8-What-are-two-way-data-binding-and-one-way-data-flow-and-how-are-they-different"><a href="#8-What-are-two-way-data-binding-and-one-way-data-flow-and-how-are-they-different" class="headerlink" title="8. What are two-way data binding and one-way data flow, and how are they different?"></a>8. What are two-way data binding and one-way data flow, and how are they different?</h4><p>Two way data binding means that UI fields are bound to model data dynamically such that when a UI field changes, the model data changes with it and vice-versa.</p><p>One way data flow means that the model is the single source of truth. Changes in the UI trigger messages that signal user intent to the model (or “store” in React). Only the model has the access to change the app’s state. The effect is that data always flows in a single direction, which makes it easier to understand.</p><p>One way data flows are deterministic, whereas two-way binding can cause side-effects which are harder to follow and understand.</p><p><strong>Good to hear:</strong></p><ul><li>React is the new canonical example of one-way data flow, so mentions of React are a good signal. Cycle.js is another popular implementation of uni-directional data flow.</li><li>Angular is a popular framework which uses two-way binding.</li></ul><p><strong>Red flags:</strong></p><ul><li>No understanding of what either one means. Unable to articulate the difference.</li></ul><h4 id="9-What-are-the-pros-and-cons-of-monolithic-vs-microservice-architectures"><a href="#9-What-are-the-pros-and-cons-of-monolithic-vs-microservice-architectures" class="headerlink" title="9. What are the pros and cons of monolithic vs microservice architectures?"></a>9. What are the pros and cons of monolithic vs microservice architectures?</h4><p>A monolithic architecture means that your app is written as one cohesive unit of code whose components are designed to work together, sharing the same memory space and resources.</p><p>A microservice architecture means that your app is made up of lots of smaller, independent applications capable of running in their own memory space and scaling independently from each other across potentially many separate machines.</p><p><strong>Monolithic Pros:</strong> The major advantage of the monolithic architecture is that most apps typically have a large number of cross-cutting concerns, such as logging, rate limiting, and security features such audit trails and DOS protection.</p><p>When everything is running through the same app, it’s easy to hook up components to those cross-cutting concerns.</p><p>There can also be performance advantages, since shared-memory access is faster than inter-process communication (IPC).</p><p><strong>Monolithic cons:</strong> Monolithic app services tend to get tightly coupled and entangled as the application evolves, making it difficult to isolate services for purposes such as independent scaling or code maintainability.</p><p>Monolithic architectures are also much harder to understand, because there may be dependencies, side-effects, and magic which are not obvious when you’re looking at a particular service or controller.</p><p><strong>Microservice pros:</strong> Microservice architectures are typically better organized, since each microservice has a very specific job, and is not concerned with the jobs of other components. Decoupled services are also easier to recompose and reconfigure to serve the purposes of different apps (for example, serving both the web clients and public API).</p><p>They can also have performance advantages depending on how they’re organized because it’s possible to isolate hot services and scale them independent of the rest of the app.</p><p><strong>Microservice cons:</strong> As you’re building a new microservice architecture, you’re likely to discover lots of cross-cutting concerns that you did not anticipate at design time. A monolithic app could establish shared magic helpers or middleware to handle such cross-cutting concerns without much effort.</p><p>In a microservice architecture, you’ll either need to incur the overhead of separate modules for each cross-cutting concern, or encapsulate cross-cutting concerns in another service layer that all traffic gets routed through.</p><p>Eventually, even monolthic architectures tend to route traffic through an outer service layer for cross-cutting concerns, but with a monolithic architecture, it’s possible to delay the cost of that work until the project is much more mature.</p><p>Microservices are frequently deployed on their own virtual machines or containers, causing a proliferation of VM wrangling work. These tasks are frequently automated with container fleet management tools.</p><p><strong>Good to hear:</strong></p><ul><li>Positive attitudes toward microservices, despite the higher initial cost vs monolthic apps. Aware that microservices tend to perform and scale better in the long run.</li><li>Practical about microservices vs monolithic apps. Structure the app so that services are independent from each other at the code level, but easy to bundle together as a monolithic app in the beginning. Microservice overhead costs can be delayed until it becomes more practical to pay the price.</li></ul><p><strong>Red flags:</strong></p><ul><li>Unaware of the differences between monolithic and microservice architectures.</li><li>Unaware or impractical about the additional overhead of microservices.</li><li>Unaware of the additional performance overhead caused by IPC and network communication for microservices.</li><li>Too negative about the drawbacks of microservices. Unable to articulate ways in which to decouple monolithic apps such that they’re easy to split into microservices when the time comes.</li><li>Underestimates the advantage of independently scalable microservices.</li></ul><h4 id="10-What-is-asynchronous-programming-and-why-is-it-important-in-JavaScript"><a href="#10-What-is-asynchronous-programming-and-why-is-it-important-in-JavaScript" class="headerlink" title="10. What is asynchronous programming, and why is it important in JavaScript?"></a>10. What is asynchronous programming, and why is it important in JavaScript?</h4><p>Synchronous programming means that, barring conditionals and function calls, code is executed sequentially from top-to-bottom, blocking on long-running tasks such as network requests and disk I/O.</p><p>Asynchronous programming means that the engine runs in an event loop. When a blocking operation is needed, the request is started, and the code keeps running without blocking for the result. When the response is ready, an interrupt is fired, which causes an event handler to be run, where the control flow continues. In this way, a single program thread can handle many concurrent operations.</p><p>User interfaces are asynchronous by nature, and spend most of their time waiting for user input to interrupt the event loop and trigger event handlers.</p><p>Node is asynchronous by default, meaning that the server works in much the same way, waiting in a loop for a network request, and accepting more incoming requests while the first one is being handled.</p><p>This is important in JavaScript, because it is a very natural fit for user interface code, and very beneficial to performance on the server.</p><p><strong>Good to hear:</strong></p><ul><li>An understanding of what blocking means, and the performance implications.</li><li>An understanding of event handling, and why its important for UI code.</li></ul><p><strong>Red flags:</strong></p><ul><li>Unfamiliar with the terms asynchronous or synchronous.</li><li>Unable to articulate performance implications or the relationship between asynchronous code and UI code.</li></ul><hr><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Stick to high-level topics. If they can answer these questions, that typically means that they have enough programming experience to pick up language quirks &amp; syntax in a few weeks, even if they don’t have a lot of JavaScript experience.</p><p>Don’t disqualify candidates based on stuff that’s easy to learn (including classic CS-101 algorithms, or any type of puzzle problem).</p><p>What you really need to know is, “does this candidate understand how to put an application together?”</p><p>That’s it for the spoken interview.</p><p>In real interviews, I place a much stronger emphasis on coding challenges and <strong><em>watching candidates code.</em></strong> Those topics are covered in depth in my <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" target="_blank" rel="noopener">“Master the JavaScript Interview”</a> series.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tại hầu hết các công ty, người quản lý phải tin tưởng các developers, cho họ tham gia các cuộc phỏng vấn kỹ thuật để đánh giá các kỹ năng ứng cử viên. Nếu bạn làm tốt như một ứng cử viên, bạn sẽ cần phải phỏng vấn. Đây là cách làm.&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Local Storage, Session Storage và Cookie</title>
    <link href="http://nthung2112.github.io/2018/06/Local-Storage-Session-Storage-va-Cookie.html"/>
    <id>http://nthung2112.github.io/2018/06/Local-Storage-Session-Storage-va-Cookie.html</id>
    <published>2018-06-23T11:40:00.000Z</published>
    <updated>2018-06-23T11:45:41.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Su-khac-nhau-va-cach-su-dung-Local-Storage-Session-Storage-va-Cookie"><a href="#Su-khac-nhau-va-cach-su-dung-Local-Storage-Session-Storage-va-Cookie" class="headerlink" title="Sự khác nhau và cách sử dụng Local Storage, Session Storage và Cookie"></a>Sự khác nhau và cách sử dụng Local Storage, Session Storage và Cookie</h1><p>Bạn bị lẫn lộn giữa <strong>session storage</strong>, <strong>local storage</strong> và <strong>cookies</strong>? Bài viết dưới đây sẽ giúp bạn hiểu rõ được sự khác nhau giữa 3 cách lưu trữ này. Các kiểu không gian lưu trữ khác nhau có sẵn cho các dữ liệu có thể trên máy chủ hoặc máy khách, cho phép chúng ta chọn lựa theo nhu cầu.<br><a id="more"></a></p><h2 id="1-Local-storage"><a href="#1-Local-storage" class="headerlink" title="1. Local storage"></a>1. Local storage</h2><h3 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu:"></a>Giới thiệu:</h3><ul><li>Khả năng lưu trữ vô thời hạn: Có nghĩa là chỉ bị xóa bằng JavaScript, hoặc xóa bộ nhớ trình duyệt, hoặc xóa bằng localStorage API.</li><li>Lưu trữ được 5MB: Local Storage cho phép bạn lưu trữ thông tin tương đối lớn lên đến 5MB, lưu được lượng thông tin lớn nhất trong 3 loại.</li><li>Không gửi thông tin lên server như Cookie nên bảo mật tốt hơn.</li></ul><h3 id="Trinh-duyet-ho-tro"><a href="#Trinh-duyet-ho-tro" class="headerlink" title="Trình duyệt hỗ trợ:"></a>Trình duyệt hỗ trợ:</h3><table><thead><tr><th>Trình duyệt</th><th>Phiên bản</th></tr></thead><tbody><tr><td>Chrome</td><td>&gt;= 4.0</td></tr><tr><td>Internet Explorer / Edge</td><td>&gt;= 8.0</td></tr><tr><td>Firefox</td><td>&gt;= 3.5</td></tr><tr><td>Safari</td><td>&gt;= 4.0</td></tr><tr><td>Chrome</td><td>&gt;= 11.5</td></tr></tbody></table><p>Để kiểm tra xem trình duyệt có hỗ trợ localStorage hay không thì chúng ta dùng typeof như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(Storage) !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="comment">//Nếu có hỗ trợ</span></span><br><span class="line">    <span class="comment">//Thực hiện thao tác với Storage</span></span><br><span class="line">    alert(<span class="string">'Trình duyệt của bạn hỗ trợ Storage'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//Nếu không hỗ trợ</span></span><br><span class="line">    alert(<span class="string">'Trình duyệt của bạn không hỗ trợ Storage'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Xem-localStorage-bang-trinh-duyet"><a href="#Xem-localStorage-bang-trinh-duyet" class="headerlink" title="Xem localStorage bằng trình duyệt"></a>Xem localStorage bằng trình duyệt</h3><p>Để xem localstorage bằng trình duyệt các bạn vào trang web cần xem (ở đây mình ví dụ với trang web <a href="http://book.framgia.vn/" target="_blank" rel="noopener">http://book.framgia.vn/</a>) và sau đó các bạn ấn F12 (hoặc Ctrl + shift + i) sau đó làm theo như hình sau:</p><p><img src="https://images.viblo.asia/9bcca9a7-81d0-46af-86de-6a461f67db95.png" alt=""></p><p>Chọn tab Application, di chuyển đến Storage để thấy các Storage của trình duyệt. Để xem các local Storage đang được lưu trữ, mở rộng phần Local Storage như hình. Ở đây ta có thể thấy có 2 biến Local Storage đang được lưu là <em>pusherTransportEncrypted</em> và <em>lang</em> với giá trị của 2 biến được hiển thị bên cạnh (cột Value). Như vậy, cột Key chính là danh sách các biến local Storage đang được lưu và cột Value là các giá trị tương ứng. Để xóa hết các giá trị local Storage này đi, bạn có thể chọn biểu tượng cấm (Clear All) hoặc chọn bên cạnh là biểu tượng dấu X (Delete Selected).</p><h3 id="Su-dung"><a href="#Su-dung" class="headerlink" title="Sử dụng"></a>Sử dụng</h3><ul><li>Khởi tạo localStorage</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br><span class="line"><span class="comment">// hoặc</span></span><br><span class="line">localStorage.key = <span class="string">'value'</span>;</span><br><span class="line"><span class="comment">// hoặc</span></span><br><span class="line">localStorage[<span class="string">'key'</span>] = <span class="string">'value'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Trong đó: key là tên biến, value là giá trị của biến muốn gán vào.</p></blockquote><ul><li>Để lấy giá trị localStorage và sử dụng, ta dùng getItem</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localStorage.getItem(<span class="string">'key'</span>);</span><br><span class="line"><span class="comment">// hoặc</span></span><br><span class="line">localStorage.key;</span><br></pre></td></tr></table></figure><p><strong>Ví dụ</strong> cụ thể như sau:</p><p><img src="https://images.viblo.asia/42ea1e74-930e-4457-b8a2-125036df89dc.png" alt=""></p><ul><li>Để lấy số lượng localStorage đã có trong trình duyệt, sử dụng length như sau:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.length;</span><br></pre></td></tr></table></figure><p>Ví dụ</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(Storage) !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="comment">//Nếu hỗ trợ</span></span><br><span class="line">    <span class="keyword">var</span> data = localStorage.length;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Nếu không hỗ trợ</span></span><br><span class="line">    alert(<span class="string">'Trình duyệt của bạn không hỗ trợ'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Để xóa 1 biến trong localStorage, sử dụng removeItem(tên_key)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.removeItem(key);</span><br></pre></td></tr></table></figure><p>Hoặc xóa tất cả các biến trong localStorage, sử dụng clear</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure><h2 id="2-Session-Storage"><a href="#2-Session-Storage" class="headerlink" title="2. Session Storage"></a>2. Session Storage</h2><h3 id="Gioi-thieu-1"><a href="#Gioi-thieu-1" class="headerlink" title="Giới thiệu:"></a>Giới thiệu:</h3><ul><li>Lưu trên Client: Cũng giống như localStorage thì sessionStorage cũng dùng để lưu trữ dữ liệu trên trình duyệt của khách truy cập (client).</li><li>Mất dữ liệu khi đóng tab: Dữ liệu của sessionStorage sẽ mất khi bạn đóng trình duyệt.</li><li>Dữ liệu không được gửi lên Server</li><li>Thông tin lưu trữ nhiều hơn cookie (ít nhất 5MB)</li></ul><h3 id="Trinh-duyet-ho-tro-1"><a href="#Trinh-duyet-ho-tro-1" class="headerlink" title="Trình duyệt hỗ trợ"></a>Trình duyệt hỗ trợ</h3><table><thead><tr><th>Trình duyệt</th><th>Phiên bản</th></tr></thead><tbody><tr><td>Chrome</td><td>&gt;= 5.0</td></tr><tr><td>Internet Explorer / Edge</td><td>&gt;= 8.0</td></tr><tr><td>Firefox</td><td>&gt;= 2</td></tr><tr><td>Safari</td><td>&gt;= 4.0</td></tr><tr><td>Opera</td><td>&gt;= 10.5</td></tr></tbody></table><p>Vì sessionStorage cũng nằm trong gói Storage nên các bạn cũng có thể sử dụng lại đoạn code kiểm tra trình duyệt có hỗ trợ Storage hay không ở phía trên.</p><h3 id="Xem-Session-Storage-bang-trinh-duyet"><a href="#Xem-Session-Storage-bang-trinh-duyet" class="headerlink" title="Xem Session Storage bằng trình duyệt"></a>Xem Session Storage bằng trình duyệt</h3><p>Tương tự như localStorage, có thể chọn mở rộng mục Session Storage để xem các giá trị được lưu trữ.</p><h3 id="Su-dung-1"><a href="#Su-dung-1" class="headerlink" title="Sử dụng"></a>Sử dụng</h3><p>sessionStorage cũng có cú pháp và cách sử dụn các thuộc tính, phương thức như localStorage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span>(Storage) !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="comment">// Khởi tạo sesionStorage</span></span><br><span class="line">    sessionStorage.setItem(<span class="string">'name'</span>, <span class="string">'Ted Mosby'</span>);</span><br><span class="line">    <span class="comment">// get sessionStorage</span></span><br><span class="line">    sessionStorage.getItem(<span class="string">'name'</span>);</span><br><span class="line">    <span class="comment">// lấy ra số lượng session đã lưu trữ</span></span><br><span class="line">    sessionStorage.length;</span><br><span class="line">    <span class="comment">// xóa 1 item localStorage</span></span><br><span class="line">    sessionStorage.removeItem(<span class="string">'name'</span>);</span><br><span class="line">    <span class="comment">// xóa tất cả item trong sessionStorage</span></span><br><span class="line">    sessionStorage.clear();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'Trình duyệt của bạn không hỗ trợ!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3. Cookie"></a>3. Cookie</h2><h3 id="Gioi-thieu-2"><a href="#Gioi-thieu-2" class="headerlink" title="Giới thiệu:"></a>Giới thiệu:</h3><ul><li>Thông tin được gửi lên server: Cookie sẽ được truyền từ server tới browser và được lưu trữ trên máy tính của bạn khi bạn truy cập vào ứng dụng, mỗi khi người dùng tải ứng dụng, trình duyệt sẽ gửi cookie để thông báo cho ứng dụng về hoạt động trước đó của bạn. Vì vậy đừng bao giờ lưu trữ những thông tin quan trọng, yêu cầu tính bảo mật cao vào cookie vì nó hoàn toàn có thể bị sửa đổi và đánh cắp, thấp chí có thể lợi dụng điều này để tấn công website của bạn.</li><li>Cookie chủ yếu là để đọc phía máy chủ (cũng có thể được đọc ở phía máy khách), localStorage và sessionStorage chỉ có thể được đọc ở phía máy khách.</li><li>Có thời gian sống: Mỗi cookie thường có khoảng thời gian timeout nhất định do lập trình viên xác định trước.</li><li>Lưu trữ: cho phép lưu trữ tối đa 4KB và vài chục cookie cho một domain.</li></ul><h3 id="Xem-cookie-bang-trinh-duyet"><a href="#Xem-cookie-bang-trinh-duyet" class="headerlink" title="Xem cookie bằng trình duyệt"></a>Xem cookie bằng trình duyệt</h3><p>Tương tự như localStorage, có thể chọn mở rộng mục Cookies để xem các giá trị cookie được lưu trữ</p><p><img src="https://images.viblo.asia/94606099-1b52-4377-b354-69dd4cc0fa5e.png" alt=""></p><h3 id="Su-dung-2"><a href="#Su-dung-2" class="headerlink" title="Sử dụng"></a>Sử dụng</h3><p>Cookie có thể được tạo bằng nhiều cách, bài viết này sẽ trình bày về sử dụng cookie trong javascript. JavaScript có thể tạo, đọc, và xóa cookies với document.cookie.</p><ul><li>Tạo cookie: Javascript có thể tạo cookie như sau:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=Ted Mosby'</span>;</span><br></pre></td></tr></table></figure><p>Chúng ta cũng có thể thêm vào ngày hết hạn cho cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=Ted Mosby; expires=Thu, 18 Dec 2018 8:00:00 UTC'</span>;</span><br></pre></td></tr></table></figure><p>Hoặc đặt hẹn giờ sau bao lâu cookie sẽ hết hạn với max-age (tính bằng giây)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=Ted Mosby; max-age=9000'</span>;</span><br></pre></td></tr></table></figure><ul><li>Đọc cookie:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure><p>document.cookie sẽ trả lại tất cả cookie trong một chuỗi tring kiểu như: cookie1 = giá trị; cookie2 = giá trị; cookie3 = giá trị;</p><p>Hoặc để lấy giá trị của 1 cookie, có thể viết một hàm như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">cname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = cname + <span class="string">'='</span>;</span><br><span class="line">    <span class="keyword">var</span> decodedCookie = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line">    <span class="keyword">var</span> ca = decodedCookie.split(<span class="string">';'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;ca.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = ca[i];</span><br><span class="line">        <span class="keyword">while</span> (c.charAt(<span class="number">0</span>) == <span class="string">' '</span>) &#123;</span><br><span class="line">            c = c.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c.indexOf(name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> c.substring(name.length, c.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tham số truyền vào là cname - tên cookie muốn lấy giá trị.</p></blockquote><blockquote><p>Tạo một biến name và thêm vào “=” để tìm kiếm trong chuỗi document.cookie</p></blockquote><blockquote><p>Chia document.cookie dựa trên dấu ; thành một mảng nhiều phần tử và gán mảng đấy cho biến ca</p></blockquote><blockquote><p>Vòng lặp (i=0; i&lt;ca.length; i++) để đọc mỗi giá trị c = ca[i]</p></blockquote><blockquote><p>Nếu cookie được tìm thấy (c.indexOf(name)==0), trả về giá trị của cookie (c.substring(name.length,c.length). Nếu cookie không được tìm thấy, trả về ‘’</p></blockquote><p>Ví dụ muốn lấy giá trị của cookie tên là language thì ta có thể gọi getcookie(‘language’) và kêt quả trả về là giá trị của cookie có tên đó.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = getCookie(<span class="string">'language'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lang);</span><br></pre></td></tr></table></figure><p>Kết quả:</p><p><img src="https://images.viblo.asia/de11cb91-6bf0-47a2-840f-2ba067b391cb.png" alt=""></p><ul><li>Thay đổi giá trị cookie: Trong javascript, bạn có thể thay đổi một cookie giống như cách mà bạn tạo ra cookie, tức là ghi đè giá trị mới lên cookie đã có:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"username=Barney Stinson; expires=Wed, 26 Dec 2018 8:00:00 UTC"</span>;</span><br></pre></td></tr></table></figure><ul><li>Kiểm tra cookie: Để kiểm tra coookie, có thể xây dựng hàm như sau:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCookie</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username = getCookie(<span class="string">'username'</span>);</span><br><span class="line">    <span class="keyword">if</span> (username != <span class="string">''</span>) &#123;</span><br><span class="line">        alert(<span class="string">'Welcome again '</span> + username);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        username = prompt(<span class="string">'Please enter your name: '</span>,  <span class="string">''</span>);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="string">''</span> &amp;&amp; username != <span class="literal">null</span>) &#123;</span><br><span class="line">            setCookie(<span class="string">'username'</span>, username, <span class="number">365</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Nếu cookie được thiết lập, nó sẽ hiển thị một lời chào</p></blockquote><blockquote><p>Nếu cookie không được thiết lập, nó sẽ hiển thị một prompt box, hỏi tên của người dùng, lưu trữ tên của người dùng ở cookie trong 365 ngày, bằng việc gọi function setCookie đã được viết ở trên</p></blockquote><ul><li>Xóa cookie: Để xóa một cookie chỉ cần xét lại giá trị ngày hết hạn expires về một thời điểm đã qua</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=; expires=Thu, 01 Jan 1970 00:00:00 UTC'</span>;</span><br></pre></td></tr></table></figure><p>Tham khảo tại <a href="https://www.w3schools.com/js/js_cookies.asp" target="_blank" rel="noopener">https://www.w3schools.com/js/js_cookies.asp</a></p><h3 id="4-Thong-tin-them"><a href="#4-Thong-tin-them" class="headerlink" title="4. Thông tin thêm"></a>4. Thông tin thêm</h3><ul><li>Vì localStorage và sessionStorage được lưu trữ trên trình duyệt của người dùng, nên các bạn cần phải xem xét nội dung lưu trữ có liên quan đến vấn đề bảo mật hay không.</li><li>Và cũng chính vì localStorage và sessionStorage được lưu trữ trên trình duyệt nên việc sử dụng nó sẽ không ảnh hưởng đến hiệu xuất của trang web nhưng nó sẽ làm nặng trình duyệt của người dùng (không đáng kể).</li><li>Về phạm vi: <strong>sessionStorage</strong>: giới hạn trong một cửa sổ hoăc thẻ của trình duyệt. Một trang web được mở trong hai thẻ của cùng một trình duyệt cũng không thể truy xuất dữ liệu lẫn nhau. Như vậy, khi bạn đóng trang web thì dữ liệu lưu trong sessionStorage hiện tại cũng bị xóa. Còn <strong>localStorage</strong>: có thể truy xuất lẫn nhau giữa các cửa sổ trình duyệt. Dữ liệu sẽ được lưu trữ không giới hạn thời gian.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Su-khac-nhau-va-cach-su-dung-Local-Storage-Session-Storage-va-Cookie&quot;&gt;&lt;a href=&quot;#Su-khac-nhau-va-cach-su-dung-Local-Storage-Session-Storage-va-Cookie&quot; class=&quot;headerlink&quot; title=&quot;Sự khác nhau và cách sử dụng Local Storage, Session Storage và Cookie&quot;&gt;&lt;/a&gt;Sự khác nhau và cách sử dụng Local Storage, Session Storage và Cookie&lt;/h1&gt;&lt;p&gt;Bạn bị lẫn lộn giữa &lt;strong&gt;session storage&lt;/strong&gt;, &lt;strong&gt;local storage&lt;/strong&gt; và &lt;strong&gt;cookies&lt;/strong&gt;? Bài viết dưới đây sẽ giúp bạn hiểu rõ được sự khác nhau giữa 3 cách lưu trữ này. Các kiểu không gian lưu trữ khác nhau có sẵn cho các dữ liệu có thể trên máy chủ hoặc máy khách, cho phép chúng ta chọn lựa theo nhu cầu.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
      <category term="html5" scheme="http://nthung2112.github.io/tags/html5/"/>
    
  </entry>
  
</feed>
