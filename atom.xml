<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Learn and Share</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nthung2112.github.io/"/>
  <updated>2018-07-10T02:08:58.475Z</updated>
  <id>http://nthung2112.github.io/</id>
  
  <author>
    <name>Hung Tan Nguyen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Làm thế nào để thành thạo CSS Grid trong nháy mắt</title>
    <link href="http://nthung2112.github.io/2018/07/Lam-the-nao-de-thanh-thao-CSS-Grid-trong-nhay-mat.html"/>
    <id>http://nthung2112.github.io/2018/07/Lam-the-nao-de-thanh-thao-CSS-Grid-trong-nhay-mat.html</id>
    <published>2018-07-10T01:10:00.000Z</published>
    <updated>2018-07-10T02:08:58.475Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu"></a>Giới thiệu</h3><p>Đây KHÔNG phải là một bài viết để học “mọi thứ” về css grid.<br>Bài viết này hướng đến những người muốn có kết quả nhanh chóng và hiệu quả.<br>Trong bốn phần của bài viết này, tôi sẽ chỉ cho bạn 20% cần thiết để làm được 80% những gì bạn có thể làm với CSS Grid layout.</p><p>Hãy cùng tìm hiểu!</p><a id="more"></a><h3 id="Tai-sao-chi-20"><a href="#Tai-sao-chi-20" class="headerlink" title="Tại sao chỉ 20%?"></a>Tại sao chỉ 20%?</h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*LPf5rSOWKaSKTOUwkqfK0w.png" alt=""></p><p>Bất cứ khi nào, một lập trình viên tìm kiếm sự hiệu quả - sự lười biếng sẽ giúp anh ta.</p><p>CSS Grid layout rất phức tạp. Theo ý kiến của tôi, nó phức tạp hơn Flexbox. (tôi đã mất vài tuần để tìm hiểu flexbox)</p><p>Không hẳn bởi vì nó “khó” mà do CSS Grid có tới 18 thuộc tính mới cộng với những khái niệm mà bạn chưa bao giờ nghe tới trước đó.</p><p>Vậy, bạn cần biết tất cả những thuộc tính mới này ngay bây giờ? Ngay lập tức?</p><p>Không, bạn không cần!</p><p>Bạn chỉ cần học một vài thuộc tính cần thiết ngay lúc này để tạo ra kết quả mong muốn. Những thuộc tính khác có thể học sau. Đó là định nghĩa về “hiệu quả” của tôi.</p><hr><h3 id="1-CSS-Grid-layout-la-gi"><a href="#1-CSS-Grid-layout-la-gi" class="headerlink" title="1. CSS Grid layout là gì ?"></a>1. CSS Grid layout là gì ?</h3><p>Nếu bạn mới học bố cục trong CSS, CSS Grid có thể khá xa lạ với bạn.</p><p>Bạn đã nghe nói tới Flexbox chưa?</p><p>Tôi thích coi CSS Grid như là một người anh (hoặc cha) của Flexbox.</p><p>Xử lý các bố cục trong CSS được coi là một công việc khó khăn và không hấp dẫn. Flexbox đã làm cho mọi thứ dễ dàng hơn - nhưng CSS Grid thậm chí còn tốt hơn.</p><h3 id="Cai-chung-ta-se-xay-dung"><a href="#Cai-chung-ta-se-xay-dung" class="headerlink" title="Cái chúng ta sẽ xây dựng."></a>Cái chúng ta sẽ xây dựng.</h3><p>Chúng ta sẽ học cách áp dụng 20% kiến thức học được để xây dựng bố cục responsive của một ứng dụng âm nhạc</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*ripUP4LuXPQ851Zlq79bWQ.gif" alt="a responsive music app, catty music"></p><h3 id="Phan-1-10-ban-can-biet-Cac-thuat-ngu-co-ban"><a href="#Phan-1-10-ban-can-biet-Cac-thuat-ngu-co-ban" class="headerlink" title="Phần 1: 10% bạn cần biết - Các thuật ngữ cơ bản"></a>Phần 1: 10% bạn cần biết - Các thuật ngữ cơ bản</h3><p>Chúng ta hãy nhìn vào những điều đầu tiên bạn bắt buộc phải biết.</p><hr><h4 id="Grid-Container-la-gi"><a href="#Grid-Container-la-gi" class="headerlink" title="Grid Container là gì?"></a>Grid Container là gì?</h4><p>Mỗi bố cục các trang web hoặc ứng dụng bạn tạo ra (hoặc thấy) về bản chất là những chiếc hộp được đặt trong những đường ranh giới xác định.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*uFGh3Vo2i9MneYvjqJNhRw.gif" alt="gif by chris bannister"></p><p>Hiểu đơn giản, grid chỉ là “những đường kẻ”. Những đường kẻ ngang và dọc xác định vị trí của các phần tử được thiết kế khác nhau.</p><p>Bạn sẽ quen với grid nếu bạn đã sử dụng các phần mềm thiết kế như photoshop hoặc sketch.</p><p>Trong bối cảnh của CSS Grid layout, một Grid container là phần tử cha chứa tất cả các phần tử nằm trong grid. Grid container xác định vị trí ban đầu của các đường kẻ trong grid, cả dọc và ngang.</p><h4 id="Grid-Line-la-gi"><a href="#Grid-Line-la-gi" class="headerlink" title="Grid Line là gì?"></a>Grid Line là gì?</h4><p>Giả sử bạn có một bố cục như thế này:</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*xcID2GAZoYqhb4LYjN6Qug.png" alt="supposed grid layout"></p><p>Bố cục bao gồm một grid container với các phần tử ở bên trong</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*9K74dULhLERm5_3a37Byqw.png" alt="a bit of explanation"></p><p>Grid lines chính là những đường kẻ ngang và dọc phân chia grid thành các ô.</p><h4 id="Grid-Cell-la-gi"><a href="#Grid-Cell-la-gi" class="headerlink" title="Grid Cell là gì?"></a>Grid Cell là gì?</h4><p>Grid cell là đơn vị nhỏ nhất trong grid layout. Bất kỳ khoảng trống nào được xác định bởi 4 đường grid line.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*7X_NTZG0ikpVwsaB0qfdAw.png" alt="The “small boxes” of grid items may be referred to as grid cells."></p><h4 id="Grid-Area"><a href="#Grid-Area" class="headerlink" title="Grid Area"></a>Grid Area</h4><p>Một grid area có thể giống như một grid cell (giống như ở phần trước). Hoặc cũng có thể trải rộng trên nhiểu hoặc tất cả grid cell trong grid.</p><p>Trong hình vẽ dưới đây, grid area trải rộng trên 4 ô.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*_4ZnWO3zlt82VMHQ_3VNXA.png" alt=""></p><h4 id="Grid-Track-la-gi"><a href="#Grid-Track-la-gi" class="headerlink" title="Grid Track là gì?"></a>Grid Track là gì?</h4><p>Một grid track có thể xem như một tên gọi khác cho các cột và các dòng. Nó là khoảng trống giữa 2 grid line bất kỳ.</p><p>Hình dưới đây là ví dụ về grid tracks</p><p><img src="https://cdn-images-1.medium.com/max/800/1*oan28239S-v0oJZECQPKIA.png" alt=""></p><p><img src="https://cdn-images-1.medium.com/max/800/1*-tby4L7UaQavuy6uc0H1LQ.png" alt=""></p><p><img src="https://cdn-images-1.medium.com/max/800/1*xkbT0CjkBWb-5S_hxcBvGw.png" alt="grid tracks"></p><p>Vì vậy, chúng tôi đã phân loại được tất cả trong phần đầu tiên.</p><h3 id="Phan-2-10-con-lai-ma-ban-can-biet-ve-CSS-grid"><a href="#Phan-2-10-con-lai-ma-ban-can-biet-ve-CSS-grid" class="headerlink" title="Phần 2: 10% còn lại mà bạn cần biết về CSS grid."></a>Phần 2: 10% còn lại mà bạn cần biết về CSS grid.</h3><p>Bây giờ bạn đã hiểu các thuật ngữ cơ bản, giống như một đứa trẻ mạo hiểm, hãy bắt đầu!</p><h4 id="Lam-the-nao-de-dinh-nghia-mot-Grid"><a href="#Lam-the-nao-de-dinh-nghia-mot-Grid" class="headerlink" title="Làm thế nào để định nghĩa một Grid?"></a>Làm thế nào để định nghĩa một Grid?</h4><p>Giống như Flexbox, mọi thứ bắt đầu với display: grid hoặc display: inline-grid cho phiên bản inline.</p><p>Ví dụ, để biến một div thành một grid container:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lam-the-nao-de-tao-cac-cot-va-dong"><a href="#Lam-the-nao-de-tao-cac-cot-va-dong" class="headerlink" title="Làm thế nào để tạo các cột và dòng?"></a>Làm thế nào để tạo các cột và dòng?</h4><p>Để tạo các cột và các dòng trong một grid container, chúng ta sẽ sử dụng 2 thuộc tính mới: <code>grid-template-columns</code> và <code>grid-template-rows</code>.</p><p>Vậy sử dụng chúng như thế nào? Khá đơn giản.</p><p><code>grid-template-columns</code> định nghĩa vị trí của các cột. <code>grid-template-rows</code> định nghĩa vị trí của các dòng.</p><p>Bạn truyền giá trị vào các thuộc tính này, và chúng tạo ra các dòng và các cột.</p><p>Xem ví dụ:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 100<span class="selector-tag">px</span> 200<span class="selector-tag">px</span> 300<span class="selector-tag">px</span></span><br></pre></td></tr></table></figure><p>Đoạn code này sẽ tạo thành 3 cột mới trong grid container. Cột đầu tiên có độ rộng 100px, cột tiếp theo 200px và cột cuối 300px.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*OGJmxXekTwSlW-aoTeSXEw.png" alt="grid-template-columns: 100px 200px 300px"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-rows</span>: 100<span class="selector-tag">px</span> 200<span class="selector-tag">px</span> 300<span class="selector-tag">px</span></span><br></pre></td></tr></table></figure><p>Đoạn code này sẽ tạo 3 dòng mới trong grid container như hình dưới đây:</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*TcGMy7iMxXoRbqs8hL0NHw.png" alt="grid-template-rows: 100px 200px 300px"></p><p>Bây giờ đặt chúng cùng nhau, bạn sẽ có một grid hoàn chỉnh với các dòng và cột đã được định nghĩa.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 100<span class="selector-tag">px</span> 200<span class="selector-tag">px</span> 300<span class="selector-tag">px</span></span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: 100<span class="selector-tag">px</span> 200<span class="selector-tag">px</span> 300<span class="selector-tag">px</span></span><br></pre></td></tr></table></figure><h3 id="Phan-3-Bat-tay-vao-Code-CSS-Grid"><a href="#Phan-3-Bat-tay-vao-Code-CSS-Grid" class="headerlink" title="Phần 3: Bắt tay vào Code - CSS Grid"></a>Phần 3: Bắt tay vào Code - CSS Grid</h3><p>Bây giờ chúng ta hãy thực hiện các bước để xây dựng bản sao của ứng dụng âm nhạc nổi tiếng, nhạc catty</p><p>Để phát triển nhanh chóng, tôi sẽ sử dụng <a href="http://www.codepen.io" target="_blank" rel="noopener">Codepen</a>. Tạo một dự án mới và hãy bắt đầu.</p><h3 id="Lam-the-nao-de-tao-ra-bo-khung-cho-ung-dung-Catty-Music"><a href="#Lam-the-nao-de-tao-ra-bo-khung-cho-ung-dung-Catty-Music" class="headerlink" title="Làm thế nào để tạo ra bộ khung cho ứng dụng Catty Music"></a>Làm thế nào để tạo ra bộ khung cho ứng dụng Catty Music</h3><p>Sau khi đã tạo một project trên codepen. Chúng ta sẽ tạo một tài liệu html cơ bản:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Có mục đích khi chọn cấu trúc này. Bạn sẽ sớm nhận ra điều đó.</p><p>Bây giờ style tài liệu.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   <span class="attribute">display</span>: grid;</span><br><span class="line">   <span class="attribute">min-height</span>: <span class="number">100%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đoạn code này sẽ biến body thành một grid-container.</p><p>Bây giờ chúng ta cần tạo cấu trúc các dòng và cột trong grid.</p><h3 id="Lam-the-nao-de-tao-ra-cac-dong-va-cac-cot-cho-ung-dung-Catty-Music"><a href="#Lam-the-nao-de-tao-ra-cac-dong-va-cac-cot-cho-ung-dung-Catty-Music" class="headerlink" title="Làm thế nào để tạo ra các dòng và các cột cho ứng dụng Catty Music"></a>Làm thế nào để tạo ra các dòng và các cột cho ứng dụng Catty Music</h3><p>Tạo các dòng và cột là khá dễ dàng.</p><p>Kết quả cuối cùng chúng cần đạt được là:</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*VFkE679czY0Tb49R9GNvyg.png" alt="final layout we seek."></p><p>Tuy nhiên, ban đầu khi thiết lập grid chúng ta cần 2 dòng và 2 cột.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*80Qn4c32kqbQzMVh-AcAoQ.png" alt="initial grid setup"></p><h4 id="Day-la-mot-vai-thu-can-chu-y-ve-thiet-lap-Grid"><a href="#Day-la-mot-vai-thu-can-chu-y-ve-thiet-lap-Grid" class="headerlink" title="Đây là một vài thứ cần chú ý về thiết lập Grid"></a>Đây là một vài thứ cần chú ý về thiết lập Grid</h4><p><strong>Columns:</strong></p><ol><li>Cột đầu tiên phải có độ rộng cố định là 50px.</li><li>Cột thứ 2 phải chiếm toàn bộ độ rộng còn lại của dòng.</li></ol><p><strong>Rows:</strong></p><ol><li>Dòng thứ 2 phải có chiều cao cố định là 100px.</li><li>Dòng đầu tiên phải chiếm toàn bộ chiều còn lại của grid.</li></ol><h4 id="Giai-phap-cua-mot-nguoi-it-kinh-nghiem"><a href="#Giai-phap-cua-mot-nguoi-it-kinh-nghiem" class="headerlink" title="Giải pháp của một người ít kinh nghiệm."></a>Giải pháp của một người ít kinh nghiệm.</h4><p>Nếu bạn KHÔNG có kinh nghiệm với CSS, bạn có thể viết như thế này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   ...   </span><br><span class="line">   <span class="selector-tag">grid-template-rows</span>: 100% 100<span class="selector-tag">px</span>;</span><br><span class="line">   <span class="selector-tag">grid-template-columns</span>: 50<span class="selector-tag">px</span> 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vấn đề với giải pháp này là bạn đã vô tình tạo ra một grid với chiều rộng là 100% + 50px và chiều cao là 100% + 100px.</p><p>Cái chúng ta muốn là chiều rộng và chiều cao là 100%. Vì thế hướng tiếp cần này là sai.</p><h4 id="Giai-phap-cua-nguoi-da-co-kinh-nghiem"><a href="#Giai-phap-cua-nguoi-da-co-kinh-nghiem" class="headerlink" title="Giải pháp của người đã có kinh nghiệm"></a>Giải pháp của người đã có kinh nghiệm</h4><p>Nếu đã có một vài kinh nghiệm với CSS, bạn có thể làm một vài thứ thông minh hơn như thế này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="selector-tag">grid-template-rows</span>: <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 100<span class="selector-tag">px</span>) 100<span class="selector-tag">px</span>;</span><br><span class="line">   <span class="selector-tag">grid-template-columns</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">calc</span>(100%<span class="selector-tag">-50px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cách này khá thông minh. Nhưng có một vấn đề - nó rất khó để bảo dưỡng.</p><p>Ví dụ, nếu vì một lý do nào đó bạn phải thay đổi độ rộng cố định, bạn cũng phải thay đổi định nghĩa calc.</p><h4 id="Giai-phap-hieu-qua-nhat"><a href="#Giai-phap-hieu-qua-nhat" class="headerlink" title="Giải pháp hiệu quả nhất"></a>Giải pháp hiệu quả nhất</h4><p>May mắn là CSS Grid có một đơn vị mới giúp chúng ta giải quyết vấn đề ở trên một cách dễ dàng đó là đơn vị. <a href="https://medium.com/flexbox-and-grids/the-css-fractional-unit-fr-in-approachable-plain-language-fdc47bd387f7" target="_blank" rel="noopener">factional(fr)</a></p><p>Đơn vị fractional giải quyết vấn đề tự động phân bố khoảng trống.</p><p>Nếu bạn có grid với 3 cột như ở dưới, đơn vị fractional sẽ tự động phân bổ các khoảng trống bằng nhau.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*1TWb0kZ4nn6uvykRLMGtOw.png" alt=""></p><p>INếu vì một vài lý do bạn thêm nhiều phần tử hơn - đừng lo lắng. Đơn vị fr sẽ phân bổ lại các khoảng trống bằng nhau.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*D5ILayU5dx_la2wnyn6ZYw.png" alt=""></p><p>Cuối cùng, nếu bạn đã có một phần tử với độ rộng cố định, bạn có thể lấy toàn bộ khoảng trống còn lại với đơn vị fr. Như thế này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="selector-tag">grid-template-rows</span>: 1<span class="selector-tag">fr</span> 100<span class="selector-tag">px</span>;</span><br><span class="line">   <span class="selector-tag">grid-template-columns</span>: 50<span class="selector-tag">px</span> 1<span class="selector-tag">fr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And that is it — done!</p><h3 id="Dat-ten-va-xac-dinh-vi-tri-boi-Grid-Areas"><a href="#Dat-ten-va-xac-dinh-vi-tri-boi-Grid-Areas" class="headerlink" title="Đặt tên và xác định vị trí bởi Grid Areas"></a>Đặt tên và xác định vị trí bởi Grid Areas</h3><p>Chúng ta đã tạo ra hệ thống grid. Bây giờ là lúc để sử dụng nó.</p><p>Mục đích của phần này học cách xác định vị trí các phần tử trong grid sử dụng grid areas.</p><p>Nhắc lại một chút, một grid area là bất kỳ khoảng trống được bao bởi 4 grid line.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*7X_NTZG0ikpVwsaB0qfdAw.png" alt="The “small boxes” of grid items may be referred to as grid cells."></p><h4 id="Lam-the-nao-de-su-dung-grid-areas"><a href="#Lam-the-nao-de-su-dung-grid-areas" class="headerlink" title="Làm thế nào để sử dụng grid areas?"></a>Làm thế nào để sử dụng grid areas?</h4><p>Nơi hợp lý để bắt đầu là đặt tên grid areas<br>Hãy để tôi giải thích.<br>Xem xét khối lệnh dưới đây:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3 divs - đơn giản. Bằng cách này, Nó là ngữ nghĩa tốt hơn để sử dụng tags aside main và footer. Tôi sẽ giữ mọi thứ đơn giản.</p><p>Bây giờ hãy xem đoạn code này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Chuyen-gi-dang-xay-ra-o-day"><a href="#Chuyen-gi-dang-xay-ra-o-day" class="headerlink" title="Chuyện gì đang xảy ra ở đây"></a>Chuyện gì đang xảy ra ở đây</h4><p>Nếu biết một chút về Javascript, hay bất kỳ ngôn ngữ lập trình nào khác, thì khái niệm về biến sẽ không phải là mới với bạn.</p><p>Trong Javascript, chúng ta có thể nói:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gridArea = <span class="string">"content"</span></span><br></pre></td></tr></table></figure><p>Cái chúng ta làm ở phía trên là, lưu chuỗi <code>content</code> vào biến <code>gridArea</code></p><p>Khai báo CSS ở phần trước tương tự như vậy.</p><blockquote><p>Mọi phần tử trong grid có thể được gán tới một vùng trong grid container.</p></blockquote><p>Tuy nhiên, trước khi làm điều đó, chúng ta bắt buộc phải gán mỗi phần tử trong grid với một tên gọi. Giống như các biến trong Javascript.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đoạn code ở trên nói rằng, class <code>.main</code> có tên là <code>content</code>. Class <code>.footer</code> có tên là <code>footer</code>. Cuối cùng, class <code>.aside</code> có tên là <code>sidebar</code></p><p>Bây giờ các grid items được gán tên cho mỗi vùng.</p><p>Trong lập trình, các biến được thiết lập để được sử dụng ở nơi khác. Bây giờ, hãy sử dụng tên grid area.</p><h4 id="Vi-tri-Grid-area"><a href="#Vi-tri-Grid-area" class="headerlink" title="Vị trí Grid area"></a>Vị trí Grid area</h4><p>Một người đàn ông trẻ có một cái bánh nướng. Anh ta có 3 đứa con và phải chia cho mỗi đứa một phần. Ai là người chia bánh thì hợp lý nhất?</p><p>Chính người đàn ông đó!</p><p>Người đàn ông trẻ cắt bánh và chia cho mỗi đứa trẻ một phần.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*xN-041OZXzMZvCJ76WRtfQ.jpeg" alt="yummy!"></p><p>Đây là lý do tôi kể câu chuyện này.</p><p>Giống như chiếc bánh, toàn bộ khoảng trống trong grid là của ai?</p><p>Chính là grid container!</p><p>Giống như người đàn ông trẻ, grid container có 3 đứa con <code>.aside</code> <code>.main</code> và <code>.footer</code>. Bây giờ grid container phải chọn cách chia toàn bộ khoảng trống trong grid cho 3 đứa con này.</p><p>Và một điều nữa.</p><p>Vì tất cả những đứa trẻ đều có tên, người đàn ông trẻ có thể nói: “hey Brian đây là phần của con hoặc hey Emma của con là phần này.”</p><p>Dễ dàng để xác định ai sở hữu phần nào của chiếc bánh, bằng cách gán mỗi phần với tên của mỗi người.</p><p>Mỗi phần tử trong grid đều đã có tên bằng cách sử dụng thuộc tính grid-area.</p><p>Bây giờ, hãy chia bánh!</p><h4 id="Thuoc-tinh-grid-template-areas"><a href="#Thuoc-tinh-grid-template-areas" class="headerlink" title="Thuộc tính grid-template-areas"></a>Thuộc tính grid-template-areas</h4><p>Bây giờ grid container phải chia “bánh”. Gán mỗi vùng tới mỗi phần tử tương ứng.</p><p>Có nhiều cách để làm điều đó, nhưng thuộc tính <code>grid-template-areas</code> là cách dễ dàng nhất để làm đó. nó chính là cái bạn cần biết để làm việc hiệu quả.</p><h4 id="Thuoc-tinh-grid-template-areas-lam-viec-nhu-the-nao"><a href="#Thuoc-tinh-grid-template-areas-lam-viec-nhu-the-nao" class="headerlink" title="Thuộc tính grid-template-areas làm việc như thế nào?"></a>Thuộc tính grid-template-areas làm việc như thế nào?</h4><p>Hãy xem đoạn code dưới đây:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">      <span class="attribute">grid-template-areas</span>: <span class="string">"sidebar  content"</span></span><br><span class="line">                           <span class="string">"footer   footer"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Cái quái gì vậy?</p><p>Không cần phải bị choáng ngợp. Trong phần này, tôi sẽ giải thích nó hoạt động như thế nào - theo thuật ngữ rõ ràng.</p><p>Thuộc tính grid-template-areas cung cấp một cấu trúc rất trực quan của grid.</p><p>Hãy xem lại đoạn code trên một lần nữa:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">      <span class="attribute">grid-template-areas</span>: <span class="string">"sidebar  content"</span></span><br><span class="line">                           <span class="string">"footer   footer"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Bạn có thể thấy toàn bộ giá trị của thuộc tính là tên của các phần tử trong grid!</p><p><code>sidebar</code> <code>content</code> và <code>footer</code> là tên của các phần tử trong grid. Khai báo ở trên gán mỗi vùng trong grid với một phần tử tương ứng.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*NjMwDa_1b1vHkAbpXI_f7w.png" alt=""></p><p>Hình ảnh trên sẽ giúp bạn hiểu grid được chia như thế nào.</p><p><code>footer</code> sẽ chiếm toàn bộ dòng bên dưới. <code>sidebar</code> và <code>content</code> sẽ chiếm cột đầu tiên và thứ 2 của dòng bên bên.</p><p>Đến đây chúng ta có:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: grid;</span><br><span class="line">      <span class="attribute">grid-template-columns</span>: <span class="number">40px</span> <span class="number">1</span>fr;</span><br><span class="line">      <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">90px</span>;</span><br><span class="line">      <span class="attribute">grid-template-areas</span>: <span class="string">"sidebar  content"</span></span><br><span class="line">                           <span class="string">"footer  footer"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Kết quả sẽ như dưới đây:</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*LNfazbNhUOy6YBEE7Sr_Uw.png" alt="STEP 1: https://codepen.io/ohansemmanuel/pen/bRWrPE"></p><p>Tôi đã thêm màu sắc để hỗ trợ hình ảnh. Phần màu đỏ đại diện cho <code>.footer</code>, hai phần còn lại, phần <code>.main</code> và <code>.sidebar</code>.</p><h3 id="Lam-cho-bo-cuc-responsive-Dinh-nghia-lai-Grid-areas-voi-Media-Queries"><a href="#Lam-cho-bo-cuc-responsive-Dinh-nghia-lai-Grid-areas-voi-Media-Queries" class="headerlink" title="Làm cho bố cục responsive - Định nghĩa lại Grid areas với Media Queries"></a>Làm cho bố cục responsive - Định nghĩa lại Grid areas với Media Queries</h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*9H_Ylq3VVHRLQRTZZLYbQQ.gif" alt="gif by Muharrem Senyil"></p><p>Các Grid area mà bạn đã tạo trong grid container có thể thay đổi tùy theo kích thước màn hình của người sử dụng.</p><p>Dưới đây là hình ảnh ứng dụng trên màn hình điện thoại.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*Gd8H2uQF3-TVi4lq7g1UAw.png" alt="Catty Music, on mobile"></p><p>Chúng ta sẽ refactor lại code theo hướng tiếp cận mobile first.</p><p>Mobile first đơn giản là làm cho style mặc định của bạn là dành cho các thiết di động. Sau đó bạn sẽ tạo ra các thay đổi cho các màn hình lớn hơn thông qua các media query.</p><p>Đặt một phần code hiện nay trong một định nghĩa media query. Như dưới đây:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">1</span>fr;</span><br><span class="line">        <span class="attribute">grid-template-areas</span>: <span class="string">"sidebar  content"</span></span><br><span class="line">                             <span class="string">"footer   footer"</span>;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bạn sẽ để đoạn code mặc định bên ngoài media query</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tại sao chúng ta đặt grid-template-rows: 1fr 100px; bên ngoài media query?</p><p>Bởi vì cả màn hình di động và desktop chúng ta đều có 2 dòng.</p><p>Tuy nhiên, trên màn hình desktop. Sidebar là 50px trong định nghĩa grid-template-columns. Còn trên các thiết bị di động sidebar không tồn tại.</p><p>Vì thế, chúng ta sẽ định nghĩa lại khai báo <code>grid-template-columns</code> cho di động.</p><p>Bây giờ với các thiết bị di động chúng ta sẽ sử dụng style này là mặc định:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   <span class="attribute">grid-template-areas</span>: <span class="string">"content"</span></span><br><span class="line">                        <span class="string">"footer"</span></span><br></pre></td></tr></table></figure><p>Khá đơn giản phải không? Hãy để tôi giải thích.</p><h3 id="Dong-chay-huong-cua-Grid"><a href="#Dong-chay-huong-cua-Grid" class="headerlink" title="Dòng chảy (hướng) của Grid"></a>Dòng chảy (hướng) của Grid</h3><p>Đoạn code cho di động như thế này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   <span class="attribute">grid-template-areas</span>: <span class="string">"content"</span></span><br><span class="line">                        <span class="string">"footer"</span></span><br></pre></td></tr></table></figure><p>Bởi mặc định, một grid sẽ sắp xếp các phần tử trên các dòng.</p><p>Vì thế khai báo ở phía trên sẽ sắp xếp content trên một dòng và footer trên một dòng khác.</p><p>Dưới đây là kết quả - sidebar sẽ ẩn trên màn hình di động:</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*WeVXg_bAwa5UKqdZHiwQ7w.gif" alt="STEP 2: https://codepen.io/ohansemmanuel/pen/qjVvjJ?editors=1100"></p><p>Với rào cản ban đầu của sự hiểu biết cách hoạt động của grids và thiết lập responsive grid, chúng ta đã xong bố cục ứng dụng!</p><h3 id="Them-noi-dung-vao-trong-Grid"><a href="#Them-noi-dung-vao-trong-Grid" class="headerlink" title="Thêm nội dung vào trong Grid"></a>Thêm nội dung vào trong Grid</h3><p>Khi kết thúc phần này chúng ta sẽ có một bố cục ứng dụng âm nhạc hoàn chỉnh. Bây giờ hãy tập trung và việc sắp xếp nội dung trong grid.</p><h4 id="1-The-Sidebar"><a href="#1-The-Sidebar" class="headerlink" title="1. The Sidebar"></a>1. The Sidebar</h4><p>Điều này có vẻ dễ nhất để bắt đầu. Hãy đi tìm nó.</p><p>Sidebar bao gồm 8 icon cách đều nhau dọc theo toàn bộ chiều dài của sidebar.</p><p>Hãy chèn các icon vào sidebar:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-bars"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-home"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-search"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-volume-up"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-spotify"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-cog"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-soundcloud"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Kết quả sẽ như thế này: </p><p><img src="https://cdn-images-1.medium.com/max/2000/1*DY1tA49VLEOy0I5Fb_HmlQ.png" alt="https://codepen.io/ohansemmanuel/pen/BZmbza"></p><p>Các icon cũng sẽ ẩn trên màn hình di động. Và chỉ hiển thị trên các màn hình lớn hơn. Đây là hướng tiếp cận mobile first.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.aside</span> <span class="selector-tag">i</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> only screen and (min-width:<span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.aside</span> <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Các biểu tượng được hiển thị, nhưng được căn chỉnh chưa đều.</p><h4 id="Sap-xep-cac-icon"><a href="#Sap-xep-cac-icon" class="headerlink" title="Sắp xếp các icon"></a>Sắp xếp các icon</h4><p>Các thẻ <code>i</code> là các phần tử <code>inline</code> – điều đó giải thích tại sao 2 icon lại hiển thị cạnh nhau trên một dòng.</p><p>Hãy sắp xếp chúng.</p><blockquote><p>Các phần tử con của grid container cũng có thể trở thành các grid container. Tại sao không?</p></blockquote><h4 id="Buoc-1-Bien-Sidebar-thanh-mot-Grid-Container"><a href="#Buoc-1-Bien-Sidebar-thanh-mot-Grid-Container" class="headerlink" title="Bước 1: Biến Sidebar thành một Grid Container"></a>Bước 1: Biến Sidebar thành một Grid Container</h4><p>Điều này sẽ cung các tính năng căn chỉnh của grid.</p><p>Khi sidebar chỉ hiển thị trên các màn hình lớn hơn, đừng quên đặt nó trong media query.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (min-width:<span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.aside</span> &#123;</span><br><span class="line">     <span class="attribute">display</span>: grid; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="selector-class">.aside</span> <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tôi thêm border cho mỗi icon - để chúng ta dễ phân biệt.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*QcpsRWdU5Q01YC-C2Et11w.png" alt=""></p><p>Chuyện gì đang xảy ra ở đây?</p><p>Chúng ta KHÔNG thiết lập bất kỳ dòng hay cột trong sidebar. Nhưng chúng ta thấy các icon được sắp xếp khá tốt. Grid tự động thiết lập điều đó.</p><p>Đây là vị trí mặc định của các item trong một grid – trên cùng một dòng.</p><p>Một grid cũng có thể sắp xếp các phần tử sử dụng <code>justify-items</code> hay <code>align-items</code>.</p><p><code>justify-items</code> sẽ sắp xếp các phần tử theo chiều ngang.</p><p><code>align-items</code> sẽ sắp xếp các phần tử theo chiều dọc.</p><p>Áp dụng điều này cho sidebar, và chúng ta có một bổ cục các icon hoàn hảo:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="selector-tag">justify-items</span>: <span class="selector-tag">center</span>;</span><br><span class="line">     <span class="selector-tag">align-items</span>: <span class="selector-tag">center</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Bạn vẫn cảm thấy khó hiểu, hãy xem video dưới đây:</p><div class="video-container"><iframe src="//www.youtube.com/embed/pN2rGbEfNw8" frameborder="0" allowfullscreen></iframe></div><p>Bây giờ chúng ta đã một bố cục hoàn hảo dành cho các icon trong sidebar.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*gwdH9pKxjMw7MnO8vPmTgw.png" alt="https://codepen.io/ohansemmanuel/pen/MorYJq?editors=1100"></p><p><code>justify-items</code> hay <code>align-items</code> có thể có các giá trị:</p><ul><li>stretch</li><li>start</li><li>end</li><li>center</li></ul><p>Nếu đã từng làm việc với Flexbox, bạn sẽ quen với chúng.</p><p>Chúng ta sẽ thêm nhiều nội dung hơn vào thiết kế hiện tại.</p><p>Thêm 2 thẻ div vào main section:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main__header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main__body"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>NB:</strong></p><ol><li><code>main__header</code> sẽ chứa music art và playbacks:</li></ol><p><img src="https://cdn-images-1.medium.com/max/2000/1*K2ikIxNuiWo8tfY-5RvBXg.png" alt=".main__header"></p><ol><li><code>main__body</code>sẽ chứa chi tiết:</li></ol><p><img src="https://cdn-images-1.medium.com/max/2000/1*hc80JsuD3IsxxwrAijFWzQ.png" alt=".main__body"></p><p>Trong phần này chúng ta sẽ tập trung vào <code>main__header</code></p><p>Đầu tiên, thêm đoạn code html này:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main__header"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://bit.ly/2sc2NJd"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"details"</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span>CattyBoard Top 100 Single Charts (11.06.36)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sm--hide"</span>&gt;</span>Unknown Artist<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sm--hide"</span>&gt;</span>2016 . Charts . 100 songs<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">               <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-play"</span>&gt;</span> &amp;nbsp;Play all<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-plus"</span>&gt;</span> &amp;nbsp;Add to<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-ellipsis-h"</span>&gt;</span>&amp;nbsp;&amp;nbsp;More<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Chú ý cấu trúc của tài liệu</p><p><code>main__header</code> có hai con trực tiếp. Một <code>div</code> chứa một hình ảnh và <code>section</code> chứa thông tin chi tiết của album.</p><p>Kết quả của đoạn code trên khá xấu xí:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*uhNqMg2RUv_bo5371BrOfQ.png" alt="incomplete header"></p><p>Hãy làm cho nó đẹp hơn.</p><p>Cái chúng ta cần là một grid với các phần tử được sắp xếp phù hợp.</p><p>Hãy sử dụng những kiến thức về grid areas</p><p>Đầu tiên, định nghĩa grid area:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main__header</span> &gt; <span class="selector-class">.img</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: img;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main__header</span> &gt; <span class="selector-class">.details</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: dtls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>div</code> chứa hình ảnh được đặt tên là <code>img</code>. Phần chứa thông tin chi tiết của album được đặt tên là <code>dtls</code>.</p><p>Bây giờ, định nghĩa grid:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main__header</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">"img"</span></span><br><span class="line">                       <span class="string">"dtls"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>.main__header</code> trở thành một grid container, có 2 phần tử xếp chồng lên nhau đầu tiên là <code>img</code> tiếp theo là <code>dtls</code>. Bởi vì chúng ta đang theo hướng tiếp cận mobile first.</p><p>Tại thời điểm này, không có nhiều thay đổi.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*h60PmaHUtZAMZrC5xrRtbA.png" alt="I have included borders and made the text whitish for visual aid."></p><p>Đây không phải là cái chúng ta muốn trên di động.</p><p>Với màn hình di động, các phần tử nên được căn giữa.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.main__header</span> &#123;</span><br><span class="line">    <span class="attribute">justify-items</span>: center;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kết quả sẽ như dưới đây:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*9Yi3TudvNbbTdYtDBsqL1w.png" alt=""></p><p>Tiếp theo hãy làm cho text trong <code>.details</code> căn giữa:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.main__header</span> &gt; <span class="selector-class">.details</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1600/1*Dj_iJrYWYA4lpQdxuzx4Cw.png" alt=""></p><p>Đã khá gần với mục tiêu chỉ cần thêm một vài điều chỉnh.</p><p>Đoạn text <code>Unknown Artist</code> và <code>2016</code> . <code>Charts</code> . <code>100 songs</code> nên ẩn trên di động. Ảnh cũng nên nhỏ hơn.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.sm--hide</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="selector-class">.img</span> &gt; <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class <code>.sm--hide</code> sẽ ẩn trên di động. Chỉ cần thêm class tới phần tử mong muốn. Như thế này:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sm--hide"</span>&gt;</span>Unknown Artist<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sm--hide"</span>&gt;</span>2016 . Charts . 100 songs<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Và chúng ta có:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*3EldPliJB9kqZmu9B1UaRg.png" alt=""></p><p>Màn hình di động đã xong. Giờ hãy thêm style cho những màn hình lớn hơn.</p><p>Với màn hình lớn hơn, chúng ta cần một grid 2 cột. Style sẽ như thế này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (min-width:<span class="number">600px</span>) &#123;</span><br><span class="line">   <span class="selector-class">.main__header</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">250px</span> <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: <span class="string">"img dtls"</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Grid đã được định nghĩa lại với 2 cột. Một có độ rộng cố định là 250px và cột kia chiếm toàn bộ khoảng trống còn lại.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*iFRIMSqQYAl2AhHBgsCjdw.gif" alt="https://codepen.io/ohansemmanuel/pen/gReOQJ?editors=1100"></p><p>Tiến trình hiện tại của chúng ta <a href="https://codepen.io/ohansemmanuel/pen/gReOQJ?editors=1100" target="_blank" rel="noopener">here</a>.</p><h3 id="Phan-4-Ket-hop-CSS-Grid-voi-Flexbox"><a href="#Phan-4-Ket-hop-CSS-Grid-voi-Flexbox" class="headerlink" title="Phần 4: Kết hợp CSS Grid với Flexbox"></a>Phần 4: Kết hợp CSS Grid với Flexbox</h3><p>Trong phần này bạn sẽ học cách sử dụng Flexbox và Grid cùng nhau.</p><p>Hai module này đã thay đổi cách xử lý bố cục trong CSS. Và cách hiệu quả nhất là sử dụng cả 2 module cùng nhau.</p><p>Hãy đi vào chi tiết.</p><p>Với phần hiển thị thông tin chi tiết của album chúng ta sẽ sử dụng flexbox.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*hc80JsuD3IsxxwrAijFWzQ.png" alt=""></p><h4 id="Lam-sao-de-biet-cho-nao-se-su-dung-Flexbox"><a href="#Lam-sao-de-biet-cho-nao-se-su-dung-Flexbox" class="headerlink" title="Làm sao để biết chỗ nào sẽ sử dụng Flexbox?"></a>Làm sao để biết chỗ nào sẽ sử dụng Flexbox?</h4><p>Quy tắc chung là sử dụng Grid cho bố cục toàn bộ trang, còn Flexbox dành cho UI bên trong các phần tử con.</p><p>Một phần tử con có thể là một flex container. Một phần tử con của flex container cũng có thể là một grid container.</p><p>Tôi giả sử rằng bạn đã biết về <a href="https://medium.freecodecamp.org/understanding-flexbox-everything-you-need-to-know-b4013d4dc9af" target="_blank" rel="noopener">flexbox</a>.</p><p>Như thường lệ, hãy bắt đầu bằng html</p><p>Dưới đây là một div, với một danh sách các bài hát. Danh sách các bài hát có các đoạn có chứa tên bài hát, nghệ sĩ, thời lượng của bài hát và “catty cloud sync”.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main__body"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>1. One Dance<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Crake feat CatKid &amp;amp; Cyla<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>2:54<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>CATTY CLOUD SYNC<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>2. Panda<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Cattee<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>4:06<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>CATTY CLOUD SYNC<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>3. Can't Stop the Feeling!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Catin Cimberlake<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>3:56<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>CATTY CLOUD SYNC<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>4. Work From Home<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Cat Harmony feat Colla<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>3:34<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>CATTY CLOUD SYNC<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Đây là cái chúng ta có:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*lz7cE6DLCPeX-S6bwCVRJw.gif" alt=""></p><p><code>main__body</code> là một phần tử của grid. Chúng ta có thể biến nó thành flex container nếu điều đó hữu ích.</p><p>Trong trường hợp của chúng ta, mỗi thẻ div là con trực tiếp của <code>main__body</code> cần trở thành một flex container. Chúng chứa tên bài hát, nghệ sĩ, thời gian và “catty cloud sync”.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main__body</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bây giờ chia chiều rộng cho các phần tử con:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main__body</span> &gt; <span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">25%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1600/1*F7_nB62n6q9TV9aDJJ23tA.png" alt="https://codepen.io/ohansemmanuel/full/pwLEBL/"></p><p>Bạn sẽ đồng ý với tôi rằng tại thời điểm này, các yếu tố cần thiết cho bố cục đã hoàn thành.</p><p>Tuy nhiên, tôi đã thực hiện một vài thay đổi. Bạn có thể xem kết quả cuối cùng <a href="https://codepen.io/ohansemmanuel/full/QgxEqz/" target="_blank" rel="noopener">here</a></p><p>Bạn sẽ nhận thấy rằng tôi vẫn để trống footer. Đó là bài tập cho bạn. Lời khuyên của tôi là sử dụng flexbox. Nó sẽ giúp bạn hiểu cách cả hai module này làm việc cùng nhau.</p><hr><p>Với một vài thuộc tính của grid, bạn đã xây dựng một bố cục thực sự. Khá ấn tượng. Bạn cũng học được kỹ năng vô giá khi kết hợp CSS Grid với Flexbox.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Gioi-thieu&quot;&gt;&lt;a href=&quot;#Gioi-thieu&quot; class=&quot;headerlink&quot; title=&quot;Giới thiệu&quot;&gt;&lt;/a&gt;Giới thiệu&lt;/h3&gt;&lt;p&gt;Đây KHÔNG phải là một bài viết để học “mọi thứ” về css grid.&lt;br&gt;Bài viết này hướng đến những người muốn có kết quả nhanh chóng và hiệu quả.&lt;br&gt;Trong bốn phần của bài viết này, tôi sẽ chỉ cho bạn 20% cần thiết để làm được 80% những gì bạn có thể làm với CSS Grid layout.&lt;/p&gt;
&lt;p&gt;Hãy cùng tìm hiểu!&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://nthung2112.github.io/tags/css/"/>
    
      <category term="grid" scheme="http://nthung2112.github.io/tags/grid/"/>
    
  </entry>
  
  <entry>
    <title>Tìm hiểu về Proxy trong ES6</title>
    <link href="http://nthung2112.github.io/2018/07/Tim-hieu-ve-Proxy-trong-ES6.html"/>
    <id>http://nthung2112.github.io/2018/07/Tim-hieu-ve-Proxy-trong-ES6.html</id>
    <published>2018-07-08T08:57:00.000Z</published>
    <updated>2018-07-08T08:59:57.977Z</updated>
    
    <content type="html"><![CDATA[<p>Nói về ES6 có lẽ chúng ta đã quá quen thuộc với các khái niệm như const và let, hàm mũi tên, class hay <a href="https://ehkoo.com/bai-viet/tong-hop-tinh-nang-noi-bat-es6" target="_blank" rel="noopener">những tính năng hay ho hấp dẫn khác</a>. Ngoài ra, ES6 cũng kèm theo những tính năng ít người biết hơn nhưng cũng rất thú vị, và một trong số đó là Proxy.<br><a id="more"></a></p><h3 id="Proxy-la-gi"><a href="#Proxy-la-gi" class="headerlink" title="Proxy là gì?"></a>Proxy là gì?</h3><p>Proxy là một class được giới thiệu từ ES6, cho phép bạn can thiệp và thay đổi hành vi của một đối tượng (object). Các hành vi này bao gồm: truy xuất/thiết lập thuộc tính của một đối tượng, thay đổi prototype, gọi hàm, khởi tạo đối tượng bằng từ khóa new… Để hiểu rõ hơn về khái niệm, bạn có thể xem qua ví dụ sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> u = &#123; <span class="attr">name</span>: <span class="string">'Công Tằng Tôn Nữ Tạ Thị Tòn Ten'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thiết lập proxy cho đối tượng `u`</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(u, &#123;</span><br><span class="line">  <span class="comment">// `get` là một trap, sẽ được gọi khi truy xuất đến thuộc tính</span></span><br><span class="line">  <span class="comment">// của đối tượng</span></span><br><span class="line">  get(target, prop, receiver) &#123;</span><br><span class="line">    <span class="comment">// Thay đổi hành vi khi truy xuất đến một thuộc tính: Nếu là</span></span><br><span class="line">    <span class="comment">// chuỗi, chuyển sang chữ hoa</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target[prop] === <span class="string">'string'</span>) <span class="keyword">return</span> target[prop].toUpperCase()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target[prop]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// CÔNG TẰNG TÔN NỮ TẠ THỊ TÒN TEN</span></span><br><span class="line">p.email = <span class="string">'ta.thi@ton.ten'</span></span><br><span class="line"><span class="built_in">console</span>.log(p.email) <span class="comment">// TA.THI@TON.TEN</span></span><br></pre></td></tr></table></figure><p>Chúng ta có thể áp dụng Proxy cho bất cứ object nào trong JavaScript, kể cả mảng, hàm hay một proxy khác.</p><blockquote><p><strong>Có thể bạn thừa biết</strong><br>Một hàm trong JavaScript là một thể hiện của lớp Function.</p></blockquote><p>Hiện tại Proxy đã được hỗ trợ bởi các trình duyệt xịn (nghĩa là không có IE đó) và node.js v6 trở đi.</p><blockquote><p><strong>Tin vắn</strong><br>Phiên bản 5.0 của <a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">MobX</a> đã hoàn toàn sử dụng ES6 Proxy.</p></blockquote><h3 id="Su-dung-nhu-the-nao"><a href="#Su-dung-nhu-the-nao" class="headerlink" title="Sử dụng như thế nào?"></a>Sử dụng như thế nào?</h3><p>Trước hết, hãy xem qua những thuật ngữ thông dụng khi làm việc với Proxy:</p><ul><li><strong>target</strong>: là đối tượng sẽ được áp dụng proxy vào</li><li><strong>traps</strong>: là những phương thức giúp bạn thay đổi hành vi của đối tượng</li><li><strong>handler</strong>: là một object chứa các traps, được đưa vào hàm dựng của lớp Proxy</li></ul><p>Để khởi tạo proxy, bạn dùng new Proxy(target, handler) như bên dưới:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><p>Chúng ta sẽ cùng đi qua những traps thông dụng.</p><h4 id="handler-get-va-handler-set"><a href="#handler-get-va-handler-set" class="headerlink" title="handler.get() và handler.set()"></a>handler.get() và handler.set()</h4><p>Như tên gọi, handler.get() và handler.set() cho phép bạn can thiệp khi truy xuất và thiết lập giá trị một thuộc tính của đối tượng.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// property: tên của thuộc tính được truy xuất</span></span><br><span class="line"><span class="comment">// receiver: đối tượng sau khi đã được gắn proxy</span></span><br><span class="line">handler.get(target, property, receiver)</span><br><span class="line"></span><br><span class="line"><span class="comment">// value: giá trị sẽ được thiết lập cho thuộc tính</span></span><br><span class="line"><span class="comment">// handler.set() phải trả về một giá trị boolean. Nếu là true thì xem như thiết lập</span></span><br><span class="line"><span class="comment">// thành công, ngược lại nếu là false thì xảy ra lỗi TypeError.</span></span><br><span class="line">handler.set(target, property, value, receiver)</span><br></pre></td></tr></table></figure><p>Chúng ta có thể dùng handler.set() để kiểm tra tính đúng đắn dữ liệu (data validation) trên thuộc tính của đối tượng. Chẳng hạn như:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> u = &#123; <span class="attr">age</span>: <span class="literal">null</span> &#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(u, &#123;</span><br><span class="line">  set(target, prop, val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'age'</span> &amp;&amp; <span class="keyword">typeof</span> val !== <span class="string">'number'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Age must be a number'</span>)</span><br><span class="line"></span><br><span class="line">    target[prop] = val</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.age = <span class="string">'10'</span> <span class="comment">// Error: Age must be a number</span></span><br><span class="line">p.age = <span class="number">10</span>   <span class="comment">// OK!</span></span><br></pre></td></tr></table></figure><h4 id="handler-defineProperty-va-handler-deleteProperty"><a href="#handler-defineProperty-va-handler-deleteProperty" class="headerlink" title="handler.defineProperty() và handler.deleteProperty()"></a>handler.defineProperty() và handler.deleteProperty()</h4><p>handle.defineProperty(target, property, descriptor) là trap được kích hoạt khi sử dụng Object.defineProperty(). Phương thức này đòi hỏi phải trả về một giá trị boolean. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;, &#123;</span><br><span class="line">  defineProperty(target, property, descriptor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property.startsWith(<span class="string">'_'</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Properties starting with _ are not allowed'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperty(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p._hello = <span class="number">1</span> <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(p, <span class="string">'_hello'</span>, &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;) <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">p.hello = <span class="number">1</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(p, <span class="string">'hello'</span>, &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>descriptor là một object quy định hành vi của thuộc tính được khai báo. Chi tiết về descriptor bạn có thể xem ở trang <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">MDN</a> hoặc hóng bài viết tiếp theo của Ehkoo.</p></blockquote><p>handle.deleteProperty(target, property) sẽ được kích hoạt khi thực hiện delete một thuộc tính. Phương thức này phải trả về true nếu quá trình xóa được chấp nhận. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;, &#123;</span><br><span class="line">  deleteProperty(target, property) &#123;</span><br><span class="line">    <span class="keyword">delete</span> target[property]</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;property&#125;</span> was removed`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p.foo <span class="comment">// foo was removed</span></span><br><span class="line"><span class="keyword">delete</span> p.bar <span class="comment">// bar was removed</span></span><br></pre></td></tr></table></figure><h4 id="handler-has"><a href="#handler-has" class="headerlink" title="handler.has()"></a>handler.has()</h4><p>handler.has() sẽ được kích hoạt khi sử dụng in. Phương thức này cũng đòi hỏi phải trả về một giá trị boolean. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; <span class="attr">_foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;, &#123;</span><br><span class="line">  has(target, property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property.startsWith(<span class="string">'_'</span>)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> property <span class="keyword">in</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'bar'</span> <span class="keyword">in</span> p) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'_foo'</span> <span class="keyword">in</span> p) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="handler-apply"><a href="#handler-apply" class="headerlink" title="handler.apply()"></a>handler.apply()</h4><p>handler.apply(target, thisArg, args) là trap dành cho các hàm, sẽ được khởi động khi hàm được gọi. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, &#123;</span><br><span class="line">  apply(target, thisArg, args) &#123;</span><br><span class="line">    <span class="keyword">const</span> [a, b] = args</span><br><span class="line">    <span class="keyword">return</span> target.call(thisArg, a * <span class="number">2</span>, b * <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h4 id="handler-construct"><a href="#handler-construct" class="headerlink" title="handler.construct()"></a>handler.construct()</h4><p>handler.construct(target, args) là trap sẽ được gọi khi khởi tạo đối tượng bằng new. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(username) &#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PUser = <span class="keyword">new</span> <span class="built_in">Proxy</span>(User, &#123;</span><br><span class="line">  construct(target, args) &#123;</span><br><span class="line">    <span class="keyword">const</span> [username] = args</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> target(username.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> u = <span class="keyword">new</span> PUser(<span class="string">'pikalong'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(u.username) <span class="comment">// PIKALONG</span></span><br></pre></td></tr></table></figure><h4 id="handler-getPrototypeOf-va-handler-setPrototypeOf"><a href="#handler-getPrototypeOf-va-handler-setPrototypeOf" class="headerlink" title="handler.getPrototypeOf() và handler.setPrototypeOf()"></a>handler.getPrototypeOf() và handler.setPrototypeOf()</h4><p>Như tên gọi, hai traps này sẽ được kích hoạt khi sử dụng Object.getPrototypeOf() và Object.setPrototypeOf() trên đối tượng.</p><blockquote><p><strong>Ghi chú</strong><br>Bên cạnh những traps được giới thiệu ở đây, còn có một số traps khác mà bạn có thể tham khảo ở trang <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">MDN</a>.</p></blockquote><h3 id="Viet-thu-nao"><a href="#Viet-thu-nao" class="headerlink" title="Viết thử nào"></a>Viết thử nào</h3><p>Bạn có dùng thử <a href="http://www.chaijs.com/" target="_blank" rel="noopener">chai</a> chưa? Thư viện này hỗ trợ viết kiểm chứng (assertion) theo phong cách BDD/TDD, giống như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chai.expect</span></span><br><span class="line">expect(foo).to.be.a(<span class="string">'string'</span>)</span><br><span class="line">expect(foo).to.equal(<span class="string">'bar'</span>)</span><br><span class="line">expect(foo).to.have.lengthOf(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hoặc chai.should</span></span><br><span class="line">foo.should.be.a(<span class="string">'string'</span>)</span><br><span class="line">foo.should.equal(<span class="string">'bar'</span>)</span><br><span class="line">foo.should.have.lengthOf(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>Cách thiết kế này rõ ràng giúp cho chương trình trở nên mạch lạc và dễ theo dõi vì câu kiểm chứng được viết như một câu tiếng Anh vậy. Chúng ta có thể bắt chước chai và thử viết một lớp Thing có những khả năng sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Khởi tạo một đối tượng của lớp Thing với tên là "Phương"</span></span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Thing(<span class="string">'Phương'</span>)</span><br><span class="line">t.name <span class="comment">// 'Phương'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Khai báo các thuộc tính boolean</span></span><br><span class="line">t.is_a.singer</span><br><span class="line">t.is_not_a.man</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kiểm tra thuộc tính</span></span><br><span class="line">t.is_a_singer <span class="comment">// true</span></span><br><span class="line">t.is_a_man <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Khai báo phương thức</span></span><br><span class="line">t.can.sing(<span class="string">'Yêu hay không yêu không yêu hay yêu nói một lời'</span>)</span><br><span class="line">t.sing() <span class="comment">// Phương sings: Yêu hay không yêu không yêu hay yêu nói một lời</span></span><br></pre></td></tr></table></figure><blockquote><p>Đây là một phần trong bài <a href="https://www.codewars.com/kata/5571d9fc11526780a000011a" target="_blank" rel="noopener">The builder of things</a> được lấy từ Codewars. Sau khi đọc hết bài viết này thì bạn hãy thử giải thử thách trên xem sao, bảo đảm kết quả không làm bạn thất vọng đâu.<br>Ngoài ra nếu bạn có tham gia Codewars thì đừng quên gia nhập clan Ehkoo nhé ;)</p></blockquote><p>Đầu tiên, để truy xuất thuộc tính name, chúng ta có thể nghĩ đến giải pháp “vô cùng rõ ràng và ngây thơ” sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đoạn code trên hoàn toàn hợp lý, nhưng sẽ không giúp chúng ta giải quyết những yêu cầu tiếp theo của bài toán. Phân tích kỹ một chút ta có thể thấy việc dùng Proxy là không thể tránh khỏi. Do đó để cài đặt t.name bằng Proxy, ta có thể viết lại thành:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; name &#125;</span><br><span class="line">    <span class="keyword">return</span> proxify(<span class="keyword">this</span>, <span class="keyword">this</span>.state)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hàm proxify() nhận vào một target và một object chứa state.</span></span><br><span class="line"><span class="comment">// State này sẽ được sử dụng để giải quyết những yêu cầu tiếp theo.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxify</span>(<span class="params">target, state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    get(target, prop, receiver) &#123;</span><br><span class="line">      <span class="comment">// Nếu truy xuất đến thuộc tính `name`, lấy ra dữ liệu trong state</span></span><br><span class="line">      <span class="keyword">if</span> (prop === <span class="string">'name'</span>) <span class="keyword">return</span> state[prop]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Còn lại thì sử dụng hành vi mặc định</span></span><br><span class="line">      <span class="keyword">return</span> target[prop]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Thing(<span class="string">'Phương'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(t.name) <span class="comment">// Phương</span></span><br><span class="line"><span class="built_in">console</span>.log(t.age)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>Vậy là tạm ổn phần lấy name. Chúng ta xem tiếp đến hành vi tiếp theo của lớp Thing.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t.is_a.singer</span><br><span class="line">t.is_not_a.man</span><br><span class="line"></span><br><span class="line">t.is_a_singer <span class="comment">// true</span></span><br><span class="line">t.is_a_man <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Hành vi này cho phép khai báo thuộc tính boolean trên đối tượng bằng cách sử dụng is_a cho giá trị true và is_not_a cho giá trị false. Sau đó ta có thể kiểm tra thuộc tính bằng cách truy xuất đến is_a_${prop}. Để cài đặt hành vi này, chúng ta có thể làm như sau:</p><ol><li>Khai báo thêm một khóa booleans: {} cho state. Khóa này đóng vai trò như một bảng tham chiếu giữa tên thuộc tính boolean và giá trị của nó, chẳng hạn như { singer: true, man: false }. Ngoài ra chúng ta cũng cần thêm vào state một cờ inBooleanMode: false.</li><li>Nếu prop là is_a hoặc is_not_a, bật cờ inBooleanMode: true</li><li>Nếu cờ inBooleanMode đang bật, thuộc tính tiếp theo sẽ là thuộc tính boolean. Do đó ta cập nhật booleans của state thành { …booleans, [prop]: state.booleanValue }</li></ol><p><img src="https://res.cloudinary.com/duqeezi8j/image/upload/v1530343401/ehkoo/proxy_iah0182.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enterBooleanMode</span>(<span class="params">receiver, state, booleanValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Bật cờ</span></span><br><span class="line">  state.inBooleanMode = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// Lưu lại giá trị boolean tùy thuộc vào là `is_a` hay `is_not_a`</span></span><br><span class="line">  state.booleanValue = booleanValue</span><br><span class="line">  <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setBoolean</span>(<span class="params">receiver, state, prop</span>) </span>&#123;</span><br><span class="line">  state.booleans = &#123;...state.booleans, [prop]: state.booleanValue &#125;</span><br><span class="line">  <span class="comment">// Reset lại các giá trị</span></span><br><span class="line">  state.inBooleanMode = <span class="literal">false</span></span><br><span class="line">  state.booleanValue = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get(target, prop, receiver) &#123;</span><br><span class="line">  <span class="comment">// Đặt ở đây để tránh trường hợp gọi t.is_a.is_a</span></span><br><span class="line">  <span class="keyword">if</span> (state.inBooleanMode) <span class="keyword">return</span> setBoolean(<span class="keyword">this</span>, state, prop)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prop === <span class="string">'name'</span>) <span class="keyword">return</span> state[prop]</span><br><span class="line">  <span class="keyword">if</span> (prop === <span class="string">'is_a'</span>) <span class="keyword">return</span> enterBooleanMode(receiver, state, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">if</span> (prop === <span class="string">'is_not_a'</span>) <span class="keyword">return</span> enterBooleanMode(receiver, state, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">if</span> (prop.startsWith(<span class="string">'is_a_'</span>)) <span class="keyword">return</span> state.booleans[prop.replace(<span class="string">'is_a_'</span>, <span class="string">''</span>)]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target[prop]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kiểm tra thử.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Thing(<span class="string">'Phương'</span>)</span><br><span class="line"></span><br><span class="line">t.is_a.singer</span><br><span class="line">t.is_not_a.man</span><br><span class="line"><span class="built_in">console</span>.log(t.is_a_singer) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(t.is_a_man)    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Để cài đặt hành vi tiếp theo, chúng ta cũng có thể làm tương tự như khai báo thuộc tính boolean bằng cách đặt thêm một cờ inDefineMethodMode và bật/tắt cờ này tương ứng. Bên cạnh đó chúng ta cũng đặt thêm một khóa methods trong state để chứa các phương thức được khai báo thông qua can.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">get(target, prop, receiver) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (state.inDefineMethodMode) <span class="keyword">return</span> setMethod(receiver, state, prop)</span><br><span class="line">  <span class="keyword">if</span> (prop === <span class="string">'can'</span>) <span class="keyword">return</span> enterDefineMethodMode(receiver, state)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lấy ra phương thức được khai báo bởi `t.can`</span></span><br><span class="line">  <span class="keyword">if</span> (state.methods[prop]) <span class="keyword">return</span> state.methods[prop]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ở đây có một chút khó khăn. Có thể thấy trong t.can.sing(phrase), sing phải là một hàm. Do đó giá trị trả về của setMethod() có thể được viết như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setMethod</span>(<span class="params">receiver, state, prop</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Đừng quên tắt cờ sau khi cài đặt method</span></span><br><span class="line">  state.inDefineMethodMode = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">phrase</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Tạo ra hàm mới</span></span><br><span class="line">    <span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;state.name&#125;</span> <span class="subst">$&#123;prop&#125;</span>: <span class="subst">$&#123;phrase&#125;</span>`</span></span><br><span class="line">    <span class="comment">// Lưu vào danh sách các phương thức được khai báo bởi `t.can`</span></span><br><span class="line">    state.methods = &#123; ...state.methods, [prop]: f &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.can.sing(<span class="string">'Yêu hay không yêu không yêu hay yêu nói một lời'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(t.sing()) <span class="comment">// Phương sing: Yêu hay không yêu không yêu hay yêu nói một lời</span></span><br></pre></td></tr></table></figure><p>Vậy là được rồi. Chúng ta chỉ còn một bước nữa là chia “sing” sang ngôi thứ ba số ít “sings”, nhưng thôi cái này để bạn tự làm nhé. Bạn có thể xem đầy đủ mã nguồn <a href="https://repl.it/repls/MiniCornyEditors" target="_blank" rel="noopener">ở đây</a>.</p><h3 id="Ket"><a href="#Ket" class="headerlink" title="Kết"></a>Kết</h3><p>Proxy là một công cụ mạnh mẽ, giúp cho việc lập trình meta trong JavaScript trở nên dễ dàng hơn. Hi vọng bài viết này đã giúp bạn hiểu rõ hơn về Proxy và có thể ứng dụng nó trong công việc.</p><h4 id="Tham-khao"><a href="#Tham-khao" class="headerlink" title="Tham khảo"></a>Tham khảo</h4><p><em>Proxy - MDN</em> - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p><p><em>ES6 Proxies in Depth</em> - <a href="https://ponyfoo.com/articles/es6-proxies-in-depth" target="_blank" rel="noopener">https://ponyfoo.com/articles/es6-proxies-in-depth</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nói về ES6 có lẽ chúng ta đã quá quen thuộc với các khái niệm như const và let, hàm mũi tên, class hay &lt;a href=&quot;https://ehkoo.com/bai-viet/tong-hop-tinh-nang-noi-bat-es6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;những tính năng hay ho hấp dẫn khác&lt;/a&gt;. Ngoài ra, ES6 cũng kèm theo những tính năng ít người biết hơn nhưng cũng rất thú vị, và một trong số đó là Proxy.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Tìm hiểu Map và Set trong Javascript</title>
    <link href="http://nthung2112.github.io/2018/07/Tim-Hieu-Map-Va-Set-Trong-Javascript.html"/>
    <id>http://nthung2112.github.io/2018/07/Tim-Hieu-Map-Va-Set-Trong-Javascript.html</id>
    <published>2018-07-08T08:12:00.000Z</published>
    <updated>2018-07-08T08:57:25.234Z</updated>
    
    <content type="html"><![CDATA[<p>Được giới thiệu từ ES6, Map, Set, WeakMap, và WeakSet là những cấu trúc dữ liệu giúp thao tác trên tập hợp. Bài viết này sẽ giới thiệu cách hoạt động cũng như các ứng dụng của chúng.<br><a id="more"></a></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><em>Map</em>, <em>mảng kết hợp</em> (associate arrays) hay <em>từ điển</em> (dictionary/dict) là những thuật ngữ dùng để chỉ một cấu trúc dữ liệu, cho phép bạn ánh xạ từ một <em>khóa</em> (key) tương ứng với một <em>giá trị</em> (value). Trong JavaScript, chúng ta có thể sử dụng <em>object</em> để thể hiện cấu trúc này.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dict = &#123;</span><br><span class="line">  hello: <span class="string">'Xin chào'</span>,</span><br><span class="line">  bye: <span class="string">'Tạm biệt'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dict[<span class="string">'hello'</span>]) <span class="comment">// Xin chào</span></span><br></pre></td></tr></table></figure><p>Tuy nhiên, nếu dùng <em>object</em> thì bạn chỉ có thể dùng <em>chuỗi</em> làm <em>khóa</em>. Ngoài ra, cách này cũng có một số <a href="http://speakingjs.com/es5/ch17.html#_pitfalls_using_an_object_as_a_map" target="_blank" rel="noopener">hạn chế khác</a>. Lớp Map do ES6 giới thiệu sẽ giúp giải quyết những vấn đề này. Với Map, bạn có thể sử dụng bất cứ dạng dữ liệu nào để làm <em>khóa</em>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">dict</span><br><span class="line"> .set(<span class="string">'foo'</span>, <span class="number">123</span>)</span><br><span class="line"> .set(obj, <span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line">dict.get(<span class="string">'foo'</span>) <span class="comment">// 123</span></span><br><span class="line">dict.get(obj)   <span class="comment">// 'hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lấy giá trị của một khóa không tồn tại</span></span><br><span class="line">dict.get(<span class="string">'wat'</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>Bạn cũng có thể truyền vào hàm dựng của Map một mảng các cặp giá trị dạng [key, value], ví dụ như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="number">123</span>],</span><br><span class="line">  [obj, <span class="string">'hello world'</span>]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>Như đã nói ở trên, bạn có thể dùng bất cứ dạng dữ liệu gì để làm <em>khóa</em> cho Map, kể cả mảng, object, hàm, hay NaN.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">dict</span><br><span class="line"> .set(arr, <span class="string">'an array'</span>)</span><br><span class="line"> .set(f, <span class="string">'a function'</span>)</span><br><span class="line"> .set(<span class="literal">NaN</span>, <span class="string">'not a number'</span>)</span><br></pre></td></tr></table></figure><p>Bản thân Map sử dụng phương thức so sánh <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#A_model_for_understanding_equality_comparisons" target="_blank" rel="noopener">SameValueZero</a> để tìm <em>khóa</em> và giá trị tương ứng. SameValueZero hoạt động tương tự như ===, nhưng xem các giá trị NaN bằng nhau, cũng như +0 bằng -0.</p><blockquote><p><strong>Đố-hẻm-vui</strong>: Đố bạn kết quả của các biểu thức sau là gì?</p><p>NaN == NaN<br>NaN === NaN<br>Object.is(NaN, NaN)</p></blockquote><p>Do SameValueZero nên hai <em>object</em> khác nhau sẽ là hai <em>khóa</em> riêng biệt.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">dict.set(o1, <span class="string">'Ô Một'</span>).set(o2, <span class="string">'Ô Hai'</span>)</span><br><span class="line">dict.get(o2) <span class="comment">// Ô Hai</span></span><br><span class="line">dict.get(&#123;&#125;) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>Nếu trong map đã có sẵn <em>khóa</em>, dữ liệu mới sẽ bị ghi đè lên.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(<span class="string">'foo'</span>, <span class="number">1</span>)</span><br><span class="line">m.set(<span class="string">'foo'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">m.get(<span class="string">'foo'</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>Để duyệt qua các <em>khóa</em> và giá trị trong Map, bạn có thể dùng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="number">1</span>], [<span class="string">'bar'</span>, <span class="number">2</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">dict.keys()    <span class="comment">// ['foo', 'bar']</span></span><br><span class="line">dict.values()  <span class="comment">// [1, 2]</span></span><br><span class="line">dict.entries() <span class="comment">// [ ['foo', 1], ['bar', 2] ]</span></span><br><span class="line">dict.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> has <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;, <span class="comment">/* thisArgs bạn có thể truyền vào tham chiếu cho `this` ở đây */</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sử dụng for..of cùng với destructuring</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> dict) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> has <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bạn cũng có thể dùng toán tử spread … với Map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="number">1</span>], [<span class="string">'bar'</span>, <span class="number">2</span>]</span><br><span class="line">])</span><br><span class="line"><span class="built_in">console</span>.log([</span><br><span class="line">  [<span class="string">'wut'</span>, <span class="number">3</span>],</span><br><span class="line">  ...dict</span><br><span class="line">])</span><br><span class="line"><span class="comment">// [ [ 'wut', 3 ], [ 'foo', 1 ], [ 'bar', 2 ] ]</span></span><br></pre></td></tr></table></figure><p>Một số thao tác khác với Map.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="number">1</span>], [<span class="string">'bar'</span>, <span class="number">2</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Đếm số cặp giá trị trong map</span></span><br><span class="line">dict.size <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kiểm tra trong map có khóa "foo" hay không</span></span><br><span class="line">dict.has(<span class="string">'foo'</span>) <span class="comment">// true</span></span><br><span class="line">dict.has(<span class="string">'wut'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Xóa một khóa, trả về boolean nếu thành công, false nếu thất bại</span></span><br><span class="line">dict.delete(<span class="string">'wut'</span>) <span class="comment">// false</span></span><br><span class="line">dict.delete(<span class="string">'foo'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Xóa hết các cặp giá trị của map</span></span><br><span class="line">dict.clear()</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tại sao lại là size mà không phải length?</strong><br>Một số độc giả tinh ý sẽ nhận ra chúng ta dùng size thay vì length để đếm số cặp giá trị trong map. Lý do là vì: length dùng cho những chuỗi có thể index (đánh số) được, ví dụ với <em>mảng</em> ta có thể arr[3]. Ngược lại, size dành cho những cấu trúc không có thứ tự như Map và Set.</p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set là tập hợp các giá trị không bị trùng lặp, nghĩa là trong một <em>set</em> không thể có hai giá trị bằng nhau.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">set</span><br><span class="line">  .add(<span class="string">'red'</span>)</span><br><span class="line">  .add(<span class="string">'blue'</span>)</span><br><span class="line">  .add(<span class="string">'sweet'</span>)</span><br><span class="line">  .add(<span class="string">'you'</span>)</span><br><span class="line"></span><br><span class="line">s.size <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>Bạn cũng có thể truyền một <em>mảng</em> vào hàm dựng của Set.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'sweet'</span>, <span class="string">'red'</span>, <span class="string">'you'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(s) <span class="comment">// Set (4) &#123;'red', 'blue', 'sweet', 'you'&#125;</span></span><br></pre></td></tr></table></figure><p>Bạn cũng có thể thấy giá trị ‘red’ bị trùng lặp đã được loại bỏ. Chúng ta có thể áp dụng Set để tạo ra một <em>mảng</em> chứa những phần tử duy nhất.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'sweet'</span>, <span class="string">'red'</span>, <span class="string">'you'</span>]</span><br><span class="line"><span class="keyword">const</span> b = [...new <span class="built_in">Set</span>(a)]</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [ 'red', 'blue', 'sweet', 'you' ]</span></span><br></pre></td></tr></table></figure><p>Cũng tương tự như Map, Set sử dụng SameZeroValue để so sánh các phần tử với nhau.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="literal">NaN</span>, &#123;&#125;, obj])</span><br><span class="line">s.has(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">s.has(obj) <span class="comment">// true</span></span><br><span class="line">s.has(&#123;&#125;)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Để duyệt qua các phần tử của Set, bạn có thể dùng các phương thức như với Map.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vì Set không có khái niệm keys nên kết quả của `s.keys()` và `s.values()` là như nhau.</span></span><br><span class="line">s.keys()</span><br><span class="line">s.values()</span><br><span class="line"></span><br><span class="line">s.entries()</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, setReference</span>) </span>&#123;</span><br><span class="line">&#125;, thisArg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Một số thao tác khác trên Set.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Xóa một phần tử trong set</span></span><br><span class="line">s.delete(<span class="number">3</span>) <span class="comment">// Set (4) &#123;1, 2, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Xóa hết phần tử trong set</span></span><br><span class="line">s.clear()</span><br></pre></td></tr></table></figure><h3 id="WeakMap-va-WeakSet"><a href="#WeakMap-va-WeakSet" class="headerlink" title="WeakMap và WeakSet"></a>WeakMap và WeakSet</h3><p>ES6 cũng giới thiệu hai lớp WeakMap và WeakSet. So với Map, các <em>khóa</em> của WeakMap bắt buộc phải là <em>object</em>, và chúng sẽ bị giải phóng khỏi bộ nhớ (garbage-collecting – “hốt rác”) đầu tiên nếu không có tham chiếu nào.</p><p>WeakMap có các phương thức tương tự như Map, ngoại trừ việc bạn không thể duyệt qua WeakMap bằng .keys(), .values(), .entries() hay for..of. Bạn cũng không thể .clear(), vì lý do an toàn dữ liệu.</p><p>Một ứng dụng của WeakMap là dùng để chứa dữ liệu private mà không gây ra rò rỉ bộ nhớ.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privates = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123; <span class="attr">phoneNumber</span>: <span class="number">123</span> &#125;</span><br><span class="line">    privates.set(<span class="keyword">this</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPhoneNumber() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = privates.get(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> data.phoneNumber</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> u = <span class="keyword">new</span> User()</span><br><span class="line"><span class="built_in">console</span>.log(u) <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(u.getPhoneNumber()) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>Tương tự như WeakMap, WeakSet cũng chỉ có thể chứa <em>object</em>, và nếu một phần tử trong WeakSet không có tham chiếu tới, nó sẽ bị giải phóng khỏi bộ nhớ.</p><h3 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h3><p>Với những cải tiến so với <em>object</em> thông thường, Map sẽ là công cụ hữu hiệu để lưu trữ dữ liệu dạng (khóa, giá trị). Trong khi đó, Set giúp bạn lưu trữ chuỗi dữ liệu mà không lo lắng về việc trùng lắp giá trị.</p><h4 id="Tham-khao"><a href="#Tham-khao" class="headerlink" title="Tham khảo"></a>Tham khảo</h4><p>[1] Axel Rauschmayer. ECMAScript 6: maps and sets. <a href="http://2ality.com/2015/01/es6-maps-sets.html" target="_blank" rel="noopener">http://2ality.com/2015/01/es6-maps-sets.html</a></p><p>[2] Keyed Collections - JavaScript | MDN. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections</a></p><p>[3] Steve Brownlee. WeakMap for JavaScript Private Data. <a href="https://www.stevebrownlee.com/weakmap-javascript-private-data/" target="_blank" rel="noopener">https://www.stevebrownlee.com/weakmap-javascript-private-data/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Được giới thiệu từ ES6, Map, Set, WeakMap, và WeakSet là những cấu trúc dữ liệu giúp thao tác trên tập hợp. Bài viết này sẽ giới thiệu cách hoạt động cũng như các ứng dụng của chúng.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Tổng hợp những tính năng ES6 nổi bật</title>
    <link href="http://nthung2112.github.io/2018/07/Tong-hop-nhung-tinh-nang-ES6-noi-bat.html"/>
    <id>http://nthung2112.github.io/2018/07/Tong-hop-nhung-tinh-nang-ES6-noi-bat.html</id>
    <published>2018-07-08T01:08:00.000Z</published>
    <updated>2018-07-08T09:09:59.591Z</updated>
    
    <content type="html"><![CDATA[<p>Việc hầu hết những tính năng hay ho hấp dẫn của ES6 đều đã được <a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">các trình duyệt hỗ trợ</a> quả là tin vui cho giới lập trình web. Nhờ nó mà nhà phát triển có thể xây dựng ứng dụng trực tiếp bằng ES6, không cần phải thông qua các công cụ chuyển đổi như <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a> hay <a href="https://buble.surge.sh/guide/" target="_blank" rel="noopener">Bublé</a> nữa, giúp ứng dụng trở nên gọn nhẹ hơn, giảm thiểu kích thước tập tin khi chuyển đến người sử dụng.</p><a id="more"></a><h3 id="Noi-dung"><a href="#Noi-dung" class="headerlink" title="Nội dung"></a>Nội dung</h3><ol><li>let và const</li><li>Hàm mũi tên (arrow functions)</li><li>Chuỗi bản mẫu (template strings)</li><li>Object chân phương (object literals)</li><li>Phân rã biến (destructuring)</li><li>Rest và Spread</li><li>Giá trị mặc định cho tham số</li><li>Lớp (class)</li><li>Promise</li></ol><h3 id="1-let-va-const"><a href="#1-let-va-const" class="headerlink" title="1. let và const"></a>1. let và const</h3><p>Ngày xa xưa ấy, bạn khai báo biến trong JavaScript bằng var, giống như ví dụ dưới đây.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFoo</span>(<span class="params">shouldDo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldDo) &#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(printFoo(<span class="literal">false</span>)) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(printFoo(<span class="literal">true</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>Biến được khai báo với var sẽ có tầm vực bên trong hàm gần nhất (function scope), và sẽ được đẩy lên đầu của tầm vực (hoisting). Đó là lý do tại sao foo lại có giá trị undefined trong dòng console.log đầu tiên.</p><p>ES6 giới thiệu let và const như hai cách khai báo biến mới, hỗ trợ tầm vực theo khối (block scope) và không thực hiện hoisting.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFoo</span>(<span class="params">shouldDo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldDo) &#123;</span><br><span class="line">    <span class="keyword">let</span> foo = <span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Value of foo in scope'</span>, foo) <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo is out of block scope'</span>, foo) <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(printFoo(<span class="literal">false</span>)) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(printFoo(<span class="literal">true</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>Điểm khác biệt giữa let và const là với const, bạn không thể gán giá trị mới cho biến sau khi khai báo, trong khi điều này lại có thể với let.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">2</span></span><br><span class="line">foo = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="number">2</span></span><br><span class="line">baz = <span class="number">3</span> <span class="comment">// Error: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>const mang ý nghĩa “constant” chứ không phải “immutability”. Nghĩa là với các biến là object hay array, bạn vẫn có thể thay đổi giá trị bên trong của chúng.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">2</span> &#125;</span><br><span class="line">obj.foo = <span class="number">5</span></span><br><span class="line">obj.bar = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; foo: 5, bar: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>]</span><br><span class="line">arr.push(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tuy vậy bạn không thể gán một đối tượng khác cho obj/arr</span></span><br><span class="line">obj = &#123; <span class="attr">baz</span>: <span class="number">4</span> &#125; <span class="comment">// Error: Assignment to constant variable.</span></span><br><span class="line">arr = [] <span class="comment">// Error: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> <a href="http://caniuse.com/#feat=let,const" target="_blank" rel="noopener">Được hỗ trợ</a> trên tất cả trình duyệt, kể cả IE11.<br><strong>Lời khuyên:</strong> Dùng const cho tất cả khai báo biến vì nó sẽ giúp bạn hạn chế trường hợp “vô tình” thay đổi giá trị của biến. Chỉ dùng let trong trường hợp bất khả kháng, và tránh xa var.</p></blockquote><h3 id="2-Ham-mui-ten"><a href="#2-Ham-mui-ten" class="headerlink" title="2. Hàm mũi tên"></a>2. Hàm mũi tên</h3><p>Hàm mũi tên – (fat) arrow functions – là một kiểu cú pháp rút gọn cho khai báo hàm trong JavaScript. Trước ES6, bạn khai báo một hàm trong JavaScript với từ khóa function.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hàm add() ở trên là syntactic sugar cho...</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“Syntactic sugar” là cú pháp làm cho ngôn ngữ trở nên dễ đọc và dễ hiểu hơn, theo kiểu nó làm cho ngôn ngữ “ngọt ngào hơn” (sweeter) với lập trình viên.</p></blockquote><p>Với hàm mũi tên trong ES6, bạn có thể viết lại thành:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bạn cũng có thể viết dưới dạng biểu thức (expression), hàm mũi</span></span><br><span class="line"><span class="comment">// tên sẽ tự động trả giá trị về (auto-return).</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br></pre></td></tr></table></figure><p>Hàm mũi tên cũng hữu dụng để giải quyết vấn đề muôn thuở trong JavaScript: “which this is this?” – khái niệm con trỏ this. Với ES5, bạn hay gặp trường hợp giống như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.count++)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> App()</span><br></pre></td></tr></table></figure><p>Trước ES6, mỗi khai báo hàm đều có một giá trị this tách biệt. Điều này làm cho đoạn code ở trên không hoạt động, vì this.count bên trong hàm của setInterval mang giá trị undefined. Cách giải quyết thông thường là đặt một biến self, that hay _this để giữ reference, hoặc sử dụng Function.prototype.bind.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(self.count++)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hoặc</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.count++)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setInterval(counter.bind(<span class="keyword">this</span>), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Với hàm mũi tên trong ES6, giá trị của this chính là this trong tầm vực gần nhất với nó (lexical this). Do đó chúng ta không cần phải khai báo biến tạm hay dùng .bind nữa.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.count++), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hàm mũi tên cũng rất hữu ích khi thao tác trên mảng và tiến hành chuyển đổi dữ liệu, giúp mã nguồn dễ đọc và rõ ràng hơn.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subtotal = products.filter(<span class="function"><span class="params">product</span> =&gt;</span> product.price &gt; <span class="number">500</span>).reduce(<span class="function">(<span class="params">acc, product</span>) =&gt;</span> acc + product.price, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ.<br><strong>Lời khuyên:</strong> Nếu có dùng đến this thì hàm mũi tên rất hữu dụng. Trường hợp không dùng thì…cũng hữu dụng luôn vì mã nguồn gọn gàng dễ đọc hơn. Với những trường hợp bạn muốn bao đóng giá trị của this chỉ gói gọn trong hàm của nó, dùng function.</p></blockquote><h3 id="3-Chuoi-ban-mau"><a href="#3-Chuoi-ban-mau" class="headerlink" title="3. Chuỗi bản mẫu"></a>3. Chuỗi bản mẫu</h3><p>Chuỗi bản mẫu (template strings) là chuỗi chân phương (string literals) nhưng cho phép đính kèm biểu thức. Nó cũng cho phép khai báo chuỗi trên nhiều dòng. Để sử dụng, bạn dùng ký tự backtick ` (dấu huyền). Ví dụ như là:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'John'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greetings = <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>,</span></span><br><span class="line"><span class="string">The result of 1 + 1 is <span class="subst">$&#123;<span class="number">1</span> + <span class="number">1</span>&#125;</span>, and the time is now <span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>.`</span></span><br></pre></td></tr></table></figure><p>Vì chuỗi bản mẫu cũng chỉ là chuỗi nên bạn có thể gọi đến những phương thức của String.prototype.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="string">`Hello World`</span>.substr(<span class="number">0</span>, <span class="number">5</span>).toUpperCase()</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ.<br><strong>Lời khuyên:</strong> Dùng chuỗi bản mẫu khi bạn cần gắn biểu thức hay chuỗi có nội dung ở nhiều dòng. Còn lại thì vẫn dùng chuỗi bình thường với ‘ hay “.</p></blockquote><h3 id="4-Object-chan-phuong-object-literals"><a href="#4-Object-chan-phuong-object-literals" class="headerlink" title="4. Object chân phương (object literals)"></a>4. Object chân phương (object literals)</h3><p>Object chân phương (object literals) chỉ đơn giản là khai báo một object trong JavaScript như bạn đã làm bao năm nay.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> birthYear = <span class="number">2000</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  birthYear: birthYear,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span>(<span class="params">currentYear</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentYear - obj.birthYear</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 nâng cấp object chân phương, cho phép bạn khai báo tắt thuộc tính của object với biến cùng tên, và khai báo phương thức cho object.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> birthYear = <span class="number">2000</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  birthYear, <span class="comment">// khai báo tắt birthYear: birthYear</span></span><br><span class="line">  getAge(currentYear) &#123;</span><br><span class="line">    <span class="comment">// `this` được gán trực tiếp vào bản thân object</span></span><br><span class="line">    <span class="keyword">return</span> currentYear - <span class="keyword">this</span>.birthYear</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Một lưu ý với this là khi bạn dùng hàm mũi tên, this sẽ được lấy từ this trong tầm vực gần với nó nhất, chứ không trỏ đến đối tượng hiện tại. Do đó…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  getAge: <span class="function"><span class="params">currentYear</span> =&gt;</span> currentYear - <span class="keyword">this</span>.birthYear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…sẽ không chạy như mong muốn, vì có thể this.birthYear mang giá trị undefined. Để sử dụng hàm mũi tên bạn phải viết lại như trước ES6.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  getAge: <span class="function"><span class="params">currentYear</span> =&gt;</span> currentYear - obj.birthYear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ngoài ra từ ES6 bạn cũng có thể khai báo thuộc tính cho object một cách linh động bằng cách sử dụng cú pháp [].</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> attr = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">const</span> year = <span class="number">2017</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; [attr]: <span class="number">1</span>, [<span class="string">'now'</span> + year]: <span class="string">'wow'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; foo: 1, now2017: 'wow' &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> Được hỗ trợ bởi tất cả trình duyệt<br><strong>Lời khuyên:</strong> Tính năng khai báo tắt thuộc tính của object cực ký hữu dụng =&gt; nên dùng. Nếu không bận tâm đến this thì bạn có thể dùng hàm mũi tên khi khai báo phương thức cho object để mã nguồn gọn gàng sạch đẹp hơn.</p></blockquote><h3 id="5-Phan-ra-bien"><a href="#5-Phan-ra-bien" class="headerlink" title="5. Phân rã biến"></a>5. Phân rã biến</h3><p>Phân rã biến – destructuring – theo mình là tính năng tiện dụng nhất của ES6. Tính năng này giúp bạn tách biến từ thuộc tính của đối tượng hay phần tử trong các đối tượng có thể duyệt với for, như mảng hoặc chuỗi. Chẳng hạn như:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = user</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// 'John'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> [first, second] = arr</span><br><span class="line"><span class="built_in">console</span>.log(first, second) <span class="comment">// 1, 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'Hello'</span></span><br><span class="line"><span class="keyword">const</span> [first, second] = str</span><br><span class="line"><span class="built_in">console</span>.log(first, second) <span class="comment">// 'H', 'e'</span></span><br></pre></td></tr></table></figure><p>Bạn cũng có thể phân rã các thuộc tính lồng nhau.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'John'</span>,</span><br><span class="line">    age: <span class="number">21</span>,</span><br><span class="line">    products: [&#123; <span class="attr">name</span>: <span class="string">'Creamy Crustacean Omelette'</span>, <span class="attr">price</span>: <span class="number">1200</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'Galdin Gratin'</span>, <span class="attr">price</span>: <span class="number">2300</span> &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [&#123; <span class="attr">products</span>: [&#123; price &#125;] &#125;] = userList</span><br><span class="line"><span class="built_in">console</span>.log(price) <span class="comment">// 1200</span></span><br></pre></td></tr></table></figure><p>Với mảng hay chuỗi, bạn có thể bỏ qua phần tử không mong muốn khi phân rã.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> [first, , third] = arr</span><br><span class="line"><span class="built_in">console</span>.log(first, third) <span class="comment">// 1, 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'Hello'</span></span><br><span class="line"><span class="keyword">const</span> [fst, , , , lst] = str</span><br><span class="line"><span class="built_in">console</span>.log(fst, lst) <span class="comment">// 'H', 'o'</span></span><br></pre></td></tr></table></figure><p>Phân rã biến cũng rất thường gặp khi bạn sử dụng ES6 module.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ.</p></blockquote><h3 id="6-Rest-va-spread"><a href="#6-Rest-va-spread" class="headerlink" title="6. Rest và spread"></a>6. Rest và spread</h3><p>Rest – phần còn lại – là một bổ sung của phân rã biến mảng ở trên. Bạn dùng ba dấu chấm … để biểu thị rest.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, second, ...others] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(first, second, others)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// [3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>Rest cũng được dùng khi khai báo hàm có thể nhận nhiều tham số</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'You passed'</span>, args)</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// You passed[ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="function">(<span class="params">x, y, ...rest</span>) =&gt;</span> <span class="built_in">console</span>.log(rest, x, y)</span><br></pre></td></tr></table></figure><p>Bạn lưu ý biến args ở trên khác với biến đặc biệt arguments vốn có sẵn bên trong hàm. arguments là một đối tượng giống Array, với những thuộc tính đặc biệt như callee, trong khi args chỉ là một mảng bình thường.</p><p>Spread – rải – là thao tác ngược lại với rest, giúp bạn kết hợp một mảng đã có sẵn thành mảng mới.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = [<span class="number">1</span>, <span class="number">2</span>, ...arr, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>Spread rất hữu ích để thay thế các thao tác thên mảng, như .concat().</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> head = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> tail = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log([...head, ...tail]) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>Spread cũng rất ngon khi thay thế cho Function.prototype.apply.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mul = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> x * y * z</span><br><span class="line"><span class="keyword">const</span> params = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thay thế cho</span></span><br><span class="line"><span class="comment">// mul.prototype.apply(null, params)</span></span><br><span class="line">mul(...params)</span><br></pre></td></tr></table></figure><p>Rest/spread cũng có thể hoạt động trên object, tương tự như Object.assign(), nhưng bạn lưu ý tính năng vẫn đang được <a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">đề xuất</a> (proposal). Về phía trình duyệt, có Firefox và Chrome là hỗ trợ, trong khi Edge và Safari hoàn toàn không hoạt động.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">'John'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">const</span> userWithAgeEs5 = <span class="built_in">Object</span>.assign(&#123;&#125;, user, &#123; <span class="attr">age</span>: <span class="number">21</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thời đại mới với spread</span></span><br><span class="line"><span class="keyword">const</span> userWithAge = &#123; ...user, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(userWithAge) <span class="comment">// &#123; name: 'John', age: 21 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Và rest</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, ...others &#125; = userWithAge</span><br><span class="line"><span class="built_in">console</span>.log(others) <span class="comment">// &#123; age: 21 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ rest và spread với mảng hay chuỗi. Với spread object, Edge và Safari chưa hỗ trợ.</p></blockquote><h3 id="7-Gia-tri-mac-dinh-cho-tham-so"><a href="#7-Gia-tri-mac-dinh-cho-tham-so" class="headerlink" title="7. Giá trị mặc định cho tham số"></a>7. Giá trị mặc định cho tham số</h3><p>Khi khai báo hàm, tính năng này cho phép bạn thiết lập giá trị mặc định của tham số khi nó không được truyền giá trị hoặc có giá trị undefined.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDiscountedPrice</span>(<span class="params">price, discountRate = <span class="number">0.1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * (<span class="number">1</span> + discountRate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dĩ nhiên bạn có thể dùng bất cứ giá trị nào làm giá trị mặc định.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processItems</span>(<span class="params">items = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.map(transformItemData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hoặc dùng biến</span></span><br><span class="line"><span class="keyword">const</span> DISCOUNT_RATE = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">const</span> getDiscountedPrice = <span class="function">(<span class="params">price, discountRate = DISCOUNT_RATE</span>) =&gt;</span> price * (<span class="number">1</span> + discountRate)</span><br></pre></td></tr></table></figure><h3 id="8-Lop-class"><a href="#8-Lop-class" class="headerlink" title="8. Lớp (class)"></a>8. Lớp (class)</h3><p>Với ES5, chúng ta sử dụng function để tạo lớp và thêm các phương thức vào lớp bằng cách mở rộng prototype.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(f.add(<span class="number">2</span>)) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>ES6 mang đến cú pháp mới giúp tạo lớp trực tiếp và dễ dàng hơn.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Khai báo phương thức tĩnh (static method)</span></span><br><span class="line">  <span class="keyword">static</span> whoAmI() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'I am a Foo class'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Foo(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(f.add(<span class="number">2</span>)) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo.whoAmI()) <span class="comment">// I am a Foo class</span></span><br></pre></td></tr></table></figure><p>Bạn cũng có thể kế thừa từ lớp khác bằng từ khóa extends.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="comment">// Gọi đến hàm dựng của lớp cha</span></span><br><span class="line">    <span class="keyword">super</span>(x)</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  calculate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.add(<span class="number">4</span>) + <span class="keyword">this</span>.y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Bar(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(f.calculate()) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>Ngoài ra với bạn cũng có thể dùng hàm mũi tên khi khai báo phương thức trong lớp. Điều này giúp đảm bảo this luôn trỏ đến đối tượng hiện tại. Cú pháp này đặc biệt thông dụng trong các ứng dụng React, tuy nhiên <strong>vẫn chưa được hỗ trợ mặc định</strong> bởi các trình duyệt, nên bạn phải dùng Babel để chuyển đổi mã nguồn.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">name</span>: <span class="string">'Fabulous button'</span> &#125;</span><br><span class="line"></span><br><span class="line">  doClick = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    <span class="comment">// 'You clicked Fabulous button'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.doClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tính tương thích:</strong> Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ lớp căn bản.</p></blockquote><h3 id="9-Promise"><a href="#9-Promise" class="headerlink" title="9. Promise"></a>9. Promise</h3><p>Nếu bạn chưa biết Promise là gì thì <a href="https://kipalog.com/posts/Promise-la-khi-gi-" target="_blank" rel="noopener">click vào đây</a>.</p><p>Vì Promise đã được công nhận như một phần của đặc tả ECMAScript 6 nên các trình duyệt có nghĩa vụ phải hỗ trợ mặc định. So với những thư viện chuyên biệt như <a href="http://bluebirdjs.com" target="_blank" rel="noopener">bluebird</a> hay <a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">q</a> thì phiên bản mặc định có ít tính năng hơn, nhưng cũng vừa đủ để dùng. Quan trọng là không cần thư viện thứ ba.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> showUser = <span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Your name is <span class="subst">$&#123;user.name&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserData = <span class="function"><span class="params">userId</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> RemoteApi.get(<span class="string">`/users/<span class="subst">$&#123;userId&#125;</span>`</span>, (err, response) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err)</span><br><span class="line">      resolve(response)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">getUserData(<span class="number">123</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> response.data)</span><br><span class="line">  .then(showUser)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Oh no'</span>, err))</span><br></pre></td></tr></table></figure><p>Promise còn có các hàm tĩnh khác:</p><h5 id="Promise-all-iterator"><a href="#Promise-all-iterator" class="headerlink" title="Promise.all(iterator)"></a>Promise.all(iterator)</h5><p>Nhận vào một mảng các promises và chỉ resolve khi tất cả promises trong mảng được resolve.</p><h5 id="Promise-race-iterator"><a href="#Promise-race-iterator" class="headerlink" title="Promise.race(iterator)"></a>Promise.race(iterator)</h5><p>Nhận vào một mảng các promises và resolve/reject ngay khi một trong các promises trong mảng resolve/reject.</p><h5 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h5><p>Trả về một promise được tự động resolve.</p><h5 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h5><p>Trả về một promise được tự động reject.</p><blockquote><p><strong>Tính tương thích:</strong> Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ.</p></blockquote><h3 id="Ket"><a href="#Ket" class="headerlink" title="Kết"></a>Kết</h3><p>ES6 mang đến những tính năng tuyệt vời cho lập trình viên, giúp cho làm việc với JavaScript trở nên dễ thở hơn, đồng thời nâng cao hiệu suất, cải thiện mã nguồn và giảm dung lượng tập tin khi truyền tải trên mạng. Nếu ứng dụng của bạn hướng đến các trình duyệt hiện đại, đừng chần chờ gì, hãy dùng ES6 ngay hôm nay.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Việc hầu hết những tính năng hay ho hấp dẫn của ES6 đều đã được &lt;a href=&quot;https://kangax.github.io/compat-table/es6/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;các trình duyệt hỗ trợ&lt;/a&gt; quả là tin vui cho giới lập trình web. Nhờ nó mà nhà phát triển có thể xây dựng ứng dụng trực tiếp bằng ES6, không cần phải thông qua các công cụ chuyển đổi như &lt;a href=&quot;http://babeljs.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Babel&lt;/a&gt; hay &lt;a href=&quot;https://buble.surge.sh/guide/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bublé&lt;/a&gt; nữa, giúp ứng dụng trở nên gọn nhẹ hơn, giảm thiểu kích thước tập tin khi chuyển đến người sử dụng.&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Chi phí của Javascript</title>
    <link href="http://nthung2112.github.io/2018/07/Chi-phi-cua-Javascript.html"/>
    <id>http://nthung2112.github.io/2018/07/Chi-phi-cua-Javascript.html</id>
    <published>2018-07-07T08:01:00.000Z</published>
    <updated>2018-07-08T09:31:29.960Z</updated>
    
    <content type="html"><![CDATA[<p>Khi các website chúng ta xây dựng ngày càng phụ thuộc vào JavaScript, thỉnh thoảng chúng ta cũng phải trả giá cho những gì được gửi về phía người dùng, theo những cách không dễ nhìn thấy . Trong bài viết này, tôi sẽ nói về lý do tại sao một chút <strong>kỷ luật</strong> có thể giúp nếu bạn muốn website của mình có thể tải và phản ứng một cách nhanh chóng trên các thiết bị di động.<br><a id="more"></a></p><blockquote><p>tl;dr: less code = less parse/compile + less transfer + less to decompress</p><p>Dài quá ngại đọc: ít mã lệnh = ít thời gian phân tách/biên dịch + ít dung lượng trao đổi + ít phải giải nén</p></blockquote><h3 id="1-Ket-noi-mang"><a href="#1-Ket-noi-mang" class="headerlink" title="1. Kết nối mạng"></a>1. Kết nối mạng</h3><p>Khi nghĩ về chi phí cho JavaScript, hầu hết các lập trình viên nghĩ về mặt <strong>chi phí tải và thực thi mã lệnh</strong>. Kết nối Internet của người dùng càng chậm thì gửi nhiều bytes JavaScript về phía họ càng lâu.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*U00XcnhqoczTuJ8NH8UhOw.png" alt=""></p><p>Điều này cũng có thể là một vấn đề với cả những nước đã phát triển, vì <strong>kết nối mạng đang sử dụng</strong> của một người dùng có thể không thật sự là 3G, 4G hay WiFi. Bạn có thể đang vào mạng WiFi của một quán cà phê, nhưng đang kết nối với một hotspot di động với tốc độ 2G.</p><p>Bạn có thể <strong>giảm</strong> chi phí truyền tải JavaScript bằng cách:</p><ul><li><strong>Chỉ chuyển đến người dùng phần mã lệnh cần thiết</strong>. Kỹ thuật chia mã (code-splitting) có thể hữu ích ở đây.</li><li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer" target="_blank" rel="noopener"><strong>Tối giản hóa</strong></a> mã lệnh (sử dụng Uglify cho ES5, <a href="https://github.com/babel/minify" target="_blank" rel="noopener">babel-minify</a> hay <a href="https://www.npmjs.com/package/uglify-es" target="_blank" rel="noopener">uglify-es</a> cho ES2015)</li><li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer" target="_blank" rel="noopener"><strong>Nén mã lệnh</strong></a> tới mức tối đa, bằng cách dùng <a href="https://www.smashingmagazine.com/2016/10/next-generation-server-compression-with-brotli/" target="_blank" rel="noopener">Brotli</a> ~ <a href="https://twitter.com/paulcalvano/status/924660429846208514" target="_blank" rel="noopener">q11</a>, Zopfli hay gzip. Brotli hoàn toàn qua mặt gzip khi xét về tỉ lệ nén. Giải thuật này đã giúp cho CertSimple giảm 17% dung lượng nén tập tin JS, và LinkedIn tiết kiệm 4% thời gian tải.</li><li><strong>Xóa mã lệnh không dùng tới</strong>. Với <a href="https://developers.google.com/web/updates/2017/04/devtools-release-notes" target="_blank" rel="noopener">DevTools code coverage</a>, bạn có thể nhận dạng phần mã nào không được thực thi. Để loại bỏ mã nguồn không cần thiết, bạn có thể sử dụng kỹ thuật <a href="https://webpack.js.org/guides/tree-shaking/" target="_blank" rel="noopener">“rung cây”</a> (tree-shaking) của Webpack, các kỹ thuật tối ưu hóa nâng cao của <a href="https://developers.google.com/closure/compiler/" target="_blank" rel="noopener">Closure Compiler</a>, và các plugin hỗ trợ tỉa tót mã lệnh như lodash-babel-plugin hay ContextReplacementPlugin của Webpack dành cho các thư viện như moment.js. Sử dụng babel-preset-env và browserlist để tránh tình trạng chuyển đổi những tính năng ES2015 đã được hỗ trợ mặc định trong các trình duyệt. Những lập trình viên nhiều kinh nghiệm có thể phân tích các bản đóng gói (bundles) của Webpack và tìm cách bỏ đi những thư viện phụ thuộc không cần thiết.</li><li><strong>Lưu bộ đệm để giảm tải các yêu cầu mạng</strong>. Xác định thời gian sống tối ưu cho các tập tin JS (max-age) và cung cấp các token thẩm định (ETag) để tránh phải truyền tải những bytes không cần thiết. Lưu bộ đệm bằng Service Worker có thể giúp ứng dụng của bạn trở nên chủ động hơn trong trường hợp mất kết nối, đồng thời cho phép bạn truy xuất đến những tính năng đặc biệt, chẳng hạn như <a href="https://v8project.blogspot.com/2015/07/code-caching.html" target="_blank" rel="noopener">bộ đệm lưu trữ mã trong V8</a>. Hãy tìm hiểu về lưu đệm dài hạn với kỹ thuật băm tên tập tin (filename hashing).</li></ul><p><img src="https://cdn-images-1.medium.com/max/2000/1*8Spf9To8dzTG3Xy9s57oVA.png" alt=""></p><h3 id="2-Phan-tach-Bien-dich"><a href="#2-Phan-tach-Bien-dich" class="headerlink" title="2. Phân tách/Biên dịch"></a>2. Phân tách/Biên dịch</h3><p>Sau khi đã tải, một trong những chi phí JavaScript <strong>nặng nề</strong> nhất là thời gian để một trình xử lý JS tiến hành phân tách/biên dịch mã nguồn. Trong Chrome DevTools, phân tách và biên dịch là những phần trong thời gian “Scripting” màu vàng, có thể thấy trong bảng Performance.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*_4gNDmBlXxOF2-KmsOrKkw.png" alt=""></p><p>Phần Bottom-Up/Call Tree cho phép xem chính xác thời gian phân tách và biên dịch mã:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*GdrVt_BTTzzBOIoyZZsQZQ.png" alt=""></p><p><em>Trong bản Performance của Chrome DevTools, tìm đến phần Bottom-Up. Khi Runtime Call Stats trong V8 được kích hoạt, chúng ta có thể thấy thời gian cần thiết của những tiến trình như Phân Tách và Biên Dịch</em></p><p>Nhưng mà, tại sao điều này lại quan trọng?</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Dirw7RdQj9Dktc-Ny6-xbA.png" alt=""></p><p><strong>Mất nhiều thời gian để phân tách/biên dịch mã nguồn có thể làm chậm đi đáng kể thời gian người dùng có thể tương tác với website. Bạn càng gửi xuống nhiều tập tin JavaScript, trình duyệt càng tốn thời gian để phân tách và biên dịch trước khi website của bạn có thể tương tác được.</strong></p><p><img src="https://cdn-images-1.medium.com/max/1600/1*6Y665hpxfWNMu2EXu3VGlw.png" alt=""></p><blockquote><p>Ăn byte nào trả byte đó, <strong>JavaScript ngày càng trở nên đắt đỏ cho trình duyệt để xử lý hơn là một bức hình hay web font có cùng dung lượng tương ứng</strong> – <em>Tom Dale - tác giả của Ember.js</em></p></blockquote><p>So với JavaScript, cũng có nhiều chi phí tham gia vào quá trình xử lý một bức ảnh có dung lượng tương tự (chúng vẫn cần phải được giải mã!) nhưng đối với phần cứng của thiết bị di động trung bình, có vẻ như tác động của JS có phần tiêu cực hơn đến khả năng tương tác của website.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*PRVzNizF9jQ_QADF5lQHpA.png" alt=""></p><p><small><em>Các byte của JavaScript và hình ảnh cần đến những chi phí rất khác nhau. Hình ảnh thường không chặn luồng chính (main thread) hay ngăn cản tương tác với các giao diện trong quá trình giải mã và hiển thị lên màn hình (rasterization). Ngược lại JS có thể làm chậm quá trình tương tác vì các chi phí phân tách, biên dịch và thực thi.</em></small></p><p>Khi chúng ta nói về phân tách và biên dịch bị chậm, ngữ cảnh rất quan trọng – vì ở đây chúng ta đang nói về những chiếc điện thoại ở phân khúc trung bình. Người dùng bình dân có thể dùng những thiết bị với CPUs và GPUs chậm chạp, hoàn toàn không có bộ đệm L2/L3 và thậm chí còn bị giới hạn bộ nhớ.</p><blockquote><p>Năng lực mạng và năng lực của thiết bị thường không đi chung với nhau. Một người dùng sử dụng kết nối Fiber siêu tốc không nhất thiết phải có CPU tốt nhất để phân tách và thực thi JavaScript được gửi đến. Điều ngược lại cũng chính xác…kết nối cùi mía, nhưng CPU lại nhanh như điện. – Kristofer Baxter, LinkedIn.</p></blockquote><p>Trong bài <a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201" target="_blank" rel="noopener">JavaScript Start-up Performance</a>, tôi có lưu ý về chi phí phân tách một tập tin JavaScript (đơn giản) đã được giải nén có dung lượng khoảng 1MB trên phần cứng bình dân và cao cấp. <strong>Thời gian phân tách/biên tịch mã lệnh giữa chiếc điện thoại nhanh nhất với chiếc điện thoại trung bình khác nhau từ 2 đến 5 lần.</strong></p><p><img src="https://cdn-images-1.medium.com/max/2000/1*8BQ3bCYu1AVvJWPR1x8Yig.png" alt=""></p><p><small><em><strong>Thời gian phân tách một bản đóng gói JavaScript có dung lượng 1MB (~250KB gzipped)</strong> giữa các thiết bị máy tính cá nhân và di động thuộc nhiều dòng khác nhau. Khi nhìn vào chi phí cho việc phân tách, chúng ta phải xem xét khi tập tin đã <strong>được giải nén</strong>, chẳng hạn như ~250KB gzipped khi giải nén thì khoảng 1MB.</em></small></p><p>Đối với những trang trong thực tế, như CNN.com thì sao?</p><p><strong>Trên một chiếc iPhone 8 cao cấp thì mất khoảng 4 giây để phân tách/biên dịch JS trên CNN.com, so với khoảng 13 giây cho một chiếc điện thoại bình dân (Moto G4)</strong>. Điều này có thể tác động rõ ràng đến khả năng tương tác của người dùng với website.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*7ysArXJ4nN0rQEMT9yZ_Sg.png" alt=""></p><p><small><em>So sánh thời gian phân tách mã nguồn trên chip A11 Bionic của Apple với Snapdragon 617 trên các thiết bị Android bình dân</em></small></p><p>Điều này nêu bật tầm quan trọng của việc kiểm thử ứng dụng trên các phần cứng <strong>trung bình</strong> (như chiếc Moto G4) thay vì chiếc điện thoại trong túi của bạn. Nói gì thì nói, ngữ cảnh cũng quan trọng: <strong>tối ưu hóa cho thiết bị và điều kiện kết nối mà người dùng <em>của bạn</em> có.</strong></p><p><img src="https://cdn-images-1.medium.com/max/1600/1*6oEpMEi_pjRNjmtN9i2TCA.png" alt=""></p><p>Các ứng dụng phân tích thống kê (analytics) có thể đưa ra một cái nhìn về <a href="https://crossbrowsertesting.com/blog/development/use-google-analytics-find-devices-customers-use/" target="_blank" rel="noopener">dòng thiết bị di động</a> mà người dùng thực tế của bạn đang sử dụng. Thông tin này đem đến cơ hội để hiểu hơn về các điều kiện giới hạn của CPU/GPU trên các thiết bị đó.</p><p><strong>Mà có thật là chúng ta đang gửi xuống người dùng quá nhiều JavaScript không? Hên xui :)</strong></p><p>Bằng cách sử dụng HTTP Archive (với khoảng 500K websites) để phân tích hiện trạng JavaScript trên các thiết bị di động, chúng ta có thể thấy rằng 50% website cần đến hơn 14 giây để có thể tương tác. Những trang này bỏ ra đến hơn 4 giây chỉ để phân tách và biên dịch JS.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*sVgunAoet0i5FWEI9NSyMg.png" alt=""></p><p>Thời gian để tải và xử lý JS và các tài nguyên khác đóng một vai trò ở đây, và có lẽ không quá ngạc nhiên khi người dùng phải chờ một lúc trước khi cảm giác website đã có thể sử dụng. Rõ ràng chúng ta có thể làm tốt hơn.</p><p><strong>Loại bỏ những phần JavaScript không quan trọng trong trang có thể giảm thiểu thời gian truyền tải, quá trình phân tách và biên dịch vốn ngốn CPU, và cả việc ngốn bộ nhớ. Nó cũng làm cho website trở nên có thể tương tác được nhanh hơn.</strong></p><h3 id="3-Thoi-gian-thuc-thi"><a href="#3-Thoi-gian-thuc-thi" class="headerlink" title="3. Thời gian thực thi"></a>3. Thời gian thực thi</h3><p>Chi phí không chỉ nằm ở quá trình phân tách và biên dịch. <strong>Quá trình thực thi JavaScript</strong> (chạy mã lệnh sau khi đã phân tách/biên dịch) là một trong những thao tác phải xảy ra trong luồng chính. Thời gian thực thi quá lâu có thể làm trì hoãn thời gian người dùng có thể tương tác với website.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*ec0wEKKVl7iQidBks3oDKg.png" alt=""></p><blockquote><p>If script executes for more than 50ms, time-to-interactive is delayed by the entire amount of time it takes to download, compile, and execute the JS — Alex Russell</p><p>Nếu một đoạn mã phải thực thi trong hơn 50ms, thời gian để tương tác bị trì hoãn bằng nguyên cả thời gian cần thiết để tải, biên dịch và thực thi JS – Alex Russell</p></blockquote><p>Để giải quyết vấn đề này, JavaScript tận dụng khả năng chia nhỏ thành từng phần (small chunks) để tránh không khóa hoàn toàn luồng chính. Bạn hãy tìm hiểu để xem có thể giảm thiểu công việc trong quá trình thực thi hay không.</p><h3 id="4-Mot-so-khuon-mau-de-giam-thieu-chi-phi-truyen-tai-JavaScript"><a href="#4-Mot-so-khuon-mau-de-giam-thieu-chi-phi-truyen-tai-JavaScript" class="headerlink" title="4. Một số khuôn mẫu để giảm thiểu chi phí truyền tải JavaScript"></a>4. Một số khuôn mẫu để giảm thiểu chi phí truyền tải JavaScript</h3><p>Khi bạn đang tìm cách để giảm thiểu thời gian truyền tải, phân tách và biên dịch JavaScript, có vài khuôn mẫu có thể hữu ích, như kỹ thuật chia nhỏ theo định tuyến (route-based chunking) hay còn gọi là <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" target="_blank" rel="noopener">PRPL</a>.</p><p>PRPL là một kỹ thuật để tối ưu hóa khả năng tương tác trên website bằng cách chia nhỏ mã nguồn và lưu bộ đệm một cách quyết liệt.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*VgdNbnl08gcetpqE1t9P9w.png" alt=""></p><p>Hãy xem những tác động nó có thể mang lại.</p><p>Chúng ta phân tính thời gian tải của những trang web di động thông dụng và các ứng dụng web tăng tiến (Progressive Web Apps – PWAs) bằng cách sử dụng Runtime Call Stats trong V8. Như chúng ta có thể thấy, thời gian phân tách (phần màu cam) chiếm một phần lớn trong tổng thời gian của các website này.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*9BMRW5i_bS4By_JSESXX8A.png" alt=""></p><p><a href="https://wego.com/" target="_blank" rel="noopener">Wego</a>, một trang sử dụng PRPL, xoay xở để giữ cho thời gian phân tách ở mức thấp, giúp cho website có thể tương tác nhanh hơn. Những trang còn lại cũng đã thực hiện kỹ thuật chia mã và dự toán hiệu suất (performance budgeting) để giảm chi phí JS.</p><h3 id="5-Nhung-chi-phi-khac"><a href="#5-Nhung-chi-phi-khac" class="headerlink" title="5. Những chi phí khác"></a>5. Những chi phí khác</h3><p>JavaScript cũng có thể tác động đến hiệu suất của website theo những hướng khác:</p><ul><li>Bộ nhớ. Website có thể cảm thấy bị giựt (jank) hay tạm dừng thường xuyên do bộ gom rác (garbage collector - GC) hoạt động. Khi trình duyệt tiến hành thu hồi bộ nhớ, quá trình thực thi JS bị tạm dừng. Do đó khi trình duyệt thu hồi bộ nhớ quá thường xuyên, tiến trình JS cũng bị dừng liên tục hơn chúng ta mong muốn. Lập trình viên cần tránh bị rò rỉ bộ nhớ và tiến trình dừng của GC để website có thể hoạt động ổn định hơn.</li><li>Trong quá trình chạy, mã JavaScript chạy quá lâu có thể khóa luồng chính, làm cho website trở nên không tương tác được. Bằng cách chia nhỏ công việc ra thành từng phần (sử dụng requestAnimationFrame() hay requestIdleCallback() để phân lịch) có thể giúp giảm thiểu các vấn đề về tương tác.</li></ul><h3 id="6-Ky-thuat-Khoi-dong-Tang-tien-progressive-bootstrapping"><a href="#6-Ky-thuat-Khoi-dong-Tang-tien-progressive-bootstrapping" class="headerlink" title="6. Kỹ thuật Khởi động Tăng tiến (progressive bootstrapping)"></a>6. Kỹ thuật Khởi động Tăng tiến (progressive bootstrapping)</h3><p>Nhiều website xem tính ẩn hiện của nội dung trên trang là một chi phí đắt đỏ khi tối ưu hóa tính tương tác. Để có thể thực hiện tiến trình vẽ đầu tiên (first paint) một cách nhanh chóng, lập trình viên thường sử dụng kỹ thuật tạo nội dung trước ở phía server (server-side rendering - SSR), sau đó “nâng cấp” bằng cách gắn các hàm xử lý sự kiện sau khi JavaScript đã được tải về.</p><p>Nhưng hãy cẩn thận – kỹ thuật này cũng có chi phí riêng của nó. Bạn 1) nhìn chung sẽ gửi xuống một tập tin HTML <em>nặng ký hơn</em> và có thể ảnh hưởng đến tính tương tác của site, hoặc 2) có thể đưa người dùng vào một vùng thung lũng huyền bí (uncanny valley) nơi một nửa trải nghiệm không thật sự có thể tương tác được, cho đến khi JavaScript hoàn tất quá trình xử lý.</p><p>Kỹ thuật Khởi động Tăng tiến có thể là một hướng tiếp cận tốt hơn. Bạn chỉ cần gửi xuống một trang vừa đủ có thể hoạt động, bao gồm chỉ HTML/JS/CSS cần thiết cho định tuyến hiện tại. Khi các tài nguyên khác đã được tải xong, ứng dụng có thể lazy-load vào và mở ra các chức năng khác.</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*zY03Y5nVEY21FXA63Qe8PA.png" alt="Kỹ thuật Khởi động Tăng tiến"></p><p><strong>Kỹ thuật tải mã lệnh tương ứng với những gì đang được hiển thị chính là cứu cánh. PRPL và Khởi động Tăng tiến là hai khuôn mẫu giúp đạt được mục tiêu này.</strong></p><h3 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h3><p><strong>Kích thước tập tin khi truyền tải rất quan trọng đối với những kết nối mạng cấp thấp. Thời gian phân tách mã nguồn lại quan trọng đối với những thiết bị có giới hạn về CPU. Chúng ta cần phải giữ cho các chỉ số này ở mức thấp.</strong></p><p>Nhiều nhóm phát triển đã thành công trong việc làm theo các dự toán hiệu suất nghiêm ngặt, để giảm thiểu thời gian truyền tải và phân tách/biên dịch. Bạn có thể xem hướng dẫn “<a href="https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/" target="_blank" rel="noopener">Can You Afford It?: Real-world Web Performance Budgets</a>” của Alex Russell về dự toán hiệu suất cho các thiết bị di động.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*U8PJVNrA_tYADQ6_S4HUYw.png" alt=""></p><p>Nếu bạn đang phát triển một website hướng đến các thiết bị di động, hãy cố gắng hết sức để xây dựng nó trên phần cứng tiêu biểu, giữ cho thời gian phân tách/biên dịch JavaScript ở mức thấp, và thu nhận một dự toán hiệu suất để chắc chắn rằng nhóm của bạn luôn theo sát chi phí JavaScript.</p><h3 id="Tim-hieu-them"><a href="#Tim-hieu-them" class="headerlink" title="Tìm hiểu thêm"></a>Tìm hiểu thêm</h3><div class="video-container"><iframe src="//www.youtube.com/embed/_srJ7eHS3IM" frameborder="0" allowfullscreen></iframe></div><p><small><em>Bài nói chuyện của tôi ở Chrome Dev Summit 2017 về chi phí cho JavaScript. Phần sau của bài nói có nhắc đến những ví dụ thực tế từ các trang như Pinterest hay Tinder.</em></small></p><ul><li><a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201" target="_blank" rel="noopener">JavaScript Start-up Performance</a></li><li><a href="https://nolanlawson.github.io/frontendday-2016/" target="_blank" rel="noopener">Solving the web performance crisis </a> —  Nolan Lawson</li><li><a href="https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/" target="_blank" rel="noopener">Can you afford it? Real-world performance budgets</a>  —  Alex Russell</li><li><a href="https://twitter.com/kristoferbaxter/status/908144931125858304" target="_blank" rel="noopener">Evaluating web frameworks and libraries </a> —  Kristofer Baxter</li><li><a href="https://blog.cloudflare.com/results-experimenting-brotli/" target="_blank" rel="noopener">Kết quả thử nghiệm của Cloudflare cho giải thuật nén Brotli</a> (lưu ý là nén Brotli động ở chất lượng cao có thể làm chậm quá trình hiển thị trang lần đầu tiên nên bạn cần đánh giá một cách thận trọng. Có khi bạn sẽ muốn nén theo phương pháp tĩnh hơn.)</li><li><a href="https://medium.com/@samccone/performance-futures-bundling-281543d9a0d5" target="_blank" rel="noopener">Performance Futures </a> —  Sam Saccone</li></ul><p><em>Chân thành cám ơn Nolan Lawson, Kristofer Baxter và Jeremy Wagner vì những phản hồi của mọi người.</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Khi các website chúng ta xây dựng ngày càng phụ thuộc vào JavaScript, thỉnh thoảng chúng ta cũng phải trả giá cho những gì được gửi về phía người dùng, theo những cách không dễ nhìn thấy . Trong bài viết này, tôi sẽ nói về lý do tại sao một chút &lt;strong&gt;kỷ luật&lt;/strong&gt; có thể giúp nếu bạn muốn website của mình có thể tải và phản ứng một cách nhanh chóng trên các thiết bị di động.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>10 mẹo CSS hữu ích bạn nên biết</title>
    <link href="http://nthung2112.github.io/2018/06/10-meo-CSS-huu-ich-ban-nen-biet.html"/>
    <id>http://nthung2112.github.io/2018/06/10-meo-CSS-huu-ich-ban-nen-biet.html</id>
    <published>2018-06-27T01:01:00.000Z</published>
    <updated>2018-06-27T01:11:20.866Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Pagespeed Optimization</strong> (tối ưu hóa tốc độ trang) là một công việc mà hầu như mọi Web developer đều quan tâm và nên biết, mục đích của nó là đưa nội dung website đến với người xem nhanh nhất có thể.</p><p>Front-end developer thường làm việc với HTML, CSS, Javascript và các hình ảnh. Do đó, đây cũng là các đối tượng chính để chúng ta tối ưu tốc độ tải trang cho website. Tốc độ tải trang của website ngoài các yếu tố liên quan do server thì còn phụ thuộc vào kích thước và số lượng file phải tải về, do đó càng giảm được kích thước file lẫn số lượng file cần phải tải về thì cũng đồng thời tăng tốc độ tải file và giảm số lượng request lên server.<br><a id="more"></a><br>Ở bài này mình sẽ giới thiệu với các bạn 10 mẹo CSS hữu ích giúp giảm kích thước, số lượng file CSS, tối ưu file CSS và phát triển CSS dễ dàng hơn, nội dung bài gồm những phần sau:</p><ol><li><a href="#01-han-che-su-dung-import">Hạn chế sử dụng @import</a></li><li><a href="#02-su-dung-cach-viet-ngan-gon">Sử dụng cách viết ngắn gọn (shorthand properties)</a></li><li><a href="#03-khai-bao-class-bo-tro">Khai báo class bổ trợ (Helper classes)</a></li><li><a href="#04-han-che-su-dung-inline-css-trong-elements">Hạn chế sử dụng CSS trong element của HTML (inline CSS attributes in HTML elements)</a></li><li><a href="#05-giam-so-luong-file-css">Giảm số lượng file CSS (Combine external CSS)</a></li><li><a href="#06-giam-kich-thuoc-file-css">Giảm kích thước file CSS</a></li><li><a href="#07-ap-dung-ky-thuat-oocss">Áp dụng OOCSS (Object Oriented CSS)</a></li><li><a href="#08-to-chuc-class-va-id-mot-cach-khoa-hoc">Đặt tên class và id một cách khoa học</a></li><li><a href="#09-ngon-ngu-tien-xu-ly-css">Ngôn ngữ tiền xử lý CSS (CSS Preprocessor)</a></li><li><a href="#10-gioi-thieu-so-luoc-koala-app">Sử dụng Koala-app khi làm việc với CSS</a></li></ol><h2 id="1-Han-che-su-dung-import"><a href="#1-Han-che-su-dung-import" class="headerlink" title="1. Hạn chế sử dụng @import"></a>1. Hạn chế sử dụng @import</h2><p>Hạn chế sử dụng @import hoặc tốt nhất là không nên sử dụng @import trong file CSS, vì nó sẽ <strong>làm chậm quá trình tải</strong> và <strong>không sử dụng được khả năng tải file đồng thời của browser</strong>. Để dễ hiểu bạn hãy xem ví dụ sau:</p><p>Mình có 2 file CSS là a.css và b.css được nhúng vào trang web như sau:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'a.css'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'b.css'</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Trong file b.css, bạn import file c.css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(c.css);</span><br></pre></td></tr></table></figure><p>Kết quả khi browser tải trang sẽ như thế này:</p><p>HTML downloada.cssb.cssc.css</p><p>Chú thích:</p><ul><li>Request 1: browser gửi request để lấy HTML về</li><li>Request 2: browser gửi request để lấy a.css</li><li>Request 3: browser gửi request để lấy b.css</li><li>Request 4: browser gửi request để lấy c.css</li></ul><p>Như các bạn thấy ở hình trên, để tải được c.css thì browser phải chờ để tải xong a.css.</p><p><strong>Lý do</strong>: Vì browser khi đã tải xong b.css và bắt đầu đọc nội dung bên trong thì thấy <strong>@import</strong> yêu cầu phải tải thêm c.css, lúc này browser phải đứng chờ cho nhóm proccess trước đó chạy xong (trong trường hợp này là chờ a.css) thì mới bắt đầu tải tiếp c.css và tiếp tục render sau khi đã tải xong.</p><p>Trong khi đó nếu bạn loại bỏ @import url(c.css) trong b.css đi và nhúng trực tiếp c.css vào trang HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'a.css'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'b.css'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'c.css'</span>&gt;</span></span><br></pre></td></tr></table></figure><p>thì bạn sẽ có kết quả như sau:</p><p>HTML downloada.cssb.cssc.css</p><p>Lúc này browser sẽ bắt đầu tải file đồng thời không cần phải chờ cho a.css tải xong, sẽ rút ngắn được thời gian tải file xuống.</p><p>Như tiêu đề mình nói rằng nên <strong>Hạn chế</strong> sử dụng @import, vậy một câu hỏi nhỏ đặt ra là <strong>khi nào thì nên dùng @import?</strong>.</p><p>Theo mình thì khi <strong>những định nghĩa CSS cần lệ thuộc vào một định nghĩa ở file CSS khác trước – thì khi đó nên dùng @import</strong>, ví dụ bạn sử dụng các bộ thư viện reset CSS như <a href="https://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a>, bạn cần reset tất cả các định nghĩa CSS về một chuẩn chung trước khi viết định nghĩa CSS tiếp theo – lúc này bạn sẽ dùng @import để import file Normalize.css vào trong file định nghĩa CSS của bạn, lý do sử dụng @import ở đây là để tránh cơ chế tải file đồng thời của browser và bắt buộc browser phải tải và áp định nghĩa CSS của Normalize.css trước rồi mới đến các định nghĩ CSS ở bên dưới @import.</p><p>Một câu hỏi tiếp theo <strong>Nếu nhất thiết phải dùng @import như ví dụ trên, thì các nào khác để giải quyết thay vì dùng @import hay không?</strong>.</p><p>Tất nhiên là có cách, đó là bạn copy toàn bộ nội dung của file Normalize.css vào trong file CSS của bạn, hay còn gọi là <strong>Combine external CSS</strong> mình sẽ giới thiệu phía bên dưới.</p><h2 id="2-Su-dung-cach-viet-ngan-gon"><a href="#2-Su-dung-cach-viet-ngan-gon" class="headerlink" title="2. Sử dụng cách viết ngắn gọn"></a>2. Sử dụng cách viết ngắn gọn</h2><p>Sử dụng cách viết ngắn gọn (shorthand properties) để dễ dàng thiết lập một số thuộc tính chỉ trên một dòng, đây cũng là một cách để bạn dễ dàng kiểm soát – theo dõi code của mình, đồng thời cũng hỗ trợ giảm số lượng ký tự trong file css và giảm kích thước file.</p><p>Lấy ví dụ đơn giản về cách thiết lập thuộc tính hình ảnh cho background</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>:<span class="selector-id">#000</span>;</span><br><span class="line"><span class="selector-tag">background-image</span><span class="selector-pseudo">:url(bg-image.jpg)</span>;</span><br><span class="line"><span class="selector-tag">background-repeat</span><span class="selector-pseudo">:no-repeat</span>;</span><br><span class="line"><span class="selector-tag">background-attachment</span><span class="selector-pseudo">:fixed</span>;</span><br><span class="line"><span class="selector-tag">background-position</span><span class="selector-pseudo">:center</span> <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure><p>Bạn có thể viết thành</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>:<span class="selector-id">#000</span> <span class="selector-tag">url</span>(<span class="selector-tag">bg-image</span><span class="selector-class">.jpg</span>) <span class="selector-tag">no-repeat</span> <span class="selector-tag">fixed</span> <span class="selector-tag">center</span> <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure><p>Cấu trúc shorthand của thuộc tính background như sau</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: &lt;<span class="selector-tag">color</span>&gt; &lt;<span class="selector-tag">image</span>&gt; &lt;<span class="selector-tag">repeat</span>&gt; &lt;<span class="selector-tag">attachment</span>&gt; &lt;<span class="selector-tag">position</span>&gt;;</span><br></pre></td></tr></table></figure><p>Ngoài background thì còn có một số thuộc tính khác cũng có thể sử dụng shorthand như margin, padding, border, outline, … bạn có thể tham khảo thêm trên <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Shorthand_properties" target="_blank" rel="noopener">Mozilla Developer Network (MDN)</a>. Ở cuối trang này có danh sách các thuộc tính có thể áp dụng shorthand.</p><p>Bên cạnh đó, nếu bạn thích khai báo mã màu HEX thì đối với một số mã màu thông dụng bạn cũng có thể viết ngắn gọn lại ví dụ như #FFF thay cho #FFFFFF hay #000 thay cho #000000. Bạn có thể tham khảo cách chuyển đổi tại <a href="http://maettig.com/?page=PHP/CSS_Color_Converter" target="_blank" rel="noopener">CSS Color Converter</a>.</p><h2 id="3-Khai-bao-class-bo-tro"><a href="#3-Khai-bao-class-bo-tro" class="headerlink" title="3. Khai báo class bổ trợ"></a>3. Khai báo class bổ trợ</h2><p>Class bổ trợ (Helper classes) là những class được định nghĩa sẵn một số thuộc tính đơn giản và thường hay sử dụng. Ví dụ như text-align, font-weight, color… Class bổ trợ trong quá trình viết HTML các bạn chỉ cần thêm class đó vào mà không cần phải định nghĩa lại thuộc tính. Cách làm này khá hữu dụng khi bạn sử dụng một CSS framework và cần custom “rất ít” thuộc tính, hoặc bạn không chọn được tên class phù hợp cho element đó, hay element đó không cần xác định class để làm gì đó với javascript.</p><p>Điểm lợi của việc này ngoài việc bạn không cần định nghĩa lại một số thuộc tính không cần thiết, thì nếu CSS càng nhiều thì bạn sẽ tiết kiệm được khá nhiều thuộc tính cần khai báo lại và sẽ giảm được kích thước file CSS. Ví dụ:</p><p>Mình có các element sau cần viết CSS và mình đang dùng framework bootstrap:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-success btn-md text-uppercase"</span>&gt;</span></span><br><span class="line">    Show More</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Thay vì mình cần phải viết CSS như sau để custom lại theo ý mình</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">text-align</span>: center; <span class="attribute">padding-top</span>: <span class="number">20px</span>; &#125;</span><br><span class="line"><span class="selector-tag">p</span> &gt; <span class="selector-tag">button</span> &#123; <span class="attribute">background-color</span>: <span class="number">#fff</span>; <span class="attribute">padding-right</span>: <span class="number">30px</span>; <span class="attribute">padding-left</span>: <span class="number">30px</span> &#125;</span><br></pre></td></tr></table></figure><p>Thì mình sẽ khai báo class bổ trợ để có thể tái sử dụng cho nhiều trường hợp khác về sau ( Những class có sẵn của bootstrap mình sẽ không liệt kê vào, vì hiện giờ mình cần custom các element này )</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.padding-top-20</span> &#123; <span class="attribute">padding-top</span>: <span class="number">20px</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-30</span> &#123; <span class="attribute">padding-right</span>: <span class="number">30px</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-30</span> &#123; <span class="attribute">padding-left</span>: <span class="number">30px</span>; &#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.btn-bg-white</span> &#123; <span class="attribute">background-color</span>: <span class="number">#fff</span>; &#125;</span><br></pre></td></tr></table></figure><p>Như vậy trong HTML mình sẽ khai báo như sau</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-center padding-top-20"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-success btn-md btn-bg-white text-uppercase padding-right-30 padding-left-30"</span>&gt;</span>Show More<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Như vậy thì về sau những class này mình có thể tái sử dụng rất nhiều lần ở rất nhiều element, và mình có thể bỏ đi khá nhiều công đoạn phải gõ lại code CSS khi có phát sinh thêm element mới.</p><p>Điều này mình học hỏi từ bootstrap và cảm thấy nó khá là hay. Bạn có thể tham khảo thêm các <a href="https://getbootstrap.com/css/#helper-classes" target="_blank" rel="noopener">helper class</a> hoặc <a href="https://getbootstrap.com/css/#type" target="_blank" rel="noopener">typography</a> của bootstrap để hiểu rõ hơn.</p><h2 id="4-Han-che-su-dung-Inline-CSS-trong-cac-elements"><a href="#4-Han-che-su-dung-Inline-CSS-trong-cac-elements" class="headerlink" title="4. Hạn chế sử dụng Inline CSS trong các elements"></a>4. Hạn chế sử dụng Inline CSS trong các elements</h2><p>Ở đây, mình chỉ khuyên các bạn nên hạn chế sử dụng, vì điều này sẽ làm các bạn khó kiểm soát code CSS của mình. “Vạn bất đắc dĩ” cần giải quyết nhanh (hotfix) thì hãy dùng hoặc nếu chỉ dùng một lần hoặc là CSS động từ javascript thì có thể chấp nhận được.</p><p>Theo như <a href="https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery#CSSattributes" target="_blank" rel="noopener">Google Pagespeed Insights</a> thì việc này sẽ làm code bị lặp lại không cần thiết và vi phạm <a href="https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery#CSSattributes" target="_blank" rel="noopener">Chính sách Bảo mật Nội dung của W3</a>, trong một số trường hợp thì các attribute này sẽ bị chặn.</p><h2 id="5-Giam-so-luong-file-CSS"><a href="#5-Giam-so-luong-file-CSS" class="headerlink" title="5. Giảm số lượng file CSS"></a>5. Giảm số lượng file CSS</h2><p>Gom các file CSS lại với nhau (Combine external CSS) là việc dễ làm nhất, thay vì phải viết thành nhiều file như header.css, navigation.css, footer.css… vào trong văn bản HTML thì bạn hãy gom các file này thành một file duy nhất. Nội dung file này sẽ chứa toàn bộ nội dung của các file trên, như vậy bạn sẽ giảm được nhiều request đến server và giảm tải cho server khá nhiều.</p><p>Thay vì sử dụng như vầy</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/header.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/navigation.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/footer.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Nên gom chúng lại thành</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/style.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-Giam-kich-thuoc-file-CSS"><a href="#6-Giam-kich-thuoc-file-CSS" class="headerlink" title="6. Giảm kích thước file CSS"></a>6. Giảm kích thước file CSS</h2><p>Giảm kích thước file CSS được thực hiện bằng cách loại bỏ các khoảng trắng không cần thiết, dấu xuống hàng, dấu chấm phẩy cuối cùng trong class hoặc id… Công đoạn này còn được gọi là <strong>minify</strong>. Để tiện phân biệt giữa file chưa minify và file đã minify thì bạn nên thêm <strong>.min</strong> vào tên file đã minify. Ví dụ style.css sau khi minify sẽ thành style.min.css.</p><p>Bạn có thể truy cập vào <a href="http://www.cleancss.com/css-minify/" target="_blank" rel="noopener">Clean CSS</a> để thực hiện minify css hoặc sử dụng tool Koala-app mình sẽ giới thiệu bên dưới để tự động xuất file minify trong quá trình viết code.</p><h2 id="7-Ap-dung-ky-thuat-OOCSS"><a href="#7-Ap-dung-ky-thuat-OOCSS" class="headerlink" title="7. Áp dụng kỹ thuật OOCSS"></a>7. Áp dụng kỹ thuật OOCSS</h2><p><strong>OOCSS</strong> (Object Oriented CSS) – CSS hướng đối tượng, thật ra hướng đối tượng ở đây có nghĩa là bạn gom các thuộc tính giống nhau của 2 class cùng áp dụng cho một element thành một class để giảm thiểu sự lặp lại. Ví dụ:</p><p>Thay vì khai báo 2 class cho button như sau</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.42857143</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#337ab7</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#2e6da4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.btn-success</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.42857143</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mình sẽ gom một số thuộc tính của 2 class này thành một class khác có tên là btn:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.42857143</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#337ab7</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#2e6da4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.btn-success</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Như vậy nếu sau này có thay đổi gì về một số thuộc tính chung của 2 class thì mình chỉ cần thay đổi class btn thì sẽ dễ dàng và nhanh hơn.</p><h2 id="8-To-chuc-class-va-id-mot-cach-khoa-hoc"><a href="#8-To-chuc-class-va-id-mot-cach-khoa-hoc" class="headerlink" title="8. Tổ chức class và id một cách khoa học"></a>8. Tổ chức class và id một cách khoa học</h2><p>Việc này để hỗ trợ bạn sau này khi xem lại code của mình dễ dàng hơn và không bị rối với cách đặt tên của mình, đồng thời cũng dễ dàng nếu có áp dụng một số CSS preprocessor hay BEM.</p><p>Thay vì đặt tên</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.titlepost</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.headerpost</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.contentpost</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>thì nên đặt thành</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post-title</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post-header</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post-content</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>hoặc tổ chức thành</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post</span> &gt; <span class="selector-class">.title</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post</span> &gt; <span class="selector-class">.header</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.post</span> &gt; <span class="selector-class">.content</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="9-Ngon-ngu-tien-xu-ly-CSS"><a href="#9-Ngon-ngu-tien-xu-ly-CSS" class="headerlink" title="9. Ngôn ngữ tiền xử lý CSS"></a>9. Ngôn ngữ tiền xử lý CSS</h2><p><strong>Tiền xử lý CSS</strong> (CSS Preprocessor) – là một cách mở rộng của CSS hoặc cũng có thể coi nó là một ngôn ngữ riêng. Mục đích của CSS preprocessor là để bạn dễ dàng cấu trúc các đoạn code CSS, giảm thời gian phải viết đi viết lại một đoạn code, dễ dàng áp dụng OOCSS… Nói cách khác bạn có thể hiểu CSS preprocessor gần như là một ngôn ngữ lập trình vì nó cũng có biến, kế thừa class, và dễ dàng tạo ra một thư viện riêng cho bạn quản lý, kế thừa và tái sử dụng ở những dự án khác.</p><p>CSS preprocessor hiện nay có rất nhiều nhưng phổ biến nhất hiện nay là <a href="http://lesscss.org/" target="_blank" rel="noopener"><strong>Less</strong></a> và <a href="http://sass-lang.com/" target="_blank" rel="noopener"><strong>Sass.</strong></a> Ở đây mình giới thiệu các bạn về Sass vì mình đang sử dụng nó thay cho Less, và CSS framework phổ biến – <a href="https://blog.getbootstrap.com/2015/08/19/bootstrap-4-alpha/" target="_blank" rel="noopener">Bootstrap, kể từ phiên bản 4 đã chuyển từ Less qua Sass</a>. Về Sass các bạn xem <a href="http://sass-lang.com/install" target="_blank" rel="noopener">hướng dẫn cài đặt trên trang chủ</a>.</p><p>Khi bắt đầu với một dự án có áp dụng Sass, việc đầu tiên mình thường làm là cấu trúc CSS thành nhiều file nhỏ để tránh nhồi nhét CSS vào một file và dễ dàng cho việc quản lý, tìm kiếm khi cần thiết. Mình thường cấu trúc các file Sass như sau:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scss</span><br><span class="line">|-- style.scss</span><br><span class="line">|-- _variable.scss</span><br><span class="line">|-- _helper.scss</span><br><span class="line">|-- _mixins.scss</span><br><span class="line">|-- components</span><br><span class="line">|-- -- _header.scss</span><br><span class="line">|-- -- _footer.scss</span><br><span class="line">|-- mixins</span><br><span class="line">|-- -- button.scss</span><br><span class="line">|-- -- label.scss</span><br></pre></td></tr></table></figure><p>Trong file style.scss nội dung như sau:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"variable"</span>;</span><br><span class="line">@impprt <span class="string">"helper"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"mixins"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Components</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"components/header"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"components/footer"</span>;</span><br></pre></td></tr></table></figure><p>Chú thích:</p><ul><li>_variable.scss: variable chứa các thông tin về các biến dùng chung</li><li>_helper.scss: helper sẽ chứa/import các class helper</li><li>_mixins.scss: mixins sẽ chứa/import các class custom hoặc class được tái sử dụng nhiều lần</li></ul><p>Nội dung file _helper.scss như mình đã nói sẽ tạo ra các class helper, nhưng ở đây mình áp dụng tính chất của Scss để tạo ra các class với ít dòng code nhất:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$numbersPX</span>:</span><br><span class="line">  <span class="string">"10"</span> <span class="number">10px</span>,</span><br><span class="line">  <span class="string">"15"</span> <span class="number">15px</span>,</span><br><span class="line">  <span class="string">"20"</span> <span class="number">20px</span>,</span><br><span class="line">  <span class="string">"25"</span> <span class="number">25px</span>,</span><br><span class="line">  <span class="string">"30"</span> <span class="number">30px</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// padding</span></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$i</span> in <span class="variable">$numbersPX</span>&#123;</span><br><span class="line">  <span class="selector-class">.padding-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.padding-top-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.padding-bottom-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.padding-right-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-right</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.padding-left-</span>#&#123;nth(<span class="variable">$i</span>, 1)&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: nth(<span class="variable">$i</span>, <span class="number">2</span>) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>khi Sass complier ra file CSS thì mình sẽ thu được kết quả như sau</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.padding-10</span> &#123; <span class="attribute">padding</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-10</span> &#123; <span class="attribute">padding-top</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-10</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-10</span> &#123; <span class="attribute">padding-right</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-10</span> &#123; <span class="attribute">padding-left</span>: <span class="number">10px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-15</span> &#123; <span class="attribute">padding</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-15</span> &#123; <span class="attribute">padding-top</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-15</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-15</span> &#123; <span class="attribute">padding-right</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-15</span> &#123; <span class="attribute">padding-left</span>: <span class="number">15px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-20</span> &#123; <span class="attribute">padding</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-20</span> &#123; <span class="attribute">padding-top</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-20</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-20</span> &#123; <span class="attribute">padding-right</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-20</span> &#123; <span class="attribute">padding-left</span>: <span class="number">20px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-25</span> &#123; <span class="attribute">padding</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-25</span> &#123; <span class="attribute">padding-top</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-25</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-25</span> &#123; <span class="attribute">padding-right</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-25</span> &#123; <span class="attribute">padding-left</span>: <span class="number">25px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-30</span> &#123; <span class="attribute">padding</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-top-30</span> &#123; <span class="attribute">padding-top</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-bottom-30</span> &#123; <span class="attribute">padding-bottom</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-right-30</span> &#123; <span class="attribute">padding-right</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-class">.padding-left-30</span> &#123; <span class="attribute">padding-left</span>: <span class="number">30px</span> <span class="meta">!important</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="10-Gioi-thieu-so-luoc-Koala-App"><a href="#10-Gioi-thieu-so-luoc-Koala-App" class="headerlink" title="10. Giới thiệu sơ lược Koala App"></a>10. Giới thiệu sơ lược Koala App</h2><p><a href="http://koala-app.com" target="_blank" rel="noopener">Koala app</a> là một ứng dụng GUI hỗ trợ biên dịch Less, Sass, Compass và CoffeeScript sang CSS và JS. Koala App chạy được trên cả 3 môi trường Mac OS, Linux và Windows nên rất tiện nếu bạn cần thay đổi qua lại giữa các hệ điều hành. Ngoài ra, Koala App còn hỗ trợ minify cho cả CSS và JS.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2016/01/image01-700x453.png" alt=""></p><p>Sử dụng Koala App rất đơn giản, bạn chỉ cần mở lên và ấn dấu + trên đầu chương trình để chọn thư mục chứa các file cần xử lý, và Koala App sẽ tự động scan toàn bộ các folder bên trong và theo dõi khi có thay đổi.</p><p>Nếu bạn “siêng” thì có thể tham khảo cách để tự cấu hình project để Koala-app hoạt động theo ý mình <a href="https://github.com/oklai/koala/wiki/Using-project-settings" target="_blank" rel="noopener">tại đây</a>.</p><p>Trên đây là những mẹo CSS rút ra từ kinh nghiệm làm việc của mình. Nếu bạn còn những mẹo hay khác thì đừng ngại chia sẻ bên dưới nhé.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Pagespeed Optimization&lt;/strong&gt; (tối ưu hóa tốc độ trang) là một công việc mà hầu như mọi Web developer đều quan tâm và nên biết, mục đích của nó là đưa nội dung website đến với người xem nhanh nhất có thể.&lt;/p&gt;
&lt;p&gt;Front-end developer thường làm việc với HTML, CSS, Javascript và các hình ảnh. Do đó, đây cũng là các đối tượng chính để chúng ta tối ưu tốc độ tải trang cho website. Tốc độ tải trang của website ngoài các yếu tố liên quan do server thì còn phụ thuộc vào kích thước và số lượng file phải tải về, do đó càng giảm được kích thước file lẫn số lượng file cần phải tải về thì cũng đồng thời tăng tốc độ tải file và giảm số lượng request lên server.&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://nthung2112.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Tối ưu hiệu suất render để website mượt hơn</title>
    <link href="http://nthung2112.github.io/2018/06/Toi-uu-hieu-suat-render-de-website-muot-hon.html"/>
    <id>http://nthung2112.github.io/2018/06/Toi-uu-hieu-suat-render-de-website-muot-hon.html</id>
    <published>2018-06-26T00:50:00.000Z</published>
    <updated>2018-06-27T01:12:25.692Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Optimizing Performance</strong> (tối ưu hóa hiệu suất) cho website là một công việc mà bất kỳ front-end developer nào cũng nên biết, mục đích là để trang web đáp ứng được 3 tiêu chí:</p><ol><li><strong>NHẸ</strong>: Giảm kích thước trang web và các thành phần đi kèm như javascript, css, hình ảnh… nhằm đảm bảo <strong>thời gian tải xuống ngắn hơn</strong>. Chúng ta có thể dùng các bộ minify cho javascript, css…, nén các tập tin hình ảnh, font chữ, svg… ngoài ra còn có các kĩ thuật như code splitting, browser caching, HTTP caching…</li><li><strong>NHANH</strong> <strong>Hiển thị nội dung trang web càng sớm càng tốt</strong> bằng cách: chia cấu trúc DOM hợp lý, hạn chế blocking CSS/JS, hạn chế chỉnh sửa DOM tree, chia các file ra thành nhiều module, tải resource bất đồng bộ, tối ưu hóa các selector của CSS và JS…</li><li><strong>MƯỢT</strong>: Sau khi nội dung trang web đã được tải về và hiển thị thì việc tiếp theo là <strong>bảo đảm các hiệu ứng animation, transition, scrolling… phải mượt</strong>, không bị lag và giật (jank).</li></ol><a id="more"></a><p>Trong 3 tiêu chí này, có 2 tiêu chí mà front-end developer chúng ta hằng ngày đều thực hiện là <strong>nhẹ và nhanh</strong>. Bằng cách sử dụng các framework (angularjs, reactjs…) và các bộ build tool (grunt, gulp, webpack…), các resource trong project ở môi trường production lúc nào cũng được minify và đóng gói đầy đủ, gọn gàng.</p><p>Do đó, trong bài này tôi sẽ hướng dẫn cho bạn cách đáp ứng được tiêu chí thứ 3, đó là <strong>MƯỢT</strong>, thứ mà ít có framework hay công cụ nào có thể hỗ trợ bạn được.</p><p> <a href="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image05.png" target="_blank" rel="noopener"><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image05-700x455.png" alt=""></a> </p><p>Trên thực tế, các web page yêu cầu độ mượt cao thường là các webpage có nhiều hiệu ứng, chuyển động, ví dụ như các trang landing page, giới thiệu sản phẩm, HTML5 game, hoặc các ứng dụng có animation chạy trên các thiết bị có cấu hình thấp. Bạn có thể xem qua một số trang sau:</p><ul><li><a href="http://world.mathigon.org/" target="_blank" rel="noopener">http://world.mathigon.org/</a></li><li><a href="http://matthew.wagerfield.com/parallax/" target="_blank" rel="noopener">http://matthew.wagerfield.com/parallax/</a></li></ul><h2 id="Lam-the-nao-de-web-page-“muot”"><a href="#Lam-the-nao-de-web-page-“muot”" class="headerlink" title="Làm thế nào để web page “mượt”?"></a>Làm thế nào để web page “mượt”?</h2><p>Mượt ở đây chính là “Rendering Performance”, để tối ưu hiệu suất render chúng ta phải hiểu được quá trình render của browser.</p><h3 id="60"><a href="#60" class="headerlink" title="60"></a>60</h3><p>… là số khung hình trên một giây mà các thiết bị phổ biến hiện nay hỗ trợ (60fps). Để cho trang web mượt thì tốc độ render phải đáp ứng được con số này. Tức là trong <strong>1 giây</strong> chúng ta phải cho ra <strong>60 khung hình</strong>. Với mỗi khung hình, chúng ta có 1 / 60 = 16,66 mili giây. Trên thực tế, browser còn có một số tác vụ khác phải làm bên cạnh việc render, vì thế chúng ta trừ hao còn lại khoảng 16ms.</p><p>Bất cứ animation hay transition nào, muốn đảm bảo được tốc độ 60fps thì phải cũng phải đảm bảo trong vòng <strong>16ms phải render được một khung hình</strong>, nếu không thì sẽ bị hiện tượng “frame skip”, hiệu ứng sẽ bị giật, lag.</p><h3 id="Can-phai-lam-nhung-gi-trong-16ms-do"><a href="#Can-phai-lam-nhung-gi-trong-16ms-do" class="headerlink" title="Cần phải làm những gì trong 16ms đó?"></a>Cần phải làm những gì trong 16ms đó?</h3><p>Để cho ra được 1 khung hình, đây là các việc mà browser phải thực hiện (<strong>the pixel pipeline</strong>):</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image19-700x107.png" alt=""></p><p>Giải thích ngắn gọn:</p><p><strong>1. JavaScript</strong>: là hoạt động execute code của javascript.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'my-element'</span>).style.width = <span class="string">'300px'</span>;</span><br></pre></td></tr></table></figure><p><strong>2. Style calculation</strong>: tính toán các thuộc tính theo các quy tắc từ file CSS (hoặc thẻ <code>&lt;style&gt;</code>, thuộc tính style).</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'my-element'</span> <span class="attr">style</span>=<span class="string">'width: 300px'</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3. Layout</strong>: browser thực hiện “chia vùng” cho các element khi hiển thị trên màn hình, dựa trên các thuộc tính đã tính toán được từ bước Style.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image28.png" alt=""></p><p><strong>4. Paint</strong>: tô màu cho từng pixel, bao gồm việc: vẽ chữ (render font), hình ảnh, màu, vẽ các hiệu ứng CSS như border, box-shadow… Việc tô màu này được thực hiện trên nhiều “layer” cùng một lúc (phần sau sẽ giải thích rõ hơn về layer). Đây là bước chiếm nhiều thời gian nhất.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image23.png" alt=""></p><p><strong>5. Composite</strong>: gộp các layer đã được vẽ (ở bước Paint) và hiển thị lên màn hình theo đúng thứ tự của các layer đó.</p><p>Như vậy, chỉ với 16ms browser phải thực hiện 5 bước như trên để có thể render ra được 1 khung hình. Vậy để đảm bảo mọi thứ đều hoàn thành dưới 16ms, việc chúng ta cần làm là tối ưu từng bước. Cụ thể là:</p><ul><li><p><strong>JavaScript:</strong></p><ul><li>Dùng requestAnimationFrame.</li><li>Dùng Web workers, Micro-task cho các tác vụ nặng.</li><li>Profiling with Chrome DevTools.</li></ul></li><li><p><strong>Style:</strong></p><ul><li>Giảm độ phức tạp của selector</li><li>Giảm số lượng element bị ảnh hưởng</li></ul></li><li><p><strong>Layout:</strong></p><ul><li>Hạn chế kích hoạt layout</li><li>Sử dụng Flexbox</li><li>Hạn chế forced synchronous layout.</li></ul></li><li><p><strong>Paint:</strong></p><ul><li>Paint là tác vụ xử lý lâu nhất</li><li>Box-shadow, large image không tốt cho paint</li><li>Tạo và quản lý layer hợp lý</li></ul></li><li><p><strong>Composite:</strong></p><ul><li>Sử dụng transform và opacity</li><li>Quản lý các layer bằng Chrome DevTools</li></ul></li></ul><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image22-250x203.png" alt=""></p><h2 id="Tung-buoc-toi-uu-hieu-suat-render"><a href="#Tung-buoc-toi-uu-hieu-suat-render" class="headerlink" title="Từng bước tối ưu hiệu suất render"></a>Từng bước tối ưu hiệu suất render</h2><h3 id="Buoc-1-Javascript"><a href="#Buoc-1-Javascript" class="headerlink" title="Bước 1: Javascript"></a>Bước 1: Javascript</h3><h4 id="1-1-Su-dung-requestAnimationFrame-de-thuc-hien-cac-thay-doi-tren-UI"><a href="#1-1-Su-dung-requestAnimationFrame-de-thuc-hien-cac-thay-doi-tren-UI" class="headerlink" title="1.1. Sử dụng requestAnimationFrame để thực hiện các thay đổi trên UI."></a>1.1. Sử dụng requestAnimationFrame để thực hiện các thay đổi trên UI.</h4><p>Khi thực hiện các thay đổi trên UI bằng JavaScript, bạn sẽ muốn thực hiện nó ngay vào lúc bắt đầu của frame, lúc đó browser sẽ có được toàn bộ 16ms để thực hiện các thay đổi (JavaScript ⇒ Style ⇒ Layout ⇒ Paint ⇒ Composite). Để làm được điều này bạn cần dùng hàm requestAnimationFrame. Hàm này có chức năng “hẹn giờ” chạy vào đúng thời điểm của frame tiếp theo.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If run as a requestAnimationFrame callback, this</span></span><br><span class="line"><span class="comment"> * will be run at the start of the frame.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateScreen</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Make visual updates here.</span></span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(updateScreen);</span><br></pre></td></tr></table></figure><p>Một số đoạn code trên mạng hoặc trong các framework thường sử dụng hàm setTimeout, tuy nhiên hàm được gọi bởi setTimeout sẽ không khởi chạy lúc bắt đầu frame, dẫn đến việc không tận dụng hết được khoảng thời gian 16ms, do đó gây ra hiện tượng frame skip, gây giật, lag.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image071-700x300.png" alt=""></p><h4 id="1-2-Chuyen-cac-tac-vu-nang-sang-Web-workers"><a href="#1-2-Chuyen-cac-tac-vu-nang-sang-Web-workers" class="headerlink" title="1.2. Chuyển các tác vụ nặng sang Web workers"></a>1.2. Chuyển các tác vụ nặng sang Web workers</h4><p>Đối với các tác vụ nặng như encode/decode, xử lý dữ liệu lớn… chúng ta nên chuyển tác vụ đó sang <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage" target="_blank" rel="noopener">Web Workers</a>. Web Workers hoạt động trên một thread riêng biệt, sẽ giúp giảm tải cho UI Thread và giúp tiết kiệm được thời gian xử lý.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSortWorker = <span class="keyword">new</span> Worker(<span class="string">"sort-worker.js"</span>);</span><br><span class="line">dataSortWorker.postMesssage(dataToSort);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The main thread is now free to continue working on other things...</span></span><br><span class="line"> </span><br><span class="line">dataSortWorker.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sortedData = evt.data;</span><br><span class="line">  <span class="comment">// Update data on screen...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Tuy nhiên, Web Workers không thể tương tác với DOM tree, do đó một số tác vụ không thể chuyển qua Web Workers được. Trong trường hợp này ta có thể áp dụng phương pháp “micro-task”: chia nhỏ task ra, sau đó sử dụng requestAnimationFrame để cập nhật UI. Lúc này, nếu mỗi task nhỏ có thời gian thực thi bé hơn 16ms thì sẽ tránh được hiện tượng giật, lag như khi chạy cả task lớn.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskList = breakBigTaskIntoMicroTasks(monsterTaskList);</span><br><span class="line">requestAnimationFrame(processTaskList);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processTaskList</span>(<span class="params">taskStartTime</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> taskFinishTime;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">   <span class="comment">// Assume the next task is pushed onto a stack.</span></span><br><span class="line">   <span class="keyword">var</span> nextTask = taskList.pop();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Process nextTask.</span></span><br><span class="line">   processTask(nextTask);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Go again if there’s enough time to do the next task.</span></span><br><span class="line">   taskFinishTime = <span class="built_in">window</span>.performance.now();</span><br><span class="line"> &#125; <span class="keyword">while</span> (taskFinishTime - taskStartTime &lt; <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (taskList.length &gt; <span class="number">0</span>)</span><br><span class="line">   requestAnimationFrame(processTaskList);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Su-dung-Chrome-DevTools-de-“dieu-tra”-JavaScript-execution"><a href="#1-3-Su-dung-Chrome-DevTools-de-“dieu-tra”-JavaScript-execution" class="headerlink" title="1.3. Sử dụng Chrome DevTools để “điều tra” JavaScript execution"></a>1.3. Sử dụng Chrome DevTools để “điều tra” JavaScript execution</h4><p>Chrome DevTools là công cụ cực kỳ hữu ích. Ở tab “Timeline” của Chrome DevTools, bạn có thể kiểm tra được độ mượt của web page bằng cách:</p><ol><li>Nhấn nút Record (hoặc Ctrl + R trên Windows, Command + R trên Mac)</li><li>Thực hiện animation / transition trên trang web chính</li><li><p>Nhấn nút Stop Record.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image24-700x515.png" alt=""></p></li></ol><p>Chrome DevTools sẽ hiển thị toàn bộ các thông tin liên quan đến các tác vụ JavaScript ⇒ Style ⇒ Layout ⇒ Paint ⇒ Composite. Bạn có thể kiếm tra để xem tác vụ nào chiếm nhiều thời gian nhất và gây ra frame skip.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image06.png" alt=""></p><h3 id="Buoc-2-Style-calculation"><a href="#Buoc-2-Style-calculation" class="headerlink" title="Bước 2: Style calculation"></a>Bước 2: Style calculation</h3><p>Cố gắng giữ cho selector của bạn càng đơn giản càng tốt, và giảm số lượng element bị ảnh hưởng bởi selector, ví dụ:</p><p>Nên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123; <span class="comment">/* styles */</span> &#125;</span><br></pre></td></tr></table></figure><p>Không nên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:nth-last-child(-n+1)</span> <span class="selector-class">.title</span> &#123; <span class="comment">/* styles */</span> &#125;</span><br></pre></td></tr></table></figure><p>Không nên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*, *<span class="selector-pseudo">:before</span>, *<span class="selector-pseudo">:after</span> &#123; <span class="comment">/* styles */</span> &#125;</span><br></pre></td></tr></table></figure><p>Nên:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="comment">/* styles */</span> &#125;</span><br></pre></td></tr></table></figure><p>Việc sử dụng các selector này cần phải cân bằng giữa việc code gọn gàng đẹp đẽ và hiệu suất. Khi sử dụng các selector phức tạp thì browser cần phải thực hiện nhiều tính toán, nhưng nếu chỉ sử dụng các selector đơn giản thì lại khiến code của chúng ta khó quản lý.</p><p>Giải pháp ở đây là chúng ta nên sử dụng một số kỹ thuật quản lý style như: <a href="https://bem.info/" target="_blank" rel="noopener">BEM (Block, Element, Modifier)</a>, <a href="https://github.com/postcss/postcss" target="_blank" rel="noopener">PostCSS</a>. Các công cụ này sẽ giúp chúng ta vừa dễ quản lý code CSS ở môi trường dev, và cũng vừa đảm bảo hiệu suất ở môi trường production sau khi build.</p><h3 id="Buoc-3-Layout"><a href="#Buoc-3-Layout" class="headerlink" title="Bước 3: Layout"></a>Bước 3: Layout</h3><h4 id="3-1-Han-che-kich-hoat-tinh-toan-layout"><a href="#3-1-Han-che-kich-hoat-tinh-toan-layout" class="headerlink" title="3.1. Hạn chế kích hoạt tính toán layout"></a>3.1. Hạn chế kích hoạt tính toán layout</h4><p>Việc thay đổi một số thuộc tính CSS của element có thể kích hoạt browser tính toán lại layout của element đó.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Changing width and height</span></span><br><span class="line"><span class="comment"> * triggers layout.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-class">.box--expanded</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">350px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Khi một element bị thay đổi layout thì thường là các element khác cũng sẽ bị thay đổi theo (kích thước, vị trí…). Do đó nếu trang của bạn có nhiều element và việc kích hoạt layout diễn ra quá thường xuyên thì hoàn toàn không tốt cho performance.</p><p>Bạn có thể sử dụng Chrome DevTools để kiểm tra xem web page của bạn có bị kích hoạt layout quá nhiều hay không.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image02-700x489.png" alt=""></p><p>Ví dụ trong hình này, bạn có thể thấy sự kiện Layout chiếm tới 20.636ms, vượt qua con số 16ms và tất nhiên là sẽ dẫn đến frame skip, số lượng element cần tính toán lại layout là 1618 (rất nhiều).</p><p>Để biết được những thuộc tính nào sẽ kích hoạt Layout (và lý do vì sao), bạn có thể tra cứu ở trang <a href="http://csstriggers.com/" target="_blank" rel="noopener">http://csstriggers.com/</a> – công cụ do một Googler viết cho mục đích tra cứu.</p><h4 id="3-2-Su-dung-cac-thuoc-tinh-moi-cua-CSS3"><a href="#3-2-Su-dung-cac-thuoc-tinh-moi-cua-CSS3" class="headerlink" title="3.2. Sử dụng các thuộc tính mới của CSS3"></a>3.2. Sử dụng các thuộc tính mới của CSS3</h4><p>CSS3 có cung cấp một số thuộc tính mới không những giúp chúng ta canh chỉnh layout dễ hơn mà còn giúp tăng hiệu suất rất nhiều. Điển hình là Flexbox, việc sử dụng flexbox để canh chỉnh layout sẽ dễ hơn so với cách dùng float truyền thống.</p><p>Xem bài hướng dẫn tuyệt vời về Flexbox: <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">http://css-tricks.com/snippets/css/a-guide-to-flexbox/</a></p><p>Về hiệu suất, dưới đây là 2 hình ảnh đo hiệu suất của việc kích hoạt layout trên 1300 elements.</p><p>Sử dụng Float:</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image16-700x476.png" alt=""></p><p>Sử dụng Flexbox:</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image14-700x454.png" alt=""></p><p>Có thể thấy con số “Self Time” giảm từ <strong>~14ms</strong> chỉ còn <strong>~3.5ms</strong>, đó là một sự thay đổi rất đáng kể.</p><h4 id="3-3-Han-che-kich-hoat-layout-som"><a href="#3-3-Han-che-kich-hoat-layout-som" class="headerlink" title="3.3. Hạn chế kích hoạt layout sớm"></a>3.3. Hạn chế kích hoạt layout sớm</h4><p>Hãy xem xét đoạn code sau: thay đổi kích thước của 3 elements</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> h1 = element1.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write (invalidates layout)</span></span><br><span class="line">element1.style.height = (h1 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Read (triggers layout)</span></span><br><span class="line"><span class="keyword">var</span> h2 = element2.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write (invalidates layout)</span></span><br><span class="line">element2.style.height = (h2 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Read (triggers layout)</span></span><br><span class="line"><span class="keyword">var</span> h3 = element3.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write (invalidates layout)</span></span><br><span class="line">element3.style.height = (h3 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure><p>Khi một element (DOM) được ghi giá trị mới thì layout sẽ bị đánh dấu <strong>giá trị hết hiệu lực</strong> (invalidates) và sẽ được tính toán lại tại một thời điểm nào đó. Để đảm bảo performance, browser sẽ thực hiện tính toán lại layout vào <strong>thời điểm bắt đầu của frame tiếp theo</strong>.</p><p>Tuy nhiên nếu trong thời gian <strong>frame hiện tại chưa kết thúc</strong>, ta muốn lấy giá trị kích thước của element thì lúc này browser buộc phải thực hiện <strong>tính toán layout lại sớm hơn</strong> so với thông thường để có thể trả về kết quả. Hiện tượng này gọi là “forced synchronous layout” – tạm dịch “kích hoạt layout sớm”, và nó gây ra vấn đề về performance khi ta phải thực hiện nhiều tác vụ hơn trong 1 frame.</p><p>Để giải quyết, cách nhanh nhất là chúng ta sẽ “đọc trước, ghi sau”.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> h1 = element1.clientHeight;</span><br><span class="line"><span class="keyword">var</span> h2 = element2.clientHeight;</span><br><span class="line"><span class="keyword">var</span> h3 = element3.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write (invalidates layout)</span></span><br><span class="line">element1.style.height = (h1 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">element2.style.height = (h2 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">element3.style.height = (h3 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Document reflows at end of frame</span></span><br></pre></td></tr></table></figure><p>Hoặc sử dụng requestAnimationFrame để “hẹn giờ” cho cả 3 thao tác ghi vào frame tiếp theo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> h1 = element1.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write</span></span><br><span class="line">requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> element1.style.height = (h1 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> h2 = element2.clientHeight;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Write</span></span><br><span class="line">requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> element2.style.height = (h2 * <span class="number">2</span>) + <span class="string">'px'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Bằng cách này, cả 3 thao tác ghi đều sẽ được thực hiện một lần trong frame tiếp theo, tốt hơn cho hiệu suất.</p><p>Bạn sẽ thấy rõ tác dụng của việc hạn chế layout sớm trong một số trường hợp thực tế như sau “Layout thrashing”:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Puts the browser into a read-write-read-write cycle.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">  paragraphs[i].style.width = box.offsetWidth + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Như đoạn code trên, layout sẽ liên tục bị trigger và kích hoạt sớm ở trong vòng lặp (read: box.offsetWidth, và write: paragraphs[i].style.width) điều này là thảm họa cho browser</p><p>(hình: dấu chấm than vàng là báo hiệu <strong>forced synchronous layout</strong>).</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image17.png" alt=""></p><p>Nếu đã biết về vấn đề forced synchronous layout, đoạn code trên nên được viết lại như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read.</span></span><br><span class="line"><span class="keyword">var</span> width = box.offsetWidth;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeAllParagraphsToMatchBlockWidth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">   <span class="comment">// Now write.</span></span><br><span class="line">   paragraphs[i].style.width = width + <span class="string">'px'</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nếu cảm thấy việc quản lý layout quá phức tạp, bạn có thể tham khảo sử dụng thư viện <a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">FastDOM</a>, thư viện này giúp bạn quản lý các tác vụ read/write để đảm bảo không gây ra forced synchronous layout.</p><h3 id="Buoc-4-Paint"><a href="#Buoc-4-Paint" class="headerlink" title="Bước 4: Paint"></a>Bước 4: Paint</h3><h4 id="4-1-Dung-Chrome-Developer-Tools-de-phat-hien-van-de-performance-khi-paint"><a href="#4-1-Dung-Chrome-Developer-Tools-de-phat-hien-van-de-performance-khi-paint" class="headerlink" title="4.1. Dùng Chrome Developer Tools để phát hiện vấn đề performance khi paint"></a>4.1. Dùng Chrome Developer Tools để phát hiện vấn đề performance khi paint</h4><p>Bất kỳ sự thay đổi nào trên màn hình browser đều yêu cầu quá trình paint, animation, transition, lúc bôi đen đoạn text hay cả con trỏ nhấp nháy ở textbox.</p><p>Để biết được browser phải vẽ lại những phần nào trên màn hình, bạn có thể bật chức năng “Show paint rectangles” ở tab “Rendering” trong Chrome Developer Tools.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image18.png" alt=""></p><p>Những vùng bị vẽ lại sẽ được tô và hiển thị màu xanh lá cây trên màn hình.</p><p> <img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image21-700x454.png" alt=""></p><p>Bạn có thể xem chi tiết hoạt động vẽ của browser bằng cách kích hoạt chế độ “Paint profiler” ở tab “Timeline” khi record.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image03.png" alt=""></p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image04.png" alt=""></p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image15-700x454.png" alt=""></p><p>Ở chế độ này, bạn có thể kiểm tra <strong>quá trình vẽ của tất cả các element</strong> trong web page. Dựa vào các thông tin này bạn có thể phân tích và đưa ra hướng giải quyết phù hợp nếu quá trình paint mất quá nhiều thời gian. Một số yếu tố khiến quá trình paint diễn ra chậm:</p><ul><li>Các hiệu ứng CSS phức tạp: box-shadow, gradient, curves</li><li>Các element chồng đè lên nhau.</li><li>Các hình ảnh có kích thước quá lớn</li><li>…</li></ul><h4 id="4-2-Su-dung-hop-ly-cac-layer"><a href="#4-2-Su-dung-hop-ly-cac-layer" class="headerlink" title="4.2. Sử dụng hợp lý các layer"></a>4.2. Sử dụng hợp lý các layer</h4><p>Trên thực tế, quá trình vẽ diễn ra song song trên nhiều các layer khác nhau, việc phân chia các layer hợp lý sẽ giúp tiết kiệm được thời gian vẽ rất nhiều.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image27-700x602.png" alt=""></p><p>Ví dụ trong trường hợp này, khi bạn cuộn trang thì browser phải vẽ lại layer trên cùng (text), còn layer hình bên dưới có vị trí cố định, không có gì thay đổi nên không cần phải vẽ lại nữa. Các layer này sẽ được gộp lại (ở bước cuối cùng – composite) và hiển thị lên màn hình.</p><p><strong>Làm sao để tạo layer?</strong></p><p>Vẽ – Paint – là tác vụ nặng nhất, chiếm nhiều thời gian nhất trong các bước, do đó bạn có thể thấy rõ được lợi ích của việc <strong>phân chia các layer làm sao cho browser ít phải vẽ lại nhất</strong>.</p><p>Một layer (compositor layer) sẽ được tạo khi bạn sử dụng thuộc tính will-change (trên Chrome, Opera, Firefox) thuộc tính này báo hiệu cho browser biết element sẽ có sự thay đổi, do đó sẽ đưa element này vào một layer mới.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moving-element</span> &#123; <span class="attribute">will-change</span>: transform; &#125;</span><br></pre></td></tr></table></figure><p>Đối với các browser không hỗ trợ will-change bạn có thể sử dụng thuộc tính 3D transform để “ép buộc” tạo layer mới:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moving-element</span> &#123; <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0); &#125;</span><br></pre></td></tr></table></figure><p>Cần lưu ý, việc tạo layer mới sẽ yêu cầu thêm bộ nhớ và tác vụ để quản lý các layer, do đó bạn không nên tạo quá nhiều layer, và chiến lược tao layer ở đây không cố định mà còn tùy thuộc vào tính chất của các animation, transition có trên website của bạn.</p><p><strong>Không nên:</strong> (layer explosions – tạo ra quá nhiều layer không cần thiết)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123; </span><br><span class="line"> <span class="attribute">will-change</span>: transform;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Buoc-5-Composite"><a href="#Buoc-5-Composite" class="headerlink" title="Bước 5: Composite"></a>Bước 5: Composite</h2><p>Tại bước này, browser sẽ tiến hành gộp các compositor layer đã được vẽ (ở bước 4) và hiển thị lên màn hình.</p><p>Trường hợp lý tưởng nhất cho performance là bỏ qua 2 bước Layout và Paint, công việc của browser chỉ là thay đổi các compositor layer để tạo ra một frame.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image20-700x107.png" alt=""></p><p>Để làm được điều đó, bạn chỉ được thay đổi các thuộc tính mà Compositor có thể xử lý độc lập (mà không cần phải kích hoạt Layout và Paint). Các thuộc tính đó là <strong>transform</strong> và <strong>opacity</strong>.</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image12-700x525.png" alt=""></p><p>Tuy nhiên trên thực tế chúng ta cần phải thay đổi nhiều thuộc tính hơn nữa để đáp ứng được yêu cầu khi animate các hiệu ứng. Do đó, giải pháp chính là phải <strong><span class="c0">tạo và quản lý được các layer một cách hợp lý</span></strong>. Để quản lý được các layer, bạn có thể sử dụng công cụ Chrome Developer Tools.</p><p>Trong tab “Timeline” đánh dấu vào mục Paint</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image26.png" alt=""></p><p>Tiến hành record và chọn phần Paint trên kết quả hiển thị</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image08.png" alt=""></p><p>Ở đây bạn sẽ thấy thẻ “Layer” trong phần thông tin của frame</p><p><img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image001.png" alt=""></p><p>Từ đây bạn có thể tra cứu toàn bộ các frame mà web page đang có.</p><p> <img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image13-700x525.png" alt=""></p><p>Danh sách các layer được liệt kê dưới dạng cây (layer tree), preview dạng 3D, có thông tin về kích thước, bộ nhớ, lý do layer được tạo…</p><h2 id="Tong-ket"><a href="#Tong-ket" class="headerlink" title="Tổng kết"></a>Tổng kết</h2><p>Như vậy là ta đã đi từng bước để có thể tối ưu hiệu suất render cho web page:</p><ul><li><p><strong>JavaScript</strong><br>   – Dùng requestAnimationFrame<br>   – Dùng Web workers, Micro-task cho tác vụ nặng<br>   – Profiling with Chrome DevTools</p></li><li><p><strong>Style</strong><br>   – Giảm độ phức tạp của selector<br>   – Giảm số lượng element bị ảnh hưởng</p></li><li><p><strong>Layout</strong><br>   – Hạn chế kích hoạt layout<br>   – Sử dụng Flexbox<br>   – Hạn chế forced synchronous layout.</p></li><li><p><strong>Paint</strong><br>   – Paint là tác vụ xử lý lâu nhất<br>   – Box-shadow, large image không tốt cho paint<br>   – Tạo và quản lý layer hợp lý</p></li><li><p><strong>Composite</strong><br>   – Sử dụng transform và opacity<br>   – Quản lý các layer bằng Chrome DevTools</p></li></ul><p>Sau khi đã thực hiện những bước trên, web page của bạn sẽ hoạt động mượt mà, trơn tru với 60fps. Chúc bạn thành công!</p><p>60FPS FOR THE WIN!</p><h1 id="Chuyen-ngoai-le"><a href="#Chuyen-ngoai-le" class="headerlink" title="Chuyện ngoài lề"></a>Chuyện ngoài lề</h1><p>Ở Silicon Straits Saigon, chúng tôi có một bài test dành cho Front-end Developer, đó là implement hiệu ứng scrolling sau (ảnh động, load hơi lâu): <a href="https://bit.ly/1CCYx9y" target="_blank" rel="noopener">http://bit.ly/1CCYx9y</a></p><p>Các bạn có thể vận dụng những kiến thức có được trong bài viết này để “thử sức” với hiệu ứng trên.</p><p>Đây là bài làm của tôi, mặc dù không được hoàn hảo nhưng có thể dùng được cho mục đích tham khảo.</p><p>Link: <a href="https://trungdq88.github.io/css-stuffs/delay-scroll/" target="_blank" rel="noopener">http://trungdq88.github.io/css-stuffs/delay-scroll/</a></p><p>Timeline Record:</p><p> <img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image05-700x455.png" alt=""></p><p>Layers (một phần):</p><p> <img src="https://4qr7k2a2xza2vctux33bisalkw-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/image10-700x299.png" alt=""></p><h2 id="Cac-nguon-tham-khao-trong-bai-viet"><a href="#Cac-nguon-tham-khao-trong-bai-viet" class="headerlink" title="Các nguồn tham khảo trong bài viết:"></a>Các nguồn tham khảo trong bài viết:</h2><p>Một số hình ảnh và code mẫu:</p><ul><li>Google Developer: <a href="https://developers.google.com/web/fundamentals/performance/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/</a></li><li>Preventing Layout Thrashing:<a href="http://wilsonpage.co.uk/preventing-layout-thrashing/" target="_blank" rel="noopener">http://wilsonpage.co.uk/preventing-layout-thrashing/</a></li></ul><p>Các trang web có hiệu ứng đẹp:</p><ul><li><a href="http://world.mathigon.org/" target="_blank" rel="noopener">http://world.mathigon.org/</a></li><li><a href="http://matthew.wagerfield.com/parallax/" target="_blank" rel="noopener">http://matthew.wagerfield.com/parallax/</a></li></ul><p>Khóa học:</p><ul><li>Udacity Course: Browser Rendering Optimization – Building 60 FPS Web Apps: <a href="https://www.udacity.com/course/browser-rendering-optimization--ud860" target="_blank" rel="noopener">https://www.udacity.com/course/browser-rendering-optimization–ud860</a></li></ul><p>Các nguồn khác:</p><ul><li>Web Workers: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage</a></li><li>BEM: <a href="https://bem.info/" target="_blank" rel="noopener">https://bem.info/</a></li><li>PostCSS: <a href="https://github.com/postcss/postcss" target="_blank" rel="noopener">https://github.com/postcss/postcss</a></li><li>CSS Trigger: <a href="http://csstriggers.com/" target="_blank" rel="noopener">http://csstriggers.com/</a></li><li>Guide to Flexbox: <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">http://css-tricks.com/snippets/css/a-guide-to-flexbox/</a></li><li>FastDOM: <a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">https://github.com/wilsonpage/fastdom</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Optimizing Performance&lt;/strong&gt; (tối ưu hóa hiệu suất) cho website là một công việc mà bất kỳ front-end developer nào cũng nên biết, mục đích là để trang web đáp ứng được 3 tiêu chí:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;NHẸ&lt;/strong&gt;: Giảm kích thước trang web và các thành phần đi kèm như javascript, css, hình ảnh… nhằm đảm bảo &lt;strong&gt;thời gian tải xuống ngắn hơn&lt;/strong&gt;. Chúng ta có thể dùng các bộ minify cho javascript, css…, nén các tập tin hình ảnh, font chữ, svg… ngoài ra còn có các kĩ thuật như code splitting, browser caching, HTTP caching…&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NHANH&lt;/strong&gt; &lt;strong&gt;Hiển thị nội dung trang web càng sớm càng tốt&lt;/strong&gt; bằng cách: chia cấu trúc DOM hợp lý, hạn chế blocking CSS/JS, hạn chế chỉnh sửa DOM tree, chia các file ra thành nhiều module, tải resource bất đồng bộ, tối ưu hóa các selector của CSS và JS…&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MƯỢT&lt;/strong&gt;: Sau khi nội dung trang web đã được tải về và hiển thị thì việc tiếp theo là &lt;strong&gt;bảo đảm các hiệu ứng animation, transition, scrolling… phải mượt&lt;/strong&gt;, không bị lag và giật (jank).&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>10 câu hỏi phỏng vấn mà Javascript Developer nên biết</title>
    <link href="http://nthung2112.github.io/2018/06/10-cau-hoi-phong-van-ma-Javascript-Developer-nen-biet.html"/>
    <id>http://nthung2112.github.io/2018/06/10-cau-hoi-phong-van-ma-Javascript-Developer-nen-biet.html</id>
    <published>2018-06-23T15:11:00.000Z</published>
    <updated>2018-06-23T15:28:47.131Z</updated>
    
    <content type="html"><![CDATA[<p>Tại hầu hết các công ty, người quản lý phải tin tưởng các developers, cho họ tham gia các cuộc phỏng vấn kỹ thuật để đánh giá các kỹ năng ứng cử viên. Nếu bạn làm tốt như một ứng cử viên, bạn sẽ cần phải phỏng vấn. Đây là cách làm.</p><a id="more"></a><h3 id="It-Starts-With-People"><a href="#It-Starts-With-People" class="headerlink" title="It Starts With People"></a>It Starts With People</h3><p>In <a href="https://medium.com/javascript-scene/how-to-build-a-high-velocity-development-team-4b2360d34021" target="_blank" rel="noopener">“How to Build a High Velocity Development Team”</a>, Tôi đã nêu một vài điểm đáng để lặp lại:</p><blockquote><p>“Nothing predicts business outcomes better than an exceptional team. If you’re going to beat the odds, you need to invest here, first.”</p></blockquote><p>Như Marcus Lemonis đã nói, cần tập trung vào 3 P’s:</p><hr><blockquote><p>“People, Process, Product”</p></blockquote><hr><div class="video-container"><iframe src="//www.youtube.com/embed/37rMZSA6oLk" frameborder="0" allowfullscreen></iframe></div><p>Your early hires should be very strong, senior-level candidates. People who can hire and mentor other developers, and help the mid-level and junior developers you’ll eventually want to hire down the road.</p><p>Read <a href="https://medium.com/javascript-scene/why-hiring-is-so-hard-in-tech-c462c3230017" target="_blank" rel="noopener">“Why Hiring is So Hard in Tech”</a> for a good breakdown of the general do’s and don’ts of candidate evaluation.</p><hr><blockquote><p>The best way to evaluate a candidate is a pair programming exercise.</p></blockquote><hr><p>Pair program with the candidate. Let the candidate drive. Watch and listen more than you talk. A good project might be to pull tweets from the Twitter API and display them on a timeline.</p><p>That said, no single exercise will tell you everything you need to know. An interview can be a very useful tool as well, but don’t waste time asking about syntax or language quirks. You need to see the big picture. Ask about architecture and paradigms — the big decisions that can have a major impact on the whole project.</p><p>Syntax and features are easy to Google. It’s much harder to Google for software engineering wisdom or the common paradigms and idioms JavaScript developers pick up with experience.</p><p>JavaScript is special, and it plays a critical role in almost every large application. What is it about JavaScript that makes it meaningfully different from other languages?</p><p>Here are some questions that will help you explore the stuff that really matters:</p><h4 id="1-Can-you-name-two-programming-paradigms-important-for-JavaScript-app-developers"><a href="#1-Can-you-name-two-programming-paradigms-important-for-JavaScript-app-developers" class="headerlink" title="1. Can you name two programming paradigms important for JavaScript app developers?"></a>1. Can you name two programming paradigms important for JavaScript app developers?</h4><p>JavaScript is a multi-paradigm language, supporting <strong>imperative/procedural</strong> programming along with <strong>OOP</strong> (Object-Oriented Programming) and <strong>functional programming</strong>. JavaScript supports OOP with <strong>prototypal inheritance</strong>.</p><p><strong>Good to hear:</strong></p><ul><li>Prototypal inheritance (also: prototypes, OLOO).</li><li>Functional programming (also: closures, first class functions, lambdas).</li></ul><p><strong>Red flags:</strong></p><ul><li>No clue what a paradigm is, no mention of prototypal oo or functional programming.</li></ul><h4 id="2-What-is-functional-programming"><a href="#2-What-is-functional-programming" class="headerlink" title="2. What is functional programming?"></a>2. What is functional programming?</h4><p>Functional programming produces programs by composing mathematical functions and avoids shared state &amp; mutable data. Lisp (specified in 1958) was among the first languages to support functional programming, and was heavily inspired by lambda calculus. Lisp and many Lisp family languages are still in common use today.</p><p>Functional programming is an essential concept in JavaScript (one of the two pillars of JavaScript). Several common functional utilities were added to JavaScript in ES5.</p><p><strong>Good to hear:</strong></p><ul><li>Pure functions / function purity.</li><li>Avoid side-effects.</li><li>Simple function composition.</li><li>Examples of functional languages: Lisp, ML, Haskell, Erlang, Clojure, Elm, F Sharp, OCaml, etc…</li><li>Mention of features that support FP: first-class functions, higher order functions, functions as arguments/values.</li></ul><p><strong>Red flags:</strong></p><ul><li>No mention of pure functions / avoiding side-effects.</li><li>Unable to provide examples of functional programming languages.</li><li>Unable to identify the features of JavaScript that enable FP.</li></ul><h4 id="3-What-is-the-difference-between-classical-inheritance-and-prototypal-inheritance"><a href="#3-What-is-the-difference-between-classical-inheritance-and-prototypal-inheritance" class="headerlink" title="3. What is the difference between classical inheritance and prototypal inheritance?"></a>3. What is the difference between classical inheritance and prototypal inheritance?</h4><p><strong>Class Inheritance:</strong> instances inherit from classes (like a blueprint — a description of the class), and create sub-class relationships: hierarchical class taxonomies. Instances are typically instantiated via constructor functions with the <em><code>new</code></em> keyword. Class inheritance may or may not use the <em><code>class</code></em> keyword from ES6.</p><p><strong>Prototypal Inheritance:</strong> instances inherit directly from other objects. Instances are typically instantiated via factory functions or <em><code>Object.create()</code>.</em> Instances may be composed from many different objects, allowing for easy selective inheritance.</p><hr><blockquote><p>In JavaScript, prototypal inheritance is simpler &amp;<br>more flexible than class inheritance.</p></blockquote><hr><p><strong>Good to hear:</strong></p><ul><li>Classes: create tight coupling or hierarchies/taxonomies.</li><li>Prototypes: mentions of concatenative inheritance, prototype delegation, functional inheritance, object composition.</li></ul><p><strong>Red Flags:</strong></p><ul><li>No preference for prototypal inheritance &amp; composition over class inheritance.</li></ul><h4 id="4-What-are-the-pros-and-cons-of-functional-programming-vs-object-oriented-programming"><a href="#4-What-are-the-pros-and-cons-of-functional-programming-vs-object-oriented-programming" class="headerlink" title="4. What are the pros and cons of functional programming vs object-oriented programming?"></a>4. What are the pros and cons of functional programming vs object-oriented programming?</h4><p><strong>OOP Pros:</strong> It’s easy to understand the basic concept of objects and easy to interpret the meaning of method calls. OOP tends to use an imperative style rather than a declarative style, which reads like a straight-forward set of instructions for the computer to follow.</p><p><strong>OOP Cons:</strong> OOP Typically depends on shared state. Objects and behaviors are typically tacked together on the same entity, which may be accessed at random by any number of functions with non-deterministic order, which may lead to undesirable behavior such as race conditions.</p><p><strong>FP Pros:</strong> Using the functional paradigm, programmers avoid any shared state or side-effects, which eliminates bugs caused by multiple functions competing for the same resources. With features such as the availability of point-free style (aka tacit programming), functions tend to be radically simplified and easily recomposed for more generally reusable code compared to OOP.</p><p>FP also tends to favor declarative and denotational styles, which do not spell out step-by-step instructions for operations, but instead concentrate on <strong>what</strong> to do, letting the underlying functions take care of the <strong>how</strong>. This leaves tremendous latitude for refactoring and performance optimization, even allowing you to replace entire algorithms with more efficient ones with very little code change. (e.g., memoize, or use lazy evaluation in place of eager evaluation.)</p><p>Computation that makes use of pure functions is also easy to scale across multiple processors, or across distributed computing clusters without fear of threading resource conflicts, race conditions, etc…</p><p><strong>FP Cons:</strong> Over exploitation of FP features such as point-free style and large compositions can potentially reduce readability because the resulting code is often more abstractly specified, more terse, and less concrete.</p><p>More people are familiar with _OO_ and imperative programming than functional programming, so even common idioms in functional programming can be confusing to new team members.</p><p>FP has a much steeper learning curve than OOP because the broad popularity of OOP has allowed the language and learning materials of OOP to become more conversational, whereas the language of FP tends to be much more academic and formal. FP concepts are frequently written about using idioms and notations from lambda calculus, algebras, and category theory, all of which requires a prior knowledge foundation in those domains to be understood.</p><p><strong>Good to hear:</strong></p><ul><li>Mentions of trouble with shared state, different things competing for the same resources, etc…</li><li>Awareness of FP’s capability to radically simplify many applications.</li><li>Awareness of the differences in learning curves.</li><li>Articulation of side-effects and how they impact program maintainability.</li><li>Awareness that a highly functional codebase can have a steep learning curve.</li><li>Awareness that a highly OOP codebase can be extremely resistant to change and very brittle compared to an equivalent FP codebase.</li><li>Awareness that immutability gives rise to an extremely accessible and malleable program state history, allowing for the easy addition of features like infinite undo/redo, rewind/replay, time-travel debugging, and so on. Immutability can be achieved in either paradigm, but a proliferation of shared stateful objects complicates the implementation in OOP.</li></ul><p><strong>Red flags:</strong></p><ul><li>Unable to list disadvantages of one style or another — Anybody experienced with either style should have bumped up against some of the limitations.</li></ul><p><strong>Learn More:</strong></p><ul><li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 1</a> — Prototypal OO.</li><li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 2</a> — Functional Programming.</li></ul><h4 id="5-When-is-classical-inheritance-an-appropriate-choice"><a href="#5-When-is-classical-inheritance-an-appropriate-choice" class="headerlink" title="5. When is classical inheritance an appropriate choice?"></a>5. When is classical inheritance an appropriate choice?</h4><p>The answer is never, or almost never. Certainly never more than one level. Multi-level class hierarchies are an anti-pattern. I’ve been issuing this challenge for years, and the only answers I’ve ever heard fall into one of several <a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a" target="_blank" rel="noopener">common misconceptions</a>. More frequently, the challenge is met with silence.</p><blockquote><p>“If a feature is sometimes useful<br>and sometimes dangerous<br>and if there is a better option<br>then <strong>always use the better option</strong>.”<br>~ Douglas Crockford</p></blockquote><p><strong>Good to hear:</strong></p><ul><li>Rarely, almost never, or never.</li><li>A single level is sometimes OK, from a framework base-class such as React.Component.</li><li>“Favor object composition over class inheritance.”</li></ul><h4 id="6-When-is-prototypal-inheritance-an-appropriate-choice"><a href="#6-When-is-prototypal-inheritance-an-appropriate-choice" class="headerlink" title="6. When is prototypal inheritance an appropriate choice?"></a>6. When is prototypal inheritance an appropriate choice?</h4><p>There is more than one type of prototypal inheritance:</p><ul><li><strong>Delegation</strong> (i.e., the prototype chain).</li><li><strong>Concatenative</strong> (i.e. mixins, <em><code>Object.assign()</code></em>).</li><li><strong>Functional</strong> (Not to be confused with functional programming. A function used to create a closure for private state/encapsulation).</li></ul><p>Each type of prototypal inheritance has its own set of use-cases, but all of them are equally useful in their ability to enable <strong>composition,</strong> which creates <strong>has-a</strong> or <strong>uses-a</strong> or <strong>can-do</strong> relationships as opposed to the <strong>is-a</strong> relationship created with class inheritance.</p><p><strong>Good to hear</strong>:</p><ul><li>In situations where modules or functional programming don’t provide an obvious solution.</li><li>When you need to compose objects from multiple sources.</li><li>Any time you need inheritance.</li></ul><p><strong>Red flags:</strong></p><ul><li>No knowledge of when to use prototypes.</li><li>No awareness of mixins or <em><code>Object.assign()</code>.</em></li></ul><h4 id="7-What-does-“favor-object-composition-over-class-inheritance”-mean"><a href="#7-What-does-“favor-object-composition-over-class-inheritance”-mean" class="headerlink" title="7. What does “favor object composition over class inheritance” mean?"></a>7. What does “favor object composition over class inheritance” mean?</h4><p>This is a quote from <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="noopener">“Design Patterns: Elements of Reusable Object-Oriented Software”</a>. It means that code reuse should be achieved by assembling smaller units of functionality into new objects instead of inheriting from classes and creating object taxonomies.</p><p>In other words, use <strong>can-do, has-a,</strong> or <strong>uses-a</strong> relationships instead of <strong>is-a</strong> relationships.</p><p><strong>Good to hear:</strong></p><ul><li>Avoid class hierarchies.</li><li>Avoid brittle base class problem.</li><li>Avoid tight coupling.</li><li>Avoid rigid taxonomy (forced is-a relationships that are eventually wrong for new use cases).</li><li>Avoid the gorilla banana problem (“what you wanted was a banana, what you got was a gorilla holding the banana, and the entire jungle”).</li><li>Make code more flexible.</li></ul><p><strong>Red Flags:</strong></p><ul><li>Fail to mention any of the problems above.</li><li>Fail to articulate the difference between composition and class inheritance, or the advantages of composition.</li></ul><h4 id="8-What-are-two-way-data-binding-and-one-way-data-flow-and-how-are-they-different"><a href="#8-What-are-two-way-data-binding-and-one-way-data-flow-and-how-are-they-different" class="headerlink" title="8. What are two-way data binding and one-way data flow, and how are they different?"></a>8. What are two-way data binding and one-way data flow, and how are they different?</h4><p>Two way data binding means that UI fields are bound to model data dynamically such that when a UI field changes, the model data changes with it and vice-versa.</p><p>One way data flow means that the model is the single source of truth. Changes in the UI trigger messages that signal user intent to the model (or “store” in React). Only the model has the access to change the app’s state. The effect is that data always flows in a single direction, which makes it easier to understand.</p><p>One way data flows are deterministic, whereas two-way binding can cause side-effects which are harder to follow and understand.</p><p><strong>Good to hear:</strong></p><ul><li>React is the new canonical example of one-way data flow, so mentions of React are a good signal. Cycle.js is another popular implementation of uni-directional data flow.</li><li>Angular is a popular framework which uses two-way binding.</li></ul><p><strong>Red flags:</strong></p><ul><li>No understanding of what either one means. Unable to articulate the difference.</li></ul><h4 id="9-What-are-the-pros-and-cons-of-monolithic-vs-microservice-architectures"><a href="#9-What-are-the-pros-and-cons-of-monolithic-vs-microservice-architectures" class="headerlink" title="9. What are the pros and cons of monolithic vs microservice architectures?"></a>9. What are the pros and cons of monolithic vs microservice architectures?</h4><p>A monolithic architecture means that your app is written as one cohesive unit of code whose components are designed to work together, sharing the same memory space and resources.</p><p>A microservice architecture means that your app is made up of lots of smaller, independent applications capable of running in their own memory space and scaling independently from each other across potentially many separate machines.</p><p><strong>Monolithic Pros:</strong> The major advantage of the monolithic architecture is that most apps typically have a large number of cross-cutting concerns, such as logging, rate limiting, and security features such audit trails and DOS protection.</p><p>When everything is running through the same app, it’s easy to hook up components to those cross-cutting concerns.</p><p>There can also be performance advantages, since shared-memory access is faster than inter-process communication (IPC).</p><p><strong>Monolithic cons:</strong> Monolithic app services tend to get tightly coupled and entangled as the application evolves, making it difficult to isolate services for purposes such as independent scaling or code maintainability.</p><p>Monolithic architectures are also much harder to understand, because there may be dependencies, side-effects, and magic which are not obvious when you’re looking at a particular service or controller.</p><p><strong>Microservice pros:</strong> Microservice architectures are typically better organized, since each microservice has a very specific job, and is not concerned with the jobs of other components. Decoupled services are also easier to recompose and reconfigure to serve the purposes of different apps (for example, serving both the web clients and public API).</p><p>They can also have performance advantages depending on how they’re organized because it’s possible to isolate hot services and scale them independent of the rest of the app.</p><p><strong>Microservice cons:</strong> As you’re building a new microservice architecture, you’re likely to discover lots of cross-cutting concerns that you did not anticipate at design time. A monolithic app could establish shared magic helpers or middleware to handle such cross-cutting concerns without much effort.</p><p>In a microservice architecture, you’ll either need to incur the overhead of separate modules for each cross-cutting concern, or encapsulate cross-cutting concerns in another service layer that all traffic gets routed through.</p><p>Eventually, even monolthic architectures tend to route traffic through an outer service layer for cross-cutting concerns, but with a monolithic architecture, it’s possible to delay the cost of that work until the project is much more mature.</p><p>Microservices are frequently deployed on their own virtual machines or containers, causing a proliferation of VM wrangling work. These tasks are frequently automated with container fleet management tools.</p><p><strong>Good to hear:</strong></p><ul><li>Positive attitudes toward microservices, despite the higher initial cost vs monolthic apps. Aware that microservices tend to perform and scale better in the long run.</li><li>Practical about microservices vs monolithic apps. Structure the app so that services are independent from each other at the code level, but easy to bundle together as a monolithic app in the beginning. Microservice overhead costs can be delayed until it becomes more practical to pay the price.</li></ul><p><strong>Red flags:</strong></p><ul><li>Unaware of the differences between monolithic and microservice architectures.</li><li>Unaware or impractical about the additional overhead of microservices.</li><li>Unaware of the additional performance overhead caused by IPC and network communication for microservices.</li><li>Too negative about the drawbacks of microservices. Unable to articulate ways in which to decouple monolithic apps such that they’re easy to split into microservices when the time comes.</li><li>Underestimates the advantage of independently scalable microservices.</li></ul><h4 id="10-What-is-asynchronous-programming-and-why-is-it-important-in-JavaScript"><a href="#10-What-is-asynchronous-programming-and-why-is-it-important-in-JavaScript" class="headerlink" title="10. What is asynchronous programming, and why is it important in JavaScript?"></a>10. What is asynchronous programming, and why is it important in JavaScript?</h4><p>Synchronous programming means that, barring conditionals and function calls, code is executed sequentially from top-to-bottom, blocking on long-running tasks such as network requests and disk I/O.</p><p>Asynchronous programming means that the engine runs in an event loop. When a blocking operation is needed, the request is started, and the code keeps running without blocking for the result. When the response is ready, an interrupt is fired, which causes an event handler to be run, where the control flow continues. In this way, a single program thread can handle many concurrent operations.</p><p>User interfaces are asynchronous by nature, and spend most of their time waiting for user input to interrupt the event loop and trigger event handlers.</p><p>Node is asynchronous by default, meaning that the server works in much the same way, waiting in a loop for a network request, and accepting more incoming requests while the first one is being handled.</p><p>This is important in JavaScript, because it is a very natural fit for user interface code, and very beneficial to performance on the server.</p><p><strong>Good to hear:</strong></p><ul><li>An understanding of what blocking means, and the performance implications.</li><li>An understanding of event handling, and why its important for UI code.</li></ul><p><strong>Red flags:</strong></p><ul><li>Unfamiliar with the terms asynchronous or synchronous.</li><li>Unable to articulate performance implications or the relationship between asynchronous code and UI code.</li></ul><hr><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Stick to high-level topics. If they can answer these questions, that typically means that they have enough programming experience to pick up language quirks &amp; syntax in a few weeks, even if they don’t have a lot of JavaScript experience.</p><p>Don’t disqualify candidates based on stuff that’s easy to learn (including classic CS-101 algorithms, or any type of puzzle problem).</p><p>What you really need to know is, “does this candidate understand how to put an application together?”</p><p>That’s it for the spoken interview.</p><p>In real interviews, I place a much stronger emphasis on coding challenges and <strong><em>watching candidates code.</em></strong> Those topics are covered in depth in my <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" target="_blank" rel="noopener">“Master the JavaScript Interview”</a> series.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tại hầu hết các công ty, người quản lý phải tin tưởng các developers, cho họ tham gia các cuộc phỏng vấn kỹ thuật để đánh giá các kỹ năng ứng cử viên. Nếu bạn làm tốt như một ứng cử viên, bạn sẽ cần phải phỏng vấn. Đây là cách làm.&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Local Storage, Session Storage và Cookie</title>
    <link href="http://nthung2112.github.io/2018/06/Local-Storage-Session-Storage-va-Cookie.html"/>
    <id>http://nthung2112.github.io/2018/06/Local-Storage-Session-Storage-va-Cookie.html</id>
    <published>2018-06-23T11:40:00.000Z</published>
    <updated>2018-06-23T11:45:41.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Su-khac-nhau-va-cach-su-dung-Local-Storage-Session-Storage-va-Cookie"><a href="#Su-khac-nhau-va-cach-su-dung-Local-Storage-Session-Storage-va-Cookie" class="headerlink" title="Sự khác nhau và cách sử dụng Local Storage, Session Storage và Cookie"></a>Sự khác nhau và cách sử dụng Local Storage, Session Storage và Cookie</h1><p>Bạn bị lẫn lộn giữa <strong>session storage</strong>, <strong>local storage</strong> và <strong>cookies</strong>? Bài viết dưới đây sẽ giúp bạn hiểu rõ được sự khác nhau giữa 3 cách lưu trữ này. Các kiểu không gian lưu trữ khác nhau có sẵn cho các dữ liệu có thể trên máy chủ hoặc máy khách, cho phép chúng ta chọn lựa theo nhu cầu.<br><a id="more"></a></p><h2 id="1-Local-storage"><a href="#1-Local-storage" class="headerlink" title="1. Local storage"></a>1. Local storage</h2><h3 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu:"></a>Giới thiệu:</h3><ul><li>Khả năng lưu trữ vô thời hạn: Có nghĩa là chỉ bị xóa bằng JavaScript, hoặc xóa bộ nhớ trình duyệt, hoặc xóa bằng localStorage API.</li><li>Lưu trữ được 5MB: Local Storage cho phép bạn lưu trữ thông tin tương đối lớn lên đến 5MB, lưu được lượng thông tin lớn nhất trong 3 loại.</li><li>Không gửi thông tin lên server như Cookie nên bảo mật tốt hơn.</li></ul><h3 id="Trinh-duyet-ho-tro"><a href="#Trinh-duyet-ho-tro" class="headerlink" title="Trình duyệt hỗ trợ:"></a>Trình duyệt hỗ trợ:</h3><table><thead><tr><th>Trình duyệt</th><th>Phiên bản</th></tr></thead><tbody><tr><td>Chrome</td><td>&gt;= 4.0</td></tr><tr><td>Internet Explorer / Edge</td><td>&gt;= 8.0</td></tr><tr><td>Firefox</td><td>&gt;= 3.5</td></tr><tr><td>Safari</td><td>&gt;= 4.0</td></tr><tr><td>Chrome</td><td>&gt;= 11.5</td></tr></tbody></table><p>Để kiểm tra xem trình duyệt có hỗ trợ localStorage hay không thì chúng ta dùng typeof như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(Storage) !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="comment">//Nếu có hỗ trợ</span></span><br><span class="line">    <span class="comment">//Thực hiện thao tác với Storage</span></span><br><span class="line">    alert(<span class="string">'Trình duyệt của bạn hỗ trợ Storage'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//Nếu không hỗ trợ</span></span><br><span class="line">    alert(<span class="string">'Trình duyệt của bạn không hỗ trợ Storage'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Xem-localStorage-bang-trinh-duyet"><a href="#Xem-localStorage-bang-trinh-duyet" class="headerlink" title="Xem localStorage bằng trình duyệt"></a>Xem localStorage bằng trình duyệt</h3><p>Để xem localstorage bằng trình duyệt các bạn vào trang web cần xem (ở đây mình ví dụ với trang web <a href="http://book.framgia.vn/" target="_blank" rel="noopener">http://book.framgia.vn/</a>) và sau đó các bạn ấn F12 (hoặc Ctrl + shift + i) sau đó làm theo như hình sau:</p><p><img src="https://images.viblo.asia/9bcca9a7-81d0-46af-86de-6a461f67db95.png" alt=""></p><p>Chọn tab Application, di chuyển đến Storage để thấy các Storage của trình duyệt. Để xem các local Storage đang được lưu trữ, mở rộng phần Local Storage như hình. Ở đây ta có thể thấy có 2 biến Local Storage đang được lưu là <em>pusherTransportEncrypted</em> và <em>lang</em> với giá trị của 2 biến được hiển thị bên cạnh (cột Value). Như vậy, cột Key chính là danh sách các biến local Storage đang được lưu và cột Value là các giá trị tương ứng. Để xóa hết các giá trị local Storage này đi, bạn có thể chọn biểu tượng cấm (Clear All) hoặc chọn bên cạnh là biểu tượng dấu X (Delete Selected).</p><h3 id="Su-dung"><a href="#Su-dung" class="headerlink" title="Sử dụng"></a>Sử dụng</h3><ul><li>Khởi tạo localStorage</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br><span class="line"><span class="comment">// hoặc</span></span><br><span class="line">localStorage.key = <span class="string">'value'</span>;</span><br><span class="line"><span class="comment">// hoặc</span></span><br><span class="line">localStorage[<span class="string">'key'</span>] = <span class="string">'value'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Trong đó: key là tên biến, value là giá trị của biến muốn gán vào.</p></blockquote><ul><li>Để lấy giá trị localStorage và sử dụng, ta dùng getItem</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localStorage.getItem(<span class="string">'key'</span>);</span><br><span class="line"><span class="comment">// hoặc</span></span><br><span class="line">localStorage.key;</span><br></pre></td></tr></table></figure><p><strong>Ví dụ</strong> cụ thể như sau:</p><p><img src="https://images.viblo.asia/42ea1e74-930e-4457-b8a2-125036df89dc.png" alt=""></p><ul><li>Để lấy số lượng localStorage đã có trong trình duyệt, sử dụng length như sau:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.length;</span><br></pre></td></tr></table></figure><p>Ví dụ</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(Storage) !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="comment">//Nếu hỗ trợ</span></span><br><span class="line">    <span class="keyword">var</span> data = localStorage.length;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Nếu không hỗ trợ</span></span><br><span class="line">    alert(<span class="string">'Trình duyệt của bạn không hỗ trợ'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Để xóa 1 biến trong localStorage, sử dụng removeItem(tên_key)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.removeItem(key);</span><br></pre></td></tr></table></figure><p>Hoặc xóa tất cả các biến trong localStorage, sử dụng clear</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure><h2 id="2-Session-Storage"><a href="#2-Session-Storage" class="headerlink" title="2. Session Storage"></a>2. Session Storage</h2><h3 id="Gioi-thieu-1"><a href="#Gioi-thieu-1" class="headerlink" title="Giới thiệu:"></a>Giới thiệu:</h3><ul><li>Lưu trên Client: Cũng giống như localStorage thì sessionStorage cũng dùng để lưu trữ dữ liệu trên trình duyệt của khách truy cập (client).</li><li>Mất dữ liệu khi đóng tab: Dữ liệu của sessionStorage sẽ mất khi bạn đóng trình duyệt.</li><li>Dữ liệu không được gửi lên Server</li><li>Thông tin lưu trữ nhiều hơn cookie (ít nhất 5MB)</li></ul><h3 id="Trinh-duyet-ho-tro-1"><a href="#Trinh-duyet-ho-tro-1" class="headerlink" title="Trình duyệt hỗ trợ"></a>Trình duyệt hỗ trợ</h3><table><thead><tr><th>Trình duyệt</th><th>Phiên bản</th></tr></thead><tbody><tr><td>Chrome</td><td>&gt;= 5.0</td></tr><tr><td>Internet Explorer / Edge</td><td>&gt;= 8.0</td></tr><tr><td>Firefox</td><td>&gt;= 2</td></tr><tr><td>Safari</td><td>&gt;= 4.0</td></tr><tr><td>Opera</td><td>&gt;= 10.5</td></tr></tbody></table><p>Vì sessionStorage cũng nằm trong gói Storage nên các bạn cũng có thể sử dụng lại đoạn code kiểm tra trình duyệt có hỗ trợ Storage hay không ở phía trên.</p><h3 id="Xem-Session-Storage-bang-trinh-duyet"><a href="#Xem-Session-Storage-bang-trinh-duyet" class="headerlink" title="Xem Session Storage bằng trình duyệt"></a>Xem Session Storage bằng trình duyệt</h3><p>Tương tự như localStorage, có thể chọn mở rộng mục Session Storage để xem các giá trị được lưu trữ.</p><h3 id="Su-dung-1"><a href="#Su-dung-1" class="headerlink" title="Sử dụng"></a>Sử dụng</h3><p>sessionStorage cũng có cú pháp và cách sử dụn các thuộc tính, phương thức như localStorage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span>(Storage) !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="comment">// Khởi tạo sesionStorage</span></span><br><span class="line">    sessionStorage.setItem(<span class="string">'name'</span>, <span class="string">'Ted Mosby'</span>);</span><br><span class="line">    <span class="comment">// get sessionStorage</span></span><br><span class="line">    sessionStorage.getItem(<span class="string">'name'</span>);</span><br><span class="line">    <span class="comment">// lấy ra số lượng session đã lưu trữ</span></span><br><span class="line">    sessionStorage.length;</span><br><span class="line">    <span class="comment">// xóa 1 item localStorage</span></span><br><span class="line">    sessionStorage.removeItem(<span class="string">'name'</span>);</span><br><span class="line">    <span class="comment">// xóa tất cả item trong sessionStorage</span></span><br><span class="line">    sessionStorage.clear();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'Trình duyệt của bạn không hỗ trợ!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3. Cookie"></a>3. Cookie</h2><h3 id="Gioi-thieu-2"><a href="#Gioi-thieu-2" class="headerlink" title="Giới thiệu:"></a>Giới thiệu:</h3><ul><li>Thông tin được gửi lên server: Cookie sẽ được truyền từ server tới browser và được lưu trữ trên máy tính của bạn khi bạn truy cập vào ứng dụng, mỗi khi người dùng tải ứng dụng, trình duyệt sẽ gửi cookie để thông báo cho ứng dụng về hoạt động trước đó của bạn. Vì vậy đừng bao giờ lưu trữ những thông tin quan trọng, yêu cầu tính bảo mật cao vào cookie vì nó hoàn toàn có thể bị sửa đổi và đánh cắp, thấp chí có thể lợi dụng điều này để tấn công website của bạn.</li><li>Cookie chủ yếu là để đọc phía máy chủ (cũng có thể được đọc ở phía máy khách), localStorage và sessionStorage chỉ có thể được đọc ở phía máy khách.</li><li>Có thời gian sống: Mỗi cookie thường có khoảng thời gian timeout nhất định do lập trình viên xác định trước.</li><li>Lưu trữ: cho phép lưu trữ tối đa 4KB và vài chục cookie cho một domain.</li></ul><h3 id="Xem-cookie-bang-trinh-duyet"><a href="#Xem-cookie-bang-trinh-duyet" class="headerlink" title="Xem cookie bằng trình duyệt"></a>Xem cookie bằng trình duyệt</h3><p>Tương tự như localStorage, có thể chọn mở rộng mục Cookies để xem các giá trị cookie được lưu trữ</p><p><img src="https://images.viblo.asia/94606099-1b52-4377-b354-69dd4cc0fa5e.png" alt=""></p><h3 id="Su-dung-2"><a href="#Su-dung-2" class="headerlink" title="Sử dụng"></a>Sử dụng</h3><p>Cookie có thể được tạo bằng nhiều cách, bài viết này sẽ trình bày về sử dụng cookie trong javascript. JavaScript có thể tạo, đọc, và xóa cookies với document.cookie.</p><ul><li>Tạo cookie: Javascript có thể tạo cookie như sau:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=Ted Mosby'</span>;</span><br></pre></td></tr></table></figure><p>Chúng ta cũng có thể thêm vào ngày hết hạn cho cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=Ted Mosby; expires=Thu, 18 Dec 2018 8:00:00 UTC'</span>;</span><br></pre></td></tr></table></figure><p>Hoặc đặt hẹn giờ sau bao lâu cookie sẽ hết hạn với max-age (tính bằng giây)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=Ted Mosby; max-age=9000'</span>;</span><br></pre></td></tr></table></figure><ul><li>Đọc cookie:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure><p>document.cookie sẽ trả lại tất cả cookie trong một chuỗi tring kiểu như: cookie1 = giá trị; cookie2 = giá trị; cookie3 = giá trị;</p><p>Hoặc để lấy giá trị của 1 cookie, có thể viết một hàm như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">cname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = cname + <span class="string">'='</span>;</span><br><span class="line">    <span class="keyword">var</span> decodedCookie = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line">    <span class="keyword">var</span> ca = decodedCookie.split(<span class="string">';'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;ca.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = ca[i];</span><br><span class="line">        <span class="keyword">while</span> (c.charAt(<span class="number">0</span>) == <span class="string">' '</span>) &#123;</span><br><span class="line">            c = c.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c.indexOf(name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> c.substring(name.length, c.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tham số truyền vào là cname - tên cookie muốn lấy giá trị.</p></blockquote><blockquote><p>Tạo một biến name và thêm vào “=” để tìm kiếm trong chuỗi document.cookie</p></blockquote><blockquote><p>Chia document.cookie dựa trên dấu ; thành một mảng nhiều phần tử và gán mảng đấy cho biến ca</p></blockquote><blockquote><p>Vòng lặp (i=0; i&lt;ca.length; i++) để đọc mỗi giá trị c = ca[i]</p></blockquote><blockquote><p>Nếu cookie được tìm thấy (c.indexOf(name)==0), trả về giá trị của cookie (c.substring(name.length,c.length). Nếu cookie không được tìm thấy, trả về ‘’</p></blockquote><p>Ví dụ muốn lấy giá trị của cookie tên là language thì ta có thể gọi getcookie(‘language’) và kêt quả trả về là giá trị của cookie có tên đó.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = getCookie(<span class="string">'language'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lang);</span><br></pre></td></tr></table></figure><p>Kết quả:</p><p><img src="https://images.viblo.asia/de11cb91-6bf0-47a2-840f-2ba067b391cb.png" alt=""></p><ul><li>Thay đổi giá trị cookie: Trong javascript, bạn có thể thay đổi một cookie giống như cách mà bạn tạo ra cookie, tức là ghi đè giá trị mới lên cookie đã có:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"username=Barney Stinson; expires=Wed, 26 Dec 2018 8:00:00 UTC"</span>;</span><br></pre></td></tr></table></figure><ul><li>Kiểm tra cookie: Để kiểm tra coookie, có thể xây dựng hàm như sau:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCookie</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username = getCookie(<span class="string">'username'</span>);</span><br><span class="line">    <span class="keyword">if</span> (username != <span class="string">''</span>) &#123;</span><br><span class="line">        alert(<span class="string">'Welcome again '</span> + username);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        username = prompt(<span class="string">'Please enter your name: '</span>,  <span class="string">''</span>);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="string">''</span> &amp;&amp; username != <span class="literal">null</span>) &#123;</span><br><span class="line">            setCookie(<span class="string">'username'</span>, username, <span class="number">365</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Nếu cookie được thiết lập, nó sẽ hiển thị một lời chào</p></blockquote><blockquote><p>Nếu cookie không được thiết lập, nó sẽ hiển thị một prompt box, hỏi tên của người dùng, lưu trữ tên của người dùng ở cookie trong 365 ngày, bằng việc gọi function setCookie đã được viết ở trên</p></blockquote><ul><li>Xóa cookie: Để xóa một cookie chỉ cần xét lại giá trị ngày hết hạn expires về một thời điểm đã qua</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=; expires=Thu, 01 Jan 1970 00:00:00 UTC'</span>;</span><br></pre></td></tr></table></figure><p>Tham khảo tại <a href="https://www.w3schools.com/js/js_cookies.asp" target="_blank" rel="noopener">https://www.w3schools.com/js/js_cookies.asp</a></p><h3 id="4-Thong-tin-them"><a href="#4-Thong-tin-them" class="headerlink" title="4. Thông tin thêm"></a>4. Thông tin thêm</h3><ul><li>Vì localStorage và sessionStorage được lưu trữ trên trình duyệt của người dùng, nên các bạn cần phải xem xét nội dung lưu trữ có liên quan đến vấn đề bảo mật hay không.</li><li>Và cũng chính vì localStorage và sessionStorage được lưu trữ trên trình duyệt nên việc sử dụng nó sẽ không ảnh hưởng đến hiệu xuất của trang web nhưng nó sẽ làm nặng trình duyệt của người dùng (không đáng kể).</li><li>Về phạm vi: <strong>sessionStorage</strong>: giới hạn trong một cửa sổ hoăc thẻ của trình duyệt. Một trang web được mở trong hai thẻ của cùng một trình duyệt cũng không thể truy xuất dữ liệu lẫn nhau. Như vậy, khi bạn đóng trang web thì dữ liệu lưu trong sessionStorage hiện tại cũng bị xóa. Còn <strong>localStorage</strong>: có thể truy xuất lẫn nhau giữa các cửa sổ trình duyệt. Dữ liệu sẽ được lưu trữ không giới hạn thời gian.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Su-khac-nhau-va-cach-su-dung-Local-Storage-Session-Storage-va-Cookie&quot;&gt;&lt;a href=&quot;#Su-khac-nhau-va-cach-su-dung-Local-Storage-Session-Storage-va-Cookie&quot; class=&quot;headerlink&quot; title=&quot;Sự khác nhau và cách sử dụng Local Storage, Session Storage và Cookie&quot;&gt;&lt;/a&gt;Sự khác nhau và cách sử dụng Local Storage, Session Storage và Cookie&lt;/h1&gt;&lt;p&gt;Bạn bị lẫn lộn giữa &lt;strong&gt;session storage&lt;/strong&gt;, &lt;strong&gt;local storage&lt;/strong&gt; và &lt;strong&gt;cookies&lt;/strong&gt;? Bài viết dưới đây sẽ giúp bạn hiểu rõ được sự khác nhau giữa 3 cách lưu trữ này. Các kiểu không gian lưu trữ khác nhau có sẵn cho các dữ liệu có thể trên máy chủ hoặc máy khách, cho phép chúng ta chọn lựa theo nhu cầu.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
      <category term="html5" scheme="http://nthung2112.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>Load Javascript với async và defer</title>
    <link href="http://nthung2112.github.io/2018/06/Load-Javascript-voi-async-va-defer.html"/>
    <id>http://nthung2112.github.io/2018/06/Load-Javascript-voi-async-va-defer.html</id>
    <published>2018-06-23T11:29:00.000Z</published>
    <updated>2018-06-23T11:37:52.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Van-de"><a href="#Van-de" class="headerlink" title="Vấn đề"></a>Vấn đề</h1><p><strong>Javascript</strong> là 1 trong những tài nguyên chặn trang, có nghĩa là việc hiển thị HTML có thể bị chặn hay làm chậm bởi Javascript. Khi parser đọc đến <code>&lt;script&gt;</code> tag, bất kể là inline hay là external file, quá trình parse sẽ tạm dừng để fetch script đó về và execute. Việc này có thể là vấn đề nếu chúng ta load nhiều file Javascript trên trang, làm tăng thời gian load trang mặc dù có thể việc hiển thị html ở trang không thực sự phụ thuộc vào những file javascript đó. Và may mắn thay, thẻ <code>&lt;script&gt;</code> có 2 thuộc tính, đó là <strong>async và defer</strong>, cho phép chúng ta kiểm soát và load những file này theo ý muốn, tránh chặn quá trình load trang.</p><a id="more"></a><h1 id="Mo-ta-cach-thuc-thi"><a href="#Mo-ta-cach-thuc-thi" class="headerlink" title="Mô tả cách thực thi"></a>Mô tả cách thực thi</h1><p><img src="http://www.growingwiththeweb.com/images/2014/02/26/legend.svg" alt=""></p><h2 id="lt-script-gt"><a href="#lt-script-gt" class="headerlink" title="&lt;script&gt;"></a><code>&lt;script&gt;</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script.js"</span> /&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    ....</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Với thẻ script không có thuộc tính gì khác thì HTML file sẽ được parse cho đến khi gặp phải thẻ script, đến lúc này thì quá trình parse sẽ tạm dùng và để fetch script file về (nếu là external file), sau đó execute những code script này, sau đó mới tiếp tục lại quá trình parse html </p><p><img src="http://www.growingwiththeweb.com/images/2014/02/26/script.svg" alt=""></p><h2 id="lt-script-async-gt"><a href="#lt-script-async-gt" class="headerlink" title="&lt;script async&gt;"></a><code>&lt;script async&gt;</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"script.js"</span> /&gt;</span><br></pre></td></tr></table></figure><p>Với thẻ script có thuộc tính async, khi quá trình parse html gặp phải script này, nó sẽ vẫn tiếp tục parse html cho đến khi script này được download xong, thì quá trình parse html mới tạm dừng để execute những code script này, sau đó lại tiếp tiếp quá trình parse html</p><p><img src="http://www.growingwiththeweb.com/images/2014/02/26/script-async.svg" alt=""></p><h2 id="lt-script-defer-gt"><a href="#lt-script-defer-gt" class="headerlink" title="&lt;script defer&gt;"></a><code>&lt;script defer&gt;</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"script.js"</span> /&gt;</span><br></pre></td></tr></table></figure><p>Với thẻ script có thuộc tính defer, quá trình parse html sẽ không bị dừng lại mà parse cho đến khi hoàn thành, quá trình download các script file được tiến hành song song, và cuối cùng thì sẽ execute những script code này khi html đã parse xong.</p><p><img src="http://www.growingwiththeweb.com/images/2014/02/26/script-defer.svg" alt=""></p><h1 id="Vay-nen-dung-khi-nao"><a href="#Vay-nen-dung-khi-nao" class="headerlink" title="Vậy nên dùng khi nào?"></a>Vậy nên dùng khi nào?</h1><p>Nó phụ thuộc vào từng tình huống cụ thể.</p><h2 id="Quy-tac-nhu-sau"><a href="#Quy-tac-nhu-sau" class="headerlink" title="Quy tắc như sau:"></a>Quy tắc như sau:</h2><ul><li>Nếu script là 1 module tách biệt, không phụ thuộc vào script nào khác thì nên sử dụng async cho load và execute với trang luôn</li><li>Nếu script phụ thuộc vào script khác, hoặc bị script khác phụ thuộc, thì nên dùng defer, để load và execute theo thứ tự</li><li>Nếu script nhỏ và các script khác phụ thuộc vào nó, thì cho load inline và không cần async hay defer</li></ul><h2 id="Ngoai-ra-nen-can-nhac-1-so-cau-hoi-truoc-khi-them-cac-thuoc-tinh-nay"><a href="#Ngoai-ra-nen-can-nhac-1-so-cau-hoi-truoc-khi-them-cac-thuoc-tinh-nay" class="headerlink" title="Ngoài ra nên cân nhắc 1 số câu hỏi trước khi thêm các thuộc tính này"></a>Ngoài ra nên cân nhắc 1 số câu hỏi trước khi thêm các thuộc tính này</h2><h3 id="1-The-script-dang-nam-o-dau-trong-trang"><a href="#1-The-script-dang-nam-o-dau-trong-trang" class="headerlink" title="1. Thẻ script đang nằm ở đâu trong trang"></a>1. Thẻ script đang nằm ở đâu trong trang</h3><p>Async và defer có thể rất cần thiết nếu thẻ script không nằm ở cuối trang. HMTL document được parse theo thứ tự, từ thẻ mở <html> cho đến thẻ đóng </html>. Nếu script năm ngay gần cuối thẻ đóng  thì việc sử dụng async hay defer thì cũng không có ý nghĩa lắm bởi vì việc parse html đã gần xong xuôi, và javascript không còn block gì html nữa.</p><h3 id="2-Script-do-co-doc-lap-khong"><a href="#2-Script-do-co-doc-lap-khong" class="headerlink" title="2. Script đó có độc lập không?"></a>2. Script đó có độc lập không?</h3><p>Với những file script không phụ thuộc vào những file khác, thì thuộc tính async dùng cho script đó là việc nên làm, vì nó load và execute script song song, giảm thời gian tải trang, kết quả cuối cùng nhanh hơn.</p><h3 id="3-Script-co-yeu-cau-viec-load-DOM-xong-moi-thuc-hien"><a href="#3-Script-co-yeu-cau-viec-load-DOM-xong-moi-thuc-hien" class="headerlink" title="3. Script có yêu cầu việc load DOM xong mới thực hiện?"></a>3. Script có yêu cầu việc load DOM xong mới thực hiện?</h3><p>Trong nhiều trường hợp, các script chứa đựng code tương tác với DOM, hoặc phụ thuộc vào các thành phần trên trang, yêu cầu trang phải parse xong thì mới execute script. Thông thường thì những file như thế sẽ được đặt ở cuối trang để chắc chắn mọi thử đã được parse. Tuy nhiên chúng ta có thể dùng thuộc tính defer thay thế, đảm bảo script sẽ được execute khi trang đã tải xong.</p><h3 id="4-Script-nho-va-cac-file-khac-phu-thuoc-vao-no"><a href="#4-Script-nho-va-cac-file-khac-phu-thuoc-vao-no" class="headerlink" title="4.Script nhỏ và các file khác phụ thuộc vào nó?"></a>4.Script nhỏ và các file khác phụ thuộc vào nó?</h3><p>Nếu script dung lượng nhỏ, và các file khác phụ thuộc vào nó, thì nên để script đó inline. Mặc dù nó block quá trình parse HTML, nhưng nó không đáng kể vì dung lượng nhỏ.</p><h1 id="Loi-ich"><a href="#Loi-ich" class="headerlink" title="Lợi ích"></a>Lợi ích</h1><p>Với việc biết cách sử dụng các thuộc tính async, defer hợp lí thì tốc độ load trang sẽ được cải thiện hơn, mang lại cảm giác thích thú cho người dùng. Vì vậy nó giúp tối ưu SEO, giúp tăng điểm Google Page Speed (<a href="https://developers.google.com/speed/pagespeed/insights" target="_blank" rel="noopener">https://developers.google.com/speed/pagespeed/insights</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Van-de&quot;&gt;&lt;a href=&quot;#Van-de&quot; class=&quot;headerlink&quot; title=&quot;Vấn đề&quot;&gt;&lt;/a&gt;Vấn đề&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Javascript&lt;/strong&gt; là 1 trong những tài nguyên chặn trang, có nghĩa là việc hiển thị HTML có thể bị chặn hay làm chậm bởi Javascript. Khi parser đọc đến &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, bất kể là inline hay là external file, quá trình parse sẽ tạm dừng để fetch script đó về và execute. Việc này có thể là vấn đề nếu chúng ta load nhiều file Javascript trên trang, làm tăng thời gian load trang mặc dù có thể việc hiển thị html ở trang không thực sự phụ thuộc vào những file javascript đó. Và may mắn thay, thẻ &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; có 2 thuộc tính, đó là &lt;strong&gt;async và defer&lt;/strong&gt;, cho phép chúng ta kiểm soát và load những file này theo ý muốn, tránh chặn quá trình load trang.&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Functional Programming - Phần 3 - Buông bỏ</title>
    <link href="http://nthung2112.github.io/2018/06/Functional-Programming-Phan-3-Buong-bo.html"/>
    <id>http://nthung2112.github.io/2018/06/Functional-Programming-Phan-3-Buong-bo.html</id>
    <published>2018-06-20T08:46:00.000Z</published>
    <updated>2018-06-23T08:54:01.269Z</updated>
    
    <content type="html"><![CDATA[<p>Functional Programming là một con đường khác, một phương pháp tư duy khác trong coding. Ở tầm nhìn trừu tượng hơn, người ta xếp Functional Programming vào nhóm “Declarative”, còn OOP thuộc nhóm “Imperative”.</p><p>Từ các bài học ngữ pháp chúng ta đã biết 2 kiểu câu: câu trần thuật (Declarative Sentence), và câu mệnh lệnh (Imperative Sentence).</p><p>Lập trình theo lối “Imperative Programming” là sắp xếp một loạt các mệnh lệnh liên tiếp, để máy tính thực thi tuần tự từng bước. Ở đây người ta tập trung vào “how”. Nào, hãy làm thế này, rồi làm thế kia… Một hình thức “cầm tay chỉ việc”.<br><a id="more"></a><br>Ví dụ trên trang web có 4 boxes màu đỏ thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  float: left;</span><br><span class="line">  margin: <span class="number">10</span>px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.hide &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="box hide"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box hide"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box hide"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box hide"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Mấy boxes này đang ẩn, ta cần làm chúng hiện ra bằng cách loại bỏ class “hide” đi.</p><p>Các giáo viên tin học đáng kính ở trường xưa thường dạy viết kiểu như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tìm hết các tags có class "box':</span></span><br><span class="line"><span class="keyword">const</span> els = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.box'</span>);</span><br><span class="line"><span class="comment">// quét tất cả các tags tìm thấy</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; els.length; i++) &#123;</span><br><span class="line">  <span class="comment">// với tag thứ i</span></span><br><span class="line">  <span class="keyword">let</span> el = els[i];</span><br><span class="line">  <span class="comment">// xóa bỏ class "hide" để cho tag hiện lên</span></span><br><span class="line">  el.classList.remove(<span class="string">'hide'</span>);</span><br><span class="line">  <span class="comment">// nếu còn phần tử phía sau thì tăng i lên 1 đơn vị</span></span><br><span class="line">  <span class="comment">// quay lại với xử lý tag thứ i + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Họ dùng code hướng dẫn cho máy tính làm từng nhiệm vụ.</p><p>Người tu luyện Functional Programming không tư duy theo cách đó.</p><h3 id="No-for-while"><a href="#No-for-while" class="headerlink" title="No for/while"></a>No for/while</h3><p>“Declarative Programming” là tập trung vào “what”. Chúng ta chỉ cần định nghĩa những quy tắc đầu vào, đầu ra. Chẳng hạn “nếu input là 1 thì output là 2”. Phần còn lại để máy tính xử lý.</p><p>Người tu luyện Functional Programming không cần for loop.</p><p>Code như thế này nhìn mới mẻ hơn nhiều:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getElements = <span class="function">(<span class="params">selector</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(selector));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getRemover = <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">className</span>) =&gt;</span> &#123;</span><br><span class="line">    el.classList.remove(className);</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> els = getElements(<span class="string">'.box'</span>)</span><br><span class="line">  .map(getRemover)</span><br><span class="line">  .map(<span class="function"><span class="params">removeClass</span> =&gt;</span> removeClass(<span class="string">'hide'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(els);</span><br></pre></td></tr></table></figure><p>Trước tiên chúng ta tạo ra 1 pure function getElements dùng để lấy các elements trên trang thông qua CSS Selector. Tập hợp này vốn là ArrayLike, ta dùng Array.from chuyển thành Array thực sự để có thể tận dụng các phương thức trong Array prototype.</p><p>Ở đây ta định nghĩa input là CSS Selector, output là 1 mảng DOM Elements.</p><p>Còn getRemover lại là 1 higher-order function. Có thể gọi nó bằng cách chaining getRemover(DOMElement)(classToRemove). Chúng ta lợi dụng đặc tính của higher-order function, sau 2 lần map thì chạm tới function do getRemover ném lại.</p><p>Ở đây ta định nghĩa input là DOM Element, output là function() {nhận input là className và output là DOM Element đã mất đi class đó}.</p><p>Code như vậy ta có thể đem logic dùng lại ở nhiều chỗ khác nhau, chỉ cần thay đổi input. Ví dụ loại bỏ class float-left khỏi tất cả các thẻ div.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> els = getElements(<span class="string">'div'</span>)</span><br><span class="line">  .map(getRemover)</span><br><span class="line">  .map(<span class="function"><span class="params">removeClass</span> =&gt;</span> removeClass(<span class="string">'float-left'</span>));</span><br></pre></td></tr></table></figure><h3 id="No-if-else"><a href="#No-if-else" class="headerlink" title="No if/else"></a>No if/else</h3><p>Người tu luyện Functional Programming cũng không cần if/else.</p><p>Thậm chí họ còn tạo ra cả một chiến dịch <a href="https://francescocirillo.com/pages/anti-if-campaign" target="_blank" rel="noopener">Anti-IF</a>!</p><p>Có nhiều cách để loại bỏ hoàn toàn if/else ra khỏi chương trình của bạn. Đơn giản nhất là dùng ternary.</p><h4 id="Ternary"><a href="#Ternary" class="headerlink" title="Ternary"></a>Ternary</h4><p>Trong JavaScript, ternary - tam phân - có tên gọi chính thức là Toán tử Điều kiện - Conditional Operator. Nó là cách viết ngắn gọn của if/else.</p><p>Hãy xem đoạn code dài dòng, rẽ nhánh phức tạp như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> title = <span class="string">'Mr.'</span>;</span><br><span class="line"><span class="keyword">if</span> (person.gender === <span class="string">'female'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!person.gotMarried) &#123;</span><br><span class="line">    title = <span class="string">'Ms.'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    title = <span class="string">'Mrs.'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Có thể được viết gọn lại thành:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = person.gender === <span class="string">'female'</span> ? (!person.gotMarried ? <span class="string">'Ms.'</span> : <span class="string">'Mrs.'</span>) : <span class="string">'Mr.'</span>;</span><br></pre></td></tr></table></figure><p>Không còn if/else nữa.</p><p>Ta cũng vô hình trung loại bỏ được var, let vì không cần gán lại giá trị cho title.</p><h4 id="Logical-operators"><a href="#Logical-operators" class="headerlink" title="Logical operators"></a>Logical operators</h4><p>Cách thứ 2 là khai thác sức mạnh ngầm của các logical operators &amp;&amp;, ||. Đây là những toán tử logic. Hôm trước có bạn viết <a href="https://kipalog.com/posts/--va--" target="_blank" rel="noopener">1 cái TIL ngắn</a> khá hay. Sau đây ta quan sát chúng kỹ hơn qua lăng kính Functional Programming.</p><p>Giả sử có đoạn code như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHello = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, bonjour, nihao'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doNothing = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do nothing'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greet = <span class="function">(<span class="params">hasClient</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasClient) &#123;</span><br><span class="line">    sayHello();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    doNothing();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="literal">true</span>); <span class="comment">// =&gt; 'Hello, bonjour, nihao'</span></span><br><span class="line">greet(<span class="literal">false</span>); <span class="comment">//=&gt; 'Do nothing'</span></span><br></pre></td></tr></table></figure><p>Về mặt logic, hàm greet() kiểm tra điều kiện nếu có khách thì chào, nếu không thì không làm gì cả.</p><p>Theo định nghĩa của &amp;&amp; và ||, chúng ta biết:</p><ul><li>expr1 &amp;&amp; expr2 trả về expr1 nếu expr1 là falsy, ngoài ra nó trả về expr2.</li></ul><p>Một điều thú vị ở đây là JavaScript engine luôn ước lượng giá trị biểu thức logic dạng này từ trái sang phải và theo nguyên tắc “đoản mạch” - <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation" target="_blank" rel="noopener">short-circuit evaluation</a>“. Tiên hữu nào giỏi Vật lý chắc còn nhớ hiện tượng “đoản mạch”, đó là khi dòng điện không chạy qua tải hoặc chỉ chạy qua một phần.</p><p>Vì AND chỉ trả về true nếu cả 2 mệnh đề cùng đúng, nên ngay khi bắt gặp expr1 sai, nó lập tức kết luận mệnh đề ghép là Sai và chấm dứt tại đó luôn, không chạy qua nửa bên phải expr2 nữa.</p><ul><li>expr1 || expr2 trả về expr1 nếu expr1 là truthy, ngoài ra nó trả về expr2.</li></ul><p>Vì OR trả về true nếu ít nhất 1 mệnh đề đúng, nên ngay khi bắt gặp expr1 đúng, nó lập tức kết luận mệnh đề ghép là Đúng và bỏ qua expr2.</p><p>Short-circuit thần thánh!</p><p>Các lập trình viên kinh nghiệm thường lợi dụng đặc điểm này để tối ưu hiệu suất chương trình. Họ để các biểu thức tính toán phức tạp ở nửa sau của biểu thức logic. Như vậy, khi chưa rơi vào hoàn cảnh thích hợp, chúng sẽ bị bỏ qua, không cần tốn resource xử lý.</p><p>Tới đây, ta đã có thể viết lại hàm greet() một cách bí hiểm như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="function">(<span class="params">hasClient</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (hasClient || doNothing()) &amp;&amp; sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bắt đầu phần nằm trong ngoặc đơn bên trái &amp;&amp;. Nếu hasClient là true thì giá trị phần này cũng là true, doNothing() bị bỏ qua.</p><p>Vì phần bên trái của &amp;&amp; là true nên cuối cùng, giá trị biểu thức quy về phần bên phải &amp;&amp;, tức là sayHello().</p><p>Lập luận tương tự cho trường hợp hasClient là false, dòng chảy chương trình lập tức rẽ sang doNothing(). Lúc này giá trị nửa bên trái &amp;&amp; là false, do đó không cần quan tâm đến sayHello() nữa.</p><p>Viết như trên vừa độc vừa lạ, vừa khử được if/else, mà vẫn hoàn toàn ăn khớp với điều kiện quy ước.</p><p>Tuy nhiên, logical operators nếu nhìn không quen thì có vẻ hơi khó hình dung mạch suy diễn của chương trình. Tôi chỉ đưa ra đây để các tin hữu tham khảo. Trong dự án thực tế, vẫn nên dùng ternary cho đỡ hại não đồng đội:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="function">(<span class="params">hasClient</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> hasClient ? sayHello() : doNothing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Logical-functions"><a href="#Logical-functions" class="headerlink" title="Logical functions"></a>Logical functions</h4><p>Một cách tiếp cận khác thể hiện tinh thần Functional Programming quyết liệt hơn, đó là tạo ra các hàm đặc trách nhiệm vụ xử lý logic. Ví dụ trong <a href="https://ramdajs.com" target="_blank" rel="noopener">Ramda.js</a> và <a href="https://sanctuary.js.org" target="_blank" rel="noopener">Sanctuary</a> đều có ifElse , unless , when, và hàng chục hàm logic khác.</p><p>Hàm greet nếu viết lại với Ramda sẽ trở nên xinh xắn như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> R = <span class="built_in">require</span>(<span class="string">'ramda'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greet = R.ifElse(R.identity, sayHello, doNothing);</span><br></pre></td></tr></table></figure><p>Đó là vẻ đẹp đầy tính nghệ thuật của Function Composition. Bạn cứ ngắm nhìn nó và đừng nói gì cả! Composition cũng có nghĩa là tác phẩm, như thơ của Paul Verlaine hay nhạc của Beethoven.</p><h3 id="No-new-this"><a href="#No-new-this" class="headerlink" title="No new/this"></a>No new/this</h3><p>Có 2 thứ luôn khiến Brendan Eich cảm thấy hài lòng khi <a href="https://brendaneich.com/2008/04/popularity/" target="_blank" rel="noopener">kể về lịch sử JavaScript</a>, đó là first-class function và prototype mechanism.</p><p>Ngày nay, hầu hết developer đều biết rằng thừa kế trong JavaScript là prototype-based inheritance. Nhưng ở thời kỳ web còn hoang sơ, người ta hay dùng new và các hàm constructors để lập trình OOP trong JavaScript theo kiểu class-based, giống như bên Java vẫn làm.</p><h4 id="Classical-inheritance"><a href="#Classical-inheritance" class="headerlink" title="Classical inheritance"></a>Classical inheritance</h4><p>Cổ thư ghi lại rất nhiều ví dụ kiểu này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'woof-woof, my name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rocky = <span class="keyword">new</span> Dog(<span class="string">'Rocky'</span>);</span><br><span class="line">rocky.say();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> molly = <span class="keyword">new</span> Dog(<span class="string">'Molly'</span>);</span><br><span class="line">molly.say();</span><br></pre></td></tr></table></figure><p>Hàm Dog gọi là Function Constructor, các tiền bối chân giới Đại Việt thủa trước chuyển ngữ thành “hàm dựng”. Còn chúng ta thời nay có lẽ cứ nên giữ nguyên văn.</p><h4 id="Prototypal-inheritance"><a href="#Prototypal-inheritance" class="headerlink" title="Prototypal inheritance"></a>Prototypal inheritance</h4><p>Sang đầu kỷ thứ 3, ở tông môn Yahoo! có một vị trưởng lão tu vi rất cao thâm tên là <a href="https://en.wikipedia.org/wiki/Douglas_Crockford" target="_blank" rel="noopener">Douglas Crockford</a> tung ra bộ kỳ thư “JavaScript: The Good Parts”, trong đó có đoạn nhấn mạnh bản chất prototype trong JavaScript, sự khác biệt giữa classical inheritance và prototypal inheritance. Ông cho rằng từ khóa new mang theo nhiều điểm bất cập, nên khuyến khích dùng Object.create để sao chép nguyên mẫu sang đối tượng kế thừa.</p><p>Tư tưởng của Douglas Crockford quả thực mới mẻ. Vào lúc đó, nhiều JavaScript engine còn chưa kịp hỗ trợ Object.create. Cuốn này vừa ra mắt đã gây náo loạn cả tin giới, trở thành sách gối đầu giường của rất nhiều tu sĩ.</p><p>Object.create cho phép sao chép các properties hoặc protoype của đối tượng. Hàm Dog có thể được viết lại theo hướng prototypal inheritance như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'woof-woof, my name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rocky = <span class="built_in">Object</span>.create(Dog.prototype);</span><br><span class="line">rocky.name = <span class="string">'Rocky'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> molly = <span class="built_in">Object</span>.create(Dog.prototype);</span><br><span class="line">molly.name = <span class="string">'Molly'</span>;</span><br><span class="line"></span><br><span class="line">rocky.say();</span><br><span class="line">molly.say();</span><br></pre></td></tr></table></figure><p>Không cần new nữa!</p><p>Các cường giả sau đó nhanh chóng phát triển thêm nhiều cách tiếp cận prototypal inheritance khác, nổi bật nhất phải kể đến Concatenative inheritance, Prototype delegation và Functional inheritance.</p><p>ES6 Class ngày nay chỉ vay mượn syntax của classical OOP để làm interface, còn bên trong nó chính là cơ chế prototypal inheritance.</p><h4 id="Object-Composition"><a href="#Object-Composition" class="headerlink" title="Object Composition"></a>Object Composition</h4><p>Nhưng dù sao prototypal inheritance vẫn thuộc về OOP.</p><p>Người tu luyện Functional Programming không cần new.</p><p>Gần 10 năm sau bom tấn “The Good Parts”, Douglas Crockford lại một lần nữa khiến tin giới chấn động bằng “JavaScript: The Better Parts”. Thời điểm này, ông đã không còn dùng Object.create() nữa, cũng từ bỏ luôn this, for loops, for in, while… Tu vi của ông đã tiến thêm một bước lớn. Trong clip, ông nói về những tính năng mới của ES6 lúc ấy vẫn còn chưa chính thức xuất xưởng. Mấy lão quái kiệt này luôn đi trước thiên hạ vài năm.</p><div class="video-container"><iframe src="//www.youtube.com/embed/bo36MrBfTk4" frameborder="0" allowfullscreen></iframe></div><p>Đó cũng là khi trào lưu Functional Programming đang dần nóng trở lại, người ta bắt đầu nhắc đến khái niệm <a href="https://medium.com/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381" target="_blank" rel="noopener">Object Composition</a>.</p><p>Đi cặp với new là this. Từ khóa this chẳng qua chỉ là kỹ xảo nhằm tạo ra một ngữ cảnh khu biệt (context) để thực thi các hàm. Trong JavaScript, mỗi hàm như 1 kết giới độc lập. Function khi được gắn lên object thì gọi là method. Ngữ cảnh method đó chạy thường chính là đối tượng sở hữu nó. Sau này mới sinh ra các thủ thuật bind, apply, call để đánh tráo context.</p><p>Với những người mới học JavaScript, this đôi khi trở thành nỗi khiếp sợ. Rất khó debug các vấn đề phát sinh trong hàm nếu không biết chính xác ngữ cảnh chạy nó. Mà ngữ cảnh lại thường không ổn định. Đúng hơn, phải nói rằng chúng luôn luôn mutable.</p><p>Người tu luyện Functional Programming không cần this.</p><p>Đoạn code với classical OOP trên kia có thể viết lại thành:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sayName = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(</span><br><span class="line">    state,</span><br><span class="line">    &#123;</span><br><span class="line">      say: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`woof-woof, my name is <span class="subst">$&#123;state.name&#125;</span>`</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createDog = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> state = &#123;</span><br><span class="line">    name,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(state, sayName(state));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rocky = createDog(<span class="string">'Rocky'</span>);</span><br><span class="line">rocky.say();</span><br><span class="line"><span class="keyword">const</span> molly = createDog(<span class="string">'Molly'</span>);</span><br><span class="line">molly.say();</span><br></pre></td></tr></table></figure><p>Nhìn đâu cũng thấy functions.</p><p>Không còn for/while, if/else, new/this.</p><p>Liệu bạn đã sẵn sàng rời khỏi những phàm vật ấy?</p><p>Hay nói như các nhà sư, liệu bạn có thể buông bỏ?</p><p><img src="https://i.imgur.com/LK0k8LW.jpg" alt=""></p><p>Khi lối tư duy truyền thống đã ăn sâu vào tâm trí, hễ gặp vấn đề phân cấp đối tượng thì chúng ta sẽ nghĩ ngay đến OOP, class, prototype, inheritance… thậm chí coi chúng như giải pháp tất yếu, duy nhất. Hễ xử lý tập hợp là phải looping, hễ thấy có điều kiện thì chỉ biết dựa vào if… Đây là trở ngại rất lớn cho kẻ mới nhập đạo.</p><p>Phải tìm cách rũ bỏ những thứ không cần thiết, thì mới đi xa được.</p><p>Rời khỏi chúng, chỉ giữ lại một ý niệm duy nhất: FUNCTION!</p><p>Nhất niệm “phân sần”!</p><p><img src="https://i.imgur.com/0clmtSN.jpg" alt=""></p><p>Ban đầu tất nhiên là sẽ khó khăn, lúng túng. Giống như hàng ngày bạn vẫn đi trên con đường quen thuộc từ nhà đến công sở rồi lại trở về nhà. Cho đến một hôm con đường đó bị cảnh sát chặn lại, bạn đành phải rẽ sang lối khác.</p><p>Trên con đường xa lạ ấy, bạn không còn trông thấy những điểm mốc hàng ngày vẫn thấy: 1 shop lưu niệm, 1 cây xăng, 1 tiệm cầm đồ, sau ngã tư là đến ven sông, cây cầu sơn màu đỏ, một tiệm tạp hóa thường có cô em rất xinh ngồi trước cửa… Bạn không còn bắt gặp những dấu hiệu đã quen mắt. Bạn chẳng biết mình đã đi đến đâu, còn cách nhà bao nhiêu km nữa.</p><p>Nhưng con đường nào đi lại vài lần thì cũng thành quen. Chẳng có gì đáng ngại. Vấn đề là, ngay khi bạn nhận thấy Functional Programming là thứ gì đó rất thú vị, đáng để học hỏi, vận dụng nó, bạn nên thực hiện ngay lập tức, đừng chờ đợi dịp nào thuận tiện, đừng chờ tìm được minh sư dẫn dắt. Nếu vậy, bạn sẽ khó mà rời khỏi lối mòn xưa cũ.</p><p>Krishnamurti từng diễn giải một điều gần tương tự, đại ý thế này:</p><blockquote><p>Nếu bạn đi về hướng Bắc suốt những ngày tháng của cuộc đời bạn, giống như con người đã đi theo một hướng đặc biệt, rồi có người nào đó xuất hiện và nói, “Hướng đó không đúng”. Sau đó ông ta bảo bạn, “Đi về hướng Nam, hướng Đông, bất kỳ hướng nào, ngoại trừ hướng đó.” Và khi bạn thực sự chuyển động khỏi hướng đó, có một sự thay đổi ngay tại chính những tế bào não bởi vì bạn đã phá vỡ cái khuôn mẫu. Và cái khuôn mẫu đó phải được phá vỡ ngay lúc này, không phải bốn mươi năm hay một trăm năm sau.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Functional Programming là một con đường khác, một phương pháp tư duy khác trong coding. Ở tầm nhìn trừu tượng hơn, người ta xếp Functional Programming vào nhóm “Declarative”, còn OOP thuộc nhóm “Imperative”.&lt;/p&gt;
&lt;p&gt;Từ các bài học ngữ pháp chúng ta đã biết 2 kiểu câu: câu trần thuật (Declarative Sentence), và câu mệnh lệnh (Imperative Sentence).&lt;/p&gt;
&lt;p&gt;Lập trình theo lối “Imperative Programming” là sắp xếp một loạt các mệnh lệnh liên tiếp, để máy tính thực thi tuần tự từng bước. Ở đây người ta tập trung vào “how”. Nào, hãy làm thế này, rồi làm thế kia… Một hình thức “cầm tay chỉ việc”.&lt;br&gt;
    
    </summary>
    
    
      <category term="functional programming" scheme="http://nthung2112.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Functional Programming - Phần 2 - Nhập đạo</title>
    <link href="http://nthung2112.github.io/2018/06/Functional-Programming-Phan-2-Nhap-dao.html"/>
    <id>http://nthung2112.github.io/2018/06/Functional-Programming-Phan-2-Nhap-dao.html</id>
    <published>2018-06-16T08:43:00.000Z</published>
    <updated>2018-06-23T08:53:54.125Z</updated>
    
    <content type="html"><![CDATA[<p>Như vậy, Functional Programming là nghệ thuật lập trình trong đó ta:</p><ul><li>sử dụng functions để điều khiển workflow</li><li>tuân thủ 2 nguyên tắc immutability và purity</li></ul><p>Nói cách khác, chư vị tin hữu muốn tu luyện Functional Programming thì phải giữ đạo tâm trong sáng, ý chí kiên định, hàng ngày chiêm nghiệm, suy diễn, cảm ngộ function, tu vi theo đó sẽ không ngừng thăng tiến.</p><p>Nhưng làm thế nào để cảm ngộ “phân sần ý cảnh”? Ta phải nắm bắt, quan sát, tư duy, suy tưởng về function ra sao? Sau đây là những pháp quyết nhập môn.<br><a id="more"></a></p><h3 id="Higher-order-function"><a href="#Higher-order-function" class="headerlink" title="Higher-order function"></a>Higher-order function</h3><p>Higher-order function là một khái niệm đến từ Toán học. Bất cứ hàm nào tiếp nhận 1 function như tham số, hoặc trả về 1 function như kết quả, thì đều được coi là higher-order function.</p><p>Dưới đây là 1 ví dụ, hàm getItem nhận vào hàm by mô tả điều kiện, lại trả về 1 hàm khác. Nó thừa tiêu chuẩn để gọi là higher-order function.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getItem = <span class="function"><span class="params">by</span> =&gt;</span> arr =&gt; by;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hoặc phiên bản chi tiết</span></span><br><span class="line"><span class="keyword">const</span> getItem = <span class="function">(<span class="params">by</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> by(arr);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Lập trình phong cách Functional Programming là khiêu vũ với các functions.</p><p>Trong Functional Programming, hầu như mọi functions đều là higher-order function, vì chúng đều có thể nhận vào và ném ra các functions.</p><p>Nhưng như vậy thì có lợi ích gì? Nó đơn giản cung cấp cho ta một cách khác để lập luận và suy diễn. Chẳng hạn như với hàm getItem trên kia cho phép bạn biến hóa rất nhiều dạng, tùy vào cách bạn thao túng by.</p><p>Khi bạn viết getItem, bạn không cần biết sau này sẽ phải kiểm tra điều kiện ra sao, cũng không quan tâm sẽ nhận được đầu vào như thế nào.</p><p>Bạn có thể tạo ra hàm tìm số lớn nhất trong 1 mảng toàn số như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tạo hàm engine lấy max number từ mảng</span></span><br><span class="line"><span class="keyword">const</span> maxNumber = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...arr);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rồi truyền vào getItem để được hàm cần thiết</span></span><br><span class="line"><span class="keyword">const</span> getMaxNumber = getItem(maxNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thử xem sao</span></span><br><span class="line">getMaxNumber([<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="comment">// =&gt; 8</span></span><br></pre></td></tr></table></figure><p>Thế sao không truyền thẳng cái mảng số kia vào maxNumber cho khỏe? Vì trong thiết kế này ta đang cư xử với maxNumber như plugin. Còn nhiều plugins khác nữa. Ta không gọi trực tiếp plugin mà gọi qua 1 giao diện tổng quát hơn.</p><p>Giờ ta lại có dữ liệu 1 nhóm người như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> members = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Alice'</span>,</span><br><span class="line">    height: <span class="number">165</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    height: <span class="number">152</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Celina'</span>,</span><br><span class="line">    height: <span class="number">178</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Dan'</span>,</span><br><span class="line">    height: <span class="number">194</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Eric'</span>,</span><br><span class="line">    height: <span class="number">187</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>Ta muốn tìm người cao nhất trong nhóm thì sao? Hãy thêm 1 plugin khác.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bạn tạo 1 hàm engine lấy max height từ mảng</span></span><br><span class="line"><span class="keyword">const</span> maxHeight = <span class="function">(<span class="params">people</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> people.reduce(<span class="function">(<span class="params">prev, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev.height &gt; current.height ? prev : current;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rồi truyền vào getItem để được hàm cần thiết</span></span><br><span class="line"><span class="keyword">const</span> getTallestPerson = getItem(maxHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thử xem sao</span></span><br><span class="line">getTallestPerson(members);</span><br><span class="line"><span class="comment">// =&gt; &#123; name: 'Dan', height: 194 &#125;</span></span><br></pre></td></tr></table></figure><p>Ví dụ trên tuy tầm thường, nhưng có thể là gợi ý tốt để bạn dùng higher-order function thiết kế những chương trình linh hoạt, dễ mở rộng.</p><h3 id="Function-Composition"><a href="#Function-Composition" class="headerlink" title="Function Composition"></a>Function Composition</h3><p>Đây là <a href="https://www.mathsisfun.com/sets/functions-composition.html" target="_blank" rel="noopener">khái niệm Toán học</a> mà tiếng Việt ta gọi là “hàm hợp”, hay “hàm phức hợp”. Mọi thứ trong Functional Programming đều có nguồn gốc Toán học.</p><p>Function Composition là sự phối hợp, liên kết nhiều hàm lại với nhau, thành một hàm lớn, nhiều chức năng hơn.</p><p>Có 2 kỹ thuật căn bản trong Function Composition là compose và pipe.</p><h4 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h4><p>Hãy nhớ lại, trong không gian Functional Programming tồn tại vô số pure functions nhỏ gọn, đơn giản. Đúng triết lý “do one thing and do it well” của UNIX.</p><p>Vì mỗi hàm chỉ làm 1 việc, khi muốn thực hiện nhiều hành động lên cùng một input, ta chỉ việc kết hợp các hàm cần thiết lại với nhau.</p><p>Bây giờ chúng ta hãy tạm ngừng tu luyện, tạm quên tu vi để nhập phàm, quan sát và cảm ngộ nhân sinh.</p><p>Lần này, bạn hóa thành con trai thứ 4 trong gia đình một thôn dân sinh sống dưới chân núi Tản Viên bằng nghề bán thịt…</p><p>Một hôm bạn xin được khúc cây lớn ở chỗ ông chú làm kiểm lâm kiêm lâm tặc.</p><p> <img src="https://i.imgur.com/OQofkz2.jpg" alt=""></p><p>Từ khúc gỗ này, bạn muốn làm ra cái thớt cho nhà dùng.</p><p>Là tu sĩ mới nhập môn tu luyện Functional Programming, tuy không có tu vi, nhưng bạn vẫn hình dung được sẽ cần đến các pure functions sau:</p><ul><li>cưa(): nhận vào khúc gỗ, trả về từng khoanh tròn</li><li>sấy(): nhận khoanh gỗ tươi, trả về khoanh gỗ khô</li><li>bào(): nhận vào khoanh gỗ, trả về khoanh gỗ bằng phẳng</li><li>khoan(): nhận vào khoanh gỗ, trả về khoanh gỗ có 2 lỗ (để gắn quai treo/móc lên cho gọn)</li><li>chà(): nhận vào khoanh gỗ, trả về khoanh gỗ trơn láng (dùng giấy nhám, miền ngoài gọi giấy giáp, để đánh cho nhẵn bề mặt)</li><li>móc(): nhận thớt không quai, trả về thớt có quai</li></ul><p>Mỗi hàm chỉ làm đúng 1 việc. Không hơn. Không kém. Khi đi qua chừng đó công đoạn, ta sẽ được sản phẩm mong muốn.</p><p> <img src="https://i.imgur.com/qKYfPYA.jpg" alt=""></p><p>Dĩ nhiên chúng ta đang muốn khúc gỗ được sửa đổi nên tạm bỏ qua vấn đề immutability.</p><p>Đây là phiên bản mô phỏng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cưa = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã cưa`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sấy = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã sấy`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bào = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã bào`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> khoan = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã khoan`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chà = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã chà`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> móc = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã gắn móc`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Để tạo ra 1 cái thớt, ở thời viễn cổ xa xưa, các man sĩ thường code thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thớt = cưa(<span class="string">'khúc gỗ'</span>);</span><br><span class="line">thớt = sấy(thớt);</span><br><span class="line">thớt = bào(thớt);</span><br><span class="line">thớt = khoan(thớt);</span><br><span class="line">thớt = chà(thớt);</span><br><span class="line">thớt = móc(thớt);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thớt);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc</span></span><br></pre></td></tr></table></figure><p> <img src="https://i.imgur.com/nBLW7ye.jpg" alt=""></p><p>5 vạn năm sau, khi đã xuất hiện Toán học, các tộc nhân bộ lạc Giao Chỉ thời đại Hồng Bàng lại thích code như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thớt = móc(chà(khoan(bào(sấy(cưa(<span class="string">'khúc gỗ'</span>))))));</span><br><span class="line"><span class="built_in">console</span>.log(thớt);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc</span></span><br></pre></td></tr></table></figure><p>Đây chính là Toán học cơ bản. Với y = f(g(x)), ta tính g(x) trước, được bao nhiêu truyền vào f() là ra kết quả. Việc tính toán đi từ ngoặc trong cùng ra ngoài, mắt thường nhìn thấy là từ phải sang trái, từ g đến f.</p><p>Lại thêm 5 ngàn năm nữa trôi qua. Lúc này đã có ES6. Một số cường giả Functional Programming sáng tạo ra phương thức compose, như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> (x) =&gt; f(g(x)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Bạn có thể dùng <a href="https://babeljs.io/repl" target="_blank" rel="noopener">Babel</a> dịch sang ES2015 cho dễ hiểu.</p><p>Ý tưởng của compose là xếp cuốn chiếu các hàm lại với nhau, theo thứ tự từ trái sang phải để tạo ra một hàm mới, mà khi được thực thi, nó sẽ lần lượt gọi các hàm đã truyền vào trước đó theo thứ tự ngược lại, từ phải sang trái.</p><p>Tức là nếu y = compose(f, g), thì y(x) = f(g(x));<br>Nó sẽ tính g(x) trước rồi truyền kết quả cho f;<br>Giả sử g(x) = z thì y(x) = f(z);</p><p>Nếu bạn vẫn thấy mơ hồ thì cứ xem cái này là Đạo. Chỉ có thể cảm ngộ, không thể giảng được bằng lời!</p><p>Trở lại với cái thớt. Hàm compose tất nhiên là higher-order function. Ta sẽ thử xem nó làm việc ra sao:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quăng_cho_tao_cái_thớt = compose(móc, chà, khoan, bào, sấy, cưa);</span><br><span class="line"><span class="built_in">console</span>.log(quăng_cho_tao_cái_thớt.toString());</span><br><span class="line"><span class="comment">// =&gt; bạn đoán xem log ra thứ gì?</span></span><br></pre></td></tr></table></figure><p>Bây giờ ta có 1 hàm, gọi là quăng_cho_tao_cái_thớt(), kết quả của sự lắp ghép bằng compose tất cả các pure functions ở trên.</p><p>Ta biết compose sẽ gọi từ phải sang trái, nên công đoạn nào làm trước thì để bên phải.</p><p>Chạy thử 1 phát:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thớt = quăng_cho_tao_cái_thớt(<span class="string">'khúc gỗ'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thớt); </span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc</span></span><br></pre></td></tr></table></figure><p>Vậy là đủ công đoạn, khúc gỗ đã trở thành một cái thớt tốt.</p><p>Nhưng chưa hết. Khi bạn treo cái thớt đó ở nhà, nhiều người quen đến chơi thấy đẹp hỏi mua. Nhiều đến mức bạn quyết định kinh doanh thớt.</p><p>Làm thớt kinh doanh thì phải gán nhãn, vậy là bạn tạo ra một pure function mới và dùng compose để làm khuôn sản suất loại thớt commercial này.</p><p>Dễ ợt, không ảnh hưởng gì đến loại thớt cho nhà dùng.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nhãn = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span> đã dán nhãn`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> làm_thớt_để_bán = compose(nhãn, móc, chà, khoan, bào, sấy, cưa);</span><br></pre></td></tr></table></figure><p>Hoặc tận dụng lại khuôn mẫu cũ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> làm_thớt_để_bán = compose(nhãn, quăng_cho_tao_cái_thớt);</span><br></pre></td></tr></table></figure><p>Thử xem sao:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thớt_bán = làm_thớt_để_bán(<span class="string">'khúc gỗ'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thớt_bán);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã móc đã dán nhãn</span></span><br></pre></td></tr></table></figure><p>Để mở rộng thị phần, hướng đến phân khúc giá rẻ, bạn tạo ra dòng sản phẩm thớt tầm trung, dùng chip MediaTek, bỏ qua bước sấy khô và đánh bóng để giảm giá thành. Rất đơn giản:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> làm_thớt_loại_hai = compose(nhãn, móc, khoan, bào, cưa);</span><br></pre></td></tr></table></figure><p>Thử xem sao:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thớt_loại_hai = làm_thớt_loại_hai(<span class="string">'khúc gỗ'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thớt_loại_hai);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã bào đã khoan đã móc đã dán nhãn</span></span><br></pre></td></tr></table></figure><p>Lập trình như vậy phải nói là vô cùng tao nhã, lịch thiệp! Đôi khi tôi cảm thấy phong cách lập trình Functional Programming có sự thanh tịnh đầy chất quý tộc, vừa bình dân lại vừa hàn lâm, đẹp đến mức khó hiểu!</p><p>Nếu dùng OOP, có thể chúng ta còn đang loay hoay giữa một đống class Máy Cưa, Máy Bào, Máy Khoan… Hoặc 1 class Máy Làm Thớt khổng lồ có đủ methods cưa, bào, khoan… Rồi còn một mớ properties mà ta phải cân nhắc xem cái nào public, cái nào private. Rồi phải tạo instance, thừa kế qua lại mấy vòng may ra mới làm được cái thớt. Muốn thêm dòng sản phẩm lại càng khó khăn. Phải tạo class Thớt_nhà<em>dùng, extend ra Thớt</em>để<em>bán, Thớt</em>để_bán_loại_2, phiền phức không sao kể xiết!</p><p>Functional Programming thì chỉ cần mấy hàm đơn giản, rời rạc, dùng compose lắp ráp lại như lắp ráp dây chuyền công nghệ là chế được các kiểu thớt.</p><p>Function Composition tựa như một nhà máy hiện đại, mỗi chi tiết linh kiện được xử lý bằng một robot chuyên trách, kết hợp lại với nhau một cách khoa học để tạo ra sản phẩm hoàn thiện.</p><h4 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h4><p>Một biến thể của compose là pipe, vận hành theo chiều ngược lại. Ta có thể implement bằng cách đảo vị trí f và g thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> (x) =&gt; g(f(x)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Hoặc giữ nguyên code của compose nhưng thay reduce bằng reduceRight:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduceRight(<span class="function">(<span class="params">f, g</span>) =&gt;</span> (x) =&gt; f(g(x)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Vì pipe tổ hợp các hàm theo chiều ngược lại so với compose nên ta viết:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> làm_thớt_dỏm = pipe(cưa, bào, nhãn);</span><br></pre></td></tr></table></figure><p>Thử xem sao:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thớt_dỏm = làm_thớt_dỏm(<span class="string">'khúc gỗ'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thớt_dỏm);</span><br><span class="line"><span class="comment">// =&gt; khúc gỗ đã cưa đã bào đã dán nhãn</span></span><br></pre></td></tr></table></figure><p>Dùng pipe có vẻ thuận mắt hơn. Thứ tự các bước cưa, bào… trông khá tự nhiên. Nếu bạn quen với cách suy luận Toán học thì bạn sẽ thích compose. Còn nếu bạn muốn trực quan dễ hiểu thì cứ dùng pipe.</p><p>compose và pipe là những thuật pháp nhập môn dễ học, dễ dùng, nhưng không kém uy lực, thư viện Functional Programming nào cũng có. Trong Ramda.js, ngoài <a href="http://ramdajs.com/docs/#compose" target="_blank" rel="noopener">compose</a> và <a href="http://ramdajs.com/docs/#pipe" target="_blank" rel="noopener">pipe</a>, các tác giả còn bổ sung thêm pipeK, pipeP, composeK, composeP.</p><p>Khi đã thông thạo, bạn hoàn toàn có thể tạo ra compose theo cách của bạn. Ví dụ composeBinary liên kết các hàm từ giữa sang 2 bên thay vì từ đầu này đến đầu kia, composeRandom liên kết các hàm không theo trật tự cố định… Đó là không gian sáng tạo thuộc về riêng bạn.</p><h3 id="Currying-function"><a href="#Currying-function" class="headerlink" title="Currying function"></a>Currying function</h3><p>Thuật ngữ currying và các dạng curry, curried của nó trong khoa học máy tính được <a href="https://en.wikipedia.org/wiki/Christopher_Strachey" target="_blank" rel="noopener">Christopher Strachey</a> đặt ra từ năm 1967 để ghi nhớ công lao của <a href="https://en.wikipedia.org/wiki/Haskell_Curry" target="_blank" rel="noopener">Haskell Brooks Curry</a>, một nhà Toán học và Luận lý học người Mỹ.</p><p>Currying function là làm cho 1 function trở thành “curried function”.</p><p>Cái function ban đầu đó hơi ngốc nghếch, nó cần bạn truyền vào N tham số để tính toán, mà nếu thiếu 1 tham số, nó sẽ không chạy.</p><p>Ví dụ hàm sum thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sum cần 3 tham số để cộng dồn lại, nếu thiếu, sẽ không tính toán ra được.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// có thể ra sân</span></span><br><span class="line">sum(<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">sum(<span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">sum(<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">sum(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nhưng</span></span><br><span class="line">sum(<span class="number">4</span>, <span class="number">5</span>); <span class="comment">// =&gt; NaN</span></span><br></pre></td></tr></table></figure><p>Đây là thiếu tiền đạo cả đội không chịu ra sân tập! Nhưng cuộc sống đâu phải lúc nào cũng thuận lợi, đầy đủ cho chúng ta? Dù cả mấy tiền đạo đều bị chấn thương, treo giò, trốn tập thì các anh còn lại vẫn phải có trách nhiệm ra sân chứ!</p><p>Currying chính là kỹ thuật biến hàm sum ngốc đó trở thành một function vi diệu hơn, nếu bạn gọi nó với 1 tham số, nó sẽ trả về 1 hàm tạm thời, giữ lại tham số đó, chờ khi nào đủ 3 tham số thì mới thực hiện tính toán.</p><p>Hình dung bạn tổ chức một buổi party, mời 3 người bạn tham gia. Lúc này đã có mặt 2 người, còn 1 người đến muộn. Bạn quyết định không cần chờ nữa. Bữa tiệc cứ bắt đầu đã, chừng nào người kia đến thì tính tiếp.</p><p>Đây là 1 cách implement cho hàm curry:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> totalArguments = fn.length;</span><br><span class="line">  <span class="keyword">let</span> next = <span class="function">(<span class="params">argumentLength, rest</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argumentLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next(</span><br><span class="line">          argumentLength - args.length,</span><br><span class="line">          [</span><br><span class="line">            ...rest,</span><br><span class="line">            ...args,</span><br><span class="line">          ]</span><br><span class="line">        );</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(...rest);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> next(totalArguments, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Và curry tất nhiên cũng là higher-order function.</p><p>Thử dùng với sum xem sao:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curriedSum = curry(sum);</span><br></pre></td></tr></table></figure><p>curriedSum bây giờ là phiên bản curried của hàm sum trước đó.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curriedSum(<span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">curriedSum(<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">curriedSum(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// và</span></span><br><span class="line">curriedSum(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// =&gt; [Function]</span></span><br></pre></td></tr></table></figure><p>curriedSum(5, 3) là 1 function. Nó đang chờ đợi tham số cuối cùng xuất hiện. Nếu bây giờ ta gọi nó với 1 tham số thì kết quả sẽ được tính toán ra:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curriedSum(<span class="number">5</span>, <span class="number">3</span>)(<span class="number">2</span>); <span class="comment">// =&gt; 10</span></span><br></pre></td></tr></table></figure><p>Nếu ta truyền nhiều hơn số lượng tham số còn thiếu thì sao? Ở đây là 1 tham số cuối cùng. Theo cách implement trên thì nó sẽ bỏ qua các tham số dư thừa. Các phiên bản curry của <a href="http://ramdajs.com/docs/#curry" target="_blank" rel="noopener">Ramda.js</a> và <a href="https://lodash.com/docs/4.17.10#curry" target="_blank" rel="noopener">Lodash FP</a> cũng hành xử như vậy.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curriedSum(<span class="number">5</span>, <span class="number">3</span>)(<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>); <span class="comment">// =&gt; 10</span></span><br></pre></td></tr></table></figure><p>Một điểm quan trọng nữa là ta có thể phân tách hàm gốc ra từ 1 đến N phần, với N là số lượng tham số của hàm gốc đó. Chẳng hạn, nếu hàm gốc có 3 tham số, ta có thể chia nó ra 1, 2 hoặc 3 phần. Những cách viết sau là tương đương:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curriedSum(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">curriedSum(<span class="number">3</span>, <span class="number">5</span>)(<span class="number">2</span>);</span><br><span class="line">curriedSum(<span class="number">3</span>)(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">curriedSum(<span class="number">3</span>)(<span class="number">5</span>)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>curry, cũng như compose và pipe là những kỹ thuật căn bản, ai cũng phải học, phải biết. Mọi ngôn ngữ được thiết kế với tư tưởng Functional Programming như Haskell, Scalla, Elm… đều có sẵn các hàm này. Chúng rất tinh tế và được dùng ở khắp nơi.</p><p>Chỉ cần thành thạo 3 pháp quyết này thì bạn đã được xem như đệ tử Functional Programming chân chính.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Như vậy, Functional Programming là nghệ thuật lập trình trong đó ta:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sử dụng functions để điều khiển workflow&lt;/li&gt;
&lt;li&gt;tuân thủ 2 nguyên tắc immutability và purity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nói cách khác, chư vị tin hữu muốn tu luyện Functional Programming thì phải giữ đạo tâm trong sáng, ý chí kiên định, hàng ngày chiêm nghiệm, suy diễn, cảm ngộ function, tu vi theo đó sẽ không ngừng thăng tiến.&lt;/p&gt;
&lt;p&gt;Nhưng làm thế nào để cảm ngộ “phân sần ý cảnh”? Ta phải nắm bắt, quan sát, tư duy, suy tưởng về function ra sao? Sau đây là những pháp quyết nhập môn.&lt;br&gt;
    
    </summary>
    
    
      <category term="functional programming" scheme="http://nthung2112.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Functional Programming - Phần 1 - Con đường sáng</title>
    <link href="http://nthung2112.github.io/2018/06/Functional-Programming-Phan-1-Con-duong-sang.html"/>
    <id>http://nthung2112.github.io/2018/06/Functional-Programming-Phan-1-Con-duong-sang.html</id>
    <published>2018-06-12T08:35:00.000Z</published>
    <updated>2018-06-23T08:53:43.941Z</updated>
    
    <content type="html"><![CDATA[<p>Lúc bấy giờ, Tin giới Tây phương xuất hiện 2 lão quái Nguyên Anh hậu kỳ đỉnh phong, chỉ thiếu nửa bước cảm ngộ ý cảnh là đột phá tới cảnh giới Hóa Thần. Một người là Đồ Linh tôn giả - tức Alan Turing, nổi danh với pháp môn Turing Machine. Người kia là Khâu Kỳ thượng tiên, Alonzo Church, tung hoành tam giới bằng đạo thuật Lambda Calculus (1).</p><p>Turing Machine của Alan Turing và Lambda Calculus của Alonzo Church thực ra là hai cách tiếp cận nguyên lý xử lý tính toán trong computer, thường được giới chuyên môn gọi chung là Luận đề Church - Turing (<a href="https://plato.stanford.edu/entries/church-turing/" target="_blank" rel="noopener">The Church-Turing Thesis</a>).</p><a id="more"></a><p>Turing Machine đặt cơ sở trên việc nắm giữ state machine và trạng thái tiến trình, còn ý tưởng Lambda Calculus được xây dựng trên các tính chất của hàm toán học. Lấy tu vi của bổn tiên hiện giờ thì chưa lĩnh hội được mấy thứ cao siêu như vậy, nên không dám lạm bàn ở đây. Chỉ biết rằng, 2 thuật pháp kể trên là khởi nguồn của 2 trường phái tu luyện mạnh nhất trong tin giới hiện nay: Object Oriented Programming và Functional Programming.</p><p>Có khá nhiều cơ chế lập trình - Programming Paradigm. OOP và Functional Programming chỉ là 2 trong số đó. Trong cuốn “<a href="https://drive.google.com/file/d/1sNAojaDlY4Q9LAMad_2aJLIUBt06ru7U/view" target="_blank" rel="noopener">Programming Paradigms for Dummies: What Every Programmer Should Know</a>“, tác giả Peter Van Roy đưa ra mô hình tổng hợp quan hệ giữa các cơ chế lập trình như thế này:</p><p> <img src="https://i.imgur.com/1yDCYYq.png" alt=""></p><p>Trong lịch sử công nghệ, có vẻ OOP chiếm ưu thế hơn so với Functional Programming. Bạn cứ thử nhìn xung quanh mình là biết, từ thời tập tành code đã thấy thiên địa tràn ngập quy tắc OOP rồi. Các job description, các buổi interview đều nhắc đến OOP như pháp thuật căn bản. Thảo luận kỹ thuật hầu hết xoay quanh mấy khái niệm Class, Object, Inheritance, rồi cao hơn thì SOLID, Polymorphism, Encapsulation…</p><p>Nhưng, trên thế giới, từ thời <a href="http://lisp-lang.org/" target="_blank" rel="noopener">Lisp</a> đến <a href="https://en.wikipedia.org/wiki/FP_%28programming_language%29" target="_blank" rel="noopener">FP</a>, rồi <a href="https://www.haskell.org/" target="_blank" rel="noopener">Haskell</a>, <a href="https://elixir-lang.org/" target="_blank" rel="noopener">Elixir</a>, chưa bao giờ thiếu vắng những tu tin giả đi theo con đường Functional Programming. Nhất là khoảng sau 2010, không rõ vì sao người ta bắt đầu phàn nàn nhiều hơn về OOP, trích dẫn nhiều hơn luận điểm banana/gorilla của Joe Armstrong (2), theo đó, chủ đề “Functional Programming” bắt đầu nóng dần trở lại.</p><p>Tôi biết đến Functional Programming vào khoảng 2015 qua một talk show trên YouTube của “<a href="https://en.wikipedia.org/wiki/Robert_C._Martin" target="_blank" rel="noopener">chú Bob</a>“, nhưng không hiểu lắm nên cũng không chú ý.</p><p>Phải sang 2016, tôi mới chính thức tìm hiểu sâu về Functional Programming sau khi đọc 2 loạt bài viết “<a href="https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea" target="_blank" rel="noopener">Composing Software</a>“ của <a href="https://medium.com/@_ericelliott" target="_blank" rel="noopener">Eric Elliott</a> và “<a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536" target="_blank" rel="noopener">So You Want to be a Functional Programmer</a>“ của <a href="https://medium.com/@cscalfani" target="_blank" rel="noopener">Charles Scalfani</a> trên Medium.</p><p>Eric Elliott lần lượt giải thích từng concepts của Functional Programming một cách tường tận, dễ hiểu. Còn Charles Scalfani đúng là fan cuồng Functional Programming. Anh trình bày nó dưới dạng một hệ thống triết lý, thế giới quan đặc sắc. Thậm chí, Scalfani còn đề cao Functional Programming như nấc thang tiến hóa trong lịch sử lập trình. Lối viết của anh gây ấn tượng cực mạnh.</p><p> <img src="https://i.imgur.com/e3zKVPq.png" alt=""></p><p>Trước đó, Scalfani còn có bài “<a href="https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53" target="_blank" rel="noopener">Goodbye, Object Oriented Programming</a>“ gây tranh luận sôi nổi.</p><p>Nhưng bạn đọc nên lưu ý, Functional Programming không bài xích OOP. Chúng chỉ là những con đường tu luyện khác nhau, cùng hướng về Đại Đạo. Trong khi viết code, ta hoàn toàn có thể phối hợp nhiều cơ chế lập trình khác nhau, miễn sao đạt đến kết quả Đúng - Nhanh - Ổn - Đẹp.</p><p>ReactJS là một ví dụ tiêu biểu, có thể coi nó như 7 phần Functional Programming + 3 phần OOP. Về điểm này, <a href="https://twitter.com/anjanavakil" target="_blank" rel="noopener">Anjana Vakil</a> có một bài thuyết trình rất hay ở GOTO 2017.</p><div class="video-container"><iframe src="//www.youtube.com/embed/Pg3UeB-5FdA" frameborder="0" allowfullscreen></iframe></div><p>Dù sao, từ đó đến nay, khuynh hướng tư duy Functional Programming vẫn từng bước lan rộng, ảnh hưởng đến thiết kế của rất nhiều chương trình hiện đại. Chỉ cần để ý một chút, chúng ta có thể nhận ra các đặc tính nổi bật của Functional Programming xuất hiện trong hầu hết frameworks và các bản cập nhật ngôn ngữ mới. Thậm chí, nếu xét kỹ, những khái niệm thoạt nhìn có vẻ không liên quan như WebComponent, Serverless, Microservice… cũng ẩn hiện tư tưởng Functional Programming. Và tôi gần như không còn đụng tới class, new, this nữa.</p><p> <img src="https://i.imgur.com/LuyuYCU.jpg" alt=""></p><h3 id="What’s-Functional-Programming"><a href="#What’s-Functional-Programming" class="headerlink" title="What’s Functional Programming?"></a>What’s Functional Programming?</h3><p>Vậy rốt cuộc Functional Programming là cái gì? Nếu google bạn sẽ tìm thấy hàng tá cách giải thích khác nhau. Còn tôi chủ chương nên định nghĩa ngắn gọn thế này:</p><p><em>Functional Programming là phương pháp lập trình lấy function làm đơn vị thao tác cơ bản.</em></p><p>Đúng vậy. Functional Programming xét về lý tưởng thì chỉ có function, function và function. Không lệnh gán (assignment statements), không cần tới các biến (variables), không lưu giữ trạng thái toàn cục (global state). Trong Functional Programming, chúng ta điều khiển dòng chảy chương trình bằng cách phối hợp các functions lại với nhau. Chúng ta tung hứng các functions qua lại, nhận vào function, nhả ra function, lồng ghép, xâu chuỗi, biến hóa chúng theo mọi cách có thể nghĩ ra.</p><p>Đó gọi là không gian “<a href="https://en.wikipedia.org/wiki/First-class_function" target="_blank" rel="noopener">first-class functions</a>“, nơi lập trình viên đối xử với functions như “first-class citizens”. Ở đâu functions được coi trọng như vậy, ở đó ta có thể lập trình theo cơ chế Functional Programming. JavaScript, Python, Golang, ngay cả PHP chính là như vậy. Java tính từ v8.0 ra mắt năm 2017 cũng là như vậy. Dù không hoàn hảo như Haskell, F#, etc - những tu chân giới vốn được sinh ra cho Functional Programming - nhưng ta vẫn có thể tu luyện Functional Programming được…</p><p>Chỉ có điều phải vận dụng khác một chút, linh hoạt hơn một chút. Đó là lý do tại sao trong các chương trình JavaScript, Python, dù viết theo phong cách Functional Programming nhưng vẫn phải dùng đến các biến, lệnh gán để thao tác.</p><p>Các tu tin giả tầng thấp muốn bắt đầu con đường Functional Programming cần phải nắm bắt những khái niệm cơ bản như Immutability, Purity, Higher-order functions, Currying function, Function Composition… Sau khi thăng cấp cảnh giới cao hơn thì có thể tìm hiểu Monad, Functor, Setoid, Idempotent, Lens… và nhiều nữa.</p><p>Nào, bây giờ hãy bắt đầu hành trình…</p><h3 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h3><p>Immutability nghĩa là tính bất biến.</p><p>Nguyên tắc thứ nhất trong Functional Programming là: cái nào đã khai báo một lần thì mãi mãi như vậy, không bao giờ thay đổi nữa. Các biến hoặc đối tượng trong kịch bản Functional Programming nếu có thì phải immutable.</p><p>Code thế này không phải là Functional Programming vì x và y bị thay đổi.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  y += x;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mutable là điều tối kỵ trong Functional Programming. Cần phải hạn chế đến mức thấp nhất. Các mẫu coding convention và best practices thông dụng hiện nay đều khuyến khích sử dụng const để khai báo, bỏ hẳn var , và dùng let đúng liều lượng.</p><p>Đối với Object, ta nên dùng Object.freeze để lock toàn bộ thuộc tính. Cũng có thể dùng Object.defineProperty, Object.defineProperties để lock một số thuộc tính quan trọng. Các giải pháp này đều chỉ hỗ trợ 1 cấp thuộc tính. Phải chủ động code thêm nếu muốn áp dụng lên các thuộc tính con.</p><p>Nếu dự án đủ phức tạp, hãy cân nhắc sử dụng các thư viện chuyên dụng như <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">Immutable.js</a>, <a href="https://github.com/Yomguithereal/baobab" target="_blank" rel="noopener">Baobap</a>…</p><h3 id="Purity"><a href="#Purity" class="headerlink" title="Purity"></a>Purity</h3><p>Purity là tính thuần khiết, thuần túy, sự trong sạch, không bị pha tạp.</p><p>Đây là nguyên tắc thứ hai trong Functional Programming: tất cả các hàm đều phải là pure function, không có hiệu ứng phụ (side effect), không được tác động lên bất cứ giá trị nào bên ngoài nó, cũng nói không với chỉnh sửa tham số input.</p><p>Hàm dưới đây không phải pure function vì nó chỉnh sửa DOM element bên ngoài và thay đổi giá trị chứa trong localStorage.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateView = <span class="function">(<span class="params">html</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> $view = <span class="built_in">document</span>.getElementById(<span class="string">'panel'</span>);</span><br><span class="line">  $view.innerHTML = html;</span><br><span class="line">  localStorage.setItem(<span class="string">'panelCache'</span>, html);</span><br><span class="line">  <span class="keyword">return</span> $view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đặc điểm quan trọng nữa của pure function là với mỗi tập giá trị đầu vào nhất định, luôn có 1 và chỉ 1 kết quả trả về tương ứng. Đây là tính chất của hàm số toán học.</p><p>Hàm dưới đây không phải pure function vì trả về kết quả khác nhau cho cùng đầu vào:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getDuration = <span class="function">(<span class="params">timestamp</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Date</span>.now() - timestamp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Pure function trong Functional Programming thường ngắn gọn, đơn giản và chỉ xử lý duy nhất 1 vấn đề logic.</p><p>Đây là 1 pure function kinh điển:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Dù bạn có gọi hàng triệu lần thì add(3, 2) vẫn luôn trả về 5.</p><p>Viết unit test cho pure function là nhiệm vụ dễ chịu như dạo chơi cùng một thiếu nữ ngây thơ trong trắng vậy!</p><p>Immutability và Purity là 2 đặc trưng cơ bản nhất của Functional Programming, cho phép phân biệt với các cơ chế lập trình khác. Tu tin giả tu luyện theo con đường này nhất định phải giữ tâm niệm “immutable” và “pure” trong từng sát na.</p><h3 id="Chu-thich"><a href="#Chu-thich" class="headerlink" title="Chú thích"></a>Chú thích</h3><p>1, Chữ Tàu ghi Alan Turing là 艾伦图灵 - Ngải Luân Đồ Linh, Alonzo Church là 阿隆佐邱奇 - A Long Tá Khâu Kỳ.</p><p>2, “You wanted a banana but you got a gorilla holding the banana”.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lúc bấy giờ, Tin giới Tây phương xuất hiện 2 lão quái Nguyên Anh hậu kỳ đỉnh phong, chỉ thiếu nửa bước cảm ngộ ý cảnh là đột phá tới cảnh giới Hóa Thần. Một người là Đồ Linh tôn giả - tức Alan Turing, nổi danh với pháp môn Turing Machine. Người kia là Khâu Kỳ thượng tiên, Alonzo Church, tung hoành tam giới bằng đạo thuật Lambda Calculus (1).&lt;/p&gt;
&lt;p&gt;Turing Machine của Alan Turing và Lambda Calculus của Alonzo Church thực ra là hai cách tiếp cận nguyên lý xử lý tính toán trong computer, thường được giới chuyên môn gọi chung là Luận đề Church - Turing (&lt;a href=&quot;https://plato.stanford.edu/entries/church-turing/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Church-Turing Thesis&lt;/a&gt;).&lt;/p&gt;
    
    </summary>
    
    
      <category term="functional programming" scheme="http://nthung2112.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Cấu trúc projects và đặt tên components trong React</title>
    <link href="http://nthung2112.github.io/2018/05/Cau-truc-projects-va-dat-ten-components-trong-React.html"/>
    <id>http://nthung2112.github.io/2018/05/Cau-truc-projects-va-dat-ten-components-trong-React.html</id>
    <published>2018-05-26T16:02:00.000Z</published>
    <updated>2018-05-26T13:12:57.001Z</updated>
    
    <content type="html"><![CDATA[<p>Như bạn đã biết, React chỉ là một thư viện nên nó không chỉ rõ cho người dùng cách tổ chức, phân chia cấu trúc thư mục cho dự án của mình. Xét trên một khía cạnh, có thể điều này là tốt vì dev có thể thoải mái thử rất nhiều cách khác nhau để chọn ra phương pháp phù hợp với dự án của mình. Tuy nhiên, nó lại khiến cho những dev mới bắt đầu sử dụng React cảm thấy khó hiểu. Bài viết này sẽ đưa ra một vài phương pháp phân chia folders, files giúp cho ứng dụng React của bạn có thể mở rộng một cách thuận tiện, nhất là đối với những người mới bước chân vào React và không biết phải làm như thế nào cho hợp lý.</p><a id="more"></a><h1 id="Cau-truc-files-va-folders"><a href="#Cau-truc-files-va-folders" class="headerlink" title="Cấu trúc files và folders"></a>Cấu trúc files và folders</h1><p>Một trong những câu hỏi dev thường gặp phải khi bắt đầu code là “Làm thế nào dể phân chia files và folders”. Để thuận tiện thì chúng ta sẽ bắt đầu từ cấu trúc đơn giản nhất mà package <strong>create-react-app</strong> đã tạo ra. Cụ thể là folder <strong>src</strong>. Đây là folder chính chứa source code, vì vậy chúng ta sẽ tập trung vào phần này. Toàn bộ những files, folder khác nằm ngoài vẫn sẽ được giữ nguyên:</p><p><img src="https://cdn-images-1.medium.com/max/800/1*eXN1LlNnuZmosJ7n7EsJ-Q.png" alt=""></p><h2 id="Tach-rieng-thanh-folder-Containers-va-Components"><a href="#Tach-rieng-thanh-folder-Containers-va-Components" class="headerlink" title="Tách riêng thành folder Containers và Components"></a>Tách riêng thành folder Containers và Components</h2><p>Có thể bạn đã thấy trong một vài dự án, dev thường sử dụng hai folders có tên <em>Components</em> và <em>Containers</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├─ components </span><br><span class="line">└─ containers</span><br></pre></td></tr></table></figure><p>Thoạt nhìn thì có vẻ ổn, nhưng cách phân chia như trên còn tồn tại những nhược điểm như sau:</p><ul><li><strong>Định nghĩa chức năng một cách không rõ ràng</strong> - Sử dụng cấu trúc như trên có thể gây nhầm lẫn, hiểu lần về chức năng của mỗi folder <em>Container</em> và <em>Component</em> , có nhiều người sẽ hiểu chức năng của mỗi folder theo ý khác nhau. Có người thì hiểu <em>Containers</em> là các components thực hiện việc xử lý logic (như handle click, button) và lấy dữ liệu từ server, còn components có nghĩa <em>Presentational Component</em>, thực hiện nhiệm vụ hiển thị view cho người dùng. Có người lại sử dụng <em>Containers</em> để chứa những route components (mỗi component là một link route, nếu như bạn sử dụng react-router), còn <em>Components</em> thì chứa những base component để tạo nên các route components kia. Vì thế khi làm việc trong team sẽ gây ra không đồng nhất và các member khó thống nhất trong việc sử dụng hai folder này.</li><li><strong>Components không còn linh động, reusable</strong> - Ngay cả khi bạn đã code ra một components với chức năng đặc thù, sau này bạn vẫn phải sửa lại components đó do những lí do như đổi requirements, thêm chức năng,… khiến cho file chuyển qua chuyển lại giữa 2 folders <strong>components</strong> và <strong>containers</strong>.</li><li><strong>Components trùng tên</strong> - Khi sử dụng react, tên của một component nên có ý nghĩa như chức năng của nó, và quan trọng là không nên có nhiều components trùng tên nhau trong project để tránh gây nhầm lẫn. Cách tổ chức folders như trên sẽ tạo ra 2 components có tên giống nhau, một sử dụng cho <strong>container</strong>, một sử dụng cho <strong>components</strong> (<em>presentational</em> - hiển thị)</li><li><strong>Giảm hiệu suất code</strong> - Bạn sẽ phải thường xuyên navigate giữa 2 folder trên khi viết cho một tính năng, do một tính năng thường sẽ gồm cả 2 loại components Một cách phân chia khác cũng có cấu trúc 2 folder như trên, nhưng phân biệt dựa trên module . Giả sử ứng dụng của bạn có một module User. Trong đó sẽ tách ra thành 2 folder components và containers:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">└─ User</span><br><span class="line">    ├─ components </span><br><span class="line">    └─ containers</span><br></pre></td></tr></table></figure><p>Theo hướng tiếp cận trên, dev sẽ không phải gặp khó khăn trong việc navigate giữa các folder khi code. Bạn sẽ không phải kéo lên, kéo xuống để tìm xem components của User ở đâu, khi đang hoàn thiện file trong containers để đối chiếu. Tuy nhiên, cách này sẽ sinh ra một đống folder containers và components nếu như hệ thống của bạn lớn và cót rất nhiều modules.</p><p>Như vậy, việc tách biệt 2 folder <strong>components</strong> và <strong>containers</strong> không hẳn là hợp lý. Thay vì tách riêng ra như vậy, các components sẽ được đặt hết trong folder <strong>components</strong> ngoại trừ những components sử dụng làm <em>screens</em></p><h2 id="Tai-cau-truc-folders-dua-tren-module"><a href="#Tai-cau-truc-folders-dua-tren-module" class="headerlink" title="Tái cấu trúc folders dựa trên module"></a>Tái cấu trúc folders dựa trên module</h2><p>Trong folder <strong>components</strong>, chúng ta sẽ nhóm các files lại theo module hoặc feature/tính năng.</p><p>Với tính năng CRUD user, chúng ta chỉ cần module User, nên folder tree sẽ có dạng như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">└─ components</span><br><span class="line">  └─ User</span><br><span class="line">    ├─ Form.jsx</span><br><span class="line">    └─ List.jsx</span><br></pre></td></tr></table></figure><p>Khi component được cấu thành bời nhiều hơn một file (chẳng hạn như phải import nhiều components khác, hay file chỉnh sửa css cho component đó), chúng ta sẽ đưa component này cùng các files liên quan vào một folder có cùng tên. Ví dụ như <strong>Form.jsx</strong> cần thêm <strong>Form.css</strong> để chỉnh style, bạn sẽ có một folder như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">└─ components</span><br><span class="line">  └─ User</span><br><span class="line">    ├─ Form</span><br><span class="line">    │ ├─ Form.jsx</span><br><span class="line">    │ └─ Form.css</span><br><span class="line">    └─ List.jsx</span><br></pre></td></tr></table></figure><h3 id="UI-components"><a href="#UI-components" class="headerlink" title="UI components"></a>UI components</h3><p>Ngoài các folder dành cho module hay tính năng trong ứng dụng của bạn, có thể thêm một folder _UI_ (hoặc <em>base</em>/<em>atomic</em>) dùng cho các component dạng UI - là những phần tử nhỏ sử dụng cho UI trong ứng dụng của bạn. Đây là những component giống các thư viện open source, thường được dùng đi dùng lại nhiều lần trong ứng dụng của bạn, không nhất thiết phải là một module lớn và không thực hiện các business logic. Những ví dụ về components dạng này như Button, Checkbox, SelectBox, Modal, DatePicker, BreadCrumb,…</p><h1 id="Dat-ten-cho-components"><a href="#Dat-ten-cho-components" class="headerlink" title="Đặt tên cho components"></a>Đặt tên cho components</h1><p>Ở phần trên chúng ta đã thấy được cách hệ thống files và folder trong ứng dụng, còn bây giờ sẽ tìm hiểu xem đặt tên components ra sao cho phù hợp.</p><p>Như đã đề cập ở trên, tên của components nên rõ ràng và không bị trùng lặp để có thể dễ tìm lại và tránh nhầm lẫn cho những thành viên khác trong team. Ngoài ra, tên components rõ ràng cũng giúp cho việc debug bằng những extension tools trở nên dễ dàng hơn trên trình duyệt (chẳng hạn như React Dev Tools) - vì khi app của bạn gặp lỗi khi đang chạy thì lỗi sẽ hiển thị ở đúng components xảy ra lỗi.</p><p>Để đặt tên components, chúng ta sẽ đặt theo hướng <em>path-based-component-naming</em>, nghĩa là cấu thành bởi đường dẫn từ folder src/components đến file chúng ta tạo component đó. Chẳng hạn, bạn có một file với đường dẫn <strong>src/components/User/List.jsx</strong> thì tên component được sử dụng trong <strong>List.jsx</strong> sẽ được đặt là <strong>UserList</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span></span><br></pre></td></tr></table></figure><p>Nếu một file trong folder trùng tên với tên folder, chúng ta sẽ không cần phải lặp lại cả tên folder lẫn tên file. Chẳng hạn, có một file <strong>src/components/User/Form/Form.jsx</strong> thì thay vì sử dụng <strong>UserFormForm</strong>, chúng ta sẽ đặt là UserForm.</p><p>Việc đặt tên components theo đường dẫn như trên có những ích lợi như sau:</p><ul><li><strong>Việc search file trong text editor/IDE trở nên thuận tiện hơn</strong> - Chỉ cần gõ vào ô search của IDE hay text editor mà bạn sử dụng là có thể tìm đến file một cách nhanh chóng. Hoặc navigate đến file cũng rất thuận tiện:</li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*DLndSrnMgIklk7tAhzgMWg.png" alt=""></p><ul><li><p><strong>Tránh lặp đi lặp lại tên khi import</strong> Theo cách đặt tên như vậy, bạn sẽ luôn đặt tên file giống với chức năng, nhiệm vụ của nó. Đối với component <strong>form</strong> ở trên, chính xác thì phải là <strong>user form</strong>, nhưng do file đã nằm trong folder <strong>User</strong> nên chúng ta không cần lặp lại từ đó trong tên file của component, mà chỉ cần sử dung <strong>Form.jsx</strong></p><p>Có nhiều trường hợp, dev viết app React và đặt tên file/folder cũng như tên component một cách đầy đủ, bao gồm cả tên module lớn và nhỏ, và dần dần sau này khi app scale lên thì việc đặt tên này sẽ trở nên phức tạp hơn rất nhiều. Thử so sánh hai trường hợp sau đây:</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ScreensUserForm <span class="keyword">from</span> <span class="string">'./screens/User/UserForm'</span>;</span><br><span class="line"><span class="comment">// vs</span></span><br><span class="line"><span class="keyword">import</span> ScreensUserForm <span class="keyword">from</span> <span class="string">'./screens/User/Form'</span>;</span><br></pre></td></tr></table></figure><p>Đối với module nhỏ với ít thành phần như trên thì cách đặt tên thứ hai có vẻ như không tạo nhiều khác biệt lắm, ta có thể thấy cách viết thứ nhất vẫn ổn. Tuy nhiên, nếu như app của bạn scale lên với nhiều thành phần, module, chức năng phức tạp thì việc đặt tên như vậy sẽ trở nenen vô cùng kinh khủng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MediaPlanViewChannel <span class="keyword">from</span> <span class="string">'/MediaPlan/MediaPlanView/MediaPlanViewChannel.jsx'</span>;</span><br><span class="line"><span class="comment">// vs</span></span><br><span class="line"><span class="keyword">import</span> MediaPlanViewChannel <span class="keyword">from</span> <span class="string">'./MediaPlan/View/Channel'</span>;</span><br></pre></td></tr></table></figure><p>Chưa kể những dòng như thế này còn lặp lại nhiều lần vì phải import nhiều thành phần cùng lúc…. Ví lí do đó, chúng ta nên đặt tên file và folder đúng với chức năng/nhiệm vụ trực tiếp của nó, thay vì thêm vào tên của những module cha. Còn tên component thì nên đặt theo đường dẫn tương đối so với folder src/components.</p><h1 id="Screens-components-Dung-cho-mot-view-page"><a href="#Screens-components-Dung-cho-mot-view-page" class="headerlink" title="Screens components - Dùng cho một view page"></a>Screens components - Dùng cho một view page</h1><p>Ở trên, bài viết có nhắc đến những compoents không được đặt trong folder components, được gọi là <em>screens</em>. Giống như tên gọi của nó, đây là những components tượng trưng cho một <em>màn hình</em> hiển thị trong ứng dụng của bạn Lấy ví dụ đối với tính năng CRUD users, chúng ta sẽ có những màn hình cơ bản nhất bao gồm:</p><ul><li>List users (/users</li><li>Create user (/user)</li><li>Edit user (/users/:id)</li></ul><p>Như vậy, chúng ta có 3 screens khác nhau. Mỗi screen là một component cấu thành lên một page trong ứng dụng react của bạn. Screen component nên là một presentational component và không nên thực hiện xử lý business logic.</p><p>Các screens sẽ nằm trong một folder screens song song với components trong đường dẫn src, vì mỗi component ở trong sẽ đại diện cho route của ứng dụng, thay vì một module nào đó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">    ├─ components </span><br><span class="line">    └─ screens</span><br><span class="line">      └─ User</span><br><span class="line">        ├─ Form.jsx</span><br><span class="line">        └─ List.jsx</span><br></pre></td></tr></table></figure><p>Nếu ứng dụng của bạn sử dụng react-router, chúng ta sẽ giữ một file Root.jsx trong folder screens và đưa toàn bộ các view route vào trong file này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Redirect, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ScreensUserForm <span class="keyword">from</span> <span class="string">'./User/Form'</span>;</span><br><span class="line"><span class="keyword">import</span> ScreensUserList <span class="keyword">from</span> <span class="string">'./User/List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ScreensRoot = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/user/list"</span> component=&#123;ScreensUserList&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/user/create"</span> component=&#123;ScreensUserForm&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/user/:id"</span> component=&#123;ScreensUserForm&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Router&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ScreensRoot;</span><br></pre></td></tr></table></figure><p>Với cách này chúng ta đã đưa toàn bộ screens vào trong một folder có cùng tên với định nghĩa route: user/ -&gt; User/. Folder User chứa màn hình List và màn hinh Form bên trong. Từ đó bạn có thể dễ dàng tìm thấy màn hình nào render route nào bằng cách nhìn vào url.</p><p>Một màn hình có thể sử dụng để render nhiều route, như chúng ta thấy màn hình Form sẽ render 2 route dành cho việc Create và Edit. Chú ý rằng, chúng ta nên thêm prefix Screen khi đặt tên cho các screen, để tránh nhầm lẫn với các component trong folder components.</p><p>Như vậy tên của screen component đặt trong folder src/screens/User/List.jsx nên được đặt là ScreenUserList:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> UserForm <span class="keyword">from</span> <span class="string">'../../components/User/Form/Form'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ScreensUserForm = <span class="function">(<span class="params">&#123; match: &#123; params &#125; &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      &#123;<span class="string">`<span class="subst">$&#123;!params.id ? <span class="string">'Create'</span> : <span class="string">'Update'</span>&#125;</span>`</span>&#125; User</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;UserForm id=&#123;params.id&#125; /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default ScreensUserForm;</span></span><br></pre></td></tr></table></figure><p>Như trong đoạn code trên thì screen component sẽ không xử lý gì liên quan đến state (data) mà chỉ thực hiện render ra component <em>UserForm</em>.</p><p>Cuối cùng thì chúng ta sẽ có được một cấu trúc folder như sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├─ components </span><br><span class="line">│  ├─ User</span><br><span class="line">│  │ ├─ Form</span><br><span class="line">│  │ │ ├─ Form.jsx</span><br><span class="line">│  │ │ └─ Form.css</span><br><span class="line">│  │ └─ List.jsx</span><br><span class="line">│  └─ UI </span><br><span class="line">│</span><br><span class="line">└─ screens</span><br><span class="line">  ├─ User</span><br><span class="line">  │ ├─ Form.jsx</span><br><span class="line">  │ └─ List.jsx</span><br><span class="line">  └─ Root.jsx</span><br></pre></td></tr></table></figure><h2 id="Tong-ket"><a href="#Tong-ket" class="headerlink" title="Tổng kết"></a>Tổng kết</h2><p>Tóm tắt lại, chúng ta cần nhớ những điểm sau đây:</p><ul><li><strong>Presentational</strong> và <strong>Container</strong> components được đặt trong folder src/components</li><li>Nhóm các components lại dựa trên module/feature</li><li>Đưa những component chung được sử dụng nhiều lần (UI components) vào trong src/components/UI</li><li>Viết component <strong>screens</strong> (màn hình) thật đơn giản, ít code</li><li>Nhóm các màn hình lại theo route của ứng dụng. Với route /user/list thì screen sẽ nằm trong src/screens/User/List.jsx.</li><li>Components được dặt tên theo đường dẫn tương đối của so với src/components hoặc src - Tên component trong file src/components/User/List.jx sẽ có tên là UserList, tên component trong file src/screens/User/List.jsx sẽ có tên là ScreensUserList.</li><li>Component trong file có cùng tên với folder chứa nó sẽ không lặp lại tên của folder. Ví dụ file src/components/User/List/List.jsx sẽ có component được đặt tên là UserList, chứ <strong>KHÔNG PHẢI</strong> là UserListList</li></ul><h1 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h1><p>Bài viết đã đưa ra một trong những cách để tổ chức, phân chia cũng như đặt tên cho file, folder và component khi thiết kế ứng dụng bằng React. Đương nhiên, đây chỉ là ý kiến chủ quan, bạn hoàn toàn có thể tự mình thiết lập và đưa ra những pattern mà bạn cảm thấy hợp lý, thuận tiện khi làm việc với React, miễn sao cho trải nghiệm của bản thân là tốt nhất. Xin cảm ơn!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Như bạn đã biết, React chỉ là một thư viện nên nó không chỉ rõ cho người dùng cách tổ chức, phân chia cấu trúc thư mục cho dự án của mình. Xét trên một khía cạnh, có thể điều này là tốt vì dev có thể thoải mái thử rất nhiều cách khác nhau để chọn ra phương pháp phù hợp với dự án của mình. Tuy nhiên, nó lại khiến cho những dev mới bắt đầu sử dụng React cảm thấy khó hiểu. Bài viết này sẽ đưa ra một vài phương pháp phân chia folders, files giúp cho ứng dụng React của bạn có thể mở rộng một cách thuận tiện, nhất là đối với những người mới bước chân vào React và không biết phải làm như thế nào cho hợp lý.&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://nthung2112.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Gooact: React trong 160 dòng code JavaScript</title>
    <link href="http://nthung2112.github.io/2018/05/Gooact-React-trong-160-dong-code-JavaScript.html"/>
    <id>http://nthung2112.github.io/2018/05/Gooact-React-trong-160-dong-code-JavaScript.html</id>
    <published>2018-05-26T08:13:00.000Z</published>
    <updated>2018-05-26T13:12:23.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lam-the-nao-de-xay-dung-React-cho-rieng-minh-chi-trong-vai-phut"><a href="#Lam-the-nao-de-xay-dung-React-cho-rieng-minh-chi-trong-vai-phut" class="headerlink" title="Làm thế nào để xây dựng React cho riêng mình chỉ trong vài phút."></a>Làm thế nào để xây dựng React cho riêng mình chỉ trong vài phút.</h2><h3 id="Gioi-thieu"><a href="#Gioi-thieu" class="headerlink" title="Giới thiệu"></a><strong>Giới thiệu</strong></h3><p><a href="https://reactjs.org" target="_blank" rel="noopener"><strong>React</strong></a> là một thư viện tuyệt vời - nhiều nhà phát triển ngay lập tức đã yêu thích nó vì tính đơn giản, hiệu suất và cách khai báo làm việc. Nhưng cá nhân tôi có một lý do cụ thể khiến nó trở nên đặc biệt đối với tôi - và đó là cách nó hoạt động bên dưới. Tôi tìm thấy những ý tưởng đứng đằng sau React đơn giản nhưng kỳ lạ thú vị - và tôi tin rằng sự hiểu biết nguyên tắc cốt lõi của nó sẽ giúp bạn viết mã nhanh hơn và an toàn hơn.</p><p>Trong bài viết này, tôi sẽ chỉ cho cho bạn cách viết một bản sao của React đầy đủ chức năng, bao gồm Component API và tự triển khai Virtual DOM. Nó được chia thành bốn phần - mỗi phần là một chủ đề chính:</p><ul><li><strong>Elements</strong>: Trong phần này chúng ta sẽ tìm hiểu cách các khối JSX được xử lý thành phiên bản nhẹ của DOM được gọi là VDOM như thế nào.</li><li><strong>Rendering</strong>: Trong phần này tôi sẽ hướng dẫn bạn cách chuyển đổi VDOM thành DOM thông thường.</li><li><strong>Patching</strong>: Trong phần này tôi sẽ trình bày lý do tại sao thuộc tính “key” quan trọng như thế và cách sử dụng VDOM để nối lại với DOM hiện tại một cách hiệu quả.</li><li><strong>Components:</strong> Phần cuối cùng sẽ cho bạn biết về các thành phần React và quy trình tạo, vòng đời và dựng hình của chúng.</li></ul><p>Mỗi phần sẽ kết thúc bằng một ví dụ có link <strong>CodePen</strong> trực tiếp, vì vậy bạn có thể ngay lập tức kiểm tra tất cả các tiến trình chúng ta đã thực hiện. Bắt đầu nào.</p><h3 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a><strong>Elements</strong></h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*KQcMpRQeOW0sdc0wYrwSrw.png" alt=""></p><p><a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html#elements-describe-the-tree" target="_blank" rel="noopener"><strong>Element</strong></a> là một đối tượng trọng lượng nhẹ của một DOM thực tế. Nó chứa tất cả thông tin quan trọng - như node type, attributes và danh sách children —  vì vậy nó có thể dễ dàng rendered trong tương lai. Thành phần giống như cây của các elements được gọi là VDOM - một ví dụ được hiển thị bên dưới:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"ul"</span>,</span><br><span class="line">    <span class="string">"props"</span>: &#123;</span><br><span class="line">        <span class="string">"className"</span>: <span class="string">"some-list"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"children"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"li"</span>,</span><br><span class="line">            <span class="string">"props"</span>: &#123;</span><br><span class="line">                <span class="string">"className"</span>: <span class="string">"some-list__item"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"children"</span>: [</span><br><span class="line">                <span class="string">"One"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"li"</span>,</span><br><span class="line">            <span class="string">"props"</span>: &#123;</span><br><span class="line">                <span class="string">"className"</span>: <span class="string">"some-list__item"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"children"</span>: [</span><br><span class="line">                <span class="string">"Two"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thay vì viết object quái dị đó mọi lúc, hầu hết các nhà phát triển React đều sử dụng cú pháp JSX, trông giống như một sự kết hợp gọn gàng giữa mã JavaScript và các thẻ HTML:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** @jsx createElement */</span><br><span class="line">const list = <span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">"some-list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">"some-list__item"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">"some-list__item"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span>;</span><br></pre></td></tr></table></figure><p>In order to get executed it needs to be transpiled into regular function calls — notice that pragma comment which defines what function must be used:<br>Để được thực hiện, nó cần phải được chuyển thành các gọi hàm thông thường - chú ý comment pragma là phải luôn sử dụng:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = createElement(<span class="string">'ul'</span>, &#123;<span class="attr">className</span>: <span class="string">'some-list'</span>&#125;,</span><br><span class="line">    createElement(<span class="string">'li'</span>, &#123;<span class="attr">className</span>: <span class="string">'some-list__item'</span>&#125;, <span class="string">'One'</span>),</span><br><span class="line">    createElement(<span class="string">'li'</span>, &#123;<span class="attr">className</span>: <span class="string">'some-list__item'</span>&#125;, <span class="string">'Two'</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Cuối cùng, function mong muốn được gọi - và nó được cho là trả về cấu trúc VDOM được mô tả ở trên. Việc triển khai của chúng tôi sẽ ngắn gọn - nhưng mặc dù có vẻ nguyên thủy, nó phục vụ mục đích cần một cách hoàn hảo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createElement = <span class="function">(<span class="params">type, props, ...children</span>) =&gt;</span> &#123;</span><br><span class="line">    props = props != <span class="literal">null</span> ? props : &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;type, props, children&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CodePen đầu tiên có sẵn <a href="https://codepen.io/SweetPalma/pen/gzpZNv?editors=0010" target="_blank" rel="noopener"><strong>ở đây</strong></a>— nó chứa phương pháp được mô tả ở trên với một vài cây VDOM do nó tạo ra.</p><h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*Wc-kOHkiu41Rc69-cG9KhA.png" alt=""></p><p><a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener"><strong>Rendering</strong></a> là một quá trình biến VDOM thành DOM hiển thị. Nói chung, nó là một thuật toán khá đơn giản mà đi qua cây VDOM và tạo ra phần tử DOM tương ứng cho mỗi node:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> render = <span class="function">(<span class="params">vdom, parent=<span class="literal">null</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent) parent.textContent = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">const</span> mount = parent ? (<span class="function"><span class="params">el</span> =&gt;</span> parent.appendChild(el)) : (<span class="function"><span class="params">el</span> =&gt;</span> el);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'string'</span> || <span class="keyword">typeof</span> vdom == <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mount(<span class="built_in">document</span>.createTextNode(vdom));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'boolean'</span> || vdom === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mount(<span class="built_in">document</span>.createTextNode(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> vdom.type == <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mount(Component.render(vdom));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> vdom.type == <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(vdom.type);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> [].concat(...vdom.children)) <span class="comment">// flatten</span></span><br><span class="line">            dom.appendChild(render(child));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> vdom.props)</span><br><span class="line">            setAttribute(dom, prop, vdom.props[prop]);</span><br><span class="line">        <span class="keyword">return</span> mount(dom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid VDOM: <span class="subst">$&#123;vdom&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setAttribute = <span class="function">(<span class="params">dom, key, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value == <span class="string">'function'</span> &amp;&amp; key.startsWith(<span class="string">'on'</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> eventType = key.slice(<span class="number">2</span>).toLowerCase();</span><br><span class="line">        dom.__gooactHandlers = dom.__gooactHandlers || &#123;&#125;;</span><br><span class="line">        dom.removeEventListener(eventType, dom.__gooactHandlers[eventType]);</span><br><span class="line">        dom.__gooactHandlers[eventType] = value;</span><br><span class="line">        dom.addEventListener(eventType, dom.__gooactHandlers[eventType]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">'checked'</span> || key == <span class="string">'value'</span> || key == <span class="string">'id'</span>) &#123;</span><br><span class="line">        dom[key] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">'key'</span>) &#123;</span><br><span class="line">        dom.__gooactKey = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> value != <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> value != <span class="string">'function'</span>) &#123;</span><br><span class="line">        dom.setAttribute(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Code ở trên có vẻ trông đáng sợ, nhưng hãy làm cho mọi thứ trở nên ít phức tạp hơn bằng cách tách nó thành các phần nhỏ hơn:</p><ul><li><strong>Custom Attribute Setter</strong>: Các thuộc tính được chuyển đến VDOM không phải lúc nào cũng hợp lệ về DOM - những thứ như trình xử lý sự kiện, key định danh và các giá trị phải được xử lý riêng lẻ.</li><li><strong>Primitive VDOM rendering:</strong> Primitives — như strings, numbers, booleans và nulls — được chuyển thành các node văn bản thuần túy.</li><li><strong>Complex VDOM rendering:</strong> Nodes với tag string được biến thành các phần tử DOM với hiển thị children theo đệ quy.</li><li><strong>Component VDOM rendering</strong>: Nodes với tag function tag được xử lý riêng — không chú ý nhiều đến phần đó, chúng ta sẽ thực hiện nó sau.</li></ul><p>CodePen thứ hai có sẵn <a href="https://codepen.io/SweetPalma/pen/ZoGwWY?editors=0010" target="_blank" rel="noopener"><strong>ở đây</strong></a>— nó thể hiện thuật toán render trong hành động.</p><h3 id="Patching"><a href="#Patching" class="headerlink" title="Patching"></a>Patching</h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*2IcfCputh--ch7rTVLCmcw.png" alt=""></p><p><a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener"><strong>Patching</strong></a> là một quá trình hòa hợp DOM hiện có với cây VDOM mới được xây dựng.</p><p>Hãy tưởng tượng bạn có một số VDOM lồng nhau sâu và cập nhật thường xuyên. Khi một cái gì đó thay đổi, ngay cả phần nhỏ nhất - mà phải được hiển thị. Triển khai native sẽ yêu cầu render toàn bộ mỗi lần cập nhật như vậy.</p><ul><li>Xóa các nút DOM hiện có.</li><li>Re-render mọi thứ.</li></ul><p>Đó là lý do thực tế — xây dựng DOM và vẽ lại nó là một hoạt động khá tốn kém. Nhưng chúng ta có thể tối ưu hóa điều này bằng cách viết thuật toán và sẽ yêu cầu ít sửa đổi DOM:</p><ul><li>Xây dựng một VDOM mới.</li><li>Đệ quy so sánh nó với DOM hiện có.</li><li>Tìm các nút đã được thêm, xóa hoặc thay đổi theo bất kỳ cách nào.</li><li>Patch(Vá) chúng lại.</li></ul><p>Nhưng sau đó một vấn đề khác nổi lên — độ phức tạp tính toán. So sánh hai cây có độ phức tạp O(n³) — ví dụ: nếu bạn định patch một ngìn elements — nó sẽ yêu cầu <em>một tỷ</em> so sánh. Điều đó là quá nhìu. Thay vào đó, chúng ta sẽ triển khai một thuật toán độ phức tạp O(n) với hai giả định sau:</p><ul><li>Hai elements của các loại khác nhau sẽ tạo ra những cây khác nhau.</li><li>Nhà phát triển có thể gợi ý các phần tử con nào có thể không đổi qua các lần render khác nhau với prop “key”.</li></ul><p>Trong thực tế, các giả định này có giá trị đối với hầu hết các trường hợp sử dụng thực tế. Bây giờ chúng tôi đã sẵn sàng cho một phần code khác:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patch = <span class="function">(<span class="params">dom, vdom, parent=dom.parentNode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> replace = parent ? <span class="function"><span class="params">el</span> =&gt;</span> (parent.replaceChild(el, dom) &amp;&amp; el) : (<span class="function"><span class="params">el</span> =&gt;</span> el);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> vdom.type == <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Component.patch(dom, vdom, parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom != <span class="string">'object'</span> &amp;&amp; dom <span class="keyword">instanceof</span> Text) &#123;</span><br><span class="line">        <span class="keyword">return</span> dom.textContent != vdom ? replace(render(vdom)) : dom;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'object'</span> &amp;&amp; dom <span class="keyword">instanceof</span> Text) &#123;</span><br><span class="line">        <span class="keyword">return</span> replace(render(vdom));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'object'</span> &amp;&amp; dom.nodeName != vdom.type.toUpperCase()) &#123;</span><br><span class="line">        <span class="keyword">return</span> replace(render(vdom));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vdom == <span class="string">'object'</span> &amp;&amp; dom.nodeName == vdom.type.toUpperCase()) &#123;</span><br><span class="line">        <span class="keyword">const</span> pool = &#123;&#125;;</span><br><span class="line">        <span class="keyword">const</span> active = <span class="built_in">document</span>.activeElement;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> index <span class="keyword">in</span> <span class="built_in">Array</span>.from(dom.childNodes)) &#123;</span><br><span class="line">            <span class="keyword">const</span> child = dom.childNodes[index];</span><br><span class="line">            <span class="keyword">const</span> key = child.__gooactKey || index;</span><br><span class="line">            pool[key] = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> vchildren = [].concat(...vdom.children); <span class="comment">// flatten</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> index <span class="keyword">in</span> vchildren) &#123;</span><br><span class="line">            <span class="keyword">const</span> child = vchildren[index];</span><br><span class="line">            <span class="keyword">const</span> key = child.props &amp;&amp; child.props.key || index;</span><br><span class="line">            dom.appendChild(pool[key] ? patch(pool[key], child) : render(child));</span><br><span class="line">            <span class="keyword">delete</span> pool[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> pool) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pool[key].__gooactInstance)</span><br><span class="line">                pool[key].__gooactInstance.componentWillUnmount();</span><br><span class="line">            pool[key].remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> attr <span class="keyword">of</span> dom.attributes) dom.removeAttribute(attr.name);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> vdom.props) setAttribute(dom, prop, vdom.props[prop]);</span><br><span class="line">        active.focus();</span><br><span class="line">        <span class="keyword">return</span> dom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Hãy điều tra tất cả các kết hợp có thể:</p><ul><li><strong>Primitive VDOM + Text DOM:</strong> So sánh giá trị VDOM với nội dung DOM và thực hiện full render nếu chúng khác nhau.</li><li><strong>Primitive VDOM + Element DOM :</strong> Full render.</li><li><strong>Complex VDOM + Text DOM :</strong> Full render.</li><li><strong>Complex VDOM + Element DOM of different type :</strong> Full render.</li><li><strong>Complex VDOM + Element DOM of same type :</strong> Sự kết hợp thú vị nhất, nơi diễn ra sự hòa hợp của children, xem chi tiết bên dưới.</li><li><strong>Component VDOM + any kind of DOM:</strong> Cũng giống như trong phần trước, được xử lý riêng và sẽ được triển khai sau.</li></ul><p>Như bạn có thể thấy, các nút text và phức tạp nói chung không tương thích và yêu cầu full render — may mắn thay đó là một sự thay đổi hiếm hoi. Nhưng những gì về sự hòa hợp của children đệ quy - nó thực hiện như sau:</p><ul><li>Current active element is memoized — reconciliation may break focus sometimes.</li><li>DOM children are moved into temporary pool under their respective keys — index is used as a key by default.</li><li>VDOM children are paired to the pool DOM nodes by key and recursively patched — or rendered from scratch if pair is not found.</li><li>DOM nodes that left unpaired are removed from document.</li><li>New attributes are applied to final parent DOM.</li><li>Focus is returned back to previously active element.</li></ul><p>CodePen thứ ba có sẵn <a href="https://codepen.io/SweetPalma/pen/rvOWxa?editors=0010" target="_blank" rel="noopener"><strong>ở đây</strong></a> — bao gồm ví dụ nhỏ về list patching.</p><h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*wOrDURrPrNvH3eKeaQuyQQ.png" alt=""></p><p><a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener"><strong>Component</strong></a> về mặt khái niệm tương tự như hàm JavaScript — nó có đầu vào tùy ý được gọi là “props” và trả về tập các elements mô tả những gì sẽ xuất hiện trên màn hình. Nó có thể được định nghĩa là một stateless function hoặc derived class với trạng thái bên trong của riêng và tập các phương thức và các lifecycle hooks. Tôi sẽ ngắn gọn về lý thuyết - tốt hơn hãy xem code:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">this</span>.props = props || &#123;&#125;;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> render(vdom, parent=<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, vdom.props, &#123;<span class="attr">children</span>: vdom.children&#125;);</span><br><span class="line">        <span class="keyword">if</span> (Component.isPrototypeOf(vdom.type)) &#123;</span><br><span class="line">            <span class="keyword">const</span> instance = <span class="keyword">new</span> (vdom.type)(props);</span><br><span class="line">            instance.componentWillMount();</span><br><span class="line">            instance.base = render(instance.render(), parent);</span><br><span class="line">            instance.base.__gooactInstance = instance;</span><br><span class="line">            instance.base.__gooactKey = vdom.props.key;</span><br><span class="line">            instance.componentDidMount();</span><br><span class="line">            <span class="keyword">return</span> instance.base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> render(vdom.type(props), parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> patch(dom, vdom, parent=dom.parentNode) &#123;</span><br><span class="line">        <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, vdom.props, &#123;<span class="attr">children</span>: vdom.children&#125;);</span><br><span class="line">        <span class="keyword">if</span> (dom.__gooactInstance &amp;&amp; dom.__gooactInstance.constructor == vdom.type) &#123;</span><br><span class="line">            dom.__gooactInstance.componentWillReceiveProps(props);</span><br><span class="line">            dom.__gooactInstance.props = props;</span><br><span class="line">            <span class="keyword">return</span> patch(dom, dom.__gooactInstance.render());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Component.isPrototypeOf(vdom.type)) &#123;</span><br><span class="line">            <span class="keyword">const</span> ndom = Component.render(vdom);</span><br><span class="line">            <span class="keyword">return</span> parent ? (parent.replaceChild(ndom, dom) &amp;&amp; ndom) : (ndom);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Component.isPrototypeOf(vdom.type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> patch(dom, vdom.type(props));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(nextState) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.base &amp;&amp; <span class="keyword">this</span>.shouldComponentUpdate(<span class="keyword">this</span>.props, nextState)) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevState = <span class="keyword">this</span>.state;</span><br><span class="line">            <span class="keyword">this</span>.componentWillUpdate(<span class="keyword">this</span>.props, nextState);</span><br><span class="line">            <span class="keyword">this</span>.state = nextState;</span><br><span class="line">            patch(<span class="keyword">this</span>.base, <span class="keyword">this</span>.render());</span><br><span class="line">            <span class="keyword">this</span>.componentDidUpdate(<span class="keyword">this</span>.props, prevState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.state = nextState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextProps != <span class="keyword">this</span>.props || nextState != <span class="keyword">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Các static methods được gọi internally:</p><ul><li><strong>Render</strong>: Performs initial rendering. Stateless components are called as a regular function — result is displayed immediately. Class components are instantiated and attached to the DOM — and only then are rendered.</li><li><strong>Patching:</strong> Performs further update. Sometimes DOM node already has a component instance attached to it — pass new properties to it and patch differences. Perform full render otherwise.</li></ul><p>Các Instance methods có nghĩa là có thể bị ghi đè hoặc được gọi trong các derived classes do người dùng định nghĩa:</p><ul><li><strong>Constructor:</strong> Handles properties and defines initial state, storing them within itself.</li><li><strong>State modifier:</strong> Handles new state, fires all required lifecycle hooks and initiates patch cycle.</li><li><strong>Lifecycle hooks:</strong> Set of methods that are fired throughout component life — on mount, during updates and just before it gets removed.</li></ul><p>Lưu ý rằng phương thức render bị thiếu — nó được định nghĩa trong các child classes. CodePen cuối cùng có <a href="https://codepen.io/SweetPalma/pen/gzavjB?editors=0010" target="_blank" rel="noopener"><strong>ở đây</strong></a> — với tất cả các code chúng tôi đã thực hiện cho đến đây cùng với một ví dụ to-do đơn giản.</p><h3 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h3><p>Đó là tất cả của tôi — chúng ta có một bản sao React đầy đủ chức năng ngay bây giờ. Tôi sẽ gọi nó là Gooact — đó sẽ là một món quà nhỏ cho người bạn tốt của tôi. Chúng ta hãy xem xét kỹ hơn các kết quả:</p><ul><li>Gooact có thể xây dựng và patch hiệu quả các cây DOM phức tạp bằng cách sử dụng VDOM làm tham chiếu.</li><li>Gooact hỗ trợ cả hai functional và class components — cùng với việc xử lý chính xác internal state và hooks lifecycle hoàn chỉnh.</li><li>Gooact dùng  transpiled code cung cấp bởi Babel.</li><li>Gooact vừa đủ trong 160 dòng code JavaScript chưa nén.</li></ul><p>Mục đích chính của bài viết này là để chứng minh các nguyên tắc cốt lõi của cấu trúc bên trong React mà không cần phải đi sâu vào các API phụ trợ - đó là lý do tại sao chúng bị thiếu một số thứ sau trong Gooact:</p><ul><li>Gooact không hỗ trợ những thứ như fragments, portals, contexts, references và một số thứ khác đã được giới thiệu trong các phiên bản mới hơn.</li><li>Gooact không triển khai React Fiber do sự phức tạp của nó — nhưng tôi có thể viết một bài về nó trong tương lai.</li><li>Gooact không theo dõi các key trùng lặp và đôi khi có thể gây ra lỗi.</li><li>Gooact thiếu hỗ trợ callbacks thêm cho một số methods.</li></ul><p>Như bạn có thể thấy, đó là một lĩnh vực tuyệt vời cho các tính năng và cải tiến mới - repository có sẵn <a href="https://github.com/sweetpalma/gooact" target="_blank" rel="noopener"><strong>ở đây</strong></a>, do đó, vì vậy đừng ngần ngại fork và thử nghiệm. Bạn thậm chí có thể cài đặt nó bằng cách sử dụng NPM!</p><p>Tôi muốn cảm ơn toàn bộ <a href="https://github.com/facebook/react/blob/master/AUTHORS" target="_blank" rel="noopener"><strong>React Team</strong></a> đã tạo một thư viện tuyệt vời, làm cho cuộc sống của hàng nghìn nhà phát triển trở nên dễ dàng hơn. Đặc biệt cảm ơn đến <a href="https://github.com/developit/preact" target="_blank" rel="noopener"><strong>Preact</strong></a> tác giả chính là <a href="https://twitter.com/_developit" target="_blank" rel="noopener"><strong>Jason Miller</strong></a> — bài viết này đã được lấy cảm hứng từ cách tối giản nó được thực hiện.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Ok_UbUJOtYxN08pFNHMwMQ.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lam-the-nao-de-xay-dung-React-cho-rieng-minh-chi-trong-vai-phut&quot;&gt;&lt;a href=&quot;#Lam-the-nao-de-xay-dung-React-cho-rieng-minh-chi-trong-va
      
    
    </summary>
    
    
      <category term="react" scheme="http://nthung2112.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Cơ chế sử dụng Virtual DOM trong React</title>
    <link href="http://nthung2112.github.io/2018/05/Co-che-su-dung-Virtual-DOM-trong-React.html"/>
    <id>http://nthung2112.github.io/2018/05/Co-che-su-dung-Virtual-DOM-trong-React.html</id>
    <published>2018-05-25T15:22:00.000Z</published>
    <updated>2018-05-25T15:35:20.184Z</updated>
    
    <content type="html"><![CDATA[<p>Khi tìm hiểu về ReactJS, chắc hẳn bạn đã nghe tới khái niệm DOM ảo (Virtual DOM). Nó giúp cho hiệu suất làm việc của React cao hơn hẳn so với các thư viện và framework Javascript khác. Nhưng bạn đã bao giờ tìm hiểu DOM ảo là gì và nó hoạt động như thế nào trong React? Hôm nay, chúng ta cùng tìm hiểu về chủ đề này nhé.<br><a id="more"></a></p><h2 id="Virtual-DOM-la-gi"><a href="#Virtual-DOM-la-gi" class="headerlink" title="Virtual DOM là gì?"></a><strong>Virtual DOM là gì?</strong></h2><p>Điều đầu tiên tôi muốn nói ở đây là: Virtual DOM không được phát minh ra bởi React, mà React sử dụng nó. DOM ảo là một bản sao chép trừu tượng của DOM thật (HTML DOM). Bạn có thể tưởng tượng nó giống như một bản thiết kế, chứa các chi tiết cần thiết để cấu hình lên một DOM. Ví dụ, thay vì tạo một thẻ <code>&lt;div&gt;</code> thật chứa các thẻ <code>&lt;ul&gt;</code> bên trong, nó sẽ tạo một div object chứa <code>ul</code> object bên trong. Cụ thể ở trong React sẽ là các <code>React.div</code> và <code>React.ul</code>. Khi tương tác, ta có thể tương tác với các object đó rất nhanh mà không phải động tới DOM thật hoặc thông qua DOM API. Tiếp theo chúng ta sẽ tìm hiểu cụ thể React tương tác với DOM ảo như thế nào nhé</p><h2 id="Virtual-DOM-trong-React"><a href="#Virtual-DOM-trong-React" class="headerlink" title="Virtual DOM trong React"></a><strong>Virtual DOM trong React</strong></h2><p>Trước tiên, đã bao giờ bạn tự hỏi tại sao lại phải tương tác thông qua DOM ảo, sao không render trực tiếp ở DOM thật? Vậy bạn đã thực sự hiểu rõ DOM được tạo và re-render như thế nào mỗi khi các thành phần trong DOM thay đổi?</p><p><img src="https://cdn-images-1.medium.com/max/800/1*ZrzXoRljG5Co5KvEsWJNjA.png" alt=""></p><p>Mỗi khi có sự thay đổi, vì cấu trúc của DOM là <strong>tree structure</strong> , khi muốn thay đổi các element và các thẻ con của nó, nó phải thông qua các <strong>Reflow/Layout</strong>, sau đó các thay đổi đó sẽ được Re-painted, rất mất thời gian. Vì thế, càng nhiều các item phải <strong>reflow/repaint</strong>, web của bạn sẽ càng load chậm. Vậy React đã sử dụng DOM ảo như thế nào? Để một trang lớn như Facebook mà chúng ta dùng hàng ngày có hiệu suất làm việc cao như vậy? Để dễ hình dung, chúng ta sẽ tìm hiểu thông qua một ví dụ nho nhỏ dưới đây nhé.</p><p><img src="https://cdn-images-1.medium.com/max/800/1*QX2kUf7GoCkTNkTWBUfX-g.png" alt=""></p><p>Đó là giao diện của một app cộng hoặc trừ 2 số. Người dùng sẽ nhập vào 2 số vào 2 ô input, sau đó chọn phép toán và in ra kết quả ở phần Output.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">output</span>: <span class="string">''</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> IntegerA, IntegerB, IntegerC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">        &lt;h2&gt;using React&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          Input 1:</span></span><br><span class="line"><span class="regexp">          &lt;input type="text" placeholder="Input 1" ref="input1" /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          Input 2 :</span></span><br><span class="line"><span class="regexp">          &lt;input type="text" placeholder="Input 2" ref="input2" /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button</span></span><br><span class="line"><span class="regexp">            id="add"</span></span><br><span class="line"><span class="regexp">            onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">              IntegerA = parseInt(this.refs.input1.value);</span></span><br><span class="line"><span class="regexp">              IntegerB = parseInt(this.refs.input2.value);</span></span><br><span class="line"><span class="regexp">              IntegerC = IntegerA + IntegerB;</span></span><br><span class="line"><span class="regexp">              this.setState(&#123; output: IntegerC &#125;);</span></span><br><span class="line"><span class="regexp">            &#125;&#125;</span></span><br><span class="line"><span class="regexp">          &gt;</span></span><br><span class="line"><span class="regexp">            Add</span></span><br><span class="line"><span class="regexp">          &lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">          &lt;button</span><br><span class="line">            id=<span class="string">"subtract"</span></span><br><span class="line">            onClick=&#123;() =&gt; &#123;</span><br><span class="line">              IntegerA = <span class="built_in">parseInt</span>(<span class="keyword">this</span>.refs.input1.value);</span><br><span class="line">              IntegerB = <span class="built_in">parseInt</span>(<span class="keyword">this</span>.refs.input2.value);</span><br><span class="line">              IntegerC = IntegerA - IntegerB;</span><br><span class="line">              <span class="keyword">this</span>.setState(&#123; <span class="attr">output</span>: IntegerC &#125;);</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            Subtract</span><br><span class="line">          &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;hr /&gt;</span><br><span class="line">          &lt;h2&gt;Output: &#123;<span class="keyword">this</span>.state.output&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">import React, &#123; Component &#125; from 'react';</span></span><br><span class="line"><span class="regexp">import Calculator from './</span>Calculator<span class="string">';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default class Layout extends Component &#123;</span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;Basic Calculator&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;Calculator /&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>Và đây là DOM thật sau lần load đầu tiên</p><p><img src="https://cdn-images-1.medium.com/max/800/1*UeJO46kqBIm0Z8j9B8G6kw.png" alt="How DOM looks after initial rendering"></p><p>Còn đây là DOM ảo mà React tạo ra tương ứng với DOM thật bên trên. Trong React, nó cũng được gọi là một Component với <strong>tree structure</strong> gồm các Component con bên trong</p><p><img src="https://cdn-images-1.medium.com/max/800/1*WMkI8W__gUagZEVCUN37Pg.png" alt="Component Tree structure build by React"></p><p>Sau đây, chúng ta sẽ cùng thử nhập vào 2 số và click vào button Add và xem React xử lí như thế nào nhé.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input 1: 100</span><br><span class="line">Input 2: 50</span><br><span class="line"></span><br><span class="line">Output mong đợi sẽ là 150.</span><br></pre></td></tr></table></figure><p>Điều gì xảy ra khi ta click vào button Add? Ở ví dụ này, chúng ta set <strong>output</strong> là một <strong>state</strong>, vì thế khi một <strong>output</strong> mới được hiện ra nghĩa là ta đã set cho <strong>State</strong> đó một giá trị mới đó là 150.</p><h3 id="Danh-dau-Component-dirty"><a href="#Danh-dau-Component-dirty" class="headerlink" title="Đánh dấu Component dirty"></a>Đánh dấu Component dirty</h3><p><img src="https://cdn-images-1.medium.com/max/600/1*SBXiC6G3cjT5deW1tR0C4w.png" alt="Calculator component marked Dirty"></p><p>Trong React, khi một Component có một <strong>state</strong> mới được set, React đánh dấu nó như là một <strong>dirty Component</strong>, nghĩa là mỗi khi chúng ta gọi tới function <em>setState()</em> thì Component đó sẽ được đánh dấu là <strong>dirty</strong>. Cụ thể ở đây, khi ta click Add, React sẽ đánh dấu Component <strong>Calculator</strong> như thế nào:</p><ol><li>Tất cả các event khi ta thao tác với DOM, nó được gói trọn trong <strong>React event listener</strong>. Vì thế khi nút Add được click, event đó được gửi tới <strong>React event listener</strong> và sau đó nó sẽ chạy một <em>anonymous function</em>()</li><li>Trong <em>anonymous function()</em>, chúng ta gọi tới function <em>this.setState</em> với một <strong>state</strong> value mới.</li><li>Function <em>this.setState</em>() được chạy, Component <strong>Calculator</strong> được đánh dấu là <strong>dirty</strong>.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReactUpdates.js  - enqueueUpdate(component) function</span></span><br><span class="line">dirtyComponents.push(component);</span><br></pre></td></tr></table></figure><ol><li>Và hiện tại, Calculator của chúng ta đã được đánh dấu là <strong>dirty</strong>. Cùng xem những gì sẽ diễn ra tiếp theo</li></ol><h3 id="Chay-qua-Component-lifecycle"><a href="#Chay-qua-Component-lifecycle" class="headerlink" title="Chạy qua Component lifecycle"></a>Chạy qua Component lifecycle</h3><p><a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">Component lifecycle</a> trong React là một loạt các hàm mặc định sẽ được chạy ngay trước, trong và ngay sau quá trình update một Component. Ở ví dụ này, chúng ta không overwrite các hàm đó thì nó sẽ chạy ở các giá trị mặc định.</p><p><img src="https://cdn-images-1.medium.com/max/800/1*HmOs3RG_uYsneZFHnrmYEA.png" alt=""></p><p>Quá trình update Component được diễn ra như sau:</p><ol><li>React sẽ kiểm tra Component đó có được mark <strong>dirty</strong> hay không, sau đó bắt đầu quá trình update.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReactUpdates.js</span></span><br><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (dirtyComponents.length || asapEnqueued) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirtyComponents.length) &#123;</span><br><span class="line">      <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, <span class="literal">null</span>, transaction);</span><br></pre></td></tr></table></figure><ol><li>Sau đó, React sẽ kiểm tra xem có <strong>pending state</strong> nào phải được update hay không hoặc có <strong>forceUpdate</strong> nào không</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>._pendingStateQueue !== <span class="literal">null</span> || <span class="keyword">this</span>._pendingForceUpdate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateComponent(transaction, <span class="keyword">this</span>._currentElement, </span><br><span class="line">      <span class="keyword">this</span>._currentElement, <span class="keyword">this</span>._context, <span class="keyword">this</span>._context);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/600/1*UVixYuczWFlNJ7tbM4TAsg.png" alt=""></p><p>Trong ví dụ này của chúng ta, trong Calculator wrapper, <strong>this.pendingStateQueue,</strong> chứa State object với giá trị Output mới 3. React chạy các lifecycle methods. Đầu tiên là <em>componentWillReceiveProps</em>(), tiếp đó là <em>shouldComponentUpdate()</em> (các phương thức này có giá trị mặc định thế nào nếu chúng ta không overwrite nó thì các bạn tự tìm hiểu nhé). Trong trường hợp này, method <em>shouldComponentUpdate()</em> sẽ trả về <em>true</em>, sau đó sẽ chạy <em>componentWillUpdate(), render()</em> và <em>componentDidUpdate()</em>. Thứ quan trọng nhất trong quá trình update ở đấy chính là <em>render()</em>, đó chính là chỗ mà DOM ảo được tạo lại và update DOM ảo để tìm ra sự khác biệt để sau đó cập nhật ở DOM thật, hay nói các khác là tìm ra cụ thể những element thay đổi để update chỉ những element đó trong DOM thật.</p><h3 id="Xay-dung-lai-Component-Update-DOM-ao-tim-su-thay-doi-update-DOM-that"><a href="#Xay-dung-lai-Component-Update-DOM-ao-tim-su-thay-doi-update-DOM-that" class="headerlink" title="Xây dựng lại Component, Update DOM ảo, tìm sự thay đổi, update DOM thật"></a>Xây dựng lại Component, Update DOM ảo, tìm sự thay đổi, update DOM thật</h3><p><img src="https://cdn-images-1.medium.com/max/800/1*9paXIsNMjkuN4iBdpJ-MXg.png" alt=""></p><p>React sẽ kiểm tra các element trước và sau khi được render lại ở lần vừa rồi có giống nhau hay không, sau đó bắt đầu quá trình đồng bộ.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prevRenderedElement = <span class="keyword">this</span>._renderedComponent._currentElement;</span><br><span class="line"> <span class="keyword">var</span> nextRenderedElement = <span class="keyword">this</span>._instance.render(); <span class="comment">//Calculator.render() method is called and the element is build.</span></span><br></pre></td></tr></table></figure><p>Quá trình đồng bộ và update DOM thật như sau: </p><p><img src="https://cdn-images-1.medium.com/max/800/1*chzMjpfd821rcHntjWb8rQ.png" alt=""></p><p>Những điểm màu đỏ nghĩa là quá trình đồng bộ sẽ được lặp lại đối với những thành phần con của nó. Và đây là DOM mà chúng ta nhận được sau quá trình đó :</p><p><img src="https://cdn-images-1.medium.com/max/600/1*l2w9vcsBN7wd2UqZ7qZTHA.png" alt=""></p><p>Trong ví dụ này, chỉ có phần Output bị thay đổi, bạn có thể nhìn thấy phần được đánh dấu flash ở hình dưới, chỉ có phần đó được DOM thật re-painted </p><p><img src="https://cdn-images-1.medium.com/max/800/1*-N2b8UJgqIUtgUfPLWtQQw.png" alt=""></p><p>Và cây component được cập nhật tại DOM thực tế.</p><p><img src="https://cdn-images-1.medium.com/max/800/1*xvjOyXVne-7Y0ch0dRTIdw.png" alt=""></p><h2 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a><strong>Kết luận</strong></h2><p>Qua ví dụ trên mong là bạn có thể hình dung phần nào đó cách thực hoạt động của DOM ảo trong React và tính hữu dụng của nó. Nhờ có DOM ảo, React có thể tìm ra các node bị thay đổi và update ở DOM thật chỉ ở những cái node đó, thật thuận tiện và nhanh gọn phải không nào.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Khi tìm hiểu về ReactJS, chắc hẳn bạn đã nghe tới khái niệm DOM ảo (Virtual DOM). Nó giúp cho hiệu suất làm việc của React cao hơn hẳn so với các thư viện và framework Javascript khác. Nhưng bạn đã bao giờ tìm hiểu DOM ảo là gì và nó hoạt động như thế nào trong React? Hôm nay, chúng ta cùng tìm hiểu về chủ đề này nhé.&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://nthung2112.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Tìm Hiểu Regular Expression Javascript</title>
    <link href="http://nthung2112.github.io/2018/05/Tim-Hieu-Regular-Expression-Javascript.html"/>
    <id>http://nthung2112.github.io/2018/05/Tim-Hieu-Regular-Expression-Javascript.html</id>
    <published>2018-05-25T14:38:00.000Z</published>
    <updated>2018-05-25T14:47:51.414Z</updated>
    
    <content type="html"><![CDATA[<p>Regular expression hay còn được gọi tắt là Regex hay RegExp, là một cách để biểu diễn khuôn mẫu của string. Đây là một phần của ngôn ngữ lập trình JavaScript, cũng như nhiều ngôn ngữ lập trình khác. Nếu bạn là một lập trình viên và đã từng sử dụng Regular Expression thì bạn chắc hẳn sẽ thấy rằng nó có cú pháp rất kinh khủng và có phần “bí ẩn”. Tuy nhiên, công cụ này lại cực kì mạnh mẽ và hiệu quả khi dùng để xử lý string. Sau đây, chúng ta sẽ cùng tìm hiểu về Regular Expression trong JavaScript.<br><a id="more"></a></p><h2 id="Khoi-tao-Regular-Expression"><a href="#Khoi-tao-Regular-Expression" class="headerlink" title="Khởi tạo Regular Expression"></a>Khởi tạo Regular Expression</h2><p>Có hai cách để tạo ra một Regular Expression là:</p><ul><li>Sử dụng hàm khởi tạo của đối tượng RegExp</li><li>Viết trực tiếp sử dụng cặp dấu “/ /“</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="regexp">/abc/</span>;</span><br></pre></td></tr></table></figure><p>Cả hai cách trên ta đều thu được một Regular Expression biểu diễn một string có dạng: <em>abc</em>.</p><h2 id="Mot-so-phuong-thuc-cua-Regular-Expression"><a href="#Mot-so-phuong-thuc-cua-Regular-Expression" class="headerlink" title="Một số phương thức của Regular Expression"></a>Một số phương thức của Regular Expression</h2><h3 id="Phuong-thuc-Test"><a href="#Phuong-thuc-Test" class="headerlink" title="Phương thức Test"></a>Phương thức Test</h3><p>Đây là phương thức đơn giản nhất dùng để kiểm tra xem một string có chứa khuôn mẫu đã định nghĩa hay không. Nếu có thì kết quả trả về là TRUE và ngược lại thì là FALSE.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/abc/</span>.test(<span class="string">"abcde"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/abc/</span>.test(<span class="string">"12abcde"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/abc/</span>.test(<span class="string">"abxcde"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>Trong ví dụ trên, 2 string “abcde” và “12abcde” đều chứa “abc” nên kết quả trả về là true. String còn lại “abxcde” không chứa “abc” nên kết quả là false.</p><h4 id="Kiem-tra-trung-khop-voi-tap-hop-cac-ki-tu"><a href="#Kiem-tra-trung-khop-voi-tap-hop-cac-ki-tu" class="headerlink" title="Kiểm tra trùng khớp với tập hợp các kí tự"></a>Kiểm tra trùng khớp với tập hợp các kí tự</h4><p>Nếu chỉ kiểm tra như ví dụ trên thì bạn hoàn toàn có thể sử dụng phương thức <em>indexOf</em> của string thay vì sử dụng Regular Expression. Tuy nhiên, với Regular Expression thì bạn có thể kiểm tra những mẫu string phức tạp hơn. <strong>Ví dụ:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0123456789]/</span>.test(<span class="string">"in 1992"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]/</span>.test(<span class="string">"in 1992"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]/</span>.test(<span class="string">"Hello "</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-5]/</span>.test(<span class="string">"Gold 9999"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>Ví dụ 1, 2, 3 kiểm tra xem string có chứa bất kì chữ số nào từ 0 đến 9. Ví dụ cuối cùng kiểm tra xem string có chứa bất kì chữ số nào từ 0 đến 5. JavaScript sử dụng cặp dấu ngoặc vuông [] để biểu thị việc kiểm tra string có chứa bất kì kí tự nào có trong cặp dấu [] hay không. Trong đó, dấu “-“ giữa hai kí tự dùng để chỉ 1 khoảng giữa hai kí tự đó.</p><ul><li>[0-9] là các chữ số từ 0 đến 9</li><li>[a-z] là các chữ cái từ a đến z</li></ul><p>Ngoài ra, JavaScript cung cấp sẵn một số cách biểu diễn một tập hợp các kí tự:</p><ul><li>\d : bất kì chữ số nào từ 0 đến 9</li><li>\w : một chữ cái</li><li>\s : kí tự trắng (dấu cách, tab, dòng mới,…)</li><li>\D : kí tự không phải số</li><li>\W : kí tự không phải chữ cái</li><li>\S : kí tự không phải kí tự trắng</li><li>. : bất kì kí tự nào trừ dòng mới.</li></ul><p>Ví dụ kiểm tra ngày giờ có định dạng: <strong>dd-mm-yyyy hh:mm</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dateTime = <span class="regexp">/\d\d-\d\d-\d\d\d\d \d\d:\d\d/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dateTime.test(<span class="string">"30-01-2003 15:20"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(dateTime.test(<span class="string">"30-jan-2003 15:20"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h4 id="Dao-nguoc-tap-hop-cac-ki-tu"><a href="#Dao-nguoc-tap-hop-cac-ki-tu" class="headerlink" title="Đảo ngược tập hợp các kí tự"></a>Đảo ngược tập hợp các kí tự</h4><p>Trường hợp bạn muốn kiểm tra một string chứa bất kì kí tự nào không có trong tập hợp đã cho thì bạn có thể sử dụng kí tự “^”. Ví dụ:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> notBinary = <span class="regexp">/[^01]/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(notBinary.test(<span class="string">"1100100010100110"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(notBinary.test(<span class="string">"1100100010200110"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h4 id="Lap-lai-khuon-mau"><a href="#Lap-lai-khuon-mau" class="headerlink" title="Lặp lại khuôn mẫu"></a>Lặp lại khuôn mẫu</h4><p>Trong ví dụ về kiểm tra ngày giờ bên trên, “\d” xuất hiện lặp lại rất nhiều lần. Điều này gây nên sự khó theo dõi. Do đó, JavaScript cung cấp cách thức để biểu diễn sự lặp lại khuôn mẫu:</p><ul><li>“+”: biểu thị phần tử xuất hiện &gt;= 1 lần</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/'\d+'/</span>.test(<span class="string">"'123'"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/'\d+'/</span>.test(<span class="string">"''"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><ul><li>“*”: biểu thị phần tử xuất hiện &gt;= 0 lần (có thể không xuất hiện)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/'\d*'/</span>.test(<span class="string">"'123'"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/'\d*'/</span>.test(<span class="string">"''"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><ul><li>“?”: biểu thị phần tử xuất hiện 0 hoặc 1 lần</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> neighbor = <span class="regexp">/neighbou?r/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(neighbor.test(<span class="string">"neighbour"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(neighbor.test(<span class="string">"neighbor"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(neighbor.test(<span class="string">"neighbouur"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><ul><li>{n}: biểu thị phần tử xuất hiện đúng n lần</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;4&#125;/</span>.test(<span class="string">"1234"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;4&#125;/</span>.test(<span class="string">"12345"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;4&#125;/</span>.test(<span class="string">"123"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><ul><li>{x,y}: biểu thị phần tử xuất hiện từ x đến y lần</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,4&#125;/</span>.test(<span class="string">"12345"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,4&#125;/</span>.test(<span class="string">"1234"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,4&#125;/</span>.test(<span class="string">"123"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,4&#125;/</span>.test(<span class="string">"12"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,4&#125;/</span>.test(<span class="string">"1"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><ul><li>{x, }: biểu thị phần tử xuất hiện &gt;= x lần</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,&#125;/</span>.test(<span class="string">"12"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,&#125;/</span>.test(<span class="string">"1234"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d&#123;2,&#125;/</span>.test(<span class="string">"1"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h4 id="Nhom-cac-phan-tu"><a href="#Nhom-cac-phan-tu" class="headerlink" title="Nhóm các phần tử"></a>Nhóm các phần tử</h4><p>Trong nhiều trường hợp bạn muốn lặp lại cả một nhóm các phần tử. Khi đó, bạn phải nhóm các phần tử đó lại sử dụng cặp dấu ngoặc đơn “( )”.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cartoonCrying = <span class="regexp">/boo+(hoo+)+/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cartoonCrying.test(<span class="string">"Boohoooohoohooo"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h4 id="Lua-chon-khuon-mau"><a href="#Lua-chon-khuon-mau" class="headerlink" title="Lựa chọn khuôn mẫu"></a>Lựa chọn khuôn mẫu</h4><p>Trường hợp bạn có nhiều khuôn mẫu và bạn cần kiểm tra xem string đưa ra chứa một trong các khuôn mẫu đó thì bạn có thể viết các Regular Expression tương ứng để kiểm tra. Hoặc sử dụng kí tự (|) để biểu diễn “hoặc”:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animalCount = <span class="regexp">/\d+ (pig|cow|chicken)s?/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(animalCount.test(<span class="string">"15 pigs"</span>));</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(animalCount.test(<span class="string">"15 pigchickens"</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="Phuong-thuc-Exec"><a href="#Phuong-thuc-Exec" class="headerlink" title="Phương thức Exec"></a>Phương thức Exec</h3><p>Nếu như phương thức <strong>test</strong> chỉ kiểm tra xem có tồn tại khuôn mẫu hay không thì phương thức <strong>exec</strong> sẽ trả về một đối tượng chứa thông tin thành phần trùng khớp với khuôn mẫu, ngược lại thì trả về null.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> match = <span class="regexp">/\d+/</span>.exec(<span class="string">"one two 100 200"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match);</span><br><span class="line"><span class="comment">// =&gt; ["100", index: 8, input: "one two 100 200"]</span></span><br><span class="line"><span class="built_in">console</span>.log(match.index);</span><br><span class="line"><span class="comment">// =&gt; 8</span></span><br></pre></td></tr></table></figure><p>Ví dụ trên trả về thành phần thoả mãn khuôn mẫu đầu tiên là: “100”. <em>Index</em> là vị trí đầu tiên của string thoả mãn khuôn mẫu. Khi Regular Expression chứa group với cặp dấu ngoặc đơn thì phần tử đầu tiên trong kết quả sẽ là toàn bộ thành phần trùng khớp, thành phần tiếp theo là phần trùng khớp với group đầu tiên, thành phần tiếp theo là phần trùng khớp với group thứ 2,…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quotedText = <span class="regexp">/'([^']*)'/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(quotedText.exec(<span class="string">"she said 'hello'"</span>));</span><br><span class="line"><span class="comment">// =&gt; ["'hello'", "hello", index: 9, input: "she said 'hello'"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/bad(ly)?/</span>.exec(<span class="string">"bad"</span>));</span><br><span class="line"><span class="comment">// =&gt; ["bad", undefined, index: 0, input: "bad"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/(\d)+/</span>.exec(<span class="string">"123"</span>));</span><br><span class="line"><span class="comment">// =&gt; ["123", "3", index: 0, input: "123"]</span></span><br></pre></td></tr></table></figure><h4 id="Trich-xuat-du-lieu-tu-string"><a href="#Trich-xuat-du-lieu-tu-string" class="headerlink" title="Trích xuất dữ liệu từ string"></a>Trích xuất dữ liệu từ string</h4><p>Phương thức này đặc biệt hữu ích khi bạn muốn lấy thông tin ra từ string. Ví dụ sau đưa ra một string biểu diễn ngày, tháng, năm. Sau đó chúng ta sẽ trích xuất ra thông tin về ngày, tháng và năm ở trong đó:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDate</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dateTime = <span class="regexp">/(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)-(\d&#123;4&#125;)/</span>;</span><br><span class="line">  <span class="keyword">var</span> match = dateTime.exec(string);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    day : match[<span class="number">1</span>],</span><br><span class="line">    month : match[<span class="number">2</span>],</span><br><span class="line">    year: match[<span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = findDate(<span class="string">"30-1-2003"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// =&gt; Object &#123;day: "30", month: "1", year: "2003"&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Ranh-gioi-cua-string"><a href="#Ranh-gioi-cua-string" class="headerlink" title="Ranh giới của string"></a>Ranh giới của string</h4><p>Trong ví dụ trên, hàm findDate vẫn tìm ra kết quả nếu như string là “30-1-200300” hay “1130-1-2003”,… Đây là trường hợp không mong muốn. Regular Expression JavaScript cung cấp 2 cách để giải quyết vấn đề này:</p><ul><li>Sử dụng kí tự biểu diễn bắt đầu (^) và kết thúc ($$ string</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDate</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dateTime = <span class="regexp">/^(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)-(\d&#123;4&#125;)$/</span>;</span><br><span class="line">  <span class="keyword">var</span> match = dateTime.exec(string);</span><br><span class="line">  <span class="keyword">if</span>(!match) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    day : match[<span class="number">1</span>],</span><br><span class="line">    month : match[<span class="number">2</span>],</span><br><span class="line">    year: match[<span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = findDate(<span class="string">"30-1-2003"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"><span class="comment">// =&gt; Object &#123;day: "30", month: "1", year: "2003"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = findDate(<span class="string">"0030-1-200300"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"><span class="comment">// =&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = findDate(<span class="string">"Hello 30-1-2003 Haha"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br><span class="line"><span class="comment">// =&gt; null</span></span><br></pre></td></tr></table></figure><ul><li>Sử dụng kí tự biên (\b)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDate</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dateTime = <span class="regexp">/\b(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)-(\d&#123;4&#125;)\b/</span>;</span><br><span class="line">  <span class="keyword">var</span> match = dateTime.exec(string);</span><br><span class="line">  <span class="keyword">if</span>(!match) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    day : match[<span class="number">1</span>],</span><br><span class="line">    month : match[<span class="number">2</span>],</span><br><span class="line">    year: match[<span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = findDate(<span class="string">"30-1-2003"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"><span class="comment">// =&gt; Object &#123;day: "30", month: "1", year: "2003"&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = findDate(<span class="string">"0030-1-200300"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"><span class="comment">// =&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = findDate(<span class="string">"Hello 30-1-2003 Haha"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br><span class="line"><span class="comment">// =&gt; Object &#123;day: "30", month: "1", year: "2003"&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Tao-doi-tuong-RegExp-mot-cach-linh-dong"><a href="#Tao-doi-tuong-RegExp-mot-cach-linh-dong" class="headerlink" title="Tạo đối tượng RegExp một cách linh động"></a>Tạo đối tượng RegExp một cách linh động</h2><p>Trong nhiều trường hợp, bạn muốn tạo ra một Regular Expression với nội dung chưa được biết trước. Bạn có thể sử dụng hàm khởi tạo của RegExp theo cách sau:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"lampv"</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"LamPV is a suspicious character."</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\b("</span> + name + <span class="string">")\\b"</span>, <span class="string">"gi"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text.replace(regexp, <span class="string">"_$1_"</span>));</span><br><span class="line"><span class="comment">// =&gt; _LamPV_ is a suspicious character.</span></span><br></pre></td></tr></table></figure><p>Trong đó:</p><ul><li>tham số g: chỉ ra rằng khuôn mẫu áp dụng Global, nghĩa là nó áp dụng cho tất cả thành phần trùng khớp.</li><li>tham số i: chỉ ra rằng khuôn mẫu không phân biệt chữ hoa và chữ thường.</li></ul><p>Ngoài ra, ở đây tôi có sử dụng phương thức <em>replace</em> của <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noopener">string</a> - dùng để thay thế tất cả những thành phần trùng khớp với khuôn mẫu với “_$1_”. Ở đây $$ chính là nội dung của group thứ nhất.</p><h2 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h2><p>Trên đây là một số kiến thức cơ bản về Regular Expression. Hy vọng qua bài viết này bạn phần nào hiểu và biết cách sử dụng công cụ hiệu quả này trong công việc lập trình của mình, đặc biệt là lập trình JavaScript. Tóm tắt một số khuôn mẫu cơ bản của Regular Expression:</p><ul><li>/abc/ : chuỗi các kí tự <em>abc</em></li><li>/[abc]: bất kỳ kí tự nào thuộc tập hợp a, b, c</li><li>/[^abc]: bất kỳ kí tự nào không thuộc tập a, b, c</li><li>/[0-9]/: bất kỳ kí tự nào thuộc đoạn từ 0 đến 9</li><li>/x+/: thành phần x xuất hiện &gt;= 1 lần</li><li>/x*/: thành phần x xuất hiện &gt;= 0 lần (có thể không xuất hiện)</li><li>/x?/: thành phần x xuất hiện 0 hoặc 1 lần</li><li>/x{2, 4}/: thành phần x xuất hiện từ 2 đến 4 lần</li><li>/(abc)/: cụm <em>abc</em></li><li>/a|b|c/: bất kì pattern nào trong 3 loại a, b, c</li><li>/\d/: chữ số từ 0 đến 9</li><li>/\w/: chữ cái</li><li>/\s/: kí tự trắng (dấu cách, tab, dòng mới,…)</li><li>/./ : bất kỳ kí tự nào trừ dòng mới</li><li>/\b/: ranh giới từ</li><li>/^/: bắt đầu string</li><li>/$$: kết thúc string</li></ul><h2 id="Tham-khao"><a href="#Tham-khao" class="headerlink" title="Tham khảo"></a>Tham khảo</h2><ul><li><a href="http://eloquentjavascript.net/09_regexp.html" target="_blank" rel="noopener">http://eloquentjavascript.net/09_regexp.html</a></li><li>Bài thực hành của tôi: <a href="https://github.com/completejavascript/practical-javascript/blob/master/regular_expression/regexp_golf_completejavascript.com.js" target="_blank" rel="noopener">Regexp Golf</a>, <a href="https://github.com/completejavascript/practical-javascript/blob/master/regular_expression/quoting_style_completejavascript.com.js" target="_blank" rel="noopener">Quoting style</a>, <a href="https://github.com/completejavascript/practical-javascript/blob/master/regular_expression/numbers_again_completejavascript.com.js" target="_blank" rel="noopener">Numbers again</a>.</li><li><a href="http://phamvanlam.com/xac-thuc-ma-mau-rgb-va-ma-mau-hex-su-dung-regex-trong-javascript/" target="_blank" rel="noopener">Xác thực mã màu RGB và mã màu HEX sử dụng Regex trong Javascript</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Regular expression hay còn được gọi tắt là Regex hay RegExp, là một cách để biểu diễn khuôn mẫu của string. Đây là một phần của ngôn ngữ lập trình JavaScript, cũng như nhiều ngôn ngữ lập trình khác. Nếu bạn là một lập trình viên và đã từng sử dụng Regular Expression thì bạn chắc hẳn sẽ thấy rằng nó có cú pháp rất kinh khủng và có phần “bí ẩn”. Tuy nhiên, công cụ này lại cực kì mạnh mẽ và hiệu quả khi dùng để xử lý string. Sau đây, chúng ta sẽ cùng tìm hiểu về Regular Expression trong JavaScript.&lt;br&gt;
    
    </summary>
    
    
      <category term="regex" scheme="http://nthung2112.github.io/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>Giới thiệu về Composing Software</title>
    <link href="http://nthung2112.github.io/2018/05/Gioi-thieu-ve-Composing-Software.html"/>
    <id>http://nthung2112.github.io/2018/05/Gioi-thieu-ve-Composing-Software.html</id>
    <published>2018-05-22T01:09:00.000Z</published>
    <updated>2018-05-25T15:58:41.743Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Ghi chú: Đây là phần giới thiệu về loạt bài “Composing Software” về việc học các kỹ năng functional programming và compositional software trong JavaScript ES6+ từ đầu. Hãy theo dõi còn rất nhiều thứ khác nữa!<br><a href="https://medium.com/javascript-scene/the-rise-and-fall-and-rise-of-functional-programming-composable-software-c2d91b424c8c" target="_blank" rel="noopener"><em>Bài viết Kế tiếp &gt;</em></a><br><a id="more"></a><br>Composition: “Hành động kết hợp các parts hoặc elements để tạo thành một tổng thể.”</p></blockquote><p>Trong lớp học lập trình đầu tiên của tôi, tôi đã nói rằng phát triển phần mềm là  “hành động phá vỡ một vấn đề phức tạp thành các vấn đề nhỏ hơn, và soạn các giải pháp đơn giản để tạo thành một giải pháp hoàn chỉnh cho vấn đề phức tạp.”</p><p>Một trong những hối tiếc lớn nhất của tôi trong cuộc sống là tôi đã không hiểu ý nghĩa của bài học đó từ sớm. Tôi đã học được bản chất của thiết kế phần mềm quá muộn trong cuộc sống.</p><p>Tôi đã phỏng vấn hàng trăm developers. Những gì tôi đã học được từ những buổi đó là Tôi không đơn độc. Rất ít developers phần mềm làm việc mà có nắm bắt tốt về bản chất của phát triển phần mềm. Họ không nhận thức được các công cụ quan trọng nhất chúng ta có thể có để xử lý hoặc làm thế nào để đưa chúng vào sử dụng cho tốt. 100% đã đấu tranh để trả lời một hoặc cả hai câu hỏi quan trọng nhất trong lĩnh vực phát triển phần mềm:</p><ul><li>What is function composition?</li><li>What is object composition?</li></ul><p>Vấn đề là bạn không thể tránh được ‘composition’ chỉ vì bạn không biết về nó. Bạn vẫn làm điều đó - nhưng bạn làm điều đó rất tệ. Bạn viết mã với nhiều lỗi hơn và làm cho các developers khác khó hiểu hơn. Đây là một vấn đề lớn. Các ảnh hưởng ấy tốn nhất nhiều chi phí. Chúng tôi dành nhiều thời gian hơn để duy trì phần mềm hơn là chúng tôi tạo ra nó từ đầu và các lỗi của chúng tôi tác động đến hàng tỷ người trên khắp thế giới.</p><p>Cả thế giới chạy trên phần mềm ngày nay. Mỗi chiếc xe mới là một siêu máy tính mini trên bánh xe, và các vấn đề với thiết kế phần mềm gây ra tai nạn thực sự và chi phí cuộc sống thực của con người. Vào năm 2013, Ban giám khảo đã tìm thấy nhóm phát triển phần mềm của Toyota có tội <a href="http://www.safetyresearch.net/blog/articles/toyota-unintended-acceleration-and-big-bowl-%E2%80%9Cspaghetti%E2%80%9D-code" target="_blank" rel="noopener">“Liều lĩnh không để ý”</a> sau khi một cuộc điều tra tai nạn cho thấy spaghetti code với 10000 biến global.</p><p><a href="https://www.technologyreview.com/s/607875/should-the-government-keep-stockpiling-software-bugs/" target="_blank" rel="noopener">Hackers và governments stockpile bugs</a> để theo dõi mọi người, ăn cắp thẻ tín dụng, khai thác tài nguyên máy tính để khởi chạy các cuộc tấn công từ chối dịch vụ phân tán (DDoS), crack mật khẩu và thậm chí <a href="https://www.technologyreview.com/s/604138/the-fbi-shut-down-a-huge-botnet-but-there-are-plenty-more-left/" target="_blank" rel="noopener">điều khiển cuộc bầu cử</a>.</p><p>Chúng ta phải làm tốt hơn.</p><h3 id="You-Compose-Software-Every-Day"><a href="#You-Compose-Software-Every-Day" class="headerlink" title="You Compose Software Every Day"></a>You Compose Software Every Day</h3><p>Nếu bạn là nhà phát triển phần mềm, bạn lập trình các chức năng và cấu trúc dữ liệu mỗi ngày, cho dù bạn có biết hay không. Bạn có thể làm điều đó một cách có ý thức (và tốt hơn), hoặc bạn có thể làm điều đó một cách vô tình, with duct-tape and crazy glue.</p><p>Quá trình phát triển phần mềm là chia nhỏ các vấn đề lớn thành các vấn đề nhỏ hơn, xây dựng các thành phần giải quyết những vấn đề nhỏ hơn, sau đó kết hợp các thành phần lại với nhau để tạo thành một ứng dụng hoàn chỉnh.</p><h3 id="Composing-Functions"><a href="#Composing-Functions" class="headerlink" title="Composing Functions"></a>Composing Functions</h3><p>Function composition là quá trình áp dụng một function là output của function khác. Trong đại số, có hai hàm số, <code>f</code> và <code>g</code>, <code>(f ∘ g)(x) = f(g(x))</code>. Vòng tròn là toán tử kết hợp. Nó thường được phát âm “kết hợp với” hoặc là “theo sau”. Bạn có thể nói như “f <em>kết hợp với</em> g bằng f of g of x”, or “f <em>theo sau</em> g bằng f of g of x”. Chúng ta nói f <em>theo sau</em> g bởi vì g is giá trị đầu, sau đó output của nó được chuyển thành đối số f.</p><p>Mỗi lần bạn viết code như thế này, nó là composing functions:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> doStuff = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> afterG = g(x);</span><br><span class="line">  <span class="keyword">const</span> afterF = f(afterG);</span><br><span class="line">  <span class="keyword">return</span> afterF;</span><br><span class="line">&#125;;</span><br><span class="line">doStuff(<span class="number">20</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>Mỗi khi bạn viết một chuỗi promise, nó là composing functions:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> wait = <span class="function"><span class="params">time</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">  (resolve, reject) =&gt; setTimeout(</span><br><span class="line">    resolve,</span><br><span class="line">    time</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line">wait(<span class="number">300</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">20</span>)</span><br><span class="line">  .then(g)</span><br><span class="line">  .then(f)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value)) <span class="comment">// 42</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>Tương tự như vậy, mỗi khi bạn thực hiện các gọi các chuỗi phương thức mảng, các hàm lodash, observables (RxJS, etc…) nó là composing functions. Nếu là một chuỗi, thì nó là composing. Nếu bạn chuyển một giá trị trả về vào những functions khác, nó cũng là composing. Nếu bạn gọi hai hàm theo trình tự, nó là composing nếu sử dụng dữ liệu hàm này làm dữ liệu đầu vào cho hàm kia.</p><blockquote><p>Nếu là một chuỗi, thì nó là composing.</p></blockquote><p>Khi bạn viết một functions có chủ ý, bạn sẽ làm tốt hơn.</p><p>Composing functions có chủ ý, chúng ta có thể cải thiện hàm doStuff() thành 1 dòng đơn giản:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> doStuffBetter = <span class="function"><span class="params">x</span> =&gt;</span> f(g(x));</span><br><span class="line">doStuffBetter(<span class="number">20</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>Một trong những phản đối chung về kiểu này là khó để debug. Ví dụ, chúng ta sẽ viết function composition bằng cách nào?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doStuff = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> afterG = g(x);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`after g: <span class="subst">$&#123; afterG &#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> afterF = f(afterG);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`after f: <span class="subst">$&#123; afterF &#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> afterF;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">doStuff(<span class="number">20</span>); <span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"after g: 21"</span></span><br><span class="line"><span class="comment">"after f: 42"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Đầu tiên, hãy trừu tượng rằng “after f”, “after g” và viết vào một tiện ích nhỏ gọi là trace():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> trace = <span class="function"><span class="params">label</span> =&gt;</span> value =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; label &#125;</span>: <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Now we can use it like this:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doStuff = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> afterG = g(x);</span><br><span class="line">  trace(<span class="string">'after g'</span>)(afterG);</span><br><span class="line">  <span class="keyword">const</span> afterF = f(afterG);</span><br><span class="line">  trace(<span class="string">'after f'</span>)(afterF);</span><br><span class="line">  <span class="keyword">return</span> afterF;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">doStuff(<span class="number">20</span>); <span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"after g: 21"</span></span><br><span class="line"><span class="comment">"after f: 42"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Thư viện functional programming phổ biến như Lodash và Ramda bao gồm các tiện ích để thực hiện function composition dễ hơn. Bạn có thể viết lại hàm trên như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pipe <span class="keyword">from</span> <span class="string">'lodash/fp/flow'</span>;</span><br><span class="line"><span class="keyword">const</span> doStuffBetter = pipe(</span><br><span class="line">  g,</span><br><span class="line">  trace(<span class="string">'after g'</span>),</span><br><span class="line">  f,</span><br><span class="line">  trace(<span class="string">'after f'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">doStuffBetter(<span class="number">20</span>); <span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"after g: 21"</span></span><br><span class="line"><span class="comment">"after f: 42"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>If you want to try this code without importing something, you can define pipe like this:<br>Nếu bạn muốn thử code này mà không cần nhập gì, bạn có thể xác định pipe như thế này:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pipe(...fns: [...Function]) =&gt; x =&gt; y</span></span><br><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class="function">(<span class="params">y, f</span>) =&gt;</span> f(y), x);</span><br></pre></td></tr></table></figure><p>Đừng lo lắng nếu bạn chưa thể theo dõi cách hoạt động. Sau đó, chúng tôi sẽ khám phá function composition chi tiết hơn. In fact, it’s so essential, you’ll see it defined and demonstrated many times throughout this text. The point is to help you become so familiar with it that its definition and usage becomes automatic. Be one with the composition.</p><p>pipe() creates a pipeline of functions, passing the output of one function to the input of another. When you use pipe() (and its twin, compose()) You don’t need intermediary variables. Writing functions without mention of the arguments is called <strong>point-free style.</strong> To do it, you’ll call a function that returns the new function, rather than declaring the function explicitly. That means you won’t need the function keyword or the arrow syntax (=&gt;).</p><p>Point-free style can be taken too far, but a little bit here and there is great because those intermediary variables add unnecessary complexity to your functions.</p><p>There are several benefits to reduced complexity:</p><h4 id="Working-Memory"><a href="#Working-Memory" class="headerlink" title="Working Memory"></a>Working Memory</h4><p>Bộ não con người trung bình chỉ có một vài tài nguyên được chia sẻ cho lượng tử rời rạc trong bộ nhớ làm việc <a href="http://www.nature.com/neuro/journal/v17/n3/fig_tab/nn.3655_F2.html" target="_blank" rel="noopener">working memory</a>, và mỗi biến có khả năng tiêu thụ một trong những lượng tử đó. As you add more variables, our ability to accurately recall the meaning of each variable is diminished. Working memory models typically involve 4–7 discrete quanta. Above those numbers, error rates dramatically increase.</p><p>Using the pipe form, we eliminated 3 variables — freeing up almost half of our available working memory for other things. That reduces our cognitive load significantly. Software developers tend to be better at chunking data into working memory than the average person, but not so much more as to weaken the importance of conservation.</p><h4 id="Signal-to-Noise-Ratio"><a href="#Signal-to-Noise-Ratio" class="headerlink" title="Signal to Noise Ratio"></a>Signal to Noise Ratio</h4><p>Concise code also improves the signal-to-noise ratio of your code. It’s like listening to a radio — when the radio is not tuned properly to the station, you get a lot of interfering noise, and it’s harder to hear the music. When you tune it to the correct station, the noise goes away, and you get a stronger musical signal.</p><p>Code is the same way. More concise code expression leads to enhanced comprehension. Some code gives us useful information, and some code just takes up space. If you can reduce the amount of code you use without reducing the meaning that gets transmitted, you’ll make the code easier to parse and understand for other people who need to read it.</p><h4 id="Surface-Area-for-Bugs"><a href="#Surface-Area-for-Bugs" class="headerlink" title="Surface Area for Bugs"></a>Surface Area for Bugs</h4><p>Take a look at the before and after functions. It looks like the function went on a diet and lost a ton of weight. That’s important because extra code means extra surface area for bugs to hide in, which means more bugs will hide in it.</p><blockquote><p><em>Less code = less surface area for bugs = fewer bugs.</em></p></blockquote><h3 id="Composing-Objects"><a href="#Composing-Objects" class="headerlink" title="Composing Objects"></a>Composing Objects</h3><blockquote><p>“Favor object composition over class inheritance” the Gang of Four, <a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;qid=1494993475&amp;sr=8-1&amp;keywords=design+patterns&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=6c553f16325f3939e5abadd4ee04e8b4" target="_blank" rel="noopener">“Design Patterns: Elements of Reusable Object Oriented Software”</a></p></blockquote><blockquote><p>“In computer science, a composite data type or compound data type is any data type which can be constructed in a program using the programming language’s primitive data types and other composite types. […] The act of constructing a composite type is known as composition.” ~ Wikipedia</p></blockquote><p>These are primitives:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = <span class="string">'Claude'</span>;</span><br><span class="line"><span class="keyword">const</span> lastName = <span class="string">'Debussy'</span>;</span><br></pre></td></tr></table></figure><p>And this is a composite:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = &#123;</span><br><span class="line">  firstName,</span><br><span class="line">  lastName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Likewise, all Arrays, Sets, Maps, WeakMaps, TypedArrays, etc… are composite datatypes. Any time you build any non-primitive data structure, you’re performing some kind of object composition.</p><p>Note that the Gang of Four defines a pattern called the <strong>composite pattern</strong> which is a specific type of recursive object composition which allows you to treat individual components and aggregated composites identically. Some developers get confused, thinking that the composite pattern is <em>the only form of object composition.</em> Don’t get confused. There are many different kinds of object composition.</p><p>The Gang of Four continues, “you’ll see object composition applied again and again in design patterns”, and then they catalog three kinds of object compositional relationships, including <strong>delegation</strong> (as used in the state, strategy, and visitor patterns), <strong>acquaintance</strong> (when an object knows about another object by reference, usually passed as a parameter: a uses-a relationship, e.g., a network request handler might be passed a reference to a logger to log the request — the request handler <em>uses</em> a logger), and <strong>aggregation</strong> (when child objects form part of a parent object: a has-a relationship, e.g., DOM children are component elements in a DOM node — A DOM node <em>has</em> children).</p><p>Class inheritance can be used to construct composite objects, but it’s a restrictive and brittle way to do it. When the Gang of Four says “favor object composition over class inheritance”, they’re advising you to use flexible approaches to composite object building, rather than the rigid, tightly-coupled approach of class inheritance.</p><p>We’ll use a more general definition of object composition from <a href="https://www.amazon.com/Categorical-Methods-Computer-Science-Topology/dp/0387517227/ref=as_li_ss_tl?ie=UTF8&amp;qid=1495077930&amp;sr=8-3&amp;keywords=Categorical+Methods+in+Computer+Science:+With+Aspects+from+Topology&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=095afed5272832b74357f63b41410cb7" target="_blank" rel="noopener">“Categorical Methods in Computer Science: With Aspects from Topology”</a> (1989):</p><blockquote><p>“Composite objects are formed by putting objects together such that each of the latter is ‘part of’ the former.”</p></blockquote><p>Another good reference is “Reliable Software Through Composite Design”, Glenford J Myers, 1975. Both books are long out of print, but you can still find sellers on Amazon or eBay if you’d like to explore the subject of object composition in more technical depth.</p><p><em>Class inheritance is just one kind of composite object construction.</em> All classes produce composite objects, but not all composite objects are produced by classes or class inheritance. “Favor object composition over class inheritance” means that you should form composite objects from small component parts, rather than inheriting all properties from an ancestor in a class hierarchy. The latter causes a large variety of well-known problems in object oriented design:</p><ul><li><strong>The tight coupling problem:</strong> Because child classes are dependent on the implementation of the parent class, class inheritance is the tightest coupling available in object oriented design.</li><li><strong>The fragile base class problem:</strong> Due to tight coupling, changes to the base class can potentially break a large number of descendant classes — potentially in code managed by third parties. The author could break code they’re not aware of.</li><li><strong>The inflexible hierarchy problem:</strong> With single ancestor taxonomies, given enough time and evolution, all class taxonomies are eventually wrong for new use-cases.</li><li><strong>The duplication by necessity problem:</strong> Due to inflexible hierarchies, new use cases are often implemented by duplication, rather than extension, leading to similar classes which are unexpectedly divergent. Once duplication sets in, it’s not obvious which class new classes should descend from, or why.</li><li><strong>The gorilla/banana problem:</strong> “…the problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.” ~ Joe Armstrong, <a href="http://www.amazon.com/gp/product/1430219483?ie=UTF8&amp;camp=213733&amp;creative=393185&amp;creativeASIN=1430219483&amp;linkCode=shr&amp;tag=eejs-20&amp;linkId=3MNWRRZU3C4Q4BDN" target="_blank" rel="noopener">“Coders at Work”</a></li></ul><p>The most common form of object composition in JavaScript is known as <strong>object concatenation</strong> (aka mixin composition). It works like ice-cream. You start with an object (like vanilla ice-cream), and then mix in the features you want. Add some nuts, caramel, chocolate swirl, and you wind up with nutty caramel chocolate swirl ice cream.</p><p>Building composites with class inheritance:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="string">'a'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(options);</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="string">'b'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myBar = <span class="keyword">new</span> Bar(); <span class="comment">// &#123;a: 'a', b: 'b'&#125;</span></span><br></pre></td></tr></table></figure><p>Building composites with mixin composition:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  a: <span class="string">'a'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  b: <span class="string">'b'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;...a, ...b&#125;; <span class="comment">// &#123;a: 'a', b: 'b'&#125;</span></span><br></pre></td></tr></table></figure><p>We’ll explore other styles of object composition in more depth later. For now, your understanding should be:</p><ol><li>There’s more than one way to do it.</li><li>Some ways are better than others.</li><li>You want to select the simplest, most flexible solution for the task at hand.</li></ol><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>This isn’t about functional programming (FP) vs object-oriented programming (OOP), or one language vs another. Components can take the form of functions, data structures, classes, etc… Different programming languages tend to afford different atomic elements for components. Java affords classes, Haskell affords functions, etc… But no matter what language and what paradigm you favor, you can’t get away from composing functions and data structures. In the end, that’s what it all boils down to.</p><p>We’ll talk a lot about functional programming, because functions are the simplest things to compose in JavaScript, and the functional programming community has invested a lot of time and effort formalizing function composition techniques.</p><p>What we won’t do is say that functional programming is better than object-oriented programming, or that you must choose one over the other. OOP vs FP is a false dichotomy. Every real Javascript application I’ve seen in recent years mixes FP and OOP extensively.</p><p>We’ll use object composition to produce datatypes for functional programming, and functional programming to produce objects for OOP.</p><p><em>No matter how you write software, you should compose it well.</em></p><blockquote><p>The essence of software development is composition.</p></blockquote><p>A software developer who doesn’t understand composition is like a home builder who doesn’t know about bolts or nails. Building software without awareness of composition is like a home builder putting walls together with duct tape and crazy glue.</p><p>It’s time to simplify, and the best way to simplify is to get to the essence. The trouble is, almost nobody in the industry has a good handle on the essentials. We as an industry have failed you, the software developer. It’s our responsibility as an industry to train developers better. We must improve. We need to take responsibility. Everything runs on software today, from the economy to medical equipment. There is literally no corner of human life on this planet that is not impacted by the quality of our software. We need to know what we’re doing.</p><p>It’s time to learn how to compose software.</p><p><a href="https://medium.com/javascript-scene/the-rise-and-fall-and-rise-of-functional-programming-composable-software-c2d91b424c8c" target="_blank" rel="noopener">Continued in “The Rise and Fall and Rise of Functional Programming”</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Ghi chú: Đây là phần giới thiệu về loạt bài “Composing Software” về việc học các kỹ năng functional programming và compositional software trong JavaScript ES6+ từ đầu. Hãy theo dõi còn rất nhiều thứ khác nữa!&lt;br&gt;&lt;a href=&quot;https://medium.com/javascript-scene/the-rise-and-fall-and-rise-of-functional-programming-composable-software-c2d91b424c8c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;em&gt;Bài viết Kế tiếp &amp;gt;&lt;/em&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
      <category term="hof" scheme="http://nthung2112.github.io/tags/hof/"/>
    
  </entry>
  
  <entry>
    <title>Sử dụng ký pháp BEM trong CSS</title>
    <link href="http://nthung2112.github.io/2018/05/Su-dung-ky-phap-BEM-trong-CSS.html"/>
    <id>http://nthung2112.github.io/2018/05/Su-dung-ky-phap-BEM-trong-CSS.html</id>
    <published>2018-05-20T09:05:00.000Z</published>
    <updated>2018-05-20T09:16:00.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ky-phap-BEM-la-gi"><a href="#Ky-phap-BEM-la-gi" class="headerlink" title="Ký pháp BEM là gì"></a>Ký pháp BEM là gì</h2><p>BEM viết tắt của Blocks, Elements, Modifiers, là một phương pháp đặt tên class cho HTML và CSS. Được phát triển <a href="https://en.bem.info" target="_blank" rel="noopener">tại Yandex</a> giúp lập trình viên hiểu rõ hơn mối quan hệ giữa HTML và CSS trong dự án front end.<br><a id="more"></a><br>Ví dụ sau đây sẽ minh hoạ cách sử dụng ký pháp BEM:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Một Block (khối) độc lập */</span></span><br><span class="line"><span class="selector-class">.btn</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Element (phần tử) con, phụ thuộc vào Block ở trên */</span></span><br><span class="line"><span class="selector-class">.btn__price</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modifier (bộ điều chỉnh) thay đổi trạng thái của Block */</span></span><br><span class="line"><span class="selector-class">.btn--orange</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.btn--big</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>Với cách đặt tên class này, ta có <strong>Block</strong> sẽ đại diện cho một component, và trong ví dụ ở đây, là một button <code>.btn</code>. Block cũng sẽ đóng vai trò là một <em>parent</em> mà trong nó sẽ có một hoặc nhiều hơn <strong>Element</strong> con liên quan. Tên class cho Element và mối quan hệ của nó với Block sẽ được diễn tả bằng tên của Block, tiếp theo là <em>hai gạch dưới</em>, và cuối cùng là tên của Element <code>.btn__price</code>. Thành phần thứ ba của BEM là các <strong>Modifier</strong> mà chúng sẽ giúp điều chỉnh các trạng thái hoặc phái sinh khác của Block / Element. Tên của Modifier sẽ được nối với tên Block / Element phía trước bởi <em>02 gạch ngang</em> <code>.btn--orange</code>.</p><p>Trong HTML, ký pháp BEM sẽ được dùng như sau:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn--big btn--orange"</span> <span class="attr">href</span>=<span class="string">"http://int3ractive.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__price"</span>&gt;</span>$9.99<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__text"</span>&gt;</span>Subscribe<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><iframe src="https://codepen.io/css-tricks/embed/226a65c8f7d64615aabd45048d1d3b6d" width="100%" height="300" frameborder="0" allowfullscreen></iframe><p>Ấn tượng đầu tiên với bạn có thể là tên class quá xấu và mất thời gian hơn so với việc tạo riêng một class mới cho một kiểu button mới. Tuy nhiên, ký pháp BEM sẽ mang lại nhiều lợi ích mà tôi sẽ phân tích tiếp theo sau đây:</p><h2 id="Tai-sao-su-dung-ky-phap-BEM"><a href="#Tai-sao-su-dung-ky-phap-BEM" class="headerlink" title="Tại sao sử dụng ký pháp BEM"></a>Tại sao sử dụng ký pháp BEM</h2><p>Trước tiên, ký pháp BEM giúp người mới tham gia dự án dễ dàng phát hiện ra các trạng thái và các đối tượng con của một component đã được viết sẵn. Điều này giúp tránh cho họ phải viết lại những kiểu CSS đã có sẵn và hạn chế việc viết thừa code hoặc trùng kiểu CSS, điều mà rất hay xảy ra trong dự án lớn có nhiều người tham gia.</p><p>Thứ hai, chỉ cần đọc HTML, bạn vẫn có thể nhanh chóng nắm được các thành phần phụ thuộc lẫn nhau. Trong ví dụ trên, bạn dễ dàng nhìn thấy <code>.btn__price</code> phụ thuộc vào <code>.btn</code> mặc dù bạn chưa biết vai trò cụ thể của nó ngay lập tức.</p><p>Thứ ba, với ký pháp BEM, mọi định nghĩa chỉ có một cấp class và không lồng cấp. Điều này giúp cho độ ưu tiên (specificity) chung của hệ thống CSS thấp. Đây là một lợi thế vì sau này bạn không phải “chiến đấu” với specificity của những thuộc tính đã có sẵn (VD: siêu lồng cấp <code>.a .b .c .d .e {...}</code>) cũng như vận dụng những kỹ thuật không hay để thay thế được style (chẳng hạn <code>!important</code> hay inline CSS).</p><p>Quy luật thác nước cascading của CSS là con dao hai lưỡi: nó giúp dễ dàng định nghĩa những thuộc tính và kiểu chung trên những selector tổng quát mà không cần phải khai báo lặp lại trên từng phần tử, nhưng nếu không nắm được tầm ảnh hưởng, lập trình viên CSS rất dễ gây ra những tác động phụ đến các đối tượng không liên quan khi chỉnh sửa trên những class có sẵn hoặc thậm chí viết mới. Với ký pháp BEM, lập trình viên sẽ tự tin hơn khi bắt tay chỉnh sửa hoặc viết thêm style vì đã biết rõ tầm ảnh hưởng của selector mà mình đang viết ra.</p><p>Tóm lại, ký pháp BEM, nếu áp dụng triệt để, sẽ giúp cải thiện sự phối hợp giữa các thành viên trong nhóm. Ngoài ra, nó buộc người viết CSS phải đầu tư suy nghĩ về việc xây dựng những component độc lập và tái sử dụng được (phù hợp với tiêu chí của <a href="https://github.com/stubbornella/oocss/wiki" target="_blank" rel="noopener">OOCSS</a>).</p><h2 id="Su-dung-BEM-voi-SASS"><a href="#Su-dung-BEM-voi-SASS" class="headerlink" title="Sử dụng BEM với SASS"></a>Sử dụng BEM với SASS</h2><p>Với phiên bản SASS mới nhất hiện nay, việc viết theo ký pháp BEM trong SCSS dễ dàng và thuận tiện hơn bao giờ hết.</p><p>Bạn vẫn sẽ sử dụng cách viết lồng để cô lập khối component và kết hợp với biểu tượng <em>parent</em> <code>&amp;</code> của SASS để đặt tên cho Element và Modifier mà không phải đánh lại tên của Block. VD:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line"></span><br><span class="line">    &amp;__element &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &amp;--mod &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mặc dù viết lồng cấp, khi được biên dịch thành CSS, chúng vẫn được trải phẳng thành một cấp class theo đúng tinh thần của BEM:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block__element</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block--mod</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>Nếu bạn sử dụng LibSass (nhanh hơn rất nhiều lần bản gốc Ruby) để biên dịch SASS, thì hãy đảm bảo các công cụ wrapper được cập nhật các phiên bản tương đương hoặc mới hơn như sau: node-sass <a href="https://github.com/sass/node-sass/releases/tag/v3.4.0" target="_blank" rel="noopener">3.4.0</a>, gulp-sass <a href="https://github.com/dlmanning/gulp-sass/releases/tag/v2.1.0" target="_blank" rel="noopener">2.1.0</a> (nếu sử dụng <a href="https://github.com/gulpjs/gulp" target="_blank" rel="noopener">GulpJS</a>) và grunt-sass <a href="https://github.com/sindresorhus/grunt-sass/releases/tag/v1.1.0" target="_blank" rel="noopener">1.1.0</a> (nếu sử dụng <a href="https://github.com/gruntjs/grunt" target="_blank" rel="noopener">GruntJS</a>)</p><p>Thế còn LESS? Vì tôi không sử dụng LESS nên sẽ không đề cập ở đây. Bạn có thể giúp bổ sung hướng dẫn cho LESS nếu nó có cú pháp trợ giúp tương đương.</p><h2 id="Cac-y-kien-khong-dong-tinh"><a href="#Cac-y-kien-khong-dong-tinh" class="headerlink" title="Các ý kiến không đồng tình"></a>Các ý kiến không đồng tình</h2><p>Vẫn có một số ý kiến hoài nghi và không đồng tình với phương pháp đặt tên này.</p><h3 id="Ten-class-qua-xau"><a href="#Ten-class-qua-xau" class="headerlink" title="Tên class quá xấu"></a>Tên class quá xấu</h3><p>Đồng ý với bạn rằng BEM trông kỳ quặc, tuy nhiên khả năng mà nó đem lại vô cùng lớn và sẽ hoàn toàn xoá mờ hạn chế về mặt “ngoại hình” của nó.</p><p>Ngoài ra BEM đòi hỏi phải gõ nhiều chữ hơn và chiếm nhiều byte ký tự hơn, tuy nhiên với việc sử dụng SASS như trên và việc gzip file đã trở thành tiêu chuẩn như hiện nay, những điều đó không còn là vấn đề so với lợi ích mà BEM mang lại.</p><h3 id="Descendant-selector-van-giai-quyet-duoc-van-de-nhu-truoc-gio"><a href="#Descendant-selector-van-giai-quyet-duoc-van-de-nhu-truoc-gio" class="headerlink" title="Descendant selector vẫn giải quyết được vấn đề như trước giờ"></a>Descendant selector vẫn giải quyết được vấn đề như trước giờ</h3><p>Có một <a href="https://twitter.com/samuelfine/status/575645771334291456" target="_blank" rel="noopener">chỉ trích</a> dành cho BEM thế này: Thay vì viết</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-search</span>        &#123;&#125;</span><br><span class="line"><span class="selector-class">.site-search__field</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.site-search--full</span>  &#123;&#125;</span><br></pre></td></tr></table></figure><p>Họ đặt vấn đề rằng tại sao không viết như thế này:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-search</span>        &#123;&#125;</span><br><span class="line"><span class="selector-class">.site-search</span> <span class="selector-tag">input</span>  &#123;&#125;</span><br><span class="line"><span class="selector-class">.site-search</span><span class="selector-class">.full</span>   &#123;&#125;</span><br></pre></td></tr></table></figure><p>Rõ ràng cả hai cách viết đều có thể giúp hiện thực được component cụ thể này và cách thứ hai có vẻ “gọn gàng” hơn. Tuy nhiên khi CSS của toàn bộ dự án trở nên lớn và phức tạp hơn, thì rất khó tránh khỏi các kiểu được định nghĩa chồng chéo lên nhau ngoài tầm kiểm soát.</p><p>Thử tưởng tượng <code>.site-search</code> cũng nằm trong một container tên <code>.main</code> và những <code>input</code> bên trong <code>.main</code> cần được style với <code>.main input</code>. Như vậy, <code>input</code> bên trong <code>.site-search</code> sẽ bị điều chỉnh một cách không mong muốn.</p><p>Tương tự, nếu như <code>.full</code> trong ví dụ trên hoặc một tên phổ biến như <code>.label</code> được dùng như modifier, thì sẽ có rủi ro (rất cao) là một ngày nào đó một lập trình viên khác định nghĩa một class global trùng tên và sẽ làm hỏng style của element kia.</p><p>Ngoài ra, khi bạn đọc trong ngữ cảnh HTML, bạn sẽ khó thấy được quan hệ ràng buộc giữa <code>input</code> và <code>.full</code> với block <code>.site-search</code>.</p><h3 id="“Toi-don-gian-la-khong-thich-ky-phap-nay”"><a href="#“Toi-don-gian-la-khong-thich-ky-phap-nay”" class="headerlink" title="“Tôi đơn giản là không thích ký pháp này”"></a>“Tôi đơn giản là không thích ký pháp này”</h3><p>Một số người khi nhìn thấy cách đặt tên BEM đã ngay lập tức bác bỏ nó. Họ không thích BEM, đó là quyền của họ, tuy nhiên sẽ là vô lý nếu phản bác việc cần có một số quy tắc đặt tên để dễ dàng nắm bắt và quản lý CSS trong dự án trung và lớn.</p><p>Hơn nữa, bạn hoàn toàn có thể nghĩ ra cho mình một cách đặt tên khác cho hợp sở thích, nhưng vẫn dựa trên nguyên tắc của BEM đã đề ra. Là kết quả đúc kết từ những kiến trúc CSS lớn và phức tạp trước đây, đề xuất của BEM không phải vô tình lại có một số điểm chung với các phương pháp quản lý CSS khác như SMACSS hay OOCSS. Lấy ví dụ khái niệm module của SMACSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ví dụ một module */</span></span><br><span class="line"><span class="selector-class">.btn</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modifier của một module */</span></span><br><span class="line"><span class="selector-class">.btn-primary</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Btn Module với State */</span></span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.is-collapsed</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>Trong các phương pháp quản lý CSS vừa kể trên thì chỉ có BEM là làm rõ được mối quan hệ với các thành phần con bên trong.</p><p>Tóm lại, mỗi phương pháp đều có ưu nhược điểm. Quan trọng là cả team phải có phương pháp tiếp cận khoa học và áp dụng triệt để thì kiến trúc CSS của cả dự án mới vững và dễ bảo trì.</p><h2 id="Cau-hoi-thuong-gap"><a href="#Cau-hoi-thuong-gap" class="headerlink" title="Câu hỏi thường gặp:"></a>Câu hỏi thường gặp:</h2><p>❓<strong>Hỏi:</strong> Element có modifier hay không?<br>💬️ <strong>Đáp:</strong> Có. Element có thể có modifier riêng của nó. Ví dụ:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.accordion__copy--open</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>❓<strong>Hỏi:</strong> Có cần phải đặt tên class cho tất cả element (thẻ HTML) trong block hay không?<br>💬️ <strong>Đáp:</strong> Không cần thiết, chỉ những element cần có style riêng được viết trong CSS. Tuy nhiên cũng không nên lạm dụng những thẻ wrapper (phổ biến nhất là DIV) một cách vô tội vạ và không có chức năng vai trò cụ thể nào. Như vậy việc đặt tên element con cũng khiến bạn phải suy nghĩ một tag nào đó có thật sự cần thiết thêm vào trong block hay không.</p><p>❓<strong>Hỏi:</strong> Bên trong element con <code>foo</code> có một tag đóng vai trò một element con <code>bar</code> khác của block, vậy việc đặt tên class cho element <code>bar</code> này như thế nào? Có nên đặt là <code>.block__foo__bar</code>?<br>💬️ <strong>Đáp:</strong> Vẫn đặt bằng tên block và hai gạch dưới rồi đến tên element <code>.block__bar</code>, không chen giữa bằng <code>foo__</code>. Nói tóm lại, tên của element chỉ cần thể hiện quan hệ phụ thuộc với block, không cần phải chỉ rõ sự lồng bên trong nhau của các element con. (Xem thêm ví dụ trong câu hỏi tiếp theo)</p><p>❓<strong>Hỏi:</strong> Một thẻ HTML có thể là element của 2 block khác nhau không?<br>💬️ <strong>Đáp:</strong> Hoàn toàn có thể. Hãy xem ví dụ sau:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn--big btn--orange"</span> <span class="attr">href</span>=<span class="string">"http://int3ractive.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__price"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon icon--dollar-sign btn__icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>9.99<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"btn__text"</span>&gt;</span>Subscribe<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Button có biểu tượng dollar-sign là một block <code>.icon</code>. Có thể trong block <code>.btn</code>, biểu tượng dollar-sign cần được style riêng, nên cần có một cái tên xác định rõ vai trò và style cho element này là <code>.btn__icon</code>. Nếu block <code>.icon.icon--dollar-sign</code> được dùng ở một ngữ cảnh khác, thì rõ ràng nó không cần class <code>.btn__icon</code> nữa vì tên class đã chỉ rõ sự ràng buộc với block <code>.btn</code> và chỉ được thêm vào khi ở bên trong nó.</p><p>❓<strong>Hỏi:</strong> Một element con có thể đóng vai trò là block của riêng nó không? Có thể xây dựng chuỗi component phụ thuộc nhau như <code>.a__b__c</code> không?<br>💬️ <strong>Đáp:</strong> Câu hỏi này thật sự ngoài tầm hiểu biết và kinh nghiệm của tôi. Có thể có những hoàn cảnh đặt biệt như vậy. Tuy nhiên, theo tôi, nếu có cũng không nên quá 2 cấp, tức là element con chỉ đặt đến <code>.a__b__c</code> là tối đa. Điều này là để sự phụ thuộc không quá sâu, làm giảm khả năng dùng lại của block (portability) và sự linh hoạt của các đối tượng CSS theo tinh thần OOCSS. Xem ví dụ bên dưới.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* block list */</span></span><br><span class="line"><span class="selector-class">.list</span> &#123; &#125;</span><br><span class="line"><span class="comment">/* item là con của list */</span></span><br><span class="line"><span class="selector-class">.list__item</span> &#123; &#125;</span><br><span class="line"><span class="comment">/* link là con của block list__item, để phân biệt với list__link</span></span><br><span class="line"><span class="comment">hoặc chỉ rõ mối quan hệ phụ thuộc giữa item và link*/</span></span><br><span class="line"><span class="selector-class">.list__item__link</span> &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="Sai-lam-hay-mac-phai-khi-su-dung-BEM"><a href="#Sai-lam-hay-mac-phai-khi-su-dung-BEM" class="headerlink" title="Sai lầm hay mắc phải khi sử dụng BEM:"></a>Sai lầm hay mắc phải khi sử dụng BEM:</h2><p>Tôi xin hẹn lại về vấn đề này trong một bài viết khác, khi mà bản thân đã ứng dụng nhiều và quan sát được những ví dụ thực tiễn hơn để tổng hợp những sai lầm hay mắc phải do ảnh hưởng từ phương pháp cũ cũng như cách hiểu chưa đúng về phương pháp BEM này.</p><p>Xem thêm:</p><ul><li>Bài viết <a href="http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/" target="_blank" rel="noopener">giới thiệu BEM của CSSWizadry</a></li><li>Bài viết <a href="http://www.smashingmagazine.com/2012/04/a-new-front-end-methodology-bem/" target="_blank" rel="noopener">giới thiệu BEM của Smashing Magazine</a></li><li><a href="http://webuniverse.io/css-organization-naming-conventions-and-safe-extend-without-preprocessors/" target="_blank" rel="noopener">Sử dụng BEM và @extend của SASS</a></li><li>Bài viết <a href="https://medium.com/fed-or-dead/battling-bem-5-common-problems-and-how-to-avoid-them-5bbd23dee319" target="_blank" rel="noopener">5 sai lầm phổ biến với BEM</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Ky-phap-BEM-la-gi&quot;&gt;&lt;a href=&quot;#Ky-phap-BEM-la-gi&quot; class=&quot;headerlink&quot; title=&quot;Ký pháp BEM là gì&quot;&gt;&lt;/a&gt;Ký pháp BEM là gì&lt;/h2&gt;&lt;p&gt;BEM viết tắt của Blocks, Elements, Modifiers, là một phương pháp đặt tên class cho HTML và CSS. Được phát triển &lt;a href=&quot;https://en.bem.info&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tại Yandex&lt;/a&gt; giúp lập trình viên hiểu rõ hơn mối quan hệ giữa HTML và CSS trong dự án front end.&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://nthung2112.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Giới thiệu Progressive Web App</title>
    <link href="http://nthung2112.github.io/2018/05/Gioi-thieu-Progressive-Web-App.html"/>
    <id>http://nthung2112.github.io/2018/05/Gioi-thieu-Progressive-Web-App.html</id>
    <published>2018-05-18T00:30:00.000Z</published>
    <updated>2018-05-18T00:43:05.756Z</updated>
    
    <content type="html"><![CDATA[<p><strong>P</strong>rogressive Web App (PWA) là một dạng ứng dụng web (web app) mới đang thu hút rất nhiều sự quan tâm từ các nhà phát triển web khắp thế giới đặc biệt là các doanh nghiệp hoạt động trực tuyến, tuy nhiên nó vẫn còn khá mới mẻ tại Việt Nam.<br><a id="more"></a><br>Đã có nhiều bài viết liên quan đến PWA dành cho <a href="https://addyosmani.com/blog/getting-started-with-progressive-web-apps/" target="_blank" rel="noopener">lập</a> <a href="https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/" target="_blank" rel="noopener">trình</a> <a href="https://www.smashingmagazine.com/2016/08/a-beginners-guide-to-progressive-web-apps/" target="_blank" rel="noopener">viên</a>, cho nên trong bài viết này tôi sẽ cố gắng giải thích PWA để người dùng Web phổ thông vẫn có thể hiểu.</p><h2 id="Progressive-Web-App-la-gi"><a href="#Progressive-Web-App-la-gi" class="headerlink" title="Progressive Web App là gì?"></a>Progressive Web App là gì?</h2><p><strong>PWA là ứng dụng web được viết để tận dụng những tính năng mới nhất của trình duyệt Web trên máy tính để bàn (desktop) lẫn điện thoại thông minh, nhưng đồng thời vẫn chạy được trên những trình duyệt và thiết bị cũ hơn. PWA lấy phương pháp <a href="https://www.youtube.com/watch?v=5oUSzo1oRv0" target="_blank" rel="noopener">Cải Tiến Tăng Dần (Progressive Enhancement)</a> làm cốt lõi (nên mới có chữ Progressive).</strong></p><p>Đối với những trình duyệt và thiết bị cũ, PWA hoạt động như một mobile website thông thường. Nhưng với những trình duyệt trên thiết bị di động mới nhất, PWA hoạt động như một <em>mobile app</em>[^1] thực thụ.</p><p>Những tác giả của khái niệm PWA (đến từ nhóm phát triển trình duyệt Chrome) đã đưa ra những đặc tính cần có của một PWA như sau:</p><ul><li><strong>Progressive</strong> - Chạy được trên <em>mọi</em> (nên hiểu: tuyệt đại đa số) thiết bị, do được phát triển với phương pháp Cải Tiến Tăng Dần.</li><li><strong>Responsive</strong> - Có thiết kế <em>giao diện tùy ứng</em> (responsive design), hiển thị và sử dụng được trên mobile, tablet, laptop hay bất kỳ cỡ màn hình nào trong tương lai.</li><li><strong>Connectivity independent</strong> - PWA vẫn có thể hoạt động tốt với điều kiện kết nối mạng chập chờn hoặc mất hẳn (offline).</li><li><strong>App-like</strong> - Có giao diện và trải nghiệm như mobile app thực thụ.</li><li><strong>Fresh</strong> - Dù nó hoạt động như mobile app, nhưng tính năng và giao diện luôn được cập nhật tức thời nhờ nền tảng Web (không cần người dùng update từ Apple App Store hay Google Play - gọi chung là app store).</li><li><strong>Safe</strong> - PWA phải được tải thông qua giao thức TLS (hay nôm na là HTTPS), để đảm bảo việc trao đổi dữ liệu không bị bên thứ ba can thiệp.</li><li><strong>Discoverable</strong> - Thông qua file khai báo chuẩn (được thống nhất bởi tổ chức W3C), mà các PWA dễ dàng được các cỗ máy tìm kiếm đánh dấu và thông báo cho người dùng.</li><li><strong>Re-engageable</strong> - PWA cho phép việc tái tiếp cận người dùng dễ dàng hơn nhờ những tính năng đặc biệt như là push notification (thông báo chủ động).</li><li><strong>Installable</strong> - PWA cho phép người dùng dễ dàng lưu lại web app trên điện thoại (thường là trên màn hình home screen) mà không cần phải vào app store</li><li><strong>Linkable</strong> - Dễ dàng share app chỉ với đường link và không cần người nhận phải cài đặt phức tạp chỉ để xem được nội dung bạn muốn share.</li></ul><h2 id="Nhung-diem-khac-biet-cua-Progressive-Web-App"><a href="#Nhung-diem-khac-biet-cua-Progressive-Web-App" class="headerlink" title="Những điểm khác biệt của Progressive Web App?"></a>Những điểm khác biệt của Progressive Web App?</h2><p>Trước tiên cần hiểu rằng, sự tiến hóa của mobile web app cần sự hợp tác của rất nhiều bên liên quan trong đó có các nhà phát triển trình duyệt, hệ điều hành di động, và cả những chuyên gia về ngôn ngữ lập trình cho Web. Sự tiến hóa của mobile web thường đi cùng với sự phát triển và chuẩn hóa của nền tảng Web do tổ chức <strong>W3C</strong>[^2] chịu trách nhiệm.</p><p>Khi tôi tư vấn và phát triển app cho khách hàng, rất nhiều lần doanh nghiệp từ chối lựa chọn giải pháp web app hoặc hybrid app với lý do chính là <em>“HTML5 không nhanh bằng native”</em>. Tuy nhiên điều này không còn đúng tại thời điểm hiện tại.</p><p>Nhờ những cải tiến của phần cứng thiết bị, hệ điều hành di động, trình duyệt, và nhất là đặc tả Web trong vài năm gần đây mà web app đã thêm những khả năng không thua kém native app như:</p><ul><li>Giao diện tương tác mượt mà hơn, đặt biệt là hỗ trợ đồ họa 3D, animation từ phần cứng (hardware accelerated)</li><li>Khả năng chơi video, audio thông qua trình duyệt mobile đã hoàn thiện và định dạng gần như đã thống nhất.</li><li>Bàn phím ảo thích ứng với trường nhập web form khác nhau: email, URL, telephone…</li><li>Có khả năng truy xuất các sensor và bộ phận đa phương tiện của thiết bị: định vị GPS, con quay hồi chuyển, trạng thái pin, network, camera, microphone…</li><li>Cơ sở dữ liệu (CSDL) tại trình duyệt cho phép tìm kiếm và truy cập nhanh lượng dữ liệu lớn và cho phép người dùng trở lại trang web app nhanh hơn.</li><li>Đặc tả mới về CSS cho phép designer và front end developer tạo giao diện tùy ứng (responsive design) và giao diện giống app dễ dàng hơn.</li></ul><p>Dù vậy, web app vẫn còn một số hạn chế so với native app. Chúng ta hãy xem PWA đã được bổ sung những khả năng gì để có thể xóa dần khoảng cách giữa web và native:</p><h2 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h2><p>Được giới thiệu chính thức <a href="https://en.wikipedia.org/wiki/Progressive_Web_Apps" target="_blank" rel="noopener">từ 2015</a>, PWA đã trải qua thời gian thử nghiệm và trưởng thành đủ lâu để giờ đây chúng ta có thể khẳng định PWA chính là tương lai của Web và Web App.</p><p>PWA đóng góp thêm một giải pháp ứng dụng di động nhiều hứa hẹn, giải phóng doanh nghiệp khỏi sự lệ thuộc vào app store, những hạn chế của native app. Và nếu được thiết kế hợp lý, PWA sẽ là giải pháp hợp nhất cho “mọi nền tảng” từ desktop đến mobile.</p><hr><h4 id="Ghi-chu"><a href="#Ghi-chu" class="headerlink" title="Ghi chú:"></a>Ghi chú:</h4><p>[^1]: Xin tóm tắt lại một số thuật ngữ về <strong>“app”</strong> trên thiết bị di động:</p><ul><li>Mobile app hoặc native app: (ở Việt Nam thường gọi tắt là “app”) là ứng dụng được cài đặt từ app store, được viết bằng ngôn ngữ lập trình dành riêng cho từng hệ điều hành di động khác nhau.</li><li>(Mobile) web app: là website chạy trên trình duyệt của smart phone nhưng có trải nghiệm giống app và thường trao đổi nhiều dữ liệu giữa người dùng và website.</li><li>Hybrid app: là ứng dụng được cài đặt từ app store, tuy nhiên được viết bằng cùng ngôn ngữ lập trình với web app. Dù hybrid app có thể cài được trên nhiều HĐH khác nhau nhưng nó chỉ cần được viết cùng một bộ mã nguồn với một ít điều chỉnh riêng cho mỗi loại HĐH mà nó hỗ trợ.</li></ul><p>[^2]: Tổ chức World Wide Web Consortium có trách nhiệm chuẩn hóa các đặc tả về Web và khuyến khích các trình duyệt khác nhau phải tuân theo để các website hoạt động một cách đồng nhất bất kể trình duyệt dùng để hiển thị.</p><p>[^3]: URL là đường link đến một trang web bất kỳ</p><p>[^4]: Các trình duyệt phổ biến nhất bao gồm: Chrome, Firefox, Safari, MS Edge, Opera, Samsung Internet, UC Browser. Tại Việt Nam, trình duyệt phổ biến thứ 2 sau Chrome là CocCoc. Tuy nhiên CocCoc cũng là một trình duyệt biến thể từ mã nguồn mở của Chrome nên những tính năng của PWA cũng sẽ được hỗ trợ.</p><p>[^5]: Người dùng sẽ vẫn nhận được push notification cho dù họ không lưu app về home screen chỉ cần họ đã bấm đồng ý nhận push notification. Việc yêu cầu gửi push notification cần thận trọng và chỉ thực hiện khi người dùng đã thể hiện sự quan tâm đến dịch vụ của bạn. (Nếu không khả năng người dùng từ chối nhận push notification là rất cao)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;P&lt;/strong&gt;rogressive Web App (PWA) là một dạng ứng dụng web (web app) mới đang thu hút rất nhiều sự quan tâm từ các nhà phát triển web khắp thế giới đặc biệt là các doanh nghiệp hoạt động trực tuyến, tuy nhiên nó vẫn còn khá mới mẻ tại Việt Nam.&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://nthung2112.github.io/tags/javascript/"/>
    
      <category term="pwa" scheme="http://nthung2112.github.io/tags/pwa/"/>
    
  </entry>
  
</feed>
