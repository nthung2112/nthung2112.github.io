{"meta":{"title":"Learn and Share","subtitle":null,"description":"Learn any share","author":"Hung Tan Nguyen","url":"http://nthung2112.github.io"},"pages":[{"title":"About me","date":"2017-03-09T01:12:38.000Z","updated":"2017-08-20T15:08:41.686Z","comments":true,"path":"about/index.html","permalink":"http://nthung2112.github.io/about/index.html","excerpt":"","text":"Hi all, Tôi là Hung Tan Nguyen. Tôi viết blog này mục đích để note lại những kiến thức mình đã tham khảo và học hỏi được, bên cạnh đó mình cũng muốn chia sẻ những kinh nghiệm của mình để nâng cao thêm kiến thức của mình. Thanks all."},{"title":"Tags","date":"2017-03-09T14:16:54.197Z","updated":"2017-03-09T14:16:54.197Z","comments":true,"path":"tags/index.html","permalink":"http://nthung2112.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-03-09T14:16:54.197Z","updated":"2017-03-09T14:16:54.197Z","comments":true,"path":"categories/index.html","permalink":"http://nthung2112.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Web Architecture 101","slug":"Web-Architecture-101","date":"2019-01-06T16:31:00.000Z","updated":"2019-01-06T16:34:26.744Z","comments":true,"path":"2019/01/Web-Architecture-101.html","link":"","permalink":"http://nthung2112.github.io/2019/01/Web-Architecture-101.html","excerpt":"Khái niệm kiến trúc web cơ bản mà tôi ước tôi biết khi mới trở thành developer. Biểu đổ trên trình bày khá đủ về kiến trúc của chúng tôi ở Storyblocks. Nếu bạn không phải là một web developer lâu năm thì ảnh trên trông sẽ khá phức tạp. Việc mổ xẻ dưới đây chắc sẽ giúp nó dễ tiếp cận hơn trước khi chúng ta đào sâu vào chi tiết của mỗi thành phần.","text":"Khái niệm kiến trúc web cơ bản mà tôi ước tôi biết khi mới trở thành developer. Biểu đổ trên trình bày khá đủ về kiến trúc của chúng tôi ở Storyblocks. Nếu bạn không phải là một web developer lâu năm thì ảnh trên trông sẽ khá phức tạp. Việc mổ xẻ dưới đây chắc sẽ giúp nó dễ tiếp cận hơn trước khi chúng ta đào sâu vào chi tiết của mỗi thành phần. Người dùng search trên Google từ khóa “Strong Beautiful Fog And Sunbeams In The Forest”. Kết quả đầu tiên đến từ Storyblocks, trang stock và vector của chúng tôi. Người dùng click vào kết quả và được chuyển tiếp đến trang chi tiết về bức ảnh. Về cơ bản là trình duyệt của người dùng gửi một request đến server DNS để tìm cách liên hệ với Storyblocks, và sau đó gửi request. Request này sẽ gửi đến load balancer, và nó chọn ngẫu nhiên 1 trong số các web server chúng tôi đang chạy để xử lý request. Web server tìm thông tin về ảnh từ caching service và lấy dữ liệu còn lại từ database. Cũng lưu ý rằng “hồ sơ màu” của bức ảnh chưa được tính toán, nên chúng tôi gửi một job đến hàng đợi “job queue”, và job server sẽ xử lý đồng bộ, đồng thời cập nhật database với kết quả có được sau khi xử lý. Tiếp đó, chúng tôi thử tìm những bức ảnh tương tự bằng cách gửi một request đến service “full text search” với đầu vào là tiêu đề bức ảnh. Người dùng tình cờ đăng nhập vào Storyblocks với tư cách thành viên thì chúng tôi tìm thông tin tài khoản từ “account service”. Cuối cùng, chúng tôi bắn một sự kiện đến firehose để lưu lại trên hệ thống lưu trữ đám mây và load vào data warehouse, thứ sẽ được phân tích để trả lời những câu hỏi về business. Server render HTML view và gửi nó trở lại trình duyệt của người dùng, trước hết thông qua load balancer. Trang web chứa JavaScript và CSS được load từ hệ lưu trữ đám mấy, nó kết nối với CDN, nên trình duyệt của người dùng có thể liên hệ với CDN để nhận nội dung. Sau cùng, trình duyệt hiển thị trang web cho người dùng. Giờ tôi sẽ đi lần lượt từng thành phần, giới thiệu theo kiểu “101 …” nhằm cung cấp cho bạn một mô hình chuẩn để suy nghĩ về kiến trúc web (web architecture) về sau. 1. DNSDNS là viết tắt của “Domain Name Server” và nó là công nghệ xương sống để để www (world wide web) trở nên khả dĩ. Ở mức độ cơ bản thì DNS cung cấp một tham chiếu key/value từ domain name (chẳng hạn google.com …) đến một địa chỉ IP (chẳng hạn 85.129.83.120 …), giúp máy tính điều hướng request đến server tương ứng. Tương tự với số điện thoại, sự khác biệt giữa domain và địa chỉ IP chính là sự khác biệt giữa việc “gọi John Doe” và “gọi đến số 201-867-5309”. Bạn cần một danh bạ để tìm số của John, và tương tự, bạn cần DNS để tìm địa chỉ IP cho domain (tên miền). Thế nên bạn có thể xem DNS là một cuốn danh bạ cho internet. Còn nhiều điều chi tiết hơn mà chúng ta có thể đề cập đến nhưng tôi sẽ bỏ qua vì nó không phải ở mức giới thiệu kiểu “101”. P/S: 101 là gì thì đọc ở đây nhé http://www.slate.com/articles/news_and_politics/explainer/2006/09/101_101.html 2. Load Balancer (Cân bằng tải)Trước khi đi sâu vào cân bằng tải, chúng ta cần thảo luận về “horizontal scaling“ (mở rộng theo chiều ngang) và “vertical scaling“ (mở rộng theo chiều dọc). Chúng là gì và khác nhau như thế nào? Đơn giản “horizontal scaling” nghĩa là mở rộng quy mô bằng cách thêm nhiều máy tính vào nguồn tài nguyên, trong khi “vertical scaling” nghĩa là tăng cường sức mạnh cho một máy tính đã có (chẳng hạn như CPU, RAM). Trong web development, gần như bạn luôn muốn mở rộng theo kiểu “horizontal”. Vì, server có thể bỗng dưng bị chết, mạng gặp sự cố, toàn bộ trung tâm dữ liệu thường xuyên mất mạng. Có nhiều hơn một server cho phép bạn lập kế hoạch cho các sự cố để ứng dụng vẫn tiếp tục chạy (fault tolerant). Lý do thứ hai, “horizontal scaling” sẽ cho bạn kết hợp tối thiểu các phần backend khác nhau của ứng dụng (web server, database, service X, …) bằng cách để chúng chạy trên nhiều server. Cuối cùng, bạn có thể mở rộng quy mô đến một mức mà “vertical scaling” không thể làm được. Đó là vì không có một máy tính nào trên thế giới đủ lớn để thực hiện tất cả tính toán cho ứng dụng. Hãy nghĩ nền tảng tìm kiếm của Google như một ví dụ điển hình (dù điều này ứng dụng cho các công ty ở quy mô bé hơn nhiều). Storyblocks, chạy từ 150 đến 400 AWS EC2 tại thời điểm viết bài này, để đạt được khối lượng tính toán ấy bằng “vertical scaling” là một thách thức rất lớn. Trở lại với cân bằng tải, chúng là ma thuật để mở rộng theo kiểu “horizontal”, điều hướng incoming request đến một trong nhiều server và gửi phản hồi từ server về client. Bất kỳ server nào cũng phải xử lý request theo cùng một cách, do đó chỉ còn lại một vấn đề là phân bổ request qua nhiều server để chúng không bị quá tải (overload). Vậy đó, khái niệm cân bằng tải khá đơn giản. Tất nhiên công nghệ nằm phía sau nó rất phức tạp nhưng không cần đề cập với phiên bản “101” làm chi. 3. Web Application ServersWeb server là nơi thực thi business logic, xử lý request của user và gửi lại HTML đến trình duyệt của user. Để làm việc đó, chúng kết nối với nhiều infra phía back-end như database, caching layer, job queue, search service, microservice, data/logging queue, … Như đã đề cập ở trên, ít nhất 2 server thường được kết nối với cân bằng tải để xử lý request của người dùng. Bạn nên biết rằng triển khai server yêu cầu một ngôn ngữ cụ thể (Node.js, Ruby, PHP, Scala, Java, C# .NET, …) và một web framework cho ngôn ngữ đó (Express, Ruby on Rails, Play, Laravel, …). Tuy nhiên đi sâu vào chi tiết của những ngôn ngữ này nằm ngoài phạm vi của bài viết. 4. Database ServersMọi ứng dụng web hiện đại đều sử dụng một hoặc nhiều database để lưu trữ thông tin. Database cung cấp phương thức để định nghĩa cấu trúc dữ liệu, insert dữ liệu mới, tìm dữ liệu đã có, cập nhật hoặc xóa dữ liệu, thực hiện tính toán, … Dù tôi tránh đào sao vào một công nghệ cụ thể cho mỗi thành phần của kiến trúc web, sẽ rất tệ nếu tôi không đề cập đến SQL và NoSQL. SQL là viết tắt của “Structured Query Language” (ngôn ngữ truy vấn có cấu trúc) được phát minh vào thập niên 70 của thế kỷ trước, cung cấp một chuẩn để truy vấn dữ liệu. SQL database lưu trữ dữ liệu theo bảng, được liên kết với nhau thường bằng ID. Hãy lấy một ví dụ cơ bản về lưu trữ địa chỉ của người dùng. Bạn có 2 bảng, users và _user_addresses_, liên kết với nhau bằng id của người dùng. NoSQL, nghĩa là “Non-SQL”, là một công nghệ cơ sở dữ liệu mới hơn, dùng để xử lý khối lượng dữ liệu lớn được sinh ra bởi những ứng dụng web có quy mô lơn (hầu hết các biến thể của SQL không scale theo kiểu “horizontal” tốt và chỉ có thể scale theo kiểu “vertical” đến một mức độ nhất định). Nếu bạn không biết gì về NoSQL, tôi đề nghị xem những tài liệu dưới đây: https://www.w3resource.com/mongodb/nosql.php http://www.kdnuggets.com/2016/07/seven-steps-understanding-nosql-databases.html https://resources.mongodb.com/getting-started-with-mongodb/back-to-basics-1-introduction-to-nosql 5. Caching ServiceMột caching service (dịch vụ lưu bộ nhớ đệm) cung cấp lưu trữ dữ liệu theo kiểu “key/value” đơn giản giúp nó tìm kiếm thông tin với thời gian gần như bằng 0. Các ứng dụng thường tận dụng caching service để lưu kết quả của những tính toán đắt đỏ để nhận kết của từ bộ nhớ đệm thay vì phải tính toán lại một lần nữa khi cần. Ứng dụng có thể cache kết quả của một truy vấn cơ sở dữ liệu, gọi đến một dịch vụ bên ngoài, cache HTML của một đường link, … Dưới đây là một vài ví dụ thực tế: Google lưu kết quả tìm kiếm cho những truy vấn thông thường như “dog” hoặc “Taylor Swift” để không phải tính toán lại mỗi lần Facebook lưu nhiều dữ liệu bạn nhìn thấy khi đăng nhập, chẳng hạn bài viết, bạn bè… Bạn có thể đọc chi tiết về Facebook caching ở đây. Storyblocks lưu HTML output, kết quả tìm kiếm, … Hai công nghệ caching phổ biến nhất là Redis và Memcache. 6. Job Queue &amp; ServersHầu hết ứng dụng web đều cần làm một số công việc bất đồng bộ ở phía back-end mà không kết hợp trực tiếp vào dữ liệu trả về cho người dùng. Chẳng hạn, Google cần crawl và index toàn bộ internet để trả về kết quả tìm kiếm. Nó không được làm mỗi lần bạn tìm kiếm. Thay vào đó, nó crawl các trang web một cách bất đồng bộ, và cập nhật index theo thời gian. Mặc dù có nhiều kiến trúc khác nhau cho các công việc bất đồng bộ, nhưng phố biến nhất là kiến trúc “job queue”. Nó chứa 2 thành phần: một hàng đợi “job” cần được chạy, và một hoặc nhiều “job server” (hay còn lại là worker) để chạy job trong hàng đợi. Job queue chứa một danh sách job cần được chạy bất đồng bộ. Hàng đợi đơn giản nhất là FIFO (first in first out) mặc dù hầu hết ứng dụng sẽ cần một vài hàng đợi có ưu tiên. Mỗi khi ứng dụng cần chạy job thì nó chỉ cần thêm job đó vào hàng đợi. Storyblocks, chẳng hạn, tận dụng “job queue” để hỗ trợ rất nhiều công việc phía back-end nhằm phục vụ thị trường của chúng tôi. Chúng tôi chạy job để encode video và ảnh, xử lý file CSV, thống kê người dùng, gửi mật khẩu reset email, … Lúc đầu chúng tôi sử dụng hàng đợi FIFO đơn giản, sau đó nâng cấp lên hàng đợi ưu tiên để đảm bảo rằng những hoạt động khẩn như gửi mật khẩu reset email được hoàn thành càng sớm càng tốt. Job server xử lý job. Chúng thăm dò “job queue” để xác định có job cần làm hay không, và nếu có thì chúng sẽ đẩy job vào hàng đợi và thực thi nó. 7. Full-text Search ServiceHầu hết ứng dụng web hỗ trợ một vài chức năng tìm kiếm mà người dùng thường sẽ cung cấp một tham số văn bản (còn gọi là “query”) và ứng dụng trả về kết quả “liên quan”. Công nghệ hỗ trợ đặc tính này thường gọi là “full-text search”, sử dụng index để nhanh chóng tìm tài liệu chứa từ khóa cần truy vấn. Dù có thể thực hiện “full-text search” trực tiếp từ database (chẳng hạn MySQL hỗ trợ full-text search), nó thường chạy một “search service” riêng để tính toán và lưu trữ chỉ mục và cung cấp một giao diện truy vấn riêng. Nền tảng full-text search phổ biến nhất hiện nay là Eltasticsearch, bên cạnh một số lựa chọn khác như Sphinx hoặc Apache Solr. 8. ServicesKhi ứng dụng đạt đến quy mô nhất định, sẽ có một số “service” được tahcs ra để chạy như một ứng dụng riêng. Chúng không được public bên ngoài nhưng ứng dụng và các service khác có thể tương tác với chúng. Storyblocks có một số service như vậy: Account service để lưu trữ dữ liệu người dùng trên tất cả các trang web của chúng tôi, cho phép chúng tôi dễ dàng cung cấp các cơ hội “cross-sell” và tạo những trải nghiệm người dùng nhất quán hơn Content service lưu trữ metadata cho video, audio, ảnh. Nó cũng cung cấp giao diện để download nội dung và xem lịch sử download. Payment service cung cấp giao diện thanh toán bằng thẻ tín dụng. HTML → PDF service cung cấp giao diện đơn giản để sinh ra file PDF từ HTML. 9. DataNgày nay, công ty muốn tồn tại thì phải dựa trên cách họ khai thác dữ liệu. Hầu hết những ứng dụng bây giờ, mỗi lần đạt đến một quy mô nhất định, hãy tận dụng kênh dữ liệu (data pipeline) để đảm bảo rằng dữ liệu được thu thập, lưu trữ và phân tích. Một kênh dữ liệu bao gồm 3 giai đoạn chính: Ứng dụng gửi dữ liệu, sự kiện về tương tác của người dùng cho “firehose” (cung cấp giao diện streaming để nhập và xử lý dữ liệu). Thông thường dữ liệu thô được xử lý sẽ được gửi đến firehose khác. AWS Kinesis và Kafka là hai công nghệ phố biến nhất cho mục đích này. Dữ liệu thô cũng như dữ liệu đã được chuyển đổi được lưu trữ đến cloud. AWS Kinesis cung cấp một setting gọi là “firehose” sẽ lưu dữ liệu thô vào S3 để dễ cấu hình. Dữ liệu được chuyển đổi sẽ được tải vào data warehouse để phân tích. Chúng tôi sử dụng AWS Redshift, mặc dù các công ty lớn khác thường dùng Oracle hoặc công nghệ warehouse độc quyền. Nếu bộ dữ liệu đủ lớn, công nghệ NoSQL MapReduce như Hadoop sẽ được sử dụng để phân tích. Một bước khác không được mô tả trong biểu đồ kiến trúc là: tải dữ liệu từ database của ứng dụng và service vào data warehouse. Chẳng hạn ở Storyblocks, chúng tôi tải VideoBlocks, AudioBlocks, Storyblocks, account service, … vào Redshift mỗi đêm. Điều này cung cấp cho bộ phân tích những dữ liệu tổng thể bằng cách cấp phát dữ liệu business cùng với dữ liệu tương tác của người dùng. 10. Cloud storageDịch vụ đám mây là cách đơn giản nhất để lưu trữ, truy xuất và chia sẻ dữ liệu trên internet, theo AWS. Bạn có thể dùng nó để lưu trữ và truy cập với lợi thế là tương tác với nó quả RESTful API. Amazon S3 là dịch vụ lưu trữ đám mây phổ biến nhất ngày nay, và chúng tôi dựa vào nó để lưu trữ video, ảnh, audio, CSS và JavaScript, dữ liệu sự kiện người dùng và hơn thế nữa. 11. CDNCSN là viết tắt của “Content Delivery Network” và công nghệ cung cấp một cách để phục vụ nội dung tĩnh như HTML, CSS, JavaScript và ảnh trên web nhanh hơn so với việc chỉ dùng một server. Nó hoạt động bằng cách phân tán nội dung qua nhiều “edge server” khắp thế giới để người dùng cuối có thể download nội dung từ “edge server” thay vì từ server gốc. Chẳng hạn như ảnh dưới đây, một người dùng từ Tây Ban Nha request một trang web mà có server gốc là ở New York, nhưng các tài nguyên tĩnh của trang web lại được tải về từ “edge server” của CDN từ Anh.","categories":[],"tags":[{"name":"architecture","slug":"architecture","permalink":"http://nthung2112.github.io/tags/architecture/"}]},{"title":"Một mô hình sử dụng Git branches hiệu quả","slug":"Mot-mo-hinh-su-dung-Git-branches-hieu-qua","date":"2019-01-06T16:24:00.000Z","updated":"2019-01-06T16:27:51.189Z","comments":true,"path":"2019/01/Mot-mo-hinh-su-dung-Git-branches-hieu-qua.html","link":"","permalink":"http://nthung2112.github.io/2019/01/Mot-mo-hinh-su-dung-Git-branches-hieu-qua.html","excerpt":"Mới đầu mình tính viết về git-flow - một tool đơn giản dùng để quản lý Git branches, xong thấy bài viết này về một ví dụ sử dụng Git branches hay quá, nên quyết định dịch luôn. Mở đầuNgay bây giờ, tôi sẽ giới thiệu với các bạn mô hình sử dụng Git mà tôi đã và đang sử dụng trong các dự án khoảng một năm trở lại đây. Đó là một mô hình thực sự thành công, nhưng mãi đến giờ tôi mới có cơ hội để có thể viết về nó và chia sẻ với các bạn. Tôi sẽ không đi vào chi tiết dự án, mà chỉ xoay quanh chiến lược quản lý các phân nhánh mà thôi.","text":"Mới đầu mình tính viết về git-flow - một tool đơn giản dùng để quản lý Git branches, xong thấy bài viết này về một ví dụ sử dụng Git branches hay quá, nên quyết định dịch luôn. Mở đầuNgay bây giờ, tôi sẽ giới thiệu với các bạn mô hình sử dụng Git mà tôi đã và đang sử dụng trong các dự án khoảng một năm trở lại đây. Đó là một mô hình thực sự thành công, nhưng mãi đến giờ tôi mới có cơ hội để có thể viết về nó và chia sẻ với các bạn. Tôi sẽ không đi vào chi tiết dự án, mà chỉ xoay quanh chiến lược quản lý các phân nhánh mà thôi. Trong bài viết dưới đây, tôi sử dụng Git để quản lý version cho toàn bộ source code. Nếu các bạn có hứng thú với việc phân tích dữ liệu thời gian thực dựa vào hoạt động trên Git, có thể tham khảo phần mềm mà GitPrime mà công ty tôi phát triển. Tại sao lại chọn Git?Đã có quá nhiều cuộc chiến nổ ra khi bàn về ưu điểm nhược điểm của Git so với các công cụ quản lý source code tập trung khác (như CVS, SVN). Là một developer, tôi cảm thấy yêu thích Git hơn. Git thực sự đã thay đổi cách suy nghĩ về merging và branching. Những ai đã từng làm việc với CVS/Subversion đều hiểu merging/branching không hề đơn giản, trong tài liệu về CVS/Subversion branching và merging chỉ được nhắc đến ở chapter cuối, dành cho các users có kinh nghiệm. Còn với Git, branching/merging là một phần trong workflow hàng ngày của bạn, được mô tả ở những phần đầu tiên trong Git book. Phân tán, nhưng tập trungMô hình Git mà tôi sử dụng hoạt động xoay quanh một repo trung tâm. Nên nhớ đó “chỉ được xem như” là repo trung tâm, chứ về mặt kỹ thuật thì GIT không hề có cái gì gọi là repo trung tâm cả. Ví dụ như repo origin ở hình bên dưới. Mỗi developer sẽ pull và push với origin. Bên cạnh đó, mỗi người có thể pull những thay đổi từ những người khác để tạo thành các sub teams. Điều này sẽ thực sự có ích khi phải làm việc nhóm 2-3 người trở lên để hoàn thành một feature lớn, mà không phải đẩy source code vẫn đang dở dang lên origin. Ở hình vẽ bên trên, các subteams là Alice-Bob, Alice-David, Clair-David. Về mặt kỹ thuật, đơn giản là Alice định nghĩa một Git remote là bob, trỏ đến repo của Bob, và ngược lại. Những branches chínhRepo trung tâm sẽ chứa hai branches chính hoạt động mãi mãi: master develop Nhánh master tại origin là nhánh quen thuộc với tất cả các Git users. Song song là nhánh develop. origin/master được coi là nhánh chính với HEAD phản ánh trạng thái production-ready. origin/develop được coi là nhánh chính với HEAD phản ánh trạng thái thay đổi mới nhất trong quá trình phát triển, chuẩn bị cho release tiếp theo. Khi source code bên develop đạt đến một mức độ ổn định nào đó và sẵn sàng để release thì sẽ được merge sang bên master và đánh dấu với release number. Như vậy, theo định nghĩa về nhánh master, chúng ta mặc định hiểu rằng khi có thay đổi được merge vào master thì tức là sẽ có một phiên bản production mới được release. Nhờ đó chúng ta có thể sử dụng script để tự động build lên production server mỗi khi có commit ở master. Những branches phụBên cạnh hai branches chính master và develop, mô hình mà tôi đang sử dụng còn có thêm rất nhiều những branches phụ để giúp các team members có thể phát triển song song, dễ dàng tracking theo features, chuẩn bị cho release hoặc fix nhanh các vấn đề production. Khác với hai branches chính kia, các branches phụ này chỉ tồn tại trong một khoảng thời gian ngắn, rồi sẽ bị xoá đi. Feature branches Release branches Hotfix branches Phía trên là các loại branches khác nhau tôi hay sử dụng. Mỗi loại branches lại có một nhiệm vụ riêng, và cách xử lý riêng. Tôi sẽ đi sâu vào phân tích ở đoạn sau. Về mặt kỹ thuật, chả có branch nào là “đặc biệt” so với các branches khác cả. Tất cả chỉ là Git branches thông thường, chúng chỉ được phân loại bằng cách ta sử dụng ra sao thôi. Feature branches Tách từ: develop Merge vào: develop Naming convention: tự do, ngoại trừ master, develop, release-, hotfix- Feature branches (hay còn gọi là topic branches) được sử dụng để phát triển các feature mới phục vụ cho release sau này. Khi bắt đầu phát triển một chức năng, có thể chưa rõ được thời điểm chức năng đó được tích hợp vào hệ thống và release. Feature branch sẽ tồn tại trong quá trình chức năng được phát triển, cuối cùng sẽ được merge lại vào develop (khi quyết định lần release tới bao gồm chức năng đó) hoặc bị bỏ đi (khi thấy chức năng không còn cần thiết). Về cơ bản thì feature branches chỉ tồn tại ở repos của developers, chứ ko phải ở origin. Tạo feature branch1$ git checkout -b myfeature develop Merge vào develop1234$ git checkout develop$ git merge --no--ff myfeature$ git branch -d myfeature$ git push origin develop –no-ff giúp thao tác merge luôn tạo ra một commit mới, ngay cả khi có thể merge theo fast-forward. Flag này giúp chúng ta không bị mất thông tin liên quan đến lịch sử các commits của feature branch. Ở trường hợp bên phải, không thể nhận biết được những commits nào phát triển cùng chức năng nếu không ngồi đọc log message của từng commit. Khi dấy, nếu muốn revert lại cả feature (phải revert nhiều commits liên quan) thì thực sự là đau đầu. Và đó là lý do mà –no-ff được sử dụng. Đương nhiên, nó sẽ tạo ra thêm vài commit, nhưng chả có vấn đề gì cả. Release branches Tách từ: develop Merge vào: develop và master Naming convention: release-* Release branches được sử dụng để chuẩn bị cho release bản production mới. Tất cả các công việc cuối cùng trước khi release sẽ được thực hiện ở đây, ngoài ra còn để fix nốt các bugs lẻ tẻ, chuẩn bị meta-data (version number, build dates, etc..). Nhờ việc tách nhánh ra khỏi develop, chúng ta có thể tiếp tục phát triển các features cho đợt release khác một cách bình thường. Thời điểm được lựa chọn để tách nhánh từ develop là khi develop phản ánh được trạng thái mong muốn cho việc release mới. Ít nhất lúc đó tất cả các features dành cho đợt release phải được merge vào develop rồi. Những features nhắm đến các lần release sau thì chưa được merge vào, phải đợi sau khi tách nhánh. Chúng ta sẽ tiến hành đánh version theo rule của dự án ngay sau khi tạo release branch. Tạo release branch123$ git checkout -b release-1.2 develop$ ./bump-version.sh 1.2$ git commit -a -m &quot;Bumped version number to 1.2&quot; Ở ví dụ trên, bump-version.sh tượng trưng cho một script thay đổi một vài files trong source code để phản ánh version mới. Sau khi tạo branch mới và chuyển sang branch đó, chúng ta sẽ thực hiện nâng version, rồi commit thao tác đó. Branch mới này sẽ tồn tại cho đến khi việc release được thực hiện gọn ghẽ. Trong khoảng thời gian đó, có thể thực hiện fix bugs ở branch này, tuy nhiên nghiêm cấm việc bổ sung feature mới lên đó. Tốt nhất nếu có features mới thì hãy merge vào develop, và đợi đợt release sau. Kết thúc release branchKhi source code trên release branch sẵn sàng để release, đầu tiên, phải merge vào master, sau đó phải đc merge lại vào develop để những lần release sau cũng chứa những thay đổi ở lần này. 123$ git checkout master$ git merge --no-ff release-1.2$ git tag -a 1.2 Vậy là source code đã được release lên master, và đã được tag để tiện sau này tham chiếu. 12$ git checkout develop$ git merge --no-ff release-1.2 Ở bước này, rất có thể sẽ có confict, nên hãy fix nó rồi commit nhé. Bây giờ thì việc release đã hoàn thành, và chúng ta ko cần đến branch này nữa. 1$ git branch -d release-1.2 Hotfix branches Tách từ: master Merge vào: develop và master Naming convention: hotfix-* Hotfix branches cũng giống release branches ở chỗ được sử dụng để chuẩn bị cho việc release production mới, chỉ khác ở chỗ là ko có plan từ trước. Khi có một bug nghiêm trọng trên bản production cần được giải quyết ngay lập tức, một hotfix branch sẽ được tách ra từ master và được đánh version để nhận biết. Ưu điểm của việc tách nhánh này ở chỗ các team members khác có thể tiếp tục công việc ở develop trong khi những người khác có thể tập trung vào fix bug của production. Tạo hotfix branchHotfix branch được tạo ra từ master. Ví dụ hiện tại version 1.2 là phiên bản production đang chạy và xuất hiện lỗi nghiêm trọng. Tuy nhiên source code trên develop vẫn chưa ổn định, vì thế chúng ta phải tách nhánh hotfix và tiến hành sửa lỗi. 123$ git checkout -b hotfix-1.2.1 master$ ./bump-version.sh 1.2.1$ git commit -a -m &quot;Bumped version number to 1.2.1&quot; Sau khi tách nhánh phải tiến hành up version luôn nhé! Sau khi sửa lỗi, hãy thực hiện commit. 1$ git commit -m &quot;Fixed severe production problem&quot; Kết thúc hotfix branchSau khi kết thúc sửa lỗi, những thay đổi phải được merge lại master, đồng thời cũng phải merge vào develop để ngăn lỗi xảy ra ở những lần release sau. Nghe rất giống với xử lý trên release branch phải không. 123456$ git checkout master$ git merge --no-ff hotfix-1.2.1$ git tag -a 1.2.1$ git checkout develop$ git merge --no-ff hotfix-1.2.1 Tuy nhiên, có một điểm cần lưu ý rằng: khi đang tồn tại một release branch thì cần phải merge hotfix vào release branch đó, thay cho develop. Khi release branch được merge vào develop thì cuối cùng những thay đổi trong hotfix cũng được merge vào develop, nên không có vấn đề gì cả. Trừ khi thực sự công việc ở develop cần phần hotfix ngay lập tức và ko thể đợi release branch được merge, thì cần cẩn thận merge hotfix vào develop. Cuối cùng, chúng ta cũng ko cần đến branch này nữa: 1$ git branch -d hotfix-1.2.1","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://nthung2112.github.io/tags/git/"},{"name":"gitflow","slug":"gitflow","permalink":"http://nthung2112.github.io/tags/gitflow/"}]},{"title":"Giới thiệu về Atomic CSS","slug":"Gioi-thieu-ve-Atomic-CSS","date":"2019-01-06T10:18:00.000Z","updated":"2019-01-06T10:39:27.084Z","comments":true,"path":"2019/01/Gioi-thieu-ve-Atomic-CSS.html","link":"","permalink":"http://nthung2112.github.io/2019/01/Gioi-thieu-ve-Atomic-CSS.html","excerpt":"","text":"Những vấn đề với cách viết CSS hiện tạiSpecificity war, thâm cung nội chiếnBạn còn nhớ lần đầu bạn viết CSS giống như thế nào không? Có thể là khai báo style cho một thẻ HTML nào đó. 1234567a &#123; text-decoration: none;&#125;p &#123; color: rainbow;&#125; Sau đó bạn biết thêm về ID và class: 12345678910#header &#123; margin: 10px; text-align: center; color: fabulous;&#125;.text &#123; font-weight: 700; font-size: 20px;&#125; Và bạn học được cách xử lý các pseudo selectors, hoặc khai báo cho các phần tử anh chị em con cháu họ hàng, v.v… 12345678#header &gt; a:first-child &#123; color: unicorn;&#125;#header p &gt; a.text::before &#123; content: '⛓'; font-family: Comic Sans;&#125; Rồi khi bạn đã quen với CSS và bắt tay vào làm dự án thực tế, bạn bàng hoàng nhận ra kẻ thù không ở đâu xa, chúng đang lởn vởn quanh ta í mà. Bạn bước vào cuộc chiến gọi là “specificity war”, đánh nhau tơi bời khói lửa với class được viết bởi các chiến hữu trong team. Quả là một trận đấu kinh hoàng khi ai cũng muốn đè đầu cưỡi cổ (override) người đi trước. Kẻ nắm giữ !important trong tay cứ nghĩ đã gần với chiến thắng, nào ngờ xuất hiện tiểu nhân dùng inline style + !important. Tình anh em sứt mẻ, chiến hữu quay đầu không nhìn mặt nhau. Bạn ức chế và gào lên “đậu phộng CSS 🥜”. Specificity là gì? Specificity là một trọng số được trình duyệt sử dụng để quyết định CSS style nào sẽ được áp dụng cho các element. Specificity được tính toán dựa vào phân loại selector và số lượng selector áp dụng lên một element. Bạn có thể đọc thêm về chủ đề này ở đây hoặc trên trang MDN. http://cssspecificity.com minh hoạ khá cụ thể cách tính specificity. Block__Element–ModifierDân tay to mặt bự đọc đến đây có lẽ đang âm thầm (hoặc công khai) cười khẩy: “Ai kêu gà, xài BEM là được rồi”. Chíp chíp 🐥 Cho những bạn chưa biết: BEM - Block Element Modifier là một phương pháp đặt tên CSS class được phát triển bởi Yandex. Theo lý thuyết, BEM giúp bạn xây dựng các class theo từng block, mỗi block lại có element con, và các element này có thể sẽ có giao diện khác nhau tuỳ thuộc vào modifier của nó. Ví dụ đây là CSS: 123456789101112131415&gt; /* Block */&gt; .btn &#123;&gt; &#125;&gt; &gt; /* Element */&gt; .btn__price &#123;&gt; &#125;&gt; &gt; /* Modifier */&gt; .btn--big &#123;&gt; &#125;&gt; &gt; .btn--green &#123;&gt; &#125;&gt; Áp dụng vào HTML: &lt;button class=&quot;btn btn--big btn--green&quot;&gt;&lt;span class=&quot;btn__price&quot;&gt;$9.99&lt;/span&gt;&lt;/button&gt; Hoàn toàn không sai. BEM là một phương pháp hiệu quả để chia nhỏ trang thành từng component, và bạn hoàn toàn có thể tránh được cuộc thánh chiến ở trên bằng cách chỉ sử dụng class được đặt tên theo BEM. Ngoài ra, khi một component không còn được dùng nữa, bạn có thể tự tin xoá đi class của nó mà không sợ ảnh hưởng đến các component khác. Tuy nhiên BEM cũng có những vấn đề “khó chịu” mà bạn có thể xem thêm ở bài viết Battling BEM CSS: 10 Common Problems And How To Avoid Them. Kinh nghiệm cá nhân là khi làm việc với BEM, có thể bạn sẽ bỏ kha khá thời gian chỉ để suy nghĩ về ngữ nghĩa (semantics) của class. Bạn sẽ phải cân nhắc block này nên đặt tên là gì, những thành phần con của nó có nên là element hay là một component khác, rồi element này nên có tên chi, nên gọi nó là wrapper, container, hay body, v.v… Đừng coi thường việc đặt tên nhé, một trong những vấn đề khó nhai nhất của khoa học máy tính đấy. Ngoài ra tên class thường dính liền với cấu trúc/ nội dung HTML mà nó được sử dụng, dẫn đến việc khi refactor code lại (chuyển thành component tổng quát hơn), chúng ta phải tốn thời gian suy nghĩ tên khác cho hợp lý. Với mình, việc suy nghĩ thêm về ngữ nghĩa cho CSS class không đem lại hiệu quả đáng kể. Vì không giống như HTML, trình duyệt và crawlers không quan tâm bạn đặt tên class có ý nghĩa hay không. Chúng chỉ có giá trị với lập trình viên, và thường thì chúng ta chỉ muốn viết HTML/CSS sao cho giống với thiết kế từ designers nhất mà thôi. Tính tái sử dụng và kích thước tập tin CSSMỉa mai thay, tính chất “cascading” của CSS vốn được sinh ra để hỗ trợ tái sử dụng code lại là một con dao 2 lưỡi và đem đến phiền muộn cho biết bao nhiêu người. Cascading cùng với specificity làm cho CSS trở nên khó dự đoán và lời khuyên là hạn chế cascading được bao nhiêu hay bấy nhiêu. Điều này dẫn đến tập tin CSS chứa nhiều khai báo bị trùng lắp. 123456789.ie6 #footer-content .flex-control-nav li a,.ie7 #footer-content .flex-control-nav li a,.ie8 #footer-content .flex-control-nav li a &#123; float: left;&#125;#nav.challenger-a li.menu-products &#123; float: left;&#125; Khi dự án của bạn phát triển, nhiều component xuất hiện đồng nghĩa với kích thước tập tin CSS ngày càng to ra. Đáng buồn là, không phải tất cả CSS được gửi xuống cho người dùng sẽ thật sự được sử dụng trong trang. Kích thước tập tin CSS của các website lớn, tính đến tháng 11 năm 2016. Nguồn: [1] Vậy atomic CSS giải quyết được những vấn đề trên à?Có thể. Nhưng trước hết hãy xem atomic CSS là gì đã. Atomic CSS là cách khai báo các class sao cho mỗi class chỉ mô tả một tính năng duy nhất. Để xây dựng component lớn hơn, chúng ta sẽ kết hợp các class nguyên tử này lại với nhau. Chẳng hạn như: 12345678910111213.white &#123; color: #fff;&#125;.bg-green &#123; background-color: #3d9970;&#125;.px-10 &#123; padding-left: 10px; padding-right: 10px;&#125;/* Oát đờ hợi (ಠ_ಠ) */ Trong ví dụ trên, class white chỉ làm duy nhất một việc là đổi chữ sang màu trắng, bg-green sẽ thiết lập nền sang màu xanh, trong khi px-10 chỉnh padding ở bên trái và phải (trục x/ trục hoành) thành 10px. Một component được viết theo atomic CSS sẽ giống như thế này: 123&lt;button class=\"b1 b--green bg-green white br-5 ma-10 f3 ttu fw-400 padding-10\"&gt; &lt;span class=\"bg-dark o4 white padding-x-12 fw-600 br-left-5\"&gt;$9.99&lt;/span&gt; Purchase&lt;/button&gt; See the Pen BEM vs atomic CSS by Ehkoo (@ehkoo) on CodePen. Atomic CSS đang được sử dụng bởi các công ty như npm, StackOverflow, Heroku, v.v… Chuyện bên lề: Functional CSS, Atomic CSS, hay Utility-first CSS? “Functional CSS” là tên gọi đầu tiên mình bắt gặp khi tìm hiểu về cách viết CSS này. Từ “functional” ngoài nghĩa như trong “functional programming” còn có nghĩa là “hoạt động” (trích từ điển Oxford). Do đó “functional CSS” có thể hiểu là “CSS hoạt động được”, hoàn toàn không liên quan đến ý tưởng chính: đặt CSS class thành từng hàm nhỏ. Một tên gọi khác là “Atomic CSS”, theo nghĩa mỗi class là một “nguyên tử” độc lập. Tên gọi này rất phù hợp với tiêu chí chia nhỏ class, nhưng đáng tiếc thay khi nó “có thể” nhầm lẫn là có liên quan tới phương thức Atomic Design. Ngoài ra, có một thư viện của Yahoo! cũng tên là Atomic CSS. Cuối cùng, “Utility-first CSS” có lẽ là tên gọi mô tả chính xác nhất. “Utility-first” mang nghĩa “tập trung xây dựng các class hỗ trợ”. Điểm trừ của thuật ngữ này là…tên dài quá. Suy đi xét lại thiệt hơn thì trong bài viết này mình chọn “atomic CSS” (chữ “a” viết thường) vì…gõ nhanh thôi. Nhưng bạn để ý là 3 thuật ngữ này đều dùng chung cho một cách viết CSS nhé. Vậy có gì hay?Tránh cảnh binh đaoLợi ích đầu tiên là cũng giống như BEM, atomic CSS chỉ cho phép khai báo các class nên chúng không xảy ra tranh chấp specificity. Đồng thời vì mỗi class chỉ mô tả một tính năng duy nhất, việc các thuộc tính giẫm chân lên nhau được hạn chế ở mức thấp nhất. Còn vẫn ghét nhau quá, muốn đạp nhau cho chết thì đây: 12345678910&lt;div class=\"red\"&gt; Roses are red &lt;div class=\"blue\"&gt; Violets are blue &lt;div class=\"yellow\"&gt; Honey is sweet &lt;div class=\"brown\"&gt;But not as sweet as you&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Credit: @huytd Tập tin CSS nhẹ hơnBằng cách xây dựng component bằng những class nguyên tử, bạn không cần phải lặp đi lặp lại những khai báo đã có. Khi nhận được thiết kế cho component mới, bạn chỉ cần kết hợp những class đã có sẵn với nhau hoặc viết thêm atomic classes. Những class mới xuất hiện sẽ tiếp tục được tái sử dụng nên số lượng class bạn thêm vào sẽ ngày càng giảm đi khi tuổi thọ của dự án dài ra. Trong bài viết By The Numbers: A Year and Half with Atomic CSS, John Polacek đã thử nghiệm chuyển đổi từ CSS truyền thống sang atomic CSS và kết quả là dung lượng tập tin giảm từ 123.1KB xuống còn 72.7KB (chưa nén gzip). Kết quả cuối cùng là càng ngày bạn sẽ càng viết ít CSS lại. Không phải suy nghĩ chuyện đặt tên classVì các atomic classes được đặt tên gần với thuộc tính của chúng, bạn không cần phải suy nghĩ nên đặt tên gì. Một lợi ích nữa là nhìn vào HTML bạn có thể tương đối biết được style của một element. Lấy ví dụ: 1234567&lt;!-- BEM --&gt;&lt;button class=\"btn btn--big btn--green\"&gt;&lt;span class=\"btn__price\"&gt;$9.99&lt;/span&gt; Purchase&lt;/button&gt;&lt;!-- atomic CSS --&gt;&lt;button class=\"b1 b--green bg-green white br-5 ma-10 f3 ttu fw-400 padding-10\"&gt; &lt;span class=\"bg-dark o4 white padding-x-12 fw-600 br-left-5\"&gt;$9.99&lt;/span&gt; Purchase&lt;/button&gt; Với BEM, bạn có thể sơ đoán “à cái nút này là cái nút màu xanh bự nè”, nhưng “bự” là cái gì “bự”, font size hay height, và cái gì “xanh”, chữ xanh, nền xanh hay viền xanh. Khi đi đến btn__price thì hoàn toàn không thể biết được style của nó. So sánh với atomic CSS, bạn có thể đọc ngay là “nút này có viền 1px, viền màu xanh, nền xanh, chữ trắng, bo tròn góc 5px, margin ở bốn phía 10px, font ở level 3, chữ được chuyển thành chữ hoa có font weight 400, padding bốn phía 10px”. Tương tự với thẻ SPAN, bạn có thể đọc là “nền đen có opacity 0.4, chữ trắng, padding trái phải 12px, font weight 600, bo tròn góc bên trái 5px”. Liệu việc đọc style như thế này có cần thiết? Nếu bạn mới bắt đầu, câu trả lời có thể là không, nhưng khi đã quen rồi, đọc class nhanh giúp bạn debug và thay đổi style dễ dàng hơn. Xây dựng prototype nhanh hơnPrototyping, hay là chuyện làm những giao diện giả để kiểm tra UI/UX, không còn lạ với dân làm frontend nữa. Một trong những lý do bạn chọn Bootstrap, Foundation, hay Bulma… cho dự án vì đơn giản chúng cung cấp những component được xây dựng sẵn, cùng với hệ thống grid và các class hỗ trợ. Nhưng rồi bạn sẽ lâm vào cảnh đánh nhau với các class của framework để tuỳ biến cho phù hợp với chuẩn thiết kế. Kết quả ra sao thì bạn biết rồi. Các framework được thiết kế theo hướng atomic không có nhiều component, nhưng bù lại chúng không đặt quá nhiều ý kiến riêng và ép buộc bạn phải làm theo. Hầu hết đều cho phép bạn tuỳ chỉnh màu sắc, kích thước theo ý, từ đó bạn có thể xây dựng lên những component cần thiết. Hạn chếBùng nổ classTachyons là một trong những atomic CSS framework phổ biến nhất. Trong phiên bản 4.10.0, Tachyons hỗ trợ 37 màu. Giả sử mỗi màu sẽ có class tương ứng với màu chữ, màu nền, màu viền, hover đổi màu chữ, hover đổi màu nền, và hover đổi màu viền. Tachyons có 3 breakpoints. Như vậy tổng số class được tạo ra là 37 x 8 (thuộc tính) x 3 = 888 classes. Nếu bạn phải sử dụng nhiều màu hơn, ví dụ như color palette của Material Design, hỗ trợ nhiều thuộc tính và pseudo selector hơn, thêm vài breakpoints nữa, bạn cũng có thể đoán được số lượng class phình ra như thế nào. Thực tế là không phải tất cả class màu đều được sử dụng, nên việc tạo ra class để bao gồm tất cả các trường hợp là không cần thiết. Cách giải quyết ở đây là chỉ viết thêm class khi bạn thật sự cần đến nó. Tìm và thay đổi class theo yêu cầu mới khó hơnGiả sử một ngày đẹp trời nào đó, đồng chí Nguyễn Văn Xài Nơ quyết định nền màu xanh của tất cả các nút phải đậm hơn chút xíu, nút bự nghĩa là font size phải ở level 2. Với BEM, bạn chỉ cần thay đổi giá trị của class .btn–green và .btn–big là xong. Trong khi đó bạn không thể đổi mã màu của .bg-green bởi vì thay đổi này chỉ áp dụng trên nút và biết đâu được màu cũ vẫn được dùng ở nơi khác. Bạn cũng không thể tuỳ tiện tăng font size của .f3. Giải pháp an toàn nhất là tìm tất cả các nút, xoá đi class cũ và thêm vào f2 bg-dark-green. Bạn tìm các nút bằng cách nào? Search and Replace… bg-green white br-5 ma-10 f3 -&gt; bg-dark-green white br-5 ma-10 f2? Lỡ như có một class nào đó chen vào giữa bg-green white br-5 ma-10 letter-spacing-1 f3 và thế là tèn tén ten. Nếu dự án của bạn sử dụng React, Vue, hay các thư viện hỗ trợ (web) component khác, việc thay đổi này không thành vấn đề. Còn với thuần HTML thì…coi bộ cực đó. Bạn có thể đặt tên cho UI component bằng data-, nhưng như vậy markup sẽ bị rối và ở phía người dùng, các thuộc tính này hoàn toàn không được dùng đến. 123&lt;button data-ui-name=\"button-big-green\" class=\"b1 b--green bg-green white br-5 ma-10 f3 ttu fw-400 padding-10\"&gt; &lt;span class=\"bg-dark o4 white padding-x-12 fw-600 br-left-5\"&gt;$9.99&lt;/span&gt; Purchase&lt;/button&gt; Nghi ngờ từ cộng đồngThành thật mà nói, atomic CSS rất không tự nhiên khi tiếp xúc lần đầu tiên. Chúng ta đã quá quen với cách viết CSS truyền thống/ BEM, và khi nhìn thấy một đống class đi chung với những cái tên xa lạ như ma, px, hay ttu, nghi ngờ là phản ứng rất dễ hiểu. Vậy có khác gì inline style? Nhìn sơ qua thì đúng là giống như inline style vậy, và ai cũng biết inline style là bad practice. Nhưng atomic classes khác hoàn toàn và mạnh mẽ hơn inline style nhiều. Atomic classes cho phép bạn viết media queries, @support, pseudo selectors hay sử dụng animation, những điều mà inline style không làm được. Và vì atomic CSS được lưu trong tập tin CSS, trình duyệt có thể lưu vào bộ nhớ đệm, không giống như inline style. Tên class thấy gớm Kiểu viết tắt ma (margin all), px (padding x), ph (padding horizontal) hay bg rất phổ biến trong cộng đồng atomic CSS. Ban đầu bạn có thể thấy khó hiểu và tốn thời gian để học, nhưng sau một thời gian chúng sẽ trở nên tự nhiên. Ngoài ra còn một số ý kiến phản đối atomic CSS nữa mà nếu muốn, bạn có thể đọc bài viết The Problem with Atomic CSS rồi tự đưa ra nhận xét. Spoiler alert: không phải tất cả luận điểm trong bài đều hợp lý. Tích hợp vào dự ánNếu bạn đọc đến đây và không cảm thấy atomic CSS là một ý tưởng dị hợm thì bài viết này coi như đã thành công. Để dùng atomic CSS trong dự án, bạn có thể chọn cách dùng các thư viện có sẵn, hoặc tự xây dựng thư viện riêng. Dùng hàng ăn sẵnCách này phù hợp với những dự án mới hoặc bạn muốn thử nghiệm với atomic CSS. Hiện tại thì hai thư viện phổ biến nhất là Tachyons và Tailwind. Tachyons có lượng người dùng đông đảo vì xuất hiện trước, nhưng Tailwind lại mạnh mẽ hơn vì cho phép bạn thay đổi màu sắc, kích thước, v.v… hoàn toàn theo ý muốn. Không thì bạn có thể dùng hệ thống thiết kế của StackOverflow hay Heroku cũng được. Sự thật là các atomic classes quá nhỏ nên chúng gần như giống hệt nhau ở tất cả framework, có khác chăng chỉ là tên gọi mà thôi. Tự trồngTrong một dự án đang chạy, nếu muốn áp dụng atomic CSS thì không gì tốt hơn là tự trồng lấy một framework. Các atomic classes rất nhỏ và đơn giản nên hoàn toàn không có gì khó để tự viết cả. Bạn có thể từ từ bóc tách các thuộc tính của các class cũ và chuyển chúng thành atomic classes. Dự án của bạn có thể sắp xếp các tập tin (S)CSS như thế này. 123456789101112131415161718192021styles/utils/├── _animation.scss├── _background.scss├── _border.scss├── _box-shadow.scss├── _color.scss├── _cursor.scss├── _display.scss├── _flex.scss├── _font-size.scss├── _font-weight.scss├── _height.scss├── _letter-spacing.scss├── _line-height.scss├── _list.scss├── _margin.scss├── _max-width.scss├── _padding.scss├── _ratio.scss├── _text-align.scss└── _width.scss Về việc đặt tên, bạn có thể chọn kiểu viết tắt px, ma hay ttu như trong Tachyons, hoặc kiểu đầy đủ padding-x, margin-all, text-transform-uppercase. Cái này tuỳ thuộc vào sở thích của từng team. Ngoài ra, việc viết lặp đi lặp lại nhóm class có thể gây nhàm chán, do đó bạn đừng quên tận dụng các công cụ tiền xử lý CSS như SASS, LESS, hay Stylus để cuộc sống dễ thở hơn. Chẳng hạn như đoạn code dưới đây để tạo ra các class liên quan đến height: 1234567$list: 28 96 128 640;@each $value in $list &#123; .h-#&#123;$value&#125; &#123; height: #&#123;$value&#125;px; &#125;&#125; Khi cần thêm một giá trị mới, bạn chỉ cần bỏ nó vào $list. Bạn cũng có thể dùng mixin để tạo ra các class responsive: 123456789@include media(extra-large) &#123; $list: 28 96 128 640; @each $value in $list &#123; .h-#&#123;$value&#125;-xl &#123; height: #&#123;$value&#125;px; &#125; &#125;&#125; KếtNếu nhóm của bạn đang dùng BEM hay các phương pháp phát triển CSS khác và hài lòng với chúng, bạn có thể không cần atomic CSS. Atomic CSS không phải sinh ra là để triệt tiêu BEM, mà bổ sung và giúp bạn làm việc với CSS một cách hiệu quả hơn. Cuối cùng, hãy xem video này và quyết định có nên xài atomic CSS không nhé ;)","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"atomic","slug":"atomic","permalink":"http://nthung2112.github.io/tags/atomic/"}]},{"title":"Cách Javascript hoạt động P19: Bên trong custom element + thủ thuật xây dựng component tối ưu","slug":"Cach-Javascript-hoat-dong-P19-Ben-trong-custom-element-thu-thuat-xay-dung-component-toi-uu","date":"2019-01-05T17:03:00.000Z","updated":"2019-01-05T17:07:19.212Z","comments":true,"path":"2019/01/Cach-Javascript-hoat-dong-P19-Ben-trong-custom-element-thu-thuat-xay-dung-component-toi-uu.html","link":"","permalink":"http://nthung2112.github.io/2019/01/Cach-Javascript-hoat-dong-P19-Ben-trong-custom-element-thu-thuat-xay-dung-component-toi-uu.html","excerpt":"Đây là bài cuối cùng trong series rồi (chắc vậy á, lâu nay không thấy họ đăng bài mới). Cảm ơn mọi người đã ủng hộ mình trong suốt thời gian qua. Tuy nhiên nếu SessionStack có bài viết nào mới thì mình sẽ cập nhật thêm. Element: phần tử Custom element: phần tử tùy chọn (tức là những element do người dùng tự tạo ra) Component: thành phần Chào các bạn đến với bài thứ 19 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.","text":"Đây là bài cuối cùng trong series rồi (chắc vậy á, lâu nay không thấy họ đăng bài mới). Cảm ơn mọi người đã ủng hộ mình trong suốt thời gian qua. Tuy nhiên nếu SessionStack có bài viết nào mới thì mình sẽ cập nhật thêm. Element: phần tử Custom element: phần tử tùy chọn (tức là những element do người dùng tự tạo ra) Component: thành phần Chào các bạn đến với bài thứ 19 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Khái quátTrong bài trước chúng ta đã thảo luận về Shadow DOM API và 1 vài ý tưởng vốn là các mảnh ghép của 1 bức tranh lớn hơn: web components. Toàn bộ ý tưởng đằng sau tiêu chuẩn web components là có thể mở rộng các tính năng sẵn có của HTML bằng cách tạo ra các element vừa nhỏ gọn, hướng mô đun và có thể tái sử dụng nhiều lần. Đây là 1 tiêu chuẩn tương đối mới trong W3C và đã được chấp nhận bởi đa số các trình duyệt lớn và có thể thấy nó xuất hiện trong nhiều môi trường production… dĩ nhiên là với 1 chút sự giúp đỡ từ các thư viện polyfill mà chúng ta sẽ nói sau.*_Polyfill là để chỉ việc biến đổi, thay thế hoặc chỉnh sửa các tính năng mới của ngôn ngữ JS, HTML, CSS sao cho nó có thể hoạt động được trên các trình duyệt cũ như IE Như các bạn đã biết, trình duyệt cung cấp cho chúng ta 1 số ít các công cụ quan trọng để xây dựng website và các webapp. Ta đang nói về HTML, CSS &amp; Javascript. Bạn dùng HTML để kiến trúc nên app của bạn, CSS để trang điểm và làm cho nó đẹp hơn rồi dùng Javascript thực hiện các hành động khác. Tuy nhiên, trước khi web components được giới thiệu thì không có cách nào dễ dàng để liên kết các hành vi của Javascript đến với kiến trúc của HTML. Trong bài viết này, chúng ta sẽ tìm hiểu về nền tảng của web component: custom element. Nói ngắn gọn, API custom element cho phép bạn tạo ra các custom HTML element với logic Javascript và CSS style tích hợp sẵn. Rất nhiều người cảm thấy bối rối nhầm lẫn custom element với Shadow DOM. Nhưng chúng là 2 ý tưởng hoàn toàn khác nhau và chúng thực sử bổ khuyết cho nhau thay vì thay thế lẫn nhau. Một vài framework và library như Angular, React… cố giải quyết cùng 1 vấn đề bằng cách giới thiệu ý tưởng riêng của họ. Bạn có thể so sánh custom element với Angular directive hoặc React component. Tuy nhiên, custom element gần gũi với trình duyệt mà không yêu cầu gì hơn ngoài bản gốc của Javascript, HTML, CSS. Dĩ nhiên, điều này không có nghĩa rằng nó là bản thay thế cho các Javascript framework điển hình. Các framework hiện đại cho phép chúng ta thực hiện nhiều thứ hơn là chỉ giả lập hành vi của custom element. Vì thế mà chúng có thể cùng hoạt động bên cạnh nhau. APITrước khi chúng ta đào sâu hơn thì hãy cùng duyệt qua những gì mà API cung cấp. Object global customElements sẵn có cho ta vài phương thức: define(tagName, constructor, options): Định nghĩa custom element mới. Nó nhận vào 3 đối số: 1 thẻ tên hợp lệ cho custom element, định nghĩa lớp cho custom element và 1 object options. Hiện tại thì chỉ có 1 option được hỗ trợ là extends, mang giá trị là 1 string chỉ định tên của element có sẵn để mở rộng. Thường được dùng để tạo ra các tùy biến của element sẵn có. get(tagName): Trả về constructor của 1 custom element nếu như element được định nghĩa và ngược lại thì trả về undefined. Nó nhận vào 1 đối số duy nhất: thẻ tên hợp lệ của custom element. whenDefined(tagName): Trả về 1 promise và được resolve khi custom element được định nghĩa. Nếu như element đã được định nghĩa rồi thì nó sẽ resolve ngay lập tức. Promise bị reject nếu như thẻ tên không phải là tên hợp lệ của custom element. Nó nhận vào 1 đối số: thẻ tên hợp lệ của 1 custom element. Cách tạo custom elementTạo ra custom element rất đơn giản. Bạn chỉ cần làm 2 việc: định nghĩa 1 lớp cho element và cho nó extends từ lớp HTMLElement, việc thứ 2 là đăng ký tên cho element đó: 12345678910class MyCustomElement extends HTMLElement &#123; constructor() &#123; super(); // … &#125; // …&#125;customElements.define('my-custom-element', MyCustomElement); Hoặc nếu muốn thì bạn có thể sử dụng anonymous class (lớp vô danh) trong trường hợp bạn muốn code gọn gàng hơn 1 chút: 12345678customElements.define('my-custom-element', class extends HTMLElement &#123; constructor() &#123; super(); // … &#125; // …&#125;); Như các bạn đã thấy, custom element được đăng ký bằng phương thức customElements.define(…) Custom element giải quyết vấn đề gì ?Vậy chứ vấn đề ở đây là gì? Div soups chẳng hạn. Thế div soups là cái nồi gì? Thì rõ theo nghĩa đen thì nó là cái nồi súp thẻ div. Trong các ứng dụng webapp hiện đại thì đây là kiểu kiến trúc rất phổ biến khi ta có rất nhiều các thẻ div lồng nhau như thế này đây: 12345678910111213&lt;div class=\"top-container\"&gt; &lt;div class=\"middle-container\"&gt; &lt;div class=\"inside-container\"&gt; &lt;div class=\"inside-inside-container\"&gt; &lt;div class=\"are-we-really-doing-this\"&gt; &lt;div class=\"mariana-trench\"&gt; … &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Kiểu kiến trúc như thế này thường được dùng vì nó bảo trình duyệt phải render những gì mà developer muốn. Nhưng nó lại làm cho code HTML khó đọc và rất khó bảo trì. Ví dụ chúng ta có 1 component trông như thế này: Vậy thì theo cách cũ, HTML sẽ như thế này: 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class=\"primary-toolbar toolbar\"&gt; &lt;div class=\"toolbar\"&gt; &lt;div class=\"toolbar-button\"&gt; &lt;div class=\"toolbar-button-outer-box\"&gt; &lt;div class=\"toolbar-button-inner-box\"&gt; &lt;div class=\"icon\"&gt; &lt;div class=\"icon-undo\"&gt;&amp;nbsp;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"toolbar-button\"&gt; &lt;div class=\"toolbar-button-outer-box\"&gt; &lt;div class=\"toolbar-button-inner-box\"&gt; &lt;div class=\"icon\"&gt; &lt;div class=\"icon-redo\"&gt;&amp;nbsp;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"toolbar-button\"&gt; &lt;div class=\"toolbar-button-outer-box\"&gt; &lt;div class=\"toolbar-button-inner-box\"&gt; &lt;div class=\"icon\"&gt; &lt;div class=\"icon-print\"&gt;&amp;nbsp;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"toolbar-toggle-button toolbar-button\"&gt; &lt;div class=\"toolbar-button-outer-box\"&gt; &lt;div class=\"toolbar-button-inner-box\"&gt; &lt;div class=\"icon\"&gt; &lt;div class=\"icon-paint-format\"&gt;&amp;nbsp;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Tuy nhiên, tưởng tượng rằng chúng ta có thể làm như thế này: 12345678&lt;primary-toolbar&gt; &lt;toolbar-group&gt; &lt;toolbar-button class=\"icon-undo\"&gt;&lt;/toolbar-button&gt; &lt;toolbar-button class=\"icon-redo\"&gt;&lt;/toolbar-button&gt; &lt;toolbar-button class=\"icon-print\"&gt;&lt;/toolbar-button&gt; &lt;toolbar-toggle-button class=\"icon-paint-format\"&gt;&lt;/toolbar-toggle-button&gt; &lt;/toolbar-group&gt;&lt;/primary-toolbar&gt; Rõ ràng ví dụ thứ 2 nhìn sạch sẽ và gọn hơn nhiều. Dễ bảo trì, dễ đọc cho cả trình duyệt và developer. Đơn giản hơn nhiều. Vấn đề tiếp theo là khả năng tái sử dụng. Công việc của developer chúng ta đòi hỏi không chỉ viết code hoạt động được mà còn phải bảo trì được. Và 1 điều làm cho code dễ bảo trì là nó có thể dễ dàng tái sử dụng 1 phần nào đó của code thay vì phải viết đi viết lại nhiều lần. Dưới đây là 1 ví dụ đơn giản nhưng bạn sẽ hiểu ý tưởng của nó. Giả sử ta có element sau: 1234&lt;div class=\"my-custom-element\"&gt; &lt;input type=\"text\" class=\"email\" /&gt; &lt;button class=\"submit\"&gt;&lt;/button&gt;&lt;/div&gt; Nếu chúng ta cần sử dụng nó ở nơi nào khác thì ta sẽ phải viết lại đoạn HTML trên nhiều lần. Giả sử như ta cần thay đổi 1 phần nào đó và áp dụng cho mọi element. Ta sẽ phải đi tìm tất cả mọi nơi có đoạn code đó và chỉnh sửa chính xác cùng 1 thay đổi y chang nhau rất nhiều lần, bùm….. Vậy thì không tốt hơn nếu ta chỉ cần như vậy thôi sao: 1&lt;my-custom-element&gt;&lt;/my-custom-element&gt; Nhưng webapp hiện đại không chỉ có HTML tĩnh. Bạn cần tương tác với nó nữa. Và đây là lúc ta cần Javascript. Thường thì bạn sẽ tạo ra 1 vài element, ghép chúng vào bất kỳ event listener nào mà bạn muốn để cho nó có thể tương tác phản hồi khi có input từ người dùng. Bất kể là click, kéo-thả, hover, nhấn bàn phím, vân vân 1234567var myDiv = document.querySelector('.my-custom-element');myDiv.addEventListener('click', _ =&gt; &#123; myDiv.innerHTML = '&lt;b&gt; I have been clicked &lt;/b&gt;';&#125;);&lt;div class=\"my-custom-element\"&gt; I have not been clicked yet.&lt;/div&gt; Với API custom element, toàn bộ phần logic này có thể được đóng gói vào bên trong chính element đó. Xem ví dụ bên dưới 123456789101112131415class MyCustomElement extends HTMLElement &#123; constructor() &#123; super(); var self = this; self.addEventListener('click', _ =&gt; &#123; self.innerHTML = '&lt;b&gt; I have been clicked &lt;/b&gt;'; &#125;); &#125;&#125;customElements.define('my-custom-element', MyCustomElement);&lt;my-custom-element&gt; I have not been clicked yet&lt;/my-custom-element&gt; Mới đầu nhìn vào thì có vẻ như giải pháp custom element này đòi hỏi nhiều Javascript. Tuy nhiên trong các ứng dụng thực tế thì bạn sẽ hiếm khi gặp phải trường hợp mà bạn tạo ra 1 element mà không phải tái sử dụng nó. Một diều điển hình nữa trong các webapp hiện đại là đa số các element đều được tạo ra bằng code trong quá trình hoạt động (dynamic). Vì thế bạn cần phải xử lý các trường hợp riêng biệt khi element được thêm vào bằng Javascript hoặc nó được định nghĩa trước kia trong kiến trúc HTML. Bạn sẽ có toàn bộ những tính năng ấy nếu dùng custom element. Tóm lại, custom element làm code bạn dễ hiểu, dễ bảo trì hơn, chia nhỏ nó thành các module khép kín nhỏ hơn, có thể tái sử dụng. Các yêu cầuTrước khi bạn bắt đầu tạo custom element của chính mình, bạn nên biết rằng có 1 số quy tắc đặc biệt mà ta phải tuân theo: Tên phải chứa dấu gạch ngang (-). Bằng cách này bộ parser của HTML mới hiểu được element nào là do người dùng tạo ra và element nào là sẵn có. Nó cũng đảm bảo rằng không có xung đột khi đặt tên với các element sẵn có (bất kể bây giờ hay trong tương lai, khi một element mới được thêm vào). Ví dụ, &lt;my-custom-element&gt; là 1 tên hợp lệ trong khi &lt;myCustomElement&gt; và &lt;my_custom_element&gt; thì không. Không được đăng ký cùng 1 thẻ tên nhiều hơn 1 lần. Điều này sẽ làm cho trình duyệt bắn ra 1 biệt lệ DOMException. Bạn không thể ghi đè các custom element. Custom element không thể tự đóng thẻ. Bộ parser HTML chỉ cho phép 1 nhóm các element sẵn có có thể tự đóng thẻ của nó (ví dụ: &lt;img&gt;, &lt;link&gt;, &lt;br&gt;). Các khả năngVậy thì bạn thực sự có thể làm được gì với custom element? Và câu trả lời là: rất nhiều thứ. Một trong số những tính năng tốt nhất là định nghĩa class của element thực sự liên kết đến chính DOM element của nó. Điều này có nghĩa bạn có thể dùng trực tiếp this với event listener, truy cập vào các property của nó, truy cập các node con và vân vân. 12345678910111213class MyCustomElement extends HTMLElement &#123; // ... constructor() &#123; super(); this.addEventListener('mouseover', _ =&gt; &#123; console.log('I have been hovered'); &#125;); &#125; // ...&#125; Dĩ nhiên là nó cho bạn khả năng để ghi đè lại node con của 1 element với nội dung mới. Và cũng dĩ nhiên là điều này không nên làm, bởi vì nó sẽ dẫn đến nhiều vấn đề không mong muốn. Rõ ràng nếu như bạn có 1 custom element đang hoạt động và đột nhiên phát hiện ra phần markup của element của mình bị thay đổi thì sẽ bối rối lắm. Có 1 vài vị trí đặc biệt mà bạn có thể định nghĩa để thực thi code tại các thời điểm cụ thể trong vòng đời của element. constructor: constructor được gọi 1 lần khi element được tạo ra hoặc nâng cấp (chúng ta sẽ nói về nó sau). Đa số nó được dùng để khởi tạo state (trạng thái), gắn kết các event listener, tạo shadow DOM, vân vân. Lưu ý bạn hầu như cần phải gọi super() trong constructor. connectedCallback: phương thức connectedCallback được gọi mỗi lần element được thêm vào DOM. Nó có thể được dùng (khuyến nghị nên dùng) để delay (hoãn lại) vài việc cho đến khi element thực sự được gắn vào trang (chẳng hạn như lấy tài nguyên từ server). disconnectedCallback: tương tự như connectedCallback thì disconnectedCallback được gọi khi 1 element bị lấy ra khỏi DOM. Thường là để giải phóng tài nguyên. Lưu ý rằng disconnectedCallback không bao giờ được gọi nếu như user đóng tab. Hãy cẩn thận với những thứ mà bạn khởi tạo lúc đầu. attributeChangedCallback: phương thức này được gọi khi 1 attribute của element được thêm vào, gỡ ra, cập nhật hoặc thay thế. Nó cũng được gọi khi element được tạo ra bởi parser. Tuy nhiên, lưu ý rằng nó chỉ áp dụng cho các attribute nằm trong danh sách an toàn (whitelist) của property observedAttributes addoptedCallback: phương thức này được gọi khi document.adoptNote(…) được gọi để đưa đó sang 1 document khác. Lưu ý rằng tất cả các callbacks ở trên đều là đồng bộ. Ví dụ, connectedCallback được gọi ngay lập tức sau khi element được thêm vào DOM và trong lúc đó không có gì xảy ra. Phản chiếu propertyCác element HTML sẵn có cung cấp 1 khả năng rất tiện dụng: phản chiếu property. Nghĩa là các giá trị của 1 vài property được phản chiếu trực tiếp về DOM dưới dạng attribute. Một ví dụ điển hình là property id. 1myDiv.id = 'new-id'; Cũng sẽ cập nhật DOM thành: 1&lt;div id=\"new-id\"&gt; ... &lt;/div&gt; Và nó cũng áp dụng theo hướng ngược lại nữa. Phần này cực kỳ tiện lợi bởi vì nó cho phép bạn cấu hình các element khai báo. Custom element không có tính năng như thế này nhưng có 1 cách để bạn tự triển khai. Ta có thể có được tính năng tương tự khi định nghĩa các getter &amp; setter cho các property. 1234567891011121314151617class MyCustomElement extends HTMLElement &#123; // ... get myProperty() &#123; return this.hasAttribute('my-property'); &#125; set myProperty(newValue) &#123; if (newValue) &#123; this.setAttribute('my-property', newValue); &#125; else &#123; this.removeAttribute('my-property'); &#125; &#125; // ...&#125; Mở rộng elementAPI custom element cho phép bạn không chỉ tạo ra các element HTML mà còn có thể mở rộng element sẵn có. Phương pháp này hoạt động cực tốt cho cả element sẵn có và custom element. Bạn chỉ cần mở rộng định nghĩa class của nó là được. 12345class MyAwesomeButton extends MyButton &#123; // ...&#125;customElements.define('my-awesome-button', MyAwesomeButton); Hoặc trong trường hợp của element có sẵn, ta cần thêm 1 param thứ 3 vào hàm customElements.define(…) - một object với property extends và giá trị là thẻ tên của element đang được mở rộng. Bằng cách này trình duyệt biết được chính xác thì element nào đang được mở rộng bởi vì có rất nhiều element sẵn có cùng chia sẻ giao diện DOM. Nếu không chỉ định element nào mà mình muốn mở rộng, trình duyệt sẽ không biết được chức năng nào đang được mở rộng. 12345class MyButton extends HTMLButtonElement &#123; // ...&#125;customElements.define('my-button', MyButton, &#123;extends: 'button'&#125;); Một element gốc mở rộng (extended native element) còn được gọi là element được tùy biến (customized built-in element). Nguyên tắc vàng cho bạn đó là luôn luôn mở rộng các element đang tồn tại sẵn. Và làm việc này một cách dần dần. Nó cho phép bạn giữ lại tất cả các tính năng trước đó (property, attribute, các hàm). Chú ý rằng element được tùy biến chỉ được hỗ trợ từ Chrome 67 trở lên. Nó sẽ được triển khai cho các trình duyệt khác ngoại trừ Safari. Nâng cấp elementNhư đã nói ở trên, chúng ta sử dụng phương thức customElements.define(…) để đăng ký 1 custom element. Nhưng nó không có nghĩa rằng đó là việc đầu tiên bạn phải làm. Đăng ký custom element có thể được hoãn lại sau này. Kể cả sau khi chính element đó được thêm vào DOM. Quá trình này được gọi là nâng cấp element. Để giúp bạn biết được thực sự khi nào thì element được định nghĩa thì trình duyệt có cung cấp phương thức customElements.whenDefine(…). Bạn truyền thẻ tên của element vào, nó trả về 1 promise và sẽ được resolve khi element đăng ký xong. 123customElements.whenDefined('my-custom-element').then(_ =&gt; &#123; console.log('My custom element is defined');&#125;); Ví dụ, khi bạn muốn delay 1 vài thứ cho đến khi tất cả các element con được định nghĩa xong, cực kỳ có ích khi mà bạn có các custom element lồng nhau. Thỉnh thoảng element cha sẽ dựa vào sự triển khai của các element con. Trong trường hợp này bạn cần đảm bảo rằng các element con được định nghĩa trước element cha. Shadow DOMNhư đã nói, custom element và shadow DOM đi đôi với nhau. Custom element được dùng để đóng gói logic Javascript vào bên trong 1 element trong khi shadow DOM được dùng để tạo ra 1 môi trường khép kín cho phần DOM không bị ảnh hưởng bởi các yếu tố bên ngoài. Mình đề nghị bạn nên đọc lại bài viết trước để hiểu thêm về shadow DOM và các ý tưởng của nó. Để sử dụng shadow DOM cho custom element, bạn chỉ cần đơn giản gọi this.attachShadow 12345678910111213class MyCustomElement extends HTMLElement &#123; // ... constructor() &#123; super(); let shadowRoot = this.attachShadow(&#123;mode: 'open'&#125;); let elementContent = document.createElement('div'); shadowRoot.appendChild(elementContent); &#125; // ...&#125;); TemplateChúng ta đã tìm hiểu sơ về template trong bài viết trước về shadow DOM và chúng xứng đáng có 1 bài viết riêng. Ở đây chúng ta sẽ đưa ra 1 ví dụ đơn giản làm thế nào để bạn có thể kết hợp các template vào quá trình tạo ra custom element. Sử dụng thẻ &lt;template&gt; bạn có thể khai báo thẻ của 1 mảnh DOM, một thứ được parse nhưng không được render trên trang. 12345678910111213141516171819&lt;template id=\"my-custom-element-template\"&gt; &lt;div class=\"my-custom-element\"&gt; &lt;input type=\"text\" class=\"email\" /&gt; &lt;button class=\"submit\"&gt;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;let myCustomElementTemplate = document.querySelector('#my-custom-element-template');class MyCustomElement extends HTMLElement &#123; // ... constructor() &#123; super(); let shadowRoot = this.attachShadow(&#123;mode: 'open'&#125;); shadowRoot.appendChild(myCustomElementTemplate.content.cloneNode(true)); &#125; // ...&#125;); Giờ đây chúng ta có thể kết hợp custom element với shadow DOM và template, ta có được 1 element khép kín trong phạm vi của chính nó và có kiến trúc HTML riêng biệt cũng như Javascript logic StylingChúng ta đã đi qua phần của HTML &amp; Javascript, giờ là về CSS. Rõ ràng thì ta cần 1 cách để chỉnh style cho các element. Chúng ta có thể thêm CSS stylesheet vào bên trong shadow DOM nhưng bạn sẽ thắc mắc là làm thế nào ta có thể chỉnh style của element từ bên ngoài với vai trò là 1 user của element đó. Và câu trả lời lại đơn giản: bạn cứ style nó giống như cách bạn làm với các element gốc. 123456my-custom-element &#123; border-radius: 5px; width: 30%; height: 50%; // ...&#125; Lưu ý rằng style định nghĩa từ bên ngoài có độ ưu tiên cao hơn và nó sẽ ghi đè style định nghĩa từ element. Bạn cũng biết có 1 số trường hợp khi trang được load nhưng nội dung trên trang vẫn ở dạng HTML thô và chưa được style (flash of unstyled content - FOUC). Bạn có thể ngăn chặn tình huống này bằng cách định nghĩa style cho các undefined component và sử dụng một số cách transition khi chúng được định nghĩa xong. Để làm như vậy ta cần dùng selector :defined 12345my-button:not(:defined) &#123; height: 20px; width: 50px; opacity: 0;&#125; Element không tồn tại (unknown) và custom element chưa định nghĩa (undefined)Tiêu chuẩn HTML rất linh động và cho phép khai báo bất kỳ thẻ nào ta muốn. Nếu trình duyệt không thể nhận ra thẻ đó thì nó sẽ được parse dưới dạng HTMLUnknownElement. 12345var element = document.createElement('thisElementIsUnknown');if (element instanceof HTMLUnknownElement) &#123; console.log('The selected element is unknown');&#125; Tuy nhiên, điều này lại không áp dụng với custom element. Bạn có nhớ khi chúng ta bàn về việc có 1 số quy tắc đặt tên để định nghĩa custom element? Lý do là nếu như trình duyệt nhận ra tên hợp lệ cho 1 custom element thì nó sẽ parse nó dưới dạng HTMLElement và trình duyệt cân nhắc để trở thành custom element chưa định nghĩa. 12345var element = document.createElement('this-element-is-undefined');if (element instanceof HTMLElement) &#123; console.log('The selected element is undefined but not unknown');&#125; Mặc dù không có sự khác biệt nào có thể nhìn bằng mắt thường giữa HTMLElement và HTMLUnknownElement nhưng cũng có vài thứ mà ta cần phải nhớ. Parser sẽ đối xử với chúng khác nhau. Nếu một element có cái tên hợp lệ (theo kiểu custom element như đã nói ở trên) thì sẽ được kiểm tra xem nó có phần triển khai nào cho custom element không. Nó sẽ được đối xử như 1 div bình thường cho tới khi phần triển khai đó được định nghĩa. Ngược lại element chưa định nghĩa thì không triển khai bất kỳ phương thức hay property nào. Hỗ trợ từ trình duyệtPhiên bản đầu tiên của custom element được giới thiệu trong Chrome 36+. Cái gọi là API v0 của custom element mà giờ đây đã không dùng nữa và cân nhắc rằng đó là những yếu kém mặc dù vẫn đang tồn tại. Nếu bạn muốn tìm hiểu về v0 thì có thể đọc bài viết ở đây. API v1 của custom element xuất hiện kể từ Chrome 54 và Safari 10.1 (chỉ có 1 phần). Microsoft Edge thì đang trong giai đoạn thử mẫu và Mozilla đã có từ v50 những không được kích hoạt sẵn và cần người dùng tự kích hoạt nó. Hiện tại chỉ có các trình duyệt webkit mới hỗ trợ hoàn toàn. Tuy nhiên như đã nhắc ở trên, có các polyfill tồn tại cho phép bạn dùng custom element trên tất cả các trình duyệt, kể cả IE11. Kiểm tra tính khả dụngĐể đảm bảo trình duyệt có hỗ trợ custom element bạn có thể làm là thực hiện 1 bài kiểm tra nhỏ để xem property customElements có tồn tại trong object window hay không: 12345const supportsCustomElements = 'customElements' in window;if (supportsCustomElements) &#123; // Bạn có thể dùng API Custom elements ở đây&#125; Hoặc nếu ta dùng thư viện polifyll: 1234567891011121314151617181920function loadScript(src) &#123; return new Promise(function(resolve, reject) &#123; const script = document.createElement('script'); script.src = src; script.onload = resolve; script.onerror = reject; document.head.appendChild(script); &#125;);&#125;// Chạy lazy load cho polyfill nếu cần thiếtif (supportsCustomElements) &#123; // Trình duyệt hỗ trợ sẵn cho custom element. Bạn có thể dùng bình thường.&#125; else &#123; loadScript('path/to/custom-elements.min.js').then(_ =&gt; &#123; // Polyfill cho custom element đã được kích hoạt. Bạn có thể dùng bình thường. &#125;);&#125; Vậy nói gọn gọn lại, 1 phần của tiêu chuẩn web component là custom element cho bạn các khả năng sau: Liên kết Javascript và CSS với HTML element Cho phép bạn mở rộng các element HTML sẵn có (cả element gốc và custom element) Không cần thư viện hay framework ngoài. Bạn chỉ cần Javascript, HTML và CSS gốc và có thể cần thêm thư viện polyfill để hỗ trợ trình duyệt cũ. Nó được xây dựng để hoạt động trơn tru, mượt mà với các tính năng khác của web component (shadow DOM, template, slots, vân vân) Liên kết chặt chẽ với công cụ dev của trình duyệt. Tận dụng các tính năng tiếp cận sẵn có. Custom element không khác với những thứ chúng ta đã dùng bấy lâu nay. Nó chỉ là 1 cách khác để làm cho mọi việc dễ dàng hơn khi phát triển webapp. Nó mở ra cánh cổng đến với việc xây dựng những app phức tạp với tốc độ nhanh. Tuy nhiên càng phức tạp thì càng có nhiều khả năng có lỗi mà khó tìm hiểu hoặc tái lập. Vì thế khi debug ta cần nhiều ngữ cảnh và công cụ như SessionStack để hỗ trợ. SessionStack tích hợp vào trong webapp và bắt đầu thu thập các thông tin như sự kiện người dùng, dữ liệu mạng, biệt lệ, thông báo debug, thay đổi trên DOM, vân vân, và gửi chúng về server của họ. Sau đó, dữ liệu thu được sẽ được xử lý để tạo ra đoạn video trải nghiệm để bạn có thể xem user đã tương tác như thế nào với sản phẩm của bạn. Bên cạnh những thông tin kỹ thuật mà SessionStack đã cung cấp thì nó còn cho phép bạn khả năng để tái hiện lại các vấn đề mà bạn không bao giờ biết được khi debug trước đây. Để đảm bảo cho SessionStack luôn luôn thực hiện được các phiên làm việc hoàn hảo đến từng pixel thì team của họ đã bám sát lấy những công nghệ, framework và tiêu chuẩn web tiên tiến cũng như mới nhất.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P18: WebRTC & cơ chế mạng peer-to-peer","slug":"Cach-Javascript-hoat-dong-P18-WebRTC-co-che-mang-peer-to-peer","date":"2019-01-05T17:00:00.000Z","updated":"2019-01-06T10:16:09.777Z","comments":true,"path":"2019/01/Cach-Javascript-hoat-dong-P18-WebRTC-co-che-mang-peer-to-peer.html","link":"","permalink":"http://nthung2112.github.io/2019/01/Cach-Javascript-hoat-dong-P18-WebRTC-co-che-mang-peer-to-peer.html","excerpt":"Thêm một bài nữa mang nặng kiến thức về mạng mà mình lại không chuyên về mảng này, nếu mình dịch chỗ nào không phù hợp thì nhờ mọi người giúp đỡ nhé @@_ Peer-To-Peer hay P2P: Mạng ngang hàng Real-time: thời gian thực Chào các bạn đến với bài thứ 18 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.","text":"Thêm một bài nữa mang nặng kiến thức về mạng mà mình lại không chuyên về mảng này, nếu mình dịch chỗ nào không phù hợp thì nhờ mọi người giúp đỡ nhé @@_ Peer-To-Peer hay P2P: Mạng ngang hàng Real-time: thời gian thực Chào các bạn đến với bài thứ 18 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Khái quátĐầu tiên thì WebRTC là cái gì vậy? Nó là viết tắt của chữ Real Time Communication (Giao tiếp thời gian thực), nghe qua chắc bạn cũng đã có cái gì sơ sơ về công nghệ này rồi nhỉ. WebRTC lấp đầy 1 khoảng trống lớn trong nền tảng web. Trước đây, các công nghệ P2P chẳng hạn như những app chat trên desktop có thể làm những việc mà web không làm được. Nhưng WebRTC đã thay đổi điều đó. Về cơ bản WebRTC cho phép webapp có thể thiết lập giao tiếp Peer-To-Peer, chính là nội dung trong bài viết này. Ta sẽ thảo luận về các chủ đề sau đây để có thể mang đến cho bạn 1 cái nhìn toàn cảnh về “ruột gan phèo phổi” của WebRTC: Giao tiếp Peer-To-Peer Tường lửa và NAT Traversal Tín hiệu (Signaling), Phiên (Session), Giao thức (Protocol) Các API của WebRTC Giao tiếp Peer-To-PeerĐể có thể giao tiếp lẫn nhau thông qua trình duyệt web, mỗi trình duyệt của user phải thực hiện những bước sau đây: Đồng ý để bắt đầu giao tiếp Biết cách xác định vị trí của đối tượng Vượt qua an ninh và tưởng lửa bảo vệ Chuyển giao tất cả các giao tiếp đa phương tiện theo real-time 1 trong số những thách thức lớn nhất liên quan đến các giao tiếp P2P dựa trên trình duyệt là làm sao để biết vị trí &amp; thiết lập 1 kết nối socket mạng (network socket connection) với 1 trình duyệt khác để vận chuyển dữ liệu 2 chiều. Ta sẽ xem xét những khó khăn liên quan đến việc thiết lập kết nối này. Khi webapp của bạn cần dữ liệu hoặc tài nguyên, nó sẽ lấy về từ các server. Tuy nhiên, nếu bạn muốn tạo ra 1 ứng dụng video chat chẳng hạn, bằng cách kết nối trực tiếp đến trình duyệt của người khác - thì đây là vấn đề, vì bạn không biết địa chỉ bởi vì trình duyệt của người kia không phải là 1 web server. Vì vậy để có thể thiết lập 1 kết nối P2P ta cần rất nhiều thứ. Tường lửa và NAT TraversalThường thì máy tính của bạn không không có địa chỉ IP public tĩnh. Lý do là máy tính của bạn phải núp đằng sau tường lửa và thiết bị NAT (Network access translation - Bộ phiên dịch truy cập mạng). Thiết bị NAT sẽ dịch địa chỉ IP cá nhân từ bên trong tường lửa thành địa chỉ IP công khai (public-facing IP). Ta cần các thiết bị NAT để bảo mật và giải quyết sự giới hạn của IPv4 đối với những địa chỉ IP công khai sẵn có. Đó là lý do tại sao webapp không nên giả định rằng thiết bị hiện tại có 1 địa chỉ IP public tĩnh. Cùng tìm hiểu 1 chút về cách hoạt động của các thiết bị NAT. Nếu như bạn đang ở trong môi trường công cộng và kết nối vào mạng WiFi, máy tính của bạn sẽ được gán 1 địa chỉ IP mà nó chỉ tồn tại đằng sau NAT. Giả sử IP là 172.0.23.4, tuy nhiên, với thế giới bên ngoài, địa chỉ IP của bạn có thể mang giá trị khác, ví dụ 164.53.27.98. Vì vậy, thế giới bên ngoài sẽ thấy các request của bạn đến từ địa chỉ 164.53.27.98 nhưng thiết bị NAT sẽ đảm bảo các response cho những request (được gửi từ máy của bạn) sẽ trả về đúng chỗ là 172.0.23.4. Ơn trời các bảng ánh xạ (mapping table). Lưu ý rằng ngoài địa chỉ IP thì cổng (port) cũng là điều kiện cần thiết cho các giao tiếp mạng. Do có sự tham gia của các thiết bị NAT, trình duyệt của bạn cần tìm được địa chỉ IP của máy tính có trình duyệt mà bạn muốn giao tiếp. Đến đây thì ta lại phải nhờ đến các server STUN (Session Traversal Utilities for NAT - Tiện ích truyền tải theo phiên cho NAT) và TURN (Traversal Using Relays around NAT - Truyền tải sử dụng điểm chuyển tiếp vòng quanh NAT). Để các công nghệ WebRTC hoạt động được, đầu tiên thì 1 request hỏi địa chỉ IP public của bạn sẽ được gửi đến server STUN. Bạn cứ nghĩ theo hướng kiểu như máy tính đang tạo truy vấn đến 1 server từ xa để hỏi về địa chỉ IP mà server đó nhận câu truy vấn là bao nhiêu. Server từ xa sẽ trả về địa chỉ IP mà nó thấy. Nói ngắn gọn là máy tính của bạn “hỏi” 1 server từ xa địa chỉ IP của chính máy bạn là bao nhiêu. Giả sử tiến trình này hoạt động bình thường và bạn nhận được địa chỉ IP public của mình cũng như số port, bạn sẽ có thể nói với những peer ngang hàng khác làm thế nào để kết nối trực tiếp đến bạn. Những peer này cũng có thể làm cùng 1 việc là sử dụng STUN &amp; server TURN và nói cho bạn biết nên liên lạc đến địa chỉ nào. Signaling, Sessions, ProtocolsTín hiệu, phiên, giao thức Quá trình khám phá thông tin mạng được mô tả ở trên chỉ là 1 phần của chủ đề về Signaling to bự hơn nhiều, trong trường hợp của WebRTC thì phần signaling này dựa trên 1 chuẩn JSEP (Javascript Session Establishment Protocol - Giao thức thiết lập phiên của Javascript). Signaling bao gồm cả khám phá mạng (network discovery) và NAT Traversal, tạo và quản lý phiên, bảo mật giao tiếp, siêu dữ liệu (metadata) và phối hợp khả năng của media, xử lý lỗi. Để kết nối có thể hoạt động, peer thu được những điều kiện về local media cho metadata (ví dụ: những khả năng về kích thước và kiểu codec) và gom góp các địa chỉ mạng có thể có cho host của ứng dụng. Cơ chế signaling dùng để truyền tới/lui những thông tin quan trọng này không được định nghĩa trong API của WebRTC. Signaling không được quy định bởi chuẩn WebRTC và nó không được triển khai bằng API của nó để cho phép sử dụng một cách linh động các công nghệ và giao thức cần thiết. Các WebRTC developer sẽ đối phó với signaling và server xử lý signaling. Giả sử app WebRTC dựa trên trình duyệt của bạn có thể xác định được địa chỉ IP public của nó bằng cách sử dụng STUN như đã nói ở trên, bước tiếp theo thực sự là 1 màn đàm phán &amp; thiết lập phiên kết nối đến với peer. Phần đàm phán và thiết lập khởi tạo phiên xảy ra khi dùng 1 giao thức signaling/giao tiếp được đặc tả trong các giao tiếp đa phương tiện. Giao thức này cũng chịu trách nhiệm cho việc điều hành các quy định trong đó phiên được quản lý và hủy bỏ. Một trong số các giao thức như vậy có tên là Session Initiation Protocol (SIP - Giao thức khởi tạo phiên). Lưu ý rằng do sự linh động của WebRTC signaling, SIP không phải là giao thức signaling duy nhất có thể dùng. Giao thức signaling được chọn phải hoạt động với 1 giao thức ở tầng ứng dụng gọi là Session Description Protocol (SDP - Giao thức mô tả phiên), giao thức này được sử dụng trong trường hợp của WebRTC. Tất cả các metadata đa phương tiện cụ thể được truyền đi bằng giao thức SDP này. Bất kỳ peer nào (ví dụ: app tận dụng WebRTC) thử giao tiếp với 1 peer khác đều sinh ra 1 tập các ứng viên giao thức Interactive Connectivity Establishment (ICE - Thiết lập kết nối tương tác). Những ứng viên này biểu diễn 1 bộ kết hợp của địa chỉ IP, port, giao thức giao vận được dùng. Lưu ý rằng 1 máy tính có thể có nhiều giao diện mạng (không dây, có dây, vân vân), vì thế có thể được gán nhiều địa chỉ IP cho mỗi giao diện. Dưới đây là sơ đồ lấy từ MDN mô tả lại sự trao đổi: Thiết lập kết nốiMỗi peer đầu tiên phải thiết lập địa chỉ IP public như đã nói ở trên. “Kênh” (channel) dữ liệu signaling sau đó được tự động tạo ra để xác định các peer và hỗ trợ đàm phán peer-to-peer và thiết lập phiên. Thế giới bên ngoài hoàn toàn không biết hoặc không thể truy xuất đến những “kênh” này và nó cũng yêu cầu 1 định danh duy nhất nếu muốn truy cập. Lưu ý rằng, do sự linh động của WebRTC và cũng bởi tiến trình signaling không được cụ thể hóa trong các tiêu chuẩn, ý tưởng và cách thực hiện của “kênh” có thể sẽ có ít nhiều khác biệt tuy vào công nghệ sử dụng. Rõ ràng, 1 vài giao thức không cần đến cơ chế “kênh” mà vãn giao tiếp được. Chúng ta sẽ giả sử rằng “kênh” được dùng trong việc triển khai cho các mục đích được nhắc tới ở bài viết này. Một khi 2 hoặc nhiều peer đã cùng kết nối vào 1 “kênh” thì những peer đã có thể giao tiếp và trao đổi thông tin phiên. Tiến trình này về mặt nào đó thì tương tự như mô hình publish/subscribe. Về cơ bản, peer khởi tạo ban đầu sẽ gửi 1 “lời đề nghị” sử dụng 1 giao thức signaling chẳng hạn như Session Initiation Protocol (SIP - Giao thức khởi tạo phiên) và SDP. Người khởi tạo sẽ chờ để nhận được “câu trả lời” từ bất kỳ người nhận nào đã kết nối với “kênh”. Khi đã nhận được câu trả lời, 1 tiến trình diễn ra để xác định và trao đổi giao thức ứng viên ICE tốt nhất (Interactive Connectivity Establishment - Thiết lập kết nối tương tác) mà mỗi peer thu thập được. Một khi chọn được ứng viên ICE tối ưu thì về cơ bản sẽ có nhiều thứ theo sau đó được chấp nhận, bao gồm: những metadata cần thiết, các định tuyến mạng (địa chỉ IP và port) và các thông tin media thường dùng để giao tiếp với mỗi peer. Phiên mạng socket mạng giữa những peer sau đó được thiết lập hoàn chỉnh và kích hoạt. Tiếp đó, các luồng dữ liệu local và các endpoint kênh dữ liệu được tạo ra bởi mỗi peer, dữ liệu đa phương tiện cuối cùng được chuyển đi theo cả 2 đường sử dụng bất kỳ công nghệ giao tiếp 2 chiều nào. Nếu như tiến trình đồng ý chấp nhận ứng viên ICE tốt nhất bị thất bại, thỉnh thoảng nguyên nhân là do tường lửa hoặc kỹ thuật NAT đang dùng, thì giải pháp dự phòng sau đó là sử dụng 1 server TURN dưới dạng 1 điểm chuyển tiếp thay thế. Tiến trình này về cơ bản sẽ dùng 1 server hoạt động như người trung gian và nó chuyển tiếp bất kỳ dữ liệu nào truyền qua lại giữa các peer. Lưu ý rằng đây không phải là giao tiếp peer-to-peer thực thụ trong đó các peer truyền dữ liệu 2 chiều trực tiếp đến với nhau. Khi sử dụng giải pháp dự phòng TURN để giao tiếp, mỗi peer sẽ không cần phải biết làm thế nào để liên lạc và truyền dữ liệu đến bên kia. Thay vào đó, nó cần biết server TURN public nào để gửi và nhận dữ liệu đa phương tiện theo thời gian thực xuyên suốt phiên giao tiếp. Điều quan trọng cần phải hiểu rằng đây chắc chẳn là 1 dạng “kế hoạch dự phòng” và chỉ dùng khi không còn cách nào khác. Các server TURN phải khá vững chắc, có băng thông rộng, khả năng xử lý và có thể xử lý 1 lượng lớn dữ liệu tiềm tàng. Cách sử dụng server TURN vì thế rõ ràng là sẽ phát sinh thêm chi phí và sự phức tạp. Các API của WebRTCCó 3 mục phân loại API chính trong WebRTC: Media Capture and Streams (luồng media và chụp media) - cho phép bạn truy xuất vào các thiết bị đầu vào, chẳng hạn như microphone hay web camera. API cho phép bạn lấy 1 luồng media từ các thiết bị đó. RTCPeerConnection - dùng những API này, bạn có thể gửi theo thời gian thực 1 luồng âm thanh &amp; hình ảnh đã bắt được thông qua internet đến 1 endpoint WebRTC khác. Bạn có thể tạo ra kết nối giữa máy local và peer từ xa. Nó cũng cung cấp các phương thức để kết nối đến 1 peer từ xa, duy trì và kiểm soát kết nối &amp; đóng kết nối 1 khi ta không cần đến nó nữa. RTCDataChannel - API này cho phép bạn truyền dữ liệu tùy ý. Mỗi kênh dữ liệu được liên kết với 1 RTCPeerConnection. Chúng ta sẽ đi sâu vào thảo luận mỗi loại trên. Media Capture &amp; StreamsAPI Media Capture &amp; Streams, thường được gọi là Media Stream API hoặc Stream API, là 1 API hỗ trợ những luồng (stream) dữ liệu âm thanh hay hình ảnh, các phương thức để làm việc với chúng, những hạn chế liên kết với từng loại dữ liệu, callback thành công/thất bại khi sử dụng dữ liệu bất đồng bộ và những sự kiện được bắn ra suốt quá trình. Phương thức getUserMedia() của MediaDevices nhắc nhở người dùng cấp quyền để sử dụng đầu vào media, nó tạo ra 1 MediaStream kèm với các track chứa kiểu request của media. Luồng đó có thể chứa 1 track video (được tạo ra bởi phần cứng hay nguồn video ảo chẳng hạn như camera, thiết bị ghi video, dịch vụ chia sẻ màn hình, vân vân), 1 track audio (tương tự, được tạo ra bởi nguồn ghi vật lý hoặc nguồn ghi ảo như microphone, bộ chuyển A/D…) và có thể có cả những loại track khác. Nó sẽ trả về 1 Promise và resolve thành object MediaStream. Nếu người dùng từ chối cấp quyền hoặc là media phù hợp không tồn tại thì promise đó sẽ bị reject với PermissionDeniedError hoặc NotFoundError. Mô hình singleton MediaDevice có thể được truy xuất thông qua object navigator như sau: 1234567navigator.mediaDevices.getUserMedia(constraints).then(function(stream) &#123; /* use the stream */&#125;).catch(function(err) &#123; /* handle the error */&#125;); Lưu ý là bạn cần truyền object constraints để nói cho API loại stream nào để trả về. Bạn có thể cấu hình tất cả những thứ linh tinh liên quan, bao gồm cả camera mà bạn dùng (camera trước/sau), tần suất khung hình, độ phân giải, vân vân. Kể từ phiên bản 25, các trình duyệt dựa trên nhân Chromium cho phép dữ liệu âm thanh từ getUserMedia() có thể được truyền đến element audio hoặc video (nhưng lưu ý rằng mặc định thì các media element bị tắt tiếng (mute)) getUserMedia còn có thể được dùng như 1 node đầu vào cho Web Audio API 1234567891011function gotStream(stream) &#123; window.AudioContext = window.AudioContext || window.webkitAudioContext; var audioContext = new AudioContext(); // Tạo AudioNode từ stream var mediaStreamSource = audioContext.createMediaStreamSource(stream); // Kết nối nó đến điểm đích để nghe bạn // hoặc bất kỳ node nào khác đang xử lý mediaStreamSource.connect(audioContext.destination);&#125;navigator.getUserMedia(&#123;audio:true&#125;, gotStream); Giới hạn về sự riêng tưLà 1 API có thể chứa nhiều điều lo ngại đáng kể về quyền riêng tư, getUserMedia() được tổ chức bởi các đặc điểm kỹ thuật với những yêu cầu rất cụ thể về thông báo người dùng và quản lý quyền truy cập. getUserMedia() phải luôn luôn xin quyền từ người dùng trước khi mở bất kỳ thiết bị thu thập thông tin media nào chẳng hạn như webcam hay microphone. Trình duyệt có thể có tính năng cấp quyền trên mỗi domain (once-per-domain), nhưng nó phải hỏi bạn ít nhất là lần đầu tiên hoạt động và người dùng phải đặc biệt cấp quyền tiếp theo nếu họ muốn. Một điều quan trọng tương đương là các quy định xung quanh thông báo (notification). Trình duyệt được yêu cầu phải hiển thị 1 thông số thể hiện camera hoặc microphone đang hoạt động, hơn hết thảy bất kỳ thông số thể hiện phần cứng nào khác. Họ cũng phải hiện 1 chỉ số cho thấy rằng quyền được được cấp để sử dụng thiết bị đầu vào, kể cả nếu như thiết bị đó chưa được kích hoạt để ghi chép tại thời điểm đó. RTCPeerConnectionGiao diện RTCPeerConnection thể hiện 1 kết nối WebRTC giữa máy tính local và peer từ xa. Nó cung cấp các phương thức để kết nối đến peer từ xa, duy trì, kiểm soát kết nối và ngắt kết nối một khi nó không cần dùng tới nữa. Dưới đây là 1 mô hình kiến trúc của WebRTC thể hiện vai trò của RTCPeerConnection: Từ góc độ của Javascript, điều cần hiểu trong mô hình trên là RTCPeerConnection trao cho các web developer một cái nhìn tinh tế từ những sự phức tạp xuất phát từ đống “nội tạng” rối rắm bên dưới. Các mã codec và giao thức được dùng bởi WebRTC thực hiện 1 lượng lớn công việc dể làm cho giao tiếp real-time hoạt động được, kể cả với các mạng không đáng tin cậy: Che dấu mất gói tin (Package loss concealment - PLC, là 1 kỹ thuật dùng để che đậy ảnh hưởng của tình trạng mất gói tin trong giao tiếp VoIP) Hủy bỏ phản hồi (Echo cancellation - trong mạng máy tính thì “echo” được hiểu là quá trình gửi trả về gói tin đã gửi đi) Khả năng thích ứng băng thông Bộ đệm jitter động (jitter buffer - Trong kỹ thuật VoIP thì jitter buffer là vùng dữ liệu chia sẻ nơi mà các gói tin âm thanh có thể được thu thập, lưu trữ và gửi đi đến bộ xử lý âm thanh) Tự động chiếm quyền kiểm soát Giảm nhiễu và xóa nhiễu “Dọn dẹp” hình ảnh RTCDataChannelCũng như hình ảnh và âm thanh, WebRTC cũng hỗ trợ giao tiếp real-time cho các loại dữ liệu khác. API RTCDataChannel cho phép peer-to-peer trao đổi các dữ liệu tùy ý. Có rất nhiều trường hợp sử dụng API này, ví dụ: Dùng trong các game Ứng dụng chat real-time Truyền file Các mạng phi tập trung API cũng có nhiều tính năng để tận dụng tối đa RTCPeerConnection và kích hoạt sức mạnh cũng như sự linh động của giao tiếp peer-to-peer: Tận dụng cài đặt phiên của RTCPeerConnection Đa kênh đồng thời với khả năng phân chia mức độ ưu tiên Ngữ cảnh vận chuyển đáng tin cậy và không đáng tin cậy. Tích hợp sẵn bảo mật (DTLS) và kiểm soát tắc nghẽn. Cú pháp tương tự như WebSocket mà ta đã biết, với phương thức send() và sự kiện message: 1234567891011121314151617var peerConnection = new webkitRTCPeerConnection(servers, &#123;optional: [&#123;RtpDataChannels: true&#125;]&#125;);peerConnection.ondatachannel = function(event) &#123; receiveChannel = event.channel; receiveChannel.onmessage = function(event)&#123; document.querySelector(\"#receiver\").innerHTML = event.data; &#125;;&#125;;sendChannel = peerConnection.createDataChannel(\"sendDataChannel\", &#123;reliable: false&#125;);document.querySelector(\"button#send\").onclick = function ()&#123; var data = document.querySelector(\"textarea#send\").value; sendChannel.send(data);&#125;; Sự giao tiếp diễn ra trực tiếp giữa các trình duyệt, vì thế RTCDataChannel có thể nhanh hơn nhiều so với WebSocket kể cả khi cần đến 1 server chuyển tiếp (TURN). WebRTC trong thế giới thựcTrong thế giới thực thì WebRTC cần có server, tuy nhiên thực tế lại đơn giản hơn: Các user tự khám phá ra đối tác của họ và trao đổi các chi tiết chẳng hạn như tên. Các ứng dụng WebRTC phía client (các peer) trao đổi thông tin mạng. Các peer trao đổi dữ liệu về media chẳng hạn như định dạng hình ảnh và độ phân giải. Các ứng dụng WebRTC phía client di chuyển xuyên qua các cổng NAT và tường lửa. Nói cách khác, WebRTC cần phải có 4 tính năng ở phía server: User khám phá ra và giao tiếp. Signaling Di chuyển NAT/tường lửa Các server chuyển tiếp trong trường hợp giao tiếp peer-to-peer thất bại. Giao thức STUN và bản mở rộng TURN của nó được dùng bởi ICE để kích hoạt RTCPeerConnection nhằm đối phó với di chuyển NAT và các thay đổi mạng mơ hồ khác. Như đã nhắc đến trước đó, ICE là 1 giao thức để kết nối các peer, chẳng hạn như 2 ứng dụng video chat client. Khi khởi tạo, ICE sẽ thử kết nối trực tiếp đến các peer với độ trễ thấp nhất có thể thông qua UDP. Trong tiến trình này, các server STUN có 1 tác vụ duy nhất: kích hoạt 1 peer phía sau NAT để tìm địa chỉ public &amp; số port. Bạn có thể kiểm tra các server STUN đang tồn tại ở danh sách này (Google cũng có 1 số server) | | # source : http://code.google.com/p/natvpn/source/browse/trunk/stun_server_list || | # A list of available STUN server. || | || | stun.l.google.com:19302 || | stun1.l.google.com:19302 || | stun2.l.google.com:19302 || | stun3.l.google.com:19302 || | stun4.l.google.com:19302 || | stun01.sipphone.com || | stun.ekiga.net || | stun.fwdnet.net || | stun.ideasip.com || | stun.iptel.org || | stun.rixtelecom.se || | stun.schlund.de || | stunserver.org || | stun.softjoys.com || | stun.voiparound.com || | stun.voipbuster.com || | stun.voipstunt.com || | stun.voxgratia.org || | stun.xten.com | view raw stuns hosted with ❤ by GitHub. Tìm những ứng viên kết nốiNếu như UDP thất bại, ICE sẽ thử TCP: đầu tiên là HTTP, sau đó là HTTPS. Nếu kết nối trực tiếp thất bại - cụ thể là bởi vì dịch chuyển NAT &amp; tường lửa mức độ doanh nghiệp - ICE sẽ dùng 1 server TURN trung gian (điểm chuyển tiếp). Nói cách khác, ICE đầu tiên sẽ dùng STUN với UDP để kết nối trực tiếp các peer với nhau, nếu thất bại, nó sẽ đổi kế hoạch sang dùng server chuyển tiếp TURN. Cụm từ “tìm kiếm ứng viên” nhắc đến quá trình tìm kiếm các giao diện mạng &amp; port. Bảo mậtCó rất nhiều cách mà 1 ứng dụng hoặc plugin giao tiếp real-time có thể bị ảnh hưởng về bảo mật. Ví dụ: Dữ liệu hoặc media không được mã hóa có thể bị chặn trên đường đi giữa các trình duyệt hay giữa trình duyệt và server Một ứng dụng có thể ghi chép và phân phối âm thanh, hình ảnh mà user hoàn toàn không biết Malware hoặc virus máy tính có thể được cài đặt cùng với 1 ứng dụng hoặc plugin vớ vẩn. WebRTC có nhiều tính năng để tránh các vấn đề trên: WebRTC triển khai sử dụng các giao thức bảo mật chẳng hạn như DTLS và SRTP Mã hóa là điều cần thiết đối với tất cả các component của WebRTC, bao gồm cả cơ chế signaling. WebRTC không phải là 1 plugin: các component của nó chạy trong sandbox của trình duyệt và không chạy ở luồng riêng, các component không yêu cầu cài đặt riêng lẻ và được cập nhật mỗi khi trình duyệt được cập nhật. Truy xuất camera và microphone phải được cấp quyền rõ ràng và khi camera hoặc microphone đang hoạt động thì phải được thể hiện ra ở phía giao diện người dùng. WebRTC là 1 công nghệ cực kỳ thú vị &amp; mạnh mẽ dành cho các sản phẩm cần làm việc với mô hình truyền tải real-time giữa các trình duyệt. Ví dụ, ở SessionStack, họ cho phép user tích hợp thư viện Javascript của họ vào bên trong webapp của user. Nhiệm vụ của nó là bắt đầu thu thập các dữ liệu như sự kiện người dùng, thay đổi trên DOM, dữ liệu mạng, biệt lệ, thông báo debug, vân vân, và gửi chúng về cho server. Trong khi đó, user của bạn có thể vào trong webapp của họ, mở 1 phiên làm việc bình thường và xem nó hoạt động theo thời gian thực. Sử dụng các dữ liệu thu thập được, SessionStack có thể tái tạo mọi thứ đã từng xảy ra trên trình duyệt của user, kết hợp các thông tin về hình ảnh thuần túy với 1 bộ giả lập console của trình duyệt và mọi thứ bên trong nó. Bạn cứ nghĩ nó giống như desktop từ xa nhưng không bắt người dùng cuối phải tải về bất cứ chương trình nào. Và trên hết tất cả các thông tin hình ảnh, bạn có thể thực sự thấy được các thông tin kỹ thuật lấy từ phiên. Họ đã làm được tất cả điều đó thuần túy với các server, tuy nhiên sử dụng WebRTC họ có thể thật sự không cần phụ thuộc vào server nữa mà giao tiếp trực tiếp giữa các trình duyệt với nhau, giảm độ trễ và sức mạnh tính toán cần thiết.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P17: Bên trong Shadow DOM + xây dựng component khép kín","slug":"Cach-Javascript-hoat-dong-P17-Ben-trong-Shadow-DOM-xay-dung-component-khep-kin","date":"2019-01-05T16:50:00.000Z","updated":"2019-01-06T10:16:19.727Z","comments":true,"path":"2019/01/Cach-Javascript-hoat-dong-P17-Ben-trong-Shadow-DOM-xay-dung-component-khep-kin.html","link":"","permalink":"http://nthung2112.github.io/2019/01/Cach-Javascript-hoat-dong-P17-Ben-trong-Shadow-DOM-xay-dung-component-khep-kin.html","excerpt":"Trong bài có nhiều từ mình để nguyên mà không dịch nhé, vì dịch ra thì bay mất nghĩa @@_ element: phần tử custom element: phần tử tự tạo component: thành phần custom component: thành phần tự tạo markup: nói chung là ngôn ngữ đánh dấu, hay nói dễ hiểu hơn là code HTML (Hyper Text Markup Language) Chào các bạn đến với bài thứ 17 trong series khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định.","text":"Trong bài có nhiều từ mình để nguyên mà không dịch nhé, vì dịch ra thì bay mất nghĩa @@_ element: phần tử custom element: phần tử tự tạo component: thành phần custom component: thành phần tự tạo markup: nói chung là ngôn ngữ đánh dấu, hay nói dễ hiểu hơn là code HTML (Hyper Text Markup Language) Chào các bạn đến với bài thứ 17 trong series khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Khái quátWeb Components (Thành phần web) là 1 bộ các công nghệ khác nhau cho phép ta tạo ra những custom element có thể tái sử dụng. Tính năng của chúng được đóng gói tách hoàn toàn khỏi code và bạn có thể dùng nó trong webapp của mình. Có 4 loại Web Component tiêu chuẩn: Shadow DOM (Bóng của DOM) HTML Templates (các mẫu HTML) Custom elements (Các custom element) HTML Imports Trong bài này ta sẽ tập trung vào Shadow DOM Shadow DOM được thiết kế như 1 công cụ dùng để xây dựng các app dựa trên component. Nó cung cấp các giải pháp cho các vấn đề chung trong ngành phát triển web mà bạn chắc chắn đã gặp qua: Isolated DOM (DOM cô lập): 1 DOM của component khép kín (ví dụ: document.querySelector() không trả về các node trong Shadow DOM của component). Điều này cũng làm đơn giản hóa các CSS Selector trong webapp của bạn bởi vì các DOM component đều bị cô lập, nó cho phép bạn khả năng sử dụng chung nhiều id/class mà không lo bị xung đột về cách đặt tên. Scoped CSS (CSS trong phạm vi): CSS định nghĩa bên trong Shadow DOM chỉ có phạm vi trong nó. Các quy tắc về style không lọt ra ngoài và style của trang cũng không can thiệp vào nó. Composition (kết hợp): Thiết kế 1 API khai báo, dựa trên markup cho component của bạn. Shadow DOMBài viết này giả định rằng bạn đã quen thuộc với các khái niệm và API về DOM. Nếu bạn chưa rõ thì có thể đọc bài viết chi tiết về nó ở đây: https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction Shadow DOM cũng chỉ là 1 DOM bình thường, ngoại trừ 2 điều sau: Cách tạo ra/sử dụng trong mối quan hệ với toàn bộ trang so với cách mà bạn tạo/sử dụng DOM thường. Cách tương tác của nó trong mối quan hệ với toàn bộ trang Một cách tổng quát, bạn tạo ra các node DOM và nối (append) chúng dưới dạng children vào element khác. Trong trường hợp của Shadow DOM, bạn tạo ra 1 cây DOM trong phạm vi (scoped DOM) và được kết nối vào element tuy nhiên nó tách biệt với children của chính nó. Cây con trong phạm vi này được gọi là shadow tree. Element mà nó nối vào được gọi là shadow host. Bất cứ thứ gì bạn thêm vào shadow tree trở thành 1 phần local của element chủ, bao gồm cả &lt;style&gt;. Đây là cách mà Shadow DOM có được phạm vi của CSS style. Tạo Shadow DOMMột shadow root là 1 phần của document và được nối vào 1 element chủ (host element). Thời điểm bạn nối 1 shadow root chính là lúc element có được shadow DOM của nó. Để tạo shadow DOM cho 1 element, ta gọi element.attachShadow(): 123456var header = document.createElement('header');var shadowRoot = header.attachShadow(&#123;mode: 'open'&#125;);var paragraphElement = document.createElement('p');paragraphElement.innerText = 'Shadow DOM';shadowRoot.appendChild(paragraphElement); Phần thông số kỹ thuật này định nghĩa 1 danh sách các element mà shadow tree không thể nối vào. Tính kết hợp trong Shadow DOMTính kết hợp là 1 trong số những tính năng quan trọng nhất của Shadow DOM. Khi viết code HTML, “kết hợp” là cách mà bạn xây dựng webapp. Bạn kết nối và cài đặt các viên gạch khác nhau (còn gọi là các element) chẳng hạn như &lt;div&gt;, &lt;header&gt;, &lt;form&gt;, vân vân, để xây dựng UI cho webapp. Một số tag thậm chí có thể hoạt động với nhau. Sự kết hợp định nghĩa tại sao các element như &lt;select&gt;, &lt;form&gt;, &lt;video&gt;… lại linh động và chấp nhận các element HTML cụ thể làm children của nó để thực hiện các công việc đặc biệt. Ví dụ, &lt;select&gt; biết cách render các element &lt;option&gt; thành 1 danh sách dropdown với các item được định nghĩa trước. Shadow DOM giới thiệu các tính năng sau mà từ đó ta có thể thực hiện tính “kết hợp”. Light DOM (DOM nhẹ)Đây là đoạn markup mà user của component của bạn viết ra. DOM này tồn tại bên ngoài Shadow DOM của component. Nó là một children thực của element. Tưởng tượng rằng bạn đã tạo ra 1 custom component có tên &lt;extended-button&gt; có thể mở rộng button mặc định của HTML và bạn muốn thêm 1 bức hình, thêm vài đoạn text bên trong nó, thì dưới đây là những gì mà nó nên có: 12345&lt;extended-button&gt; &lt;!-- thẻ img và span là Light DOM của extended-button --&gt; &lt;img src=\"boot.png\" slot=\"image\"&gt; &lt;span&gt;Launch&lt;/span&gt;&lt;/extended-button&gt; extended-button là component tùy chọn mà bạn định nghĩa, đoạn HTML bên trong nó được gọi là Light DOM và được thêm vào bởi user của component của bạn. Shadow DOM ở đây chính là component mà bạn đã tạo ra (tức là &lt;extended-button&gt;). Với component thì Shadow DOM là local, nó định nghĩa cho chính bản thân nó cấu trúc nội bộ, CSS trong phạm vi và đóng gói toàn bộ các chi tiết về triển khai. Flattened DOM tree (Cây DOM phẳng)Kết quả của trình duyệt khi phân phối Light DOM - một sản phẩm được tạo ra bởi user và đặt vào trong Shadow DOM của bạn cùng với phần định nghĩa của custom component, sẽ render ra sản phẩm cuối cùng. Cây phẳng (flattened tree) là những gì sau cuối mà bạn thấy trong DevTools và được render trên trang. 123456789101112&lt;extended-button&gt; #shadow-root &lt;style&gt;…&lt;/style&gt; &lt;slot name=\"image\"&gt; &lt;img src=\"boot.png\" slot=\"image\"&gt; &lt;/slot&gt; &lt;span id=\"container\"&gt; &lt;slot&gt; &lt;span&gt;Launch&lt;/span&gt; &lt;/slot&gt; &lt;/span&gt;&lt;/extended-button&gt; TemplatesKhi bạn phải tái sử dụng liên tục 1 vài đoạn markup nào đó trên trang web, cách tốt hơn là ta sử dụng 1 kiểu template hơn là cứ lặp đi lặp lại cùng 1 cấu trúc đó hết lần này đến lần khác. Trước đây vẫn làm được điều này nhưng bây giờ thì dễ hơn nhiều với element HTML &lt;template&gt; hỗ trợ sẵn bởi rất nhiều trình duyệt hiện đại. Element này và nội dung của nó không được render trên DOM nhưng nó vẫn có thể tham chiếu đến bằng Javascript. Cùng xem 1 ví dụ đơn giản nào: 123&lt;template id=\"my-paragraph\"&gt; &lt;p&gt; Paragraph content. &lt;/p&gt;&lt;/template&gt; Đoạn code đó sẽ không hiển thị trên trang của bạn trừ khi bạn tham chiếu đến nó bằng Javascript và nối nó vào DOM bằng 1 cách nào đó, chẳng hạn như: 123var template = document.getElementById('my-paragraph');var templateContent = template.content;document.body.appendChild(templateContent); Giờ đây, để đạt được cùng 1 mục đích chung thì có nhiều kỹ thuật khác nhau để lựa chọn nhưng như đã đề cập trước đây, sẽ dễ dàng hơn nhiều nếu như các kỹ thuật đó được hỗ trợ natively. template được các trình duyệt hỗ trợ khá tốt (trừ IE) Tự bản thân template đã rất có ích rồi, nhưng nó còn hoạt động tốt hơn nữa với các custom element. Chúng ta sẽ định nghĩa vài custom element trong 1 bài viết khác, còn bây giờ, trong lúc này thì bạn nên biết là có 1 API customElement trên trình duyệt cho phép chúng ta định nghĩa thẻ (tag) riêng của ta với các tùy chọn render. Giờ ta sẽ định nghĩa 1 web component sử dụng template trên làm nội dung cho Shadow DOM, chúng ta gọi nó là : 12345678910customElements.define('my-paragraph', class extends HTMLElement &#123; constructor() &#123; super(); let template = document.getElementById('my-paragraph'); let templateContent = template.content; const shadowRoot = this.attachShadow(&#123;mode: 'open'&#125;).appendChild(templateContent.cloneNode(true)); &#125;&#125;); Điểm then chốt cần chú ý ở đây là chúng ta nối 1 bản sao của nội dung template vào shadow root - thứ được tạo ra bằng phương thức Node.cloneNode() Và bởi vì ta nối nội dung của nó với 1 Shadow DOM nên ta có thể đưa thêm 1 vài thông tin về style bên trong template với element &lt;style&gt;, sau đó phần style này sẽ được đóng gói bên trong custom element. Phần này sẽ không hoạt động nếu ta chỉ nối nó vào 1 DOM bình thường. Ví dụ ta đổi template thành như sau: 12345678910&lt;template id=\"my-paragraph\"&gt; &lt;style&gt; p &#123; color: white; background-color: #666; padding: 5px; &#125; &lt;/style&gt; &lt;p&gt;Paragraph content. &lt;/p&gt;&lt;/template&gt; Giờ thì component tùy chọn ta đã định nghĩa với template trên có thể được dùng như thế này:&lt;my-paragraph&gt;&lt;/my-paragraph&gt; Slots (khe trống)Templates có một vài nhược điểm, 1 trong số đó là nội dung của nó thuộc loại “tĩnh”, không cho phép ta render kèm theo các dữ liệu hoặc biến để làm cho nó hoạt động theo cách bình thường như các template HTML tiêu chuẩn mà ta thường sử dụng. Và đây là lúc mà &lt;slot&gt; xuất hiện. Bạn có thể tưởng tượng rằng slots giống như người giữ chỗ, nó cho phép bạn đặt HTML riêng của mình vào trong template. Nó giúp cho bạn tạo ra các template HTML linh động hơn, dễ tùy biến hơn bằng cách thêm vào nhiều slot. Viết lại template ở phần trên với slot: 12345&lt;template id=\"my-paragraph\"&gt; &lt;p&gt; &lt;slot name=\"my-text\"&gt;Default text&lt;/slot&gt; &lt;/p&gt;&lt;/template&gt; Nếu như nội dung của slot không được định nghĩa khi element được đính kèm theo markup, hoặc nếu như trình duyệt không hỗ trợ slot thì &lt;my-paragraph&gt; sẽ chỉ hiện dòng nội dung backup “Default text”. Để định nghĩa nội dung slot, ta cần đính kèm 1 cấu trúc HTML bên trong element &lt;my-paragraph&gt; với thuộc tính slot và gán giá trị của nó với name của slot mà ta muốn nó truyền vào. Giống như code dưới đây: 123&lt;my-paragraph&gt; &lt;span slot=\"my-text\"&gt;Let's have some different text!&lt;/span&gt;&lt;/my-paragraph&gt; Các element có thể được chèn vào trong slot được gọi là Slotable; khi 1 element được chèn vào trong slot thì ta nói nó đã bị slotted. Để ý rằng ví dụ trên chúng ta đã chèn 1 element vào, nó chính là slotted element. Nó có 1 thuộc tính slot giá trị bằng my-text - cùng giá trị với thuộc tính name trong phần định nghĩa của slot ở template. Sau khi được render trên trình duyệt, đoạn code trên sẽ tạo ra 1 cây Flattened DOM như sau: 12345678&lt;my-paragraph&gt; #shadow-root &lt;p&gt; &lt;slot name=\"my-text\"&gt; &lt;span slot=\"my-text\"&gt;Let's have some different text!&lt;/span&gt; &lt;/slot&gt; &lt;/p&gt;&lt;/my-paragraph&gt; Lưu ý đến phần tử #shadow-root - nó xuất hiện như 1 chỉ thị rằng Shadow DOM đang tồn tại ở đây. StylingMột component sử dụng Shadow DOM có thể được tùy chỉnh style từ trang chính, có thể định nghĩa style của riêng nó hoặc cung cấp hook dưới dạng thuộc tính tùy chỉnh CSS để user có thể ghi đè những thiết lập mặc định. Định nghĩa style cho componentScoped CSS (CSS trong phạm vi) là 1 trong số các tính năng tuyệt vời nhất của Shadow DOM: Các CSS selector từ trang bên ngoài sẽ không áp dụng được vào bên trong component của bạn Các style định nghĩa bên trong component sẽ không ảnh hưởng đến toàn bộ trang. Chúng được đóng gói trong phạm vi của element chủ. Các CSS selector được dùng bên trong Shadow DOM áp dụng với component một cách cục bộ. Trong thực tiễn thì điều này nghĩa là ta có thể dùng nhiều lần các tên id/class phổ biến mà không cần lo về sự xung đột giữa chúng trên trang. CSS selector càng đơn giản thì càng có hiệu năng tốt hơn. Giờ ta cùng xem 1 đoạn #shadow-root dưới đây định nghĩa style: 123456789101112#shadow-root&lt;style&gt; #container &#123; background: white; &#125; #container-items &#123; display: inline-flex; &#125;&lt;/style&gt;&lt;div id=\"container\"&gt;&lt;/div&gt;&lt;div id=\"container-items\"&gt;&lt;/div&gt; Tất cả style ở ví dụ trên đều nằm trong vùng local của #shadow-root Bạn có thể dùng element &lt;link&gt; để chèn thêm stylesheets ở ngoài vào trong #shadow-root và nó cũng sẽ thuộc về vùng local. pseudo-class :host_Ai chưa biết về pseudo-class thì có thể tham khảo ở đây: https://www.w3schools.com/css/css_pseudo_classes.asp_ :host cho phép bạn chọn và chỉnh style cho element làm host (chủ) của shadow tree: 12345&lt;style&gt; :host &#123; display: block; /* mặc định thì các custom element có thuộc tính display: inline */ &#125;&lt;/style&gt; Có 1 điều bạn cần phải cẩn thận khi sử dụng :host: phần định nghĩa :host trong các trang cha (parent) sẽ có ưu tiên cao hơn định :host định nghĩa trong element. Điều này cho phép người dùng có thể ghi đè phần định nghĩa style cao nhất từ bên ngoài. Bên cạnh đó, :host chỉ hoạt động trong ngữ cảnh của 1 shadow root, vì vậy bạn không thể dùng nó bên ngoài Shadow DOM. Dạng function :host() cho phép bạn trỏ trực tiếp đến host nếu nó khớp với 1 . Đây là 1 cách rất tuyệt vời để component của bạn có thể đóng gói các hành vi phản hồi đến các tương tác hoặc trạng thái người dùng và chỉnh style cho các node bên trong dựa trên host: 12345678910111213141516171819&lt;style&gt; :host &#123; opacity: 0.4; &#125; :host(:hover) &#123; opacity: 1; &#125; :host([disabled]) &#123; /* style khi host có thuộc tính disabled */ background: grey; pointer-events: none; opacity: 0.4; &#125; :host(.pink) &gt; #tabs &#123; color: pink; /* tô màu cho node #tabs khi host có class=\"pink\" */ &#125;&lt;/style&gt; Dựng chủ đề (theme) và element với pseudo-class :host-context(&lt;selector&gt;)Pseudo-class :host-context(&lt;selector&gt;) khớp host element nếu nó hoặc bất kỳ element cha (ancestor) nào của nó khớp với . Một ví dụ phổ biến cho trường hợp này là làm việc với chủ để (theming). Thực tế là có rất nhiều người khi làm theme đều thêm class vào thẻ &lt;html&gt; hoặc &lt;body&gt;: 12345&lt;body class=\"lightheme\"&gt; &lt;custom-container&gt; … &lt;/custom-container&gt;&lt;/body&gt; :host-context(.lightheme) sẽ chỉnh style cho khi nó là con cháu (descendant) của .lightheme: 1234:host-context(.lightheme) &#123; color: black; background: white;&#125; :host-context() có thể có ích cho theming nhưng có 1 cách khác còn tốt hơn nữa, đó là định nghĩa 1 style hooks sử dụng các thuộc tính custom của CSS, bạn có thể xem ở đây: https://developers.google.com/web/fundamentals/web-components/shadowdom#stylehooks Chỉnh style cho host element của component từ bên ngoàiBạn có thể chỉnh style cho host element của component từ bên ngoài vào bằng cách dùng tag name của nó như 1 selector, kiểu vậy nè: 123custom-container &#123; color: red;&#125; Style bên ngoài có mức ưu tiên cao hơn style định nghĩa bên trong Shadow DOM. Ví dụ, nếu user viết 1 selector như sau: 123custom-container &#123; width: 500px;&#125; …thì nó sẽ ghi đè lên rule của component: 123:host &#123; width: 300px;&#125; Tức là width lúc này có giá trị 500px Styling chính component thì chỉ có thể đến mức này thôi. Vậy nếu bạn muốn style các thành phần sâu hơn bên trong của component thì sao? Ta sẽ cần đến các thuộc tính custom của CSS. Tạo style hook sử dụng thuộc tính custom của CSSUser có thể dùng mẹo để chỉnh style cho các thành phần bên trong nếu như tác giả của component đó có cung cấp styling hook sử dụng thuộc tính custom của CSS. Ý tưởng tương tự với &lt;slot&gt; nhưng áp dụng cho style. Cùng xem ví dụ bên dưới: 123456789&lt;!-- main page --&gt;&lt;style&gt; custom-container &#123; margin-bottom: 60px; - custom-container-bg: black; &#125;&lt;/style&gt;&lt;custom-container background&gt;…&lt;/custom-container&gt; bên trong Shadow DOM của nó: 12345:host([background]) &#123; background: var( - custom-container-bg, #CECECE); border-radius: 10px; padding: 10px;&#125; Trong trường hợp này, component sẽ sử dụng màu black làm giá trị cho background bởi vì user muốn thế. Nếu không thì nó sẽ dùng giá trị mặc định là #CECECE. Nếu là tác giả của component, bạn có trách nhiệm cho developer biết về những thuộc tính custom của CSS mà họ có thể sử dụng. Hãy xem như đó là luật bất thành văn khi public một component. Javascript API cho slotShadow DOM API cung cấp nhiều tiện ích hữu dụng để làm việc với slot Sự kiện slotchangeSự kiện slotchange được bắn ra khi node phân phối của slot bị thay đổi. Ví dụ, nếu user thêm/bớt children từ light DOM. 1234var slot = this.shadowRoot.querySelector('#some_slot');slot.addEventListener('slotchange', function(e) &#123; console.log('Light DOM change');&#125;); Để kiểm soát các kiểu thay đổi khác trên light DOM, bạn có thể dùng MutationObserver trong constructor của element. Chúng ta đã từng thảo luận về nó trong Phần 10 rồi. Phương thức assignedNodes()Sẽ rất có ích khi biết rằng các element có liên kết với slot. Gọi slot.assignedNodes() sẽ cho phép bạn biết những element nào mà slot render. Option {flatten: true} cũng sẽ trả về nội dung fallback của slot (nếu như không có node nào đang được phân phối). Cùng xem ví dụ sau đây: 1&lt;slot name='slot1'&gt;&lt;p&gt;Default content&lt;/p&gt;&lt;/slot&gt; Giả sử nó nằm trong 1 component gọi là &lt;my-container&gt; Giờ ta sẽ test thử các cách sử dụng khác nhau của component này và kết quả trả về của assignedNodes(): Trường hợp đầu tiên, ta sẽ thêm nội dung vào slot: 123&lt;my-container&gt; &lt;span slot=\"slot1\"&gt; container text &lt;/span&gt;&lt;/my-container&gt; Gọi assignedNodes() sẽ có kết quả [&lt;span slot=&#39;slot1&#39;&gt; container text &lt;/span&gt;]. Để ý rằng kết quả là 1 array các node. Trong trường hợp thứ 2, ta để nội dung trống trơn:&lt;my-container&gt; &lt;/my-container&gt; Kết quả khi gọi assignedNodes() là 1 array rỗng []. Tuy nhiên nếu như bạn đẩy thêm option {flatten: true} thì nó sẽ lấy giá trị mặc định và trả về [Default content]. Ngoài ra, để có thể chạm tới 1 element bên trong slot, bạn có thể gọi assignedNodes() để xem nếu có element nào đang được gán vào component slot hay không. Mô hình sự kiện (event model)Thật thú vị khi để ý thấy điều gì xảy ra khi 1 sự kiện nằm trong Shadow DOM được bắn ra. Mục tiêu của sự kiện được điều chỉnh để bảo trì sự đóng gói, cô lập bởi Shadow DOM. Khi 1 sự kiện được tái-mục-tiêu (re-target), trông giống như là nó xuất phát từ chính component hơn là từ các element bên trong của Shadow DOM - vốn là 1 phần của component. Dưới đây là danh sách các sự kiện có thể phát ra ngoài Shadow DOM (1 số thì không): Sự kiện Focus: blur, focus, focusin, focusout Sự kiện cho con trỏ chuột: click, dbclick, mousedown, mouseenter, mousemove, vân vân. Sự kiện cho con lăn chuột: wheel Sự kiện cho input: beforeinput, input Sự kiện cho bàn phím: keydown, keyup Sự kiện kết hợp: compositionstart, compositionupdate, compositionend Sự kiện kéo-thả: dragstart, drag, dragend, drop, vân vân. Các sự kiện customCác sự kiện custom mặc định thì không phát ra bên ngoài Shadow DOM. Nếu bạn muốn điều phối 1 sự kiện custom và muốn nó phát ra ngoài, bạn cần thêm 2 option: bubbles: true và composed: true Ví dụ: 12var container = this.shadowRoot.querySelector('#container');container.dispatchEvent(new Event('containerchanged', &#123;bubbles: true, composed: true&#125;)); Sự hỗ trợ trình duyệt: Để xác định xem trình duyệt có sẵn hỗ trợ cho Shadow DOM hay không thì ta có thể kiểm tra sự tồn tại của attachShadow: 1const supportsShadowDOMV1 = !!HTMLElement.prototype.attachShadow; Nhưng nói chung là không được nhiều cho lắm: Nhìn chung thì Shadow DOM có lối hành xử rất khác với DOM thường. Team SessionStack có 1 chút kinh nghiệm khi sử dụng chúng trong thư viện của họ. Thư viện đó khi được tích hợp vào trong webapp thì sẽ bắt đầu thu thập các thông tin chẳng hạn như sự kiện người dùng, dữ liệu mạng, biệt lệ, thông báo debug, thay đổi trên DOM, vân vân, và gửi chúng về cho server của họ. Sau đó, họ sẽ xử lý các dữ liệu thu được để cho phép bạn có thể dùng SessionStack để tái hiện lại các vấn đề xảy ra trong sản phẩm của bạn. Sự khó khăn họ gặp phải trong quá trình phát triển khi sử dụng Shadow DOM: họ phải kiểm soát mọi thay đổi trên DOM để có thể tái tạo lại sau này. Họ dùng MutationObserver để làm việc đó. Tuy nhiên, Shadow DOM không trigger các sự kiện MutationObserver trong phạm vi toàn cục, nghĩa là họ phải xử lý các component này theo 1 cách hoàn toàn khác.Họ cũng nhận thấy rằng ngày nay, có rất nhiều webapp đang tận dụng sức mạnh của Shadow DOM nên có vẻ như công nghệ này sẽ có 1 tương lai rất rạng ngời.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P16: Engine lưu trữ + lựa chọn API lưu trữ nào cho phù hợp","slug":"Cach-Javascript-hoat-dong-P16-Engine-luu-tru-lua-chon-API-luu-tru-nao-cho-phu-hop","date":"2018-11-25T09:42:00.000Z","updated":"2018-11-25T09:44:30.253Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P16-Engine-luu-tru-lua-chon-API-luu-tru-nao-cho-phu-hop.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P16-Engine-luu-tru-lua-chon-API-luu-tru-nao-cho-phu-hop.html","excerpt":"Chào các bạn đến với bài thứ 16 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Khái quátLựa chọn cơ chế lưu trữ đúng đắn cho thiết bị lưu trữ ở local rất quan trọng khi thiết kế webapp. Một engine lưu trữ tốt sẽ đảm bảo thông tin của bạn được lưu chắc chắn, giảm băng thông và cải thiện sự phản hồi. Chiến lược lưu trữ bộ nhớ đệm phù hợp là thành phần cốt lõi cho phép trải nghiệm mobile web offline, càng ngày càng có nhiều người dùng cảm thấy rằng như đó là trải nghiệm mặc định phải có. Trong chương này, chúng ta sẽ thảo luận về những API lưu trữ có sẵn &amp; các service và cung cấp một số hướng dẫn làm thế nào để lựa chọn đúng loại cho webapp của bạn.","text":"Chào các bạn đến với bài thứ 16 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Khái quátLựa chọn cơ chế lưu trữ đúng đắn cho thiết bị lưu trữ ở local rất quan trọng khi thiết kế webapp. Một engine lưu trữ tốt sẽ đảm bảo thông tin của bạn được lưu chắc chắn, giảm băng thông và cải thiện sự phản hồi. Chiến lược lưu trữ bộ nhớ đệm phù hợp là thành phần cốt lõi cho phép trải nghiệm mobile web offline, càng ngày càng có nhiều người dùng cảm thấy rằng như đó là trải nghiệm mặc định phải có. Trong chương này, chúng ta sẽ thảo luận về những API lưu trữ có sẵn &amp; các service và cung cấp một số hướng dẫn làm thế nào để lựa chọn đúng loại cho webapp của bạn. Data model (mô hình dữ liệu)Mô hình lưu trữ dữ liệu xác định làm thế nào để dữ liệu được tổ chức nội bộ. Điều này ảnh hưởng toàn bộ thiết kế của webapp, định nghĩa sự cân bằng để làm cho webapp hoạt động hiệu quả nhưng vẫn giải quyết được vấn đề cần giải quyết. Giống như bất cứ thứ gì liên quan đến kỹ thuật, không tồn tại phương pháp nào “tốt hơn” và cũng không có giải pháp một-cho-tất-cả nào hết. Cùng xem qua 1 chút về một số data model mà ta có thể dùng: Kiểu cấu trúc: Dữ liệu được lưu trong các bảng kèm với các trường đã được định nghĩa, giống như các hệ quản trị cơ sở dữ liệu đặc trưng dựa trên SQL, chúng có tính linh hoạt và các câu truy vấn động. Một ví dụ nổi bật về kho dữ liệu kiểu cấu trúc trên trình duyệt chính là IndexedDB. key/value: kho dữ liệu key/value, và cả cơ sở dữ liệu NoSQL, cho phép lưu trữ và trích xuất dữ liệu không có cấu trúc được đánh index bằng 1 key duy nhất. Kho dữ liệu kiểu key/value giống như bảng băm (hash table) ở chỗ chúng cho phép truy cập liên tục vào các dữ liệu ẩn đã được đánh index. Một ví dụ điển hình cho kho dữ liệu key/value là Cache API trên trình duyệt và Apache Cassandra trên server. Byte Streams: mô hình đơn giản này lưu dữ liệu dưới dạng 1 biến độ dài, một chuỗi ẩn các byte, và nó để lại bất kỳ hình thức tổ chức nội bộ nào cho lớp ứng dụng. Mô hình này đặc biệt tốt cho các hệ thống tập tin (file) và các blob dữ liệu có tổ chức dạng phân cấp. Ví dụ điển hình của kho dữ liệu byte stream bao gồm những hệ thống file và các dịch vụ lưu trữ cloud. Tính bền vữngCó thể phân tích các phương pháp lưu trữ cho webapp với sự mức độ ưu tiên cho timeframe hơn là dữ liệu nào cần được bền vững: Session Persistence (Bền vững phiên): dữ liệu trong mục này chỉ được giữ cố định miễn là một session của web hoặc một tab trên trình duyệt vẫn đang hoạt động. Ví dụ về cơ chế lưu trữ với phiên bền vững chính là Session Storage API Device Persistence (Bền vững thiết bị): dữ liệu trong mục này được giữ cố định xuyên suốt nhiều session và nhiều tab hoặc cửa sổ trình duyệt, trên 1 thiết bị cụ thể. Ví dụ: Cache API Global Persistence (Bền vững toàn cục): dữ liệu trong mục này được giữ cố định xuyên suốt các session &amp; các thiết bị. Vì thế, đây là dạng mạnh mẽ nhất của bền vững dữ liệu. Nó không được lưu trữ trên chính thiết bị và điều đó nghĩa là bạn cần phải có 1 kiểu lưu trữ ở phía server. Chúng ta sẽ không thảo luận chi tiết về nó vì bài viết này chỉ tập trung vào lưu trữ dữ liệu trên thiết bị. Bền vững dữ liệu trên trình duyệtNgày nay có rất ít các browser API cho phép bạn lưu trữ dữ liệu. Chúng ta sẽ tìm hiểu qua một vài thứ như thế và tạo 1 bản so sánh để có thể dễ dàng lựa chọn giải pháp phù hợp. Tuy nhiên thì đầu tiên, có vài thứ bạn cần phải cân nhắc trước khi chọn làm thế nào để cố định dữ liệu. Dĩ nhiên thì thứ đầu tiên bạn cần phải hiểu kỹ chính là webapp của bạn được dùng như thế nào, sau đó còn có bảo trì và nâng cấp. Thậm chí nếu bạn có câu trả lời cho các câu hỏi đó, bạn cũng sẽ phải kết thúc với 1 số lựa chọn và chọn chúng. Vì thế nên dưới đây là 1 số thứ bạn nên xem qua: Trình duyệt hỗ trợ: bạn cần phải nhớ kỹ 1 sự thật là các API được xây dựng tốt &amp; được chuẩn hóa có mức độ ưu ái cao hơn, bởi vì chúng hướng tới sự tồn tại lâu dài và được hỗ trợ rộng rãi. Những API đó cũng thường có tài liệu rộng hơn và cộng đồng developer hỗ trợ giàu kinh nghiệm hơn. Transactions (giao dịch): đôi khi transactions rất quan trọng đối với 1 tập hợp của các hoạt động lưu trữ tự động thành công hay thất bại. Các cơ sở dữ liệu theo truyền thống luôn hỗ trợ tính năng này sử dụng 1 mô hình transaction, những cập nhật liên quan được nhóm lại thành các đơn vị chuyên biệt. Sync/Async (đồng bộ/bất đồng bộ): một vài API lưu trữ thể hiện sự đồng bộ khi mà các request lưu trữ hoặc lấy dữ liệu sẽ chặn tiến trình đang hoạt động cho tới khi request được hoàn thành. Sử dụng API lưu trữ đồng bộ có thể chặn tiến trình chính và làm cho trải nghiệm UI trên webapp bị đông cứng không hoạt động. Nếu có thể, hãy dùng các API bất đồng bộ. So sánhTrong phần này, chúng ta sẽ so sánh các API hiện có dành cho web developer và so sánh chúng với các tiêu chí đã nói ở trên API Mô hình dữ liệu (Data model) Tính bền vững (persistence) Trình duyệt hỗ trợ Transactions Sync/Async File System (hệ thống file) Byte stream thiết bị 52% Không Async Local Storage key/value thiết bị 93% Không Sync Session Storage key/value session 93% Không Sync Cookies cấu trúc thiết bị 100% Không Sync Cache key/value thiết bị 60% Không Async IndexedDB hỗn hợp (hybrid) thiết bị 83% Có Async File System API (hệ thống file) Với File System API, webapp có thể tạo, đọc, điều hướng và ghi vào 1 khu vực sandbox thuộc hệ thống local file của user. API được chia nhỏ thành nhiều chủ đề: Đọc và sửa file: File/Blob, FileList, FileReader Tạo và ghi file: Blob(), FileWriter Các thư mục và truy cập hệ thống file: DirectoryReader, FileEntry/DirectoryEntry, LocalFileSystem File System API không phải là 1 hệ thống API tiêu chuẩn. Bạn không nên dùng nó trên sản phẩm webapp production bởi vì nó sẽ không hoạt động với tất cả user. Có rất sự không tương thích lớn giữa các triển khai khác nhau và hành vi của chúng sẽ chắc chắn bị thay đổi trong tương lai. FileSystem - interface của File &amp; Directory Entries API được dùng để thể hiện 1 hệ thống file. Những object này có thể được lấy từ thuộc tính filesystem của bất kỳ entry thuộc hệ thống file nào. Một vài trình duyệt cung cấp thêm các API để tạo &amp; quản lý các hệ thống file. Interface này sẽ không cấp quyền cho bạn truy cập vào hệ thống file của user. Thay vào đó, bạn sẽ có 1 “ổ đĩa ảo” (virtual drive) bên trong sandbox của trình duyệt. Nếu bạn muốn truy cập vào hệ thống file của user, bạn cần phải gọi hỏi user bằng cách ví dụ như cài 1 Chrome extension. Yêu cầu 1 hệ thống fileMột webapp có thể yêu cầu truy cập đến một hệ thống file sandbox bằng cách gọi: window.requestFileSystem(): 123// Lưu ý: Hệ thống file đã được đánh tiền tố tính đến Google Chrome 12.window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;window.requestFileSystem(type, size, successCallback, opt_errorCallback) Nếu bạn gọi hàm requestFileSystem() lần đầu tiên thì 1 vùng lưu trữ mới được tạo ra. Quan trọng hãy nhớ rằng hệ thống file này được gói gọn trong sandbox, nghĩa là 1 webapp không thể truy cập file của webapp khác. Sau khi bạn có quyền truy cập vào hệ thống file, bạn có thể làm tất cả các hoạt động cơ bản với file &amp; thư mục. FileSystem là 1 lựa chọn lưu trữ khá khác biệt với các loại khác vì nó hướng đến thỏa mãn như cầu lưu trữ ở phía client trong những tình huống không dùng được cơ sở dữ liệu. Một cách tổng quát thì đó là những ứng dụng hoạt động với những cục blob nhị phân cỡ bự và/hoặc chia sẻ dữ liệu với các ứng dụng khác bên ngoài trình duyệt. Dưới đây là những trường hợp có thể sử dụng FileSystem API: Tải lên (upload) liên tục: khi 1 file hay thư mục được chọn để upload, nó copy các file vào trong 1 vùng local sandbox và upload từng phần, từng phần. Video game, âm nhạc hoặc các app khác mà có nhiều tài nguyên media. Chỉnh sửa âm thanh/hình ảnh với truy cập offline hoặc là lưu đệm local để tăng tốc độ - những cục blob dữ liệu như thế thường rất lớn khi đọc-ghi. Xem video offline - cần phải download 1 lượng lớn file để xem sau hoặc seek + streaming hiệu quả. Ứng dụng Web Mail offline - download các file đính kèm và lưu chúng ở local. Tình hình hỗ trợ của API: Local Storage API localstorage cho phép bạn truy cập object Storage dành cho origin của Document. Dữ liệu lưu trữ xuyên suốt nhiều session trình duyệt. localstorage tương tự như sessionStorage, ngoại trừ việc dữ liệu lưu ở trong dataStorage không bị hết hạn, dữ liệu trong sessionStorage sẽ bị dọn dẹp khi session của trang kết thúc, tức là khi đóng tab trang đó. Để ý rằng dữ liệu lưu trong localStorage hay sessionStorage là cụ thể cho origin của từng trang, bao gồm sự kết hợp của giao thức (protocol), host và cổng (port). Tình hình hỗ trợ sáng sủa của nó: Session Storage sessionStorage cho phép bạn truy cập vào 1 object Storage của session cho origin hiện tại. sessionStorage tương tự như localStorage, như đã giải thích ngắn gọn ở trên. Điểm khác biệt duy nhất là dữ liệu lưu trong localStorage không bị hết hạn, còn trong sessionStorage thì bị xóa khi session của trang kết thúc. Một session của trang tồn tại miễn là cửa sổ trình duyệt vẫn còn mở và tồn tại khi trang reload hoặc restore. Mở trang trong 1 tab mới hoặc cửa sổ mới sẽ tạo ra session mới, khác với cách hoạt động của session cookies. Dữ liệu lưu trong sessionStorage hay localStorage là dành riêng cho origin của trang. Tình hình hỗ trợ của sessionStorage: Cookies Một cookie (hay web cookie, cookie trình duyệt) là 1 cục dữ liệu nhỏ xíu mà server gửi đến trình duyệt của user. Trình duyệt có thể lưu nó và gửi ngược về cùng server đó trong request tiếp theo. Thông thường, nó được dùng để cho biết nếu 2 request đến từ cùng 1 trình duyệt - ví dụ: giữ cho user tiếp tục đăng nhập. Nó ghi nhớ thông tin trạng thái cho giao thức HTTP không trạng thái (stateless). Cookies có 3 trường hợp dùng chính: Quản lý session: login, giỏ hàng online, lưu điểm game hay bất cứ thứ gì server cần nhớ. Cá nhân hóa (Personalization): các thiết đặt của người dùng, chủ để và những cài đặt khác. Theo dõi: ghi lại và phân tích hành vi của người dùng. Cookies đã từng được dùng để lưu trữ tổng quát ở phía client. Như vậy vẫn hợp pháp vì lúc đó nó là giải pháp duy nhất để lưu trữ thông tin ở phía client, ngày nay thì người ta thường chọn các API lưu trữ hiện đại hơn. Cookies được gửi về với mỗi request nên có thể ảnh hưởng xấu đến hiệu năng (đặc biệt với các kết nối trên thiết bị di động). Có 2 loại cookies: Cookie phiên (session cookies: Chúng bị xóa khi client tắt. Trình duyệt web có thể dùng khôi phục session để lấy lại gần hết session cookies, giống như là trình duyệt chưa bao giờ bị tắt vậy. Cookie dài hạn (permanent cookie): thay vì hết hạn khi người dùng tắt trình duyệt, permanent cookie hết hạn tại 1 ngày nhất định (Expires) hoặc là sau 1 khoảng thời gian nhất định (Max-Age). Lưu ý rằng các thông tin bí mật và nhạy cảm không nên lưu hoặc vận chuyển với HTTP Cookies bởi vì rõ ràng toàn bộ cơ chế này vốn không an toàn. Và rõ ràng là cookies hoạt động tốt với tất cả các trình duyệt. Cache Interface Cache cung cấp cơ chế lưu trữ cho cặp object Request/Response được lưu đệm. Lưu ý rằng interface Cache được dùng trong phạm vi window giống như workers. Bạn không phải dùng nó cùng với service worker mặc dù nó được định nghĩa trong thông tin của service worker. Một origin có thể có nhiều object Cache (có tên cụ thể). Bạn có trách nhiệm triển khai code (ví dụ như trong ServiceWorker) để xử lý cập nhật cho Cache. Các item trong Cache không được cập nhật trừ khi được yêu cầu tường minh; chúng không hết hạn trừ khi bị xóa. Dùng hàm CacheStorage.open() để mở 1 object Cache với tên cụ thể và gọi bất kỳ phương thức Cache nào để bảo trì Cache. Bạn cũng có trách nhiệm dọn dẹp định kỳ các cache entry. Mỗi trình duyệt có 1 giới hạn cứng với số lượng cache lưu trữ cấp cho 1 origin. Hạn mức sử dụng Cache ước tính tồn tại trong API StorageEstimate. Trình duyệt làm công việc tốt nhất của nó để quản lý dung lượng đĩa nhớ nhưng nó có thể xóa lưu trữ Cache của 1 origin. Đại khái là trình duyệt hoặc sẽ xóa tất cả dữ liệu của 1 origin hoặc không làm gì cả. Đảm bảo đánh phiên bản của cache bằng tên và chỉ dùng phiên bản cache nào mà code của bạn có thể sử dụng an toàn. Bạn có thể xem thêm bài Xóa cache cũ để hiểu thêm. Interface CacheStorage thể hiện sự lưu trữ cho các object Cache Interface: Cung cấp thư mục master của tất cả các cache có tên mà có thể truy xuất bởi ServiceWorker hoặc các loại worker khác hoặc phạm vi window (bạn không bị giới hạn chỉ sử dụng với service worker kể cả thông tin của Service Worker có định nghĩa như vậy). Duy trì khả năng ánh xạ (mapping) tên tương ứng với object Cache Dùng phương thức CacheStorage.open() để lấy 1 instance của Cache Dùng phương thức CacheStorage.match() để kiểm tra nếu 1 Request có phải là 1 key trong bất kỳ object Cache nào mà object CacheStorage theo dõi. Bạn có thể truy cập CacheStorage thông qua thuộc tính toàn cục caches IndexedDB IndexedDB là 1 cách để bạn lưu trữ dữ liệu một cách bền vững bên trong trình duyệt của người dùng. Bởi vì nó cho phép bạn tạo các webapp với khả năng viết câu truy vấn đa dạng bất kể tình trạng mạng. Những ứng dụng này có thể làm việc online &amp; offline. IndexedDB có ích cho các ứng dụng cần lưu trữ 1 lượng lớn dữ liệu (ví dụ: danh sách các DVD cho mượn trong thư viện) và các ứng dụng không cần sự kết nối internet ổn định để hoạt động (ví dụ: ứng dụng mail, danh sách to-do, notepad). Trong bài này, nó là cơ sở dữ liệu lưu trữ mà chúng ta sẽ thảo luận chi tiết hơn 1 chút bởi vì các API lưu trữ khác đều được hiểu biết khá rộng. Thêm nữa, IndexedDB càng ngày càng phổ biến với các webapp phức tạp ngày càng gia tăng. Bên trong IndexedDBIndexedDB cho phép bạn lưu trữ và lấy các object được lưu bằng cách dùng key. Tất cả thay đổi bạn thực hiện với cơ sở dữ liệu đều xảy ra trong phạm vi transaction. Giống như nhiều giải pháp lưu trữ web khác, IndexedDB bám sát nguyên tắc cùng origin (same-origin policy). Vì thế bạn có thể truy cập dữ liệu lưu trữ trong phạm vi 1 domain nhưng không thể truy cập dữ liệu của các domain khác. IndexedDB là API bất đồng bộ (asynchronous) có thể sử dụng trong hầu hết các ngữ cảnh, bao gồm cả WebWorkers. Nó thường bao gồm cả 1 phiên bản đồng bộ (synchronous) nữa để dùng trong web worker nhưng đã bị xóa bỏ bởi vì cộng đồng web không có hứng thú với nó. IndexedDB thường cạnh tranh với cơ sở dữ liệu WebSQL nhưng nó đã bị hủy bởi W3C. Trong khi cả 2 IndexedDB và WebSQL là các giải pháp lưu trữ, chúng lại không cung cấp cùng tính năng. CSDL WebSQL là 1 hệ truy cập CSDL quan hệ trong khi IndexedDB là hệ bảng đánh số (indexed table). Đừng bắt đầu với IndexedDB nếu như bạn chỉ nghe nói hoặc giả định rằng nó tốt hơn các loại CSDL khác. Thay vì thế hãy đọc thật kỹ tài liệu của nó. Dưới đây là 1 vài ý tưởng cần thiết mà bạn cần phải biết: CSDL IndexedDB lưu theo cặp key-value: giá trị có thể là object cấu trúc phức tạp và key có thể là thuộc tính của những object đó. Bạn có thể tạo index dùng bất kỳ thuộc tính nào của object để dễ tìm kiếm cũng như khi cần sắp xếp. Key cũng có thể là object nhị phân. API IndexedDB đa phần là bất đồng bộ: API không đưa dữ liệu cho bạn bằng cách trả về giá trị. Thay vì thế nó truyền vào 1 hàm callback. Bạn không “lưu” 1 giá trị vào trong CSDL hoặc “lấy” nó ra theo nghĩa đồng bộ. Thay vào đó, bạn “yêu cầu” (request) một hành động trên CSDL. Một sự kiện thông báo cho bạn khi hành động hoàn thành và kiểu sự kiện bạn nhận được nếu như có hành động thành công hay thất bại. Không khác mấy so với cách hoạt động của XMLHttpRequest (hoặc là cả tá thứ khác về Javascript) IndexedDB dùng rất nhiều request: request là object nhận các sự kiện thành công hay thất bại như đã nói ở trên. Chúng có thuộc tính onsuccess và onerror cũng như readyState, result và errorCode sẽ cho bạn biết về trạng thái của request. IndexedDB hướng đối tượng: IndexedDB không phải CSDL quan hệ với các bảng thể hiện tập hợp hàng &amp; cột. Điểm khác biệt cơ bản này ảnh hưởng đến giai đoạn thiết kế và xây dựng ứng dụng của bạn. IndexedDB không dùng ngôn ngữ truy vấn cấu trúc (SQL): nó dùng kiểu truy vấn trên index để tạo ra con trỏ, chính con trỏ này dùng để lặp xuyên suốt tập kết quả. Nếu bạn không quen với hệ thống NoSQL thì có thể xem thêm bài này trên Wikipedia IndexedDB dùng nguyên tắc cùng origin: một origin là domain, giao thức tầng ứng dụng và cổng (port) của URL của văn bản là nơi mà code được thực thi. Mỗi origin có 1 tập các CSDL riêng của nó. Mỗi CSDL có 1 cái tên định danh nó trong origin. Giới hạn của IndexedDBIndexedDB được thiết kế để dùng với hầu hết các tình huống cần lưu trữ ở phía client. Nó không được thiết kế cho 1 vài trường hợp dưới đây: Sắp xếp toàn cầu (Internationalized sorting): không phải tất cả ngôn ngữ đều sắp xếp array theo cùng 1 cách, vì thế mà Internationalized sorting không được hỗ trợ. CSDL không thể lưu dữ liệu theo 1 thứ tự toàn cầu cụ thể, bạn có thể tự tay sắp xếp dữ liệu đọc từ CSDL ra. Đồng bộ hóa: API không được thiết kế để thực hiện đồng bộ hóa với CSDL ở phía server. Bạn phải viết code riêng để đồng bộ CSDL IndexedDB ở client với CSDL ở server. Tìm kiếm toàn văn bản (Full text searching ): API không cung cấp giải pháp tương tự như LIKE trong SQL. Thêm vào đó, hãy cẩn thận trình duyệt có thể xóa CSDL trong những trường hợp sau đây: User yêu cầu xóa: nhiều trình duyệt có cài đặt cho phép user xóa tất cả dữ liệu lưu trữ cho 1 website, bao gồm cả cookies, bookmarks, mật khẩu được lưu và dữ liệu IndexedDB. Trình duyệt đang chạy chế độ riêng tư: một vài trình duyệt có chế độ riêng tư như private browsing (Firefox) hay incognito (Chrome). Tại cuối session, trình duyệt sẽ xóa toàn bộ CSDL. Ổ cứng hoặc giới hạn cho phép bị đầy Dữ liệu bị hỏng Các trường hợp chính xác và khả năng của trình duyệt thay đổi theo thời gian, nhưng nguyên lý chung của các nhà phát triển trình duyệt là tạo ra nỗ lực tốt nhất để lưu giữ dữ liệu khi có thể. Lựa chọn API lưu trữNhư đã đề cập ở trên, sẽ tốt hơn nếu chọn các API được hỗ trợ rộng rãi trong nhiều trình duyệt và cung cấp mô hình gọi bất đồng bộ nhằm nâng tối đa khả năng phản hồi của UI. Như 1 cách tự nhiên, ngữ cảnh như thế này sẽ dẫn đến các lựa chọn công nghệ: Với lưu trữ offline, dùng Cache API. API này tồn tại trong các trình duyệt hỗ trợ công nghệ Service Worker, cần thiết để xây dựng app offline. Để lưu trữ trạng thái của ứng dụng và các dữ liệu do người dùng tạo ra, sử dụng IndexedDB. Nó cho phép user làm việc offline trên nhiều trình duyệt hơn so với những trình duyệt chỉ hỗ trợ Cache API. SessionStack sử dụng các API lưu trữ khác nhau. Ví dụ, thư viện tích hợp vào trong webapp của khách hàng dùng cả cookies &amp; session storage. Lý do là thư viện đó cần thu thập các dữ liệu chẳng hạn như các sự kiện, thay đổi trên DOM, dữ liệu mạng, biệt lệ, thông tin debug, vân vân, rồi sau đó gửi về server. Họ thu thập dữ liệu như vậy từ session của người dùng nhưng họ cần 1 cách chính xác để xác định khi nào session của user bắt đầu và kết thúc. Họ cân nhắc 1 session sẽ là toàn bộ chu kỳ sử dụng webapp từ lúc bắt đầu, bao gồm cả xem trang và điều hướng cho đến khi user đóng trình duyệt hay tab và không quay trở lại trong vài phút, phần này họ dùng 1 sự kết hợp của session storage &amp; logic ở phía server. Còn gì nữa nào, họ cho phép bạn xác định từng người dùng cuối để có thể cung cấp cho bạn dữ liệu người dùng trên mỗi session. Họ dựa vào cookies để làm việc này (giống như các công cụ giám sát/phân tích). Trong ứng dụng của họ, bạn có thể xem (xem theo yêu cầu hoặc thời gian thực) những sự kiện đã thu tập dưới dạng video được tái tạo lại cách mà user gặp phải các vấn đều, họ sử dụng chủ yếu là cookies bởi vì serivce RESTful của họ về cơ bản thì cần authentication token để authenticate, authorize và xác nhận request.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P15: Bên trong Class & Inheritance + Transpiling với Babel & Typescript","slug":"Cach-Javascript-hoat-dong-P15-Ben-trong-Class-Inheritance-Transpiling-voi-Babel-Typescript","date":"2018-11-25T09:37:00.000Z","updated":"2018-11-25T09:40:14.437Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P15-Ben-trong-Class-Inheritance-Transpiling-voi-Babel-Typescript.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P15-Ben-trong-Class-Inheritance-Transpiling-voi-Babel-Typescript.html","excerpt":"Chào các bạn đến với bài thứ 15 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Ngày nay, cách phổ biến nhất để dựng cấu trúc của bất kỳ dự án phần mềm nào là sử dụng class. Trong bài viết này, chúng ta sẽ cùng khám phá các cách khác nhau để triển khai class trong Javascript và làm thế nào ta có thể xây dựng cây thứ bậc của class (class hierarchy). Chúng ta sẽ bắt đầu bằng cách đào sâu tìm hiểu cách hoạt động của prototype và phân tích những cách để giả lập kế thừa class trong các thư viện nổi tiếng. Tiếp đến ta sẽ xem làm cách nào mà transpiling có thể thêm những tính năng không được hỗ trợ chính thức cho ngôn ngữ và cách mà nó được dùng trong Babel &amp; Typescript để giới thiệu về sự hỗ trợ của class trong ECMAScript 2015. Cuối cùng, ta sẽ kết thúc với một vài ví dụ về class được triển khai native trong V8.","text":"Chào các bạn đến với bài thứ 15 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Ngày nay, cách phổ biến nhất để dựng cấu trúc của bất kỳ dự án phần mềm nào là sử dụng class. Trong bài viết này, chúng ta sẽ cùng khám phá các cách khác nhau để triển khai class trong Javascript và làm thế nào ta có thể xây dựng cây thứ bậc của class (class hierarchy). Chúng ta sẽ bắt đầu bằng cách đào sâu tìm hiểu cách hoạt động của prototype và phân tích những cách để giả lập kế thừa class trong các thư viện nổi tiếng. Tiếp đến ta sẽ xem làm cách nào mà transpiling có thể thêm những tính năng không được hỗ trợ chính thức cho ngôn ngữ và cách mà nó được dùng trong Babel &amp; Typescript để giới thiệu về sự hỗ trợ của class trong ECMAScript 2015. Cuối cùng, ta sẽ kết thúc với một vài ví dụ về class được triển khai native trong V8. Khái quátTrong Javascript, về bản chất không có kiểu dữ liệu nguyên thủy và mọi thứ tạo ra đều là object. Ví dụ, nếu ta tạo 1 string: 1const name = \"SessionStack\"; Thì chúng ta có thể gọi nhiều phương thức khác nhau trên object vừa mới được tạo ra: 12console.log(a.repeat(2)); // SessionStackSessionStackconsole.log(a.toLowerCase()); // sessionstack Không giống như các ngôn ngữ khác, trong Javascript, khai báo string hay number sẽ tự động tạo ra một object mà nó sẽ đóng gói giá trị đó và cung cấp nhiều phương thức khác nhau có thể thực thi được kể cả với các kiểu dữ liệu nguyên thủy. Một sự thật thú vị khác là những kiểu dữ liệu phức tạp, chẳng hạn như array, cũng là object. Nếu bạn nhìn kỹ hơn vào typeof của một array, bạn sẽ thấy nó là object. Số index của mỗi phần tử trong danh sách chính là thuộc tính của object. Vì thế khi bạn truy xuất một phần tử bằng số index trong array, bạn thực ra chỉ truy xuất vào thuộc tính của object array và trả về giá trị của nó. Khi nói về vấn đề lưu trữ dữ liệu thì 2 định nghĩa sau là giống hệt nhau: 123456let names = [“SessionStack”];let names = &#123; “0”: “SessionStack”, “length”: 1&#125; Kết quả là thời gian cần để truy xuất 1 phần tử trong array và 1 thuộc tính của object là như nhau. Thật khó để nhận ra. Trước đây, trong 1 project, tác giả phải thực hiện quá trình tối ưu hóa rất lớn cho một đoạn code quan trọng. Sau khi thử tất cả các lựa chọn dễ, tác giả đã thay thế toàn bộ object được dùng trong project bằng array. Về lý thuyết, truy xuất 1 phần tử trong 1 array thì nhanh hơn truy xuất 1 key trong hash map (bản đồ băm). Tác giả đã ngạc nhiên rằng cách làm này không mang lại một chút hiệu quả hơn với hiệu năng. Trong Javascript, cả array và object đều được triển khai về việc truy xuất 1 key trong hash map và sẽ tốn cùng 1 lượng thời gian như nhau. Giả lập class với prototypeKhi nghĩ về object, thứ đầu tiên xuất hiện chính là class. Tất cả chúng ta thông thường đều xây dựng cấu trúc của ứng dụng dựa trên class và các mối quan hệ giữa chúng với nhau. Mặc dù object trong Javascript xuất hiện khắp nơi, ngôn ngữ này lại không sử dụng kiểu kế thừa truyền thống dựa trên class. Thay vào đó nó dùng prototype.[ Trong Javascript, mọi object được kết nối đến object khác - chính là prototype của nó. Khi bạn thử truy xuất 1 thuộc tính hoặc phương thức trên 1 object, quá trình tìm kiếm (thuộc tính/phương thức) sẽ bắt đầu với chính object đó trước. Nếu không tìm thấy thì nó sẽ tiếp tục với prototype của object đó. Chúng ta sẽ thử với 1 ví dụ đơn giản về định nghĩa constructor cho 1 class: 1234567function Component(content) &#123; this.content = content;&#125;Component.prototype.render = function() &#123; console.log(this.content);&#125; Ta thêm hàm render vào prototype bởi vì chúng ta muốn mỗi instance của Component đều có thể tìm thấy nó. Khi bạn gọi phương thức này trên mỗi instance của class Component, quá trình tìm kiếm đầu tiên sẽ thực hiện trên chính instance đó. Sau đó nó tiếp tục thực hiện tìm trên prototype và tại đây thì phương thức render được tìm thấy. Giờ ta thử mở rộng class Component ra, ta sẽ thêm vào một class con: 123function InputField(value) &#123; this.content = `&lt;input type=\"text\" value=\"$&#123;value&#125;\" /&gt;`;&#125; Nếu ta muốn InputField mở rộng chức năng của class Component và có thể gọi phương thức render của nó thì ta cần phải thay đổi prototype. Khi 1 phương thức được gọi trên instance của class con, ta không muốn tìm kiếm trong prototype trống rỗng của nó. Quá trình tìm kiếm sẽ tiếp tục ở class Component. 1InputField.prototype = Object.create(new Component()); Bằng cách này, phương thức render có thể được tìm thấy trong prototype của class Component. Để có thể kế thừa, ta cần kết nối prototype của InputField đến 1 instance của class Component. Nhiều thư viện sử dụng phương thức Object.setPrototypeOf để làm việc này. Tuy nhiên đây không phải là việc duy nhất mà ta cần làm. Mỗi khi mở rộng 1 class, ta cần chú ý: Đặt prototype của class con là 1 instance của class cha Gọi constructor của class cha trong constructor của class con để quá trình khởi tạo logic trong constructor của class cha có thể được thực thi. Giới thiệu cách truy xuất phương thức từ class cha. Bạn cần phải làm thế khi muốn ghi đè 1 phương thức và bạn muốn gọi đến phần triển khai gốc trong phương thức ở class cha. Như bạn thấy thì nếu muốn sử dụng tất cả tính năng của kế thừa dựa trên class thì bạn cần thực thi phần logic phức tạp này mỗi lần kế thừa. Mỗi khi bạn cần tạo ra nhiều class thì tốt nhất là đóng gói mớ logic ấy trong 1 (hoặc vài) hàm để có thể tái sử dụng. Đây là cách mà các developer trước đây giải quyết vấn đề kế thừa dựa trên class - bằng cách giả lập với nhiều thư viện khác nhau. Những giải pháp này trở nên rất phổ biến và rõ ràng là có thiếu sót trong ngôn ngữ Javascript. Đó là lý do mà cú pháp mới để tạo class và hỗ trợ kế thừa class được giới thiệu trong bản sửa đổi lớn đầu tiên của ECMAScript 2015. Transpiling classKhi tính năng mới của ES6 (hay ECMAScript 2015) được đề xuất, cộng đồng Javascript developer không ngồi yên chờ đợi tất cả các engine và trình duyệt bắt đầu hỗ trợ nó. Một cách tốt hơn để đạt được là thông qua transpile. Nó cho phép 1 đoạn code viết trong ECMAScript 2015 được biến đổi thành Javascript mà tất cả trình duyệt đều có thể hiểu. Bao gồm cả khả năng viết class với kế thừa dựa trên class và transpile chúng thành code hoạt động được. Một trong số những transpiler nổi tiếng nhất cho Javascript là Babel. Giờ thì cùng xem transpile hoạt động thế nào, ta sẽ áp dụng nó cho đoạn code về Component viết ở trên nhé: 123456789101112class Component &#123; constructor(content) &#123; this.content = content; &#125; render() &#123; console.log(this.content) &#125;&#125;const component = new Component('SessionStack');component.render(); Và đây là những gì Babel transpile ra: 12345678910111213141516var Component = function () &#123; function Component(content) &#123; _classCallCheck(this, Component); this.content = content; &#125; _createClass(Component, [&#123; key: 'render', value: function render() &#123; console.log(this.content); &#125; &#125;]); return Component;&#125;(); Như bạn thấy, code được biến đổi thành ECMAScript 5, loại có thể được thực thi trên bất kỳ môi trường nào. Ngoài ra còn có 1 số hàm được thêm vào. Chúng là 1 phần của thư viện Babel tiêu chuẩn. Hàm _classCallCheck và _createClass có mặt như 1 phần trong kết quả biên dịch. Hàm đầu tiên đảm bảo hàm constructor không bao giờ được gọi như 1 hàm bình thường. Điều này được thực hiện bằng việc kiểm tra có hay không ngữ cảnh mà trong đó hàm được đánh giá là 1 instance của object Component. Code sẽ kiểm tra nếunó trỏ đến instance. Hàm thứ 2 _createClass xử lý việc tạo ra các thuộc tính cho object và được truyền vào dưới dạng danh sách các object với key &amp; value. Để khám phá về cách kế thừa hoạt động ra sao thì ta cùng phân tích class InputField được kế thừa từ Component 123456class InputField extends Component &#123; constructor(value) &#123; const content = `&lt;input type=\"text\" value=\"$&#123;value&#125;\" /&gt;`; super(content); &#125;&#125; Kết quả sau khi xử lý transpile với Babel: 123456789101112var InputField = function (_Component) &#123; _inherits(InputField, _Component); function InputField(value) &#123; _classCallCheck(this, InputField); var content = '&lt;input type=\"text\" value=\"' + value + '\" /&gt;'; return _possibleConstructorReturn(this, (InputField.__proto__ || Object.getPrototypeOf(InputField)).call(this, content)); &#125; return InputField;&#125;(Component); Trong ví dụ trên, logic kế thừa được đóng gói trong hàm _inherits. Nó thực hiện cùng y chang hành động mà chúng ta đã mô tả trong phần trước bằng cách cài đặt prototype của class con trở thành 1 instance của class cha. Để transpile code, Babel thực hiện nhiều quá trình chuyển đổi. Đầu tiên code ECMAScript 2015 được parse và biến đổi thành một dạng thể hiện trung gian, gọi là Abstract Syntax Tree, chính là chủ đề ta đã thảo luận ở bài trước. Sau đó cây này được biến đổi lần nữa thành 1 cây AST khác mà mỗi node của nó được biến đổi thành phần tương ứng trong ECMAScript 5. Cuối cùng cây AST được chuyển ngược lại thành code. AST trong BabelMột cây AST sẽ có nhiều node, mỗi node chỉ có duy nhất 1 node cha. Trong Babel, tồn tại 1 kiểu cơ bản cho các node. Nó chưa thông tin về loại node và vị trí của chúng trong code. Có nhiều loại node khác nhau, chẳng hạn như Literals thể hiện string, number, null, vân vân. Cũng có cả node Statements dành cho các luồng kiểm soát (if) và vòng lặp (for, while). Có cả node đặc biệt dành cho class. Nó là 1 con (child) của class Node cơ bản. Nó mở rộng bằng cách thêm các trường để lưu tham chiếu đến class cơ bản và body của class như là 1 node riêng biệt. Giờ ta sẽ biến đổi đoạn code sau thành cây AST 123456789class Component &#123; constructor(content) &#123; this.content = content; &#125; render() &#123; console.log(this.content) &#125;&#125; Đây là kết quả: Sau khi tạo ra cây AST, mỗi node được biến đổi thành node ECMAScript 5 tương đương với nó và chuyển ngược lại thành code thường theo tiêu chuẩn của ECMAScript 5. Quá trình này được thực hiện bằng 1 tiến trình tìm kiếm node nằm ở vị trí xa nhất với root node và biến đổi chúng thành code. Sau đó node cha của nó sẽ được biến đổi bằng đoạn code đã sinh ra cho các node con của nó. Quá trình này được gọi là depth-first traversal Trong ví dụ trên, đầu tiên code của 2 node MethodDefinition sẽ được sinh ra, theo sau nó là code của node ClassBody và cuối cùng là node ClassDeclaration Transpile với TypeScriptMột framework phổ biến khác hỗ trợ khả năng transpile chính là TypeScript. Nó giới thiệu cú pháp kiểu mới để viết ứng dụng Javascript và được biến đổi thành ECMAScript 5 mà có thể chạy trên bất kỳ trình duyệt hay engine nào. Dưới đây là phần triển khai của class Component trong TypeScript: 123456789class Component &#123; content: string; constructor(content: string) &#123; this.content = content; &#125; render() &#123; console.log(this.content) &#125;&#125; Và đây là cây AST được sinh ra: Nó hỗ trợ kế thừa: 123456class InputField extends Component &#123; constructor(value: string) &#123; const content = `&lt;input type=\"text\" value=\"$&#123;value&#125;\" /&gt;`; super(content); &#125;&#125; Kết quả transpile ra: 12345678910var InputField = /** @class */ (function (_super) &#123; __extends(InputField, _super); function InputField(value) &#123; var _this = this; var content = \"&lt;input type=\\\"text\\\" value=\\\"\" + value + \"\\\" /&gt;\"; _this = _super.call(this, content) || this; return _this; &#125; return InputField;&#125;(Component)); Kết quả cuối cùng một lần nữa lại là ECMAScript 5 với 1 số hàm thêm vào từ thư viện của TypeScript. Logic được đóng gói trong __extends là giống y hệt như những gì chúng ta đã thảo luận ở phần trước. Với Babel và TypeScript càng ngày càng được đón nhận nồng nhiệt, class tiêu chuẩn và kế thừa dựa trên class trở thành 1 cách chuẩn của phần cấu trúc những ứng dụng Javascript. Điều này đẩy nhanh tiến độ về native support (hỗ trợ tự nhiên) cho class trên trình duyệt. Native support (hỗ trợ tự nhiên)Vào năm 2014, native support cho class được giới thiệu trong Chrome. Nó cho phép cú pháp khai báo class được thực hiện mà không cần phải dùng đến các thư viện hay transpiler. Quá trình triển khai class một cách tự nhiên được gọi là syntax sugar (cú pháp ngọt ngào). Đây chỉ là 1 cú pháp dễ chịu có thể biên dịch xuống thành cùng loại với kiểu nguyên thủy đang được hỗ trợ mặc định trong ngôn ngữ. Bạn có thể dùng kiểu định nghĩa class mới, dễ dùng hơn, nhưng cuối cùng nó cũng quay về tạo constructor và gán prototypes Sự hỗ trợ của V8Cùng xem cách hoạt động của native support cho class trong ECMAScript 2015 trên V8. Như ta đã thảo luận ở bài trước, đầu tiên cú pháp mới cần được parse thành code Javascript cũ và thêm vào cây AST. Vì thế kết quả của định nghĩa class là 1 node mới (loại ClassLiteral) được thêm vào cây. Node này chứa 1 vài thứ. Đầu tiên, nó giữ constructor ở 1 hàm khác. Nó cũng chứa 1 danh sách các thuộc tính của class. Chúng có thể là phương thức, getter, setter, các trường public hay private. Node này cũng chứa luôn tham chiếu đến class cha mà chính class cha này lại nữa chứa constructor &amp; danh sách các thuộc tính và class cha khác (của nó). Một khi ClassLiteral này được chuyển thành code, nó được dịch 1 lần nữa thành các hàm và prototypes. Với team tại SessionStack, tối ưu hóa từng phần nhỏ của code là cực kỳ quan trọng những cũng là 1 công việc rất thách thức. Có 2 lý do cho việc cần thiết phải tối ưu hóa mức độ cao. Đầu tiên, thư viện của họ sẽ tích hợp với trong webapp, nó thu thập dữ liệu từ phiên làm việc của user, chẳng hạn như sự kiện, thay đổi trên DOM, dữ liệu mạng, biệt lệ, thông báo lỗi, vân vân. Thu thập thông tin mà không làm ảnh hưởng đến hiệu năng của webapp là 1 thách thức khó mà team của tác giả đã giải quyết thành công.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P14: Parsing, Abstract Syntax Tree & mẹo giảm tối đa thời gian parse","slug":"Cach-Javascript-hoat-dong-P14-Parsing-Abstract-Syntax-Tree-meo-giam-toi-da-thoi-gian-parse","date":"2018-11-25T09:32:00.000Z","updated":"2018-11-25T09:35:26.778Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P14-Parsing-Abstract-Syntax-Tree-meo-giam-toi-da-thoi-gian-parse.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P14-Parsing-Abstract-Syntax-Tree-meo-giam-toi-da-thoi-gian-parse.html","excerpt":"Chào các bạn đến với bài thứ 14 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Khái quátChúng ta đều biết rằng những thứ lộn xộn có thể hợp thành 1 thứ lớn hơn gọi là Javascript. Một đoạn code không chỉ có thể di chuyển qua mạng mà nó còn phải được parse, biên dịch sang bytecode và cuối cùng thực thi. Trong các bài trước, chúng ta đã thảo luận về những thứ chẳng hạn như JS engine, runtime, callstack cũng như engine V8 được dùng chủ yếu trong Chrome và NodeJS. Tất cả đều đóng vai trò quan trọng trong toàn bộ quá trình thực thi của Javascript. Chủ đề mà chúng ta sẽ tìm hiểu hôm nay cũng không kém quan trọng: chúng ta sẽ nghiên cứu xem làm thế nào mà đa số các engine JS parse văn bản thành một thứ gì đó có nghĩa đối với máy móc, những gì xảy ra sau đó và làm thế nào để web developer như chúng ta có thể tận dụng những kiến thức đó làm điểm mạnh.","text":"Chào các bạn đến với bài thứ 14 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Khái quátChúng ta đều biết rằng những thứ lộn xộn có thể hợp thành 1 thứ lớn hơn gọi là Javascript. Một đoạn code không chỉ có thể di chuyển qua mạng mà nó còn phải được parse, biên dịch sang bytecode và cuối cùng thực thi. Trong các bài trước, chúng ta đã thảo luận về những thứ chẳng hạn như JS engine, runtime, callstack cũng như engine V8 được dùng chủ yếu trong Chrome và NodeJS. Tất cả đều đóng vai trò quan trọng trong toàn bộ quá trình thực thi của Javascript. Chủ đề mà chúng ta sẽ tìm hiểu hôm nay cũng không kém quan trọng: chúng ta sẽ nghiên cứu xem làm thế nào mà đa số các engine JS parse văn bản thành một thứ gì đó có nghĩa đối với máy móc, những gì xảy ra sau đó và làm thế nào để web developer như chúng ta có thể tận dụng những kiến thức đó làm điểm mạnh. Ngôn ngữ lập trình hoạt động như thế nào?Cùng lùi lại 1 chút và xem xem ngôn ngữ lập trình hoạt động thế nào. Không cần biết là bạn đang xài ngôn ngữ gì, bạn sẽ luôn cần một phần mềm có thể đọc mã nguồn và khiến cho máy tính thực hiện một điều gì đó. Phần mềm này có thể là trình thông dịch hoặc trình biên dịch. Không cần biết bạn đang xài ngôn ngữ thông dịch (Javascript, Python, Ruby) hay ngôn ngữ biên dịch (C#, Java, Rust), luôn luôn có 1 điểm chung giữa chúng: parse đoạn mã nguồn từ văn bản gốc thành một cấu trúc dữ liệu được gọi là Abstract Syntax Tree (AST). Các AST không chỉ thể hiện mã nguồn dưới dạng cấu trúc mà chúng còn đóng vai trò quan trọng trong phân tích ngữ nghĩa, chính là nơi mà trình biên dịch xác nhận tính đúng đắn và cách sử dụng phù hợp của chương trình cũng như các phần tử của ngôn ngữ. Về sau, các AST được dùng để sinh ra bytecode hoặc mã máy. Các ứng dụng ASTAST không chỉ được dùng trong trình thông dịch và trình biên dịch ngôn ngữ, chúng còn có nhiều ứng dụng trong thế giới máy tính. Một trong số đó là dùng chúng là phân tích code tĩnh. Các nhà phân tích tĩnh không thực thi code, họ cần hiểu cấu trúc của code. Ví dụ: bạn muốn triển khai một công cụ tìm sự giống nhau giữa các kiến trúc code để từ đó bạn có thể refactor nhằm giảm sự trùng lặp. Bạn có thể làm việc này bằng cách so sánh string bình thường nhưng cách triển khai thì khá cơ bản và giới hạn. Một cách tự nhiên, nếu bạn có hứng thú triển khai một công cụ thì bạn không cần phải viết riêng cho nó 1 cái parser. Có rất nhiều triển khai mã nguồn mở có sẵn có khả năng tương thích toàn diện với thông số kỹ thuật của Ecmascript. Ví dụ: Esprima và Acorn. Cũng có rất nhiều công cụ có thể giúp ta với sản phẩm nhận được từ parser, hay còn gọi là AST. Các AST cũng được dùng nhiều trong phần triển khai của các code transpiler. Ví dụ: bạn cần triển khai một bộ transpiler để chuyển code Python thành Javascript. Ý tưởng cơ bản là ta cần một Python transpiler để sinh ra cây AST - thứ mà ta cần để có thể sinh ra code Javascript sau này. Bạn có thể tự hỏi, làm sao như vậy được? Điểm mấu chốt là các AST chỉ là một điểm khác biệt về cách thể hiện một vài ngôn ngữ. Trước khi parse, nó thể hiện dưới dạng văn bản đi kèm theo một số quy luật nhất định để hình thành nên 1 ngôn ngữ. Sau khi parse, nó thể hiện dưới dạng một kiến trúc dạng cây chứa chính xác cùng 1 thông tin với văn bản đầu vào. Vì thế, bạn có thể luôn luôn có thể làm ngược lại và go back về dạng biểu diễn văn bản. Javascript parsingGiờ thì cùng tìm hiểu cây AST được xây dựng như thế nào. Đầu tiên ta có một hàm Javascript đơn giản như sau: 12345678function foo(x) &#123; if (x &gt; 10) &#123; var a = 2; return a * x; &#125; return x + 10;&#125; Parser sẽ sản sinh ra cây AST như sau: Lưu ý rằng vì mục đích dễ nhìn và đẹp thì hình trên chỉ là phiên bản tối giản của sản phẩm thực sự từ parser. Cây AST thật sẽ phức tạp hơn rất nhiều. Tuy nhiên, mục đích của chúng ta là có được ý tưởng cơ bản về việc mã nguồn sẽ biến thành cái gì trước khi nó được thực thi. Nếu bạn muốn xem cây AST thứ thiệt trông như thế nào thì bạn có thể vào đây. Đó là 1 công cụ online, bạn chỉ cần nhập code Javascript vào và nó sẽ sinh ra cây AST cho đoạn code đó. Bạn sẽ tự hỏi tại sao chúng ta cần biết về cách hoạt động của Javascript parser. Sau tất cả thì nó thuộc về trách nhiệm của trình duyệt. Và về mặt nào đó thì đúng là như thế. Tuy nhiên, bạn có thể xem hình bên dưới, đó là đồ thị biểu diễn tổng thời gian phân phối cho từng bước trong quá trình thực thi code Javascript. Hãy nhìn kỹ hơn và thử xem có thấy được gì thú vị không. Bạn có thấy được không? Nhìn kỹ xem. Trung bình thì trình duyệt chiếm khoảng 15-20% tổng thời gian thực thi để parse Javascript. Những con số này không phải là bịa đặt. Chúng là số liệu thống kê từ những ứng dụng và website có thật đang bằng cách này hay cách khác sử dụng Javascript. Giờ thì 15% có vẻ như không nhiều lắm, nhưng tin tôi đi, nó có giá trị đấy. Một app SPA tiêu chuẩn sẽ load khoảng 0.4MB code Javascript và trình duyệt tiêu tốn xấp xỉ 370ms để parse nó. Thêm một lần nữa, bạn sẽ nói rằng nó chẳng đáng bao nhiêu thời gian cả. Và rõ ràng con số đó quá nhỏ. Tuy nhiên nhớ kỹ rằng đây chỉ là thời gian cần để parse code Javascript thành cây AST. Chưa bao gồm thời gian thực thi chính nó hay bất kỳ tiến trình nào diễn ra trong khi load trang (ví dụ như CSS &amp; HTML rendering). Và tất cả thông số này mới chỉ thể hiện cho desktop. Khi chúng ta đi sâu hơn trên mobile, mọi thứ sẽ trở nên phức tạp hơn nhiều. Thời gian dành cho việc parse trên mobile thường có thể nhiều hơn 2-5 lần so với trên desktop. Đồ thị trên thể hiện thời gian parse của 1 gói code Javascript 1MB trên rất nhiều thiết bị mobile &amp; desktop thuộc nhiều phân khúc khác nhau. Gì nữa nào? Web app đang càng trở nên phức tạp theo từng phút cũng như càng có nhiều business logic phải xử lý ở phía client để có thể mang lại trải nghiệm giống hệt như native app. Bạn có thể dễ dàng hiểu được những điều đó ảnh hưởng như thế nào đến website/wepapp của bạn. Tất cả những gì bạn cần là mở dev tool của trình duyệt lên và để nó đo đạc lượng thời gian dành cho parsing, biên dịch và mọi thứ diễn ra trên trình duyệt cho tới khi trang web được load hoàn toàn. Thật không may, không có dev tool nào cho các trình duyệt mobile. Nhưng đừng lo lắng, điều này không có nghĩa rằng bạn không thể làm gì được. Đây là lý do những công cụ như DeviceTiming tồn tại. Nó có thể giúp bạn đo đạc thời gian parse và thực thi cho các đoạn code trong một môi trường kiểm soát. Nó hoạt động bằng cách gói gọn code local với đoạn code đo lường, vì thế nên mỗi lần trang web của bạn được truy cập từ các thiết bị khác nhau, bạn có thể đo đạc thời gian parse và thực thi. Điều tốt là engine Javascript đã làm rất nhiều thứ nhằm tránh cách công việc thừa thãi và tối hưu hóa nhiều hơn. Dưới đây là 1 vài thứ mà các engine của những trình duyệt lớn đã làm. Ví dụ với V8, nó thực hiện script streaming &amp; code caching. Script streaming nghĩa là các đoạn code bất đồng bộ &amp; bị trì hoãn sẽ được parse trong 1 tiến trình riêng ngay khi quá trình download bắt đầu. Nó giúp cho quá trình parsing gần như hoàn thành ngay lập tức sau khi đoạn code (script) được tải xong. Kết quả là các trang sẽ load nhanh hơn khoảng 10%. Code Javascript thường được biên dịch thành bytecode mỗi khi có một lượt truy cập trang. Tuy nhiên, cục bytecode này lại bị bỏ đi khi người dùng truy cập đến trang khác. Điều này xảy ra vì code được biên dịch phụ thuộc rất nhiều vào trạng thái và ngữ cảnh của máy tại thời điểm biên dịch. Đây là lý do Chrome 42 giới thiệu bytecode caching (bộ đệm bytecode). Đây là một kỹ thuật lưu trữ code đã biên dịch ở local để khi user quay trở lại trang cũ trước đó thì tất cả mọi hoạt động như download, parse, biên dịch… có thể bỏ qua. Nó cho phép Chrome tiết kiệm 40% thời gian parse &amp; thực thi. Thêm nữa, kết quả nó tiết kiệm pin nhiều hơn nếu chạy trên các thiết bị mobile. Trong Opera, engine Carakan có thể dùng lại kết quả biên dịch từ chương trình khác vừa mới được biên dịch gần đây. Không có các yêu cầu cụ thể nào về việc code phải đến từ cùng 1 trang hay domain. Kỹ thuật caching này thực sự rất hữu ích và có thể hoàn toàn bỏ qua bước biên dịch. Nó phụ thuộc vào hành vi tiêu chuẩn của user và ngữ cảnh lươt web: mỗi khi user thực hiện cùng chuỗi hành trình với một user khách trên app/website thì cùng 1 đoạn code Javascript sẽ được tải. Tuy nhiên, Opera đã sớm thay thế Carakan bằng Google V8. Bộ engine SpiderMonkey của Firefox không lưu cache bất kỳ thứ gì. Nó đại khái là chuyển qua dùng một thao tác giám sát để đếm xem 1 đoạn code Javascript được thực thi bao nhiêu lần. Dựa trên số đếm này nó xác định phần nào của code đang hot và cần được tối ưu hóa. Rõ ràng có một số người lựa chọn không làm gì cả. Maciej Stachowiak, lead developer của Safari, chỉ định rằng Safari không thực hiện bất kỳ hoạt động cache nào cho bytecode đã biên dịch. Có vẻ như họ đã có cân nhắc về việc này nhưng không triển khai nó bởi vì nó chỉ nhỏ hơn 2% tổng thời gian thực thi. Những hoạt động tối ưu hóa không trực tiếp ảnh hưởng đến chuyện parsing của code Javascript nhưng chúng chắc chắn đang làm tốt nhất có thể để bỏ qua nó một cách hoàn toàn. Còn cách tối ưu hóa nào tốt hơn là tối ưu hóa hoàn toàn? Có nhiều thứ chúng ta có thể làm để cải thiện thời gian load app ban đầu. Ta có thể làm tối giản lượng code Javascript đang sử dụng: ít code, ít parse, ít thực hi. Để làm được điều này, ta cần đưa ra vừa đúng lượng code cần thiết cho một tính năng cụ thể thay vì load 1 cục thiệt to lớn và dùng nó vào mọi thứ. Ví dụ, pattern PRPL có thuyết giảng về mô hình chuyển giao code như vậy. Nói cách khác, ta có thể kiểm tra các dependency và xem nếu như có gì đó thừa thãi không cần thiết làm chậm code của chúng ta. Về phần này thì hi vọng là sẽ có 1 topic riêng để nói về nó. Mục đích của bài viết này là để thảo luận chúng ta - những web developer - có thể làm được gì để giúp cho Javascript parser có thể chạy nhanh hơn. Và chính là đây, các Javascript parser hiện đại sử dụng các phỏng đoán để xác định nếu một đoạn code cụ thể nào đó chuẩn bị được thực thi ngay hoặc quá trình thực thi sẽ bị tạm ngưng và dời lại trong một thời điểm khác. Dựa trên các phỏng đoán, parser sẽ làm hoặc là eager parsing (parse nhanh) hoặc là lazy parsing (parse từ từ). Eager parsing chạy xuyên suốt các hàm nào cần được biên dịch tức thời. Nó thực hiện 3 việc chính: xây dựng cây AST, xây dựng hệ thống cấp bậc (hierarchy) cho scope và tìm tất cả các lỗi cú pháp. Lazy parsing thì ngược lại, nó chỉ được dùng cho các hàm chưa cần được biên dịch. Nó không xây dựng cây AST và cũng không tìm lỗi cú pháp. Nó chỉ xây dựng hệ thống cấp bậc cho scope và tiết kiệm được một nửa thời gian so với eager. Rõ ràng đây không phải là ý tưởng mới. Kể cả trình duyệt như IE9 cũng hỗ trợ tối ưu hóa mặc dù nó chạy hơi thô sơ nếu như so với cách mà parser ngày nay hoạt động. Giờ thì cùng xem một ví dụ về cách nó hoạt động. Giả sử ta có đoạn code sau: 1234567891011function foo() &#123; function bar(x) &#123; return x + 10; &#125; function baz(x, y) &#123; return x + y; &#125; console.log(baz(100, 200));&#125; Giống như ví dụ trước, code được đưa vào parser để phân tích cú pháp và trả ra cây AST. Vậy thì đây là những gì thực hiện theo từng dòng: Định nghĩa hàm bar nhận 1 biến x và nó có 1 câu lệnh return trả về kết quả của phép tính cộng giữa x và 10. Định nghĩa hàm baz nhận 2 biến (x và y). Nó có 1 câu lệnh return. Hàm này trả về kết quả của phép tính cộng giữa x và y. Gọi hàm baz với 2 đối số là 100 và 200. Tạo ra 1 lời gọi hàm đến console.log với giá trị là kết quả của lời gọi hàm trước đó. Điều gì vừa xảy ra vậy? Parser thấy có một định nghĩa hàm foo, định nghĩa bar và 1 hàm baz, một lời gọi đến hàm baz, một lời gọi đến hàm console.log. Chờ đã… có một số thứ parser đã làm hoàn toàn không liên quan. Đó là việc parse hàm bar. Tại sao lại không liên quan? Bởi vì hàm bar chưa bao giờ được gọi (ít nhất là cho tới thời điểm này). Đây chỉ là một ví dụ đơn giản và có vẻ như không bình thường nhưng nó xuất hiện trên rất nhiều app thực, có rất nhiều hàm được định nghĩa nhưng không bao giờ dùng đến. Thay vì parse hàm bar, chúng ta có thể đánh dấu nó đã được khai báo nhưng không chỉ ra cụ thể nó làm gì. Parsing sẽ diễn ra khi cần thiết ngay trước khi hàm được thực thi. Và dĩ nhiên là lazy parsing cũng vẫn cần thiết để tìm toàn bộ body của hàm và tạo một khai báo cho hàm đó. Nó không cần cây cú pháp bởi vì nó vẫn chưa được xử lý. Thêm nữa, bộ nhớ heap vẫn chưa được cấp phát (phần này cũng chiếm 1 lượng tương đối trong tài nguyên hệ thống). Nói ngắn gọn thì bỏ qua một số bước trên sẽ cải thiện đáng kể hiệu năng. Vậy nên nhìn lại ví dụ trên, ta có cây AST mới sẽ như thế này: Lưu ý rằng hàm bar được khai báo và chấp nhận, nhưng chỉ có thế thôi. Chúng ta không làm gì với body của hàm. Trong trường hợp này, body của hàm chỉ có 1 câu lệnh return. Tuy nhiên, trong hầu hết các ứng dụng thực tế, nó có thể lớn hơn rất nhiều, bao gồm nhiều câu lệnh return, điền kiện, vòng lặp, định nghĩa các biến và kể cả các khai báo hàm lồng nhau. Tất cả những thứ này sẽ gây tốn thời gian cũng như tài nguyên hệ thống bởi vì hàm không bao giờ được gọi. Đây là một ý tưởng cực kỳ đơn giản nhưng trong thực tế công việc thì việc triển khai nó lại không đơn giản. Dưới đây là một ví dụ mà chắc chắn không phải là trường hợp duy nhất. Toàn bộ phương thức sử dụng các hàm, vòng lặp, điều kiện, object, vân vân. Cơ bản là toàn bộ code cần được parse. Ví dụ một mô hình phổ biến để triển khai Javascript module: 1234var myModule = (function() &#123; // toàn bộ logic của module // return về module.&#125;)(); Mô hình này dễ dàng nhận ra bởi các Javascript parser hiện đại và là một dấu hiệu cho thấy code bên trong có thể dùng eager parsing. Vậy tại sao parser không mặc định lazy parsing? Nếu có gì đó được parse lazy thì nó phải được thực thi ngay lập tức và điều này thực sự gây ra sự chậm chạp. Một lazy parse được thực hiện và ngay sau đó là eager parse. Kết quả là tốc độ chậm hơn 50% khi so sánh với chỉ dùng 1 eager parse. Đến lúc này ta đã có kiến thức cơ bản về phía hậu trường, giờ thì thử xem chúng ta có giúp gì cho parser được không. Ta có thể viết code theo cách mà các hàm có thể được parse tại thời điểm phù hợp. Có một pattern được xài chung giữa các parser: đóng gói hàm bên trong dấu ngoặc (). Đây luôn là một dấu hiệu tích cực cho parser hiểu rằng hàm sẽ được thực thi ngay lập tức. Nếu parser bắt gặp một dấu mở ngoặc ( và ngay liền sau đó là một định nghĩa hàm, nó sẽ parse eager hàm đó. Chúng ta có thể giúp parser bằng cách khai báo hàm một cách tường minh như vậy hàm sẽ được thực thi ngay lập tức. Giả sử ta có hàm Javascript như sau: 123function foo(x) &#123; return x * 10;&#125; Bởi vì không có dấu hiệu rõ ràng rằng hàm sẽ được thực thi ngay lập tức nên trình duyệt sẽ thực hiện lazy parse. Tuy nhiên, chúng ta biết rằng như vậy là không đúng nên ta có thể làm 2 việc. Đầu tiên, ta lưu hàm vào trong 1 biến: 123var foo = function foo(x) &#123; return x * 10;&#125;; Lưu ý rằng ta vẫn giữ lại tên hàm foo giữa từ khóa function và dấu mở ngoặc (. Điều này tuy không cần thiết nhưng bạn bên làm vì trong trường hợp xử lý biệt lệ, stacktrace sẽ hiện ra tên cụ thể của hàm thay vì một chữ khô khan. Parser vẫn thực hiện lazy parse. Ta có thể ngăn chặn điều này bằng cách thêm một chi tiết nhỏ: gói hàm đó lại trong dấu ngoặc. 123var foo = (function foo(x) &#123; return x * 10;&#125;); Tại thời điểm này, khi parser thấy dấu mở ngoặc ( ngay trước từ khóa function nó sẽ ngay lập tức thực hiện eager parsing. Sẽ hơi khó để quản lý bởi vì chúng ta sẽ cần phải biết trong trường hợp nào thì parser chọn parse lazy hay eager. Thêm nữa ta cần phải suy nghĩ và tìm hiểu một hàm cụ thể nào đó có được gọi ngay lập tức hay không. Chúng ta chắc chắn không muốn làm vậy. Ít nhất thì nó sẽ làm cho code khó đọc &amp; khó hiểu hơn. Công cụ như Optimize.js có thể giúp ta rất nhiều. Mục đích duy nhất của nó là tối ưu hóa thời gian loaing ban đầu của code Javascript. Chúng thực hiện phân tích code tĩnh và chỉnh sửa lại để đóng gói những hàm nào cần được thực thi bên trong dấu ngoặc (), trình duyệt sẽ có thể parse eager và chuẩn bị chúng sẵn sàng để thực thi. Chúng ta có thể tiếp tục code bình thường và có đc đoạn code sau: 123(function() &#123; console.log('Hello, World!');&#125;)(); Mọi thứ có vẻ tốt, hoạt động đúng như mong đợi và nhanh nữa. Bởi vì có dấu mở ngoặc ( trước khi khai báo hàm. Rất tuyệt. Dĩ nhiên rồi, trước khi đưa lên production ta cần minify để tiết kiệm dung lượng. Đoạn code sau là sản phẩm cuối cùng: 1!function()&#123;console.log('Hello, World!')&#125;(); Một lần nữa, chúng có vẻ tốt phải không? Code hoạt động y như cũ. Nhưng có gì đó thiếu thiếu. Trình minify đã gỡ dấu ngoặc đóng gói bên ngoài hàm và thay vào đó thêm 1 dấu chấm than ! ngay trước hàm. Điều này nghĩa là parser sẽ bỏ qua nó và thực hiện lazy parse. Trên hết thì để có thể thực thi hàm nó sẽ thực hiện eager parse ngay sau khi lazy parse. Vậy thì lại làm code chạy chậm hơn. May mắn thay, chúng ta có những công cụ như Optimize.js giúp ta trong những trường hợp này. Truyền đoạn code đã minify vào Optimize.js và đây là kết quả đầu ra: 1!(function()&#123;console.log('Hello, World!')&#125;)(); Giờ thì ta đã có thành phẩm tốt nhất: code được minify và parser dễ dàng xác định được những hàm nào cần parse eager hàm nào cần parse lazy. Biên dịch trước (Pre-compilation)Vậy tại sao ta không thực hiện toàn bộ các bước này ở phía server. Dĩ nhiên thì sẽ tốt hơn nếu chúng ta thực hiện 1 lần rồi triển khai kết quả cho tất cả client, thay vì bắt mỗi client phải thực hiện nó mỗi lần chạy. Thật ra thì có những thảo luận về việc engine nên cung cấp một cách để thực thi những đoạn code đã được biên dịch trước để đỡ tốn thời gian cho trình duyệt. Về bản chất thì ý tưởng chính là có một công cụ ở phía server có thể sinh ra bytecode rồi truyền trực tiếp về phía client và thực thi. Nếu thực sự được như vậy thì thời gian khởi động app phía client sẽ được cải thiện đáng kể. Nghe rất hấp dẫn, nhưng mọi việc không đơn giản như vậy. Điều này có thể gây ra hiệu ứng ngược lại, hiệu ứng lớn là đằng khác, vì hầu hết code có thể sẽ cần phải được ký &amp; xử lý vì những lý do bảo mật. Đội ngũ V8 đang làm việc nội bộ với nhau để tránh re-parsing để quá trình biên dịch trước sẽ có lợi ích như thế. Một vài mẹo vặt bạn có thể thực hiện để app chạy nhanh hơn Kiểm tra các dependency. Loại bỏ những thứ không cần thiết. Chia nhỏ code thành nhiều phần nhỏ hơn thay vì load nguyên 1 cục bự. Trì hoãn quá trình load Javascript nếu có thể. Bạn chỉ cần load phần code nào cần thiết dựa trên route hiện tại mà thôi. Dùng dev tool &amp; DeviceTiming để tìm hiểu phần nào đang bị thắt cổ chai. Dùng công cụ như Optimize.js để giúp parser quyết định khi nào nên parse eager &amp; lazy. SessionStack là công cụ hỗ trợ tái tạo lại mọi thứ xảy ra đối với người dùng cuối tại thời điểm họ gặp phải vấn đề khi đang tương tác với webapp. Công cụ này không dựng lại phiên làm việc đó thành 1 video thật mà chỉ giả lập tất cả các sự kiện trong một môi trường sandbox trên trình duyệt. Điều này có ý nghĩa nhất định, ví dụ trong trường hợp codebase của page hiện tại lớn và phức tạp. Những kỹ thuật trên là những thứ mà team tác giả gần đây kết hợp trong quá trình phát triển SessionStack. Những tối ưu hóa đó cho phép họ load SessionStack nhanh hơn. SessionStack chạy càng nhanh nó càng có thể giải phóng tài nguyên của trình duyệt nhanh hơn và mang lại trải nghiệm một cách liên tục &amp; tự nhiên cho người dùng khi họ load &amp; xem lại các session làm việc.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P13: Bên trong CSS & JS animation & các giải pháp tối ưu hiệu năng của nó","slug":"Cach-Javascript-hoat-dong-P13-Ben-trong-CSS-JS-animation-cac-giai-phap-toi-uu-hieu-nang-cua-no","date":"2018-11-25T09:11:00.000Z","updated":"2018-11-25T09:14:13.336Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P13-Ben-trong-CSS-JS-animation-cac-giai-phap-toi-uu-hieu-nang-cua-no.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P13-Ben-trong-CSS-JS-animation-cac-giai-phap-toi-uu-hieu-nang-cua-no.html","excerpt":"Chào các bạn đến với bài thứ 13 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Khái quátMọi người đã biết rõ animation đóng vai trò cần thiết trong việc tạo ra các webapp hấp dẫn. Khi người dùng dần dần chuyển sự chú ý của họ sang UX và các doanh nghiệp bắt đầu nhận ra sự quan trọng của trải nghiệm người dùng thú vị &amp; hoàn hảo thì các ứng dụng web dần trở nên nặng nề hơn &amp; cần thể hiện nhiều UI động hơn. Tất cả những thứ này cần đến các animation phức tạp để tạo ra các chuyển dịch trạng thái mượt mà xuyên suốt hành trình trải nghiệm của người dùng. Giờ đây thì điều đó không còn là thứ gì đặc biệt nữa. User càng lúc càng giỏi và họ mong đợi ở những giao diện người dùng có tính tương tác và phản hồi cao. Tuy nhiên animating giao diện không nhất thiết phải đơn giản, minh bạch. Thứ gì cần được animated, khi nào và cảm giác mà một animation mang lại, đó mới là những câu hỏi khó trả lời.","text":"Chào các bạn đến với bài thứ 13 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Khái quátMọi người đã biết rõ animation đóng vai trò cần thiết trong việc tạo ra các webapp hấp dẫn. Khi người dùng dần dần chuyển sự chú ý của họ sang UX và các doanh nghiệp bắt đầu nhận ra sự quan trọng của trải nghiệm người dùng thú vị &amp; hoàn hảo thì các ứng dụng web dần trở nên nặng nề hơn &amp; cần thể hiện nhiều UI động hơn. Tất cả những thứ này cần đến các animation phức tạp để tạo ra các chuyển dịch trạng thái mượt mà xuyên suốt hành trình trải nghiệm của người dùng. Giờ đây thì điều đó không còn là thứ gì đặc biệt nữa. User càng lúc càng giỏi và họ mong đợi ở những giao diện người dùng có tính tương tác và phản hồi cao. Tuy nhiên animating giao diện không nhất thiết phải đơn giản, minh bạch. Thứ gì cần được animated, khi nào và cảm giác mà một animation mang lại, đó mới là những câu hỏi khó trả lời. So sánh Javascript &amp; CSS animationCó 2 phương pháp chính để tạo web animation là dùng Javascript hoặc CSS. Không có lựa chọn nào đúng hay sai cả, tất cả tùy thuộc vào thứ mà bạn muốn đạt được. Animate với CSSAnimating với CSS là cách đơn giản nhất để làm một thứ gì đó chuyển động trên màn hình. Chúng ta sẽ bắt đầu với một ví dụ nhanh về việc di chuyển một phần tử 50px theo cả 2 trục X và Y. Có thể thực hiện bằng cách đặt một CSS transition với thời gian 1000ms. 123456789101112.box &#123; -webkit-transform: translate(0, 0); -webkit-transition: -webkit-transform 1000ms; transform: translate(0, 0); transition: transform 1000ms;&#125;.box.move &#123; -webkit-transform: translate(50px, 50px); transform: translate(50px, 50px);&#125; Khi class move được thêm vào, giá trị transform bị thay đổi và transition bắt đầu. Bên cạnh transition duration (thời gian dịch chuyển), có những tùy chọn cho easing, về bản chất thì đây là cảm giác của animation. Chúng ta sẽ tìm hiểu easing chi tiết hơn trong các phần sau của bài viết này. Nếu như trong đoạn code trên, bạn tạo ra những class CSS riêng biệt để quản lý animation thì bạn có thể dùng Javascript để tắt/mở mỗi animation. Nếu như bạn có phần tử sau: 123&lt;div class=\"box\"&gt; Sample content.&lt;/div&gt; Bạn có thể dùng Javascript để tắt/mở animation của nó: 1234567var boxElements = document.getElementsByClassName('box'), boxElementsLength = boxElements.length, i;for (i = 0; i &lt; boxElementsLength; i++) &#123; boxElements[i].classList.add('move');&#125; Đoạn code trên lấy tất cả những phần tử có class box và thêm class move vào để trigger animation. Làm như thế này tạo sự cân bằng cho app của bạn. Bạn có thể tập trung vào quản lý trạng thái với Javascript và chỉ cần đơn giản đặt những class thích hợp vào phần tử cần phải đặt, để cho trình duyệt xử lý các animation. Nếu bạn tiếp tục tìm hiểu theo hướng này, bạn có thể listen sự kiện transitioned trên mỗi phần tử, nhưng chỉ nếu như bạn phải support cho mấy phiên bản cũ của IE: Listen sự kiện transitioned (được bắn ra tại cuối thời điểm transition) giống như thế này: 123456var boxElement = document.querySelector('.box'); // Lấy phần tử đầu tiên có class `box`boxElement.addEventListener('transitionend', onTransitionEnd, false);function onTransitionEnd() &#123; // Xử lý sự kiện transition đã hoàn thành.&#125; Thêm nữa, khi sử dụng CSS transition, bạn có thể dùng CSS animation, nó cho phép bạn có quyền nhiều hơn để kiểm soát mỗi animation keyframe, duration và iteration. Keyframes được dùng để hướng dẫn chỉ định trình duyệt những giá trị của thuộc tính CSS cần phải có tại mỗi thời điểm nhất định và nó sẽ giúp xử lý phần còn lại. Ví dụ: 123456789101112131415161718192021222324252627282930313233343536373839/** * Đây là phiên bản đơn giản, không có * tiền tố vendor. Nếu có thêm chúng thì * sẽ còn dài dòng hơn nữa. */.box &#123; /* Chọn animation */ animation-name: movingBox; /* duration của animation */ animation-duration: 2300ms; /* số lần mà ta muốn animation chạy */ animation-iteration-count: infinite; /* làm cho animation đảo ngược vào mỗi vòng lặp lẻ */ animation-direction: alternate;&#125;@keyframes movingBox &#123; 0% &#123; transform: translate(0, 0); opacity: 0.4; &#125; 25% &#123; opacity: 0.9; &#125; 50% &#123; transform: translate(150px, 200px); opacity: 0.2; &#125; 100% &#123; transform: translate(40px, 30px); opacity: 0.8; &#125;&#125; Animation trông như thế này đây: https://sessionstack.github.io/blog/demos/keyframes/ Với CSS animation, bạn định nghĩa chính animation độc lập với phần tử đích và sử dụng thuộc tính animation-name để chọn animation được yêu cầu. Các CSS animation phần nào được đặt sẵn tiền tố vender, với -webkit- đang được sử dụng trong Safari, Safari Mobile và Android. Chrome, Opera, Internet Explorer và Firefox tất cả đều không có sẵn tiền tố. Nhiều công cụ có thể giúp bạn thêm phiên bản tiền tố của CSS mà bạn cần, cho phép bạn viết code mà không cần phải thêm tiền tố. Animate với JavascriptTạo animation với Javascript phức tạp hơn nhiều so với sử dụng CSS transition hay animation nhưng thường thì nó cung cấp cho developer nhiều sức mạnh đáng kể. Javascript animation được viết nội tuyến như là 1 phần của code. Bạn cũng có thể đóng gói nó bên trong các object. Bên dưới là code Javascript mà bạn cần để viết lại đoạn CSS transition ở phần trên: 12345678var boxElement = document.querySelector('.box');var animation = boxElement.animate([ &#123;transform: 'translate(0)'&#125;, &#123;transform: 'translate(150px, 200px)'&#125;], 500);animation.addEventListener('finish', function() &#123; boxElement.style.transform = 'translate(150px, 200px)';&#125;); Mặc định thì Web Animation chỉ chỉnh sửa phần trình bày của một phần tử. Nếu như bạn muốn object của mình vẫn giữ nguyên vị trí lúc nó được di chuyển tới thì bạn nên sửa lại style của nó khi animation kết thúc. Đây là lý do tại sao chúng ta listen sự kiện finish trong code trên, đặt thuộc tính box.style.transform bằng giá trị translate(150px, 200px) thì nó sẽ thể hiện giống như trường hợp transform thứ 2 trong CSS animation ở trên. Với Javascript animation, bạn hoàn toàn kiểm soát style của phần tử tại thời điểm bất kỳ. Nghĩa là bạn có thể làm animation chậm lại, tạm ngưng, dừng hẳn, đảo ngược và điều khiển phần tử cho tới khi phù hợp. Điều này cực kỳ hữu ích nếu bạn muốn xây dựng các ứng dụng hướng đối tượng phức tạp bởi vì bạn có thể đóng gói các hành vi của app một cách chính xác. Easing là gì?Chuyển động tự nhiên làm cho user cảm thấy dễ chịu hơn với webapp của bạn và mang đến trải nghiệm UX tốt hơn. Một cách tự nhiên, không có thứ gì di chuyển theo đường thẳng từ điểm này đến điểm khác. Thật ra thì mọi thứ đều có xu hướng tăng tốc và giảm tốc khi chúng di chuyển trong thế giới vật lý của chúng ta và có rất nhiều yếu tố khác nhau ảnh hưởng. Bộ não con người được thiết kế bẩm sinh để cảm nhận những chuyển động nên khi bạn thực hiện animation trên webapp hãy nhớ những kiến thức này. Một vài thuật ngữ bạn cần hiểu: ease in: là khi chuyển động bắt đầu chậm và tăng tốc dần lên. ease out: chuyển động bắt đầu nhanh và giảm tốc dần. Easing cho phép bạn tạo các animation cho cảm giác tự nhiên hơn. Các từ khóa cho easingCSS transition và animation cho phép bạn chọn loại easing mà bạn muốn. Có nhiều từ khóa khác nhau ảnh hưởng đến easing của animation. Bạn cũng có thể tạo ra easing hoàn toàn của riêng bạn. Dưới đây là 1 số từ khóa bạn có thể dùng trong CSS để điều khiển easing: linear ease-in ease-out ease-in-out Giờ thì cùng tìm hiểu về chúng nào. Linear animationCác animation không có bất cứ kiểu easing nào thì được gọi là linear (thẳng hàng, còn hàn lâm hơn thì “Tuyến tính”).Đồ thị thể hiện một linear animation: Thời gian càng tăng thì giá trị cũng tăng với lượng tương ứng. Với chuyển động linear, mọi thứ có xu hướng thiếu tự nhiên. Nói chung bạn nên tránh sử dụng chuyển động linear. Đây là cách triển khai một linear animation đơn giản: 1transition: transform 500ms linear; Ease-out animationNhư đã nói ở trên, ease out làm cho animation bắt đầu nhanh hơn so với kiểu linear trong khi đó nó lại chậm dần khi kết thúc. Đồ thị trông như thế này: Nhìn chung, ease out là sự lựa chọn tốt nhất cho UI bởi vì khởi động nhanh làm cho animation của bạn có cảm giác phản hồi tốt trong khi chậm dần khi kết thúc mang lại cảm giác tự nhiên do sự chuyển động không đồng nhất. Có nhiều cách để triển khai hiệu ứng ease out nhưng cách đơn giản nhất là từ khóa ease-out trong CSS: 1transition: transform 500ms ease-out; Ease-in animationĐây là kiểu đối lập lại với ease-out animation: bắt đầu chậm chạp và kết thúc nhanh. Đồ thị mô tả: So với ease-out animation thì ease-in có hơi không bình thường vì chúng tạo ra cảm giác thiếu sự phản hồi, bởi vì chúng khởi động chậm. Kết thúc nhanh có thể cũng tạo ra cảm giác lạ tương tự, toàn bộ animation đều tăng tốc trong khi đối tượng ở thế giới thực có xu hướng giảm tốc khi dừng lại đột ngột. Để dùng ease-in animation thì bạn có thể dùng từ khóa tương tự như trên: 1transition: transform 500ms ease-in; Ease-in-out animationĐây là animation kết hợp của ease-in và ease-out. Đồ thị: Không nên sử dụng anmation-duration quá lâu bởi vì nó mang lại cảm giác rằng UI của bạn thiếu sự phản hồi. Cách sử dụng ease-in-out animation: 1transition: transform 500ms ease-in-out; Tùy biến easingBạn có thể định nghĩa đường cung easing cho riêng bạn để có thể kiểm soát nhiều hơn những cảm giác mà animation có thể tạo ra. Trên thực tế, các từ khóa ease-in, ease-out, liner, ease được nối với những đường cung Bezier (Bézier curves) đã định nghĩa sẵn, bạn có thể xem chi tiết ở Thông số kỹ thuật của CSS transition hoặc của Web Animation Đường cung BezierCùng tìm hiểu về cách hoạt động của đường cung Bezier nào.Một cung Bezier nhận 4 giá trị, hoặc nói rõ hơn thì nó nhận vào 2 cặp số. Mỗi cặp định nghĩa tọa độ X và Y của 1 điểm kiểm soát thuộc khối cung Bezier. Điểm bắt đầu của cung Bezier có tọa độ (0, 0) và kết thúc là ở (1, 1). Bạn có thể đặt cả 2 cặp số. Giá trị X cho 2 kiểm kiểm soát phải nằm trong khoảng [0, 1] còn giá trị của Y thì có thể vượt quá giới hạn [0, 1], mặc dù thông số kỹ thuật không nói rõ là bao nhiêu. Kể cả những thay đổi nhỏ trong giá trị X và Y của mỗi điểm kiểm soát mang đến cho bạn một cung hoàn toàn khác biệt. Ở 2 đồ thị bên dưới, cung Bezier có các điểm gần nhau nhưng khác tọa độ. và Như bạn thấy thì đồ thị khá là khác nhau. Điểm kiểm soát đầu tiên có vector với giá trị sai khác là (0.045, 0.183) còn điểm thứ 2 là (-0.427, -0.054) Còn đây là phần CSS cho đường cung thứ 2: 1transition: transform 500ms cubic-bezier(0.465, 0.183, 0.153, 0.946); 2 số đầu tiên là tọa độ X và Y của điểm kiểm soát thứ nhất, 2 số tiếp theo là của điểm kiểm soát thứ 2. Tối ưu hóa hiệu năngBạn cần phải duy trì 60 khung hình/giây (60 fps - game thủ hiểu cái này lắm nè :D) khi làm animation nếu không thì nó sẽ ảnh hưởng tiêu cực đến UX. Và như 1 lẽ dĩ nhiên thì animation không hề miễn phí. Không phải là chuyện tiền nong, mà là hiệu năng. Animate một vài thuộc tính có thể không tốn kém như một số khác. Ví dụ: animate width và height của 1 phần tử sẽ thay đổi trạng thái hình học của nó và là nguyên nhân ảnh hưởng đến các phần tử khác trên trang bị thay đổi vị trí hoặc kích thước. Quá trình này được gọi là layout. Chúng ta cũng đã thảo luận chi tiết về layout và rendering trong bài trước rồi. Nói chung, bạn cần tránh animate những thuộc tính nào có thể trigger quá trình layout hoặc tô màu (paint). Với đa số các trình duyệt hiện đại thì điều này nghĩa là hạn chế animation với opacity và transform Will-changeBạn có thể dùng will-change để thông báo cho trình duyệt biết bạn có ý định thay đổi thuộc tính của 1 phần tử. Nó cho phép trình duyệt cài đặt sẵn sàng trước những tối hưu hóa thích hợp nhất khi bạn cần thay đổi. Tuy nhiên cũng đừng lạm dụng will-change, bởi vì làm như thế có thể làm cho trình duyệt hao tốn tài nguyên và quay ngược lại gây ra nhiều vấn đề hơn về hiệu năng. Cách để thêm will-change cho transform và opacity: 123.box &#123; will-change: transform, opacity;&#125; Trình duyệt hỗ trợ: Chọn Javascript hay CSSCó lẽ bạn cũng đã thấy rằng không có câu trả lời đúng cho câu hỏi này, tùy thuộc vào nhiều yếu tố, dưới đây là những thứ bạn cần cân nhắc mỗi khi lựa chọn: Các animation dựa trên CSS và Web Animation được hỗ trợ native và được xử lý trong tiến trình gọi là “tiến trình tổng hợp” (compositor thread). Khác với “tiến trình chính” của trình duyệt, nơi mà styling, layout, painting và code Javascript được thực thi. Nghĩa là nếu như trình duyệt đang bận xử lý 1 số tác vụ nặng ký trên tiến trình chính thì những animation đó vẫn có thể tiếp tục thực hiện mà không bị can thiệp. Trong một vài trường hợp. các thay đổi đối với transform và opacity có thể được xử lý bởi tiến trình tổng hợp. Nếu animation trigger paint, layout hoặc cả 2 thì tiến trình chính sẽ cần phải tham gia xử lý. Trường hợp này xảy ra cho cả CSS và Javascript animation, và dĩ nhiên là việc thực hiện layout hoặc paint như vậy sẽ làm chậm bất kỳ tác vụ nào liên quan đến thực thi CSS hay Javascript Chọn đúng thứ để animateNhững animation tuyệt vời thường tạo nên sự thích thú và gắn kết giữa project của bạn với người dùng. Bạn có thể animate bất cứ thứ gì bạn muốn, dù là width, height, position, color, background, vân vân, nhưng cần phải chú ý đến những nút thắt cổ chai tiềm tàng về hiệu năng. Những animation được chọn lựa 1 cách bất cẩn có thể ảnh hưởng tiêu cực đến UX, vì vậy animation cần phải vừa phù hợp vừa tốt cho hiệu năng. Animate càng ít càng tốt, chỉ nên animate khi bạn cần UX trở nên tự nhiên hơn nhưng đừng lạm dụng nó. Dùng animation để hỗ trợ tương tácKhông nên animate chỉ vì bạn thích thế. Thay vì vậy, sử dụng animation tại những vị trí chiến lược để củng cố thêm về tương tác người dùng. Tránh animation làm ngắt quãng hoặc cản trở một cách không cần thiết các hoạt động của user Tránh animate những thuộc tính phức tạpChỉ có duy nhất 1 thứ tệ hơn cả animation đặt sai chỗ chính là những animation làm cho trang web bị lag. Kiểu animation này làm cho user cảm thấy bực bội và chán nản. Team tác giả sử dụng animation khá dễ dàng với SessionStack. Nói chung, họ theo sát những nguyên tắc đã nêu ở trên nhưng cũng có một số trường hợp mà họ phải dùng animation vì sự phức tạp của UI. SessionStack phải tái tạo lại dưới dạng video toàn bộ những thứ xảy ra với người dùng cuối tại thời điểm họ gặp phải vấn đề khi đang lướt web hay dùng webapp. Để làm được điều này SessionStack tận dụng duy nhất những dữ liệu thu thập được xuyên suốt phiên làm việc: sự kiện từ user, thay đổi trên DOM, request mạng, biệt lệ, thông báo debug, vân vân. Trình chơi của họ được tối ưu hóa khá tốt để có thể render một cách chính xác và sử dụng toàn bộ dữ liệu thu thập được để giả lập chính xác đến từng pixel trình duyệt của người dùng và những thứ xảy ra trên nó, cả về khía cạnh nhìn thấy được và góc nhìn kỹ thuật. Để đảm bảo quá trình tái tạo diễn ra một cách tự nhiên, đặc biệt với những phiên làm việc kéo dài và nặng dữ liệu, team tác giả sử dụng các animation để chỉ định chính xác hoạt động loading/buffering và bám sát các nguyên tắc tốt nhất để triển khai chúng, do đó họ không cần quá nhiều CPU và vẫn có thể để cho event loop được rảnh tay render các session.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P12: Bên trong lớp Network + Làm sao để tối ưu hóa hiệu năng và bảo mật Javascript","slug":"Cach-Javascript-hoat-dong-P12-Ben-trong-lop-Network-Lam-sao-de-toi-uu-hoa-hieu-nang-va-bao-mat-Javascript","date":"2018-11-25T09:06:00.000Z","updated":"2018-11-25T09:10:31.361Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P12-Ben-trong-lop-Network-Lam-sao-de-toi-uu-hoa-hieu-nang-va-bao-mat-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P12-Ben-trong-lop-Network-Lam-sao-de-toi-uu-hoa-hieu-nang-va-bao-mat-Javascript.html","excerpt":"Chào các bạn đến với bài thứ 12 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Như đã nói trong bài trước về render engine, tác giả bài viết tin rằng sự khác biệt giữa một Javascript developer tốt (good) và tuyệt vời (great) là dev tuyệt vời không những hiểu về các thành phần cơ bản của một ngôn ngữ mà còn cả phần cốt lõi cũng như môi trường xung quanh nó.","text":"Chào các bạn đến với bài thứ 12 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Như đã nói trong bài trước về render engine, tác giả bài viết tin rằng sự khác biệt giữa một Javascript developer tốt (good) và tuyệt vời (great) là dev tuyệt vời không những hiểu về các thành phần cơ bản của một ngôn ngữ mà còn cả phần cốt lõi cũng như môi trường xung quanh nó. Nhắc sơ qua về lịch sử một chút49 năm trước, một thứ gọi là ARPAnet được tạo ra. Nó chính là một mạng chuyển đổi gói tin sớm và cũng là mạng đầu tiên triển khai bộ TCP/IP. Mạng này cài đặt một liên kết giữa trường đại học California và Học viện nghiên cứu Stanford. 20 năm sau, Tim Berners-Lee phát hành một lời đề nghị cho “Mesh” - thứ mà sau này được biết đến là World Wide Web. Trong 49 năm đó, internet đã đi được một quãng đường dài, bắt đầu chỉ với 2 máy tính trao đổi các gói dữ liệu và giờ đạt tới hơn 75 triệu server, 3.8 tỉ người dùng internet và 1.3 tỉ websites. Trong bài này, chúng ta sẽ thử phân tích những kỹ thuật nào trình duyệt hiện đại sử dụng để tự động đẩy mạnh hiệu năng (thậm chí bạn không biết đến điều đó), và chúng ta sẽ đặc biệt soi kỹ vào lớp networking của trình duyệt. Ở cuối bài, tác giả sẽ cung cấp một số ý tưởng làm thế nào để giúp trình duyệt đẩy mạnh hơn nữa hiệu năng của webapp của bạn. Khái quátTrình duyệt web hiện đại được thiết kế đặc trị cho việc truyền tải webapp/website một cách nhanh chóng, hiệu quả và an toàn bảo mật. Với hàng trăm component cùng hoạt động trên nhiều layer khác nhau, từ quản lý tiến trình và bảo mật sandbox đến các GPU pipeline, audio và video, và còn nhiều thứ khác nữa, trình duyệt trông giống như một hệ điều hành hơn là một phần mềm bình thường. Hiệu năng tổng quát của trình duyệt được xác định bằng một cơ số các component lớn: parsing (phân giải), layout, tính toán style, quá trình thực thi Javascript &amp; WebAssembly, rendering và dĩ nhiên là cả networking stack (ngăn xếp mạng). Các kỹ sư thường nghĩ rằng networking stack là một nút cổ chai. Điều này xảy ra thường xuyên vì tất cả các tài nguyên đều cần phải được lấy về từ internet trước khi các bước còn lại được thực hiện. Với networking layer, để hoạt động hiệu quả nó cần phải đóng vai trò nhiều hơn là một bộ quản lý socket đơn giản. Với chúng ta, nó như một thứ núp dưới dạng một cơ chế rất đơn giản để kéo tài nguyên về nhưng đó thực sự là một nền tảng (platform) đầy đủ với các tiêu chí tối ưu hóa, APIs và service của riêng nó. Là web developer, chúng ta không cần phải lo nghĩ về từng gói tin TCP hay UDP, định dạng request, caching và tất cả những thứ liên quan. Toàn bộ sự phức tạp này được trình duyệt gánh dùm nên ta chỉ cần tập trung vào ứng dụng mà chúng ta đang tạo ra. Tuy nhiên, hiểu rõ điều gì thực sự đang diễn ra bên trong có thể giúp chúng ta tạo ra app nhanh hơn và bảo mật tốt hơn. Về bản chất thì dưới đây là những gì xảy ra khi user bắt đầu tương tác với trình duyệt: User nhập một URL vào thanh địa chỉ trên trình duyệt Giả sử URL đó chỉ đến 1 tài nguyên trên mạng, trình duyệt sẽ bắt đầu kiểm tra local cache và cache của ứng dụng và cố thử sử dụng một phải copy có sẵn ở local để đáp ứng request. Nếu cache không dùng được, tình duyệt sẽ lấy tên miền từ URL và yêu cầu địa chỉ IP của server từ một DNS. Nếu tên miền đã được cache sẵn thì không cần truy vấn đến DNS. Trình duyệt tạo ra một gói tin HTTP nói rằng nó yêu cầu một trang web đang cư trú tại một server từ xa. Gói tin được gửi đến TCP layer, layer này sẽ thêm thông tin của chính nó vào vị trí trên cùng của gói tin HTTP. Thông tin này cần thiết để duy trì phiên khởi động. Gói tin sau đó được trao cho IP layer với công việc chính là tìm hiểu một cách để gửi gói tin từ user đến server từ xa. Thông tin này cũng được lưu vào vị trí trên cùng của gói tin. Gói tin được gửi đến server từ xa. Khi đã nhận gói tin, một phản hồi được gửi ngược lại theo cách thức tương tự. Đặc tính kỹ thuật của Navigation Timing từ W3C cung cấp một API trình duyệt cũng như khả năng hiển thị dữ liệu về thời gian và hiệu năng đằng sau mỗi request trên trình duyệt. Giờ thì cùng quan sát các component, mỗi phần sẽ đóng một vai trò quan trọng trong việc cung cấp các trải nghiệm người dùng (UX) tối ưu: Toàn bộ tiến trình networking rất phức tạp và có nhiều layer khác nhau có thể trở thành một nút cổ chai. Đây là lý do các trình duyệt cố gắng phấn đấu để cải thiện hiệu năng bản thân bằng cách sử dụng rất nhiều kỹ thuật đa dạng để giảm thiểu tối đa sự ảnh hưởng của toàn bộ giao tiếp network. Quản lý socketCùng khởi động với một số thuật ngữ nào: Origin: một bộ 3 chứa các giao thức ứng dụng, tên miền và số port (ví dụ: https, www.example.com, 443) Socket pool: một nhóm các socket thuộc về cùng origin (tất cả các trình duyệt lớn đều giới hạn pool size lớn nhất là 6 socket). Javascript và WebAssembly không cho phép chúng ta quản lý vòng đời của các network socket riêng tư, và dĩ nhiên như vậy là tốt! Điều này không những giúp chúng ta dễ dàng hơn mà còn cho phép trình duyệt tự động thực hiện rất nhiều tối ưu hóa hiệu năng, một trong số đó bao gồm: sử dụng lại socket, yêu cầu sự ưu tiên và ràng buộc muộn (late binding), giao dịch giao thức, ép buộc giới hạn kết nối, vân vân. Thật ra các trình duyệt hiện đại đã làm tốt trong việc chia tách vòng quản lý request khỏi phần quản lý socket. Các socket được tổ chức trong các pool và được nhóm lại theo origin, mỗi pool bắt buộc phải giới hạn kết nối và các ràng buộc bảo mật. Các request chờ được xếp vào trong hàng đợi, đánh thứ tự ưu tiên và sau đó gắn kết với những socket riêng tư trong pool. Trừ khi server có ý định đóng kết nối thì cùng một socket có thể được sử dụng lại một cách tự động xuyên suốt nhiều request. Bởi vì mở mới 1 kết nối TCP thường kèm theo chi phí tốn kém cho nên tái sử dụng lại các kết nối cũ sẽ đảm bảo hiệu năng tốt hơn nhiều. Mặc định thì trình duyệt sử dụng cơ chế gọi là “keepalive” (giữ cho sống) để tiết kiệm thời gian từ việc mở mới kết nối đến server khi có request được tạo ra. Thời gian trung bình để mở 1 kết nối TCP là: Request đến máy local: 23ms Request trong nội bộ châu lục: 120ms Request giữa các châu lục với nhau: 225ms Kiểu kiến trúc này mở ra cánh cửa đến với rất nhiều cơ hội để tối ưu hóa. Request có thể được thực thi với những thứ tự khác nhau tùy thuộc vào độ ưu tiên của nó. Trình duyệt có thể tối ưu hóa sự phân chia băng thông giữa toàn bộ các socket hoặc là nó có thể mở socket khi dự đoán trước về một request. Như đã nói trước đó, toàn bộ đều được quản lý bởi trình duyệt và không yêu cầu chúng ta giúp bất cứ thứ gì. Nhưng nó không nhất thiết nghĩa là chúng ta không thể làm gì. Chọn lựa đúng pattern về giao tiếp mạng, loại và tần suất transfer, lựa chọn các giao thức và tinh chỉnh/tối ưu hóa server stack có thể đóng vai trò rất lớn trong việc cải thiện hiệu năng tổng thể của ứng dụng. Một vài trình duyệt thậm chí còn đi xa hơn. Ví dụ, Chrome có thể tự dạy cho chính nó hoạt động nhanh hơn khi bạn sử dụng nó. Nó học hỏi dựa trên những trang bạn đã ghé thăm và kiểu duyệt web điển hình cho nên nó có thể dự đoán hành vi người dùng có khả năng và thực hiện hành động trước khi user làm gì đó. Ví dụ đơn giản nhất là tự động render trước nội dung của trang khi user rê chuột lên 1 link. Nếu bạn thấy hứng thú về chủ đề tối ưu hóa của Chrome thì có thể đọc thêm chương này https://www.igvita.com/posa/high-performance-networking-in-google-chrome/ nằm trong quyển sách High-Performance Browser Networking Bảo mật mạng và đóng gói sandboxCho phép trình duyệt quản lý các socket riêng biệt có một ý nghĩa rất quan trọng: bằng cách này trình duyệt cho phép áp đặt một hệ thống đồng nhất các ràng buộc về chính sách và bảo mật lên những nguồn tài nguyên ứng dụng không đáng tin cậy. Ví dụ như trình duyệt sẽ không chấp nhận API truy xuất trực tiếp vào network socket thô vì như vậy có thể cho phép các ứng dụng độc hại tạo kết nối tùy tiện đến bất cứ host nào. Trình duyệt cũng áp đặt các giới hạn kết nối để bảo vệ server cũng như client khỏi cạn kiệt tài nguyên. Trình duyệt định dạng tất cả các request đi ra để áp đặt sự đồng nhất và các ngữ nghĩa giao thức tốt để bảo vệ server. Tương tự, giải mã response được thực hiện một cách tự động để bảo vệ user từ những server độc hại. Trao đổi TLSTransport Layer Security (TLS) là một giao thức mật mã cung cấp giao tiếp bảo mật trong mạng máy tính. Nó được sử dụng rộng rãi trong nhiều ứng dụng, một trong số đó là trình duyệt web. Website có thể dùng TLS để bảo đảm an ninh cho tất cả các giao tiếp giữa server và trình duyệt web. Toàn bộ quá trình bắt tay TLS bao gồm các bước sau: Client gửi một lời nhắn “Client hello” đến server, cùng với một giá trị ngẫu nhiên của client và bộ mã hóa được hỗ trợ. Server trả lời bằng cách gửi lời nhắn “Server hello” về cho client, cùng với giá trị ngẫu nhiên của server. Server gửi chứng chỉ xác thực của nó về cho client và có thể yêu cầu một chứng chỉ tương tự từ phía client. Server gửi lời nhắn “Server hello done”. Nếu server đã yêu cầu một chứng chỉ từ client thì client phải gửi nó. Client tạo ra một Pre-Master Secret ngẫu nhiên và mã hóa nó với public key từ chứng chỉ của server, gửi Pre-Master Secret đã được mã hóa về cho server. Server nhận Pre-Master Secret. Server và client mỗi bên sẽ sinh ra Master Secret và session key (chìa khóa phiên) dựa trên Pre-Master Secret. Client gửi thông báo “Change cipher spec” đến server để xác định rằng client sẽ bắt đầu sử dụng session key mới để băm và mã hóa message. Client cũng đồng thời gửi tin nhắn “Client finished”. Server nhận “Change cipher spec” và chuyển đổi trạng thái bảo mật của record layer của nó sang trạng thái bảo mật mã hóa đối xứng bằng session key. Server gửi lời nhắn “server finished” về cho client. Client và server giờ có thể trao đổi dữ liệu ứng dụng thông qua kênh bảo mật mà chúng đã thiết lập. Tất cả message được gửi từ client đến server và ngược lại đều được mã hóa bằng session key. User được cảnh báo trong trường hợp một trong số xác thực nào đó bị sai, ví dụ: server đang dùng một chứng chỉ tự cấp. Chính sách cùng originHai trang có cùng origin nếu như giao thức, cổng (nếu được chỉ định) và host đều giống nhau giữa 2 trang Dưới đây là một vài ví dụ về các tài nguyên có thể được nhúng cross-origin (xuyên origin): Javascript với code &lt;script src=&quot;…&quot;&gt;&lt;/script&gt;. Thông báo lỗi cú pháp chỉ tồn tại cho những đoạn script cùng origin. CSS với &lt;link rel=&quot;stylesheet&quot; href=&quot;…&quot;&gt;. Do quy tắc cú pháp thoải mái của CSS nên CSS cross-origin cần một header Content-Type đúng loại. Sự hạn chế thì tùy thuộc vào trình duyệt. Hình ảnh với thẻ &lt;img /&gt; File đa phương tiện với &lt;video&gt; và &lt;audio&gt; Plug in với &lt;object&gt;, &lt;embed&gt; and &lt;applet&gt; Fonts với @font-face. Vài trình duyệt cho phép các font cross-origin, một số khác thì yêu cầu fonts trong cùng origin. Bất cứ thứ gì với &lt;frame&gt; và &lt;iframe&gt;. Một trang có thể sử dụng header X-Frame-Options để ngăn chặn trường hợp tương tác cross-origin này. Danh sách trên vẫn còn thiếu sót nhiều, mục đích của nó là làm nổi bật nguyên tắc “quyền hạn tối thiểu” (least privilege). Trình duyệt chỉ phô ra những API và tài nguyên cần thiết cho code của chương trình: ứng dụng hỗ trợ dữ liệu và URL, trình duyệt định dạng các request và xử lý toàn bộ vòng đời của mỗi kết nối. Rất đáng để lưu tâm rằng hoàn toàn không có một concept cụ thể nào của “chính sách cùng origin” (same-origin policy). Thay vào đó, chỉ có 1 bộ cơ chế liên quan áp đặt các ràng buộc lên việc truy xuất DOM, cookie và quản lý trạng thái của session, mạng và các thành phần khác của trình duyệt. Lưu đệm tài nguyên và trạng thái của clientRequest nhanh nhất và tốt nhất chính là không gọi request nào cả. Trước khi điều phối một request, trình duyệt tự động kiểm tra bộ đệm tài nguyên của nó, thực hiện các kiểm tra xác nhận cần thiết và trả về một bản copy local của tài nguyên đó nếu phù hợp với những điều kiện cụ thể. Nếu tài nguyên ở local không tồn tại trong cache thì request lên mạng được gọi và response sẽ được chèn tự động vào trong cache để cho lần truy cập tiếp theo nếu được phép. Trình duyệt tự động đánh giá các chỉ thị lưu đệm (cache directives) cho mỗi tài nguyên. Trình duyệt tự động xác nhận lại các tài nguyên hết hạn khi nó có thể. Trình duyệt tự động quản lý kích cỡ của bộ đệm và thu hồi tài nguyên. Quản lý bộ đệm tài nguyên một cách hiệu quả và tối ưu là rất khó. Ơn trời trình duyệt đã xử lý toàn bộ những thứ phức tạp ấy giúp chúng ta rồi, tất cả những gì ta cần làm là đảm bảo server của mình trả về cache directive phù hợp, để hiểu rõ hơn thì bạn có thể đọc bài Cache Resources on the Client. Bạn cung cấp các response headers như Cache-Control, ETag và Last-Modified cho tất cả nguồn tài nguyên trên trang của bạn, phải không? Cuối cùng, một chức năng thường bị bỏ quả nhưng khá quan trọng của trình duyệt chính là nhiệm vụ cung cấp xác thực, session và quản lý cookie. Trình duyệt duy trì các gói cookie (cookie jars - tác giả chơi chữ “cookie - bánh quy”) riêng biệt cho mỗi origin, cung cấp các ứng dụng cần thiết và server APIs để đọc/ghi cookie, session và dữ liệu xác thực mới, tự động nối &amp; xử lý các header HTTP phù hợp để tự động hóa toàn bộ quá trình thay cho chúng ta. Ví dụ:Một ví dụ đơn giản nhưng dễ minh họa nhất về sự tiện dụng của việc hoãn quản lý trạng thái session với trình duyệt: một session đã được xác thực có thể chia sẻ giữa nhiều tab với nhau hoặc nhiều cửa sổ trình duyệt và ngược lại; một hành động đăng xuất (sign-out) ở 1 tab sẽ vô hiệu hóa các session đang mở ở toàn bộ các cửa sổ đang mở khác. Các API ứng dụng và giao thứcCàng đi sâu tìm hiểu về các dịch vụ network sẵn có thì cuối cùng chúng ta cũng đã tiến đến các API ứng dụng và giao thức (Application APIs &amp; Protocols). Như ta đã biết, những layer thấp thì cung cấp một mảng rộng các dịch vụ quan trọng: quản lý socket &amp; kết nối, xử lý request &amp; response, áp đặt nhiều chính sách bảo mật, lưu đệm &amp; còn nhiều nữa. Mỗi khi chúng ta khởi tạo HTTP hay XMLHttpRequest, sự kiện long-lived Server-Sent hay WebSocket session, hoặc mở kết nối WebRTC… chúng ta đang tương tác với một hoặc nhiều các dịch vụ đó. Không có giao thức hay API nào tốt nhất. Mỗi ứng dụng phức tạp sẽ cần một tổ hợp các giao vận (transports) khác nhau dựa trên sự đa dạng của các yêu cầu: giao tiếp với bộ đệm trình duyệt, protocol overhead (metadata hoặc thông tin điều hướng mạng được gửi bởi ứng dụng), độ trễ của message, độ tin cậy, kiểu truyền tải dữ liệu, vân vân. Một số giao thức có thể đáp ứng với độ trễ thấp (ví dụ: Server-Sent Events, WebSocket), nhưng không yêu cầu các tiêu chí quan trọng khác, chẳng hạn như khả năng tận dụng bộ đệm trình duyệt hoặc hỗ trợ truyền tải nhị phân hiệu quả trong mọi trường hợp. Một vài thứ bạn có thể làm để cải thiện hiệu năng và bảo mật của Webapp Luôn luôn sử dụng header Connection: Keep-Alive trong các request. Trình duyệt đã mặc định sẵn rồi. Đảm bảo server sử dụng cơ chế tương tự. Sử dụng header Cache-Control, Etag và Last-Modified phù hợp để tiết kiệm thời gian download cho trình duyệt. Dành thời gian để tinh chỉnh và tối ưu hóa web server, phép màu sẽ xảy ra! Nhớ rằng quá trình này rất cụ thể cho từng loại webapp và kiểu dữ liệu mà bạn trao đổi. Luôn luôn dùng TLS! Đặc biệt nếu như bạn có bất kỳ xác thực nào trong ứng dụng của bạn. Nghiên cứu trình duyệt cung cấp các chính sách bảo mật nào và áp đặt chúng vào trong ứng dụng của bạn. Hiệu năng và bảo mật là ưu tiên hàng đầu trong SessionStack. Lý do tại sao team tác giả không thể nghiêng về một bên nào hơn là bởi vì một khi đã tích hợp SessionStack vào webapp, nó bắt đầu giám sát mọi thứ từ thay đổi trên DOM, tương tác người dùng đến request mạng, biệt lệ và thông báo debug. Tất cả thông tin này được truyền về server theo thời gian thực và cho phép user có thể chạy lại các vấn đề đã xảy ra dưới dạng video &amp; xem mọi thứ xảy ra với người dùng của bạn. Tất cả hoạt động này được thực hiện với độ trễ tối thiểu và không ảnh hưởng tới hiệu năng của app của bạn.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P11: Render engine & mẹo tối ưu hóa hiệu năng render","slug":"Cach-Javascript-hoat-dong-P11-Render-engine-meo-toi-uu-hoa-hieu-nang-render","date":"2018-11-25T08:29:00.000Z","updated":"2018-11-25T08:33:25.317Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P11-Render-engine-meo-toi-uu-hoa-hieu-nang-render.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P11-Render-engine-meo-toi-uu-hoa-hieu-nang-render.html","excerpt":"Chào các bạn đến với bài thứ 11 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Trong những bài trước của series “Đục khoét Javascript”, chúng ta đã tập trung vào tìm hiểu ngôn ngữ Javascript, các tính năng của nó, cách chúng được thực thi trên trình duyệt, làm thế nào để tối ưu hóa, vân vân. Tuy nhiên, khi bạn xây dựng webapp, bạn không chỉ viết code Javascript. Code của bạn còn tương tác với môi trường. Thấu hiểu môi trường, cách nó hoạt động cũng như các thành phần của nó sẽ cho phép bạn xây dựng app tốt hơn và có nền tảng chuẩn bị tốt để đề phòng những nguy cơ tiềm tàng có thể xảy đến bất cứ lúc nào khi lên production.","text":"Chào các bạn đến với bài thứ 11 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Trong những bài trước của series “Đục khoét Javascript”, chúng ta đã tập trung vào tìm hiểu ngôn ngữ Javascript, các tính năng của nó, cách chúng được thực thi trên trình duyệt, làm thế nào để tối ưu hóa, vân vân. Tuy nhiên, khi bạn xây dựng webapp, bạn không chỉ viết code Javascript. Code của bạn còn tương tác với môi trường. Thấu hiểu môi trường, cách nó hoạt động cũng như các thành phần của nó sẽ cho phép bạn xây dựng app tốt hơn và có nền tảng chuẩn bị tốt để đề phòng những nguy cơ tiềm tàng có thể xảy đến bất cứ lúc nào khi lên production. Các thành phần chính của trình duyệt: Giao diện (User interface): phần này bao gồm thanh địa chỉ (address bar), nút back &amp; forward, menu bookmark, vân vân. Về bản chất, đây là những phần thuộc về trình duyệt hiển thị lên cho bạn thấy, ngoại trừ khung hiển thị trang web. Engine trình duyệt (Browser engine): nó xử lý các giao tiếp giữa user interface và rendering engine Engine dựng hình (Rendering engine): chịu trách nhiệm hiển thị trang web. Rendering engine sẽ phân giải HTML &amp; CSS và hiển thị nội dung đó lên màn hình. Mạng (Networking): đây là những lời gọi mạng chẳng hạn như XHR request, chúng được tạo ra bằng cách sử dụng nhiều triển khai khác nhau cho nhiều nền tảng khác nhau nằm phía sau một interface độc lập nền tảng (platform-independent interface). Chúng ta sẽ thảo luận về lớp network chi tiết hơn ở bài tiếp theo (số 12) trong series này nhé. Giao diện ở backend (UI Backend): dùng để vẽ nên các thành phần cốt lõi, ví dụ như checkbox hay cửa sổ. Phần này thể hiện một interface chung không phụ thuộc hay đặc trưng cho nền tảng. Nó sử dụng các phương thức về UI của hệ điều hành. Javascript engine: Chúng ta đã tìm hiểu về phần này trong bài trước. Về cơ bản, đây là nơi code Javascript được thực thi. Cố định dữ liệu (Data persistence): app của bạn có thể cần lưu trữ dữ liệu ở phía local. Các loại kiến trúc lưu trữ được hỗ trợ ở đây gồm có localStorage, indexDB, WebSQL và FileSystem Trong bài này, chúng ta sẽ tập trung vào rendering engine (engine dựng hình), bởi vì nó xử lý quá trình phân giải và hình ảnh hóa (visualization) code HTML &amp; CSS, là phần mà đa số app Javascript cần tương tác liên tục. Khái quát về rendering engineCông việc chính của rendering engine là hiển thị trang được yêu cầu lên màn hình của trình duyệt. Rendering engine có thể hiển thị HTML, văn bản XML và ảnh. Nếu bạn sử dụng thêm plugin ở ngoài thì engine có thể hiển thị các loại văn bản khác, chẳng hạn như PDF. Rendering enginesTương tự như Javascript engine, trình duyệt khác nhau cũng sử dụng các rendering engine khác nhau. Một vài bộ engine nổi tiếng: Gecko — Firefox WebKit — Safari Blink — Chrome, Opera (từ phiên bản 15 trở đi) Quá trình renderRendering engine nhận nội dung của văn bản được yêu cầu từ lớp networking. Xây dựng DOM treeBước đầu tiên của công cuộc rendering là phân giải văn bản HTML và chuyển những phần tử đã phân giải thành những DOM node thực sự trong DOM tree. Giả sử bạn có đoạn input như sau: 123456789101112&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"theme.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Hello, &lt;span&gt; friend! &lt;/span&gt; &lt;/p&gt; &lt;div&gt; &lt;img src=\"smiley.gif\" alt=\"Smiley face\" height=\"42\" width=\"42\"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; DOM tree của đoạn HTML trên sẽ giống như sau: Về cơ bản thì mỗi phần tử được thể hiện như là một node cha của tất cả các element khác nằm trực tiếp ngay bên dưới (bên trong) nó. Nguyên tắc này được áp dụng một cách đệ quy. Xây dựng CSSOM treeCSSOM viết tắt của CSS Object Model. Trong khi trình duyệt đang xây dựng DOM, nó bắt gặp một thẻ link trong phần head và dẫn tới một file CSS tên là theme.css ở bên ngoài. Dự đoán rằng nó có thể cần đến tài nguyên này để render trang, ngay lập tức nó điều phối 1 request đến. Giả sử file theme.css có nội dung như sau: 12345678910111213141516171819body &#123; font-size: 16px;&#125;p &#123; font-weight: bold; &#125;span &#123; color: red; &#125;p span &#123; display: none; &#125;img &#123; float: right; &#125; Tương tự HTML, engine cần chuyển tất cả CSS sang một thứ gì đó mà trình duyệt có thể xử lý, chính là CSSOM. Dưới đây là mô phỏng của CSSOM tree: Bạn có tự hỏi tại sao CSSOM lại có cấu trúc dạng cây (tree)? Khi tính toán bộ style cuối cùng cho mỗi object tren trang, trình duyệt sẽ bắt đầu với rule áp dụng toàn cục nhất cho node đó (ví dụ: nếu nó là con của phần tử body thì áp dụng tất cả style của body) và tinh chỉnh một cách đệ quy những style đã được tính toán bằng cách áp dụng các rule cụ thể hơn. Với ví dụ ở trên, bất kỳ text nào nằm bên trong thẻ span mà span nằm trong phần tử body thì đều có font-size 16 và màu đỏ. Những style này được kế thừa từ phần tử body. Nếu như span là con của phần tử p thì nội dung của nó sẽ bị ẩn bởi vì có style khác cụ thể hơn đã được áp dụng cho nó (ở đây là display: none). Thêm nữa, lưu ý rằng tree ở trên chưa phải là CSSOM tree hoàn chỉnh và chỉ thể hiện những style mà ta đã ghi đè trong style sheet. Mỗi trình duyệt cung cấp 1 bộ style mặc định, còn được biết tới là user agent styles - đây chính những gì ta thấy nếu như không cung cấp style cụ thể. Style của chúng ta thêm vào chỉ đơn giản là ghi đè lại những phần mặc định này. Xây dựng render treeCùng với phần thể hiện trực quan trong HTML kết hợp với dữ liệu style từ CSSOM tree là chúng ta đã có đủ nguyên liệu để tạo ra render tree. Bạn sẽ thắc mắc “render tree” là gì? Nó là 1 cây (tree) của các phần tử trực quan được xây dựng theo thứ tự trong đó chúng được hiển thị trên màn hình. Đó là sự thể hiện 1 cách trực quan của HTML cùng với CSS tương ứng. Mục đích của cây này là cho phép tô màu nội dung theo đúng thứ tự. Mỗi node trong render tree được gọi là 1 renderer hoặc render object trong Webkit. Dưới đây là cách mà render tree của DOM &amp; CSSOM ở trên thể hiện: Để xây dựng render tree, trình duyệt về cơ bản sẽ làm những bước sau đây: Bắt đầu từ root của DOM tree, nó sẽ đi qua mỗi node thấy được. Vài node có thể bị ẩn đi (ví dụ như tag script, meta, vân vân) hoặc bỏ qua bởi vì chúng không phản chiếu trong kết quả render đầu ra. Vài node bị ẩn bởi CSS và cũng bị bỏ qua khỏi render tree. Ví dụ như node span trong ví dụ trên thì nó sẽ không có mặt trong render tree vì đã được set style display: none rồi. Với mỗi node thấy được, trình duyệt sẽ tìm các rule CSSOM phù hợp và khớp với nó rồi áp dụng vào. Trình duyệt sẽ xuất ra các node thấy được với nội dung và style tương ứng. Bạn có thể xem qua source code của RenderObject (WebKit) ở đây: https://github.com/WebKit/webkit/blob/fde57e46b1f8d7dde4b2006aaf7ebe5a09a6984b/Source/WebCore/rendering/RenderObject.h Cùng nghía qua một vài dòng cốt lõi trong class này nhé: 1234567891011class RenderObject : public CachedImageClient &#123; // Tô màu lại toàn bộ object. Nó sẽ được gọi khi border color thay đổi hoặc // border style thay đổi. Node* node() const &#123; ... &#125; RenderStyle* style; // the computed style const RenderStyle&amp; style() const; ...&#125; Mỗi renderer thể hiện một khu vực hình chữ nhật tương ứng với CSS box của một node. Nó bao gồm cả thông tin hình học như độ rộng (width), chiều cao (height) hay vị trí (position). Cách bố trí của render treeKhi renderer được tạo ra và thêm vào tree, nó không có thông tin vị trí hay kích thước, phần tính toán các giá trị này được gọi là layout. HTML sử dụng mô hình layout theo dòng (flow-based layout), nghĩa là hầu như toàn bộ thời gian nó có thể tính toán thông số hình học chỉ trong 1 lần duyệt. Hệ thống tọa độ có liên quan đến root renderer. Thông số tọa độ top và left được sử dụng. Layout là 1 quá trình đệ quy, nó bắt đầu ở root renderer, chính là thứ tương ứng với phần tử trong văn bản HTML. Layout tiếp tục duyệt đệ quy qua một hoặc toàn bộ cây cấp bậc(hierarchy) renderer, tính toán các thông tin hình học cần thiết cho mỗi renderer. Vị trí của root renderer là 0,0 và kích thước của nó bằng phần nhìn thấy được của cửa sổ hiển thị trên trình duyệt (còn gọi là viewport). Bắt đầu quá trình tạo layout chính là truyền đạt lại cho mỗi node tọa độ chính xác mà nó cần phải xuất hiện trên màn hình là ở đâu. Tô màu cho render treeTrong giai đoạn này, renderer tree đã được duyệt qua và phương thức paint() của renderer được gọi để hiển thị nội dung lên màn hình. Tô màu có thể theo cách global hoặc incremantal tương tự như layout): Global (toàn cục): toàn bộ tree được lên màu. Incremental (gia tăng): chỉ có một vài renderer thay đổi theo cách không ảnh hưởng đến toàn bộ tree. Renderer vô hiệu hóa khung chữ nhật của chính nó trên màn hình. Điều này làm cho OS (hệ điều thành) hiểu rằng vùng đó cần phải được tô màu lại và sinh ra một paint event. OS thực hiện điều đó một cách thông minh bằng cách gộp nhiều vùng thành một. Về tổng quát thì quan trọng là cần phải hiểu rằng tô màu là quá trình diễn ra từ từ. Để có UX tốt hơn, render engine sẽ cố hiển thị nội dung trên màn hình ngay khi có thể. Nó sẽ không ngồi yên đợi cho tới khi toàn bộ HTML được parse để bắt đầu xây dựng và bố trí render tree. Từng phần của nội dung sẽ được parse và hiển thị lên trong khi tiến trình tiếp tục với những item nội dung tiếp theo đang được truyền về trên mạng. Thứ tự xử lý script và styleCác script được parse và thực thi ngay lập tức khi parser vừa gặp thẻ &lt;script&gt;. Quá trình parse của toàn bộ văn bản sẽ tạm dừng cho đến khi script thực thi xong. Nghĩa là tiến trình này diễn ra đồng bộ. Nếu như script là file ở ngoài thì việc đầu tiên nó cần phải được lấy về từ mạng (bất đồng bộ). Tất cả công việc parse sẽ dừng lại cho đến khi lấy xong file. HTML5 có thêm 1 tùy chọn để đánh dấu script là bất đồng bộ, do đó nó có thể được parse và thực thi trong 1 tiến trình khác. Tối ưu hóa hiệu suất renderNếu bạn muốn tối ưu hóa app thì có 5 điểm chính mà bạn cần tập trung vào dưới đây: Javascript - trong các bài trước chúng ta đã nghiên cứu về chủ đề viết code tối ưu và có hiệu quả bộ nhớ cao mà không làm ảnh hưởng đến UI. Với trường hợp của render, chúng ta cần phải suy nghĩ về cách mà code Javascript sẽ tương tác với các phần tử DOM trên trang. Javascript có thể tạo ra rất nhiều thay đổi với UI, đặc biệt là các app SPA. Tính toán Style - đây là tiến trình xác định CSS rule nào sẽ áp dụng vào phần tử nào dựa trên các selector. Một khi các rule đã được định nghĩa, chúng sẽ được áp dụng và tính toán style cuối cùng cho mỗi phần tử. Layout - khi trình duyệt biết rule nào áp dụng cho phần tử nào, nó có thể bắt đầu tính toán bao nhiêu không gian một phần tử sẽ chiếm dụng và vị trí của nó sẽ nằm ở đâu trên màn hình của trình duyệt. Mô hình layout của trang web xác định một phần tử có thể gây ảnh hưởng đến phần tử khác. Ví dụ, độ rộng của có thể ảnh hưởng độ rộng của phần tử con của nó. Điều này nghĩa là quá trình layout sẽ là quá trình nặng về tính toán số học. Phần “vẽ” được thực hiện trong nhiều layer khác nhau. Tô màu - đây là lúc mà các pixel thực sự được lên màu. Tiến trình bao gồm cả phần vẽ các câu chữ, màu sắc, hình ảnh, viền, đổ bóng, vấn vân, từng phần nhìn thấy được của từng phần tử. Kết hợp (Compositing) - Bởi vì các phần nhỏ của webpage được vẽ vào trong nhiều lớp khác nhau, chúng cần được kết hợp vào một màn hình theo đúng thứ tự để page có thể render một cách chính xác. Điều này rất quan trọng, đặc biệt là với các phần tử chồng nhau. Tối ưu hóa JavaScriptJavascript thường trigger những thay đổi nhìn thấy được trên trình duyệt. Và những tác vụ đó nhân lên nhiều lần khi xây dựng ứng dụng SPA. Dưới đây là 1 số mẹo nhỏ để bạn biết nên tối ưu phần nào của code Javascript nhằm cải thiện render: Tránh sử dụng setTimeout và setInterval đối với những cập nhật nhìn thấy được. Hai hàm này sẽ gọi callback tại 1 thời điểm nào đó trong frame, có thể là cuối frame. Thứ chúng ta cần là trigger thay đổi ngay khi bắt đầu frame để tránh bị sót. Đưa những tính toán Javascript phức tạp và tốn thời gian vào trong Web Workers như chúng ta đã thảo luận ở bài trước. Sử dụng các tác vụ siêu nhỏ (micro-tasks) để thông báo sự thay đổi của DOM với nhiều frame. Dùng trong trường hợp các tác vụ cần truy xuất vào DOM, điều này Web Workers không làm được. Về cơ bản thì nó nghĩa là bạn cần chia nhỏ 1 tác vụ lớn thành nhiều phần nhỏ hơn và chạy chúng bên trong các hàm requestAnimationFrame, setTimeout, setInterval tùy thuộc vào đặc tính của mỗi tác vụ. Tối ưu hóa CSSChỉnh sửa DOM bằng cách thêm bớt các phần tử, thay đổi các thuộc tính… sẽ làm cho trình duyệt phải tính toán lại style của phần tử và trong nhiều trường hợp, là phải tính lại layout của toàn bộ trang hoặc 1 phần của trang. Để tối ưu quá trình render, bạn cần cân nhắc những điều sau: Giảm thiểu sự phức tạp trong các selector. Sự phức tạp của selector có thể chiếm đến hơn 50% thời gian cần thiết để tính toán style cho 1 phần tử (phần còn lại là thời gian để xây dựng style). Giảm số lượng phần tử cần được tính toán style. Về bản chất thì thay đổi style trực tiếp cho 1 vài phần tử thì tốt hơn là vô hiệu toàn bộ page. Tối ưu hóa layoutTính toán lại layout có thể ngốn nhiều tài nguyên của trình duyệt nên bạn cần cân nhắc những điều sau: Giảm số lượng layout bất cứ khi nào có thể. Khi bạn thay đổi style thì trình duyệt kiểm tra để xem thử có thay đổi nào cần layout phải được tính toán lại không. Các thay đổi về property như width, height, left, top và trên hết là những property nào liên quan đến hình học, cần có layout. Vì thế tránh thay đổi chúng hết mức có thể. Dùng flexbox bất cứ khi nào có thể dùng. Nó chạy nhanh hơn và có thể cải thiện hiệu năng một cách đáng kể. Tránh ép buộc layout đồng bộ. Nhớ rằng khi Javascript chạy, tất cả giá trị của layout cũ từ frame trước đó được xác định và sẵn sàng cho bạn truy vấn. Không vấn đề gì nếu như bạn muốn truy xuất box.offsetHeight. Tuy nhiên, nếu bạn thay đổi style của box trước khi nó được truy xuất (ví dụ: cố tình thêm CSS class vào 1 phần tử), trình duyệt đầu tiên sẽ áp dụng thay đổi của style rồi sau đó mới chạy đến phần layout. Điều có có thể gây tốn thời gian và làm ảnh hưởng nặng đến tài nguyên máy tính, vì thế nên tránh càng xa nó càng tốt. Tối ưu hóa tô màuĐây thường là tác vụ chạy lâu nhất trong số các tác vụ nên quan trọng là tránh mặt nó càng xa càng tốt. Những gì bạn có thể làm: Thay đổi bất kỳ property nào khác ngoài transform hay opacity sẽ trigger tác vụ tô màu. Nhớ sử dụng tiết kiệm nhé. Nếu bạn trigger một layout, bạn cũng sẽ trigger luôn tác vụ tô màu bởi vì thay đổi về kích thước hình học cũng sẽ thay đổi phần nhìn thấy được của phần tử. Giảm diện tích tô màu thông qua thăng cấp layer và dàn dựng các animation. Render là một khía cạnh quan trọng trong cách thức hoạt động của SessionStack. SessionStack phải tái tạo lại một video về mọi thứ đã diễn ra với user tại thời điểm họ trải nghiệm qua một vấn đề khi đang lướt webapp của bạn. Để làm được điều này, SessionStack chỉ xử lý duy nhất những dữ liệu mà thư viện của nó thu thập được: các sự kiện từ user, thay đổi trên DOM, request lên mạng, biệt lệ, thông báo debug, vân vân. Trình phát video được tối ưu hóa tối đa để có thể render một cách chính xác và sử dụng toàn bộ những dữ liệu thu thập được để có thể đưa ra một bản giả lập trình duyệt của user hoàn-hảo-đến-từng-pixel cũng như những gì đã xảy ra trên đó, cả về mặt kỹ thuật lẫn quan sát.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P10: Quan sát thay đổi trên DOM bằng MutationObserver","slug":"Cach-Javascript-hoat-dong-P10-Quan-sat-thay-doi-tren-DOM-bang-MutationObserver","date":"2018-11-25T08:24:00.000Z","updated":"2018-11-25T08:29:18.823Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P10-Quan-sat-thay-doi-tren-DOM-bang-MutationObserver.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P10-Quan-sat-thay-doi-tren-DOM-bang-MutationObserver.html","excerpt":"Chào các bạn đến với bài thứ 10 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Webapp càng ngày càng nặng hơn ở phía client bởi vì nhiều lý do đại loại như UI phải “phì nhiêu” để chứa đựng những thứ logic phức tạp bên trong bao gồm cả tính toán theo thời gian thực (real-time), và nhiều nhiều thứ khác nữa. Sự phức tạp gia tăng làm cho chúng ta khó nắm bắt chính xác trạng thái của UI tại mỗi thời điểm trong vòng đời của webapp. Điều này càng khó hơn nữa nếu chúng ta xây dựng một vài thứ chẳng hạn như library hay framework mà cần phải phản ứng cũng như xử lý những hành động dựa trên DOM.","text":"Chào các bạn đến với bài thứ 10 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Webapp càng ngày càng nặng hơn ở phía client bởi vì nhiều lý do đại loại như UI phải “phì nhiêu” để chứa đựng những thứ logic phức tạp bên trong bao gồm cả tính toán theo thời gian thực (real-time), và nhiều nhiều thứ khác nữa. Sự phức tạp gia tăng làm cho chúng ta khó nắm bắt chính xác trạng thái của UI tại mỗi thời điểm trong vòng đời của webapp. Điều này càng khó hơn nữa nếu chúng ta xây dựng một vài thứ chẳng hạn như library hay framework mà cần phải phản ứng cũng như xử lý những hành động dựa trên DOM. Khái quátMutationObserver (tạm dịch: Người quan sát sự biến đổi) là một WebAPI được các trình duyệt hiện đại cung cấp để phát hiện các thay đổi trên DOM. Với API này một người có thể listen các node mới được thêm vào hoặc gỡ ra, thuộc tính thay đổi hoặc những thay đổi về nội dung văn bản trong một text node. Tại sao phải cần làm thế? Có một số ít trường hợp trong đó MutationObserver API thực sự hữu ích. Ví dụ: Bạn muốn thông báo cho người dùng webapp rằng một vài sự thay đổi đã xảy ra trên trang mà người đó đang sử dụng. Bạn đang làm việc với 1 Javascript framework sang chảnh mới, nó cần load rất nhiều JS module một cách tự động dựa trên sự thay đổi của DOM. Bạn đang làm việc với bộ soạn thảo WYSIWYG và thử triển khai tính năng undo/redo. Bằng cách tận dụng MutationObserver API, bất kỳ lúc nào bạn cũng có thể biết phần nào đã thay đổi và dễ dàng undo chúng. Trên đây chỉ là 1 số ví dụ về lợi ích của MutationObserver. Cách sử dụng MutationObserverTriển khai MutationObserver khá dễ dàng. Bạn cần tạo 1 instance MutationObserver bằng cách truyền cho nó 1 hàm và hàm này được gọi mỗi khi 1 sự thay đổi xảy ra. Đối số đầu tiên của hàm là 1 tập hợp tất cả các sự thay đổi xảy ra trên 1 khối duy nhất. Mỗi sự thay đổi cung cấp thông tin về loại của nó cũng như thay đổi nào đã xảy ra. 12345var mutationObserver = new MutationObserver(function(mutations) &#123; mutations.forEach(function(mutation) &#123; console.log(mutation); &#125;);&#125;); Object tạo ra có 3 phương thức: observe: bắt đầu lắng nghe sự thay đổi. Nó nhận 2 đối số: DOM node mà bạn muốn quan sát và một object chưa các thiết lập. disconnect: dừng quá trình lắng nghe thay đổi. takeRecords: trả về khối thay đổi cuối cùng trước khi callback được kích hoạt. Đoạn code sau thể hiện quá trình quan sát (observing) diễn ra: 123456789// Bắt đầu lắng nghe thay đổi trong root HTML của trang.mutationObserver.observe(document.documentElement, &#123; attributes: true, characterData: true, childList: true, subtree: true, attributeOldValue: true, characterDataOldValue: true&#125;); Giờ giả sử ta có 1 div cực kỳ đơn giản trong DOM: 1&lt;div id=\"sample-div\" class=\"test\"&gt; Simple div &lt;/div&gt; Sử dụng jQuery, bạn có thể xóa thuộc tính class từ div đó: 1$(\"#sample-div\").removeAttr(\"class\"); Khi đã bắt đầu quan sát, sau khi gọi hàm mutationObserver.observe(…) ta có thể xem thông tin log được in ra trong console của MutationRecord. Đây là sự biến đổi tạo ra bởi ta đã xóa thuộc tính class. Cuối cùng, để dừng sự quan sát DOM sau khi đã xong việc, ta làm như sau: 12// Dừng MutationObserver, không lắng nghe thay đổi nữa.mutationObserver.disconnect(); Ngày nay MutationObserver được hỗ trợ khá tốt: Giải pháp thay thếTuy nhiên, MutationObserver cũng chỉ mới xuất hiện chưa lâu. Vậy thì trước khi có nó, các developer dùng cái gì? Dưới đây là 1 vài lựa chọn: Polling MutationEvents CSS animations PollingGiải pháp đơn giản nhất và kém tinh tế nhất là polling (bỏ phiếu bình chọn). Sử dụng WebAPI setInterval bạn có thể thiết lập 1 tác vụ kiểm tra sự thay đổi theo chu kỳ nhất định. Dĩ nhiên thì cách này làm giảm hiệu năng của webapp 1 cách đáng sợ. MutationEventsMutationEvents API được giới thiệu vào năm 2000. Mặc dù nó có ích, các sự kiện thay đổi (mutation events) được bắn ra mỗi khi có 1 sự thay đổi bất kỳ trên DOM và một lần nữa làm ảnh hưởng đến hiệu năng. Ngày nay thì MutationEvents API đã bị hủy bỏ và những trình duyệt hiện đại sẽ sớm ngừng hỗ trợ nó. Danh mục trình duyệt hỗ trợ cho MutationEvents: CSS animationsMột giải pháp thay thế hơi kỳ cục đó là dựa trên CSS Animations. Nghe có vẻ bối rối nhỉ. Về cơ bản thì ý tưởng của nó là tạo ra 1 animation có thể được trigger khi có một element được thêm vào DOM. Khoảnh khắc animation bắt đầu, sự kiện animationstart sẽ được bắn ra: nếu bạn đã gắn 1 event handler vào sự kiện đó thì bạn sẽ biết 1 cách chính xác khi nào element được thêm vào DOM. Thời gian thực hiện của animation phải cực nhỏ để cho nó dường như vô hình trước con mắt user. Đầu tiên ta cần một element cha, bên trong nó ta sẽ listen sự kiện chèn node: 1&lt;div id=”container-element”&gt;&lt;/div&gt; Để có thể xử lý khi có node chèn vào, ta cần thiết lập một chuỗi các keyframe animation khởi động khi node được thêm vào: 1234@keyframes nodeInserted &#123; from &#123; opacity: 0.99; &#125; to &#123; opacity: 1; &#125; &#125; Với keyframe được tạo ra đó, animation cần phải được áp dụng vào các element mà ta muốn lắng nghe. Lưu ý là thời gian duration rất nhỏ, mục đích là để kéo dãn dấu vết của animation trên trình duyệt: 1234#container-element * &#123; animation-duration: 0.001s; animation-name: nodeInserted;&#125; Bước thiết lập này sẽ thêm animation vào tất cả các node con của container-element. Khi animation kết thúc (sau 0.001s như trên), sự kiện chèn node sẽ được bắn ra. Ta cần một hàm event listener Javascript. Trong hàm đó ta phải gọi event.animationName để đảm bảo đó chính là animation mà ta cần. 123456var insertionListener = function(event) &#123; // Đảm bảo đây là animation mà ta cần xử lý. if (event.animationName === \"nodeInserted\") &#123; console.log(\"Node has been inserted: \" + event.target); &#125;&#125; Giờ thì thêm event listener vào node cha: 123document.addEventListener(“animationstart”, insertionListener, false); // standard + firefoxdocument.addEventListener(“MSAnimationStart”, insertionListener, false); // IEdocument.addEventListener(“webkitAnimationStart”, insertionListener, false); // Chrome + Safari Trình duyệt hỗ trợ CSS animation: MutationObserver cung cấp một số tính năng nâng cao hơn tất cả 3 giải pháp trên. Về bản chất, nó bao phủ toàn bộ mỗi thay đổi có thể diễn ra trên DOM và nó được tối ưu hóa khi bắn ra các thay đổi trong 1 chuỗi hàng loạt. Trên hết MutationObserver được hỗ trợ bởi tất cả các trình duyệt hiện đại đi kèm với 1 số polyfills để dùng MutationEvents MutationObserver chiếm giữ một vị trí trung tâm trong thư viện của SessionStack. Khi bạn đã tích hợp thư viện của SessionStack vào webapp, nó bắt đầu thu thập các thông tin chẳng hạn như thay đổi trên DOM, request mạng, biệt lệ, thông báo debug, vân vân, và gửi chúng về server. SessionStack dùng chính những dữ liệu này để tái tạo lại mọi thứ đã xảy ra với user của bạn và hiển thị các vấn đề của sản phẩm trong cùng 1 tình huống mà nó diễn ra với user. Khá nhiều người nghĩ rằng SessionStack ghi lại video, nhưng không phải vậy. Ghi video rất tốn kém, mặt khác lượng dữ liệu thu thập được lại rất nhẹ và không ảnh hưởng đến UX cũng như hiệu năng của webapp của bạn.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P9: Cấu tạo của Web Push Notifications","slug":"Cach-Javascript-hoat-dong-P9-Cau-tao-cua-Web-Push-Notifications","date":"2018-11-24T15:51:00.000Z","updated":"2018-11-24T15:53:39.773Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P9-Cau-tao-cua-Web-Push-Notifications.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P9-Cau-tao-cua-Web-Push-Notifications.html","excerpt":"Chào các bạn đến với bài thứ 9 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Hôm nay chúng ta sẽ chuyển hướng sự chú ý qua web push notifications (tạm dịch: thông báo đẩy trên trang web): chúng ta sẽ tìm hiểu về thành phần của nó, khám phá các quy trình gửi/nhận thông báo phía sau và cuối bài sẽ cùng tìm hiểu làm sao SessionStack sử dụng chúng để xây dựng chức năng của sản phẩm. Push Notifications rất phổ biến trong thế giới của điện thoại. Vì lý do này hay lý do khác, chúng bước chân vào thế giới web lại khá muộn mặc dù nó là tính năng rất được các developer ưa chuộng và đề xuất.","text":"Chào các bạn đến với bài thứ 9 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Hôm nay chúng ta sẽ chuyển hướng sự chú ý qua web push notifications (tạm dịch: thông báo đẩy trên trang web): chúng ta sẽ tìm hiểu về thành phần của nó, khám phá các quy trình gửi/nhận thông báo phía sau và cuối bài sẽ cùng tìm hiểu làm sao SessionStack sử dụng chúng để xây dựng chức năng của sản phẩm. Push Notifications rất phổ biến trong thế giới của điện thoại. Vì lý do này hay lý do khác, chúng bước chân vào thế giới web lại khá muộn mặc dù nó là tính năng rất được các developer ưa chuộng và đề xuất. Khái quátWeb Push Notifications cho phép user tham gia vào các cập nhật theo thời gian từ webapp nhằm mục đích thu hút người dùng dựa trên nội dung thú vị, quan trọng và đúng lúc đối với họ. Push dựa trên Service Workers - chính là chủ đề mà chúng ta đã thảo luận ở bài trước. Lý do lựa chọn dùng Service Workers trong trường hợp này là vì chúng hoạt động trong background. Rất phù hợp cho Push Notifications vì như vậy nghĩa là code chỉ được thực thi khi user tương tác với chính notification đó. Push &amp; notificationPush và notification là 2 API khác nhau. Push: được gọi khi server cung cấp thông tin cho Server Worker Notification: hành động của Service Worker hoặc một đoạn script trên webapp nhằm hiển thị thông tin đến user. PushCó 3 bước cơ bản để triển khai 1 push: Giao diện (UI): thêm vào những logic cần thiết ở phía client để đăng ký user với push. Đây là phần logic Javascript mà UI của webapp cần để cho phép user đăng ký vào push message. Gửi push message: triển khai lời gọi API trên server để trigger một push message tới thiết bị của user. Nhận push message: xử lý push message một khi nó về tới trình duyệt. Giờ thì chúng ta sẽ tìm hiểu toàn bộ quá trình một cách chi tiết hơn. Xác nhận hỗ trợ từ trình duyệtĐầu tiên là cần phải kiểm tra xem trình duyệt bạn đang dùng có hỗ trợ cho push message hay không. Chúng ta có 2 bài check đơn giản: Kiểm tra serviceWorker trong object navigator Kiểm tra PushManager trong object window Code kiểm tra: 123456789if (!('serviceWorker' in navigator)) &#123; // Service Worker không được hỗ trợ, vô hiệu hóa hoặc ẩn UI đi. return; &#125;if (!('PushManager' in window)) &#123; // Push không được hỗ trợ, vô hiệu hóa hoặc ẩn UI đi. return; &#125; Đăng ký một Service WorkerTại thời điểm này, ta đã biết các chức năng đều được hỗ trợ. Bước tiếp theo sẽ là đăng ký Service Worker. Đăng ký một Service Worker như thế nào thì bạn cũng đã quen với những diễn giải từ bài trước rồi. Yêu cầu được cấp quyềnXong phần với Service Worker thì ta có thể đi tiếp đến phần đăng ký user. Bạn cần phải có quyền của user thì mới gửi push message đến họ được. API dùng để lấy quyền (permission) cũng tương đổi đơn giản, tuy nhiên điểm bất lợi là API đã thay đổi từ việc dùng callback sang trả về Promise. Nó sinh ra vấn đề khác: chúng ta không thể biết version của API đã được triển khai trên trình duyệt hiện tại, vì thế chúng ta phải xử lý cả 2 trường hợp. Nó trông như thế này đây: 1234567891011121314151617function requestPermission() &#123; return new Promise(function(resolve, reject) &#123; const permissionResult = Notification.requestPermission(function(result) &#123; // Xử lý phiên bản cũ với callback. resolve(result); &#125;); if (permissionResult) &#123; permissionResult.then(resolve, reject); &#125; &#125;) .then(function(permissionResult) &#123; if (permissionResult !== 'granted') &#123; throw new Error('Permission not granted.'); &#125; &#125;);&#125; Lời gọi đến Notification.requestPermission() sẽ hiển thị 1 bảng thông báo nhỏ: Một khi quyền đã được cấp, được đóng hoặc block thì chúng ta cũng nhận được những kết quả tương tự dưới dạng string: granted, default, denied. Nhớ rằng nếu user click chuột vào nút Block thì webapp của bạn sẽ không thể hỏi user về chuyện cấp quyền một lần nữa, cho tới khi user tự “unblock” app của bạn bằng cách thay đổi trạng thái của quyền. Tùy chọn này được giấu trong bảng cài đặt. Đăng ký một user với PushManagerKhi Service Worker đã được đăng ký và chúng ta được user cấp quyền, ta có thể subscribe 1 user bằng cách gọi registration.pushManager.subscribe() khi đăng ký Service Worker của bạn. Toàn bộ đoạn code như sau (bao gồm cả phần đăng ký Service Worker): 1234567891011121314151617function subscribeUserToPush() &#123; return navigator.serviceWorker.register('service-worker.js') .then(function(registration) &#123; var subscribeOptions = &#123; userVisibleOnly: true, applicationServerKey: btoa( 'BEl62iUYgUivxIkv69yViEuiBIa-Ib9-SkvMeAtA3LFgDzkrxZJjSgSnfckjBJuBkr3qBUYIHBQFLXYp5Nksh8U' ) &#125;; return registration.pushManager.subscribe(subscribeOptions); &#125;) .then(function(pushSubscription) &#123; console.log('PushSubscription: ', JSON.stringify(pushSubscription)); return pushSubscription; &#125;);&#125; registration.pushManager.subscribe(options) nhận một object options gồm 1 param bắt buộc và 1 param tùy chọn: userVisibleOnly: một boolean chỉ định push subscription trả về sẽ chỉ được dùng cho message mà hiệu ứng của message đó user có thể nhìn thấy được. Nó phải được gán bằng true nếu không thì sẽ lỗi (Có cả 1 quá khứ lịch sử về nó). applicationServerKey: một DOMString hoặc ArrayBufffer chứa public key được mã hóa thành Base64 mà server push sẽ dùng để xác thực server của app. Server của bạn cần sinh ra một cặp server key cho app, chúng còn được biết đến là key VAPID duy nhất cho server. Đây là 1 cặp public-private key. Private key thì được giữ một cách bí mật ở phía bạn trong khi public key được trao đổi với client. Những key này cho phép push service biết app server nào đã đăng ký user và đảm bảo đó chính là server trigger các push message đến người dùng cụ thể. Bạn chỉ cần tạo ra cặp private/public key 1 lần duy nhất cho ứng dụng. Có 1 cách làm nhanh đó là dùng trang này https://web-push-codelab.glitch.me/ Trình duyệt truyền applicationServerKey (public key) lên một push server khi đăng ký user, nghĩa là push server có thể liên kết public key của app bạn với PushSubscription của user. Đây là những gì diễn ra: Webapp của bạn được load xong và bạn gọi subscribe(), truyền server key vào. Trình duyệt tạo 1 request lên mạng đến một push service để sinh ra một endpoint, sau đó liên kết endpoint này với key và trả về cho trình duyệt. Trình duyệt sẽ thêm endpoint này vào trong object PushSubscription, chính là object được trả về từ subscribe() promise. Về sau, cứ mỗi khi bạn muốn gửi 1 push message, bạn chỉ cần tạo một Authorization header có chưa thông tin đã ký (signed) với private key từ server ứng dụng của bạn. Khi push service nhận request để gửi một push message, nó sẽ xác minh header bằng cách tìm public key đã liên kết với endpoint cụ thể đó (ở bước thứ 2) Object PushSubscriptionMột PushSubscription chứa những thông tin cần thiết để gửi push message đến thiết bị của user: 12345678&#123; \"endpoint\": \"https://domain.pushservice.com/some-id\", \"keys\": &#123; \"p256dh\":\"BIPUL12DLfytvTajnryr3PJdAgXS3HGMlLqndGcJGabyhHheJYlNGCeXl1dn18gSJ1WArAPIxr4gK0_dQds4yiI=\", \"auth\":\"FPssMOQPmLmXWmdSTdbKVw==\" &#125;&#125; endpoint ở đây là URL của push service. Để trigger một push mesage ta cần tạo request POST đến URL này.Object keys chứa giá trị dùng để mã hóa dữ liệu thông tin được gửi đi với push message.Một khi user đã được đăng ký và bạn có PushSubscription thì bạn cần gửi nó về cho server. Tại đây (trên server) bạn sẽ lưu thông tin tham gia của user vào database và kể từ bây giờ sẽ dùng nó để gửi push message về cho user đó. Gửi push messageKhi bạn cần gửi một push message cho nhiều user, điều đầu tiên bạn cần là push service. Bạn đang chỉ bảo cho push service (thông qua API) dữ liệu để gửi, gửi đến ai và các tình huống về việc làm thế nào để gửi message. Thông thường, lời gọi API này sẽ được thực hiện trên server. Push ServicesPush service là thứ dùng để nhận các request, xác nhận chúng và chuyển giao push message cho trình duyệt phù hợp. Lưu ý rằng bạn không quản lý push service, nó là 1 dịch vụ của bên thứ 3. Server của bạn giao tiếp với push service thông qua API. Một ví dụ về push service chính là Google’s FCM Push service xử lý tất cả những việc nặng nhọc. Ví dụ: Nếu như trình duyệt đang offline, push service sẽ xếp message vào hàng đợi và chờ cho đến khi trình duyệt online lại trước khi gửi message đi 1 cách tuần tự. Mỗi tình duyệt có thể dùng bất kỳ push service nào và điều này vượt ngoài khả năng kiểm soát của developer. Tuy nhiên tất cả các push service có chung API nên việc này không làm cho quá trình triển khai trở nên khó khăn. Để lấy được URL xử lý các request cho push message, bạn cần phải kiểm tra giá trị của endpoint trong object PushSubscription. Push Service APIPush Service API cung cấp 1 cách để gửi message đến cho user. API là 1 Web Push Protocol theo tiêu chuẩn IETF định nghĩa cách ta gọi API đến một push service Dữ liệu bạn gửi với push message phải được mã hóa. Bằng cách này, bạn ngăn chặn push service đọc dữ liệu gửi đi. Điều này rất quan trọng vì trình duyệt chính là người quyết định nên dùng push service nào (có thể đó là push service không đáng tin cậy và bảo mật kém) Với mỗi push message, bạn có thể đưa ra hướng dẫn như sau: TTL: định nghĩa một message nên chờ bao lâu trong hàng đợi trước khi nó bị gỡ ra và không được chuyển đi. Mức độ ưu tiên (priority): định nghĩa mức độ ưu tiên của mỗi message, cách này giúp cho push service chỉ gửi những thông tin có mức độ ưu tiên cao, ví dụ trong trường hợp pin thiết bị của người dùng sắp cạn. Chủ đề (topic): cung cấp cho push message một tên chủ đề sẽ thay thế message đang chờ xử lý (pending) có cùng chủ đề để khi thiết bị đang hoạt động, user sẽ không nhận thông tin cũ, lỗi thời. Sự kiện Push trên trình duyệtMột khi bạn gửi message đến push service như giải thích ở trên, message sẽ chuyển sang trạng thái chờ (pending) cho đến khi 1 trong số những điều sau đây xảy ra: Thiết bị online Message hết hạn trên hàng đợi do TTL. Khi push service truyền một message, trình duyệt sẽ nhận nó, giải mã và điều phối một sự kiện push trong Service Worker của bạn. Điều tuyệt vời là trình duyệt thực thi code Service Worker của bạn thậm chí cả khi web page chưa mở lên: Push message được gửi tới trình duyệt và được giải mã. Trình duyệt đánh thức Service Worker Một sự kiện push được phân phối đến Service Worker Code để cài đặt một listener cho push even cũng khá tương đồng với các loại event listener khác trong Javascript: 1234567self.addEventListener('push', function(event) &#123; if (event.data) &#123; console.log('This push event has data: ', event.data.text()); &#125; else &#123; console.log('This push event has no data.'); &#125;&#125;); Một điều cần phải hiểu về Service Worker là bạn có ít quyền kiểm soát về thời gian chạy của code Service Worker. Trình duyệt quyết định khi nào thì đánh thức nó dậy và khi nào thì hủy nó. Trong Service Worker, event.waitUntil(promise) cho trình duyệt biết công việc vẫn đang thực hiện cho tới khi promise được giải quyết xong và trình duyệt sẽ không hủy service worker nếu nó cần quá trình đó hoàn thành. Dưới đây là 1 ví dụ về xử lý sự kiện push: 12345self.addEventListener('push', function(event) &#123; var promise = self.registration.showNotification('Push notification!'); event.waitUntil(promise);&#125;); Gọi self.registration.showNotification() hiển thị một thông báo đến user và nó trả về promise, promise này được resolve khi thông báo đã được hiển thị lên. Phương thức showNotification(title, options) có thể được chỉnh sửa để phù hợp với nhu cầu. Param title là 1 string, còn options là object như dưới đây: 1234567891011121314151617181920212223&#123; \"//\": \"Visual Options\", \"body\": \"&lt;String&gt;\", \"icon\": \"&lt;URL String&gt;\", \"image\": \"&lt;URL String&gt;\", \"badge\": \"&lt;URL String&gt;\", \"vibrate\": \"&lt;Array of Integers&gt;\", \"sound\": \"&lt;URL String&gt;\", \"dir\": \"&lt;String of 'auto' | 'ltr' | 'rtl'&gt;\", \"//\": \"Behavioural Options\", \"tag\": \"&lt;String&gt;\", \"data\": \"&lt;Anything&gt;\", \"requireInteraction\": \"&lt;boolean&gt;\", \"renotify\": \"&lt;Boolean&gt;\", \"silent\": \"&lt;Boolean&gt;\", \"//\": \"Both Visual &amp; Behavioural Options\", \"actions\": \"&lt;Array of Strings&gt;\", \"//\": \"Information Option. No visual affect.\", \"timestamp\": \"&lt;Long&gt;\"&#125; Bạn có thể tìm hiểu chi tiết về mỗi options ở đây: https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification Push Notification là một cách tuyệt vời để thu thập sự chú ý của user những khi có thông tin gấp, quan trọng hoặc cần thời điểm nhạy cảm mà bạn muốn chia sẻ với họ. Team SessionStack thực hiện push notifications để báo cho user biết khi có crash, vấn đề hoặc điều gì đó bất thường trong sản phẩm của họ. Việc này giúp cho user biết ngay lập tức nếu có gì không đúng đang xảy ra. Sau đó họ có thể replay lại issue đó dưới dạng video và xem mọi thứ diễn ra với người dùng cuối của họ bằng cách tận dụng dữ liệu được thu thập với thư viện của SessionStack, chẳng hạn như thay đổi trên DOM, tương tác người dùng, request mạng, biệt lệ không được xử lý và các thông báo lỗi. Tính năng này không chỉ sẽ giúp user sử dụng SessionStack hiểu và tái hiện lại bất kỳ vấn đề nào mà nó còn cho phép họ nhận được thông báo ngay khi nó xuất hiện.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P8: Service Workers, vòng đời và các trường hợp sử dụng","slug":"Cach-Javascript-hoat-dong-P8-Service-Workers-vong-doi-va-cac-truong-hop-su-dung","date":"2018-11-24T15:04:00.000Z","updated":"2018-11-24T15:16:23.564Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P8-Service-Workers-vong-doi-va-cac-truong-hop-su-dung.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P8-Service-Workers-vong-doi-va-cac-truong-hop-su-dung.html","excerpt":"Bạn có lẽ đã biết rằng Progressive Web Apps chỉ có thể phổ biến hơn khi chúng hướng tới trải nghiệm người dùng (UX) mượt mà hơn, giống như là tạo 1 native app hơn là một trải nghiệm mang phong cách trình duyệt. Một trong số những yêu cầu khi xây dựng PWA là làm nó cực kỳ đáng tin cậy ở khoản loading: nó có thể chạy kể cả trong tình trạng internet không ổn định hoặc rớt mạng. Trong bài này, chúng ta sẽ đào sâu vào Service Workers: cách chúng hoạt động và chúng ta nên quan tâm đến đâu. Cuối bài, team tác giả có một số lợi ích độc đáo của Service Workers mà chúng ta nên dùng đồng thời chia sẻ kinh nghiệm của họ tại SessionStack.","text":"Bạn có lẽ đã biết rằng Progressive Web Apps chỉ có thể phổ biến hơn khi chúng hướng tới trải nghiệm người dùng (UX) mượt mà hơn, giống như là tạo 1 native app hơn là một trải nghiệm mang phong cách trình duyệt. Một trong số những yêu cầu khi xây dựng PWA là làm nó cực kỳ đáng tin cậy ở khoản loading: nó có thể chạy kể cả trong tình trạng internet không ổn định hoặc rớt mạng. Trong bài này, chúng ta sẽ đào sâu vào Service Workers: cách chúng hoạt động và chúng ta nên quan tâm đến đâu. Cuối bài, team tác giả có một số lợi ích độc đáo của Service Workers mà chúng ta nên dùng đồng thời chia sẻ kinh nghiệm của họ tại SessionStack. Khái quátNếu bạn muốn hiểu rõ mọi thứ về Service Workers, bạn cần phải bắt đầu với bài viết trước về Web Workers. Về cơ bản, Service Worker chỉ là 1 loại của Web Worker và cụ thể hơn là nó giống như 1 Shared Worker: Service Worker chạy trong global context của chính nó Nó không thể gắn kết với 1 trang cụ thể Không thể truy cập vào DOM Một trong những lý do tại sao Service Worker API rất tuyệt vời là chúng cho phép webapp hỗ trợ trải nghiệm khi offline, cho phép developer hoàn toàn điều khiển luồng sử dụng. Vòng đời của Service WorkerVòng đời của một service worker là hoàn toàn tách biệt với web page. Nó bao gồm các giai đoạn sau: Tải về (Download) Cài đặt (Installation) Kích hoạt (Activation) DownloadĐây là khi trình duyệt tải file .js chứa Service Worker Cài đặtĐể cài đặt một Service Worker cho webapp của bạn thì bạn cần phải đăng ký nó trước trong code Javascript. Khi Service Worker đã đăng ký xong, nó sẽ nhắc nhở tình duyệt khởi động một bước cài đặt chạy nền Service Worker. Bằng cách đăng ký Service Worker, bạn đã thông báo cho trình duyệt file Javascript của worker nằm ở đâu. Cùng xem ví dụ bên dưới: 1234567891011if ('serviceWorker' in navigator) &#123; window.addEventListener('load', function() &#123; navigator.serviceWorker.register('/sw.js').then(function(registration) &#123; // Đăng ký thành công console.log('ServiceWorker registration successful'); &#125;, function(err) &#123; // Đăng ký thất bại console.log('ServiceWorker registration failed: ', err); &#125;); &#125;);&#125; Code sẽ kiểm tra nếu môi trường hiện tại có support Service Worker hay không. Nếu như có thì file /sw.js sẽ được đăng ký. Bạn có thể gọi phương thức register() mỗi khi một trang load lên mà không phải lo lắng gì, trình duyệt sẽ sẽ tự kiểm tra nếu service worker đã được đăng ký hay chưa và tự xử lý một cách phù hợp. Một điểm quan trọng ở phương thức register() là vị trí của file service worker. Trong trường hợp này bạn có thể thấy rằng file service worker đang ở root của domain. Nghĩa là phạm vi (scope) của service worker sẽ bao hàm toàn bộ origin. Nói cách khác, service worker này sẽ nhận các sự kiện fetch (mà chúng ta sẽ thảo luận sau) cho mọi thứ trên domain này. Nếu ta đăng ký file service worker ở /example/sw.js thì service worker chỉ có thể thấy các sự kiện fetch cho trang có URL bắt đầu với /example/ (ví dụ: /example/page/1, /example/page/2) Trong giai đoạn cài đặt, tốt nhất ta nên load và cache những tài nguyên dạng tĩnh (static asset). Một khi các tài nguyên đã được cache thành công thì quá trình cài đặt Service Worker cũng hoàn thành. Nếu không (load fail), Service Worker sẽ thử lại (retry). Một khi đã thành công, bạn sẽ biết các static asset đang nằm trong cache. Bạn sẽ tự hỏi nếu như quá tình đăng ký diễn ra sau sự kiện load thì được không. Điều này không bắt buộc, nhưng đó là cách tốt nhất và được đề nghị làm theo. Tại sao? Giả sử một user lần đầu tiên ghé thăm webapp của bạn. Không có service worker nào cả và trình duyệt không có cách nào để biết trước có hay không một service worker cần được cài đặt. Nếu như Service Worker đã được cài đặt, trình duyệt sẽ dành ra 1 lượng CPU và bộ nhớ cho tiến trình đó, ngược lại thì trình duyệt sẽ dành toàn bộ cho quá trình render web page. Điểm mấu chốt là nếu bạn chỉ cài đặt Service Worker trên trang của bạn thì bạn đang mạo hiểm về độ delay của quá trình loading &amp; render chứ không phải đang làm cho trang có thể sẵn sàng cho người dùng một cách nhanh nhất có thể. Lưu ý rằng điều này chỉ quan trọng cho lần đầu tiên ghé thăm trang. Những lần ghé thăm sau thì không bị ảnh hưởng với quá trình cài đặt Service Worker. Một khi Service Worker đã được kích hoạt trong lần đầu ghé thăm trang, nó có thể xử lý các sự kiện loading/caching cho những lần ghé thăm kế tiếp. Điều này rất có ý nghĩa bởi vì nó cần phải sẵn sàng để xử lý trường hợp kết nối mạng bị hạn chế. Kích hoạtSau khi Service Worker cài đặt, bước tiếp theo là kích hoạt nó. Bước này là cơ hội tuyệt vời để quản lý cache trước đó. Một khi đã kích hoạt, Service Worker sẽ bắt đầu kiểm soát toàn trang nằm trong phạm vi của nó. Một sự thật rất thú vị: page nào đăng ký Service Worker lần đầu tiên sẽ không bị điều khiển cho đến khi nó load lại. Một khi Service Worker kiểm soát, nó sẽ có những trạng thái sau: Nó sẽ xử lý các sự kiện fetch &amp; message diễn ra khi một request mạng hoặc message được tạo ra từ page. Nó sẽ bị hủy bỏ để giải phóng bộ nhớ. Dưới đây là vòng đời của nó: Xử lý quá trình cài đặt bên trong Service WorkerSau khi page xoay vòng quá trình đăng ký, ta cùng tìm hiểu điều gì diễn ra bên trong script của Service Worker, code này xử lý sự kiện cài đặt bằng cách thêm một event listener vào instance của Service Worker. Đây là những bước cần thiết khi xử lý sự kiện cài đặt Mở cache Cache các file Xác nhận tất cả các asset cần thiết đều đã được cache. Dưới đây là quá trình cài đặt đơn giản bên trong Service Worker: 12345678910111213141516171819var CACHE_NAME = 'my-web-app-cache';var urlsToCache = [ '/', '/styles/main.css', '/scripts/app.js', '/scripts/lib.js'];self.addEventListener('install', function(event) &#123; // event.waitUntil nhận một promise để biết quá trình // cài đặt mất bao lâu và có thành công hay không. event.waitUntil( caches.open(CACHE_NAME) .then(function(cache) &#123; console.log('Opened cache'); return cache.addAll(urlsToCache); &#125;) );&#125;); Nếu tất cả các file đều đã được lưu cache thành công thì service worker sẽ được cài đặt. Nếu một file nào đó không download được thì bước cài đặt sẽ bị fail. Vì thế hãy cẩn thận với những file bạn truyền vào. Xử lý sự kiện cài đặt hoàn toàn không bắt buộc và bạn có thể bỏ qua, trong trường hợp đó bạn không cần phải thực hiện thêm bước nào nữa. Cache request trong quá trình thực thi (runtime)Phần này thực sự thú vị một cách xuất sắc. Đây là nơi bạn sẽ biết làm thế nào để can thiệp request và trả về cache đã được tạo (và tạo mới). Sau khi Service Worker cài đặt xong và user điều hướng đến page khác hoặc refresh lại page hiện tại, Service Worker sẽ nhận được sự kiện fetch. Đây là một ví dụ thể hiện làm thế nào để trả về những asset đã cache hoặc thực hiện một request mới và cache kết quả: 1234567891011121314151617181920212223242526272829303132333435363738394041424344self.addEventListener('fetch', function(event) &#123; event.respondWith( // Phương thức này xem xét request và tìm xem có // kết quả nào đã được cache từ tất cả các cache // mà Service Worker đã tạo. caches.match(event.request) .then(function(response) &#123; // Nếu tìm thấy cache thì trả về response. if (response) &#123; return response; &#125; // Nhân bản request. Một request là 1 stream và chỉ có thể sử dụng 1 lần. // Bởi vì chúng ta đang xài 1 cái cho cache và 1 cái cho trình duyệt để fetch, // nến ta cần phải nhân bản request. var fetchRequest = event.request.clone(); // Cache không tìm thấy nên ta cần thực hiện fetch // để tạo request tới mạng và trả về dữ liệu nếu tìm thấy // thứ gì đó. return fetch(fetchRequest).then( function(response) &#123; // Kiểm tra nếu ta nhận được response hợp lệ. if(!response || response.status !== 200 || response.type !== 'basic') &#123; return response; &#125; // Nhân bản response bởi vì nó cũng không phải là 1 stream. // Bởi vì chúng ta muốn trình duyệt sử dụng response cũng như // cache sử dụng response, ta cần nhân bản nó thành 2 stream. var responseToCache = response.clone(); caches.open(CACHE_NAME) .then(function(cache) &#123; // Thêm request vào cache phục vụ sau này cache.put(event.request, responseToCache); &#125;); return response; &#125; ); &#125;) );&#125;); Tóm gọn lại thì đây là những điều đã diễn ra: event.respondWith() sẽ xác định làm thế nào chúng ta phản hồi với sự kiện fetch. Ta truyền một promise từ caches.match(), hàm đang kiểm tra request và tìm kiếm nếu có bất kỳ kết quả đã được cache sẵn nào từ những cache đã được tạo trước đó. Nếu có cache, response được lấy ra. Ngược lại, fetch được thực thi. Kiểm tra nếu trạng thái là 200. Chúng ta sẽ kiểm tra kiểu response là cơ bản, nghĩa là nó sẽ chỉ ra request từ origin của chúng ta. Request đến các asset của bên thứ 3 không thể cache được trong trường hợp này. Response được thêm vào cache. Request và response phải được nhân bản (clone) vì chúng là stream. Thân (body) của một stream chỉ có thể sử dụng 1 lần. Và khi ta cần dùng nó, ta phải nhân bản nó bởi vì trình duyệt cũng cần sử dụng nó nữa. Cập nhật Service WorkerKhi một user ghé thăm webapp của bạn, trình duyệt sẽ thử download lại file .js chứa code Service Worker. Tác vụ này sẽ được chạy nền. Nếu có một chút khác biệt dù chỉ một byte giữa file Service Worker mới download về và file cũ thì trình duyệt cũng sẽ giả định rằng có sự thay đổi và Service Worker mới phải khởi tạo lại. Service Worker mới sẽ bắt đầu khởi tạo và cài đặt. Tuy nhiên vào thời điểm này, Service Worker cũ vẫn đang kiểm soát page trên webapp của bạn, nghĩa là Service Worker mới sẽ nằm trong trạng thái chờ đợi. Một khi trang đang mở được đóng lại, Service Worker cũ sẽ bị hủy bởi trình duyệt và Service Worker mới cài đặt sẽ chiếm quyền kiểm soát toàn bộ. Đây là khi sự kiện kích hoạt của nó được kích hoạt. Tại sao lại cần phải làm tất cả điều này? Là để tránh vấn đề khi có 2 phiên bản webapp chạy đồng thời trong các tab khác nhau. Việc này diễn ra một cách rất phổ biến và có thể tạo ra những lỗi tồi tệ (ví dụ: bạn có schema khác nhau trong khi lưu trữ dữ liệu local trên trình duyệt). Xóa dữ liệu trong cacheBước phổ biến nhất trong callback kích hoạt là quản lý cache. Bạn sẽ cần phải làm điều này ngay bởi vì nếu bạn dọn dẹp cache cũ trong bước cài đặt, Service Worker cũ sẽ dừng lại một cách đột ngột và không thể phân phối các file từ cache đó nữa. Dưới đây là ví dụ cách bạn có thể xóa vài file không nằm trong danh sách an toàn trong cache (trong trương hợp này là có chữ page-1 và page-2 trong tên của nó) 1234567891011121314151617181920self.addEventListener('activate', function(event) &#123; var cacheWhitelist = ['page-1', 'page-2']; event.waitUntil( // Lấy tất cả key từ cache. caches.keys().then(function(cacheNames) &#123; return Promise.all( // Lặp qua mảng các file. cacheNames.map(function(cacheName) &#123; // Nếu file trong cache không nằm trong danh sách an toàn // thì nó sẽ bị xóa. if (cacheWhitelist.indexOf(cacheName) === -1) &#123; return caches.delete(cacheName); &#125; &#125;) ); &#125;) );&#125;); Yêu cầu HTTPSKhi xây dựng webapp, bạn có thể sử dụng Service Worker qua localhost nhưng một khi đã deploy nó lên production, bạn cần chuẩn bị HTTPS (và đó cũng là lý do cuối cùng bạn cần đến HTTPS). Sử dụng Service Worker, bạn có thể chiếm quyền kết nối và ngụy tạo response. Nếu không dùng HTTPS, webapp của bạn trở thành đối tượng của cách tấn công kẻ-trung-gian (man-in-the-middle). Để an toàn hơn, bạn cần phải đăng ký Service Worker với page được phân phối qua HTTPS để bạn biết được Service Worker nào trình duyệt nhận về mà không bị thay đổi khi lưu thông qua mạng. Các trình duyệt hỗ trợSự hỗ trợ cho Service Worker ngày càng được cải thiện: Bạn có thể theo dõi tiến độ cho tất cả các trình duyệt tại đây: https://jakearchibald.github.io/isserviceworkerready/ Service Workers mở ra chân trời mớiMột số tính năng độc đáo mà Service Worker cung cấp: Push notifications : cho phép user tham gia vào lắng nghe cập nhật theo thời gian Đồng bộ dưới nền (background sync): cho phép bạn tạm hoãn các hành động cho tới khi user có kết nối ổn định. Bằng cách này bạn có thể đảm bảo rằng bất kỳ thứ gì mà user cần gửi thì chắc chắn nó sẽ được gửi đi. Đồng bộ định kỳ (periodic sync - tương lai): API cung cấp khả năng quản lý đồng bộ dưới nền theo chu kỳ. Ranh giới ảo (Geofencing - tương lai): bạn có thể định nghĩa params, còn gọi là những geofence bao quanh một khu vực. Webapp sẽ nhận thông báo khi có một thiết bị vượt qua geofence, điều này cho phép bạn cung cấp trả nghiệm có ích dựa trên vị trí địa lý của user. Mỗi mục này sẽ được thảo luận chi tiết hơn trong các bài viết khác. Team tác giả đang nỗ lực không ngừng để mang lại trải nghiệm UX mượt mà nhất có thể cho SessionStack, tối ưu hóa thời gian tải trang và thời gian phản hồi. Khi bạn replay lại 1 session của user trên SessionStack (hoặc xem nó trong thời gian thực), phần SessionStack front-end sẽ không ngừng lấy dữ liệu từ server về để tạo ra một trải nghiệm liền mạch như lưu trong buffer. Một khi bạn đã tích hợp thư viện của SessionStack vào trong webapp, nó sẽ bắt đầu thu thập dữ liệu liên tục về thay đổi trên DOM, tương tác người dùng, request mạng, biệt lệ không được xử lý và thông báo lỗi. Khi một phiên làm việc được replay hoặc stream theo thời gian thực thì SessionStack phục vụ tất cả dữ liệu cho phép bạn thấy mọi thứ về trải nghiệm người dùng ở góc độ trình duyệt của user (cả về mặt kỹ thuật lẫn hình ảnh). Những công việc này cần phải được thực hiện cực nhanh để không làm cho user phải chờ đợi. Bởi vì dữ liệu được front-end kéo về nên đây là một sàn diễn tuyệt vời cho Service Worker có thể “tỏa sáng” mà xử lý những trường hợp như reload player và stream mọi thứ thêm vài lần nữa. Xử lý kết nối mạng bị chậm cũng cực kỳ quan trọng.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P7: Thành phần của WebWorker + 5 trường hợp sử dụng","slug":"Cach-Javascript-hoat-dong-P7-Thanh-phan-cua-WebWorker-5-truong-hop-su-dung","date":"2018-11-16T00:27:00.000Z","updated":"2018-11-16T00:30:02.825Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P7-Thanh-phan-cua-WebWorker-5-truong-hop-su-dung.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P7-Thanh-phan-cua-WebWorker-5-truong-hop-su-dung.html","excerpt":"Chào các bạn đến với bài thứ 7 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Trong bài này chúng ta sẽ tìm hiểu về Web Workers: một cái nhìn tổng quan, thảo luận về các loại worker khách nhau, các thành phần của nó hoạt động với nhau như thế nào và những điểm mạnh cũng như điểm yếu của nó trong các ngữ cảnh khác nhau. Cuối cùng, team tác giả sẽ cung cấp 5 trường hợp mà trong đó Web Worker là sự lựa chọn đúng đắn. Bạn đã quen với sự thật rằng Javascript chạy đơn luồng như chúng ta đã thảo luận chi tiết ở bài trước. JS cũng giúp các developer viết code bất đồng bộ.","text":"Chào các bạn đến với bài thứ 7 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Trong bài này chúng ta sẽ tìm hiểu về Web Workers: một cái nhìn tổng quan, thảo luận về các loại worker khách nhau, các thành phần của nó hoạt động với nhau như thế nào và những điểm mạnh cũng như điểm yếu của nó trong các ngữ cảnh khác nhau. Cuối cùng, team tác giả sẽ cung cấp 5 trường hợp mà trong đó Web Worker là sự lựa chọn đúng đắn. Bạn đã quen với sự thật rằng Javascript chạy đơn luồng như chúng ta đã thảo luận chi tiết ở bài trước. JS cũng giúp các developer viết code bất đồng bộ. Những hạn chế của lập trình bất đồng bộChúng ta đã thảo luận ở bài trước về lập trình bất đồng bộ và khi nào thì nên dùng. Lập trình bất đồng bộ cho phép UI của app trở nên mượt mà, bằng cách “lên lịch” cho từng phần của code được thực thi ở thời gian phù hợp trong event loop, do đó nó cho phép render UI được thực hiện trước. Một trường hợp tốt để dùng lập trình bất đồng bộ là khi ta gọi Ajax request. Bởi vì request có thể tốn nhiều thời gian nên có thể để cho nó chạy bất đồng bộ và trong khi client chờ kết quả trả về, những code khác vẫn được thực thi. 1234567// Giả sử bạn dùng jQueryjQuery.ajax(&#123; url: 'https://api.example.com/endpoint', success: function(response) &#123; // code được thực thi khi response trả về &#125;&#125;); Nhưng điều này lại gây ra vấn đề khác: request được xử lý bởi Web API của trình duyệt, nhưng làm thế nào mà code khác có thể chạy bất đồng bộ? Ví dụ nếu như code bên trong một success callback lại chạy ngốn rất nhiều CPU: 1var result = performCPUIntensiveCalculation(); Nếu như performCPUIntensiveCalculation không phải là một request HTTP nhưng lại block code xử lý (ví dụ: 1 vòng lặp rất lớn), không có cách nào để giải phóng event loop và unblock cho UI trình duyệt, nó sẽ đóng băng và không phản hồi lại với user. Nghĩa là trong Javascript, những hàm bất đồng bộ chỉ giải quyết vấn đề nhỏ của hạn chế ở đơn luồng. Trong những trường hợp đó, bạn có thể làm cho unblock UI khỏi quá trình tính toán quá lâu bằng cách sử dụng setTimeout. Ví dụ, tách một chuỗi xử lý tính toán phức tạp vào trong nhiều lời gọi setTimeout, bằng cách đó bạn có thể đặt chúng vào những “vị trí” khác nhau trong event loop và cách này có thể giúp cho render UI được tốt hơn. Cùng xem một ví dụ đơn giản về tính toán số trung bình của 1 mảng số nguyên: 123456789101112131415function average(numbers) &#123; var len = numbers.length, sum = 0, i; if (len === 0) &#123; return 0; &#125; for (i = 0; i &lt; len; i++) &#123; sum += numbers[i]; &#125; return sum / len;&#125; Dưới đây là cách ta viết lại code trên và “giả lập” trường hợp bất đồng bộ: 1234567891011121314151617181920212223function averageAsync(numbers, callback) &#123; var len = numbers.length, sum = 0; if (len === 0) &#123; return 0; &#125; function calculateSumAsync(i) &#123; if (i &lt; len) &#123; // Đưa hàm tiếp theo vào event loop setTimeout(function() &#123; sum += numbers[i]; calculateSumAsync(i + 1); &#125;, 0); &#125; else &#123; // hết mảng, gọi callback callback(sum / len); &#125; &#125; calculateSumAsync(0);&#125; Cách này sẽ dùng setTimeout để thêm mỗi bước thực hiện tính toán vào trong event loop. Giữa mỗi lần tính toán sẽ có đủ thời gian cho các tính toán được thêm vào và giải phóng trình duyệt khỏi bị đóng băng. Web Workers đến giải cứuHTML5 mang đến cho chúng ta rất nhiều thứ tuyệt vời: SSE (đã thảo luận và so sánh với WebSocket ở bài trước) Geolocation Application cache Local Storage Drag and Drop Web Workers Web Workers là tiến trình trong trình duyệt nhưng có thể được dùng để thực thi Javascript code mà không cản trở event loop Điều này thực sự kỳ diệu. Toàn bộ mô hình của Javascript dựa trên ý tưởng về môi trường đơn luồng nhưng giờ đây là có Web Workers và nó gỡ bỏ (1 phần nào) sự hạn chế đó. Web Workers cho phép developer đặt những công việc có thời gian chạy dài và những công việc nặng về xử lý tính toán trong background mà không gây trở ngại đến UI, làm app của bạn mượt mà hơn. Ngoài ra, không cần phải xài trick với setTimeout để đánh lừa event loop nữa. Ở đây có một demo mẫu thể hiện sự khác nhau khi thực hiện sắp xếp mảng dùng và không dùng Web Workers. Khái quát về Web WorkersWeb Workers cho phép bạn làm những việc như thực thi các đoạn code xử lý tốn thời gian để tính toán các phép tính hao tổn nheiefu CPU nhưng không làm cản trở UI. Thực ra, nó sẽ chạy song song. Web Workers là đa luồng. Bạn sẽ thắc mắc: “Chứ không phải Javascript là ngôn ngữ đơn luồng à?” Đây là lúc mà bạn sẽ thốt lên aha ngạc nhiên khi nhận ra Javascript là một ngôn ngữ không định nghĩa mô hình tiến trình. Web Workers không phải là một phần của Javascript, nó là tính năng của trình duyệt mà có thể truy xuất thông qua Javascript. Đa số các trình duyệt có lịch sử về đơn tiến trình (giờ thì thay đổi rồi), và đa số các triển khai của Javascript đều diễn ra trên trình duyệt. Web Workers không được triển khai trên Node.js, nó có khái niệm hơi khác một chút về cluster hay child_process. Có 3 loại Web Workers được đề cập đến trong thông số kỹ thuật: Dedicated Workers Shared Workers Service workers Dedicated Workers (Worker chuyên dụng)Dedicated Web Workers được khởi tạo bởi tiến trình chính và chỉ có thể giao tiếp với tiến trình đó. Shared Workers (Worker chia sẻ)Shared Workers có thể được truy cập bởi tất cả các tiến trình chạy trên cùng origin (khác tab trình duyệt, iframe hoặc là các shared worker khác) Nếu bạn muốn dùng thử SessionStack để hiểu và khám phá lại những vấn đề kỹ thuật cũng như UX trên webapp của bạn, team SessionStack đang có bản dùng thử miễn phí, ở đây nhé. Service Workers (Worker dịch vụ)Một Service Worker là worker hướng sự kiện (event-driven) được đăng ký với origin và path. Nó có thể điều khiển web page/site mà nó liên kết, can thiệp và chỉnh sửa sự điều hướng và các yêu cầu tài nguyên, lưu đệm tài nguyên với phong cách rất chi tiết để cho phép bạn có toàn quyền điều khiển về việc app của bạn xử lý như thế nào trong từng trường hợp cụ thể (ví dụ như khi rớt mạng) Trong bài này chúng ta sẽ tập trung vào Dedicated Worker và chỉ gọi nó dưới cái tên Web Workers hoặc Worker Web Workers hoạt động như thế nào?Web Workers được triển khai dưới dạng đuôi .js và được đính kèm theo request HTTP bất đồng bộ trong web của bạn. Những request này được ẩn hoàn toàn bởi Web Worker API Workers sử dụng message kiểu tiến trình để thực hiện quá trình hoạt động song song. Chúng có thể giữ cho UI được cập nhật mới nhất, có thể tương tác và mượt mà với người dùng một cách hoàn hảo. Web Workers chạy trong một tiến trình cô lập trong trình duyệt. Do đó là code chúng thực thi cần phải đặt trong 1 file riêng biệt. Điều này rất quan trọng nhé. Cách tạo worker cơ bản 1var worker = new Worker('task.js'); Nếu task.js tồn tại và có thể truy cập được, trình duyệt sẽ thiết lập một tiến trình mới để tải file bất đồng bộ. Sau khi quá trình tải file hoàn tất, nó sẽ thực thi code trong đó và worker bắt đầu làm việc. Trong trường hợp file lỗi không load được thì trả về 404 và worker sẽ dừng lại một cách yên lặng như chưa có gì xảy ra. Để bắt đầu tạo worker, bạn cần gọi phương thức postMessage: 1worker.postMessage(); Giao tiếp của Web WorkerĐể giao tiếp giữa một Web Worker và trang của bạn thì bạn cần phải sử dụng phương thức postMessage hoặc kênh phát sóng (Broadcast channel). Phương thức postMessageCác trình duyệt mới hỗ trợ object JSON như là param đầu tiên của phương thức trong khi các trình duyệt cũ hơn thì chọn string Dưới đây là ví dụ về một page có worker có thể giao tiếp qua lại với nó như thế nào bằng cách truyền một object JSON. Truyền string cũng tương tự: 123456789101112&lt;button onclick=\"startComputation()\"&gt;Start computation&lt;/button&gt;&lt;script&gt; function startComputation() &#123; worker.postMessage(&#123;'cmd': 'average', 'data': [1, 2, 3, 4]&#125;); &#125; var worker = new Worker('doWork.js'); worker.addEventListener('message', function(e) &#123; console.log(e.data); &#125;, false);&lt;/script&gt; Và đoạn code của worker: 1234567891011self.addEventListener('message', function(e) &#123; var data = e.data; switch (data.cmd) &#123; case 'average': var result = calculateAverage(data); // Tính trung bình cộng từ một array self.postMessage(result); break; default: self.postMessage('Unknown command'); &#125;&#125;, false); Khi click vào button, trang chính sẽ gọi tới postMessage. Dòng worker.postMessage truyền một object JSON vào worker, object chứa thông tin là cmd và data. Worker sẽ xử lý message thông qua một message handler đã được định nghĩa. Khi message đến, các thao tác tính toán thực sự sẽ được thực hiện trong worker mà không cản trở event loop. Worker kiểm tra event e được truyền vào và thực thi giống như một hàm Javascript bình thường. Khi xong việc kết quả sẽ được trả ngược lại cho trang chính. Trong ngữ cảnh của worker, cả self và this đều đang tham chiếu đến global scope. Có 2 cách để dừng worker: gọi hàm worker.terminate() từ ngoài trang chính hoặc gọi self.close() bên trong worker. Kênh phát sóng (Broadcast Channel)Broadcast Channel giống như một API giao tiếp tổng quát. Nó cho phép chúng ta broadcast message tới tất cả các ngữ cảnh cùng chia sẻ chung origin. Tất cả các tab trình duyệt, iframe hoặc worker phục vụ chung origin có thể phát và nhận message. 1234567891011121314// Kết nối đến một broadcast channelvar bc = new BroadcastChannel('test_channel');// Ví dụ gửi một message đơn giảnbc.postMessage('This is a test message.');// Ví dụ về một event handler có chức// năng in message ra consolebc.onmessage = function (e) &#123; console.log(e.data); &#125;// Ngắt kết nốibc.close() Xem hình minh họa thì bạn sẽ hiểu cách hoạt động của Broadcast Channel rõ ràng hơn: Broadcast Channel bị hạn chế hỗ trợ từ các trình duyệt: Kích thước messageCó 2 cách để gửi message trong Web Workers: Sao chép message: message được serialized, sao chép, gửi đi và được de-serialized ở đầu kia. Trang web và worker không dùng chung instance, vì thế cuối cùng là kết quả sẽ bị trùng lặp ở cả 2 phía. Đa số các trình duyệt triển khai tính năng này bằng cách encoding/decoding giá trị ở cả 2 phía thành JSON một cách tự động. Đúng như dự đoán thì các hoạt động dữ liệu như thế này bổ sung thêm chi phí đáng kể vào việc truyền tải message. Message càng lớn thì thời gian gửi càng lâu. Truyền tải message: điều này nghĩa là bên gửi sẽ không thể sử dụng nó một khi đã gửi đi. Truyền tải dữ liệu gần như tức thời. Hạn chế là chỉ duy nhất ArrayBuffer là có thể gửi được. Tính năng có sẵn của Web WorkersWeb Workder chỉ có truy xuất tới một tập hợp nhỏ các tính năng của Javascript bởi vì bản chất đa luồng của nó, dưới đây là danh sách các tính năng: Object navigator Object location (chỉ đọc - read only) XMLHttpRequest setTimeout()/clearTimeout() và setInterval()/clearInterval() Bộ đệm ứng dụng (Application Cache) Import script bên ngoài thông qua importScripts() Tạo các web worker khác Hạn chế của Web WorkersHơi buồn là Web Worker không có quyền truy cập đến một số tính năng quan trọng của Javascript: DOM (not thread-safe) Object window Object document Object parent Điều này nghĩa là Web Worker không thể thay đổi DOM (và UI). Nó có thể hơi khó khăn, nhưng nếu bạn đã quen với viêc sử dụng Web Worker đúng cách thì bạn sẽ bắt đầu sử dụng khả năng “tính toán độc lập” của nó trong khi các code thay đổi UI đang được xử lý và hoạt động. Worker sẽ chăm sóc tất cả những phần nặng nhọc cho bạn và khi đã xong viêc thì bạn chỉ cần gửi kết quả ra màn hình để cập nhật UI cho phù hợp. Xử lý lỗiGiống như code Javascript khác, bạn sẽ cần xử lý lỗi khi Web Worker bắn ra. Nếu có lỗi xảy ra trong quá trình worker thực thi, ErrorEvent sẽ được bắn. Interface này sẽ bao gồm 3 thuộc tính hữu ích cho việc tìm ra bạn đang sai chỗ nào: filename: tên của worker script gây ra lỗi lineno: số của dòng gây ra lỗi message: mô tả lỗi Ví dụ: 1234567891011function onError(e) &#123; console.log('Line: ' + e.lineno); console.log('In: ' + e.filename); console.log('Message: ' + e.message);&#125;var worker = new Worker('workerWithError.js');worker.addEventListener('error', onError, false);worker.postMessage(); // Khởi tạo worker mà không truyền messageself.addEventListener('message', function(e) &#123; postMessage(x * 2); // Intentional error. 'x' is not defined.&#125;; Ở đây bạn thấy rằng chúng ta tạo worker và bắt đầu listen sự kiện error. Bên trong worker (file workerWithError.js) chúng ta cố tình tạo một exception bằng cách nhân x với 2 trong khi x không hề tồn tại trong scope đó. Exception được bắn ra khi khởi tạo script và hàm onError được gọi với thông tin về lỗi. Trường hợp nên sử dụng Web WorkersCho đến bây giờ thì chúng ta đã nghiên cứu về điểm mạnh và hạn chế của Web Workers. Cùng xem những trường hơp nào thì dùng chúng là tốt nhất: Dò tia (Ray tracing): ray tracing là một kỹ thuật render để sinh ra những hình ảnh bằng cách dò theo vết đường đi của ánh sáng theo dạng pixel. Ray traycing sử dụng rất nhiều phép tính toán học có ảnh hướng lớn đến CPU để giả lập đường đi của ánh sáng. Ý tưởng về giả lập những hiệu ứng như phản chiếu (reflection), khúc xạ (refraction), vật liệu, vân vân. Tất cả các logic tính toán như vậy đều có thể đưa vào Web Worker để tránh gây trở ngại với UI thread. Thậm chí có thể tốt hơn nếu bạn có thể chia nhỏ quá trình render hình ảnh ra nhiều worker (và chia ra nhiều CPU). Đây là 1 minh họa đơn giản của ray tracing sử dụng Web Workers: https://nerget.com/rayjs-mt/rayjs.html Mã hóa (Encryption): Mã hóa end-to-end (E2EE) càng ngày càng phổ biến do sự gia tăng khắt khe về các quy định của dữ liệu nhạy cảm &amp; cá nhân. Mã hóa có thể khá tốn thời gian, đặc biệt nếu có rất nhiều dữ liệu cần được mã hóa thường xuyên (trước khi gửi về server chẳng hạn). Đây là một trường hợp trong đó Web Worker là lựa chọn rất tốt vì nó không yêu cầu truy xuất đến DOM hay các thứ khác, chỉ thuần túy là thuật toán mã hóa. Một khi đã được đẩy vào worker xử lý, nó sẽ hoạt động rất trơn tru và không ảnh hưởng đến trải nghiệm của người dùng. Tải trước dữ liệu: Để tối ưu website hoặc webapp và cải thiện thời gian loading, bạn có thể nhờ vả Web Workers để load và lưu dữ liệu trước và sử dụng chúng về sau khi cần đến. Web Workers rất tốt trong trường hợp này vì nó không ảnh hướng đến UI, không giống như khi ta dùng mà không có workers. Progressive Web Apps: Chúng cần được load thật nhanh kể cả khi kết nối mạng không ổn định. Nghĩa là dữ liệu cần phải được lưu trên trình duyệt. IndexDB hoặc những API tương tự hỗ trợ tốt khoản này. Về cơ bản thì lưu trữ ở phía client là cần thiết. Để có thể sử dụng mà không gây cản trở đến UI, công việc cần phải được hoàn thành trong Web Workers. Trong trường hợp của IndexDB, có một API bất đồng bộ cho phép bạn làm việc này mà không dùng workers, tuy nhiên cũng có một API đồng bộ trước đây (có thể sẽ được giới thiệu lại) chỉ được phép chạy bên trong workers. Kiểm tra chính tả (Spell checking): một bộ spell checker cơ bản hoạt động như sau: chương trình sẽ đọc một file từ điển với danh sách các từ đúng chính tả. Từ điển sẽ được parse thành cây tìm kiếm (search tree) để có thể tìm kiếm văn bản hiệu quả. Khi một từ được đưa vào checker, chương trình sẽ kiểm tra nếu nó tồn tại trong cây tìm kiếm. Nếu từ đó không tồn tại, chương trình sẽ cung cấp từ thay thế bằng cách thay đổi ký tự thay thế và kiểm tra nếu đó là 1 từ hợp lệ nếu nó là từ mà user muốn viết ra. Tất cả quá trình này có thể dễ dàng giảm tải cho hệ thống bằng Web Workers và user có thể gõ chữ, viết câu mà không gây cản trở với UI trong khi worker thực thi tất cả các phần tìm kiếm và đưa ra đề xuất. Hiệu năng và độ tin cậy là rất quan trọng đối với team SessionStack. Lý do là vì một khi đã tích hợp SessionStack vào web app của bạn, chương trình sẽ bắt đầu ghi lại mọi thứ từ thay đổi trên DOM và tương tác người dùng đến các request mạng, exception không được xử lý và các thông báo lỗi. Tất cả dữ liệu được truyền về cho server của chương trình trong thời gian thực để có thể cho phép bạn chạy lại những issue từ webapp dưới dạng video và xem thử điều gì đang diễn ra với user. Tất cả điều này được thực hiện với độ trễ tối thiểu và không có ảnh hưởng đến hiệu năng của app của bạn. Đây là lý do mà team tác giả đã đưa toàn bộ logic (phần nào có thể) từ cả thư viện điều hành &amp; phần player vào Web Worker để xử lý các công viêc nặng tải với CPU như băm để xác nhận tính toàn vẹn dữ liệu, render, vân vân. Công nghệ web liên tục thay đổi và phát triển vì thế team tác giả đã đi thêm 1 chặng đường dài để đảm bảo SessionStack thật nhẹ và không gây ảnh hưởng đến hiệu năng của người dùng.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P6: So sánh với WebAssembly + Một số trường hợp tốt hơn nên sử dụng","slug":"Cach-Javascript-hoat-dong-P6-So-sanh-voi-WebAssembly-Mot-so-truong-hop-tot-hon-nen-su-dung","date":"2018-11-16T00:19:00.000Z","updated":"2018-11-16T00:21:12.978Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P6-So-sanh-voi-WebAssembly-Mot-so-truong-hop-tot-hon-nen-su-dung.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P6-So-sanh-voi-WebAssembly-Mot-so-truong-hop-tot-hon-nen-su-dung.html","excerpt":"Chào các bạn đến với bài thứ 6 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Lần này chúng ta sẽ khám phá về WebAssembly và phân tích cách hoạt động của nó, quan trọng hơn là những điểm vượt trội hơn so với Javascript về mặt hiệu năng: thời gian tải, tốc độ thực thi, dọn rác (GC), sử dụng bộ nhớ, truy cập API, debugging, đa luồng và tính di động (portability). Cách chúng ta xây dựng web app trên bờ vực cách mạng - vẫn đang trong những ngày đầu nhưng cách chúng ta suy nghĩ về web app đang dần thay đổi.","text":"Chào các bạn đến với bài thứ 6 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Lần này chúng ta sẽ khám phá về WebAssembly và phân tích cách hoạt động của nó, quan trọng hơn là những điểm vượt trội hơn so với Javascript về mặt hiệu năng: thời gian tải, tốc độ thực thi, dọn rác (GC), sử dụng bộ nhớ, truy cập API, debugging, đa luồng và tính di động (portability). Cách chúng ta xây dựng web app trên bờ vực cách mạng - vẫn đang trong những ngày đầu nhưng cách chúng ta suy nghĩ về web app đang dần thay đổi. Cùng xem WebAssembly có thể làm gìWebAssembly (gọi tắt wasm) là một loại bytecode cấp độ thấp và hiệu quả cho web. WASM cho phép bạn sử dụng ngôn ngữ khác Javascript (như C, C++, Rust…), viết chương trình với những ngôn ngữ đó, và biên dịch trước (ahead of time) sang WebAssembly. Kết quả là webapp sẽ load và thực thi rất nhanh. Thời gian tải (loading time)Để load Javascript, trình duyệt phải load tất cả file .js đúng nguyên văn bản. WebAssembly load nhanh hơn trong trình duyệt bởi vì chỉ có những file wasm đã được biên dịch là được truyền tải qua internet. Và bởi vì wasm là ngôn ngữ bậc thấp gần giống assembly có format nhị phân rất nhỏ gọn. Thực thi (execution)Wasm chạy chậm hơn 20% so với native code. Dù gì đi nữa thì đây là một kết quả đáng kinh ngạc. Nó là một định dạng được biên dịch sang môi trường sandbox và chạy cùng rất nhiều ràng buộc để đảm bảo nó không có những điểm yếu bảo mật hoặc rất khó để chống lại. Tốc độ chậm là không đáng kể khi so với native code. Hơn nữa, nó sẽ được cải thiện chạy nhanh hơn trong tương lai. Ngoài ra, khả năng tương thích rất tốt với trình duyệt là điểm mạnh, tất cả những engine lớn đều có hỗ trợ WebAssembly và đều đưa ra thời gian thực thi tương đương nhau. Để hiểu WebAssembly thực thi nhanh như thế nào so với Javascript, bạn nên đọc bài trước trong series Đục khoét Javascript Cùng xem điều gì xảy ra trong V8: Cách tiếp cận của V8: biên dịch chậm Ở bên trái, chúng ta có Javascript source, bao gồm các hàm. Đầu tiên thì nó cần phải được parse (phân tích cú pháp) để chuyển tất cả string sang token và sinh ra Abstract Syntax Tree (AST - Cây cú pháp trừu tượng, chúng ta sẽ có một bài viết về nó sau). Cây AST là đại diện biểu thị logic của chương trình JS trong bộ nhớ. Một khi nó được sinh ra, V8 sẽ đi thẳng đến mã máy. Về cơ bản thì bạn sẽ duyệt qua cây đó, tạo ra mã máy và hàm của bạn đã được biên dịch. Không có tiến trình nào cố gắng tăng tốc nó. Giờ thì lướt qua xem V8 pipeline làm gì tiếp theo: Chúng ta có TurboFan, 1 trong những trình biên dịch tối ưu hóa của V8. Trong khi app Javascript đang chạy thì còn có rất nhiều code khác chạy trong V8. TurboFan thực hiện điều hành, nếu có gì chạy chậm bất kể là đang nghẽn cổ chai (bottleneck) hay những điểm nóng (hot spots), thì sẽ được tối ưu hóa. Nó đẩy phần code đang ngốn tài nguyên CPU đó qua một bộ JIT tối ưu để tạo ra code nhanh hơn nhiều. Nó giải quyết vấn đề, nhưng bên cạnh đó quá trình phân tích code và quyết định nên tối ưu như thế nào cũng làm tốn tài nguyên CPU. Điều này, làm hao tổn thời lượng pin nhiều hơn, đặc biệt là trên các thiết bị di động. Chà, wasm thì không cần. Nó đi thẳng vào quá trình làm việc như dưới đây: Wasm đã duyệt qua quá trình tối ưu hóa ngay trong giai đoạn biên dịch. Trên hết thì parsing đã không còn cần thiết nữa. Bạn có mã nhị phân tối ưu có thể gắn trực tiếp vào bộ phận backend để sinh ra mã máy. Tất cả các sự tối ưu hóa đã được hoàn thành bởi trình biên dịch ở frontend. Điều này làm cho quá trình thực thi wasm trở nên hiệu quả hơn rất nhiều bởi vì ta có thể bỏ qua 1 số bước trong khi xử lý. Mô hình bộ nhớ Bộ nhớ của 1 chương trình C++ là chuỗi liền kề các block nhớ không có “lỗ”. Một trong số các tính năng của wasm giúp đẩy mạnh sự bảo mật là ý tưởng về stack thực thi đặt riêng biệt với bộ nhớ thẳng hàng (linear). Trong C++ ta có heap, cấp phát từ đáy của heap và phát triển stack ở đỉnh heap. Ta có thể lấy con trỏ và tìm kiếm trong bộ nhớ stack để chơi đùa với những biến mà chúng ta còn không đụng tới. Đây là một điểm cạm bẫy mà rất nhiều malware khai thác. WebAssembly sử dụng một mô hình hoàn toàn khác. Stack thực thi tách biệt với chương trình chính WebAssembly nên không có cách nào bạn có thể chỉnh sửa và thay đổi những biến bên trong nó. Thêm nữa là các hàm có offset là số nguyên chứ ko dùng contror. Hàm trỏ vào một bảng chức năng vô hướng. Sau đó, các con số được tính toán trực tiếp này được đưa vào bên trong module. Nó được xây dựng theo cách này để có thể load nhiều wasm cùng lần, đánh offset tất cả các index và nó sẽ chạy tốt. Để tìm hiểu sâu hơn về mô hình bộ nhớ và các cách quản lý trong Javascript, bạn có thể xem lại bài trước. Dọn rác (GC)Chúng ta đã biết quản lý bộ nhớ của Javascript có bao gồm cả xử lý dọn rác Garbage Collector. Đối với WebAssembly thì hơi khác một chút. Nó hỗ trợ những ngôn ngữ quản lý bộ nhớ thủ công. Bạn có thể sử dụng GC của chính bạn với các wasm module, nhưng công việc đó hơi phức tạp. Hiện tại, WebAssembly được thiết kế xoay quanh các trường hợp sử dụng của C++ và RUST. Bởi vì wasm là ngôn ngữ thấp nên sẽ dễ hiểu hơn nếu sử dụng những ngôn ngữ lập trình gần gũi &amp; dễ biên dịch ra ngôn ngữ assembly. C có thể sử dụng malloc thường, C++ có thể dùng con trỏ thông minh. Rust dùng một mô hình khác hoàn toàn (nhưng là 1 chủ đề khác nhé). Những ngôn ngữ này không dùng GC, do đó chúng không cần các tác vụ runtime để theo dõi bộ nhớ. WebAssembly phù hợp với chúng. Thêm nữa, những ngôn ngữ này không phải được thiết kế 100% cho việc truy vấn những thứ phức tạp thuộc về Javascript, ví dụ như thay đổi DOM. Nó khá vô nghĩa khi phải viết toàn bộ app HTML trên nền C++ bởi vì C++ không được thiết kế với mục đích làm webapp. Đa số các trường hợp các kỹ sư dùng C++ hoặc Rust, họ hướng tới WebGL hoặc những thư viện có tính tối ưu hóa cao. (Ví dụ: phép tính toán học khó và phức tạp) Tuy nhiên, trong tương lai WebAssembly sẽ hỗ trợ những ngôn ngữ có sẵn GC. Truy xuất Platform APITùy thuộc vào môi trường runtime thực thi Javascript, quyền truy xuất vào những API đang tồn tại đặc trưng cho platform có thể được truy cập trực tiếp thông qua app JS của bạn. Ví dụ: bạn chạy JS code trên trình duyệt, bạn có 1 cục các Web API mà webapp có thể gọi và điều khiển trình duyệt hoặc chức năng thiết bị và có quyền truy xuất vào DOM, CSSOM, WebGL, IndexedDB, Web Audio API, vân vân. WebAssembly module không có quyền truy cập vào platform API. Mọi thứ đều trung gian qua Javascript. Nếu bạn muốn truy xuất vào một số API đặc trưng cho platform bên trong module WebAssembly thì bạn phải gọi nó thông qua Javascript. Ví dụ, nếu muốn dùng console.log, bạn gọi nó thông qua JS thay vì C++. Và dĩ nhiên là sẽ có những hạn chế về JS mà ta phải chấp nhận. Nhưng trường hợp này sẽ sớm được khắc phục khi mà đặc điểm kỹ thuật sẽ cung cấp các platform API cho wasm trong tương lai, bạn sẽ có thể sớm phát triển app mà không cần Javascript. Ánh xạ mã nguồn (Source map)Khi bạn làm tối giản code JS, bạn cần đảm bảo có thể debug nó. Đó là khi mà ta cần đến Source Map. Về cơ bản, Source Map là 1 cách để map một file tối giản về với trạng thái ban đầu của nó. Khi bạn build sản phẩm cho môi trường production, cùng với file JS đã kết hợp &amp; tối gian, bạn sẽ sinh ra 1 file source map chứa thông tin về file JS gốc. Khi bạn query một dòng cụ thể với số cột nào đó file JS, bạn có thể tra cứu trong source map để tìm ra vị trí gốc ban đầu của nó. WebAssembly không hỗ trợ source map vì nó chưa có mô tả kỹ thuật cho phần này nhưng hi vọng là tương lai gần sẽ hỗ trợ. Khi bạn đặt breakpoint trong code C++, bạn sẽ thấy code C++ thay vì WebAssembly, ít nhất là vẫn còn có ích. Đa luồng (Multithreading)Ai cũng biết Javascript là đơn luồng. Có nhiều cách để cải thiện Event Loop và nâng cấp phần lập trình bất đồng bộ mà chúng tôi đã giới thiệu trong bài trước. Javascript có thể dùng Web Workers nhưng nó rất hạn chế trường hợp. Về cơ bản, bất kỳ tính toán nào ảnh hưởng nặng đến CPU và block luồng xử UI đều có thể được đẩy ra load riêng với WebWorker. Tuy nhiên, WebWorker lại không truy xuất được vào DOM. WebAssembly hiện tại không hỗ trợ đa luồng. Tuy nhiên, điều này chắc chắn sẽ được thay đổi. Wasm đang tiến gần tới những tiến trình native (ví dụ: luồng kiểu C++). Có những luồng “thực” sẽ tạo ra rất nhiều cơ hội mới trên trình duyệt. Và lẽ dĩ nhiên, nó cũng sẽ bị lạm dụng nhiều hơn. Tính di động (Portability)Ngày nay Javascript có thể chạy ở bất kỳ đâu, từ trình duyệt đến server, kể cả trong các hệ thống nhúng. WebAssembly được thiết kế để an toàn và linh động. Như Javascript, nó chạy trên nhiều môi trường hỗ trợ wasm (ví dụ: mọi trình duyệt) WebAssembly có cùng mục tiêu di động như cách mà Java đang cố thực hiện trong những ngày đầu với Applets. Khi nào thì dùng WebAssembly tốt hơn JavaScript?Trong các phiên bản đầu của WebAssembly, chức năng chính chỉ tập trung vào các phép tính nặng tải trên CPU (các bài toán phức tạp chẳng hạn). Ứng dụng chủ yếu nhất khi nghĩ đến là games - có cả hàng tấn pixel cần thao tác xử lý trên màn hình. Bạn có thể viết app bằng ngôn ngữ mà bạn quen thuộc như C++/Rust bằng OpenGL sao đó biên dịch sang wasm và nó sẽ chạy trên trình duyệt. Bạn có thể xem ví dụ sau (tốt nhất là dùng Firefox): http://s3.amazonaws.com/mozilla-games/tmp/2017-02-21-SunTemple/SunTemple.html. Nó chạy trên nền Unreal engine. Một trường hợp khác tiêu biểu cho viêc sử dụng WebAssembly (về mặt hiệu năng) là triển khai một số thư viện chạy các tác vụ nặng với CPU, ví dụ như xử lý ảnh. Như đã nói ở trước, wasm có thể giảm khá nhiều lượng tiêu thụ pin trên các thiết bị di động (phụ thuộc vào engine), bởi vì đa số các bước xử lý đều đã được hoàn thành trước trong khi biên dịch. Trong tương lai, bạn sẽ có thể sử dụng code WASM nhị phân kể cả khi bạn không thực sự viết code có thể biên dịch ra nó. Bạn có thể tìm vài projects trên NPM đang bắt đầu triển khai theo hướng này. Với trường hợp thay đổi DOM và sử dụng nhiều platform API thì tốt nhất vẫn là dùng Javascript, bởi vì rõ ràng nó hỗ trợ tốt với các API đó. Ở SessionStack, tác giả liên tục mở rộng biên giới hiệu năng của Javascript nhằm viết được nhiều code tối ưu và hiệu quả cao. Giải pháp của họ cần cung cấp hiệu năng nhanh chóng mặt vì không thể gây ảnh hưởng lên hiệu năng của app của khách hàng. Một khi bạn đã tích hợp SessionStack vào web app của bạn, nó sẽ ghi lại mọi thứ diễn ra trên app/website: những thay đổi trên DOM, tương tác của người dùng, JS exception, stack trace, những request bị fail và cả thông báo debug, cho phép bạn chạy lại (replay) những issue đã xảy ra dưới dạng video và xem chúng diễn ra như thế nào với người dùng. Tất cả đều hoạt động theo thời gian thực (real-time) và không ảnh hưởng đến hiệu năng của webapp. SessionStack phải tối ưu hóa code một cách tối đa và làm cho quá trình này bất đồng bộ nhất có thể. Không chỉ là một thư viện! Khi bạn chạy lại một session của người dùng trong SessionStack thì nó phải render lại toàn bộ những gì mà trình duyệt của user thực hiện tại thời điểm vấn đề xảy ra và team tác giả phải xây dựng lại toàn bộ trạng thái, cho phép bạn có thể nhảy tới nhảy lui trong timeline session. Để đạt được điều đó, team tác giả đã tận dụng tối đa khả năng bất đồng bộ mà Javascript cung cấp trong khi thiếu sót những giải pháp tốt hơn. Với WebAssembly, team tác giả có thể đẩy những tiến trình xử lý và render nặng nhất vào một ngôn ngữ phù hợp hơn với công việc này và để phần thu thập dữ liệu, thay đổi DOM cho Javascript làm.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P5: Hiểu sâu về WebSocket & HTTP/2 với SSE","slug":"Cach-Javascript-hoat-dong-P5-Hieu-sau-ve-WebSocket-HTTP-2-voi-SSE","date":"2018-11-16T00:04:00.000Z","updated":"2018-11-16T00:16:38.066Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P5-Hieu-sau-ve-WebSocket-HTTP-2-voi-SSE.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P5-Hieu-sau-ve-WebSocket-HTTP-2-voi-SSE.html","excerpt":"Chào các bạn đến với bài thứ 5 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Trong phần này chúng ta sẽ đào sâu với thế giới của những giao thức giao tiếp, ánh xạ (mapping) và thảo luận về những thuộc tính cũng như thành phần của chúng. Chúng ta sẽ đưa ra 1 so sánh nhỏ giữa WebSockets và HTTP/s. Cuối cùng, team SessionStack sẽ chia sẻ một vài ý tưởng về việc lựa chọn phương thức nào cho phù hợp với giao thức mạng.","text":"Chào các bạn đến với bài thứ 5 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Trong phần này chúng ta sẽ đào sâu với thế giới của những giao thức giao tiếp, ánh xạ (mapping) và thảo luận về những thuộc tính cũng như thành phần của chúng. Chúng ta sẽ đưa ra 1 so sánh nhỏ giữa WebSockets và HTTP/s. Cuối cùng, team SessionStack sẽ chia sẻ một vài ý tưởng về việc lựa chọn phương thức nào cho phù hợp với giao thức mạng. Giới thiệuNgày nay những webapp phức tạp có nhiều tính năng, UI động xuất hiện như trăm hoa đua nở. Cũng không phải bất ngờ, internet cũng đã phát triển được một quãng đường khá dài kể từ khi bắt đầu. Ban đầu, internet không được xây dựng để dành cho những app động và phức tạp. Nó được hình thành như là một tập hợp của các trang HTML, kết nối với nhau để cấu thành nên khái niệm về “Web” chứa thông tin. Phần lớn mọi thứ được xây dựng xung quanh mô hình request/response nổi tiếng của HTTP. Một client tải trang và không có gì xảy ra cho đến khi user bắt đầu click và di chuyển đến trang tiếp theo. Khoảng năm 2005, AJAX được giới thiệu và rất nhiều người đã khám phá khả năng tạo kết nối giữa client và server theo 2 chiều (bidirectional). Và vẫn như thế, tất cả giao tiếp HTTP được chỉ đạo bởi client yêu cầu user tương tác hoặc thực hiện theo chu kỳ để lấy dữ liệu mới từ server. Tạo một HTTP “2 chiều”Công nghệ cho phép server gửi dữ liệu về client một cách “chủ động” đã phát triển được 1 thời gian. Push và Comet là ví dụ. Một trong số mẹo nổi tiếng để tạo ra ảo giác rằng server đang gửi dữ liệu về client được gọi là long polling. Với long polling, client mở kết nối HTTP đến server và giữ nó tiếp tục mở cho đến khi có response trả về. Mỗi khi server có dữ liệu mới cần được gửi, nó chuyển giao thông tin dưới dạng một response. Cùng xem một ví dụ đơn giản về long polling: 123456789101112131415(function poll()&#123; setTimeout(function()&#123; $.ajax(&#123; url: 'https://api.example.com/endpoint', success: function(data) &#123; // Làm gì đó với `data` // ... // Cài đặt poll mới theo đệ quy poll(); &#125;, dataType: 'json' &#125;); &#125;, 10000);&#125;)(); Đây là một hàm tự thực thi cơ bản chạy một cách tự động lần đầu tiên. Nó sẽ cài đặt một khoảng thời gian 10 giây và sau mỗi lời gọi Ajax bất đồng bộ đến server, callback lại gọi ajax lần nữa. Vài kỹ thuật khác có thể kể đến như Flash, request nhiều thành phần XHR và htmlfiles nổi tiếng. Tất cả những phương pháp này đều có chung một vấn đề: Chúng qua mặt HTTP, làm cho chúng không phù hợp với những app có độ trễ thấp. Giả sử như game bắn súng nhiều người chơi trên trình duyệt hoặc bất kỳ game onlinen nào có đối thủ thực. Giới thiệu WebSocketsThông số kỹ thuật của WebSocket định nghĩa một kết nối API dạng “socket” (ổ cắm điện!) giữa trình duyệt và server. Theo nghĩa đen thì có 1 kết nối cố định giữa client và server và cả 2 bên có thể gửi dữ liệu bất kỳ lúc nào. Client thiết lập một kết nối WebSocket thông qua một tiến trình được gọi là WebSocket handshake (bắt tay WebSocket). Tiến trình này bắt đầu với client gửi một request HTTP thông thường đến server. Nó kèm theo header Upgrade để thông báo cho server rằng client muốn tạo một kết nối WebSocket. Cùng xem thử quá trình mở kết nối WebSocket như thế nào ở phía client: 12// Create a new WebSocket with an encrypted connection.var socket = new WebSocket('ws://websocket.example.com'); WebSocket URL sử dụng ws scheme. Chúng ta còn có cả wss cho những kết nối WebSocket bảo mật hơn, tương tự như HTTPS. Scheme này bắt đầu một tiến trình mở kết nối WebSocket đến websocket.example.com. Dưới đây là 1 ví dụ đơn giản của header của request khởi tạo. 12345GET ws://websocket.example.com/ HTTP/1.1Origin: http://example.comConnection: UpgradeHost: websocket.example.comUpgrade: websocket Nếu server hỗ trợ giao thức WebSocket, nó sẽ đồng ý để nâng cấp và giao tiếp thông qua header Upgrade trong response. Cùng xem phần thiết lập của nó trong Node.js như thế nào: 1234567891011121314151617181920212223242526272829// Chúng ta sẽ dùng https://github.com/theturtle32/WebSocket-Node// Triển khai WebSocketvar WebSocketServer = require('websocket').server;var http = require('http');var server = http.createServer(function(request, response) &#123; // xử lý HTTP request. &#125;);server.listen(1337, function() &#123; &#125;);// tạo serverwsServer = new WebSocketServer(&#123; httpServer: server&#125;);// WebSocket serverwsServer.on('request', function(request) &#123; var connection = request.accept(null, request.origin); // Đây là callback quan trọng nhất,chúng ta sẽ // xử lý thông tin của client ở đây. connection.on('message', function(message) &#123; // Xử lý thông tin WebSocket &#125;); connection.on('close', function(connection) &#123; // Đóng kết nối &#125;);&#125;); Sau khi thành lập kết nối, server trả về: 1234HTTP/1.1 101 Switching ProtocolsDate: Wed, 25 Oct 2017 10:07:34 GMTConnection: UpgradeUpgrade: WebSocket Khi kết nối đã được thiết lập, sự kiện open sẽ được bắn ra cho instance WebSocket ở phía client: 123456var socket = new WebSocket('ws://websocket.example.com');// Hiện thông báo khi kết nối WebSocket thành công.socket.onopen = function(event) &#123; console.log('WebSocket is connected.');&#125;; Giờ thì quá trình “bắt tay” đã hoàn tất, kết nối khởi tạo HTTP được thay thế bằng WebSocket và sử dụng cùng loại nền tảng kết nối TCP/IP. Tại thời điểm này, cả 2 bên đều có thể gửi dữ liệu. Với WebSocket, bạn có thể truyền bao nhiêu thông tin tùy thích mà không cần phải gánh chịu những chi phí không đáng có liên quan đến request HTTP truyền thống. Dữ liệu được truyền đi thông qua WebSocket dưới dạng tin nhắn (message), mỗi tin nhắn bao gồm một hoặc nhiều frame chứa dữ liệu bạn gửi đi (gọi là kiện hàng - payload). Để đảm bảo message có thể tái cấu trúc một cách chính xác khi nó đến với client, mỗi frame được gán cứng từ 4-12 byte thông tin về payload. Sử dụng hệ thống thông tin dựa trên frame như thế này giúp giảm tải khối lượng dữ liệu dư thừa (non-payload data) phải truyền đi, có thể làm cho độ trễ giảm đi đáng kể. Lưu ý: Đặc biệt chú ý là client chỉ được thông báo về message mới một khi tất cả frame đều được nhận và payload message gốc được tái cấu trúc đầy đủ WebSocket URLsChúng ta có đề cập sơ qua về WebSocket URL scheme ở trên. Trong thực thế, chúng giới thiệu có 2 scheme mới là ws:// và wss:// URL có cấu trúc ngữ pháp cụ thể về scheme. WebSocket URL đặc biệt vì nó không hỗ trợ nhóm ký tự anchor (có dấu thăng ở trước, ví dụ: #đây_là_anchor). Có những luật chung được áp dụng cho cả style của WebSocket URL và HTTP URL. ws không được mã hóa, nó có cổng mặc định là 80 trong khi đó wss yêu cầu mã hóa TLS và dùng cổng 443 mặc định. Framing protocol (Giao thức framing)Cùng đào sâu một chút về framing protocol với những gì RFC cung cấp: 1234567891011121314151617180 1 2 30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len | Extended payload length ||I|S|S|S| (4) |A| (7) | (16/64) ||N|V|V|V| |S| | (if payload len==126/127) || |1|2|3| |K| | |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +| Extended payload length continued, if payload len == 127 |+ - - - - - - - - - - - - - - - +-------------------------------+| |Masking-key, if MASK set to 1 |+-------------------------------+-------------------------------+| Masking-key (continued) | Payload Data |+-------------------------------- - - - - - - - - - - - - - - - +: Payload Data continued ... :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +| Payload Data continued ... |+---------------------------------------------------------------+ Theo như RFC định nghĩ về WebSocket thì nó chỉ có duy nhất một header trước mỗi gói tin, và nó khá phức tạp. Chúng ta cùng tìm hiểu: fin (1 bit): biểu thị nếu frame đó là frame cuối cùng tạo nên message. Hầu hết message đều có thể chứa trong một frame duy nhất và bit này luôn có giá trị. Thực nghiệm cho thấy Firefox tạo 1 frame thứ 2 sau mỗi 32K. rsv1, rsv2, rsv3 (Mỗi thứ 1 bit): phải bằng 0 trừ khi có một extension (đại khái như tiện ích mở rộng) được trao đổi và nó định nghĩa ý nghĩa cho giá trị khác 0. Nếu nhận về một giá trị khác 0 và không có extension nào xác định ý nghĩa của giá trị khác 0 đó được trao đổi thì người nhận cuối sẽ bị mất kết nối. opcode (4 bit): nó cho biết những gì frame đại diện. Có những giá trị sau đây được dùng: 0x00: frame này tiếp tục payload từ frame trước đó. 0x01: frame này chứa dữ liệu chữ (text). 0x02: frame này chứa dữ liệu nhị phân (binary). 0x08: frame này hủy kết nối. 0x09: frame này là ping. 0x0a: frame này là pong. (Bạn có thể thấy rằng có nhiều giá trị không sử dụng, chúng được dự trữ cho tương lai khi cần) mask (1 bit): biểu thị nếu kết nối đã được che đậy (mask). Rõ ràng là mỗi message từ client đến server phải được che đậy và về mặt kỹ thuật thì nó sẽ hủy kết nối nếu không được che đậy. payload_len (7 bit): độ dài của payload. WebSocket frame có những độ dài theo các khoảng tính theo byte như sau: 0-125 biểu thị độ dài của payload Nếu là 126 byte thì 2 byte tiếp theo biểu thị độ dài payload dưới dạng số nguyên 16bit không dấu Nếu là 127 byte thì 8 byte tiếp theo biểu thị độ dài payload dưới dạng số nguyên 64bit không dấu Vậy là độ dài payload sẽ vào khoảng ~7bit, 16bit hoặc 64bit. masking-key (32 bit): tất cả frame được gửi từ client đến server sẽ được che đậy (mask) bằng một giá trị 32bit đính kèm trong frame. payload: Dữ liệu thật sự cần được che đậy. Độ dài của nó chính là payload_len Tại sao WebSocket lại dựa trên frame (frame-based) mà không dựa trên dòng chảy (stream-based)? Có trời mới biết, tác giả cũng không biết vì sao nên nếu bạn có thông tin gì về điều này thì có thể nhắn tin đến tác giả. Ngoài ra thì có một topic thảo luận rất tốt về vấn đề này trên HackerNews, bạn có thể tham khảo. Dữ liệu trên frameNhư đã nói ở trên, dữ liệu có thể phân mảnh thành nhiều frame. Frame đầu tiên chuyển giao dữ liệu có một opcode biểu thị kiểu dữ liệu đang được truyền. Điều này cần thiết bởi vì Javascript hầu như không có hỗ trợ cho kiểu dữ liệu nhị phân (binary) khi nó được xây dựng. 0x01 biểu thị kiểu encode văn bản UTF-8, 0x02 là dữ liệu nhị phân. Đa số mọi người sẽ chuyển giao JSON trong trường hợp bạn muốn chọn opcode văn bản. Khi bạn phát tín hiệu (emit) dữ liệu nhị phân nó sẽ được thể hiện trên trình duyệt dưới dạng cụ thể là Blob. API để gửi dữ liệu thông qua WebSocket khá đơn giản: 1234var socket = new WebSocket('ws://websocket.example.com');socket.onopen = function(event) &#123; socket.send('Some message'); // Gửi dữ liệu đến server.&#125;; Khi WebSocket nhận dữ liệu (ở phía client), một sự kiện message được bắn ra. Sự kiện này bao gồm một thuộc tính gọi là data có thể dùng để truy cập nội dung của message. 12345// Xử lý message gửi đi từ server.socket.onmessage = function(event) &#123; var message = event.data; console.log(message);&#125;; Bạn có thể khám phá dữ liệu một cách dễ dàng trong mỗi frame trong kết nối WebSocket sử dụng tab Network trong Chrome DevTools: Sự phân mảnhDữ liệu payload có thể được chia thành nhiều frame riêng. Nơi nhận có nhiệm vụ lưu đệm chúng cho đến khi bit fin được set. Thế nên bạn có thể chuyển 1 chuỗi “Hello World” trong 11 gói tin của 6 (độ dài header) + 1 byte cho mỗi gói. Sự phân mảnh không được chấp nhận cho gói tin điều khiển (control packages). Tuy nhiên, đặc điểm kỹ thuật muốn bạn có thể xử lý những frame điều khiển xen kẽ nhau. Đó là trường hợp gói tin TCP nhận được có thứ tự lộn xộn. Logic để kết nối frame được mô tả sơ lược như sau: Nhận frame đầu tiên Ghi nhớ opcode Nối các frame payload lại với nhau cho đến khi bit fin được set. Giả định rằng opcode cho mỗi gói tin là 0 Mục đích chính của sự phân mảnh là cho phép gửi message khi không biết rõ kích thước ban đầu của message. Với sự phân mảnh, server có thể chọn một kích thước buffer (bộ đệm) phù hợp và khi buffer đầy thì ghi mảnh (fragment) đó vào network. Trường hợp sử dụng phụ của sự phân mảnh là truyền tin đa luồng (multiplexing), vốn dĩ không cần một message lớn trên một kênh logic để tiếp nhận toàn bộ kênh đầu ra, vì thế multiplexing cần phải giải phóng để cắt message ra thành nhiều mảnh để có thể chia sẻ đến kênh đầu ra tốt hơn. Heartbeating (nhịp tim) là gì ?Tại một thời điểm sau khi “bắt tay” (handshake), cả client và server có thể lựa chọn để gửi đi một ping đến phía kia. Khi ping được nhận, người nhận phải gửi ngược lại một pong ngay khi có thể. Đó gọi là heartbeat (nhịp tim đập). Bạn có thể dùng nó để đảm bảo client vẫn đang được kết nối. Một ping hay pong chỉ là frame bình thường, không phải frame điều khiển. Ping có opcode là 0x9 và opcode của pong là 0xA. Khi bạn nhận được ping, gửi ngược lại pong với chính xác cùng dữ liệu Payload như ping (với ping và pong thì độ dài payload tối đa là 125). Bạn cũng có thể nhận được pong mà chưa từng gửi ping. Nếu nó xảy ra thì bỏ qua, quên nó đi. Heartbeat có thể rất có ích. Có nhiều dịch vụ (chẳng hạn như bộ cân bằng tải - load balancer) sẽ hủy những kết nối đứng yên (idle). Thêm nữa, bên nhận không thể biết nếu bên kia (bên gửi) đã bị kết thúc hay chưa. Chỉ có đến lần gửi thông tin tiếp theo ta mới nhận ra có gì đó không ổn. Xử lý lỗiBạn có thể xử lý bao nhiêu lỗi xảy ra cũng được bằng cách listen đến sự kiện error.Ví dụ: 123456var socket = new WebSocket('ws://websocket.example.com');// Xử lý lỗi xảy ra.socket.onerror = function(error) &#123; console.log('WebSocket Error: ' + error);&#125;; Đóng kết nốiĐể đóng kết nổi thì client hoặc server phải gửi một frame điều khiển với dữ liệu chứa opcode 0x8. Ngay khi nhận được frame đó thì bên nhận sẽ gửi trả một frame đóng (close). Bên gửi sẽ đóng kết nối. Bất kỳ thông tin nào nhận được sau khi đóng kết nối đều bị vứt bỏ. Đây là cách bạn khởi tạo quá trình đóng kết nối WebSocket từ client: 1234// Đóng nếu kết nối đang được mở.if (socket.readyState === WebSocket.OPEN) &#123; socket.close();&#125; Để thực hiện dọn dẹp sau khi đóng kết nối thành công, bạn có thể thêm một event listener vào sự kiện close: 1234// Dọn dẹp những thứ cần thiết.socket.onclose = function(event) &#123; console.log('Disconnected from WebSocket.');&#125;; Server lắng nghe sự kiện close để xử lý nếu cần: 123connection.on('close', function(reasonCode, description) &#123; // Kết nối đang bị đóng.&#125;); So sánh WebSockets và HTTP/2Trong khi HTTP/2 cung cấp nhiều thứ, nó lại không hoàn toàn thay thế sự cần thiết cho các công nghệ push/streaming hiện có. Điều quan trọng đầu tiên về HTTP/2 mà ta cần chú ý là nó không phải là một thay thế cho tất cả HTTP. Những động từ, mã status và đa số các loại header sẽ vẫn như cũ. HTTP/2 hướng đến cải thiện sự hiệu quả trong cách mà dữ liệu truyền trên đường dây. Giờ nếu so sánh HTTP/2 với WebSocket thì ta có nhiều thứ tương đồng: HTTP/2 WebSocket Headers Được nén (HPACK) Không nén Binary Có Nhị Phân hoặc Văn Bản Multiplexing Có Có Sự ưu tiên Có Không Nén Có Có Đinh hướng Client/Server hoặc là Server Push 2 chiều Full-duplex Có Có Như đã thấy ở trên, HTTP/2 giới thiệu tính năng Server Push để cho phép server gửi tài nguyên một cách chủ động đến bộ đệm phía client. Tuy nhiên, nó không cho phép tự ý push dữ liệu xuống client. Server push chỉ được xử lý bằng browser và không được bật trong code của ứng dụng, nghĩa là không có API cho app để get thông báo từ những sự kiện như thế này. Đây là nơi Sự kiện server gửi thông tin (Server-Sent Events - SSE) trở nên rất có ích. SSE là 1 cơ chế cho phép server push dữ liệu bất đồng bộ về client một khi kết nối client-server được thiết lập. Server có thể lựa chọn để gửi dữ liệu khi nào một “cục” dữ liệu mới đã sẵn sàng. Nó có thể được cân nhắc như là mô hình đăng ký-xuất bản (publish-subscribe) 1 chiều. Nó cũng cung cấp một chuẩn Javascript client API tên là EventSource được triển khai trong đa số các trình duyệt hiện đại như là 1 phần của tiêu chuẩn HTML5 bởi W3C. Chú ý rằng trình duyệt không hỗ trợ EventSource API cũng có thể dễ dàng polyfill. Bởi vì SSE dựa trên HTTP, nó có thể phù hợp với HTTP/2 và có thể kết hợp để đạt được sự tốt nhất của cả 2 bên: HTTP/2 xử lý tầng giao vận (transport layer) hiệu quả dựa trên các luồng multiplex và SSE cung cấp API cho app để thực hiện push. Để hiểu hoàn toàn về Stream và Multiplexing, đầu tiên ta cần biết sơ lược về định nghĩa tại IETF: một “stream” là chuỗi tuần tự 2 chiều và độc lập của nhiều frame được trao đổi giữa client và server trong một kết nối HTTP/2. Mộ trong số những đặc tính chính của nó là một kết nối HTTP/2 có thể chứa đồng thời nhiều stream đang mở với frame endpoint xen kẽ từ nhiều stream. Phải nhớ rằng SSE là dựa trên HTTP. Nghĩa là với HTTP/2, không chỉ nhiều stream SSE được xen kẽ trên một kết nối TCP mà cũng cơ chế đó có thể thực hiện với sự kết hợp của nhiều stream SSE (push từ server đến client) và nhiều client request (client đến server). Nhờ ơn HTTP/2 và SSE mà giờ đây chúng ta đã có một kết nối HTTP 2 chiều thuần túy với API đơn giản để code ứng dụng có thể đăng ký cho server push. Thiếu đi khả năng giao tiếp 2 chiều thường được xem như là một bước cải lùi khi so sánh SSE với WebSocket. Cảm ơn HTTP/2, nhờ nó mà điều này không còn là vần đề nữa. Thêm nữa là nó mở ra cơ hội để bỏ qua WebSocket và tập trung vào những công nghệ thay thế dựa trên HTTP. Làm thế nào để chọn giữa WebSocket &amp; HTTP/2?WebSocket chắc chắn sẽ tồn tại trong sự thống trị của HTTP/2 + SSE, chủ yếu bởi vì nó là công nghệ đã được đón nhận và trong nhiều trường hợp cụ thể nó có sự vượt trội so với HTTP/2 như cách nó được xây dựng cho khả năng giao tiếp 2 chiều với ít chi phí tốn kém (ví dụ: headers). Giả sử bạn muốn xây dựng game MMO (Massive Multiplayer Online: Game nhiều người chơi trực tuyến) cần một lượng khổng lồ message từ cả 2 đầu kết nối. Trong những trường hợp như thế thì WebSocket thể hiện rất rất tốt. Tổng quát thì sử dụng WebSocket khi nào bạn cần một kết nối với độ trễ rất thấp, gần như là realtime giữa client &amp; server. Nhớ kỹ rằng việc này có thể yêu cầu bạn cân nhắc lại cách xây dựng ứng dụng server-side của bạn, cũng như chuyển sang tập trung vào những công nghệ như event queue. Nếu trường hợp của bạn cần hiển thị tin tức thị trường, dữ liệu thị trường, ứng dụng chat… theo thời gian thực, sử dụng HTTP/2 + SSE sẽ cung cấp cho bạn kênh giao tiếp 2 chiều hiệu quả trong khi gặt hái nhiều lợi ích khi hoạt động trong thế giới của HTTP: WebSocket thường gây ra khó khăn khi cân nhắc sự tương thích với hạ tầng web hiện tại cũng như nó nâng cấp kết nối HTTP đến một giao thức hoàn toàn khác mà không có gì dính dáng tới HTTP. Mở rộng và bảo mật: những thành phần của web (firewall, phát hiện xâm nhập, cân bằng tải) được xây dựng, bảo trì và thiết đặt với tư tưởng của HTTP, một môi trường cho ứng dụng lớn và nghiêm ngặt sẽ ưu tiên khả năng phục hồi, bảo vật và khả năng mở rộng. Bạn cũng cần phải cân nhắc về vấn đề hỗ trợ của trình duyệt: Khá tốt phải không nào? Nhưng với HTTP/2 thì không hẳn: Chỉ có TLS (Cũng không tệ lắm) Hỗ trợ một phần cho IE11 nhưng chỉ trên Windows 10 Chỉ hỗ trợ OSX 10.11 trở lên trên Safari Chỉ hỗ trợ HTTP/2 nếu bạn có thể điều hướng nó qua APLN (server của bạn cũng cần phải hỗ trợ nó rõ ràng) Hỗ trợ SSE thì tốt hơn một chút: Chỉ có IE/Edge là không hỗ trợ (Opera Mini cũng thế). Vẫn có những polyfill khá tốt để giúp chúng ta làm viêc với SSE trên IE/Edge. SessionStack lựa chọn như thế nào?Team SessionStack sử dụng cả 2 WebSocket và HTTP, tùy thuộc vào từng trường hợp. Một khi bạn đã tích hợp SessionStack vào web app của bạn, nó sẽ ghi lại mọi thứ diễn ra trên app/website: những thay đổi trên DOM, tương tác của người dùng, JS exception, stack trace, những request bị fail và cả thông báo debug, cho phép bạn chạy lại (replay) những issue đã xảy ra dưới dạng video và xem chúng diễn ra như thế nào với người dùng. Tất cả đều hoạt động theo thời gian thực (real-time) và không ảnh hưởng đến hiệu năng của webapp. Điều đó nghĩa là bạn có thể tham gia vào một phiên làm việc của user, trong khi user đang hoạt động trên trình duyệt. Trong trường hợp này, team tác giả chọn sử dụng HTTP bởi vì không cần giao tiếp 2 chiều (server chỉ cần stream dữ liệu đến trình duyệt). Nếu dùng WebSocket ở đây thì sẽ rất tệ, càng khó để bảo trì và mở rộng. Tuy nhiên, thư viện SessionStack tích hợp vào trong webapp của bạn sử dụng WebSocket (nếu có thể, còn không thì HTTP). Nó sắp xếp và gửi dữ liệu về server và cũng là giao tiếp 1 chiều. Team tác giả chọn WebSocket vì trong trường hợp này vài tính năng cần thiết sử dụng giao tiếp 2 chiều.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P4: Event loop, lập trình bất đồng bộ & 5 mẹo cải thiện Async/Await","slug":"Cach-Javascript-hoat-dong-P4-Event-loop-lap-trinh-bat-dong-bo-5-meo-cai-thien-Async-Await","date":"2018-11-13T16:34:00.000Z","updated":"2018-11-13T16:39:26.827Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P4-Event-loop-lap-trinh-bat-dong-bo-5-meo-cai-thien-Async-Await.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P4-Event-loop-lap-trinh-bat-dong-bo-5-meo-cai-thien-Async-Await.html","excerpt":"Chào các bạn đến với bài thứ 4 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Lần này chúng ta sẽ mở rộng những gì có trong bài đầu tiên bằng cách đánh giá những nhược điểm của môi trường đơn luồng (single thread) và làm thế nào để vượt qua chúng nhằm xây dựng những Javascript UI ấn tượng. Và vẫn như cũ, cuối bài viết tác giả sẽ chia sẻ 5 mẹo nhỏ để viết code tốt hơn với async/await.","text":"Chào các bạn đến với bài thứ 4 trong series đục khoét và khám phá Javascript cũng như các thành phần của nó. Trong quá trình xác định và tìm hiểu các thành phần cốt lõi, tác giả cũng chia sẻ một số nguyên tắc mà họ đang dùng để xây dựng SessionStack, một ứng dụng Javascript hướng đến sự mạnh mẽ, hiệu năng cao và ổn định. Lần này chúng ta sẽ mở rộng những gì có trong bài đầu tiên bằng cách đánh giá những nhược điểm của môi trường đơn luồng (single thread) và làm thế nào để vượt qua chúng nhằm xây dựng những Javascript UI ấn tượng. Và vẫn như cũ, cuối bài viết tác giả sẽ chia sẻ 5 mẹo nhỏ để viết code tốt hơn với async/await. Tại sao đơn luồng lại là giới hạn.Trong bài đầu tiên của series, chúng ta suy ngẫm về câu hỏi điều gì xảy ra khi chúng ta có 1 hàm trong callstack và hàm đó lại ngốn quá nhiều thời gian để thực thi. Hãy tưởng tượng, ta thực hiện một thuật toán chuyển đổi hình ảnh phức tạp chạy trên browser. Trong khi callstack đang thực thi các hàm, trình duyệt lại không thể làm gì cả, nó bị kẹt. Nghĩa là trình duyệt không thể vẽ, render, nó không thể chạy code khác, chỉ đơn giản là kẹt. Và vấn đề là ở đây, giao diện (UI) của app bạn sẽ hoạt động không hiệu quả. App của bạn bị kẹt. Trong một vài trường hợp thì đây không phải vấn đề nghiêm trọng. Tuy nhiên, có vấn đề còn lớn hơn nữa. Một khi trình duyệt của bạn xử lý quá nhiều thứ trong callstack, nó sẽ bị “đỡ” trong 1 khoảng thời gian dài. Tại thời điểm đó, đa số các browser sẽ chọn giải pháp hiện lỗi, hỏi người dùng có muốn hủy trang hiện tại không. Điều này thật là xấu xí và ảnh hưởng nghiêm trọng đến trải nghiệm (UX): Những thành phần xây dựng nên 1 chương trình JSBạn có thể viết toàn bộ code JS trong 1 file .js duy nhất nhưng chương trình của bạn chắc chắn chứa nhiều thành phần nhỏ (gọi là những block), chỉ có một số block sẽ được thực thi ngay (gọi là nhóm A) và phần còn lại thì chạy sau (nhóm B). Đơn vị block phổ biến nhất là function (hàm). Vấn đề mà đa số các developer JS mới gặp phải là họ nghĩ rằng nhóm B không cần phải được thực thi một cách nghiêm ngặt ngay sau khi thực thi nhóm A. Nói cách khác, những nhiệm vụ không được hoàn thành ngay bây giờ thì theo lỹ thuyết nó sẽ được hoàn thành một cách bất đồng bộ, nghĩa là bạn sẽ không phải gặp tình huống blocking (bị chặn) như đề cập ở trên Ví dụ: 12345// Giả sử ajax(..) là một hàm Ajax thuộc thư viện nào đóvar response = ajax('https://example.com/api');console.log(response);// `response` sẽ không chứa dữ liệu trả về Chắc bạn cũng nhận thấy rằng những request Ajax như thế này không chạy đồng bộ với nhau, nghĩa là tại thời điểm code thực thi, hàm ajax(…) chưa có dữ liệu trả về để gán vào biến response Một cách đơn giản cho thường gặp để “chờ” một hàm xử lý bất đồng bộ trả kết quả về đó là sử dụng callback: 123ajax('https://example.com/api', function(response) &#123; console.log(response); // \"response\" giờ đã có dữ liệu&#125;); Chú ý: Bạn có thể viết những Ajax request đồng bộ, tuy nhiên đừng bao giờ làm thế. Nếu bạn viết Ajax như vậy thì UI sẽ bị block cứng đơ và người dùng sẽ không thể thực hiện các hành động như click, nhập dữ liệu, điều hướng, lăn chuột… Một trải nghiệm kinh khủng. Đây là cách mà Ajax được viết đồng bộ, nhưng làm ơn, đừng bao giờ sử dụng nó trong app của bạn: 12345678// Giả sử bạn đang dùng jQueryjQuery.ajax(&#123; url: 'https://api.example.com/endpoint', success: function(response) &#123; // callback ở đây. &#125;, async: false // Một ý tưởng cực kỳ tồi tệ&#125;); Chúng ta đã sử dụng Ajax request để ví dụ. Ngoài ra bạn có thể dùng bất kỳ đoạn code nào để thực hiện bất đồng bộ. Dưới đây là ví dụ khác với hàm setTimeout(callback, milliseconds). Cách thức mà hàm setTimeout hoạt động là nó sẽ đặt 1 sự kiện (ở đây là sự kiện timeout) và để nó thực hiện sau: 123456789101112function first() &#123; console.log('first');&#125;function second() &#123; console.log('second');&#125;function third() &#123; console.log('third');&#125;first();setTimeout(second, 1000); // gọi hàm `second` sau 1000msthird(); Và đây là kết quả của đoạn code trên: 123firstthirdsecond Mổ xẻ Event Loop (vòng lặp sự kiện)Chúng ta sẽ bắt đầu với một chút “kỳ quặc” - mặc dù JS chấp nhận code chạy bất đồng bộ (như trường hợp của setTimeout) thì cho đến khi giới thiệu ES6, JS cũng không thực sự có một khái niệm trực tiếp nào về bất đồng bộ. Bộ engine JS chưa bao giờ làm gì vượt ra khỏi việc thực thi một khối lệnh trong chương trình của bạn tại 1 thời điểm cố định. Bạn có thể xem chi tiết hơn về cách engine JS (cụ thể là Google V8) hoạt động như thế nào ở bài viết trước. Vậy thì ai là người ra lệnh cho engine JS phải thực thi những khối lệnh trong chương trình? Trên thực tế, engine JS không chạy cô lập, nó hoạt động bên trong một môi trường chủ (hosting environment), môi trường này đối với đa số các developer chính là trình duyệt web hoặc Node.js. Thực ra, ngày nay, JS đã và đang được nhúng vào rất nhiều loại thiết bị khác nhau, từ robot cho tới bóng đèn. Mỗi một thiết bị có thể xem như là 1 loại khác nhau của môi trường chủ cho engine JS. Mẫu số chung của tất cả các môi trường đó là một cơ chế tích hợp sẵn được gọi là event-loop (vòng lặp sự kiện), nó xử lý quá trình thực thi của nhiều khối lệnh trong chương trình theo thời gian, mỗi lần đều gọi engine JS. Điều này nghĩa là engine JS chỉ là 1 môi trường thực thi theo yêu cầu cho bất kỳ đoạn code JS tùy ý nào. Nó chỉ là môi trường bao quanh có lịch trình cho các sự kiện (quá trình thực thi code JS). Ví dụ, khi code JS của bạn gọi Ajax request để lấy dữ liệu từ server, bạn cài đặt một đoạn code response trong một hàm (gọi là callback), và engine JS sẽ truyền đạt lại với môi trường chủ: Này, tao chuẩn bị tạm ngưng quá trình thực thi ngay bây giờ, nhưng mà khi nào mày xong việc với request đó và có một vài cục dữ liệu thì nhớ gọi lại hàm này nhé. Trình duyệt sau đó sẽ lắng nghe về response từ mạng, và khi nó có gì đó trả về cho bạn, nó sẽ lên lịch cho hàm callback được thực thi bằng cách chèn nó vào trong event loop Cùng xem sơ đồ này nào: Bạn có thể xem lại phần bài viết về Memory Heap &amp; Call Stack trong bài viết trước đây Vậy thì những Web APIs này là gì? Về bản chất, chúng là những tiến trình mà bạn không thể truy xuất (access), bạn chỉ có thể gọi nó. Chúng là những thành phần của trình duyệt mà trong đó cách xử lý đồng bộ được bắt đầu. Nếu bạn là một Node.js developer thì chúng là những C++ APIs. Vậy cuối cùng thì event loop là cái éo gì ? Event Loop có một công việc đơn giản: theo dõi Call Stack và Callback Queue (hàng đợi các hàm callback). Nếu Call Stack đang trống, nó sẽ lấy event đầu tiên từ trong hàng đợi ra và đẩy nó vảo trong Call Stack - tức là thực thi nó. Mỗi vòng lặp như thế được gọi là 1 tick trong Event Loop. Mỗi sự kiện chỉ là 1 hàm callback. 12345console.log('Hi');setTimeout(function cb1() &#123; console.log('cb1');&#125;, 5000);console.log('Bye'); Cùng thực thi đoạn code trên và xem điều gì xảy ra nào: Trạng thái đang trống, console của trình duyệt đang trống, Call Stack đang trống. console.log(‘Hi’) được thêm vào Call Stack. console.log(‘Hi’) được thực thi. console.log(‘Hi’) bị xóa khỏi Call Stack. setTimeout(function cb1() { … }) được thêm vào Call Stack. setTimeout(function cb1() { … }) được thực thi. Trình duyệt tạo một timer - vốn là một phần của Web APIs. Nó sẽ thực hiện phần đếm ngược cho bạn. The setTimeout(function cb1() { … }) được thực hiện xong và bị xóa khỏi Call Stack. console.log(‘Bye’) được thêm vào Call Stack. console.log(‘Bye’) được thực thi. console.log(‘Bye’) bị xóa khỏi Call Stack. Sau ít nhất 5000ms, timer hoàn thành công việc của nó và đẩy cb1 callback vào trong Callback Queue. Event Loop lấy cb1 từ trong Callback Queue và đưa nó vào trong Call Stack. cb1 được thực thi và nó thêm console.log(‘cb1’) vào trong Call Stack. console.log(‘cb1’) được thực thi. console.log(‘cb1’) bị xóa khỏi Call Stack. cb1 bị xóa khỏi Call Stack. Ảnh gif tổng hợp lại quá trình 16 bước ở trên: Thật thú vị khi biết rằng ES6 có mô tả event loop hoạt động như thế nào, nghĩa là về mặt kỹ thuật, nó nằm trong phạm vi trách nghiệm của một JS engine, tức là không còn chỉ đóng vai trò môi trường chủ. Một lý do chính đáng cho sự thay đổi này chính là việc giới thiệu Promise trong ES6 bởi vì promise mới cần truy xuất trực tiếp, kiểm soát tối đa lịch trình điều hành đối với event loop queue (Sau này chúng ta sẽ thảo luận chi tiết hơn) setTimeout(…) hoạt động như thế nào?Điều quan trọng cần phải biết là setTimeout(…) không tự động đặt callback vào trong event loop queue. Nó thiết lập một bộ đếm. Khi bộ đếm kết thúc, môi trường đặt callback vào trong event loop, vì thế những tick tiếp theo có thể lấy nó ra và thực thi: 1setTimeout(myCallback, 1000); Nó không có nghĩa là myCallback sẽ được thực thi sau 1000ms, mà đúng hơn là, trong 1000ms, myCallback sẽ được thêm vào trong queue. Tuy nhiên queue này có thể đang có event khác đã được thêm vào trước đó, và vì thế callback của bạn sẽ phải chờ. Có một vài bài biết hoặc bài hướng dẫn dành cho người mới bắt đầu với bất đồng bộ trong JS hướng dẫn rằng ta nên setTimeout(callback, 0). Bây giờ bạn đã biết cách event loop làm việc và cách setTimeout hoạt động rồi: gọi setTimeout với thời gian là 0 chỉ vì mục đích hoãn callback lại cho tới khi Call Stack rỗng hoàn toàn. Hãy xem ví dụ dưới đây: 12345console.log('Hi');setTimeout(function() &#123; console.log('callback');&#125;, 0);console.log('Bye'); Mặc dù thời gian chờ của callback là 0ms nhưng kết quả in ra lại như thế này: 123HiByecallback Jobs (công việc) trong ES6 là gì?Một khái niệm mới gọi là Job Queue (Hàng đợi công việc) được giới thiệu trong ES6. Nó là lớp trên cùng của event loop queue. Nhiều khả năng bạn sẽ gặp phải nó khi xử lý vấn đề liên quan đến bất đồng bộ của Promise (Chúng ta sẽ nói về nó sau). Bây giờ thì chúng ta chỉ tìm hiểu về mặt ý tưởng cơ bản để sau này khi thảo luận về bất đồng bộ với Promise, bạn có thể hiểu về những hành động đã được lên lịch và xử lý. Tưởng tượng nó như thế này: Job queue là 1 queue được gắn vào cuối mỗi tick trong event loop queue. Mỗi hành động bất đồng bộ nhất định khi xảy ra trong 1 tick sẽ không làm cho toàn bộ event được thêm vào event loop queue nhưng thay vì thế sẽ thêm 1 item (tức là job) vào cuối job queue của tick hiện tại. Điều này nghĩa là bạn có thể thêm những tính năng khác để có thể thực thi sau và bạn có thể chắc chắn rằng nó sẽ được thực thi ngay sau đó, trước bất kỳ đoạn code nào khác. Một job có thể thêm nhiều job khác vào đoạn cuối của cùng 1 queue. Trên lý thuyết, job có thể lặp (loop) vô thời hạn (một job thực hiện thêm nhiều job khác, v..v…), do đó nó sẽ làm cho chương trình bị quá tải tài nguyên cần thiết để tiếp tục chạy. Về mặt khái niệm thì điều này tương tự như một công việc có thời gian thực thi dài hoặc là một vòng lặp vô hạn (ví dụ: while(true)). Job cũng giống như trick setTimeout(callback, 0) (set thời gian bằng _0_) nhưng được triển khai theo cách có vẻ như “chính thống” hơn và có sự đảm bảo về thứ tự: thực hiện sau, nhưng phải làm ngay khi có thể. CallbacksNhư bạn đã biết, callback là cách phổ biến nhất để thể hiện &amp; quản lý sự bất đồng bộ trong JS. Rõ ràng, callback là mô hình bất đồng bộ cơ bản nhất trong JS. Vô số chương trình JS, kể cả những app tinh vi và phức tạp nhất thì cũng phải dùng tới callback. Ngoại trừ việc callback không xuất hiện mà không có thiếu sót. Nhiều developer đang cố gắng tìm kiếm những mô hình bất đồng bộ tốt hơn. Tuy nhiên, chúng ta không thể sử dụng bất kỳ phương pháp thay thế nào khác nếu như bạn chưa thực sự hiểu rõ về callback. Ở chương tiếp theo, chúng ta sẽ khám phá sâu hơn về vấn đề này để tìm hiểu tại sao những mô hình bất đồng bộ tinh vi khác (sẽ nói ở những bài sau) là cần thiết và được đề nghị nên sử dụng. Callback lồng nhau (nested callback)Xem đoạn code dưới đây: 123456789101112listen('click', function (e)&#123; setTimeout(function()&#123; ajax('https://api.example.com/endpoint', function (text)&#123; if (text == \"hello\") &#123; doSomething(); &#125; else if (text == \"world\") &#123; doSomethingElse(); &#125; &#125;); &#125;, 500);&#125;); Chúng ta có 3 hàm lồng nhau, mỗi hàm thể hiện 1 bước trong chuỗi bất đồng bộ. Kiểu code như thế này thường được gọi là callback hell. Nhưng callback hell thực sự không phải vấn đề về lồng nhau hay cách dòng, thụt lề. Câu chuyện thực sự sâu xa hơn thế nhiều. Đầu tiên, chúng ta listen một event click, sau đó thì chờ timer hoạt động, rồi cuối cùng là chờ cho Ajax trả kết quả về và quá trình này có thể lặp lại nhiều lần mỗi khi chúng ta click. Thoạt nhìn đoạn code này thể hiện sự đồng bộ một cách tự nhiên theo thứ tự các bước như sau: 123listen('click', function (e) &#123; // ..&#125;); …rồi sau đó: 123setTimeout(function()&#123; // ..&#125;, 500); …tiếp theo là: 123ajax('https://api.example.com/endpoint', function (text)&#123; // ..&#125;); …và cuối cùng: 123456if (text == \"hello\") &#123; doSomething();&#125;else if (text == \"world\") &#123; doSomethingElse();&#125; Chà, đúng là một cách thể hiện code bất đồng bộ một cách rất tự nhiên, phải không nào? cười PromisesCùng xem đoạn code sau: 123var x = 1;var y = 2;console.log(x + y); Rất rõ ràng rằng nó tính tổng của x và y rồi in kết quả ra console. Tuy nhiên, nếu như giá trị của x và y chưa tồn tại và vẫn còn đang chờ để được xác định thì sao? Giả sử chúng ta cần lấy giá trị của x và y từ server trước khi chúng được dùng để tính tổng.Tưởng tượng rằng chúng ta có một hàm loadX và loadY để thực hiện load dữ liệu cho x và y từ server và một hàm để tính tổng 2 số sau khi chúng được load xong.Đoạn code sẽ giống như thế này (xấu xí và phức tạp, phải không nào?): 123456789101112131415161718192021222324252627function sum(getX, getY, callback) &#123; var x, y; getX(function(result) &#123; x = result; if (y !== undefined) &#123; callback(x + y); &#125; &#125;); getY(function(result) &#123; y = result; if (x !== undefined) &#123; callback(x + y); &#125; &#125;);&#125;// Một hàm đồng bộ hoặc bất đồng bộ để get giá trị của \"x\"function fetchX() &#123; // ..&#125;// Một hàm đồng bộ hoặc bất đồng bộ để get giá trị của \"y\"function fetchY() &#123; // ..&#125;sum(fetchX, fetchY, function(result) &#123; console.log(result);&#125;); Có một điều quan trọng cần phải nêu lên ở đây: trong đoạn code trên, chúng ta xem x và y như những giá trị tương lai và hàm sum() không quan tâm về việc x hay y hay cả 2 biến có hay không có tồn tại giá trị. Dĩ nhiên là cách tiếp cận thô dựa trên callback này cho ta nhiều thứ đáng mong đợi. Đây chỉ là 1 bước tiến nhỏ để hiểu về ích lợi của giá trị tương lai mà không cần lo lắng về khía cạnh thời gian khi chúng sẵn có. Giá trị của PromiseCùng xem ví dụ về x + y được thực hiện với Promise: 12345678910111213141516171819202122232425function sum(xPromise, yPromise) &#123; // `Promise.all([ .. ])` nhận vào 1 mảng các promise, // và trả về 1 promise chờ đợi tất cả chúng hoàn thành return Promise.all([xPromise, yPromise]) // khi một promise được phân giải (resolve), // ta lấy giá trị x, y trả về và cộng chúng lại. .then(function(values)&#123; // `values` là mảng chứa giá trị của các object // từ những promise đã được resolve return values[0] + values[1]; &#125; );&#125;// `fetchX()` và `fetchY()` trả về promise // chứa kết quả tương ứng, có thể có // luôn hoặc chờ sau mới có dữ liệusum(fetchX(), fetchY())// Ta có 1 promise cho tổng của 2 số.// Giờ thì gọi mắt xích (chain-call) hàm `.then(...)` để chờ // kết quả của promise trả về..then(function(sum)&#123; console.log(sum);&#125;); Có 2 lớp Promise trong đoạn code này. fetchX() và fetchY() được gọi trực tiếp và giá trị trả về của chúng (promise!) được đẩy vào hàm sum(…). Giá trị mà những promise này thể hiện có thể sẵn sàng để dùng ngay lúc gọi hàm hoặc là sau đó 1 chút nhưng bất kể sớm hay muộn thì mỗi promise đều chuẩn hóa hành vi của nó cho giống nhau. Chúng ta suy đoán về giá trị của x và y theo hướng độc lập thời gian. Theo chu kỳ, chúng là những giá trị tương lai. Lớp thứ 2 là promise do hàm sum(…) tạo ra (thông qua Promise.all([ … ])) và trả về, và cũng chờ nó get giá trị khi gọi .then(…). Khi hàm sum(…) hoàn tất, tổng giá trị tương lai đã sẵn sàng và có thể in nó ra. Chúng ta ẩn phần logic chờ giá trị tương lai của x và y trong hàm `sum(…). Lưu ý: Bên trong sum(…), lời gọi đến Promise.all([ … ]) tạo một promise (cái này sẽ gọi đến xPromise và yPromise rồi phân giải chúng). Chain-call đến .then() sẽ tạo ra 1 promise khác và promise này sẽ trả về values[0] + values[1] ngay khi resolve (với giá trị kết quả của phép cộng). Do đó lời gọi .then(…) ta đặt ở cuối hàm .sum(…), tức là cuối đoạn code, thực ra là xử lý trên giá trị trả về của promise thứ 2 hơn là promise thứ nhất được tạo ra bởi Promise.all([ … ]). Mặc dù vậy thì chúng ta không chain-call vào cuối hàm .then(…) sau vì làm vậy sẽ tạo thêm 1 promise và ta lại phải xử lý nó. Phần Promise chain-call này sẽ được giải thích kỹ hơn ở các phần sau trong chương này. Với Promise, lời gọi .then(…) có thể nhận 2 hàm param, hàm thứ nhất là để thực hiện thao tác với response hoàn thành (như trên), hàm thứ 2 là với trường hợp bị lỗi và bác bỏ (rejection). 1234567891011sum(fetchX(), fetchY()).then( // Hàm xử lý hoàn thành function(sum) &#123; console.log( sum ); &#125;, // Hàm xử lý bác bỏ function(err) &#123; console.error( err ); // bummer! &#125;); Nếu có gì đó không đúng trong quá trình get x và y hoặc là có sai sót khác thì promise mà .sum(…) trả về sẽ bị reject, hàm callback thứ 2 xử lý lỗi đã được đẩy vào .then(…) sẽ nhận giá trị reject từ promise. Bởi vì promise đóng gói trạng thái độc lập thời gian từ bên ngoài - chờ cho giá trị được xử lý hoàn thành/reject, và bản thân promise đã là độc lập thời gian, do đó nhiều promise có thể được kết hợp với nhau theo những cách có thể đoán trước được bất kể là thời gian hay kết quả. Hơn nữa, một khi promise được resolve thì nó sẽ tồn tại vĩnh viễn: nó trở thành một giá trị bất biến tại thời điểm đó, và có thể được lấy ra sử dụng bao nhiêu lần cũng được Thực sự là rất hữu ích khi ta nối promise thanhf 1 chuỗi: 12345678910111213141516171819function delay(time) &#123; return new Promise(function(resolve, reject)&#123; setTimeout(resolve, time); &#125;);&#125;delay(1000).then(function()&#123; console.log(\"after 1000ms\"); return delay(2000);&#125;).then(function()&#123; console.log(\"after another 2000ms\");&#125;).then(function()&#123; console.log(\"step 4 (next Job)\"); return delay(5000);&#125;)// ... Gọi hàm delay(2000) sẽ tạo ra 1 promise mà nó được hoàn thành trong 2000ms, sau đó trả nó về từ hàm hoàn thành trong .then() đầu tiên, điều này làm cho hàm .then(…) thứ hai sẽ chờ 2000ms Lưu ý: Bởi vì giá promise là bất biến sau khi đã được resolve, chúng ta có thể truyền nó đi khắp nơi mà không cần lo lắng về việc nó bất ngờ bị thay đổi. Điều này đặc biệt có ích khi có nhiều đoạn code cùng sử dụng kết quả của 1 promise. Tính bất biến nghe có vẻ như là một chủ đề liên quan đến học thuật, nhưng thật ra nó là 1 phần rất cơ bản và có khía cạnh quan trọng trong thiết kế promise mà ta không nên bỏ qua. Promise hay không Promise ?Một chi tiết quan trọng về promise là phải biết một giá trị thực sự là promise hay không phải. Nói cách khác, đó có phải là 1 giá trị sẽ hành xử như 1 promise? Chúng ta biết rằng promise được xây dựng bằng lệnh new Promise(…), và bạn cho rằng p instanceof Promise là đủ để kiểm tra? Thực ra thì không hẳn. Chủ yếu bởi vì bạn có thể nhận giá trị promise từ một cửa sổ trình duyệt khác (ví dụ: iframe), nó sẽ có promise riêng của nó, khác với promise trong cửa sổ/frame hiện tại của bạn, và câu lệnh check ở trên sẽ fail khi xác định instance của promise. Hơn nữa, một thư viện hay framework có thể sử dụng promise của riêng nó mà không dùng promise mặc định của ES6. Thật ra, bạn có thể dùng promise của thư viện trên những trình duyệt cũ không hỗ trợ promise. Nuốt chửng ngoại lệ (exception)Nếu trong quá trình tạo promise hoặc là khi tiếp nhận kết quả từ nó, một lỗi biệt lệ JS xảy ra, ví dụ như TypeError hoặc ReferenceError, exception sẽ được bắt, khi đó nó sẽ ép (force) cho promise đang chạy bị reject. Ví dụ: 1234567891011121314var p = new Promise(function(resolve, reject)&#123; foo.bar(); // `foo` chưa được định nghĩa, lỗi! resolve(374); // Code sẽ không đến được đây :(&#125;);p.then( function fulfilled()&#123; // không đến đây luôn :( &#125;, function rejected(err)&#123; // `err` sẽ là một object của exception`TypeError` // từ dòng `foo.bar()`. &#125;); Nhưng nếu như một promise được hoàn thành nhưng có lỗi exception JS trong quá trình tiếp nhận (ví dụ như trong callback của .then(…) )? Kể cả như thế thì nó cũng không bị mất, bạn sẽ thấy một chút ngạc nhiên khi biết cách mà chúng được xử lý. Đào sâu thêm 1 tí nào: 123456789101112var p = new Promise( function(resolve,reject)&#123; resolve(374);&#125;);p.then(function fulfilled(message)&#123; foo.bar(); console.log(message); // không đến được đây nè.&#125;, function rejected(err)&#123; // không đến được đây nè. &#125;); Có vẻ như exception từ foo.bar() thực sự đã bị nuốt trôi (swallow). Đúng là như thế. Có gì đó sâu hơn bên trong đã hoạt động sai tuy nhiên chúng ta lại không biết. Lời gọi p.then(…) cho chính nó trả về 1 promise khác và nó sẽ bị reject với ReferenceError exception. Xử lý những biệt lệ không bị bắt (Uncaught exception)Có nhiều cách tiếp cận khác mà nhiều người cho rằng sẽ tốt hơn. Một đề nghị phổ biến đó là promise nên có thêm một phương thức done(…), nó sẽ đánh dấu chuỗi promise là đã xong (done). .done(…)không tạo ra và trả về một promise vì thế callback truyền qua .done(…) rõ ràng là không liên quan đến việc báo cáo các vấn đề xảy ra với một chuỗi promise không tồn tại. Nó hoạt động giống như bạn đã biết trong các điều kiện uncaught error: các exception bên trong một hàm reject trong .done(…) sẽ bị bắn ra ngoài developer console dưới dạng global uncaught error. 12345678910var p = Promise.resolve(374);p.then(function fulfilled(msg)&#123; // Số number không có hàm của string, // nên sẽ bắn ra lỗi console.log(msg.toLowerCase());&#125;).done(null, function() &#123; // Nếu có uncaught exception ở đây thì nó sẽ bị bắn ra như là một global exception&#125;); Điều gì xảy ra trong ES8 và Async/awaitJavascript ES8 giới thiệu async/await để giúp cho công việc xử lý promise dễ dàng hơn. Chúng ta sẽ lướt sơ qua những khả năng mà async/await cung cấp và xem thử làm thế nào để dùng chúng để viết code bất đồng bộ một cách phù hợp. Vậy thì đầu tiên là xem thử hoạt động của async/await. Bạn định nghĩa một hàm bất đồng bộ sử dụng định nghĩa hàm async. Những hàm như vậy sẽ trả về object AsyncFunction. Object AsyncFunction biểu diễn hàm bất đồng bộ trong đó nó thực thi code bên trong nó. Khi một hàm async được gọi, nó sẽ trả về Promise. Khi hàm async trả về giá trị, nó lại không phải promise, một promise sẽ được tạo ra tự động và được phân giải (resolve) với giá trị trả về từ hàm. Khi hàm async bắn ra exception, promise sẽ reject với giá trị bắn ra. Một hàm async có thể chứa thể hiện await, nó sẽ dừng quá trình thực thi của hàm và đợi cho promise giải quyết xong rồi quay lại thực thi tiếp và trả về giá trị đã được resolve. Bạn có thể xem như promise trong JS tương tự với Java Future hay C# Task. Mục đích của async/await là làm đơn giản hóa quá trình sử dụng promise. Xem ví dụ sau: 12345678// Hàm JS bình thườngfunction getNumber1() &#123; return Promise.resolve('374');&#125;// Giống như hàm trênasync function getNumber2() &#123; return 374;&#125; Tương tự, những hàm bắn ra exception tương tự với những hàm trả về promise bị reject: 123456function f1() &#123; return Promise.reject('Some error');&#125;async function f2() &#123; throw 'Some error';&#125; Từ khóa await chỉ có thể được dùng bên trong hàm async và cho phép bạn chờ promise một cách đồng bộ. Nếu chúng ta sử dụng promise bên ngoài một hàm async thì phải dùng tới callback: 1234567891011121314async function loadData() &#123; // `rp` là một hàm gọi promise. var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // Hiện tại cả 2 request đều được gọi đồng thời và // ta phải đợi cho nó hoàn thành. var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;&#125;// Bởi vì ta không ở trong hàm `async` // nên chúng ta phải dùng `then()`.loadData().then(() =&gt; console.log('Done')); Bạn có thể định nghĩa hàm async bằng cách sử dụng async function expression (AFE - Thể hiện hàm async). Một AFE tương tự và gần giống như một async function statement (AFS). Điểm khác biệt chính giữa AFE và AFS là tên của hàm, trong AFE ta có thể bỏ qua tên để tạo hàm vô danh (anonymous function). Một AFE có thể sử dụng như một IIFE (Immediately Invoked Function Expression), loại hàm được thực thi ngay sau khi nó được định nghĩa. Nó trông như thế này: 1234567891011var loadData = async function() &#123; // `rp` là một hàm gọi promise. var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // Hiện tại cả 2 request đều được gọi đồng thời và // ta phải đợi cho nó hoàn thành. var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;&#125; Quan trọng là async/await được hỗ trợ và có thể chạy trên đa số các trình duyệt: Nếu như trình duyệt nào không hỗ trợ thì ta vẫn có thể sử dụng các JS transpiler như Babel hay TypeScript Cuối cùng thì điều quan trọng nhất là không nên chọn lựa một cách mù quáng những cách tiếp cận “mới nhất” để viết code bất đồng bộ. Tốt hơn là bạn hiểu về cấu trúc bất đồng bộ của JS, nghiên cứu tại sao nó lại là một vấn đề nghiêm túc và hiểu một cách sâu sắc về các thành phần bên trong của giải pháp mà bạn lựa chọn. Mỗi cách tiếp cận khác nhau đều có những điểm mạnh và điểm yếu, hãy cân nhắc. 5 mẹo để viết code bất đồng bộ vừa chắc chắn vừa dễ bảo trì1. Clean code (code sạch):Sử dụng async/await cho phép bạn viết code ít hơn nhiều. Mỗi lần sử dụng async/await bạn có thể bỏ qua một số bước không cần thiết, ví dụ: .then(), viết hàm anonymous để xử lý responsive, đặt tên response từ callback… 1234// `rp` là một hàm gọi promiserp(‘https://api.example.com/endpoint1').then(function(data) &#123; // …&#125;); …so với 12// `rp` là một hàm gọi promisevar response = await rp(‘https://api.example.com/endpoint1'); 2. Xử lý lỗi:Async/await giúp chúng ta có thể xử lý cả lỗi đồng bộ và bất đồng bộ với cùng một cấu trúc code: chính là try/catch nổi tiếng. Ví dụ: 123456789101112function loadData() &#123; try &#123; // Catches synchronous errors. getJSON().then(function(response) &#123; var parsed = JSON.parse(response); console.log(parsed); &#125;).catch(function(e) &#123; // Catches asynchronous errors console.log(e); &#125;); &#125; catch(e) &#123; console.log(e); &#125;&#125; …so với 12345678async function loadData() &#123; try &#123; var data = JSON.parse(await getJSON()); console.log(data); &#125; catch(e) &#123; console.log(e); &#125;&#125; 3. Điều kiện:Viết code điều kiện với async/await rõ ràng hơn rất nhiều: 123456789101112131415function loadData() &#123; return getJSON() .then(function(response) &#123; if (response.needsAnotherRequest) &#123; return makeAnotherRequest(response) .then(function(anotherResponse) &#123; console.log(anotherResponse) return anotherResponse &#125;) &#125; else &#123; console.log(response) return response &#125; &#125;)&#125; …so với 1234567891011async function loadData() &#123; var response = await getJSON(); if (response.needsAnotherRequest) &#123; var anotherResponse = await makeAnotherRequest(response); console.log(anotherResponse) return anotherResponse &#125; else &#123; console.log(response); return response; &#125;&#125; 4. Stack Frames:Không giống như async/await, stack lỗi trả về từ một chuỗi promise làm chúng ta không biết lỗi xuất phát từ đâu mà lần: 1234567891011121314function loadData() &#123; return callAPromise() .then(callback1) .then(callback2) .then(callback3) .then(() =&gt; &#123; throw new Error(\"boom\"); &#125;)&#125;loadData() .catch(function(e) &#123; console.log(err);// Error: boom at callAPromise.then.then.then.then (index.js:8:13)&#125;); …so với 1234567891011121314async function loadData() &#123; await callAPromise1() await callAPromise2() await callAPromise3() await callAPromise4() await callAPromise5() throw new Error(\"boom\");&#125;loadData() .catch(function(e) &#123; console.log(err); // output // Error: boom at loadData (index.js:7:9)&#125;); 5. Quá trình Debug:Nếu bạn đã từng sử dụng promise, bạn sẽ biết rằng debug với chúng thực sự là ác mộng. Giả sử bạn đặt breakpoint bên trong .then() và dùng những lệnh debug như stop-over, debugger sẽ không đi đến .then() tiếp theo bởi vì nó “lỡ chân” bước vào code bất đồng bộ.Với async/await bạn có thể duyệt qua những lời gọi await chính xác như những hàm đồng bộ thông thường. Viết code Javascript bất đồng bộ là rất quan trọng không chỉ cho app mà cả cho những thư viện nữa.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P3: Quản lý bộ nhớ & 4 trường hợp memory leaks phổ biến","slug":"Cach-Javascript-hoat-dong-P3-Quan-ly-bo-nho-4-truong-hop-memory-leaks-pho-bien","date":"2018-11-13T16:03:00.000Z","updated":"2018-11-13T16:05:48.137Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P3-Quan-ly-bo-nho-4-truong-hop-memory-leaks-pho-bien.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P3-Quan-ly-bo-nho-4-truong-hop-memory-leaks-pho-bien.html","excerpt":"Mấy hôm trước chúng ta đã bắt đầu series bài viết đục khoét về Javascript và cách nó hoạt động như thế nào, bằng cách hiểu về những thành phần cơ bản và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và ngon hơn. Bài đầu tiên là tổng quan về series, cung cấp cái nhìn toàn cảnh về engine, runtime &amp; callstack. Bài thứ 2 là một cái nhìn cụ thể hơn về những thành phần bên trong của bộ engine V8 của Google và một số mẹo vặt để tối ưu Javascript code. Ở bài thứ 3 này, chúng ta sẽ thảo luận về một vấn đề không kém phần quan trọng nhưng lại thường bị các dev bỏ qua do sự phức tạp ngày càng gia tăng của các ngôn ngữ lập trình thường dùng: quản lý bộ nhớ. Chúng ta cũng sẽ tìm hiểu một số mẹo để có thể xử lý những trường hợp rò rì bộ nhớ của Javascript mà team SesstionStack đã áp dụng để tránh bị rò rỉ và không làm tốn bộ nhớ của webapp.","text":"Mấy hôm trước chúng ta đã bắt đầu series bài viết đục khoét về Javascript và cách nó hoạt động như thế nào, bằng cách hiểu về những thành phần cơ bản và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và ngon hơn. Bài đầu tiên là tổng quan về series, cung cấp cái nhìn toàn cảnh về engine, runtime &amp; callstack. Bài thứ 2 là một cái nhìn cụ thể hơn về những thành phần bên trong của bộ engine V8 của Google và một số mẹo vặt để tối ưu Javascript code. Ở bài thứ 3 này, chúng ta sẽ thảo luận về một vấn đề không kém phần quan trọng nhưng lại thường bị các dev bỏ qua do sự phức tạp ngày càng gia tăng của các ngôn ngữ lập trình thường dùng: quản lý bộ nhớ. Chúng ta cũng sẽ tìm hiểu một số mẹo để có thể xử lý những trường hợp rò rì bộ nhớ của Javascript mà team SesstionStack đã áp dụng để tránh bị rò rỉ và không làm tốn bộ nhớ của webapp. Tổng quanNhững ngôn ngữ như C có bộ quản lý bộ nhớ level thấp khá cơ bản là malloc() và free(). Những phương thức này được sử dụng để cấp phát một cách tường minh và giải phóng bộ nhớ trên hệ điều hành. Một cách tương tự, Javascript cấp phát bộ nhớ khi object, string, … được tạo ra và tự động giải phóng nó mỗi khi không được sử dụng nữa bởi một tiến trình dọn rác (garbage collection). Quá trình giải phóng tài nguyên một cách tự động hóa như thế này gây ra sự nhầm lẫn và làm cho Javascript (và những ngôn ngữ bậc cao khác) developer cảm thấy “ấn tượng” nên họ thường bỏ qua vấn đề quản lý bộ nhớ. Đây là một sai lầm lớn. Kể cả khi làm việc với ngôn ngữ bậc cao, developer cũng nên hiểu về vấn đề quản lý bộ nhớ (ít nhất là những thứ cơ bản). Thỉnh thoảng có những vấn đề xảy ra với quản lý bộ nhớ tự động (bug hay sự giới hạn thực hiện trong GC…) mà developer cần phần hiểu để có thể xử lý một cách đúng đắn (hoặc tìm cách “đi đường vòng” vượt qua nó với ít thiệt hại nhất). Vòng đời của bộ nhớDù cho bạn đang dùng ngôn ngữ lập trình nào đi nữa thì vòng đời bộ nhớ hầu như đều giống nhau: Đây là những gì xảy ra ở mỗi bước trong vòng đời: Cấp phát bộ nhớ: bộ nhớ được cấp phát bởi hệ điều hành và cho phép chương trình sử dụng nó. Ở ngôn ngữ bậc thấp (như C), đây là một quá trình tường minh, rõ ràng mà developer phải xử lý. Trong các ngôn ngữ bậc cao thì phần này ngôn ngữ sẽ làm giúp bạn. Sử dụng bộ nhớ: Đây là thời điểm khi chương tình của bạn sử dụng những vùng nhớ đã được cấp phát trước đó. Các thao tác Đọc và Ghi được thực hiện khi chúng ta thực thi những biến đã được khai báo trong code. Giải phóng bộ nhớ: Giờ là lúc giải phóng toàn bộ những vùng nhớ mà bạn không còn dùng đến nữa để sử dụng lại về sau. Giống như phần cấp phát, bước này được thực hiện một cách tường minh trong các ngôn ngữ bậc thấp. Để hiểu thêm về các khái niệm của callstack và heap thì mời bạn xem lại Phần 1 của series. Bộ nhớ là gì?Trước khi đi sâu vào bộ nhớ của Javascript, chúng ta sẽ duyệt sơ qua bộ nhớ cơ bản và cách hoạt động của nó. Ở phần cứng, bộ nhớ máy tính bao gồm một cơ số các flip flops (đại khái là 1 trạng thái đóng-mở). Mỗi flip-flop chứa một vài transistor và có thể lưu trữ 1 bit thông tin. Một flip-flop độc lập có thể được truy xuất bằng số định danh duy nhất (unique identifier), do đó chúng ta có thể đọc và ghi lên chúng. Và lẽ dĩ nhiên, về mặt ý tưởng chúng ta có thể công nhận rằng toàn bộ bộ nhớ máy tính là 1 mảng khổng lồ các bit có thể đọc &amp; ghi. Về phần con người thì họ không giỏi làm việc với bit nên tổ chức chúng vào những nhóm lớn hơn, 8 bit thành 1 byte. Ngoài byte còn có word (16 hoặc 32 bit) Có rất nhiều thứ được lưu trữ trong bộ nhớ: Tất cả các biến và dữ liệu được sử dụng trong các chương trình. Code của chương trình chạy, kể cả code của hệ điều hành. Trình biên dịch và hệ điều hành làm việc với nhau để xử lý hầu như toàn bộ phần quản lý bộ nhớ nhưng chúng tôi khuyến cáo bạn nên có cái nhìn sơ lược về những gì xảy ra ở nội bộ bên trong. Khi biên dịch code, trình biên dịch sẽ xem xét các kiểu dữ liệu nguyên thủy (string, number, boolean…) và tính toán trước bao nhiêu bộ nhớ mà chúng cần sử dụng. Lượng bộ nhớ cần thiết sau đó sẽ được cấp phát cho chương tình trong không gian callstack. Vùng không gian được cấp phát được gọi là stack space bởi vì khi gọi hàm, bộ nhớ của nó được thêm vào vị trí trên cùng của bộ nhớ hiện tại. Và khi hủy bỏ, chúng bị gỡ bỏ theo quy tắc LIFO (last-in-first-out, vào sau ra trước). Ví dụ: 123int n; // 4 bytesint x[4]; // mảng 4 phần tử, mỗi phần tử 4 bytesdouble m; // 8 bytes Trình biên dịch sẽ tính toán ngay lập tức đoạn code này cần 4 + 4 * 4 + 8 = 28 bytes Đó là cách hoạt động của kích thước vùng nhớ cho kiểu số integer và double. Khoảng 20 năm trước, integer là 2 byte và double là 4 byte. Code của bạn không phải phụ thuộc vào kích thước của các kiểu dữ liệu cơ bản. Trình biên dịch sẽ chèn code tương tác với hệ điều hành để yêu cầu số lượng byte cần thiết để lưu trữ các biến. Trong ví dụ trên, trình biên dịch biết chính xác bao nhiêu bộ nhớ cần thiết cho mỗi biến. Thực tế thì mỗi khi ghi dữ liệu vào biến n, nó sẽ được dịch nội bộ thành mộ thứ đại loại như “địa chỉ vùng nhớ 4127963” Để ý rằng nếu ta thử truy xuất x[4] thì ta sẽ truy xuất nhầm sang dữ liệu đang liên kết với m. Bởi vì chúng ta đang cố truy xuất vào một phần tử không tồn tại trong mảng: 4 byte này nằm ngoài vùng x[3] vốn là vùng nhớ được cấp phát cuối cùng của mảng (index đánh từ 0 :v), và vậy là có thể ta đọc/ghi nhầm sang các bit của biến m. Điều này có thể gây ra nhiều hậu quả không mong muốn cho toàn bộ chương trình. Xem hình cho rõ hơn nhé: Khi một hàm gọi một hàm khác thì mỗi hàm sẽ chiếm một phần của stack. Phần đó sẽ lưu giữ tất cả những biến cục bộ cũng như một bộ đếm để ghi nhớ vị trí mà quá trình thực thi của hàm dừng lại. Khi hàm kết thúc thì vùng bộ nhớ lại được giải phóng cho thằng khác dùng. Cấp phát độngThật không may là mọi thứ dường như không dễ như ta tưởng khi mà ta không biết bao nhiêu bộ nhớ 1 biến có thể cần tại thời điểm thực thi. Giả sử chúng ta muốn làm như sau: 123int n = readInput(); // đọc input từ người dùng...// tạo 1 mảng với \"n\" phần tử Tại thời điểm biên dịch, trình biên dịch không biết mảng sẽ cần bao nhiêu bộ nhớ bởi vì nó được xác định bởi dữ liệu nhập vào từ phía người dùng. Vì thế nó không thể cấp phát vùng nhớ cho biến trên stack. Thay vì thế, chương trình của chúng ta cần hỏi hệ điều hành về kích thước bộ nhớ phù hợp trong khi thực thi (run-time). Vùng nhớ này được gán từ không gian heap. Sự khác biệt giữa cấp phát bộ nhớ động và tĩnh được tổng kết trong bảng sau: Cấp phát tĩnh Cấp phát động Biết kích thước tại thời điểm biên dịch. Không biết kích thức lúc biên dịch Thực hiện lúc biên dịch Thực hiện lúc thực thi (runtime) Gán vào stack Gán vào heap Gán theo thứ tự FILO (first-in-last-out) Gán không theo thứ tự cụ thể nào cả Để có thể có cái nhìn sâu sắc về cấp phát bộ nhớ động, có thể chúng ta cần dành thêm thời gian tìm hiểu về con trỏ, nhưng như vậy thì hơi bị lạc đề. Nếu bạn thấy có hứng thú với chủ đề này thì xin lỗi phải hẹn bạn trong 1 bài viết khác rồi. Cấp phát trong JavascriptJavascript giúp developer giảm bớt trách nhiệm trong việc cấp phát bộ nhớ. JS tự làm hết mọi thứ. 123456789101112131415var n = 374; // cấp phát bộ nhớ cho sốvar s = 'sessionstack'; // cấp phát cho string var o = &#123; a: 1, b: null&#125;; // cấp phát cho object và các thuộc tính của nóvar a = [1, null, 'str']; // (giống như object) cấp phát cho // mảng và các giá tị của nófunction f(a) &#123; return a + 3;&#125; // cấp phát cho hàm (là 1 object có thể thực thi)// function expressions cũng cấp phát objectsomeElement.addEventListener('click', function() &#123; someElement.style.backgroundColor = 'blue';&#125;, false); Một vài lời gọi hàm cũng trả về dạng cấp phát object: 12var d = new Date(); // cấp phát Date objectvar e = document.createElement('div'); // cấp phát 1 phần tử DOM Phương thức có thể cấp phát giá trị hoặc object: 12345678910var s1 = 'sessionstack';var s2 = s1.substr(0, 3); // s2 là 1 string mới// Bởi vì string là bất biến, // JavaScript có thể chọn không cấp phát bộ nhớ// mà lưu trữ phạm vi [0, 3]var a1 = ['str1', 'str2'];var a2 = ['str3', 'str4'];var a3 = a1.concat(a2); // mảng mới gồm 4 phần tử là// sự kết hợp của mảng a1 và a2 Sử dụng bộ nhớ trong JavascriptSử dụng bộ nhớ đã được cấp phát trong Javascript có thể gói gọn một cách đơn giản trong 2 chữ đọc/ghi Việc này có thể thực hiện bằng cách đọc/ghi giá trị của biến hoặc thuộc tính của object hoặc truyền đối số (argument) vào 1 hàm. Giải phóng khi không dùng bộ nhớ nữaĐa số các phần đề về quản lý bộ nhớ xảy ra ở giai đoạn này. Công việc khó nhất ở đây là tìm hiểu khi nào bộ nhớ đã được cấp phát có còn được sử dụng hay không. Thường thì nó yêu cầu developer xác định vùng nhớ nào trong chương trình không dùng nữa và giải phóng nó. Ngôn ngữ bậc cao thêm vào 1 chương tình gọi là bộ dọn rác (garbage collector - GC) thực hiện công việc đi tìm những vùng nhớ đã được cấp phát và tìm hiểu xem nó còn được sử dụng hay không, nếu không dùng nữa thì sẽ tự động giải phóng nó. Điều hơi chuối là tiến trình này chỉ tương đối đúng, bởi vì vấn đề tổng quát về việc xác định một vùng nhớ có còn được sử dụng hay không là bất khả thi (không thể thực hiện bằng thuật toán). Đa số GC hoạt động bằng cách thu thập những vùng nhớ không còn bị truy xuất đến, ví dụ: tất cả biến đang trỏ đến nó đều đi ra khỏi phạm vi thực thi. Tuy nhiên, điều này cũng lại không hẳn là chính xác vì tại bất kỳ thời điểm nào một địa chỉ vùng nhớ đều có thể được trỏ tới bởi 1 biến, nhưng biến đó lại không bao giờ được sử dụng nữa. Quá trình dọn rácRõ ràng cách thức để tìm được vùng nhớ “không còn dùng nữa” là bất khả thi cho nên GC thực hiện một giải pháp hạn chế cho vấn đề chung. Phần này sẽ giải thích những khái niệm cần thiết để bạn có thể hiểu được những thuật toán GC và các giới hạn của chúng. Tham chiếu bộ nhớÝ tưởng chính của những thuật toán GC dựa trên tham chiếu Trong ngữ cảnh quản lý bộ nhớ, một object A tham chiếu đến object B khác nếu như A có truy xuất đến B (có thể tường minh hoặc không tường minh). Ví dụ: một Javascript object có tham chiếu đến prototype của chính nó (không tường minh) và tham chiếu đến giá trị của thuộc tính của nó (tường minh). Trong trường hợp này, khái niệm của 1 “object” được mở rộng thành một thứ gì đó hơn là JS object thông thường và bao trùm cả function scope (hoặc là lexical scope toàn cục). Lexical scoping định nghĩa cách mà những tên biến được phân giải trong các hàm lồng nhau: những hàm con chưa scope của hàm cha kể cả khi hàm cha đã được return. Bộ đếm tham chiếuĐây là thuật toán dọn rác đơn giản nhất. Một object được đánh giá là “rác có thể dọn” nếu như không có tham chiếu nào trỏ đến nó. Ví dụ: 123456789101112131415161718192021222324252627var o1 = &#123; o2: &#123; x: 1 &#125;&#125;;// Tạo 2 object// 'o1' tham chiếu đến 'o2' vì nó là 1 thuộc tính của 'o1'// Hiện tại không có rác để dọn.var o3 = o1; // biến 'o3' đang tham chiếu tới cùng 1 object với 'o1'o1 = 1; // giờ thì object được tham chiếu trước đó bởi 'o1' // chỉ còn lại 1 tham chiếu duy nhất là 'o3'var o4 = o3.o2; // tham chiếu đến thuộc tính 'o2' // object này giờ có 2 tham chiếu: // một là thuộc tính của 'o3': o3.o2 // hai là biến 'o4'o3 = '374'; // Giờ thì object trước đây là của o1 không còn tham chiếu nữa. // Nó có thể bị dọn dẹp bởi GC // Tuy nhiên thuộc tính 'o2' của nó thì vẫn còn // được tham chiếu bởi biến 'o4' nên chưa bị dọno4 = null; // thuộc tính 'o2' trước đây trong 'o1' giờ // đã không còn gì tham chiếu đến nó // lần này thì GC có thể dọn nó được rồi. Vấn đề từ tham chiếu vòng trònCó một số giới hạn liên quan đến tham chiếu vòng tròn. Trong ví dụ sau, 2 object được tạo ra và được tham chiếu lẫn nhau, tạo thành 1 vòng tròn. Chúng sẽ được đẩy ra ngoài scope sau khi hàm kết thúc nên về mặt lý thuyết thì chúng vô dụng và có thể được giải phóng. Tuy nhiên, thuật toán đếm tham chiếu xem xét rằng mỗi object đều đang có ít nhất 1 tham chiếu đến object đó nên thuật toán sẽ bỏ qua mà không dọn dẹp. 123456789function f() &#123; var o1 = &#123;&#125;; var o2 = &#123;&#125;; o1.p = o2; // o1 tham chiếu đến o2 o2.p = o1; // o2 tham chiếu đến o1\\. // 2 thanh niên này tạo thành 1 vòng tròn tham chiếu.&#125;f(); Thuật toán Đánh dấu và dọn dẹp (Mark-and-sweep)Để xác định xem object có còn cần thiết không thì thuật toán này thử xem object đó có thể truy cập tới hay không. Thuật toán Mark-and-sweep có 3 bước: Roots: Nhìn chung, roots là những biến toàn cục (global) được tham chiếu đến trong code. Với Javascript, một biến toàn cục có vai trò như 1 root chính là object window. Trong Node.js thì nó gọi là global. Danh sách hoàn chỉnh các roots được xây dựng bởi GC. Thuật toán sẽ điều tra tất cả các roots và con cháu (children) của nó rồi đánh dấu chúng là đang hoạt động (active) (nghĩa là, chúng không phải rác). Thứ gì mà không phải con cháu của root, root không truy xuất đến được thì đều bị coi là rác. Cuối cùng, GC sẽ giải phóng các vùng nhớ không được đánh dấu active và trả bộ nhớ lại cho hệ điều hành. Thuật toán này tốt hơn thuật toán trước vì “đối tượng không có tham chiếu” dẫn tới trường hợp đối tượng không thể truy cập, ở hướng ngược lại thì nó giải quyết được vấn đề của tham chiếu vòng tròn. Năm 2012, tất cả trình duyệt hiện đại đều tích hợp sẵn bộ GC Mark-and-sweep. Những cải tiến dành cho bộ Javascript GC (như GC Thế hệ (Generational)/ Gia tăng (Incremental)/ Đồng thời (Concurrent)/ Song song (Parallel)) trong những năm gần đây đều là những nâng cấp của thuật toán Mark-and-sweep, nhưng không phải là cải tiến thuật toán GC, cũng không phải quyết định xem 1 object có thể truy cập được hay là không. Trong bài viết này, bạn có thể tìm hiểu chi tiết hơn về quá trình truy tìm rác, nó cũng bao gồm luôn cả thuật toán Mark-and-sweep và cách tối ưu hóa của nó. Tham chiếu vòng tròn chỉ là muỗiTrong ví dụ đầu tiên, sau khi hàm được trả về, 2 object đều không được tham chiếu đến bởi một object có thể truy cập được từ đối tượng toàn cục. Một lẽ dĩ nhiên, thì chúng sẽ bị GC đánh dấu và dọn sạch sẽ. Mặc dù giữa 2 object đều có tham chiếu lẫn nhau nhưng chúng không thể truy cập được từ root Hành vi phản trực quan của GCMặc dù GC rất tiện lợi nhưng chúng cũng đi kèm với những khuyết điểm. Một trong số đó là sự không xác định được. Nói cách khác, GC là không thể đoán trước được. Ta không thể biết rõ khi nào thì GC được thực thi. Có nghĩa là trong một vài trường hợp chương trình sử dụng nhiều bộ nhớ hơn số lượng mà chúng cần. Trong trường hợp khác, những thời điểm tạm dừng ngắn hạn (short-pauses) có thể đáng được chú ý trong một số ứng dụng đặc biệt nhạy cảm.Mặc dù không xác định được nghĩa là không biết khi nào GC sẽ chạy, đa số GC đều dùng chung một mô hình thu thập trong quá trình cấp phát. Nếu như cấp phát không chạy, hầu như GC cũng không chạy. Cần cân nhắc trường hợp sau: Cấp phát một số lược bộ nhớ lớn. Đa số các phần tử này (hoặc toàn bộ) đều được đánh dấu là không thể truy cập (Giả sử chúng ta vô hiệu hóa một tham chiếu đang trỏ đến bộ nhớ cache mà chúng ta không cần nữa.) Không có cấp phát nào được thực thi nữa. Trong trường hợp này, đa số các GC sẽ không chạy bất kỳ một thu gom nào. Nói cách khác, mặc dù có những tham chiếu không thể truy cập được đang tồn tại nhưng chúng lại không được GC “để mắt” đến. Đây không phải là một loại rò rỉ nghiêm trọng nhưng dĩ nhiên nó vẫn sử dụng bộ nhớ nhiều hơn bình thường. Rò rỉ bộ nhớ là gì ?Nếu bạn đọc hết những phần ở trên thì cũng dễ hiểu thôi, rò rỉ bộ nhớ là những vùng nhớ được cấp phát và sử dụng trong chương trình nhưng sau đó, khi không còn dùng nữa, chúng vẫn không được giải phóng và trả về cho hệ điều hành hoặc là kho chứa bộ nhớ. Các ngôn ngữ lập trình có nhiều cách khác nhau để quản lý bộ nhớ. Tuy nhiên, một vùng nhớ cụ thể được dùng hay không thực sự là vấn đề khó đoán. Nói cách khác, chỉ có developer mới biết khi nào thì một vùng nhớ nên được giải phóng và trả lại cho hệ điều hành. Những ngôn ngữ lập trình cung cấp các tính năng giúp developer làm việc này. Trong khi một số ngôn ngữ khác muốn developer hiểu tường tận về việc khi nào thì 1 vùng nhớ không được sử dụng nữa. Wikipedia có bài viết hay về việc quản lý bộ nhớ tự động và bằng tay, bạn có thể xem qua. 4 loại rò rỉ phổ biến trong Javascript1. Biến toàn cụcJavascript xử lý những biến không được khai báo một cách khá thú vị: khi một biến không được khai báo được tham chiếu đến thì một biến mới sẽ được tạo ra trong object toàn cục (global). Trên trình duyệt thì tên của nó là window, nghĩa là đoạn này 123function foo(arg) &#123; bar = \"some text\";&#125; …tương đương với 123function foo(arg) &#123; window.bar = \"some text\";&#125; Giả sử mục đích của bar chỉ để tham chiếu đến 1 biến trong hàm foo thì một biến toàn cục dư thừa lúc này đã được tạo ra bởi vì ta định nghĩa bar mà không dùng var. Ở ví dụ trên, nó không gây ra nhiều tổn hại, nhưng dĩ nhiên bạn có thể tưởng tượng ra bối cảnh đáng lo ngại hơn nhiều. Ví dụ như gán 1 object phức tạp trong bar chẳng hạn. Thỉnh thoảng bạn cũng có thể vô tình tạo biến toàn cục bằng this: 12345function foo() &#123; this.var1 = \"potential accidental global\";&#125;// trong hàm foo() ở đây thì \"this\" đang trỏ tới biến toàn cục foo(); Bạn có thể tránh trường hợp đáng tiếc này bằng cách thêm dòng use strict vào đầu file Javascript, nó sẽ, nói nôm na, là bật chế độ “nghiêm túc” lên khi phân tích cú pháp (parse) code JS và sẽ ngăn chặn trường hợp vô tình tạo biến toàn cục. Những biến toàn cục ngoài dự tính như trên rõ ràng là 1 vấn đề, tuy nhiên, thường thì code của bạn sẽ bị “nhiễm độc” bởi những biến toàn cục tường minh mà những biến đó lại không thể thu thập bởi GC. Đặc biệt chú ý đến các biến toàn cục thường được dùng để lưu trữ tạm thời và xử lý 1 số lượng lớn thông tin. Sử dụng biến toàn cục để lưu trữ dữ liệu nếu bạn phải làm thế, nhưng nhớ kỹ là gán nó bằng null hoặc gán lại 1 giá trị khác khi đã xong việc với nó. 2. Timers hoặc callbacks bị bỏ quênLần này ta lấy setInterval làm ví dụ vì nó thường được dùng trong JS. Những thư viện có dùng callback cung cấp observer và các công cụ tương tự thường đảm bảo tham chiếu đến callback sẽ không thể truy cập được một khi instance của nó không thể truy cập được. Ví dụ dưới đây không phải hiếm: 1234567var serverData = loadData();setInterval(function() &#123; var renderer = document.getElementById('renderer'); if(renderer) &#123; renderer.innerHTML = JSON.stringify(serverData); &#125;&#125;, 5000); // hàm sẽ được thực thi sau mỗi 5 giây. Đoạn code trên cho thấy hậu quả của việc sử dụng timer có tham chiếu đến node hay dữ liệu cũ, không còn dùng nữa. Object renderer có thể được thay thế hoặc gỡ bỏ ở đâu đó trong quá trình thực thi, điều này làm cho hàm callback trong setInterval trở nên thừa thãi. Nếu điều này xảy ra, dù cho callback hay những thứ bên trong có đủ điều kiện để được dọn dẹp thì trước hết cái interval đó phải dừng lại trước đã (bỏi vì nó vẫn đang hoạt động mà). Dĩ nhiên nếu như serverData đang chứa hay đang xử lý cả 1 đống dữ liệu thì cũng không thể bị thu dọn được. Khi sử dụng observer, bạn cần đảm bảo phải có một câu lệnh tường minh để gỡ bỏ chúng mỗi khi xong việc (Dù là observer đó không cần dùng nữa hay object không thể truy cập được). May mắn thay, đa số các trình duyệt hiện đại đều làm giúp bạn việc đó rồi: chúng sẽ tự động thu thập các observer mỗi khi object trong đó trở nên không thể truy cập được kể cả nếu như bạn quên gỡ các listener. Trước đây, một số trình duyệt không làm được điều này (IE6 chẳng hạn). Nhưng cách tốt nhất vẫn là gỡ bỏ observer khi đã xong việc với nó. Bạn xem ví dụ dưới đây: 123456789101112var element = document.getElementById('launch-button');var counter = 0;function onClick(event) &#123; counter++; element.innerHtml = 'text ' + counter;&#125;element.addEventListener('click', onClick);// Do stuff element.removeEventListener('click', onClick);element.parentNode.removeChild(element);// Giờ thì \"element\" đã được đưa ra khỏi phạm vi thực thi,// Cả \"element\" và \"onClick\" sẽ được dọn dẹp kể cả trên các trình duyệt cũ Bạn không càn phải gọi hàm removeEventListener trước khi làm cho node không thể truy cập được vì các trình duyệt hiện đại hỗ trợ GC có thể tự động xác định và xử lý chúng một cách thích hợp. Nếu bạn dùng jQuery APIs (có nhiều thư viện và frameworks khác cũng hỗ trợ), bạn cũng có thể gỡ bỏ các listener trước khi node bị đưa vào “dĩ vãng” và không dùng nữa. Những thư viện cũng đảm bảo không có rò rỉ bộ nhớ kể cả khi ứng dụng của bạn chạy trên những trình duyệt cũ. 3. ClosuresMột phần quan trọng của Javascript chính là closure: một hàm con có thể truy xuất đến biến của hàm bên ngoài nó. Trong quá tình triển khai chi tiết môi trường thực thi (runtime) của JS thì có thể xảy ra tình trạng rò rỉ bộ nhớ với closure như sau: 123456789101112131415var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) // một tham chiếu đến 'originalThing' console.log(\"hi\"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(\"message\"); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); Một khi replaceThing được gọi, theThing sẽ trở thành một object mới chứa 1 mảng rất lớn và 1 closure someMethod. Tuy nhiên, originalThing được tham chiếu bởi 1 closure mà nó lại nằm trong biến unused (chính là biến theThing từ lời gọi đến replaceThing trước đó). Nhớ rằng ở đây một khi phạm vi (scope) của closure được tạo ra cho closure trong cùng parent scope thì scope đó được dùng chung. Trong trường hợp này, scope tạo ra cho closure someMethod được chia sẻ với unused. unused có tham chiếu đến originalThing. Mặc dù unused không bao giờ được dùng, someMehod có thể được sử dụng thông qua theThing bên ngoài scope của replaceThing (ví dụ: ở 1 nơi toàn cục nào đó). Và khi someMethod chia sẻ closure với unused, tham chiếu đến originalThing trong unused ép nó phải ở trong trạng thái hoạt động (toàn bộ scope chia sẻ giữa 2 closure). Điều này ngăn chặn GC hoạt động. Trong ví dụ trên, scope được tạo ra cho closure someMethod được chia sẻ với unused, trong khi unused tham chiếu tới originalThing. someMethod có thể được gọi thông qua theThing bên ngoài scope của replaceThing, mặc dù sự thật là unused không bao giờ được sử dụng. Rõ ràng unused tham chiếu đến originalThing yêu cầu nó phải giữ trạng thái đang hoạt động bởi vì someMethod chia sẻ closure scope với unused. Tất cả những điều này có thể làm bộ nhớ bị rò rỉ đáng kể. Bạn có thể thấy biểu đồ sử dụng bộ nhớ dâng lên cao ngất khi đoạn code trên bị lặp đi lặp lại. Kích thước của nó không bị giảm đi khi GC hoạt động. Một danh sách liên kết các closure được tạo ra (root của nó là theThing) và mỗi closure scope lại chưa một tham chiếu gián tiếp tới mảng khổng lồ. Vấn đề này được tìm thấy bởi Meteor team và họ có 1 bài viết cụ thể mô tả về nó ở đây. 4. Tham chiếu ngoài DOMCó những trường hợp mà developer lưu trữ DOM node bên trong cấu trúc dữ liệu. Giả sử bạn muốn cập nhật một cách nhanh chóng dữ liệu của nhiều row trong 1 table. Nếu bạn lưu tham chiếu đến mỗi DOM row trong 1 dictionary hay mảng, sẽ có 2 tham chiếu đến cùng 1 phần tử DOM: 1 là từ cây DOME, và 1 là từ dictionary. Nếu bạn chọn lựa xóa bỏ những row này, bạn cũng phải nhớ làm cho 2 tham chiếu trên không thể truy cập được. 1234567891011121314var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image')&#125;;function doStuff() &#123; elements.image.src = 'http://example.com/image_name.png';&#125;function removeImage() &#123; // Cái ảnh là 1 node con trực tiếp của body document.body.removeChild(document.getElementById('image')); // Ở thời điểm này ta vẫn có 1 tham chiếu đến #button trong // biến toàn cục \"element\". Nói cách khác, \"button\" vẫn còn nằm // trong bộ nhớ và GC không thể dọn dẹp nó được.&#125; Cần phải xem xét kỹ lưỡng khi tham chiếu đến node con hay node lá bên trong cây DOME. Nếu bạn giữ tham chiếu đến 1 table cell (thẻ ) trong code và chọn xóa table khỏi DOM tuy nhiên vẫn giữ tham chiếu đến cell đó, bạn có thể sẽ phải đối mặt với 1 vụ rò rỉ lớn. Bạn nghĩ rằng GC sẽ giải phóng tất cả mọi thứ ngoại trừ cell đó. Tuy nhiên, điều này không dễ dàng như vậy. Bởi vì cell là 1 node con của table và những node con thì có tham chiếu đến parent của chúng, vì thế 1 tham chiếu đến 1 cell có thể giữ cả 1 table lớn trong bộ nhớ.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P2: Bên trong engine V8 & 5 mẹo để tối ưu hóa code","slug":"Cach-Javascript-hoat-dong-P2-Ben-trong-engine-V8-5-meo-de-toi-uu-hoa-code","date":"2018-11-13T15:52:00.000Z","updated":"2018-11-13T15:58:38.369Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P2-Ben-trong-engine-V8-5-meo-de-toi-uu-hoa-code.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P2-Ben-trong-engine-V8-5-meo-de-toi-uu-hoa-code.html","excerpt":"Hôm trước chúng ta đã có bài bắt đầu một chuỗi series đào sâu nghiên cứu về Javascript và cách thức nó hoạt động: Chúng tôi nghĩ rằng, bằng cách hiểu được những thành phần của JS và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và ngon hơn Bài đầu tiên của series đã cho chúng ta có một cái nhìn tổng quan về engine, runtime và callstack. Trong bài thứ 2 này, chúng ta sẽ đục khoét vào những thành phần bên trong của bộ engine V8 của Google. Tác giả cũng sẽ cung cấp một số mẹo vặt để có thể viết code Javascript tốt hơn - những thứ tốt nhất (best practices) mà team SessionStack đã và đang thực hiện để xây dựng những sản phẩm của họ.","text":"Hôm trước chúng ta đã có bài bắt đầu một chuỗi series đào sâu nghiên cứu về Javascript và cách thức nó hoạt động: Chúng tôi nghĩ rằng, bằng cách hiểu được những thành phần của JS và cách chúng tương tác với nhau thì chúng ta có thể viết code tốt hơn và ngon hơn Bài đầu tiên của series đã cho chúng ta có một cái nhìn tổng quan về engine, runtime và callstack. Trong bài thứ 2 này, chúng ta sẽ đục khoét vào những thành phần bên trong của bộ engine V8 của Google. Tác giả cũng sẽ cung cấp một số mẹo vặt để có thể viết code Javascript tốt hơn - những thứ tốt nhất (best practices) mà team SessionStack đã và đang thực hiện để xây dựng những sản phẩm của họ. Tổng quanJavascript engine là một trình thông dịch thực thi mã Javascript. Một JS engine có thể được triển khai thực hiện như là 1 trình thông dịch độc lập, hoặc là một trình biên dịch tức thời (Just-In-Time Compiler) mà nó sẽ biên dịch code Javascript thành bytecode (chưa phải mã máy, nhưng gần như là mã máy). Dưới đây là danh sách các dự án phổ biến đã triển khai cho Javascript engine: V8 - Nguồn mở, phát triển bởi Google trên nền C++ Rhino - Được quản lý bởi quỹ Mozilla Foundation, nguồn mở, phát triển hoàn toàn bằng Java SpiderMonkey - Bộ JS engine đầu tiên, ngày xưa được hỗ trợ bởi Netscape Navigator, ngày nay là Firefox JavaScriptCore - nguồn mở, còn được gọi là Nitro, được phát triển bởi Apple cho Safari KJS - Engine của KDE, phát triển bởi Harri Porten cho dự án trình duyệt Konqueror của KDE Chakra (JScript9) - Internet Explorer Chakra (JavaScript) - Microsoft Edge Nashorn - Nguồn mở và là 1 phần của OpenJDK, viết bằng Java bởi Oracle và Tool Group JerryScript - là 1 bộ engine nhẹ dành cho Vạn vật kết nối (Internet of Things) Tại sao V8 được tạo ra?Hỏi vớ vẩn V8 engine được xây dựng bởi Google bằng C++ và nó là phần mềm nguồn mở. Bộ engine này được dùng trong trình duyệt Google Chrome. Không giống như các engine khác, V8 còn được sử dụng trong môi trường runtime của Node.js V8 đầu tiên được thiết kế nhằm gia tăng hiệu suất của tiến trình thực thi JavaScript bên trong trình duyệt. Để có thể đạt được tốc độ tốt, V8 dịch mã Javascript thành mã máy thay vì sử dụng trình thông dịch. Nó biên dịch mã JS thành mã máy ngay khi thực thi bằng bộ JIT compiler (Just-In-Time compiler) giống như đa số các JS engine hiện đại khác như SpiderMoney hay Rhino. Điểm khác biệt chính đó là V8 không sinh ra bytecode hay mã trung gian. V8 sử dụng 2 trình biên dịchTrước khi phát hành phiên bản 5.9 (đầu năm 2017), engine V8 sử dụng 2 trình biên dịch: full-codegen - một trình biên dịch vừa đơn giản vừa cực nhanh, sinh mã máy đơn giản và tương đối chậm Crankshaft - một trình biên dịch tối ưu có hơi phức tạp (Just-In-Time) sinh mã đã được tối ưu tốt nhất. V8 engine còn sử dụng nhiều tiến trình nội bộ khác: Tiến trình chính thực hiện những gì bạn thường thấy: lấy code, biên dịch và thực thi nó. Có một tiến trình riêng khác cho việc biên dịch, bằng cách này thì trong khi tiến trình chính biên dịch, tiến trình phụ tối ưu (optimize) code. Một tiến trình Profiler (không biết dịch) sẽ thông báo cho runtime những phương thức nào đang chiếm dụng nhiều thời gian xử lý để cho Crankshaft có thể tối ưu chúng. Một vài tiến trình khác để xử lý dọn rác (Garbage Collector) Khi lần đầu thực thi mã Javascript, V8 engine sẽ gọi full-codegen để dịch trực tiếp những đoạn code JS đã được phân tích thành mã máy mà không thông qua bước chuyển đổi (transformation). Điều này cho phép thực thi mã máy rất nhanh. Để ý rằng V8 không sử dụng bytecode trung gian, cho thấy rằng cách làm này loại bỏ sự không cần thiết của 1 trình thông dịch. Khi code đã chạy được một thời gian thì tiến trình profiler đã thu thập đủ dữ liệu để có thể xác định phương thức nào cần được tối ưu hóa. Ở bước tiếp theo, Crankshaft sẽ bắt đầu 1 tiến trình khác. Nó dịch cây cú pháp trừu tượng (Abstract Syntax Tree - AST, sẽ có 1 bài riêng để nói về cái này nhé) của Javascript thành một dạng cấp độ cao của static single assignment (SSA - vốn ngôn ngữ có hạn nên không biết dịch), còn được gọi là Hydrogen, và cố gắng tối ưu đồ thị Hydrogen đó. Đa số sự tối ưu hóa được hoàn thành là giai đoạn này. Inlining (Nội tuyến)Bước tối ưu hóa đầu tiên là triển khai nội tuyến (Inlining) nhiều code nhất có thể. Inlining là tiến trình thay thế một vị trí gọi (call site - dòng code nơi hàm được gọi) với thân (body) của hàm được gọi. Bước thực hiện đơn giản này cho phép những tối ưu hóa sau này được ý nghĩa hơn. Lớp ẩn (Hidden class)Javascript là ngôn ngữ dựa trên các nguyên mẫu (prototype-based): không có các lớp (class) hay đối tượng (object) nào được tạo ra bằng tiến trình nhân bản (cloning process). Javascript cũng là ngôn ngữ động (dynamic), nghĩa là những thuộc tính (property) có thể được dễ dàng thêm vào hoặc xóa đi từ object sau khi object đó được khởi tạo. Đa số các trình thông dịch JS sử dụng cấu trúc dạng như từ điển (hash function based) để lưu trữ vị trí của những giá trị của thuộc tính trong object trên bộ nhớ. Cấu trúc này làm cho quá trình lấy giá trị (get) trong JS trở nên tốn kém hơn nhiều so với những ngôn ngữ lập trình non-dynamic khác như Java hay C#.Trong Java, tất cả các thuộc tính của object được xác định bởi cấu trúc object cố định trước khi biên dịch và không thể thêm hay bớt thuộc tính tại thời điểm thực thi (C# cũng có kiểu dynamic, nhưng cái đó hơi lạc đề rồi nên mình không đề cập).Kết quả là, giá trị của thuộc tính (hay con trỏ đến thuộc tính đó) được lưu dưới dạng bộ đệm liên tục (continuous buffer) trên vùng nhớ với một offset cố định giữa các vùng nhớ. Độ dài của 1 offset có thể dễ dàng xác định dựa trên loại thuộc tính, trong khi đó điều này là bất khả thi đối với Javascript khi mà loại thuộc tính có thể bị thay đổi trong quá trình thực thi. Bởi vì sử dụng cấu trúc từ điển để tìm vị trí của thuộc tính của object trong vùng nhớ là không hiệu quả nên V8 sử dụng một phương pháp khác: lớp ẩn (hidden class). Lớp ẩn hoạt động tương tự như một cấu trúc object (class) cố định trong Java, ngoại trừ việc nó được tạo ra ở quá trình thực thi (runtime). Giờ thì xem ví dụ bên dưới nhé: 12345function Point(x, y) &#123; this.x = x; this.y = y;&#125;var p1 = new Point(1, 2); Khi câu lệnh new Point(1, 2) được gọi, V8 sẽ tạo ra 1 lớp ẩn, tạm gọi là C0 Không có thuộc tính nào được định nghĩa trong Point, vì thế tạm thời C0 đang rỗng. Khi câu lệnh this.x = x được thực thi (bên trong hàm Point), V8 sẽ tạo ra 1 lớp ẩn thứ hai dựa trên C0, ta tạm gọi là C1. C1 mô tả lại vị trí trên vùng nhớ (tương tự như con trỏ) nơi mà thuộc tính x được lưu.Trong trường hợp này, x sẽ nằm ở offset 0, nghĩa là khi chúng ta view một object Point trên vùng nhớ dưới dạng bộ đệm liên tục (continuous buffer) thì offset đầu tiên sẽ tương ứng với thuộc tính x.V8 cũng sẽ cập nhật C0 với một sự chuyển đổi lớp (class transition) và tuyên bố rằng thuộc tính x được thêm vào trong object Point, lớp ẩn lúc này sẽ chuyển từ C0 sang C1.Lớp ẩn cho object Point ở hình dưới lúc này là C1 Mỗi khi có thuộc tính mới được thêm vào object, lớp ẩn cũ được cập nhật và sẽ chuyển tiếp (transition) sang lớp ẩn mới. Sự chuyển tiếp lớp ẩn là rất quan trọng bởi vì chúng cho phép những object được tạo ra theo những cách giống nhau có thể cùng chia sẻ các lớp ẩn. Nếu 2 object cùng dùng chung 1 lớp ẩn và 1 thuộc tính được thêm vào cả 2 object đó, sự chuyển tiếp sẽ đảm bảo rằng cả 2 object đều nhận được cùng 1 lớp ẩn mới và sẽ được tối ưu cùng nhau. Quá trình này được lặp lại khi câu lệnh tiếp theo this.y = y được thực thi (bên trong hàm Point, ngay sau dòng this.x = x). Một lớp ẩn mới, tạm gọi là C2 được tạo ra, một lớp chuyển tiếp (class transition) được thêm vào C1 biểu thị rằng nếu thuộc tính y được thêm vào object Point (object đã chứa thuộc tính x) thì lớp ẩn sẽ được thay đổi sang C2, và lớp ẩn của object Point sẽ được cập nhật thành C2 Sự chuyển tiếp lớp ẩn phụ thuộc vào thứ tự mà những thuộc tính được thêm vào 1 object. Ví dụ: 123456789101112function Point(x, y) &#123; this.x = x; this.y = y;&#125;var p1 = new Point(1, 2);p1.a = 5;p1.b = 6;var p2 = new Point(3, 4);p2.b = 7;p2.a = 8; Nhìn vào đoạn code trên, bạn sẽ nghĩ rằng cả p1 và p2 sẽ dùng chung lớp ẩn và sự chuyển tiếp giữa các lớp. Nhưng sự thật không phải như vậy. Đối với p1, thuộc tính thứ nhất là a sẽ được thêm vào và sau đó đến b. Với p2 thì ngược lại, b trước rồi mới đến a.Vì vậy, p1 và p2 sẽ sinh ra 2 lớp ẩn khác nhau và có sự chuyển tiếp lớp ẩn cũng khác nhau. Trong trường hợp này, tốt nhất là nên giữ đúng thứ tự thuộc tính mỗi khi khởi tạo dữ liệu để lớp ẩn có thể được dùng lại: 1234567var p1 = new Point(1, 2);p1.a = 5;p1.b = 6;var p2 = new Point(3, 4);p2.a = 8;p2.b = 7; Phần diễn giải về hidden class này khá là rối và khó hiểu, để hiểu rõ hơn thì mời bạn tham khảo thêm bài viết chi tiết của tác giả thefullsnack Inline caching (Bộ đệm nội tuyến)V8 có một điểm mạnh trong kỹ thuật tối ưu hóa dành cho các ngôn ngữ với kiểu dữ liệu động, gọi là Inline caching (bộ đệm nội tuyến). Inline caching dựa trên sự quan sát những lời gọi được lặp lại nhiều lần đến cùng 1 phương thức có xu hướng xảy ra trên cùng 1 loại object. Diễn giải chi tiết hơn về inline caching có thể xem ở đây Giờ chúng ta sẽ duyệt sơ qua những khái niệm chung chung của inline caching (nếu như bạn không có thời gian đọc hết bài chi tiết ở trên) Vậy thì nó hoạt động như thế nào? V8 duy trì bộ nhớ đệm về kiểu của các object được truyền qua dưới dạng tham số (parameter) trong những lần gọi method gần đây và sử dụng thông tin này để dự đoán về kiểu object sẽ được truyền trong tương lai. Nếu như V8 có thể dự đoán tương đối tốt về kiểu object sẽ được truyền vào thì nó có thể bỏ qua bước xử lý tìm hiểu về các thuộc tính của object đó, nó sẽ dùng những thông tin có sẵn đã được lưu từ lần trước và áp dụng cho lớp ẩn của object này. Vậy thì lớp ẩn và inline caching liên quan với nhau như thế nào? Khi một phương thức được gọi trên một object cụ thể, V8 sẽ thực hiện tìm kiếm lớp ẩn của object đó để xác định offset nhằm phục vụ cho việc truy xuất thuộc tính. Sau 2 lần gọi thành công cùng 1 phương thức đến cùng 1 lớp ẩn, V8 sẽ bỏ qua việc tìm kiếm lớp ẩn đó và đơn giản là thêm offset của thuộc tính vào trong bản thân con trỏ của object. Về sau, cứ mỗi lần gọi phương thức, V8 sẽ giả định rằng lớp ẩn không thay đổi và nhảy trực tiếp vào trong địa chỉ vùng nhớ của thuộc tính và sử dụng offset đã được lưu từ lần tìm kiếm trước đó. Cách này có thể gia tăng đáng kể tốc độ thực thi. Inline caching cũng là lý do quan trọng cho việc cùng kiểu object sẽ dùng chung lớp ẩn. Nếu bạn tạo ra 2 object có cùng 1 kiểu nhưng khác hidden class (như chúng ta đã làm ở trên), V8 sẽ không thể sử dụng inline caching bởi vì mặc dù 2 object có cùng kiểu nhưng lớp ẩn tương ứng của nó lại gán offset khác nhau cho mỗi thuộc tính. 2 object về cơ bản là giống nhau nhưng thuộc tính a và b lại có thứ tự khác nhau. Biên dịch thành mã máyMột khi đồ thị Hydrogen đã được tối ưu hóa, Crankshaft chuyển nó xuống một tầng thấp hơn gọi là Lithium. Hầu như toàn bộ các Lithium này là kiến trúc cụ thể (architecture-specific, mình cũng không hiểu nữa, kiến thức chuyên sâu quá). Đăng ký cấp phát xảy ra ở tầng này. Ở bước cuối cùng, Lithium được biên dịch thành mã máy. Sau đó, quá trình thay đổi trên ngăn xếp (on-stack replacement: OSR) sẽ diễn ra. Trước khi chúng ta bắt đầu biên dịch và tối ưu hóa một phương thức ngốn nhiều thời gian, chúng ta thường chạy nó trước. V8 sẽ không vứt hết những đoạn code chậm và chạy lại từ đầu đoạn code đã tối ưu. Thay vì thế, V8 sẽ chuyển hóa toàn bộ ngữ cảnh hiện tại (ngăn xếp, các thanh ghi), do đó ta có thể chuyển đổi sang phiên bản đã được tối ưu ngay giữa quá trình thực thi. Đây là một thao tác cực kỳ phức tạp, hãy nhớ rằng V8 đã inline toàn bộ code giữa quá trình tối ưu hóa (Đoạn này viết khó hiểu quá, nhưng mà cũng không quan tọng lắm đâu). Ngoài ra thì V8 không phải là engine duy nhất có thể làm được điều này. Có một giải pháp an toàn đó là đảo ngược quá trình tối ưu hóa (deoptimization - phức tạp hóa ?) để chuyển đổi toàn bộ code về với trạng thái chưa được tối ưu trong trường hợp engine gặp trục trặc. Bộ dọn rác (Garbage collection - GC)Đối với GC thì V8 sử dụng phương pháp thế hệ theo kiểu truyền thống là đánh-dấu-và-quét (mark-and-sweep) để dọn dẹp những thứ cũ. Giả sử quá tình đánh dấu có thể làm ngưng sự thực thi Javascript. Để có thể điều hành GC hiệu quả và thực hiện một cách ổn định, V8 sử dụng đánh dấu gia tăng (incremental marking), thay vì duyệt qua toàn bộ heap và cố đánh dấu nhiều object nhất có thể, nó sẽ đi qua từng heap, sau đó quay lại với những thực thi bình thường.Lần tiếp theo GC chạy sẽ tiếp tục từ vị trí heap mà trước đó nó đã dừng lại. Cách này cho phép một khoảng thời gian dừng rất ngắn giữa quá trình thực thi. Và như đã đề cập ở trước, quá tình quét dọn được xử lý bằng 1 tiến trình khác. Ignition và TurboFanCùng với sự ra mắt của V8 bản 5.9 đầu năm 2017, có 2 pipeline thực thi mới được giới thiệu, mang lại khả năng cải thiện hiệu năng tốt hơn và tiết kiệm bộ nhớ đáng kể đối với những ứng dụng Javascript. Bộ pipeline mới này được xây dựng trên trình thông dịch của V8 là Ignition và trình biên dịch tối ưu hóa mới nhất là TurboFan. Bạn có thể xem thêm thông tin trong bài viết trên blog của V8 tại đây Kể từ phiên bản 5.9 thì full-codegen và Crankshaft (những công nghệ đã xuất hiện trong V8 từ năm 2010) đã không còn được sử dụng cho quá trình thực thi Javascript nữa khi mà nhóm phát triển V8 đã phải vất vả để có thể theo kịp với những tính năng mới và sự tối ưu hóa cần thiết cho những tính năng này. Điều này nghĩa là xét một cách tổng quát thì V8 sẽ đơn giản hơn và có kiến trúc dễ bảo trì hơn. Những cải tiến này chỉ là bước khởi đầu. Ignition và TurboFan sẽ lót đường cho những tối ưu hóa về sau, đẩy mạnh hiệu năng Javascript và tinh giản bớt V8 trong Chrome và Node.js trong những năm tới. Cuối cùng, dưới đây là 1 số mẹo vặt để bạn có thể viết được bộ code Javascript một cách tối ưu. Bạn có thể dễ dàng rút ra được bài học từ những gì đã nêu ở trên, nhưng để dễ hiểu hơn thì mời bạn xẹm tổng kết: Làm thế nào để tối ưu hóa Javascript Thứ tự các thuộc tính của object: luôn luôn khởi tạo các thuộc tính của object sao cho chúng có cùng thứ tự để lớp ẩn và những code tối ưu có thể chia sẻ dùng chung. Thuộc tính động (Dynamic properties): thêm thuộc tính vào một object sau khi khởi tạo sẽ ép lớp ẩn phải thay đổi và làm chậm những phương thức đã được tối ưu cho lớp ẩn trước đó. Thay vì thế, ta có thể gán tất cả các thuộc tính của object trong hàm khởi tạo constructor. Phương thức: code thực thi cùng 1 phương thức nhưng nhiều lần sẽ chạy nhanh hơn code thực thi nhiều phương thức khác nhau nhưng mỗi phương thức chạy một lần (xem phần inline caching) Mảng: Tránh sử dụng mảng thưa (sparse arrays) mà key không phải là số tăng liên tục. Mảng thưa mà không có phần tử nào thì lại là bảng băm (hash table). Mỗi phần tử trong mảng như vậy sẽ gây ra sự tốn kém mỗi lần truy xuất. Ngoài ra cần tránh trường hợp cấp phát bộ nhớ trước cho những mảng lớn. Cứ để cho mảng “nở ra” một cách tự nhiên. Cuối cũng thì cũng đừng xóa các phần tử trong mảng (toán tử delete()) vì nó chỉ xóa phần từ chứ không đánh index lại mảng. Tagged values: Trong V8 thì object và số (number) là 32bits. Nó sử dụng 1 bit để phân biệt object (flag = 1) và số integer (flag = 0) gọi là SMI (SMall Integer). Vì thế nếu 1 giá trị số lớn hơn 31 bit thì V8 sẽ đóng gói số đó, chuyển nó thành kiểu double và tạo 1 object mới để lưu số. Chỉ nên sử dụng số nguyên có dấu 31 bit để tránh quá trình chuyển đổi không đáng có (lại tốn công xử lý) số thành object.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách Javascript hoạt động P1: Khái quát về engine, runtime và callstack","slug":"Cach-Javascript-hoat-dong-P1-Khai-quat-ve-engine-runtime-va-callstack","date":"2018-11-13T15:50:00.000Z","updated":"2018-11-13T15:51:06.078Z","comments":true,"path":"2018/11/Cach-Javascript-hoat-dong-P1-Khai-quat-ve-engine-runtime-va-callstack.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Cach-Javascript-hoat-dong-P1-Khai-quat-ve-engine-runtime-va-callstack.html","excerpt":"Javascript càng ngày càng phổ biến, có nhiều nhóm các lập trình viên đã và đang nâng cấp cũng như hỗ trợ JS ở nhiều mức độ khác nhau: từ frontend đến backend, hybrid app, thiết bị nhúng và còn nhiều nữa. Bài viết này mở đầu cho 1 series hướng tới mục đích đào sâu (aka Đục Khoét) vào trong Javascript và cách mà nó hoạt động như thế nào: Bằng cách hiểu rõ các thành phần của JS và cách mà chúng tương tác với nhau thì bạn có thể viết code tốt hơn và ngon hơn. Bên cạnh đó team SessionStack cũng chia sẻ một vài bí kíp trong khi xây dựng SessionStack - 1 ứng dụng Javascript nhẹ nhưng có chất lượng cao và mạnh mẽ.","text":"Javascript càng ngày càng phổ biến, có nhiều nhóm các lập trình viên đã và đang nâng cấp cũng như hỗ trợ JS ở nhiều mức độ khác nhau: từ frontend đến backend, hybrid app, thiết bị nhúng và còn nhiều nữa. Bài viết này mở đầu cho 1 series hướng tới mục đích đào sâu (aka Đục Khoét) vào trong Javascript và cách mà nó hoạt động như thế nào: Bằng cách hiểu rõ các thành phần của JS và cách mà chúng tương tác với nhau thì bạn có thể viết code tốt hơn và ngon hơn. Bên cạnh đó team SessionStack cũng chia sẻ một vài bí kíp trong khi xây dựng SessionStack - 1 ứng dụng Javascript nhẹ nhưng có chất lượng cao và mạnh mẽ.Như ta thấy trong GitHut stats, Javascript đang là top đứng đầu trong các repo đang hoạt động (Active Repositories) và tổng số push (Total Pushes) ở GitHub. Và nó cũng không bị tụt lùi quá nhiều ở những hạng mục khác. (Xem cập nhật mới nhất về GitHut stat). Nếu dự án phụ thuộc quá lớn vào Javascript thì có nghĩa rằng các lập trình viên phải tận dụng tối đa khả năng mà ngôn ngữ này cũng như hệ sinh thái (ecosystem) của nó cung cấp và thấu hiểu một cách triệt để về bản chất của nó để có thể xây dựng được những công trình vi diệu. Và một cách hiển nhiên là có rất nhiều lập trình viên đang sử dụng Javascript hằng ngày nhưng lại không có kiến thức hoặc không biết gì về những thứ đang thực sự diễn ra bên trong JS. Tổng quanHầu như mọi người ai cũng từng nghe qua bộ engine V8 và đa số mọi người biết rằng JS là một ngôn ngữ đơn luồng (single-thread) hoặc là nó sử dụng hàng đợi các callback (callback queue - không biết dịch sao cho đúng) Trong bài này, chúng ta sẽ đi lần lượt một cách chi tiết qua các khái niệm cơ bản và giải thích cụ thể Javascript chạy như thế nào. Bằng cách đó, chúng ta có thể viết code được tốt hơn, xây dựng app có khả năng xử lý API một cách mượt mà, không bị block lẫn nhau (non-blocking apps). Nếu bạn là người mới học Javascript thì bài viết này sẽ giúp bạn hiểu tại sao Javascript lại “quái dị” khi so sánh với các ngôn ngữ khác. Và nếu bạn là một dev có kinh nghiệm với JS thì hi vọng bài viết này sẽ giúp ích cho bạn hiểu thêm về cách hoạt động của JS Runtime - thứ mà bạn đang sử dụng mỗi ngày. JavaScript EngineEngine: Cỗ máy - mình sẽ không dịch từ mà để nguyên gốc tiếng Anh Một ví dụ điển hình của JS Engine chính là bộ Google V8. Bộ engine V8 này được sử dụng trong Google Chrome và Node.js. Dưới đây là một mô hình đơn giản nhất của nó: Engine gồm 2 thành phần chính: Vùng nhớ heap (memory heap): khu vực cấp phát bộ nhớ Ngăn xếp (call stack): đây là nơi chứa các khung stack khi bạn thực thi code. Runtime (Môi trường thực thi)Có những API trong trình duyệt đang được sử dụng bởi đa số JS developer hiện nay (ví dụ: setTimeout). Những API này lại không được cung cấp bởi các Engine. Vậy thì chúng từ đâu tới ? Sự thật có đôi chút phức tạp một tí. Chúng ta có JS Engine nhưng thực ra còn nhiều thứ hơn thế. Các browser thường cung cấp một hệ thống Web APIs bao gồm nhiều thành phần như DOM, AJAX, setTimeout, vân vân và mây mây. Và rồi cả những thứ nổi tiếng như event loop và callback queue nữa. Ngăn xếp (Call Stack)Javascript là ngôn ngữ lập trình đơn luồng (single-threaded), nghĩa là nó chỉ có 1 cái call stack. Vì thế nó chỉ có thể làm 1 công việc tại 1 thời điểm nhất định. Call Stack là một cấu trúc dữ liệu mà về cơ bản thì nó ghi nhớ vị trí của chúng ta trong chương trình đang chạy. Nếu như chúng ta thực thi một hàm (function) thì khi đó ta sẽ đặt hàm đấy vào vị trí trên cùng của ngăn xếp (stack), sau khi xử lý xong và return từ hàm đó, vị trí trên cùng sẽ bị đẩy ra khỏi stack. Đó là cách hoạt động của Call Stack. Để dễ hiểu hơn thì mời bạn xem ví dụ bên dưới: 12345678function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); Khi engine bắt đầu thực thi code, Call Stack còn đang rỗng. Ngay sau đó, từng bước thực hiện sẽ giống như hình bên dưới: Mỗi bản ghi trong Call Stack được gọi là khung của ngăn xếp (Stack Frame). Và đây cũng là cách chính xác mà stack traces được xây dựng và in ra mỗi khi có xử lý biệt lệ (exception handling). Về cơ bản thì nó chính là trạng thái của Call Stack ngay tại thời điểm có biệt lệ xảy ra. Hãy nhìn vào đoạn code bên dưới: 12345678910function foo() &#123; throw new Error('SessionStack will help you resolve crashes :)');&#125;function bar() &#123; foo();&#125;function start() &#123; bar();&#125;start(); Nếu như chạy đoạn code đó trên Chrome console (giả sử toàn bộ code nằm trong 1 file foo.js), thì chúng ta sẽ có stack trace như sau: Thổi tung ngăn xếp (Blowing the stack) - Trường hợp này xảy ra khi chương trình thực thi đạt tới kích thước giới hạn tối đa của Call Stack. Và để có thể có được tình huống này một cách dễ dàng nhất, chỉ cần vô tình gọi đệ quy một cách không cẩn thận là được à: 1234function foo() &#123; foo();&#125;foo(); Khi engine bắt đầu thực thi code, nó gọi hàm foo đầu tiên. Hàm này lại gọi đệ quy chính bản thân nó để rồi rơi vào 1 vòng lặp vô hạn không có điều kiện dừng. Mỗi khi gọi hàm thì 1 bản ghi sẽ được đẩy vào Call Stack, và cứ thế, cứ thể đẩy vào làm cho tràn ngăn xếp (aka stackoverflow). Giống như hình bên dưới: Tại 1 thời điểm cụ thể nào đó khi số lần gọi hàm đạt tới ngưỡng giới hạn của Call Stack (call stack size) thì trình duyệt sẽ quyết định “giải cứu” bằng cách bắn ra 1 lỗi trông như thế này đây: Chạy code đơn tiến trình có thể khá là dễ dàng bởi vì chúng ta không phải mất công đối phó với những tình huống phức tạp thường gặp trong môi trường đa tiến trình (chẳng hạn như deadlocks). Tuy nhiên đơn tiến trình cũng có những giới hạn của nó. Bởi vì Javascript chỉ có 1 Call Stack, điều gì sẽ xảy ra khi có vài xử lý chậm chạp? Xử lý đồng thời (Concurrency) &amp; Vòng lặp sự kiện (Event Loop)Điều gì sẽ xảy ra nếu như bạn có 1 hàm xử lý đang ở trong Call Stack nhưng hàm đó lại tốn kha khá thời gian để chạy? Ví dụ như bạn muốn thực hiện một vài thuật toán chuyển đổi hình ảnh phức tạp bằng Javascript ngay trên trình duyệt. Thế thì có vấn đề gì nào? Vấn đề ở đây là trong khi Call Stack đang bận tối tăm mặt mũi để xử lý thì trình duyệt lại rảnh không, ngồi chơi xơi nước vì không có gì để làm, đúng hơn là không thể làm gì được - trình duyệt đã bị block. Có nghĩa là trình duyệt không thể render, nó cũng không chạy được các câu lệnh khác, tóm lại là bị mắc kẹt. Điều này gây ảnh hưởng lớn đến sự mượt mà của UI trên app. Đó cũng không phải vấn đề duy nhất đâu. Một khi trình duyệt bắt đầu xử lý quá nhiều thứ trong Call Stack, nó sẽ bị “đơ”, không thể tương tác được trong 1 khoảng thời gian dài. Đa số trình duyệt sẽ bắn ra lỗi, hỏi bạn xem có muốn hủy trang đang chạy không. Đại loại là giống như hình dưới: Rõ ràng điều này không phải là 1 trải nghiệm người dùng (User experience) tối ưu phải không nào? Vậy thì làm thế nào để xử lý code vừa nhiều vừa nặng mà lại không làm UI bị kẹt cũng như trình duyệt bị đơ? Giải pháp đó là sử dụng callback bất đồng bộ (asynchronous callbacks). Điều này sẽ được giải thích kỹ hơn trong Phần 2 của series: Bên trong engine V8 &amp; 5 mẹo để tối ưu hóa code. Các bạn đón xem nhé. PS: Trong các bài sau mình sẽ trình bày chi tiết và kỹ hơn về cách hoạt động của Event Loop.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Một số nguyên tắc, định luật trong lập trình","slug":"Mot-so-nguyen-tac-dinh-luat-trong-lap-trinh","date":"2018-11-06T00:29:00.000Z","updated":"2018-11-06T00:41:54.871Z","comments":true,"path":"2018/11/Mot-so-nguyen-tac-dinh-luat-trong-lap-trinh.html","link":"","permalink":"http://nthung2112.github.io/2018/11/Mot-so-nguyen-tac-dinh-luat-trong-lap-trinh.html","excerpt":"Nguyên tắc DemeterCòn có tên gọi khác là nguyên tắc “càng biết ít càng tốt”. Demeter là tên gọi của Nữ thần nông nghiệp, cũng là nữ thần phân phát trong thần thoại Hi Lạp. Tên bà được dùng để đánh dấu sự ra đời của nguyên tắc này, đây có thể xem là một triết lý nền tảng của việc lập trình được sinh ra từ một aspect-oriented programming (AOP) project cùng tên.","text":"Nguyên tắc DemeterCòn có tên gọi khác là nguyên tắc “càng biết ít càng tốt”. Demeter là tên gọi của Nữ thần nông nghiệp, cũng là nữ thần phân phát trong thần thoại Hi Lạp. Tên bà được dùng để đánh dấu sự ra đời của nguyên tắc này, đây có thể xem là một triết lý nền tảng của việc lập trình được sinh ra từ một aspect-oriented programming (AOP) project cùng tên.Quan điểm cơ bản của nguyên tắc này chính là : tối giản sự hiểu biết của 1 object về cấu trúc, thuộc tính của các object khác ngoài nó (bao gồm các thành phần con). http://en.wikipedia.org/wiki/Law_of_Demeter Nói một cách đơn giản là không được tiếp xúc với thuộc tính, method của các object khác một cách trực tiếp. 12345#Vi phạm nguyên tắc Demeterconsole.log(aStudent.class.grade)#Không vi phạm nguyên tắc Demeterconsole.log(aStudent.getGrade()) Định luật Wirth“Software gets slower faster than hardware gets faster” – “Tốc độ tiến hóa của phần cứng không bằng tốc độ thoái hóa của phần mềm.” http://en.wikipedia.org/wiki/Wirth’s_law Có lẽ ý chính của nó là : lập trình ngày càng dùng nhiều tài nguyên phong phú nên framework phải luôn tiến hóa để phục vụ cho việc đó. Suy ra, tốc độ phần cứng dù có tang lên đi nữa thì tốc độ phần mềm cũng chẳng hề thay đổi gì. Định luật BrookĐây là một định luật dựa trên kinh nghiệm thực tế : “Đưa thêm người vào 1 project đang chậm, sẽ chỉ khiến nó càng chậm hơn.” Hay có thể nói theo một cách khác nữa là “Tập hợp 9 bà bầu lại cũng không thể khiến đứa trẻ ra đời sau 1 tháng.” Luận thuyết cơ bản của định luật này là Cần thời gian để quen với project Công sức dành cho việc communication sẽ tăng http://en.wikipedia.org/wiki/Brooks’s_law Định luật Conway“Organizations which design systems … are constrained to produce designs which are copies of the communication structures of these organizations.” “Một công ty thiết kế hệ thống thế nào cũng sẽ làm ra những thiết kế giống y hệt với thiết kế hệ thống của chính công ty họ.” http://en.wikipedia.org/wiki/Conway’s_law Nghiên cứu gần đây chỉ ra rằng hệ thống của công ty là nhân tố ảnh hưởng lớn nhất đến vấn đề phát sinh ra bug của sản phẩm. http://research.microsoft.com/apps/pubs/default.aspx?id=70535 Nguyên tắc bất ngờ nhỏ nhất (least astonishment)Trong trường hợp trên cùng 1 interface có 2 yếu tố hành xử mâu thuẫn với nhau, hoặc cách hành xử không rõ ràng thì cần phải chọn cách hành xử nào gây bất ngờ ít nhất cho người sử dụng. http://en.wikipedia.org/wiki/Principle_of_least_astonishment Đây là 1 nguyên tắc về giao diện người dùng. Một ví dụ đơn giản : Trên 1 interface có 2 chức năng : Ấn ctrl+Q để thoát chương trình. Nhập macro (lưu 1 tổ hợp phím mang 1 chức năng nào đó để tiện cho việc sử dụng về sau). Sẽ có trường hợp user muốn dùng Ctrl+Q cho macro của mình, nên hành xử đúng với nguyên tắc bất ngờ nhỏ nhất chính là : trong khi nhập macro thì ctrl+Q được coi như là tổ hợp phím bình thường, không phải là lệnh tắt chương trình. Đây chính là điều gây bất ngờ ít nhất cho người dùng. Nguyên tắc Boy ScoutNguyên tắc của các tổ chức Boy scout chính là : lúc đi phải sạch đẹp hơn lúc đến. Trong lĩnh vực lập trình thì nguyên tắc đó sẽ được hiểu là “Khi bạn checkin 1 module thì lúc đó nó phải đẹp hơn lúc bạn checkout.” Nguyên tắc YAGNIViết tắt của “You ain’t gonna need it” – Cái (chức năng, phần) ấy rồi sẽ không cần thiết. Đó là một câu khẩu ngữ nhắc nhở người lập trình rằng trong quy trình Extreme Programming (lập trình cực hạn) thì : “Chưa phải lúc cần thiết thì chưa được phép làm.” Nguyên tắc DRYViết tắt của “Don’t repeat yourself” – với ý nghĩa là “Đừng lặp lại những gì giống nhau”. http://en.wikipedia.org/wiki/Don’t_repeat_yourself Khi nguyên tắc này được áp dụng tốt, dù ta có thay đổi 1 phần thì những phần không liên quan cũng sẽ không bị thay đổi theo. Hơn nữa, những phần có liên quan sẽ được thay đổi cùng 1 lượt, giúp ích rất nhiều cho cả khâu estimate và khâu thực hiện. Nguyên tắc KISSViết tắt của “Keep it simple, stupid” – “Cứ đơn giản thôi, đồ ngu!”. Đây là 1 triết lí của Hải quân Mỹ. http://en.wikipedia.org/wiki/KISS_principle Những triết lý tương tự có thể kể đến là : Phương châm dao cạo Okham (Okham’s razor) – “Không đưa ra nhiều giả thiết nếu không cần thiết. Cái gì cần ít giả thiết để chứng minh sẽ không thể chứng minh được bằng nhiều giả thiết.” Albert Einstein – “Làm cái gì cũng nên đơn giản nhất có thể, nhưng đơn giản quá thì không được”. Leonardo da Vinci – “Đơn giản nhất chính là điêu luyện nhất”. Antoine de Saint- Exupéry – “Hoàn hảo, không phải là không thêm vào được nữa, mà là không thể bớt đi được nữa”. Nguyên tắc SOLIDTập hợp những nguyên tắc trong lập trình hướng đối tượng. Các chữ cái đầu hợp lại thành SOLID. http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)) SRP (Single Responsibility Principle) – “Một class chỉ được có 1 nhiệm vụ” hay nói cách khác, “nếu muốn chỉnh sửa class thì chỉ được phép có 1 và chỉ 1 lý do”. OCP (Open/closed principle) – “Mở class khi cần mở rộng nó, đóng class khi cần chỉnh sửa nó”. LSP (Liskov substitution principle) – “Subtype phải luôn có thể được thay thế bằng supertype”. ISP (Interface segregation principle) – “Việc dùng nhiều interface cho các client khác nhau, tốt hơn là việc chỉ dùng 1 interface cho cùng lúc nhiều mục đích” hay nói cách khác “Không được phép hạn chế access vào những method mà client không sử dụng”. DIP (Dependency inversion principle) – “Module tầng trên không được phụ thuộc vào module tầng dưới. Bất cứ module nào cũng phải phụ thuộc vào cái trừu tượng, không phải vào cái cụ thể”.","categories":[],"tags":[]},{"title":"Khi nào nên sử dụng PureComponent hoặc Component","slug":"Khi-nao-nen-su-dung-PureComponent-hoac-Component","date":"2018-10-17T00:57:00.000Z","updated":"2018-11-07T01:00:18.161Z","comments":true,"path":"2018/10/Khi-nao-nen-su-dung-PureComponent-hoac-Component.html","link":"","permalink":"http://nthung2112.github.io/2018/10/Khi-nao-nen-su-dung-PureComponent-hoac-Component.html","excerpt":"PureComponent tiền đề của nó là một phiên bản có hiệu suất cao hơn của Component. Điều này là đúng, nhưng hiệu suất đạt được đi cùng với một vài thứ đi kèm. Chúng ta hãy tìm hiểu về PureComponent và hiểu tại sao chúng ta nên sử dụng nó nhé.","text":"PureComponent tiền đề của nó là một phiên bản có hiệu suất cao hơn của Component. Điều này là đúng, nhưng hiệu suất đạt được đi cùng với một vài thứ đi kèm. Chúng ta hãy tìm hiểu về PureComponent và hiểu tại sao chúng ta nên sử dụng nó nhé. Component và PureComponent có một sự khác biệt1PureComponent chính xác giống như Component ngoại trừ việc đó là nó xử lý shouldComponentUpdate cho bạn. Khi props hoặc state thay đổi, PureComponent sẽ làm một shallow comparison (so sánh nông) trên cảm props và state. Component trên mặt khác sẽ không so sánh props và state của hiện tại với tương lai. Như vậy, component sẽ re-render bởi mặc định bất cứ khi nào shouldComponentUpdate gọi. Shallow Comparison 101Khi so sánh props và state trước và sau, một shallow comparison sẽ kiểm tra những giá trị nguyên thuỷ đó có cùng giá trị(ví dụ 1 bằng 1 hoặc true bằng với true) và rằng các references value là giống nhau giữa các giá trị javascript phức tạp như objects và arrays. Never MUTATEBạn có lẽ đã nghe không thay đổi objects và arrays trong props và state. Nếu bạn thay đổi object trong một component cha, component “pure” con của bạn sẽ không update. Mặc dù giá trị đã thay đổi ở component cha, component con sẽ so sánh reference tới props trước đó và không phát hiện ra sự khác biệt chúng vân cùng reference tới cùng một object. Thay vào đó trả về một objects mới khi bạn làm một sự thay đổi bằng cách tận dụng es6 cho object và array spreading hoặc sử dụng một thư viện để thi hành immutability. Có vấn đề với hiệu năng không?So sánh primitives và object references là một hoặt động vô cùng rẻ tiền. Nếu bạn có một danh sách của object con và một trong đó update, làm một kiểm tra trên props và state của chúng là so sánh nhanh như ánh sáng so với chi phí của việc re-render từng cái một. Những cách khác bạn có thể làm để tăng hiệu năngĐừng bind giá trị vào fuction trong renderBạn có một danh sách các items, mỗi lần chuyền một tham số độc nhất tới phương thức cha. Theo thứ tự bind parameter bạn có lẽ sẽ hoàn thành như thê này: 1&lt;CommentItem likeComment=&#123;() =&gt; this.likeComment(user.id)&#125; /&gt; vấn đề đó là mỗi lần component cha render method sẽ gọi, một function mới (với một reference mới) được tạo ra và chuyền xuống LikeComnent. Điều này có side effect của thay đổi props trên mỗi component con mà lần lượt sẽ là nguyên nhân tât cả chúng re-render, thậm chí tất cả dữ liệu là giống nhau. Để giải quyết vấn đề này, chỉ cần chuyền function nguyên mẫu từ component cha tới con. prop của LikeComent sẽ luôn luôn có cùng reference và không bao giờ gây ra re-render không cần thiết. 1&lt;CommentItem likeComment=&#123;this.likeComment&#125; userID=&#123;user.id&#125; /&gt; Sau đó trong component con tạo ra một class method sẽ reference props của nó: 1234567class CommentItem extends PureComponent &#123; ... handleLike() &#123; this.props.likeComment(this.props.userID) &#125; ...&#125; Đừng lấy dữ liệu trong renderXem xét một danh sách của các bài viết từ đó component hồ sơ của bạn sẽ hiển thị 10 người dùng bạn thích nhất. 123456render() &#123; const &#123; posts &#125; = this.props const topTen = [...posts].sort((a, b) =&gt; b.likes - a.likes).slice(0, 9) return //...&#125; TopTen sẽ có một new reference mỗi lần component re-render, mặc dù posts không có sự thay đổi và dữ liệu có cùng nguồn gốc. Điều này sau đó sẽ re-render list một cách không cần thiết. Bạn có thể giải quyết điều này bởi caching dữ liệu gốc. Cho ví dụ, đặt dữ liệu gốc trong state của component và update chỉ khi posts có updated. 12345678910111213componentWillMount() &#123; this.setTopTenPosts(this.props.posts)&#125;componentWillReceiveProps(nextProps) &#123; if (this.props.posts !== nextProps.posts) &#123; this.setTopTenPosts(nextProps.posts) &#125;&#125;setTopTenPosts(posts) &#123; this.setState(&#123; topTen: [...posts].sort((a, b) =&gt; b.likes - a.likes).slice(0, 9) &#125;)&#125; Nếu bạn sử dụng Redux, xem xét sử dụng reselect để tạo “selectors” để soạn và cache dữ liệu gốc. Tổng kếtAn toàn khi sử dụng pureComponent thay thế Component miễn là bạn theo hai quy tắc đơn giản sau: Thay đổi đột ngột reference value nhìn chung là không tốt. Nhưng vấn đề là phức tạp khi sử dụng PureComponent. Nếu bạn tạo ra một function, object, array mới trong render bạn (có lẽ) làm nó sai.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Redux hay MobX: Lý giải sự nhầm lẫn","slug":"Redux-hay-MobX-Ly-giai-su-nham-lan","date":"2018-09-06T00:18:00.000Z","updated":"2018-11-06T00:20:35.856Z","comments":true,"path":"2018/09/Redux-hay-MobX-Ly-giai-su-nham-lan.html","link":"","permalink":"http://nthung2112.github.io/2018/09/Redux-hay-MobX-Ly-giai-su-nham-lan.html","excerpt":"Chúng ta cần giải quyết vấn đề gì?Tất cả chúng ta đều muốn có một cách nào đó để quản lý state trong một ứng dụng. Nhưng bạn đã bao giờ tự hỏi nó giải quyết được vấn đề gì cho chúng ta chưa? Hầu hết các lập trình viên đều sử dụng một thư viện quản lý state ngay cả đối với những ứng dụng nhỏ. Hiển nhiên thôi mà, khi tất cả những người khác đều nói về chúng, tất nhiên chúng ta cũng phải bắt kịp xu thế chứ? Redux này, MobX này. Thế nhưng hầu hết các ứng dụng lại không cần đến những công cụ quản lý state phức tạp đến vậy. Nó còn nguy hiểm hơn, vì hầu hết mọi người sẽ không bao giờ gặp những vấn đề mà những thư viện như Redux hay MobX cố gắng để giải quyết.","text":"Chúng ta cần giải quyết vấn đề gì?Tất cả chúng ta đều muốn có một cách nào đó để quản lý state trong một ứng dụng. Nhưng bạn đã bao giờ tự hỏi nó giải quyết được vấn đề gì cho chúng ta chưa? Hầu hết các lập trình viên đều sử dụng một thư viện quản lý state ngay cả đối với những ứng dụng nhỏ. Hiển nhiên thôi mà, khi tất cả những người khác đều nói về chúng, tất nhiên chúng ta cũng phải bắt kịp xu thế chứ? Redux này, MobX này. Thế nhưng hầu hết các ứng dụng lại không cần đến những công cụ quản lý state phức tạp đến vậy. Nó còn nguy hiểm hơn, vì hầu hết mọi người sẽ không bao giờ gặp những vấn đề mà những thư viện như Redux hay MobX cố gắng để giải quyết.Ngày nay, một hiện trạng mà chúng ta dễ dàng thấy là việc mọi người đều viết ra những frontend app với các component. Component thì có state nội tại. Ví dụ trong React thì state nội tại đó được xử lý bằng this.state và this.setState(). Với những app lớn, vấn đề guản lý state có thể trở nên khó khăn với state nội bộ bởi vì: Một component cần phải chia sẻ state với một component khác. Một component cần phải thay đổi state của một component khác. Đến một lúc nào đó, vấn đề này càng ngày càng trở nên khó giải quyết khi nó trở thành một đống hỗn loạn các state object và các thay đổi diễn ra chồng chéo nhau khắp các component và rất khó để chúng ta có thể quản lý tất cả một cách hiệu quả. Suy ra để giải quyết vấn đề này, chúng ta có thể sử dụng thư viện như MobX hay Redux. Những thư viện này cung cấp cho chúng ta công cụ để lưu giữ state, thay đổi state và nhận những thay đổi của state. Bạn có một chỗ để tìm state, một chỗ để thay đổi nó và cũng một chỗ để nhận các thay đổi. Chúng tuân theo nguyên tắc single source of truth (chỉ một nơi để lưu trữ toàn bộ state). Nó làm cho việc quản lý state trở nên dễ dàng hơn vì nó được tách rời khỏi các component của bạn. Các thư viện quản lý state như Redux hay MobX thường có các add-on đi kèm, như với React thì chúng ta có react-redux và mobx-react, để cung cấp cho các component cách để truy cập các state. Thường thì các component đó được gọi là container component, hay chính xác hơn là, connected component. Bạn có thể truy cập hoặc thay đổi state từ bất cứ đâu trong ứng dụng của bạn bằng cách biến các component thành các connected component. Redux và MobX có gì khác nhau?Trước khi chúng ta nói về những khác biệt, tôi muốn nói về một số điểm chung giữa MobX và Redux. Cả 2 thư viện đều được dùng để quản lý state trong các ứng dụng Javascript. Chúng không nhất thiết phải đi kèm với một thư viện như React. Chúng cũng được dùng trong những thư viện khác như AngularJs hay VueJs nữa. Nhưng chúng kết hợp rất tốt với triết lý của React. Nếu bạn chọn dùng một thư viện để quản lý state, bạn sẽ không bị ràng buộc bởi nó. Bạn có thể chuyển qua sử dụng một thư viện khác bất kỳ lúc nào. Bạn hoàn toàn có thể chuyển từ MobX sang Redux hoặc ngược lại. Redux bởi Dan Abramov và Andrew Clark là một biến thể của kiến trúc flux. Trái ngược với flux, nó chỉ sử dụng duy nhất một store để lưu trữ state. Hơn nữa, thay vì sử dụng một dispatcher, nó dùng các pure function để thay đổi state. Redux bị ảnh hưởng rất nhiều bởi các nguyên tắc của functional programming (FP). Chúng ta có thể có FP trong Javascript, nhưng rất nhiều người đã quen với OOP như Java, và họ gặp rất nhiều khó khăn trong việc ứng dụng các nguyên tắc này. Điều này cũng lý giải tại sao MobX có thể sẽ dễ học hơn đối với người mới. Bởi vì Redux áp dụng các nguyên tắc của FP, nó sử dụng hàm thuần khiết. Một hàm nhận input, trả về output và không có thêm bất cứ sự phụ thuộc nào khác. Một hàm thuần khiết luôn trả về cùng một output đối với cùng một input và không hề có side effect. 1(state, action) =&gt; newState Redux state là immutable. Thay vì thay đổi state, bạn luôn trả về một state mới. Bạn không bao giờ trực tiếp thay đổi object state hay phụ thuộc vào tham chiếu đến object. 123456789// Đừng làm thế này trong Redux vì nó trực tiếp thay đổi arrayfunction addAuthor(state, action) &#123; return state.authors.push(action.author);&#125;// Luôn giữ state immutable và trả về object mớifunction addAuthor(state, action) &#123; return [ ...state.authors, action.author ];&#125; Điều cuối cùng nhưng ko kém phần quan trọng, state của bạn được normalize như trong một database. Các entity chỉ tham chiếu đến nhau bằng id. Đó là cách làm tốt nhất. Mặc dù không phải tất cả mọi người đều làm vậy, bạn có thể sử dụng một thư viện như normalizr để đạt được state đã chuẩn hóa. Normalized state giúp cho chúng ta có một state phẳng và lưu giữ các entity như một nguồn duy nhất. 123456789101112&#123; post: &#123; id: 'a', authorId: 'b', ... &#125;, author: &#123; id: 'b', postIds: ['a', ...], ... &#125;&#125; Trong khi đó, MobX bởi Michel Weststrate lại chịu ảnh hưởng của lập trình hướng đối tượng, nhưng cũng một phần bởi lập trình phản ứng (Reactive programming). Nó đống gói state của bạn thành những observable. Vì thế bạn có mọi khả năng của một Observable trong state của bạn. Dữ liệu có thể chỉ cần có setter và getter thôi, nhưng observable làm cho chúng ta có khả năng nhận update khi dữ liệu thay đổi. Trong MobX, state là mutable. Nghĩa là bạn thay đổi state trực tiếp: 123function addAuthor(author) &#123; this.authors.push(author);&#125; Thêm nữa, các entity tồn tại dưới một cấu trúc dữ liệu lồng nhau. Bạn không cần chuẩn hóa state. State được giữ không chuẩn hóa và có thể lồng nhiều tầng. 12345678910&#123; post: &#123; id: 'a', ... author: &#123; id: 'b', ... &#125; &#125;&#125; 1 Store và nhiều StoreTrong Redux bạn giữ mọi state trong một global store/global state. State object này là nguồn dữ liệu duy nhất của bạn. Mặt khác, chúng ta sử dụng nhiều reducer để thay đổi state này. Trái lại, MobX lại dùng nhiều store. Tương tự như reducer của Redux, bạn có thể áp dụng chia để trị bằng cách phân bổ chúng thành nhiều tầng dữ liệu. Bạn có thể muốn có các domain entity trong một store riêng nhưng vẫn có khả năng kiểm soát state của view trong một trong các store của bạn. Sau cùng thì bạn là người quyết định và định hướng lại cấu trúc state nào có lợi cho ứng dụng của bạn nhất. Trên lý thuyết bạn cũng có thể có nhiều store trong Redux. Không có ai bắt bạn phải dùng chỉ một store cả. Nhưng đó không phải là cách người ta khuyên dùng Redux. Nó sẽ làm trái lại những best practice nếu bạn dùng nhiều store. Trong Redux bạn chỉ cần có một store thôi và phản ứng với những thay đổi thông qua reducer và các global event. Implementation nhìn như thế nào?Trong Redux, bạn sẽ cần đoạn code như dưới đây để thêm một user vào global state. Bạn có thể thấy chúng ta có thể sử dụng spread operator để trả về một state object mới. Bạn cũng có thể dùng Object.assign() để tạo ra một immutable object trong ES5. 1234567891011121314151617181920212223const initialState = &#123; users: [ &#123; name: 'Dan' &#125;, &#123; name: 'Michel' &#125; ]&#125;;// reducerfunction users(state = initialState, action) &#123; switch (action.type) &#123; case 'USER_ADD': return &#123; ...state, users: [ ...state.users, action.user ] &#125;; default: return state; &#125;&#125;// action&#123; type: 'USER_ADD', user: user &#125;; Bạn sẽ cần phải gọi dispatch({ type: ‘USER_ADD’, user: user }); để thêm một user mới vào global state. Trong MobX, một store sẽ chỉ quản lý một substate (như một reducer trong Redux quản lý một substate) nhưng bạn có thể thay đổi state một cách trực tiếp. Annotation @observable giúp cho chúng ta có khả năng nhận update khi state thay đổi. 12345678910class UserStore &#123; @observable users = [ &#123; name: 'Dan' &#125;, &#123; name: 'Michel' &#125; ];&#125; Giờ thì chúng ta có thể gọi userStore.users.push(user); vào một instance của store. Tuy vậy best practice đó là xử lý việc thay đổi state rõ ràng hơn với các action. 1234567891011121314class UserStore &#123; @observable users = [ &#123; name: 'Dan' &#125;, &#123; name: 'Michel' &#125; ]; @action addUser = (user) =&gt; &#123; this.users.push(user); &#125;&#125; Bạn có thể bắt buộc việc sử dụng action bằng cách cấu hình Mobx với configure({ enforceActions: true });. Giờ thì bạn có thể thay đổi state bằng cách gọi userStore.addUser(user); với một instance của store. Bạn đã thấy cách chúng ta cập nhật state trong cả Redux và MobX. Chúng rất khác nhau. Trong Redux state của bạn là read-only. Bạn chỉ có thể thay đổi state bằng các action rõ ràng. Ngược lại, state trong MobX lại có thể vừa read và vừa write. Bạn có thể thay đổi state trực tiếp mà không cần dùng action, nhưng bạn cũng có thể bắt buộc sử dụng action với cấu hình đã nói ở trên. Learning curve của quản lý state trong ReactCả Redux và MobX đều hầu hết được sử dụng trong các ứng dụng React. Nhưng bản chất của chúng thì là những thư viện quản lý state độc lập, và có thể được dùng mà không cần đến React. Chúng còn có những thư viện hỗ trợ tương thích để làm cho việc kết hợp với React component trở nên dễ dàng hơn, đó là react-redux cho Redux + React và mobx-react cho MobX + React. Trong những thảo luận trên các diễn đàn công nghệ thì một vấn đề mà người ta hay nói đến đó là learning curve của Redux. Thường thì nó diễn ra trong bối cảnh mọi người bắt đầu học React nhưng đã muốn tìm hiểu là làm thế nào để quản lý state với Redux. Nhiều người sẽ cho rằng React và Redux nằm riêng thì có một learning curve khá tốt, nhưng kết hợp cả 2 lại thì chúng lại khó hiểu hơn nhiều. Vì thế MobX được coi là một giải pháp thay thế vì nó phù hợp hơn với những người mới học. Tuy vậy, tôi muốn gợi ý một cách tiếp cận khác cho các bạn mới học React về vấn đề quản lý state, đó là bắt đầu với chính những tính năng quản lý state nội bộ của component. Trong một ứng dụng React, điều đầu tiên mà bạn sẽ học đó là các hàm nằm trong vòng đời của một component và làm thế nào để quản lý state bằng setState() và this.state. Đây là một cách học mà tôi đánh giá rất cao. Nếu không theo cách này, bạn sẽ rất dễ bị choáng ngợp bởi hệ sinh thái của React. Đến một thời điểm nào đó với cách học này, bạn sẽ nhận ra rằng việc quản lý các state nội bộ của component càng ngày càng trở nên khó hơn. Đó là lúc mà chúng ta trả lời câu hỏi: Vấn đề mà MobX và Redux giải quyết cho chúng ta là gì? Cả 2 đều cung cấp một cách để quản lý state của ứng dụng độc lập với các component. State được tách biệt hoàn toàn khỏi component. Component có thể truy cập state, thay đổi nó và nhận những cập nhật với state mới. State đó chính là single source of truth. Redux hay MobX cho người mới?Một khi bạn đã quen với việc sử dụng component và quản lý state nội bộ, bạn có thể chọn một thư viện để giải quyết vấn đề này. Sau khi đã dùng cả 2 thư viện, tôi cho rằng MobX rất phù hợp đối với người mới. Chúng ta đều đã thấy MobX cần ít code hơn, dù cho nó sử dụng vài loại annotation mà có lẽ chúng ta chưa cần hiểu về chúng. Với MobX bạn không cần phải làm quen với lập trình hàm hay phải hiểu những thuật ngữ như immutability. Lập trình hàm là một mô hình đang phát triển rất nhanh, nhưng lại xa lạ với hầu hết các lập trình viên Javascript. Dù thế giới lập trình đang dần được đẩy theo xu hướng này nhưng không phải ai cũng có kinh nghiệm về nó, nên các nguyên lý của MobX sẽ dễ dàng để hiểu hơn đối với những người đã biết về hướng đối tượng. Một ứng dụng đang phát triểnTrong MobX, bạn thay đổi object có annotation và component của bạn sẽ tự động render lại. MobX đem đến nhiều xử lý nội bộ hơn là Redux, nên sẽ làm cho nó dễ dùng hơn lúc đầu vì bạn phải viết ít code hơn. Nếu bạn đã biết Angular thì sẽ thấy dùng MobX giống như là two-way data binding vậy. Bạn giữ một vài state ở đâu đó, theo dõi state bằng annotation và để cho component tự update một khi state thay đổi. 12// component&lt;button onClick=&#123;() =&gt; store.users.push(user)&#125; /&gt; Cách tốt hơn để làm điều này đó là sử dụng @action trong store. 1234567// component&lt;button onClick=&#123;() =&gt; store.addUser(user)&#125; /&gt;// store@action addUser = (user) =&gt; &#123; this.users.push(user);&#125; Nó sẽ làm cho việc thay đổi state trở nên minh bạch hơn với các action. Hơn nữa chúng ta cũng có thể bắt buộc việc sử dụng action để thay đổi state bằng cách mà tôi đã nói ở trên. 1234// root fileimport &#123; configure &#125; from 'mobx';configure(&#123; enforceActions: true &#125;); Việc thay đổi state trực tiếp trong store như chúng ta đã làm ở ví dụ thứ nhất sẽ không còn hoạt động nữa. Việc sử dụng action là một trong các best practice của MobX. Hơn nữa một khi bạn chỉ dùng action, bạn đã áp dụng các ràng buộc của Redux. Tôi xin gợi ý rằng chúng ta nên sử dụng MobX để bắt đầu một dự án. Một khi ứng dụng đã bắt đầu to lên, đó cũng là điều dễ hiểu khi chúng ta bắt buộc việc sử dụng các action. Điều này cũng đi theo đường lối của Redux đó là chúng ta không bao giờ thay đổi trực tiếp state mà lúc nào cũng phải thông qua các action. Chuyển sang ReduxKhi mà ứng dụng của bạn lớn dần và có thêm nhiều dev cùng làm việc, bạn nên chuyển qua dùng Redux. Bản chất của nó là việc nó bắt buộc sử dụng action để thay đổi state chứ không thông qua config như MobX. Action bao gồm kiểu và một payload và reducer có thể dùng để thay đổi state. 12// reducer(state, action) =&gt; newState Redux cung cấp cho bạn cả một cấu trúc để quản lý state với những ràng buộc rõ ràng. Đó là lý do mà Redux rất thành công. Một điểm mạnh khác của Redux đó là việc sử dụng nó ở server side. Bởi vì chúng ta đang làm việc với Javascript object, bạn có thể gửi state qua mạng được. Serialize và deserialize các state object hoạt động một cách tự động mà bạn không cần làm thêm gì cả. Bạn cũng có thể làm như thế với MobX nữa. MobX thì không có nhiều ràng buộc nhưng bạn cũng có thể tự tạo ra chúng bằng các config. Đó là lí do tại sao tôi không nói là bạn không thể dùng MobX với những ứng dụng lớn, nhưng Redux thì giúp chúng ta có một cách làm nhất quán hơn. Doc của MobX cũng có nói là: “MobX không hướng dẫn cho bạn cách bạn cấu trúc code, lưu state ở đâu hay xử lý các event như thế nào.” Team của bạn cần phải tự cấu trúc việc quản lý state nếu sử dụng thư viện này. Cuối cùng thì việc học quản lý state không khó như chúng ta nghĩ. Để tóm gọn lại vấn đề, một người mới học React đầu tiên sẽ học cách sử dụng setState() và this.state. Sau một thời gian thì họ sẽ thấy khó khăn với việc chỉ dùng setState() để quản lý state cho cả ứng dụng. Khi đi tìm giải pháp, họ gặp được những thư viện như MobX hay Redux. Nhưng nên chọn cái nào bây giờ? Bởi vì MobX có ít ràng buộc hơn, cần ít code hơn và dùng cũng tương tự như setState(), tôi nghĩ nó rất thích hợp với các ứng dụng vừa và nhỏ. Một khi ứng dụng đã to dần lên, bạn nên xem xét việc tạo ra thêm ràng buộc bằng config trong MobX hoặc chuyển sang dùng Redux. Lời kếtMỗi khi tôi đọc comment về tranh luận giữa Redux và MobX, luôn luôn có 1 comment kiểu này: “Redux có quá nhiều code thừa, bạn nên dùng MobX đi. Tôi đã bỏ được XXX dòng code đấy.” Comment này có thể đúng, nhưng họ chưa xem xét đến những sự đánh đổi. Redux có nhiều code thừa hơn MobX, vì nó được thêm vào vì những ràng buộc cụ thể trong thiết kế. Nó cho phép bạn có cái nhìn tổng quan hơn về state của ứng dụng dù ứng dụng đó lớn thế nào. Không phải tự nhiên mà nó là một trong những thư viện phổ biến nhất đâu. Thư viện Redux có kích thước khá là nhỏ. Hầu hết thời gian bạn sẽ dành để xử lý Javascript object và array. Nó giống với Javascript thuần hơn là MobX. Trong MobX, chúng ta gói object và array vào trong observable object và điều này giấu đi hầu hết các boilerplate code. Nó được xây dựng dựa trên tính trừu tượng ẩn. Nó sẽ thực hiện một phép thuật nào đó và code bạn tự nhiên chạy được, nhưng đồng thời cũng làm cho các cơ chế ở tầng dưới trở nên khó hiểu hơn nhiều. Với Redux thì chúng ta test và debug ứng dụng dễ hơn vì nó chỉ sử dụng Javascript thuần. Trong khi với Redux, chúng ta có một cách nhất định để làm mọi thứ thì MobX lại ít ràng buộc hơn. Nhưng dù vậy chúng ta vẫn nên tuân theo các best practice trong MobX, vì như thế sẽ dễ dàng hơn trong việc lí giải thay đổi của state. Cả 2 thư viện đều rất tốt. Trong khi Redux đã được chứng minh trong thế giới React, MobX đang dần trở thành một giải pháp thay thế đáng chú ý.","categories":[],"tags":[{"name":"mobx","slug":"mobx","permalink":"http://nthung2112.github.io/tags/mobx/"},{"name":"redux","slug":"redux","permalink":"http://nthung2112.github.io/tags/redux/"}]},{"title":"Cách tối ưu trang web của bạn với nén Gzip","slug":"Cach-toi-uu-trang-web-cua-ban-voi-nen-Gzip","date":"2018-08-07T13:45:00.000Z","updated":"2018-09-07T13:53:33.634Z","comments":true,"path":"2018/08/Cach-toi-uu-trang-web-cua-ban-voi-nen-Gzip.html","link":"","permalink":"http://nthung2112.github.io/2018/08/Cach-toi-uu-trang-web-cua-ban-voi-nen-Gzip.html","excerpt":"Nén là một phương pháp đơn giản, hiệu quả để tiết kiệm băng thông và tăng tốc trang web của bạn. Tôi đã ngần ngại khi gợi ý sử dụng nén gzip khi tăng tốc tải file javascript của bạn vì một vài vấn đề ở trình duyệt cũ. Nhưng giờ là thế kỷ 21. Hầu hết các truy cập đến trang của tôi đều từ các trình duyệt hiện đại, và thẳng thắn mà nói, hầu hết người dùng của tôi đều am hiểu công nghệ. Tôi không muốn làm mọi người chậm lại vì một vài người đang bám lấy IE 4 trên Windows 95. Google và Yahoo dùng nén gzip. Một trình duyệt hiện đại cần được tận hưởng nội dung và tốc độ của web hiện đại - vậy thì sử dụng gzip mã hóa nó. Dưới đây là cách cài đặt.","text":"Nén là một phương pháp đơn giản, hiệu quả để tiết kiệm băng thông và tăng tốc trang web của bạn. Tôi đã ngần ngại khi gợi ý sử dụng nén gzip khi tăng tốc tải file javascript của bạn vì một vài vấn đề ở trình duyệt cũ. Nhưng giờ là thế kỷ 21. Hầu hết các truy cập đến trang của tôi đều từ các trình duyệt hiện đại, và thẳng thắn mà nói, hầu hết người dùng của tôi đều am hiểu công nghệ. Tôi không muốn làm mọi người chậm lại vì một vài người đang bám lấy IE 4 trên Windows 95. Google và Yahoo dùng nén gzip. Một trình duyệt hiện đại cần được tận hưởng nội dung và tốc độ của web hiện đại - vậy thì sử dụng gzip mã hóa nó. Dưới đây là cách cài đặt. Khoan, khoan, khoan: tại sao chúng ta lại làm điều này?Trước khi chúng ta bắt đầu, tôi nên giải thích nội dung được mã hóa là gì. Khi bạn yêu cầu một file, ví dụ như http://www.yahoo.com/index.html, trình duyệt của bạn nói chuyện với một web server. Đoạn hội thoại sẽ diễn ra kiểu như sau: Trình duyệt: Này, GET cho tôi /index.html Server: Ok, để tôi tìm xem index.html có không Server: Tìm thấy rồi! Mã phản hồi của anh đây (200 OK) và tôi đang gửi file. Trình duyệt: 100KB? Ôi… chờ tí, chờ tí… ok, tải được rồi nhé. Dĩ nhiên, header và giao thức thực tế sẽ hình thức hơn nhiều (quan sát chúng với Live HTTP Headers nếu bạn muốn). Nhưng nó hoạt động, và bạn nhận được file. Thế vấn đề là gì?Chà, hệ thống hoạt động, nhưng không hiệu quả. 100KB là một đống text, và thành thật thì, HTML khá là trùng lặp. Mỗi thẻ , và đều có một thẻ đóng gần như tương tự. Các từ lặp đi lặp lại trong cả document. Bạn chia nó ra như thế nào thì HTML (và người anh em mạnh mẽ của nó, XML) đều không tinh gọn. Và xử lý thế nào với một file quá lớn? Nén nó! Nếu chúng ta có thể gửi một file .zip đến trình duyệt (index.html.zip) thay vì index.html thông thường, chúng ta sẽ tiết kiệm được băng thông và thời gian tải. Trình duyệt có thể tải file đã nén, giải nén nó, và sau đó hiển thị cho người dùng, người đang có tâm trạng tốt vì trang tải nhanh. Đoạn hội thoại giữa trình duyệt và server sẽ trông như sau: Trình duyệt: Này, tôi có thể GET index.html không? Tôi sẽ lấy phiên bản nén của nó nếu anh có. Server: Để tôi tìm… ừ, có đây. Và anh sẽ lấy bản nén? Tuyệt. Server: Ok, tôi tìm thấy index.html (200 OK), và tôi đang nén và gửi nó qua cho anh. Trình duyệt: Tuyệt! Chỉ có mỗi 10KB. Tôi sẽ giải nén và hiển thị cho người dùng. Công thức rất đơn giản: File nhỏ hơn = tải nhanh hơn = người dùng hạnh phúc. Không tin tôi à? Phần HTML của trang chủ của Yahoo giảm từ 101KB xuống còn 15KB sau khi nén: Chi tiết (không quá) lằng nhằngPhần khó trong quá trình trao đổi này là trình duyệt và server phải biết rằng việc gửi nhận file nén là được chấp nhận. Việc đồng ý này bao gồm 2 phần Trình duyệt gửi một header nói với server rằng nó chấp nhận nội dung được nén (gzip và deflate là 2 cách nén): Accept-Encoding: gzip, deflate Server gửi một phản hồi nếu nội dung thực sự được nén: Content-Encoding: gzip Nếu server không gửi content-encoding trong header của phản hồi, điều đó có nghĩa là file không được nén (điều mặc định ở nhiều server). Header “Accept-Encoding” chỉ là một yêu cầu từ trình duyệt, không phải mệnh lệnh. Nếu server không muốn gửi về nội dung được nén, trình duyệt sẽ phải tải về phiên bản nặng nề thông thường. Thiết lập server“Tin tốt” là chúng ta không thể kiểm soát được trình duyệt. Nó sẽ gửi header Accept-Encoding: gzip, deflate hoặc là không. Công việc của chúng ta là cấu hình server để nó trả về nội dung được nén nếu trình duyệt có thể xử lý, tiết kiệm băng thông cho mọi người (và đem lại một người dùng hạnh phúc). Đối với IIS, bật cấu hình nén.aspx) ở trong cài đặt. Trong Apache, bật cấu hình nén nội dung xuất khá là đơn giản. Thêm các dòng sau vào file .htaccess: 123456789101112131415# compress text, html, javascript, css, xml:AddOutputFilterByType DEFLATE text/plainAddOutputFilterByType DEFLATE text/htmlAddOutputFilterByType DEFLATE text/xmlAddOutputFilterByType DEFLATE text/cssAddOutputFilterByType DEFLATE application/xmlAddOutputFilterByType DEFLATE application/xhtml+xmlAddOutputFilterByType DEFLATE application/rss+xmlAddOutputFilterByType DEFLATE application/javascriptAddOutputFilterByType DEFLATE application/x-javascript# Or, compress certain file types by extension:&lt;files *.html&gt;SetOutputFilter DEFLATE&lt;/files&gt; Apache có 2 tùy chọn nén: mod_deflate dễ dàng cài đặt và là chuẩn. mod_gzip có vẻ mạnh hơn: bạn có thể nén trước nội dung. Deflate nhanh và hoạt động được, nên tôi sử dụng nó; dùng mod_gzip nếu bạn thấy thích. Trong cả 2 trường hợp, Apache đều kiểm tra xem trình duyệt có gửi header “Accept-Encoding” không và gửi lại phiên bản nén hoặc phiên bản thường của file. tuy nhiên, một số trình duyệt cũ sẽ phát sinh vấn đề (chi tiết bên dưới) và có một số chỉ lệnh đặc biệt mà bạn có thể thêm vào để sửa. Nếu bạn không thể thay đổi file .htaccess, bạn có thể dùng PHP để trả về nội dung nén. Thêm phần mở rộng .php vào file html của bạn và thêm đoạn code này ở đầu file: 12345&lt;?phpif (substr_count($_SERVER[‘HTTP_ACCEPT_ENCODING’], ‘gzip’)) ob_start(“ob_gzhandler”);else ob_start();?&gt; Chúng ta kiểm tra header “Accept-Encoding” và trả về phiên bản nén gzip của file (ngược lại là phiên bản thường). Việc này gần như là tự xây dựng webserver của bạn (rất thú vị!). Nhưng thực sự thì, hãy thử sử dụng Apache để nén nội dung trả về nến bạn có thể. Bạn không muốn nghịch ngợm mấy file của mình đâu. Xác minh nội dung nén của bạnKhi bạn đã cấu hình xong server của mình, hãy kiểm tra để đảm bảo rằng bạn thực sự trả về nội dung nén. Online: sử dụng công cụ kiểm tra gzip online để kiểm tra liệu trang của bạn có được nén không. Trên trình duyệt: trong Chrome, mở Developer Tools &gt; Network (Firefox/IE sẽ tương tự). Tải lại trang, và nhấn vào dòng network tương ứng với trang (ví dụ www.google.com). Header Content-Encoding: gzip nghĩa là nội dung trả về đã được nén. Nhấn biểu tượng “Use large rows” để hiển thị thêm thông tin, bao gồm cả kích cỡ file nén và kích cõ thực. Hãy chuẩn bị cho điều kỳ diệu ở kết quả. Trang chủ của instacalc thu lại từ 36k xuống còn 10k, giảm 75% kích cỡ. Thử một số ví dụTôi đã làm một số trang và một ví dụ cho phép tải về: index.html - không nén (trên server này, tôi mặc định sử dụng nén) index.htm - nén với Apache .htaccess sử dụng luật *.htm index.php - nén sử dụng PHP header Cứ thoải mái tải file, để chúng trong server của bạn và chỉnh sửa các cài đặt. Lưu ýDù khá thú vị nhưng HTTP Compression cũng chứa một số vấn đề. Dưới đây là những thứ cần phải coi chừng: Trình duyệt cũ: Phải, một số trình duyệt vẫn còn có rắc rối với nội dung nén (chúng nói rằng có thể chấp nhận nội dung nén, nhưng thực sự thì không thể). Nếu trang của bạn bắt buộc phải hoạt động với Netscape 1.0 trên Windows 95, bạn có lẽ sẽ không muốn dùng HTTP Compression. Apache mod_deflate có một số luật cho phép tránh việc nén trên một số trình duyệt cũ. Nội dung đã nén: Hầu hết ảnh, nhạc và video đều đã được nén. Đừng tốn thời gian nén chúng lần nữa. Trên thực tế, bạn sẽ chỉ muốn nén “big 3” (HTML, CSS và Javascript). CPU-load: nén nội dung khi nhận được yêu cầu sẽ tiêu tốn thời gian của CPU và tiết kiệm băng thông. Thường thì đây là sự đánh đổi tốt nếu biết tốc độ nén. Có nhiều cách để nén trước các nội dung tĩnh và gửi các bản nén này. Việc này cần được cấu hình thêm; cho dù không thể thì việc nén nội dung trả về vẫn là điều tốt. Sử dụng CPU cho người dùng có trải nghiệm nhanh hơn cũng khá là đáng, khi sự chú ý không đáng kể. Nén là một trong những cách nhanh nhất để cải thiện hiệu năng cho trang web của bạn. Hãy đi, cài đặt, và để cho người dùng của bạn thận hưởng lợi ích nó mang lại.","categories":[],"tags":[]},{"title":"Functional trong Javascript với ES6 Recursive Patterns","slug":"Functional-trong-Javascript-voi-ES6-Recursive-Patterns","date":"2018-07-24T05:28:00.000Z","updated":"2018-09-07T13:27:14.693Z","comments":true,"path":"2018/07/Functional-trong-Javascript-voi-ES6-Recursive-Patterns.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Functional-trong-Javascript-voi-ES6-Recursive-Patterns.html","excerpt":"What’s the deal here?Functional programming has been on the rise and is a topic that is very exciting to me. It allows me to write terse, declarative code that is easy to test and reason about. What is functional programming? I’ll defer that answer to someone with more knowledge on the subject, Eric Elliot: Functional programming (often abbreviated FP) is the process of building software by composing pure functions, avoiding shared state, mutable data,and side-effects. Functional programming is declarative rather than imperative, and application state flows through pure functions. Contrast with object oriented programming, where application state is usually shared and colocated with methods in objects.","text":"What’s the deal here?Functional programming has been on the rise and is a topic that is very exciting to me. It allows me to write terse, declarative code that is easy to test and reason about. What is functional programming? I’ll defer that answer to someone with more knowledge on the subject, Eric Elliot: Functional programming (often abbreviated FP) is the process of building software by composing pure functions, avoiding shared state, mutable data,and side-effects. Functional programming is declarative rather than imperative, and application state flows through pure functions. Contrast with object oriented programming, where application state is usually shared and colocated with methods in objects. ES6 brings many features that allow us to easily write pure functions, rest/spread being one of the most powerful. Using rest params, we’re able to “loop without loops” with recursion. In this article, we’re going to rewrite many commonly used JavaScript methods/functions that allow for functional patterns. PrefaceThe following functions are for demonstration and learning purposes. Many functions below are tail-recursive and should be optimized further. Fixing tail-recursion is not the subject of this article. ES6 brings tail-call optimization, but must be used in conjunction with &#39;use strict&#39; . HeadReturn the first item in an array. Is useful when you need to separate the first item from the rest of the array items. To do this, we make use of destructuring assignment. 1const head = ([x]) =&gt; x Example usage: 12const array = [1,2,3,4,5]head(array) // 1 TailReturn all but the first item in an array. 1const tail = ([, ...xs]) =&gt; xs Which is essentially the same as writing: 1const tail = ([x, ...xs]) =&gt; xs Since we don’t need to use x in the returned output, we can drop it, but keep the comma to get the rest of the items in the array. Example usage: 12const array = [1,2,3,4,5]tail(array) // [2,3,4,5] DefReturn if argument supplied is defined. 1const def = x =&gt; typeof x !== 'undefined' Example usage: 123const defined = 'this is defined'def(defined) // truedef(doesntExist) // false UndefReturn if argument supplied is undefined. 1const undef = x =&gt; !def(x) Example usage: 123const defined = 'this is defined'undef(defined) // falseundef(doesntExist) // true CopyReturns a copy of an array without using Array.slice(). Makes use of spread. 1const copy = array =&gt; [...array] Example usage: 123456let array = [1,2,3,4,5]let copied = copy(array)copied.push(6)array // [1,2,3,4,5]copied // [1,2,3,4,5,6] LengthReturn the length of an array. This is a very simple form of looping through an array with recursion, even though the values of the array don’t matter in this case (increments up starting at 1 for every item in array). We include the len param to avoid tail recursion. 1const length = ([x, ...xs], len = 0) =&gt; def(x) ? length(xs, len + 1) : len If we don’t care about tail recursion, we can write it as: 1const length = ([x, ...xs]) =&gt; def(x) ? 1 + length(xs) : 0 This would add a stack frame for each item in the array, whereas the version that avoids tail recursion, replaces a single stack frame. If the array passed in is large enough, it will throw “Maximum call stack size exceeded”. Example usage: 12const array = [1,2,3,4,5]length(array) // 5 ReverseReturn a reversed array. 1const reverse = ([x, ...xs]) =&gt; def(x) ? [...reverse(xs), x] : [] Example usage: 12const array = [1,2,3,4,5]reverse(array) // [5,4,3,2,1] Array.reverse() is okay, but it modifies the value in place which is a side-effect. Consider the following: 12345678910const array = [1,2,3,4,5]const newArray = array.reverse() // [5,4,3,2,1]array // [5,4,3,2,1]// using the reverse method we just createdconst array2 = [1,2,3,4,5]const newArray2 = reverse(array2) // [5,4,3,2,1]array2 // [1,2,3,4,5] FirstReturns a new array that contains the first n items of the given array. 1const first = ([x, ...xs], n = 1) =&gt; def(x) &amp;&amp; n ? [x, ...first(xs, n - 1)] : [] Example usage: 12const array = [1,2,3,4,5]first(array, 3) // [1,2,3] LastReturns a new array that contains the last n items of the given array. 1const last = (xs, n = 1) =&gt; reverse(first(reverse(xs), n)) Example usage: 12const array = [1,2,3,4,5]last(array, 3) // [3,4,5] SliceReturns a new array with value inserted at given index. 12345const slice = ([x, ...xs], i, y, curr = 0) =&gt; def(x) ? curr === i ? [y, x, ...slice(xs, i, y, curr + 1)] : [x, ...slice(xs, i, y, curr + 1)] : [] Example usage: 12const array = [1,2,4,5]slice(array, 2, 3) // [1,2,3,4,5] isArrayReturns if the value supplied is an array. Allows us to write Array.isArray() in a more functional manner. 1const isArray = x =&gt; Array.isArray(x) Example usage: 12const array = [1,2,3,4,5]isArray(array) // true FlattenCombines nested arrays into a single array. 123const flatten = ([x, ...xs]) =&gt; def(x) ? isArray(x) ? [...flatten(x), ...flatten(xs)] : [x, ...flatten(xs)] : [] Example usage: 123const array1 = [1,2,3]const array2 = [4,[5,[6]]]flatten([array1, array2]) // [1,2,3,4,5,6] SwapReturn a new array with 2 items swapped based on their index. 1234567const swap = (a, i, j) =&gt; ( map(a, (x,y) =&gt; &#123; if(y === i) return a[j] if(y === j) return a[i] return x &#125;)) Example usage: 12const array = [1,2,3,4,5]swap(array, 0, 4) // [5,2,3,4,1] MapFrom MDN: “…creates a new array with the results of calling a provided function on every element in this array.” 1234const map = ([x, ...xs], fn) =&gt; &#123; if (undef(x)) return [] return [fn(x), ...map(xs, fn)]&#125; Which can be simplified as: 1const map = ([x, ...xs], fn) =&gt; def(x) ? [fn(x), ...map(xs, fn)] : [] Example usage: 12const double = x =&gt; x * 2map([1,2,3], double) // [2,4,6] FilterFrom MDN: “…creates a new array with all elements that pass the test implemented by the provided function.” 12345678const filter = ([x, ...xs], fn) =&gt; &#123; if (undef(x)) return [] if (fn(x)) &#123; return [x, ...filter(xs, fn)] &#125; else &#123; return [...filter(xs, fn)] &#125;&#125; Which can be simplified as: 1234const filter = ([x, ...xs], fn) =&gt; def(x) ? fn(x) ? [x, ...filter(xs, fn)] : [...filter(xs, fn)] : [] Example usage: 123456const even = x =&gt; x % 2 === 0const odd = x = !even(x)const array = [1,2,3,4,5]filter(array, even) // [2,4]filter(array, odd) // [1,3,5] RejectThe opposite of filter, returns an array that does not pass the filter function. 12345678const reject = ([x, ...xs], fn) =&gt; &#123; if (undef(x)) return [] if (!fn(x)) &#123; return [x, ...reject(xs, fn)] &#125; else &#123; return [...reject(xs, fn)] &#125;&#125; Example usage: 1234const even = x =&gt; x % 2 === 0const array = [1,2,3,4,5]reject(array, even) // [1,3,5] PartitionSplits an array into two arrays. One whose items pass a filter function and one whose items fail. 1const partition = (xs, fn) =&gt; [filter(xs, fn), reject(xs, fn)] Example usage: 1234const even = x =&gt; x % 2 === 0const array = [0,1,2,3,4,5]partition(array, even) // [[0,2,4], [1,3,5]] ReduceFrom MDN: “…applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.” 1234const reduce = ([x, ...xs], fn, memo, i) =&gt; &#123; if (undef(x)) return memo return reduce(xs, fn, fn(memo, x, i), i + 1)&#125; Which can be simplified as: 12const reduce = ([x, ...xs], fn, memo, i = 0) =&gt; def(x) ? reduce(xs, fn, fn(memo, x, i), i + 1) : memo Example usage: 12345const sum = (memo, x) =&gt; memo + xreduce([1,2,3], sum, 0) // 6const flatten = (memo, x) =&gt; memo.concat(x)reduce([4,5,6], flatten, [1,2,3]) // [1,2,3,4,5,6] ReduceRightSimilar to reduce, but applies the function from right-to-left. 1const reduceRight = (xs, fn, memo) =&gt; reduce(reverse(xs), fn, memo) Example usage: 123const flatten = (memo, x) =&gt; memo.concat(x)reduceRight([[0,1], [2,3], [4,5]], flatten, []) // [4, 5, 2, 3, 0, 1] PartialPartially apply a function by filling in any number of its arguments. 1const partial = (fn, ...args) =&gt; (...newArgs) =&gt; fn(...args, ...newArgs) Example usage: 1234const add = (x,y) =&gt; x + yconst add5to = partial(add, 5)add5to(10) // 15 SpreadArgConvert function that takes an array to one that takes multiple arguments. This is useful when partially applying. 1const spreadArg = (fn) =&gt; (...args) =&gt; fn(args) Example usage: 12345const add = ([x, ...xs]) =&gt; def(x) ? parseInt(x + add(xs)) : []add([1,2,3,4,5]) // 15const spreadAdd = spreadArg(add)spreadAdd(1,2,3,4,5) // 15 If you only want to define a single function you can write it as: 12const add = spreadArg(([x, ...xs]) =&gt; def(x) ? parseInt(x + add(...xs)) : [])add(1,2,3,4,5) // 15 In the above, you need to remember to spread the array you are sending into the function recursively, since you are spreading the argument. ReverseArgsReverse function argument order. 1const reverseArgs = (fn) =&gt; (...args) =&gt; fn(...reverse(args)) Example usage: 12345const divide = (x,y) =&gt; x / ydivide(100,10) // 10const reverseDivide = reverseArgs(divide)reverseDivide(100,10) // 0.1 Reversing arguments can be useful when partially applying arguments. Sometimes you want to partially apply arguments at the end of the list, not those at the beginning. Reversing the arguments allows us to do that. 123const percentToDec = partial(reverseDivide, 100)percentToDec(25) // 0.25 PluckExtract property value from array. Useful when combined with the map function. 1const pluck = (key, object) =&gt; object[key] Example usage: 12345678910const product = &#123;price: 15&#125;pluck('price', product) // 15const getPrices = partial(pluck, 'price')const products = [ &#123;price: 10&#125;, &#123;price: 5&#125;, &#123;price: 1&#125;]map(products, getPrices) // [10,5,1] FlowEach function consumes the return value of the function that came before. 1const flow = (...args) =&gt; init =&gt; reduce(args, (memo, fn) =&gt; fn(memo), init) Example usage: 1234567891011121314151617const getPrice = partial(pluck, 'price')const discount = x =&gt; x * 0.9const tax = x =&gt; x + (x * 0.075)const getFinalPrice = flow(getPrice, discount, tax)// looks like: tax(discount(getPrice(x)))// -&gt; get price// -&gt; apply discount// -&gt; apply taxes to discounted priceconst products = [ &#123;price: 10&#125;, &#123;price: 5&#125;, &#123;price: 1&#125;]map(products, getFinalPrice) // [9.675, 4.8375, 0.9675] ComposeThe same as flow, but arguments are applied in the reverse order. Compose matches up more naturally with how functions are written. Using the same data as defined for the flow function: 1const compose = (...args) =&gt; flow(...reverse(args)) Example usage: 12345const getFinalPrice = compose(tax, discount, getPrice)// looks like: tax(discount(getPrice(x)))map(products, getFinalPrice) // [9.675, 4.8375, 0.9675] MinReturn the smallest number in an array. Returns Infinity if array supplied is empty. 12345const min = ([x, ...xs], result = Infinity) =&gt; def(x) ? x &lt; result ? min(xs, x) : result : result Example usage: 123const array = [0,1,2,3,4,5]min(array) // 0 MaxReturn the largest number in an array. Returns -Infinity if array supplied is empty. 12345const max = ([x, ...xs], result = -Infinity) =&gt; def(x) ? x &gt; result ? max(xs, x) : max(xs, result) : result Example usage: 123const array = [0,1,2,3,4,5]max(array) // 5 FactorialReturns the factorial of a number. Uses an accumulator to allow replacing of stack frames to allow larger factorials to be returned. 1const factorial = (x, acum = 1) =&gt; x ? factorial(x - 1, x * acum) : acum Example usage: 1factorial(5) // 120 FibonacciReturns the Fibonacci number at the given place. 1const fib = x =&gt; x &gt; 2 ? fib(x - 1) + fib(x - 2) : 1 Example usage: 1fib(15) // 610 QuicksortSort an array from smallest to largest. This is done by re-ordering the array so that it contains two sub-arrays, one with smaller values, the other with larger values. The above steps are recursively applied to each sub-array until there are no arrays left, which is flatten to return a sorted array. 1234567const quicksort = (xs) =&gt; length(xs) ? flatten([ quicksort(filter(tail(xs), x =&gt; x &lt;= head(xs))), head(xs), quicksort(filter(tail(xs), x =&gt; x &gt; head(xs))) ]) : [] This can also be implemented using partition, but requires variable assignment. 12345const quicksort = (array) =&gt; &#123; if (!length(array)) return [] const [less, more] = partition(tail(array), x =&gt; x &lt; head(array)) return flatten([quicksort(less), head(array), quicksort(more)])&#125; Example usage: 123const array = [8,2,6,4,1]quicksort(array) // [1,2,4,6,8] Everything as a ReductionMany of the functions above can be converted into reductions, which should increase performance in most, if not all cases. This also shows the flexibility of the reduce function. 12345678910111213141516171819202122232425262728293031const reduce = ([x, ...xs], f, memo, i = 0) =&gt; def(x) ? reduce(xs, f, f(memo, x, i), i + 1) : memoconst reverse = xs =&gt; reduce(xs, (memo, x) =&gt; [x, ...memo], [])const length = xs =&gt; reduce(xs, (memo, x) =&gt; memo + 1, 0)const map = (xs, fn) =&gt; reduce(xs, (memo, x) =&gt; [...memo, fn(x)], [])const filter = (xs, fn) =&gt; reduce(xs, (memo, x) =&gt; fn(x) ? [...memo, x] : [...memo], [])const reject = (xs, fn) =&gt; reduce(xs, (memo, x) =&gt; fn(x) ? [...memo] : [...memo, x], [])const first = (xs, n) =&gt; reduce(xs, (memo, x, i) =&gt; i &lt; n ? [...memo, x] : [...memo], [])const last = (xs, n) =&gt; reduce(xs, (memo, x, i) =&gt; i &gt;= (length(xs) - n) ? [...memo, x] : [...memo], [])const merge = spreadArg(xs =&gt; reduce(xs, (memo, x) =&gt; [...memo, ...x], []))const flatten = xs =&gt; reduce(xs, (memo, x) =&gt; x ? isArray(x) ? [...memo, ...flatten(x)] : [...memo, x] : [], [])const add = spreadArg(([x, ...xs]) =&gt; reduce(xs, (memo, y) =&gt; memo + y, x))const divide = spreadArg(([x, ...xs]) =&gt; reduce(xs, (memo, y) =&gt; memo / y, x))const multiply = spreadArg(([x, ...xs]) =&gt; reduce(xs, (memo, y) =&gt; memo * y, x)) Example usage: 123456789101112reverse([1,2,3]) // [3,2,1]length([1,2,3]) // 3map([1,2,3], double) // [2,3,4]filter([1,2,3,4], even) // [2,4]reject([1,2,3,4], even) // [1,3]first([1,2,3,4], 3) // [1,2,3]last([1,2,3,4], 2) // [3,4]merge([1,2,3],[4,5,6]) // [1,2,3,4,5,6]flatten([1,[2,3,[4,[5,[[6]]]]]]) // [1,2,3,4,5,6]add(1,2,3,4,5) // 15multiply(2,5,10) // 100divide(100,2,5) // 10 Wrapping UpI hope this article helps shed insight on some of the patterns made available with JavaScript and ES6. Many problems that can be solved with iteration/loops, can also be solved functionally through recursion. I hope this article was also able to show you the flexibility of the reduce function.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://nthung2112.github.io/tags/es6/"}]},{"title":"Object, Function, Method, Constructor in JavaScript","slug":"Object-Function-Method-Constructor-in-JavaScript","date":"2018-07-24T05:02:00.000Z","updated":"2018-09-07T13:27:14.724Z","comments":true,"path":"2018/07/Object-Function-Method-Constructor-in-JavaScript.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Object-Function-Method-Constructor-in-JavaScript.html","excerpt":"TL;DR Lưu ý một chút về cách trình bày:.propname tức là public property có tên là “propname” của một đối tượng Bắt đầu với Object, Function và Method","text":"TL;DR Lưu ý một chút về cách trình bày:.propname tức là public property có tên là “propname” của một đối tượng Bắt đầu với Object, Function và Method JavaScript’s object giống như một cái túi (hay một vùng nhớ) chứa các property (thuộc tính) ở bên trong nó. Những property trong JavaScript đều public và được lưu trữ theo cấu trúc Mapping (tức key-value pair). Function trong JavaScript được xem là first-class object (cũng tương tự như object và ta sẽ gọi nó là functionObject). Chính vì JavaScript’s function được xem như object nên ta có thể return (trả về), pass to parameter (truyền vào function khác thông qua đối số), store in variable (lưu trữ trong biến) or store in Object’s property (lưu trữ trong property của Object =&gt; lúc đó function được gọi là method),… Prototypes Prototype của object là một internal property (có thể hiểu là một property nội tại ẩn bên trong), ta sẽ gọi nó là {Prototype}. JavaScript standard không cung cấp cách thức để truy xuất {Prototype} property từ một object. Lưu ý {Prototype} bản thân nó cũng là một object. Giống như bao ngôn ngữ lập trình OOP khác, JavaScript có thể tạo object từ một function được gọi là constructor. Vì constructor là function và là functionObject nên nó cũng có {Prototype} property. JavaScript standard cung cấp một public property cho functionObject là .prototype để truy xuất prototype của function.Lưu ý đối tượng được truy xuất thông qua public property .prototype không phải là {Prototype} property của functionObject. Properties lookup JavaScript’s object có thể ủy thác một số property của nó cho {Prototype}. Và bản thân {Prototype} cũng làm tương tự; Tất cả đều hướng đến Build-in Object.prototype. Lưu ý Build-in Object.prototype bằng null 12345678object --chứa--&gt; &#123;Prototype&#125;và bản thân &#123;Prototype&#125; cũng là object&#123;Prototype&#125; --chứa--&gt; &#123;Prototype&#125;&apos;s &#123;Prototype&#125;và bản thân &#123;Prototype&#125;&apos;s &#123;Prototype&#125; cũng là object&#123;Prototype&#125;&apos;s &#123;Prototype&#125; --chứa--&gt; &#123;Prototype&#125;&apos;s &#123;Prototype&#125;&apos;s &#123;Prototype&#125;.......... --chứa--&gt; Build-in Object.prototype(end) Hiện tượng trên người ta gọi là Inheritance (kế thừa) trong JavaScript thông qua prototype. Do đó JavaScript là một prototype-base OOP language Ở ví dụ trên, ta thấy xảy ra đệ quy, người ta gọi là {Prototype} chain. tức duyệt xuyên suốt các {Prototype} Khi gọi một property ra từ object thì đầu tiên hệ thống sẽ kiểm tra xem property đó có nằm trong object đó không. Nếu không, chúng sẽ chuyển hướng qua tìm property đó trong object’s {Prototype}. Quá trình đệ quy cứ thế được thực hiện cho đến khi tìm đến Build-in Object.prototype thì dừng lại. Setting properties Khi một property được set giá trị, property đó không có trong object thì nó sẽ được tạo mới, hệ thống tự động bỏ qua việc tìm kiếm nó trong {Prototype}. Property mới được thêm vào object sẽ làm mờ nhạt property trùng tên (nếu có) trong {Prototype} chain {Prototype} của object bị ảnh hưởng khá mạnh bởi public property .prototype của constructor. Ta có thể quyết định {Prototype} của một object thông qua việc điều chỉnh .prototype property của constructor. Khi constructor được gọi thực thi (hay nói cách khác function được gọi theo Constructor Format) (xem phần footnotes) thì một object mới được sinh ra. {Prototype} của object mới và public property .prototype của constructor sẽ tham chiếu cùng một đối tượng. Tiếp theo sẽ là gì? Ta cùng hình dungTrước tiên sẽ là mối liên quan giữa public property .prototype và {Prototype}. hình ellipse biểu diễn object, mũi tên biểu diễn property của object đó tham chiếu đến một object khác. {Prototype} chain sẽ được tô mũi tên mày xanh lá. 1: Define constructor:1function MyConstructor() &#123; &#125; Ta dễ dàng thấy MyConstructor được biểu diễn trong hình Ellipse, tức nó là function và là functionObject và sẽ được dùng như constructor. Ghi nhớ rằng: chỉ những public property .prototype của functionObject, là những object mặc định sở hữu public property .constructorTức là theo ví dụ trên: MyConstructor.prototype là giá trị mặc định cho property .prototype của MyConstructor. Và nó mặc định sở hữu property .constructor trỏ ngược về MyConstructor Phần còn lại trong bức ảnh minh họa rõ ràng những khái niệm đã đề cập ở phần đầu bài viết Bước kế tiếp ta sẽ bỏ qua phần {Prototype} chain của MyConstructor cho gọn, vì chúng không thay đổi và cũng không liên quan đến những gì được trình kế tiếp sau đây. 2: Assign new prototype property:1MyConstructor.prototype = &#123; &#125; Ta thay .prototype mặc định của MyConstructor bằng một đối tượng mới. Đặc biệt đối tượng này không có property .constructor 3: Call constructor to create new object:1var myobject = new MyConstructor(); Như đã trình bày ở mục setting propertites của bài viết, ta dễ dàng thấy được {Prototype} của myobject và property .prototype của MyConstructor tham chiếu đến cùng một đối tượng. Vậy bây giờ dựa theo mục properties lookup, ta thử truy xuất một property bất kì từ myobject. Ta chọn property có tên là constructor, chuyện gì sẽ xảy ra 1myobject.constructor = ? Đơn giản, áp dụng {Property} chain, ta sẽ có ngay đáp án. Bây giờ cùng thu gọn tất cả những đoạn code ta viết lại: 123456function MyConstructor() &#123;&#125;MyConstructor.prototype = &#123;&#125;;var myobject = new MyConstructor();myobject.constructor == Object // truemyobject.constructor.prototype == Object.prototype // true Ghi chú: Nếu nhìn lại ta sẽ hiểu vì sao ngay từ bước #2 ta lược bỏ đi phần {Prototype} của MyConstructor là đúng đắn Thế nếu dùng instanceof kết quả như thế nào?Viết lại nguyên văn: “Javascript provides the instanceof operator that’s intended to check the prototype chain of the object you’re dealing with.” Từ những bước ở trên, ta có thể nghĩ rằng đoạn code sau sẽ trả về false 12345function MyConstructor() &#123;&#125;MyConstructor.prototype = &#123;&#125;;var myobject = new MyConstructor();myobject instanceof MyConstructor // true nhưng thực chất, nó chạy ổn và còn hơn thế nữa: 12345function MyConstructor() &#123;&#125;MyConstructor.prototype = &#123;&#125;;var myobject = new MyConstructor();myobject instanceof Object // true Khi instanceof được gọi, nó hoạt động dựa trên {Prototype} chain. Và nó chẳng đá động hay lệ thuộc vào property .constructor cùng nhìn lại hình ở bước #3 Cứ tới một “trạm” tức đối tượng tham chiếu bởi {Prototype}, nó check xem đối tượng này được tham chiếu thông qua .prototype property của ai.Đầu tiên dừng tại đối tượng {}, nó check và phát hiện ra {} được tham chiếu thông qua .prototype property của MyConstructor, suy ra: 1myobject instanceof MyConstructor // true Tiếp theo dừng tại đối tượng Object.prototype nó phát hiện ra Object.protoype tham chiếu thông qua .prototype property của build-in Object, suy ra: 1myobject instanceof Object // true Có ổn rồi, nhưng ta vẫn có thể tìm ra những điều bất thường nếu chịu khó mò mẫm: 1234567function MyConstructor() &#123;&#125;var myobject = new MyConstructor();MyConstructor.prototype = &#123;&#125;;[ myobject instanceof MyConstructor, // false ! myobject.constructor == MyConstructor, // true ! myobject instanceof Object ] // true ở đoạn code trên ta đổi thứ tự của hai dòng code, myobject được tạo ra trước sau đó MyConstructor mới đổi giá trị của .prototype property.Do đó {Prototype} chain sẽ trông như vầy: Đúng như dự đoán {Prototype} của object sẽ tham chiếu đến đối tượng cũ mà .prototype property của MyConstructor từng tham chiếu. Điều này làm thay đổi {Prototype} chain và có thêm sự xuất hiện của .constructor property của old MyConstructor.prototype dẫn đến {Prototype} của object và .prototype property của MyConstructor không tham chiếu đến cùng một đối tượng.Dừng tại {Prototype} đầu tiên là đối tượng old MyConstructor.prototype, nó không phát hiện ra đối tượng đó được tham chiếu thông qua .prototype property của ai cả. Tiếp tục {Prototype} thứ hai, là Object.prototype thì quá rõ ràng, suy ra: 12myobject instanceof MyConstructor, // false !myobject instanceof Object // true Ngoài ra, thông qua {Prototype} chain (xem lại mục properties lookup), thì ta thấy .constructor property đầu tiên được bắt gặp trong old MyConstructor.prototype nên 1myobject.constructor == MyConstructor, // true ! là điều dễ hiểu. Một số nhận địnhConstructors không phải classesNhìn lại các class-based OOP language (như Java, C#,…), các classes kế thừa từ những classes khác, và object là instance của những classes đó. Các properties và methods được chia sẻ giữa các instances. Và việc chia sẻ đó bị chi phối bởi access modifier (public, private, internal, protected,……) Javascript cũng có khái niệm kế thừa, chia sẻ properties và methods thông qua prototype. Nhưng thực tế {Prototype} của constructor và {Prototype} chain của object được tạo ra từ constructor đó, lại hoàn toàn khác biệt, không liên quan đến nhau. Constructors không hoạt động như class-based initializerĐể có được khái niệm kế thừa thông qua prototype, Khi constructor được gọi nó tiến hành liên kết {Prototype} property của object với .prototype property của chính nó. Những gì còn lại là việc constructor thêm vào một số properties, methods khác cho object Constructors chỉ là functionsXem lại bước #1, ta thấy MyConstructor chẳng khác gì một function bình thường. Vì vậy bất kì user-defined function nào trong Javascript cũng tự động có .prototype property tham chiếu đến một đối tượng sở hữu .constructor property tham chiếu ngược về function đó Bất cứ user-defined function nào cũng được gọi thực thi như một constructor bằng cách thêm vào từ khóa new. Cách làm đó sẽ truyền object mới được tạo bởi từ khóa new vào trong constructor function, và phần việc còn lại của constructor thì như đã nói ở bên trên References(tham khảo từ bài viết của zeekat/articles với một số chỉnh sửa theo hiểu biết của bản thân và để phù hợp với Tiếng Việt)(xem thêm constructor in Javascript object)(xem thêm Javascript inheritance and the constructor property)(xem thêm ECMA-262 lastest version) Footnotes[1]John G Harris từng viết trong comp.lang.javascript rằng những gì trình bày ở bên trên cũng tương đối chưa đúng hoàn toàn. Về mặt lý thuyết, host system có thể sẽ đổi Object.prototype property bằng một thứ gì đó khác. Một số thảo luận chấp thuận rằng Object.prototype chỉ được read-only. Nhưng ở một số browser (firefox) thì ta có thể gán giá trị mới cho Object.prototype mà không có lỗi nào xảy ra. [2]có 4 cách để gọi thực thi (invocation) một function trong JavaScript(giữ nguyên văn cho dễ hiểu) Function form: 1functionObject(arguments) When a function is called in the function form, this is set to the global object. that is not very useful (fixed in ES5/Strict) an inner function does not get access to the outer this Method form: 12thisObject.methodName(agurments);thisObject[\"methodName\"](arguments); When a function is called in the method form, this is set to thisObject, the object containning the function.this allows method to have a reference to the object of interest Constructor form: 1new functionObject(arguments); When a function is called with the new operator, a new object is created and assigned to this. If there is not an explicit return value, then this will be returned. Used in the Pseudoclassical style Apply form: 12functionObject.apply(thisObject, [arguments]);functionObject.call(thisObject, arguments....); A function’s apply or call method allows for calling the function,explicitly specifying thisObject. It can also take an array of parameters or a sequence of paramenters. 12345// the definition of call methodFuntion.prototype.call = function(thisObject)&#123; return this.apply(thisObject, Array.prototype.slice.apply(arguments, [1]));&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Memory Leaks trong Javascript","slug":"Memory-Leaks-trong-Javascript","date":"2018-07-24T04:41:00.000Z","updated":"2018-09-07T13:27:14.713Z","comments":true,"path":"2018/07/Memory-Leaks-trong-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Memory-Leaks-trong-Javascript.html","excerpt":"Giới thiệuMemory leaks là vấn đề mà mọi deveploper đều sẽ gặp phải khi code. Memory leaks sẽ dấn đến việc ứng dụng sẽ chạy chậm hơn, crashes, hay có thể ảnh hưởng đến các ứng dụng khác. Vậy memory leaks là gì?","text":"Giới thiệuMemory leaks là vấn đề mà mọi deveploper đều sẽ gặp phải khi code. Memory leaks sẽ dấn đến việc ứng dụng sẽ chạy chậm hơn, crashes, hay có thể ảnh hưởng đến các ứng dụng khác. Vậy memory leaks là gì?Memory leaks có thể được định nghĩa là một bộ nhớ (memory) không được sử dụng trong ứng dụng nữa nhưng vì một lý do nào đó mà nó chưa được giải phóng và trả về hệ điều hành hoặc một cái pool chứa các bộ nhớ (memory) chưa sử dụng. Các ngôn ngữ lập trình khác nhau sẽ có các cách khác nhau để quản lý bộ nhớ. Những cách quản lý bộ nhớ này sẽ giúp giảm thiểu khả năng bị memory leaks của chương trình. Tuy nhiên, việc xác định một vùng bộ nhớ có còn được sử dụng hay không lại là một vấn đề khó có thể xác định. Chỉ có developer mới có khả năng quyết định xem là vùng nhớ này nên được giải phóng hay không. Một số ngôn ngữ (như javascript) cung cấp tính năng tự động giải phóng bộ nhớ cho developer, một số khác thì developer cần phải tự mình giải phóng bộ nhớ khi không sử dụng đến nó nữa. Quản lý bộ nhớ trong JSJavascript là một trong những ngôn ngữ có garbage collection. Những ngôn ngữ lập trình như Javascript thế này sẽ thay developer quản lý bộ nhớ bằng cách kiểm tra định kỳ các vùng nhớ được cấp phát trước đó có có thể được “với tới” bởi các phần khác trong ứng dụng. Có thể nói cách khác là những ngôn ngữ như Javascript sẽ giúp biến vấn đề từ “những vùng nhớ nào vẫn còn cần trong ứng dụng” thành “những vùng nhớ nào có thể được ứng dụng access đến”. Sự khác biệt của 2 vấn đề là không nhiều nhưng lại rất quan trọng: chỉ developer mới có thể biết được là vùng nhớ nào còn cần để chạy tuy nhiên, việc xác định xem một vùng nhớ có thể vươn tới không trong ứng dụng thì có thể làm tự động bởi thuật toán. Memory leaks trong JSLý do chính của memory leaks trong các ngôn ngữ có garbage collection là các reference không mong muốn vào bộ nhớ (unwanted references), tức là một vùng nhớ được trỏ đến mà lại không được sử dụng trong ứng dụng. Để có thể hiểu rõ hơn về nó, trước hết ta cần tìm hiểu các hoạt động của garbage collector, cách nó xác định một vùng nhớ có thể được “với tới” (reach) bởi ứng dụng. Mark and sweepHầu hết các garbage collector đều sử dụng thuật toán mark-and-sweep để thực hiện việc giải phóng bộ nhớ. Thuật toán này bao gồm các bước sau: Đầu tiên, garbage collector sẽ xây dựng một danh sách các roots. Roots thực chất là các biến toàn cục mà có reference được lưu trong code. Trong Javascript, window chính là một biến toàn cục như vậy. Window sẽ luôn hiện hữu trong chương trình nên garbage collector có thể coi nó và tất cả các con của nó luôn hiện hữu. Tất cả roots và con của chúng sẽ được đánh dẫu là đang hoạt động. Tất cả những vùng nhớ mà có thể được vươn tới từ roots thì đều được coi là đang hoạt động và không đánh dấu là rác (garbage). Tất cả các vùng nhớ mà không được đánh dẫu là rác (garbage) thì bây giớ đều sẽ được coi là rác. Bây giờ thì các collector có thể giải phóng các vùng nhớ này. Mặc dù thuật toán này được tối ưu bởi các GC (garbage collector) hiện đại tuy nhiên cơ chế của nó vẫn không đổi: những vùng nhớ vươn tói được thì được coi là đang hoạt động, những vùng nhớ khác sẽ được coi là rác. Những tham chiếu không mong muốn (Unwanted references) là những tham chiếu đến các vùng bộ nhớ mà developer biết là nó không được cần đến nữa nhưng vì lý do nào đó mà nó vẫn được giữ lại trong hệ thống. Trong JS, những tham chiếu không mong muốn này là các biến (variables) được giữ đâu đó trong code mà nó sẽ không được sử dụng đến nữa nhưng lại trỏ đến một vùng nhớ mà cần được giải phóng. Để hiểu được memory leaks trong JS, ta cần biết được là khi nào thì một tham chiếu bị lãng quên. 3 loại memory leaks trong JS1: Biến toàn cụcJavascript có một cơ chế là đặt biến mà không cần khai báo. Ví dụ: 12a = \"value\";console.log(a); //\"a\" Khi một biến được khai báo như trên thì JS sẽ tự động gán nó vào global object (window trên browser). Nếu như biến này chỉ hoạt động trên phạm vi toàn cục (global scope) thì cũng không có sự khác biệt cho lắm. Tuy nhiên, nếu nó được định nghĩa trong một hàm thì đó lại là chuyện khác. Ví dụ: 123function foo()&#123; bar = \"đây là biến toàn cục ẩn\"&#125; Đoạn code trên sẽ tương đương với đoạn code sau trên browser: 123function foo()&#123; window.bar = \"đây là biến toàn cục\"&#125; Nếu khai báo bar trong phạm vi của hàm foo mà lại không sử dụng var để khai báo thì biến bar sẽ được tạo với phạm vi toàn cục, và đây là một ví dụ điển hình về memory leaks. Một cách khác mà có thể vô tình tạo ra biến toàn cục đó là thông qua this: 12345function foo() &#123; this.variable = \"có thể là biến toàn cục\";&#125;foo(); Vì this trong hàm sẽ trỏ đến biến root toàn cục (window) nếu hàm đó được gọi trực tiếp không thông qua object nào khác nên ở ví dụ trên, biến variable sẽ được gắn vào phạm vi toàn cục. Một cách để giảm thiểu những lỗi trên đó là thêm &quot;use strict;&quot; vào dòng đầu tiên của file JS. Nó sẽ giúp ngăn chặn việc khai báo biến toàn cục như trên. Chú ý khi làm việc với biến toàn cục Biến toàn cục không bao giờ được giải phóng bộ nhớ tự động theo thuật toán mark-and-sweep ở trên. Vì thế, biến toàn cục chỉ nên được sử dụng để lưu tạm dữ liệu để xử lý. Nếu cần lưu một lượng lớn dữ liệu vào biến toàn cục thì cần đảm bạo là nó sẽ bị gán về null hoặc gán lại dữ liệu khi mà bạn đã sử dụng xong nó. 2: Callback và timer bị lãng quênSau đây là một ví dụ dẫn đến memory leak khi sử dụng setInterval: 1234567var data = getData();setInterval(function()&#123; var node = document.getElementById(\"Node\"); if(node)&#123; node.innerHTML = JSON.stringify(someResource)); &#125;&#125;, 1000); Đây là một ví dụ về một timer bị treo. Timẻ bị treo tức là khi timer tham chiếu đến các node hoặc dữ liệu mà không còn được sử dụng nữa. Ở ví dụ trên, nếu như node bị xóa ở một lúc nào đấy thì toàn bộ đoạn code xử lý trong hàm callback của interval sẽ không cần đến nữa. Tuy nhiên, vì interval vẫn còn hoạt động nên các vùng nhớ được sử dụng trong hàm callback của interval cũng không được giải phóng (muốn giải phóng cần dừng interval lại). Tiếp đó, các object từ bên ngoài mà được hàm callback của interval tham chiếu đến cũng không thể được giải phóng vì vẫn có thể vươn tới được thông qua hàm callback kia. Theo ví dụ trên thì đó là data. Một trường hợp có thể dẫn đến leaks đó là do các observers object (DOM và event listener của chúng). Điều này chỉ ảnh hưởng đến các trình duyệt cũ (vd: IE6) vì các trình duyệt mới sẽ tự động làm điều này cho chúng ta. Đây là một bug của GC của IE6 và dẫn đến việc tham chiếu quay vòng. 3: Tham chiếu tới các DOM đã bị xóaCó những lúc bạn muốn lưu các DOM vào một số cấu trúc dữ liệu như mảng hoặc object trong JS code để làm một loạt các tác vụ nào đấy. Ví dụ bạn muốn update dữ liệu của một vài element nào đấy thì việc lưu các element này vào một mảng là hoàn toàn hợp lý. Khi điều này xảy ra thì sẽ có 2 tham chiếu đên DOM element này: một là từ DOM tree, hai là từ đối tượng mảng của JS. Nếu bạn muốn xóa các element này thì bạn cần phải xóa toàn bộ các tham chiếu tới chúng để có thể giải phóng bộ nhớ. Ví dụ: 12345678910111213141516171819var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image'), text: document.getElementById('text')&#125;function doStuff() &#123; image.src = 'http://some.url/image'; button.click(); console.log(text.innerHTML);&#125;function removeButton() &#123; // button là con của body. document.body.removeChild(document.getElementById('button')); // Ở đây thì button vẫn được tham chiểu đến bởi elements. Nói cách khác là // nó vẫn nằm trong bộ nhớ và không thể được giải phóng.&#125; Còn một vấn đề quan trọng nữa là khi tham chiếu đến một node lá hoặc một inner node của DOM tree, ví dụ như một ô trong bảng (&lt;td&gt; của &lt;table&gt;). Nếu bạn tham chiếu đến &lt;td&gt; này trong JS code thì khi bạn xóa &lt;table&gt; chứa node này thì GC sẽ không giải phóng được cả table chứ không phải là chỉ mỗi &lt;td&gt; node không được giải phóng. Vì node con còn tham chiếu đến node cha nên nó sẽ được GC coi là vẫn được tham chiếu và bỏ qua nó. Vì thế nên cẩn thận khi tham chiếu đến các DOM. 4: ClosuresClosures có nghĩa đơn giản là hàm nằm trong phạm vi của một hàm khác có thể tham chiếu tới các biến của hàm bao nó. Vì sao Closures có thể gây ra leak, hãy xem ví dụ sau: 123456789101112131415var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log(\"hi\"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); Ví dụ này cho ta thấy mỗi khi replaceThing được gọi, theThing sẽ tạo ra một object mới chứa một mảng và một closures (someMethod). Cùng lúc đó, biến unused cũng lưu một closures tham chiếu đên originalThing (là object theThing được tạo ra từ việc gọi replaceThing ở bước trước đó). Một điều quan trọng nữa là khi một scope được tạo ra cho các closures mà có cùng scope cha, chúng sẽ cùng chia sẻ scope đó. Trong ví dụ này thì someMethod và unused đều chia sẻ cùng một scope. Mặc dù unused không được gọi đến nhưng vì nó có tham chiếu đến originalThing nên nó sẽ được GC coi là vẫn đang hoạt động. Khi đoạn code này chạy thì bộ nhớ của chương trình sẽ tăng đều đặn và có thể nhìn thấy ngay được. Về bản chất, một linked-list của closures được tạo (với root là theThing) khi đoạn code trên được chạy và đó là lý do bộ nhớ bị tăng dần theo thời gian. Garbage Collectors (bộ dọn rác)Mặc dù GCs giúp chúng ta không phải quản lý bộ nhớ bằng tay nữa, tuy nhiên ta cũng sẽ phải đánh đổi lại một vài thứ. Một trong số đó là việc các GCs hoạt động theo một cách khó đoán biết. Thông thường rất khó có thể chắc chắn rằng một hoạt động thu thập các vùng nhớ không được sử dụng được thực thi hay không. Điều này cũng có nghĩa là trong một số trường hợp, số lượng vùng nhớ của một chương trình nhiều hơn số bộ nhớ mà chương trình đó cần. Trong một số trường hợp khác, ứng dụng sẽ bị ảnh hưởng bởi một khoảng thời gian nhỏ chương trình bị delay để thực hiện công việc thu thập bộ nhớ. Hiện nay, hầu hết GC đều hoạt động theo cách là chỉ thực hiện việc thu thập bộ nhớ khi cấp phát bộ nhớ cho chương trình. Nếu không cần cấp phát bộ nhớ, GCs sẽ không hoạt động. Chúng ta sẽ xem xét các tình huống sau: Chương trình đã cấp phát một số lượng nhỏ bộ nhớ. Sau đó, hầu hết (hoặc toàn bộ) các phần tử được đánh dấu là không thể vươn tới nữa. Chương trình không thực hiện việc cấp phát bộ nhớ nữa. Trong tình huống này, hầu như tất cả các GC sẽ không thực hiện việc thu thập bộ nhớ nữa. Nói cách khác, mặc dù có những phần tử không thể vươn tới được nữa trong chương trình, chúng sẽ không được thu hồi lại bộ nhớ. Đây không hẳn là leaks, tuy nhiên nó vẫn dẫn đến việc chương trình ngốn bộ nhớ. Chrome Memory Profiling ToolsChrome cung cấp một tập các công cụ để kiểm tra tình trạng sử dụng bộ nhớ của code JS. Có 2 view quan trọng liên quan đến bộ nhớ đó là: timeline và profiles. Timeline ViewTimeline View có thể giúp ta biết được mô hình sử dụng bộ nhớ của chương trình. Từ đây ta có thể nhìn được việc rò rỉ bộ nhớ, việc bộ nhớ sử dụng tăng liên tục theo thời gian mà không giảm xuống sau mỗi lần GC được chạy. Ví dụ: Ta có thể thấy được việc bộ nhớ rò rỉ được thể hiện thông qua việc JS heap tăng dần theo thời gian. Mặc dù sau khi được thu thập với một số lượng lớn tại đoạn cuối thì chương trình vẫn sử dụng số lượng bộ nhớ nhiều hơn so với lúc bắt đầu. Số lượng Node cũng cao hơn. Đây là dấu hiệu của việc các node DOM bị rò rỉ đâu đó trong code.o Profiles view Đây là công cụ sẽ luôn gắn bó với bạn khi phải điều tra về rò rỉ bộ nhớ. Profiles view cho phép bạn lấy ảnh chụp (snapshot) về việc sử dụng bộ nhớ của một chương trình Javascript. Nó cũng cho phép bạn ghi lại những lần cấp phát bộ nhớ theo thời gian. Mỗi một loại kết quả sẽ có các danh sách liệt kê khác nhau được đưa ra, tuy nhiên những thứ mà bạn cần quan tâm đó là danh sách tổng hợp (summary list) và danh sách so sánh (comparision list). Summary View sẽ cho ta thấy được tổng quan về các loại objects được khởi tạo và cấp phát cùng với các kích thước tổng hợp (aggregated size): kich thước nông (Shallow size) là tổng kích thước của tất cả các object của một loại cụ thể nào đó và kích thước giữ lại (retained size) bao gồm shallow size và kích thước của các object được lưu lại bởi object này. Nó cũng cho ta một thông tin về khoảng cách giữa một object với root. Comparision View cũng cung cấp cùng một thông tin như summary view nhưng nó cho phép ta so sánh giữa các snapshot khác nhau. Ví dụ: Tìm kiếm rò rỉ dữ liệu trong ChromeCó 2 kiểu rò rỉ dữ liệu chủ yếu là: rỏ rỉ dẫn đến việc bộ nhớ bị tăng một cách đều đặn theo thời gian và rò rỉ chỉ xảy ra một lần duy nhất và không gây ra việc bộ nhớ bị tăng trong tương lai nữa. Việc tìm rò rỉ dữ liệu mà bộ nhớ bị tăng dần theo thời gian khá là đơn giản và rõ ràng (sử dụng timeline view). Tuy nhiên thì đây lại là rò rỉ gây ra nhiều rắc rối nhất: nếu bộ nhớ cứ tăng dần theo thời gian, nó sẽ khiến trình duyệt chạy chậm dận và cuối cùng sẽ dẫn đến việc script bị ngừng chạy. Rò rỉ mà không dẫn đến việc bộ nhớ bị tăng theo thời gian có thể dễ dàng được tìm ra khi bộ nhớ lớn đến một mức độ nào đó. Thông thường những rò rỉ kiểu này không được chú ý quả nhiều. Nói theo một cách khác, những rò rỉ nhỏ mà chỉ xảy ra một lần thường được coi là một vấn đề để tối ưu code. Tuy nhiên, những rò rỉ mà làm bộ nhớ tăng dần theo thời gian thì được coi là bug và nó cần được fix. Ở đây ta sẽ sử dụng một ví dụ từ Chrome. Toàn bộ đoạn code như sau: 123456789101112131415161718var x = []; function createSomeNodes() &#123; var div, i = 100, frag = document.createDocumentFragment(); for (;i &gt; 0; i--) &#123; div = document.createElement(\"div\"); div.appendChild(document.createTextNode(i + \" - \"+ new Date().toTimeString())); frag.appendChild(div); &#125; document.getElementById(\"nodes\").appendChild(frag);&#125;function grow() &#123; x.push(new Array(1000000).join('x')); createSomeNodes(); setTimeout(grow,1000);&#125; Khi grow được gọi, nó sẽ bắt đầu tạo một div và gán nó vào DOM. Nó cũng sẽ khởi tạo một mảng lớn (1 triệu phần tử) và gán nó vào một mảng được tham chiếu bỏi một biến toàn cục (x). Việc này sẽ dẫn đến việc bộ nhớ bị tăng đều đặn và có thể nhận biết được với Timeline view. Phát hiện việc bộ nhớ bị tăng đều đặn trong ChromeTa sẽ bắt đầu với ví dụ sau của chrome. Sau khi click vào ví dụ của Chrome, mở Dev Tools, click vào tab timeline, tích chọn memory và click vào nút record. Tiếp đó quay lại trang ví dụ và click vào The Button để bắt đầu việc rò rỉ bộ nhớ. Sau một khoảng thời gian thì dừng lại việc record và xem kết quả: Note: Ví dụ này sẽ khiến bộ nhớ bị tăng mỗi giây. Sau khi dừng việc record thì các bạn có thể đặt breakpoint vào grow để dừng việc thực thi script. Có 2 dấu hiệu lớn trong bức ảnh trên cho thấy việc rò rỉ bộ nhớ: biểu đồ cho nodes (đường kẻ màu xanh lá) và biểu đồ cho JS heap (đường kẻ màu xanh đậm). Số lượng node luôn luôn tăng và không bao giờ giảm. Đây là dấu hiệu cảnh báo lớn. JS heap cũng tăng dần theo thời gian tuy nhiên điều này khó nhìn ra hơn do hiệu ứng từ GC. Các bạn có thể thấy là bộ nhớ tăng sau lại giảm một cách liên tục. Điểm quan trọng cần chú ý ỏ đây là sau mỗi lần bộ nhớ được giảm thì kích thước của JS heap vẫn lớn hơn so với lần giảm trước đấy. Nói cách khác, mặc dù GC đã thành công thu thập được rất nhiều bộ nhớ, một vài trong số đó bị rò rỉ. Bây giờ ta đã chắc chắn chương trình của mình bị rò rỉ bộ nhớ, ta cần phải tìm ra nguyên nhân của nó. Tạo 2 snapshotĐể tìm ra nguyên nhân rò rỉ, ta sẽ sử dụng đến công cụ profiles của Chrome. Cụ thể hơn, ta sẽ sử dụng tính năng Take Heap Snapshot. Đầu tiên, reload lại trang và tạo một snapshot ngay sau khi load xong trang. Ta sẽ sử dụng snapshot này làm cơ sở. Sau đó, click vào The Button một lần nũa, chờ khoảng một vài giây, tạo một snapshot khác. Sau đó tạo breakpoint để dừng việc rò rỉ bộ nhớ lại. Có 2 cách mà ta có thể sử dụng để kiểm tra sự khác nhau giữa 2 snapshot. Thứ nhất là sử dụng chức năng Summary rồi bắt đầu từ phía bên phải chọn Objects allocated between Snapshot 1 and Snapshot 2. Hoặc chọn Comparision thay cho Summary. Trong cả 2 trường hợp, ta sẽ thấy một danh sách các object được khởi tạo giữa 2 snapshot. Trong trường hợp này thì việc tìm ra leaks rất đơn giản. Hãy xem Size Delta của (string). 8MB với 58 object mới. Điều này rất đáng nghi ngờ: object mới được tạo nhưng không được giải phóng và 8MB bị chiếm mất. Nếu ta mở danh sách khởi tạo của (string) ta sẽ thấy có một vài object lớn được khởi tạo bên cạnh các object nhỏ. Nếu ta chọn một trong số các object lớn này thì ta sẽ thấy một vài điểm thú vị trong mục retainers: Ta thấy rằng object được chọn là một phần tử của mảng. Tiếp đó ta biết được mảng này được tham chiếu bởi biến x nằm ở trong window. Điều này cho ta thấy được toàn bộ con đường từ object lớn của chúng ta liên kết thế nào với root (window). Ta đã tìm được một nguyên nhân dẫn đến rò rỉ và nơi nó được tham chiếu. Vi dụ này khá đơn giản: object lớn được khỏi tạo thế này không thường xuyên xuất hiện trong chương trinh. Tuy nhiên trong chương trình này cũng có xuất hiện việc rò rỉ DOM có kích cỡ nhỏ hơn. Những node này có thể tìm thấy đươc thông qua snapshot tuy nhiên đối với những site lớn, mọi chuyện sẽ trở nên rắc rối hơn nhiều. Các phiên bản Chrome hiên tại có cung cấp một tính năng đó là: Record Heap Allocations Record Heap AllocationsTa se bắt đầu với viêc để cho đoạn script tiếp tục được chạy và quay lại tab Profiles của Chrome Dev Tools. Ấn nút Record Heap Allocations. Khi mà tool đang chạy, các bạn sẽ thấy một vài vạch xanh trên biểu đồ ở phía trên đầu. Nó thể hiện việc khởi tạo object khi chạy chương trình. Ta có thể thấy được tính năng của công cụ này: chọn một khoảng thời gian để xem object nào được khởi tạo trong khoảng thời gian này. Ta đặt khoảng thời gian này gần các vạch xanh đậm nhất có thể. Chỉ có 3 hàm khởi tạo được show trong danh sách: một trong số đó liên quan đến rò rỉ do (string) ở phía trên, tiếp theo là liên quan đến việc khởi tạo DOM và cái cuối cùng là khởi tạo Text. Chon một trong những hàm khởi tạo của HTMLDivElement trong danh sách và chọn Allocation stack. Từ ảnh trên ta thấy được là phần tử được khởi tạo bởi grow -> createSomeNodes. Nếu ta để ý kỹ mỗi vạch trên biểu đồ, ta sẽ thấy là hàm khởi tạo HTMLDivElement được gọi nhiều lần. Nếu ta quay trở lại với snapshot comparision view, ta sẽ thấy là nó chỉ khởi tạo object mà không xóa chúng đi. Nói cách khác là nó luôn khởi tạo object mà không cho phép GC thu thập một vài trong số chúng. Giờ khi ta đã biết objects bị rò rỉ ở đâu (createSomeNodes), ta có thể quay trở lại code để sửa lại nó. Các tính năng hữu ích khácThay vì sử dụng Summary view, ta có thể sử dụng Allocation view: Giao diện này cho ta thấy một danh sách các hàm và bộ nhớ khởi tạo liên quan đến chúng. Ta có thể thấy ngay là grow và createSomeNodes là nổi bật hơn cả. Khi chọn grow ta sẽ thấy đối tượng khởi tạo liên quan được gọi đến. Ta có thể để ý thấy (string) HTMLDivElement và Text là những hàm khởi tạo của các đối tượng bị rò rỉ. Note: để sử dụng được tính năng này, vào Dev Tools -> Settings và enable record heap allocation stack traces trước khi record.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Làm thế nào để thành thạo CSS Grid trong nháy mắt","slug":"Lam-the-nao-de-thanh-thao-CSS-Grid-trong-nhay-mat","date":"2018-07-10T01:10:00.000Z","updated":"2018-07-10T02:08:58.475Z","comments":true,"path":"2018/07/Lam-the-nao-de-thanh-thao-CSS-Grid-trong-nhay-mat.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Lam-the-nao-de-thanh-thao-CSS-Grid-trong-nhay-mat.html","excerpt":"Giới thiệuĐây KHÔNG phải là một bài viết để học “mọi thứ” về css grid.Bài viết này hướng đến những người muốn có kết quả nhanh chóng và hiệu quả.Trong bốn phần của bài viết này, tôi sẽ chỉ cho bạn 20% cần thiết để làm được 80% những gì bạn có thể làm với CSS Grid layout. Hãy cùng tìm hiểu!","text":"Giới thiệuĐây KHÔNG phải là một bài viết để học “mọi thứ” về css grid.Bài viết này hướng đến những người muốn có kết quả nhanh chóng và hiệu quả.Trong bốn phần của bài viết này, tôi sẽ chỉ cho bạn 20% cần thiết để làm được 80% những gì bạn có thể làm với CSS Grid layout. Hãy cùng tìm hiểu! Tại sao chỉ 20%? Bất cứ khi nào, một lập trình viên tìm kiếm sự hiệu quả - sự lười biếng sẽ giúp anh ta. CSS Grid layout rất phức tạp. Theo ý kiến của tôi, nó phức tạp hơn Flexbox. (tôi đã mất vài tuần để tìm hiểu flexbox) Không hẳn bởi vì nó “khó” mà do CSS Grid có tới 18 thuộc tính mới cộng với những khái niệm mà bạn chưa bao giờ nghe tới trước đó. Vậy, bạn cần biết tất cả những thuộc tính mới này ngay bây giờ? Ngay lập tức? Không, bạn không cần! Bạn chỉ cần học một vài thuộc tính cần thiết ngay lúc này để tạo ra kết quả mong muốn. Những thuộc tính khác có thể học sau. Đó là định nghĩa về “hiệu quả” của tôi. 1. CSS Grid layout là gì ?Nếu bạn mới học bố cục trong CSS, CSS Grid có thể khá xa lạ với bạn. Bạn đã nghe nói tới Flexbox chưa? Tôi thích coi CSS Grid như là một người anh (hoặc cha) của Flexbox. Xử lý các bố cục trong CSS được coi là một công việc khó khăn và không hấp dẫn. Flexbox đã làm cho mọi thứ dễ dàng hơn - nhưng CSS Grid thậm chí còn tốt hơn. Cái chúng ta sẽ xây dựng.Chúng ta sẽ học cách áp dụng 20% kiến thức học được để xây dựng bố cục responsive của một ứng dụng âm nhạc Phần 1: 10% bạn cần biết - Các thuật ngữ cơ bảnChúng ta hãy nhìn vào những điều đầu tiên bạn bắt buộc phải biết. Grid Container là gì?Mỗi bố cục các trang web hoặc ứng dụng bạn tạo ra (hoặc thấy) về bản chất là những chiếc hộp được đặt trong những đường ranh giới xác định. Hiểu đơn giản, grid chỉ là “những đường kẻ”. Những đường kẻ ngang và dọc xác định vị trí của các phần tử được thiết kế khác nhau. Bạn sẽ quen với grid nếu bạn đã sử dụng các phần mềm thiết kế như photoshop hoặc sketch. Trong bối cảnh của CSS Grid layout, một Grid container là phần tử cha chứa tất cả các phần tử nằm trong grid. Grid container xác định vị trí ban đầu của các đường kẻ trong grid, cả dọc và ngang. Grid Line là gì?Giả sử bạn có một bố cục như thế này: Bố cục bao gồm một grid container với các phần tử ở bên trong Grid lines chính là những đường kẻ ngang và dọc phân chia grid thành các ô. Grid Cell là gì?Grid cell là đơn vị nhỏ nhất trong grid layout. Bất kỳ khoảng trống nào được xác định bởi 4 đường grid line. Grid AreaMột grid area có thể giống như một grid cell (giống như ở phần trước). Hoặc cũng có thể trải rộng trên nhiểu hoặc tất cả grid cell trong grid. Trong hình vẽ dưới đây, grid area trải rộng trên 4 ô. Grid Track là gì?Một grid track có thể xem như một tên gọi khác cho các cột và các dòng. Nó là khoảng trống giữa 2 grid line bất kỳ. Hình dưới đây là ví dụ về grid tracks Vì vậy, chúng tôi đã phân loại được tất cả trong phần đầu tiên. Phần 2: 10% còn lại mà bạn cần biết về CSS grid.Bây giờ bạn đã hiểu các thuật ngữ cơ bản, giống như một đứa trẻ mạo hiểm, hãy bắt đầu! Làm thế nào để định nghĩa một Grid?Giống như Flexbox, mọi thứ bắt đầu với display: grid hoặc display: inline-grid cho phiên bản inline. Ví dụ, để biến một div thành một grid container: 123div &#123; display: grid;&#125; Làm thế nào để tạo các cột và dòng?Để tạo các cột và các dòng trong một grid container, chúng ta sẽ sử dụng 2 thuộc tính mới: grid-template-columns và grid-template-rows. Vậy sử dụng chúng như thế nào? Khá đơn giản. grid-template-columns định nghĩa vị trí của các cột. grid-template-rows định nghĩa vị trí của các dòng. Bạn truyền giá trị vào các thuộc tính này, và chúng tạo ra các dòng và các cột. Xem ví dụ: 1grid-template-columns: 100px 200px 300px Đoạn code này sẽ tạo thành 3 cột mới trong grid container. Cột đầu tiên có độ rộng 100px, cột tiếp theo 200px và cột cuối 300px. 1grid-template-rows: 100px 200px 300px Đoạn code này sẽ tạo 3 dòng mới trong grid container như hình dưới đây: Bây giờ đặt chúng cùng nhau, bạn sẽ có một grid hoàn chỉnh với các dòng và cột đã được định nghĩa. 12grid-template-columns: 100px 200px 300pxgrid-template-rows: 100px 200px 300px Phần 3: Bắt tay vào Code - CSS GridBây giờ chúng ta hãy thực hiện các bước để xây dựng bản sao của ứng dụng âm nhạc nổi tiếng, nhạc catty Để phát triển nhanh chóng, tôi sẽ sử dụng Codepen. Tạo một dự án mới và hãy bắt đầu. Làm thế nào để tạo ra bộ khung cho ứng dụng Catty MusicSau khi đã tạo một project trên codepen. Chúng ta sẽ tạo một tài liệu html cơ bản: 12345&lt;body&gt; &lt;aside&gt;&lt;/aside&gt; &lt;main&gt;&lt;/main&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt; Có mục đích khi chọn cấu trúc này. Bạn sẽ sớm nhận ra điều đó. Bây giờ style tài liệu. 1234body &#123; display: grid; min-height: 100%&#125; Đoạn code này sẽ biến body thành một grid-container. Bây giờ chúng ta cần tạo cấu trúc các dòng và cột trong grid. Làm thế nào để tạo ra các dòng và các cột cho ứng dụng Catty MusicTạo các dòng và cột là khá dễ dàng. Kết quả cuối cùng chúng cần đạt được là: Tuy nhiên, ban đầu khi thiết lập grid chúng ta cần 2 dòng và 2 cột. Đây là một vài thứ cần chú ý về thiết lập GridColumns: Cột đầu tiên phải có độ rộng cố định là 50px. Cột thứ 2 phải chiếm toàn bộ độ rộng còn lại của dòng. Rows: Dòng thứ 2 phải có chiều cao cố định là 100px. Dòng đầu tiên phải chiếm toàn bộ chiều còn lại của grid. Giải pháp của một người ít kinh nghiệm.Nếu bạn KHÔNG có kinh nghiệm với CSS, bạn có thể viết như thế này: 12345body &#123; ... grid-template-rows: 100% 100px; grid-template-columns: 50px 100%;&#125; Vấn đề với giải pháp này là bạn đã vô tình tạo ra một grid với chiều rộng là 100% + 50px và chiều cao là 100% + 100px. Cái chúng ta muốn là chiều rộng và chiều cao là 100%. Vì thế hướng tiếp cần này là sai. Giải pháp của người đã có kinh nghiệmNếu đã có một vài kinh nghiệm với CSS, bạn có thể làm một vài thứ thông minh hơn như thế này: 12345body &#123; ... grid-template-rows: calc(100% - 100px) 100px; grid-template-columns: 50px calc(100%-50px)&#125; Cách này khá thông minh. Nhưng có một vấn đề - nó rất khó để bảo dưỡng. Ví dụ, nếu vì một lý do nào đó bạn phải thay đổi độ rộng cố định, bạn cũng phải thay đổi định nghĩa calc. Giải pháp hiệu quả nhấtMay mắn là CSS Grid có một đơn vị mới giúp chúng ta giải quyết vấn đề ở trên một cách dễ dàng đó là đơn vị. factional(fr) Đơn vị fractional giải quyết vấn đề tự động phân bố khoảng trống. Nếu bạn có grid với 3 cột như ở dưới, đơn vị fractional sẽ tự động phân bổ các khoảng trống bằng nhau. INếu vì một vài lý do bạn thêm nhiều phần tử hơn - đừng lo lắng. Đơn vị fr sẽ phân bổ lại các khoảng trống bằng nhau. Cuối cùng, nếu bạn đã có một phần tử với độ rộng cố định, bạn có thể lấy toàn bộ khoảng trống còn lại với đơn vị fr. Như thế này: 12345body &#123; ... grid-template-rows: 1fr 100px; grid-template-columns: 50px 1fr;&#125; And that is it — done! Đặt tên và xác định vị trí bởi Grid AreasChúng ta đã tạo ra hệ thống grid. Bây giờ là lúc để sử dụng nó. Mục đích của phần này học cách xác định vị trí các phần tử trong grid sử dụng grid areas. Nhắc lại một chút, một grid area là bất kỳ khoảng trống được bao bởi 4 grid line. Làm thế nào để sử dụng grid areas?Nơi hợp lý để bắt đầu là đặt tên grid areasHãy để tôi giải thích.Xem xét khối lệnh dưới đây: 123&lt;div class=\"aside\"&gt;&lt;/div&gt;&lt;div class=\"main\"&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; 3 divs - đơn giản. Bằng cách này, Nó là ngữ nghĩa tốt hơn để sử dụng tags aside main và footer. Tôi sẽ giữ mọi thứ đơn giản. Bây giờ hãy xem đoạn code này: 123456789.main &#123; grid-area: content;&#125;.footer &#123; grid-area: footer;&#125;.aside &#123; grid-area: sidebar;&#125; Chuyện gì đang xảy ra ở đâyNếu biết một chút về Javascript, hay bất kỳ ngôn ngữ lập trình nào khác, thì khái niệm về biến sẽ không phải là mới với bạn. Trong Javascript, chúng ta có thể nói: 1var gridArea = \"content\" Cái chúng ta làm ở phía trên là, lưu chuỗi content vào biến gridArea Khai báo CSS ở phần trước tương tự như vậy. Mọi phần tử trong grid có thể được gán tới một vùng trong grid container. Tuy nhiên, trước khi làm điều đó, chúng ta bắt buộc phải gán mỗi phần tử trong grid với một tên gọi. Giống như các biến trong Javascript. 123456789.main &#123; grid-area: content;&#125;.footer &#123; grid-area: footer;&#125;.aside &#123; grid-area: sidebar;&#125; Đoạn code ở trên nói rằng, class .main có tên là content. Class .footer có tên là footer. Cuối cùng, class .aside có tên là sidebar Bây giờ các grid items được gán tên cho mỗi vùng. Trong lập trình, các biến được thiết lập để được sử dụng ở nơi khác. Bây giờ, hãy sử dụng tên grid area. Vị trí Grid areaMột người đàn ông trẻ có một cái bánh nướng. Anh ta có 3 đứa con và phải chia cho mỗi đứa một phần. Ai là người chia bánh thì hợp lý nhất? Chính người đàn ông đó! Người đàn ông trẻ cắt bánh và chia cho mỗi đứa trẻ một phần. Đây là lý do tôi kể câu chuyện này. Giống như chiếc bánh, toàn bộ khoảng trống trong grid là của ai? Chính là grid container! Giống như người đàn ông trẻ, grid container có 3 đứa con .aside .main và .footer. Bây giờ grid container phải chọn cách chia toàn bộ khoảng trống trong grid cho 3 đứa con này. Và một điều nữa. Vì tất cả những đứa trẻ đều có tên, người đàn ông trẻ có thể nói: “hey Brian đây là phần của con hoặc hey Emma của con là phần này.” Dễ dàng để xác định ai sở hữu phần nào của chiếc bánh, bằng cách gán mỗi phần với tên của mỗi người. Mỗi phần tử trong grid đều đã có tên bằng cách sử dụng thuộc tính grid-area. Bây giờ, hãy chia bánh! Thuộc tính grid-template-areasBây giờ grid container phải chia “bánh”. Gán mỗi vùng tới mỗi phần tử tương ứng. Có nhiều cách để làm điều đó, nhưng thuộc tính grid-template-areas là cách dễ dàng nhất để làm đó. nó chính là cái bạn cần biết để làm việc hiệu quả. Thuộc tính grid-template-areas làm việc như thế nào?Hãy xem đoạn code dưới đây: 1234body &#123; grid-template-areas: \"sidebar content\" \"footer footer\"; &#125; Cái quái gì vậy? Không cần phải bị choáng ngợp. Trong phần này, tôi sẽ giải thích nó hoạt động như thế nào - theo thuật ngữ rõ ràng. Thuộc tính grid-template-areas cung cấp một cấu trúc rất trực quan của grid. Hãy xem lại đoạn code trên một lần nữa: 1234body &#123; grid-template-areas: \"sidebar content\" \"footer footer\"; &#125; Bạn có thể thấy toàn bộ giá trị của thuộc tính là tên của các phần tử trong grid! sidebar content và footer là tên của các phần tử trong grid. Khai báo ở trên gán mỗi vùng trong grid với một phần tử tương ứng. Hình ảnh trên sẽ giúp bạn hiểu grid được chia như thế nào. footer sẽ chiếm toàn bộ dòng bên dưới. sidebar và content sẽ chiếm cột đầu tiên và thứ 2 của dòng bên bên. Đến đây chúng ta có: 1234567body &#123; display: grid; grid-template-columns: 40px 1fr; grid-template-rows: 1fr 90px; grid-template-areas: \"sidebar content\" \"footer footer\"; &#125; Kết quả sẽ như dưới đây: Tôi đã thêm màu sắc để hỗ trợ hình ảnh. Phần màu đỏ đại diện cho .footer, hai phần còn lại, phần .main và .sidebar. Làm cho bố cục responsive - Định nghĩa lại Grid areas với Media Queries Các Grid area mà bạn đã tạo trong grid container có thể thay đổi tùy theo kích thước màn hình của người sử dụng. Dưới đây là hình ảnh ứng dụng trên màn hình điện thoại. Chúng ta sẽ refactor lại code theo hướng tiếp cận mobile first. Mobile first đơn giản là làm cho style mặc định của bạn là dành cho các thiết di động. Sau đó bạn sẽ tạo ra các thay đổi cho các màn hình lớn hơn thông qua các media query. Đặt một phần code hiện nay trong một định nghĩa media query. Như dưới đây: 1234567@media only screen and (min-width: 600px) &#123; body &#123; grid-template-columns: 50px 1fr; grid-template-areas: \"sidebar content\" \"footer footer\"; &#125;&#125; Bạn sẽ để đoạn code mặc định bên ngoài media query 1234body &#123; display: grid; grid-template-rows: 1fr 100px;&#125; Tại sao chúng ta đặt grid-template-rows: 1fr 100px; bên ngoài media query? Bởi vì cả màn hình di động và desktop chúng ta đều có 2 dòng. Tuy nhiên, trên màn hình desktop. Sidebar là 50px trong định nghĩa grid-template-columns. Còn trên các thiết bị di động sidebar không tồn tại. Vì thế, chúng ta sẽ định nghĩa lại khai báo grid-template-columns cho di động. Bây giờ với các thiết bị di động chúng ta sẽ sử dụng style này là mặc định: 123body &#123; grid-template-areas: \"content\" \"footer\" Khá đơn giản phải không? Hãy để tôi giải thích. Dòng chảy (hướng) của GridĐoạn code cho di động như thế này: 123body &#123; grid-template-areas: \"content\" \"footer\" Bởi mặc định, một grid sẽ sắp xếp các phần tử trên các dòng. Vì thế khai báo ở phía trên sẽ sắp xếp content trên một dòng và footer trên một dòng khác. Dưới đây là kết quả - sidebar sẽ ẩn trên màn hình di động: Với rào cản ban đầu của sự hiểu biết cách hoạt động của grids và thiết lập responsive grid, chúng ta đã xong bố cục ứng dụng! Thêm nội dung vào trong GridKhi kết thúc phần này chúng ta sẽ có một bố cục ứng dụng âm nhạc hoàn chỉnh. Bây giờ hãy tập trung và việc sắp xếp nội dung trong grid. 1. The SidebarĐiều này có vẻ dễ nhất để bắt đầu. Hãy đi tìm nó. Sidebar bao gồm 8 icon cách đều nhau dọc theo toàn bộ chiều dài của sidebar. Hãy chèn các icon vào sidebar: 12345678910&lt;div class=\"aside\"&gt; &lt;i class=\"fa fa-bars\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-home\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-search\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-volume-up\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-spotify\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-cog\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-soundcloud\"&gt;&lt;/i&gt;&lt;/div&gt; Kết quả sẽ như thế này: Các icon cũng sẽ ẩn trên màn hình di động. Và chỉ hiển thị trên các màn hình lớn hơn. Đây là hướng tiếp cận mobile first. 1234567.aside i &#123; display: none;&#125;@media only screen and (min-width:600px) &#123; .aside i &#123; display: block; &#125; Các biểu tượng được hiển thị, nhưng được căn chỉnh chưa đều. Sắp xếp các iconCác thẻ i là các phần tử inline – điều đó giải thích tại sao 2 icon lại hiển thị cạnh nhau trên một dòng. Hãy sắp xếp chúng. Các phần tử con của grid container cũng có thể trở thành các grid container. Tại sao không? Bước 1: Biến Sidebar thành một Grid ContainerĐiều này sẽ cung các tính năng căn chỉnh của grid. Khi sidebar chỉ hiển thị trên các màn hình lớn hơn, đừng quên đặt nó trong media query. 123456789@media only screen and (min-width:600px) &#123; .aside &#123; display: grid; &#125; .aside i &#123; border: 1px solid red; &#125;&#125; Tôi thêm border cho mỗi icon - để chúng ta dễ phân biệt. Chuyện gì đang xảy ra ở đây? Chúng ta KHÔNG thiết lập bất kỳ dòng hay cột trong sidebar. Nhưng chúng ta thấy các icon được sắp xếp khá tốt. Grid tự động thiết lập điều đó. Đây là vị trí mặc định của các item trong một grid – trên cùng một dòng. Một grid cũng có thể sắp xếp các phần tử sử dụng justify-items hay align-items. justify-items sẽ sắp xếp các phần tử theo chiều ngang. align-items sẽ sắp xếp các phần tử theo chiều dọc. Áp dụng điều này cho sidebar, và chúng ta có một bổ cục các icon hoàn hảo: 12345.aside &#123; ... justify-items: center; align-items: center; &#125; Bạn vẫn cảm thấy khó hiểu, hãy xem video dưới đây: Bây giờ chúng ta đã một bố cục hoàn hảo dành cho các icon trong sidebar. justify-items hay align-items có thể có các giá trị: stretch start end center Nếu đã từng làm việc với Flexbox, bạn sẽ quen với chúng. Chúng ta sẽ thêm nhiều nội dung hơn vào thiết kế hiện tại. Thêm 2 thẻ div vào main section: 1234&lt;div class=\"main\"&gt; &lt;div class=\"main__header\"&gt;&lt;/div&gt; &lt;div class=\"main__body\"&gt;&lt;/div&gt;&lt;/div&gt; NB: main__header sẽ chứa music art và playbacks: main__bodysẽ chứa chi tiết: Trong phần này chúng ta sẽ tập trung vào main__header Đầu tiên, thêm đoạn code html này: 1234567891011121314151617&lt;div class=\"main__header\"&gt; &lt;div class=\"img\"&gt; &lt;img src=\"http://bit.ly/2sc2NJd\"/&gt; &lt;/div&gt; &lt;section class=\"details\"&gt; &lt;div&gt; &lt;p&gt;CattyBoard Top 100 Single Charts (11.06.36)&lt;/p&gt; &lt;p class=\"sm--hide\"&gt;Unknown Artist&lt;/p&gt; &lt;p class=\"sm--hide\"&gt;2016 . Charts . 100 songs&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;i class=\"fa fa-play\"&gt; &amp;nbsp;Play all&lt;/i&gt; &lt;i class=\"fa fa-plus\"&gt; &amp;nbsp;Add to&lt;/i&gt; &lt;i class=\"fa fa-ellipsis-h\"&gt;&amp;nbsp;&amp;nbsp;More&lt;/i&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt; Chú ý cấu trúc của tài liệu main__header có hai con trực tiếp. Một div chứa một hình ảnh và section chứa thông tin chi tiết của album. Kết quả của đoạn code trên khá xấu xí: Hãy làm cho nó đẹp hơn. Cái chúng ta cần là một grid với các phần tử được sắp xếp phù hợp. Hãy sử dụng những kiến thức về grid areas Đầu tiên, định nghĩa grid area: 123456.main__header &gt; .img &#123; grid-area: img;&#125;.main__header &gt; .details &#123; grid-area: dtls;&#125; div chứa hình ảnh được đặt tên là img. Phần chứa thông tin chi tiết của album được đặt tên là dtls. Bây giờ, định nghĩa grid: 12345.main__header &#123; display: grid; grid-template-areas: \"img\" \"dtls\"; &#125; .main__header trở thành một grid container, có 2 phần tử xếp chồng lên nhau đầu tiên là img tiếp theo là dtls. Bởi vì chúng ta đang theo hướng tiếp cận mobile first. Tại thời điểm này, không có nhiều thay đổi. Đây không phải là cái chúng ta muốn trên di động. Với màn hình di động, các phần tử nên được căn giữa. 12345@media screen and (max-width: 600px) &#123; .main__header &#123; justify-items: center; &#125; &#125; Kết quả sẽ như dưới đây: Tiếp theo hãy làm cho text trong .details căn giữa: 12345@media screen and (max-width: 600px) &#123; .main__header &gt; .details &#123; text-align: center; &#125; &#125; Đã khá gần với mục tiêu chỉ cần thêm một vài điều chỉnh. Đoạn text Unknown Artist và 2016 . Charts . 100 songs nên ẩn trên di động. Ảnh cũng nên nhỏ hơn. 12345678@media screen and (max-width: 600px) &#123; .sm--hide &#123; display: none; &#125; .img &gt; img &#123; width: 150px &#125;&#125; Class .sm--hide sẽ ẩn trên di động. Chỉ cần thêm class tới phần tử mong muốn. Như thế này: 12&lt;p class=\"sm--hide\"&gt;Unknown Artist&lt;/p&gt;&lt;p class=\"sm--hide\"&gt;2016 . Charts . 100 songs&lt;/p&gt; Và chúng ta có: Màn hình di động đã xong. Giờ hãy thêm style cho những màn hình lớn hơn. Với màn hình lớn hơn, chúng ta cần một grid 2 cột. Style sẽ như thế này: 123456@media only screen and (min-width:600px) &#123; .main__header &#123; grid-template-columns: 250px 1fr; grid-template-areas: \"img dtls\" &#125; &#125; Grid đã được định nghĩa lại với 2 cột. Một có độ rộng cố định là 250px và cột kia chiếm toàn bộ khoảng trống còn lại. Tiến trình hiện tại của chúng ta here. Phần 4: Kết hợp CSS Grid với FlexboxTrong phần này bạn sẽ học cách sử dụng Flexbox và Grid cùng nhau. Hai module này đã thay đổi cách xử lý bố cục trong CSS. Và cách hiệu quả nhất là sử dụng cả 2 module cùng nhau. Hãy đi vào chi tiết. Với phần hiển thị thông tin chi tiết của album chúng ta sẽ sử dụng flexbox. Làm sao để biết chỗ nào sẽ sử dụng Flexbox?Quy tắc chung là sử dụng Grid cho bố cục toàn bộ trang, còn Flexbox dành cho UI bên trong các phần tử con. Một phần tử con có thể là một flex container. Một phần tử con của flex container cũng có thể là một grid container. Tôi giả sử rằng bạn đã biết về flexbox. Như thường lệ, hãy bắt đầu bằng html Dưới đây là một div, với một danh sách các bài hát. Danh sách các bài hát có các đoạn có chứa tên bài hát, nghệ sĩ, thời lượng của bài hát và “catty cloud sync”. 1234567891011121314151617181920212223242526&lt;div class=\"main__body\"&gt; &lt;div&gt; &lt;p&gt;1. One Dance&lt;/p&gt; &lt;p&gt;Crake feat CatKid &amp;amp; Cyla&lt;/p&gt; &lt;p&gt;2:54&lt;/p&gt; &lt;p&gt;&lt;span&gt;CATTY CLOUD SYNC&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;2. Panda&lt;/p&gt; &lt;p&gt;Cattee&lt;/p&gt; &lt;p&gt;4:06&lt;/p&gt; &lt;p&gt;&lt;span&gt;CATTY CLOUD SYNC&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;3. Can't Stop the Feeling!&lt;/p&gt; &lt;p&gt;Catin Cimberlake&lt;/p&gt; &lt;p&gt;3:56&lt;/p&gt; &lt;p&gt;&lt;span&gt;CATTY CLOUD SYNC&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;4. Work From Home&lt;/p&gt; &lt;p&gt;Cat Harmony feat Colla&lt;/p&gt; &lt;p&gt;3:34&lt;/p&gt; &lt;p&gt;&lt;span&gt;CATTY CLOUD SYNC&lt;/span&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; Đây là cái chúng ta có: main__body là một phần tử của grid. Chúng ta có thể biến nó thành flex container nếu điều đó hữu ích. Trong trường hợp của chúng ta, mỗi thẻ div là con trực tiếp của main__body cần trở thành một flex container. Chúng chứa tên bài hát, nghệ sĩ, thời gian và “catty cloud sync”. 123.main__body &gt; div &#123; display:flex;&#125; Bây giờ chia chiều rộng cho các phần tử con: 123.main__body &gt; div p &#123; flex: 0 0 25%;&#125; Bạn sẽ đồng ý với tôi rằng tại thời điểm này, các yếu tố cần thiết cho bố cục đã hoàn thành. Tuy nhiên, tôi đã thực hiện một vài thay đổi. Bạn có thể xem kết quả cuối cùng here Bạn sẽ nhận thấy rằng tôi vẫn để trống footer. Đó là bài tập cho bạn. Lời khuyên của tôi là sử dụng flexbox. Nó sẽ giúp bạn hiểu cách cả hai module này làm việc cùng nhau. Với một vài thuộc tính của grid, bạn đã xây dựng một bố cục thực sự. Khá ấn tượng. Bạn cũng học được kỹ năng vô giá khi kết hợp CSS Grid với Flexbox.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"grid","slug":"grid","permalink":"http://nthung2112.github.io/tags/grid/"}]},{"title":"Tìm hiểu về Proxy trong ES6","slug":"Tim-hieu-ve-Proxy-trong-ES6","date":"2018-07-08T08:57:00.000Z","updated":"2018-07-08T08:59:57.977Z","comments":true,"path":"2018/07/Tim-hieu-ve-Proxy-trong-ES6.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Tim-hieu-ve-Proxy-trong-ES6.html","excerpt":"Nói về ES6 có lẽ chúng ta đã quá quen thuộc với các khái niệm như const và let, hàm mũi tên, class hay những tính năng hay ho hấp dẫn khác. Ngoài ra, ES6 cũng kèm theo những tính năng ít người biết hơn nhưng cũng rất thú vị, và một trong số đó là Proxy.","text":"Nói về ES6 có lẽ chúng ta đã quá quen thuộc với các khái niệm như const và let, hàm mũi tên, class hay những tính năng hay ho hấp dẫn khác. Ngoài ra, ES6 cũng kèm theo những tính năng ít người biết hơn nhưng cũng rất thú vị, và một trong số đó là Proxy. Proxy là gì?Proxy là một class được giới thiệu từ ES6, cho phép bạn can thiệp và thay đổi hành vi của một đối tượng (object). Các hành vi này bao gồm: truy xuất/thiết lập thuộc tính của một đối tượng, thay đổi prototype, gọi hàm, khởi tạo đối tượng bằng từ khóa new… Để hiểu rõ hơn về khái niệm, bạn có thể xem qua ví dụ sau: 123456789101112131415161718const u = &#123; name: 'Công Tằng Tôn Nữ Tạ Thị Tòn Ten' &#125;// Thiết lập proxy cho đối tượng `u`const p = new Proxy(u, &#123; // `get` là một trap, sẽ được gọi khi truy xuất đến thuộc tính // của đối tượng get(target, prop, receiver) &#123; // Thay đổi hành vi khi truy xuất đến một thuộc tính: Nếu là // chuỗi, chuyển sang chữ hoa if (typeof target[prop] === 'string') return target[prop].toUpperCase() return target[prop] &#125;&#125;)console.log(p.name) // CÔNG TẰNG TÔN NỮ TẠ THỊ TÒN TENp.email = 'ta.thi@ton.ten'console.log(p.email) // TA.THI@TON.TEN Chúng ta có thể áp dụng Proxy cho bất cứ object nào trong JavaScript, kể cả mảng, hàm hay một proxy khác. Có thể bạn thừa biếtMột hàm trong JavaScript là một thể hiện của lớp Function. Hiện tại Proxy đã được hỗ trợ bởi các trình duyệt xịn (nghĩa là không có IE đó) và node.js v6 trở đi. Tin vắnPhiên bản 5.0 của MobX đã hoàn toàn sử dụng ES6 Proxy. Sử dụng như thế nào?Trước hết, hãy xem qua những thuật ngữ thông dụng khi làm việc với Proxy: target: là đối tượng sẽ được áp dụng proxy vào traps: là những phương thức giúp bạn thay đổi hành vi của đối tượng handler: là một object chứa các traps, được đưa vào hàm dựng của lớp Proxy Để khởi tạo proxy, bạn dùng new Proxy(target, handler) như bên dưới: 1const p = new Proxy(target, handler) Chúng ta sẽ cùng đi qua những traps thông dụng. handler.get() và handler.set()Như tên gọi, handler.get() và handler.set() cho phép bạn can thiệp khi truy xuất và thiết lập giá trị một thuộc tính của đối tượng. 12345678// property: tên của thuộc tính được truy xuất// receiver: đối tượng sau khi đã được gắn proxyhandler.get(target, property, receiver)// value: giá trị sẽ được thiết lập cho thuộc tính// handler.set() phải trả về một giá trị boolean. Nếu là true thì xem như thiết lập// thành công, ngược lại nếu là false thì xảy ra lỗi TypeError.handler.set(target, property, value, receiver) Chúng ta có thể dùng handler.set() để kiểm tra tính đúng đắn dữ liệu (data validation) trên thuộc tính của đối tượng. Chẳng hạn như: 123456789101112const u = &#123; age: null &#125;const p = new Proxy(u, &#123; set(target, prop, val) &#123; if (prop === 'age' &amp;&amp; typeof val !== 'number') throw new TypeError('Age must be a number') target[prop] = val return true &#125;&#125;)p.age = '10' // Error: Age must be a numberp.age = 10 // OK! handler.defineProperty() và handler.deleteProperty()handle.defineProperty(target, property, descriptor) là trap được kích hoạt khi sử dụng Object.defineProperty(). Phương thức này đòi hỏi phải trả về một giá trị boolean. Ví dụ: 123456789101112const p = new Proxy(&#123; foo: 1, bar: true &#125;, &#123; defineProperty(target, property, descriptor) &#123; if (property.startsWith('_')) throw new Error('Properties starting with _ are not allowed') return Object.defineProperty(...arguments) &#125;&#125;)p._hello = 1 // ErrorObject.defineProperty(p, '_hello', &#123; value: 1 &#125;) // Errorp.hello = 1Object.defineProperty(p, 'hello', &#123; value: 1 &#125;) descriptor là một object quy định hành vi của thuộc tính được khai báo. Chi tiết về descriptor bạn có thể xem ở trang MDN hoặc hóng bài viết tiếp theo của Ehkoo. handle.deleteProperty(target, property) sẽ được kích hoạt khi thực hiện delete một thuộc tính. Phương thức này phải trả về true nếu quá trình xóa được chấp nhận. Ví dụ: 12345678910const p = new Proxy(&#123; foo: 1, bar: true &#125;, &#123; deleteProperty(target, property) &#123; delete target[property] console.log(`$&#123;property&#125; was removed`) return true &#125;&#125;)delete p.foo // foo was removeddelete p.bar // bar was removed handler.has()handler.has() sẽ được kích hoạt khi sử dụng in. Phương thức này cũng đòi hỏi phải trả về một giá trị boolean. Ví dụ: 123456789const p = new Proxy(&#123; _foo: 1, bar: true &#125;, &#123; has(target, property) &#123; if (property.startsWith('_')) return false return property in target &#125;&#125;)console.log('bar' in p) // trueconsole.log('_foo' in p) // true handler.apply()handler.apply(target, thisArg, args) là trap dành cho các hàm, sẽ được khởi động khi hàm được gọi. Ví dụ: 123456789const sum = (a, b) =&gt; a + bconst f = new Proxy(sum, &#123; apply(target, thisArg, args) &#123; const [a, b] = args return target.call(thisArg, a * 2, b * 2) &#125;&#125;)f(1, 2) // 6 handler.construct()handler.construct(target, args) là trap sẽ được gọi khi khởi tạo đối tượng bằng new. Ví dụ: 123456789101112131415class User &#123; constructor(username) &#123; this.username = username &#125;&#125;const PUser = new Proxy(User, &#123; construct(target, args) &#123; const [username] = args return new target(username.toUpperCase()) &#125;&#125;)const u = new PUser('pikalong')console.log(u.username) // PIKALONG handler.getPrototypeOf() và handler.setPrototypeOf()Như tên gọi, hai traps này sẽ được kích hoạt khi sử dụng Object.getPrototypeOf() và Object.setPrototypeOf() trên đối tượng. Ghi chúBên cạnh những traps được giới thiệu ở đây, còn có một số traps khác mà bạn có thể tham khảo ở trang MDN. Viết thử nàoBạn có dùng thử chai chưa? Thư viện này hỗ trợ viết kiểm chứng (assertion) theo phong cách BDD/TDD, giống như thế này: 123456789// chai.expectexpect(foo).to.be.a('string')expect(foo).to.equal('bar')expect(foo).to.have.lengthOf(3)// hoặc chai.shouldfoo.should.be.a('string')foo.should.equal('bar')foo.should.have.lengthOf(3) Cách thiết kế này rõ ràng giúp cho chương trình trở nên mạch lạc và dễ theo dõi vì câu kiểm chứng được viết như một câu tiếng Anh vậy. Chúng ta có thể bắt chước chai và thử viết một lớp Thing có những khả năng sau: 123456789101112131415// Khởi tạo một đối tượng của lớp Thing với tên là \"Phương\"const t = new Thing('Phương')t.name // 'Phương'// Khai báo các thuộc tính booleant.is_a.singert.is_not_a.man// Kiểm tra thuộc tínht.is_a_singer // truet.is_a_man // false// Khai báo phương thứct.can.sing('Yêu hay không yêu không yêu hay yêu nói một lời')t.sing() // Phương sings: Yêu hay không yêu không yêu hay yêu nói một lời Đây là một phần trong bài The builder of things được lấy từ Codewars. Sau khi đọc hết bài viết này thì bạn hãy thử giải thử thách trên xem sao, bảo đảm kết quả không làm bạn thất vọng đâu.Ngoài ra nếu bạn có tham gia Codewars thì đừng quên gia nhập clan Ehkoo nhé ;) Đầu tiên, để truy xuất thuộc tính name, chúng ta có thể nghĩ đến giải pháp “vô cùng rõ ràng và ngây thơ” sau: 12345class Thing &#123; constructor(name) &#123; this.name = name &#125;&#125; Đoạn code trên hoàn toàn hợp lý, nhưng sẽ không giúp chúng ta giải quyết những yêu cầu tiếp theo của bài toán. Phân tích kỹ một chút ta có thể thấy việc dùng Proxy là không thể tránh khỏi. Do đó để cài đặt t.name bằng Proxy, ta có thể viết lại thành: 123456789101112131415161718192021222324class Thing &#123; constructor(name) &#123; this.state = &#123; name &#125; return proxify(this, this.state) &#125;&#125;// Hàm proxify() nhận vào một target và một object chứa state.// State này sẽ được sử dụng để giải quyết những yêu cầu tiếp theo.function proxify(target, state) &#123; return new Proxy(target, &#123; get(target, prop, receiver) &#123; // Nếu truy xuất đến thuộc tính `name`, lấy ra dữ liệu trong state if (prop === 'name') return state[prop] // Còn lại thì sử dụng hành vi mặc định return target[prop] &#125; &#125;)&#125;const t = new Thing('Phương')console.log(t.name) // Phươngconsole.log(t.age) // undefined Vậy là tạm ổn phần lấy name. Chúng ta xem tiếp đến hành vi tiếp theo của lớp Thing. 12345t.is_a.singert.is_not_a.mant.is_a_singer // truet.is_a_man // false Hành vi này cho phép khai báo thuộc tính boolean trên đối tượng bằng cách sử dụng is_a cho giá trị true và is_not_a cho giá trị false. Sau đó ta có thể kiểm tra thuộc tính bằng cách truy xuất đến is_a_${prop}. Để cài đặt hành vi này, chúng ta có thể làm như sau: Khai báo thêm một khóa booleans: {} cho state. Khóa này đóng vai trò như một bảng tham chiếu giữa tên thuộc tính boolean và giá trị của nó, chẳng hạn như { singer: true, man: false }. Ngoài ra chúng ta cũng cần thêm vào state một cờ inBooleanMode: false. Nếu prop là is_a hoặc is_not_a, bật cờ inBooleanMode: true Nếu cờ inBooleanMode đang bật, thuộc tính tiếp theo sẽ là thuộc tính boolean. Do đó ta cập nhật booleans của state thành { …booleans, [prop]: state.booleanValue } 12345678910111213141516171819202122232425262728function enterBooleanMode(receiver, state, booleanValue) &#123; // Bật cờ state.inBooleanMode = true // Lưu lại giá trị boolean tùy thuộc vào là `is_a` hay `is_not_a` state.booleanValue = booleanValue return receiver&#125;function setBoolean(receiver, state, prop) &#123; state.booleans = &#123;...state.booleans, [prop]: state.booleanValue &#125; // Reset lại các giá trị state.inBooleanMode = false state.booleanValue = null return receiver&#125;get(target, prop, receiver) &#123; // Đặt ở đây để tránh trường hợp gọi t.is_a.is_a if (state.inBooleanMode) return setBoolean(this, state, prop) if (prop === 'name') return state[prop] if (prop === 'is_a') return enterBooleanMode(receiver, state, true) if (prop === 'is_not_a') return enterBooleanMode(receiver, state, false) if (prop.startsWith('is_a_')) return state.booleans[prop.replace('is_a_', '')] return target[prop]&#125; Kiểm tra thử. 123456const t = new Thing('Phương')t.is_a.singert.is_not_a.manconsole.log(t.is_a_singer) // trueconsole.log(t.is_a_man) // false Để cài đặt hành vi tiếp theo, chúng ta cũng có thể làm tương tự như khai báo thuộc tính boolean bằng cách đặt thêm một cờ inDefineMethodMode và bật/tắt cờ này tương ứng. Bên cạnh đó chúng ta cũng đặt thêm một khóa methods trong state để chứa các phương thức được khai báo thông qua can. 123456789get(target, prop, receiver) &#123; // ... if (state.inDefineMethodMode) return setMethod(receiver, state, prop) if (prop === 'can') return enterDefineMethodMode(receiver, state) // Lấy ra phương thức được khai báo bởi `t.can` if (state.methods[prop]) return state.methods[prop] // ...&#125; Ở đây có một chút khó khăn. Có thể thấy trong t.can.sing(phrase), sing phải là một hàm. Do đó giá trị trả về của setMethod() có thể được viết như sau: 1234567891011121314function setMethod(receiver, state, prop) &#123; // Đừng quên tắt cờ sau khi cài đặt method state.inDefineMethodMode = false return phrase =&gt; &#123; // Tạo ra hàm mới const f = () =&gt; `$&#123;state.name&#125; $&#123;prop&#125;: $&#123;phrase&#125;` // Lưu vào danh sách các phương thức được khai báo bởi `t.can` state.methods = &#123; ...state.methods, [prop]: f &#125; &#125;&#125;t.can.sing('Yêu hay không yêu không yêu hay yêu nói một lời')console.log(t.sing()) // Phương sing: Yêu hay không yêu không yêu hay yêu nói một lời Vậy là được rồi. Chúng ta chỉ còn một bước nữa là chia “sing” sang ngôi thứ ba số ít “sings”, nhưng thôi cái này để bạn tự làm nhé. Bạn có thể xem đầy đủ mã nguồn ở đây. KếtProxy là một công cụ mạnh mẽ, giúp cho việc lập trình meta trong JavaScript trở nên dễ dàng hơn. Hi vọng bài viết này đã giúp bạn hiểu rõ hơn về Proxy và có thể ứng dụng nó trong công việc. Tham khảoProxy - MDN - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy ES6 Proxies in Depth - https://ponyfoo.com/articles/es6-proxies-in-depth","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Tìm hiểu Map và Set trong Javascript","slug":"Tim-Hieu-Map-Va-Set-Trong-Javascript","date":"2018-07-08T08:12:00.000Z","updated":"2018-07-08T08:57:25.234Z","comments":true,"path":"2018/07/Tim-Hieu-Map-Va-Set-Trong-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Tim-Hieu-Map-Va-Set-Trong-Javascript.html","excerpt":"Được giới thiệu từ ES6, Map, Set, WeakMap, và WeakSet là những cấu trúc dữ liệu giúp thao tác trên tập hợp. Bài viết này sẽ giới thiệu cách hoạt động cũng như các ứng dụng của chúng.","text":"Được giới thiệu từ ES6, Map, Set, WeakMap, và WeakSet là những cấu trúc dữ liệu giúp thao tác trên tập hợp. Bài viết này sẽ giới thiệu cách hoạt động cũng như các ứng dụng của chúng. MapMap, mảng kết hợp (associate arrays) hay từ điển (dictionary/dict) là những thuật ngữ dùng để chỉ một cấu trúc dữ liệu, cho phép bạn ánh xạ từ một khóa (key) tương ứng với một giá trị (value). Trong JavaScript, chúng ta có thể sử dụng object để thể hiện cấu trúc này. 123456const dict = &#123; hello: 'Xin chào', bye: 'Tạm biệt',&#125;console.log(dict['hello']) // Xin chào Tuy nhiên, nếu dùng object thì bạn chỉ có thể dùng chuỗi làm khóa. Ngoài ra, cách này cũng có một số hạn chế khác. Lớp Map do ES6 giới thiệu sẽ giúp giải quyết những vấn đề này. Với Map, bạn có thể sử dụng bất cứ dạng dữ liệu nào để làm khóa. 1234567891011const obj = &#123; bar: 2 &#125;const dict = new Map()dict .set('foo', 123) .set(obj, 'hello world')dict.get('foo') // 123dict.get(obj) // 'hello world'// Lấy giá trị của một khóa không tồn tạidict.get('wat') // undefined Bạn cũng có thể truyền vào hàm dựng của Map một mảng các cặp giá trị dạng [key, value], ví dụ như sau: 1234const dict = new Map([ ['foo', 123], [obj, 'hello world']]) Như đã nói ở trên, bạn có thể dùng bất cứ dạng dữ liệu gì để làm khóa cho Map, kể cả mảng, object, hàm, hay NaN. 123456const arr = [1]const f = () =&gt; &#123;&#125;dict .set(arr, 'an array') .set(f, 'a function') .set(NaN, 'not a number') Bản thân Map sử dụng phương thức so sánh SameValueZero để tìm khóa và giá trị tương ứng. SameValueZero hoạt động tương tự như ===, nhưng xem các giá trị NaN bằng nhau, cũng như +0 bằng -0. Đố-hẻm-vui: Đố bạn kết quả của các biểu thức sau là gì? NaN == NaNNaN === NaNObject.is(NaN, NaN) Do SameValueZero nên hai object khác nhau sẽ là hai khóa riêng biệt. 123456const o1 = &#123;&#125;const o2 = &#123;&#125;dict.set(o1, 'Ô Một').set(o2, 'Ô Hai')dict.get(o2) // Ô Haidict.get(&#123;&#125;) // undefined Nếu trong map đã có sẵn khóa, dữ liệu mới sẽ bị ghi đè lên. 12345const m = new Map()m.set('foo', 1)m.set('foo', 2)m.get('foo') // 2 Để duyệt qua các khóa và giá trị trong Map, bạn có thể dùng: 123456789101112131415const dict = new Map([ ['foo', 1], ['bar', 2]])dict.keys() // ['foo', 'bar']dict.values() // [1, 2]dict.entries() // [ ['foo', 1], ['bar', 2] ]dict.forEach(function(value, key, map) &#123; console.log(`$&#123;key&#125; has $&#123;value&#125;`)&#125;, /* thisArgs bạn có thể truyền vào tham chiếu cho `this` ở đây */)// Sử dụng for..of cùng với destructuringfor (let [key, value] of dict) &#123; console.log(`$&#123;key&#125; has $&#123;value&#125;`)&#125; Bạn cũng có thể dùng toán tử spread … với Map 12345678const dict = new Map([ ['foo', 1], ['bar', 2]])console.log([ ['wut', 3], ...dict])// [ [ 'wut', 3 ], [ 'foo', 1 ], [ 'bar', 2 ] ] Một số thao tác khác với Map. 1234567891011121314151617const dict = new Map([ ['foo', 1], ['bar', 2]])// Đếm số cặp giá trị trong mapdict.size // 2// Kiểm tra trong map có khóa \"foo\" hay khôngdict.has('foo') // truedict.has('wut') // false// Xóa một khóa, trả về boolean nếu thành công, false nếu thất bạidict.delete('wut') // falsedict.delete('foo') // true// Xóa hết các cặp giá trị của mapdict.clear() Tại sao lại là size mà không phải length?Một số độc giả tinh ý sẽ nhận ra chúng ta dùng size thay vì length để đếm số cặp giá trị trong map. Lý do là vì: length dùng cho những chuỗi có thể index (đánh số) được, ví dụ với mảng ta có thể arr[3]. Ngược lại, size dành cho những cấu trúc không có thứ tự như Map và Set. SetSet là tập hợp các giá trị không bị trùng lặp, nghĩa là trong một set không thể có hai giá trị bằng nhau. 12345678const s = new Set()set .add('red') .add('blue') .add('sweet') .add('you')s.size // 4 Bạn cũng có thể truyền một mảng vào hàm dựng của Set. 12const s = new Set(['red', 'blue', 'sweet', 'red', 'you'])console.log(s) // Set (4) &#123;'red', 'blue', 'sweet', 'you'&#125; Bạn cũng có thể thấy giá trị ‘red’ bị trùng lặp đã được loại bỏ. Chúng ta có thể áp dụng Set để tạo ra một mảng chứa những phần tử duy nhất. 123const a = ['red', 'blue', 'sweet', 'red', 'you']const b = [...new Set(a)]console.log(b) // [ 'red', 'blue', 'sweet', 'you' ] Cũng tương tự như Map, Set sử dụng SameZeroValue để so sánh các phần tử với nhau. 12345const obj = &#123;&#125;const s = new Set([NaN, &#123;&#125;, obj])s.has(NaN) // trues.has(obj) // trues.has(&#123;&#125;) // false Để duyệt qua các phần tử của Set, bạn có thể dùng các phương thức như với Map. 12345678910111213const s = new Set([1, 2, 3, 4, 5])// Vì Set không có khái niệm keys nên kết quả của `s.keys()` và `s.values()` là như nhau.s.keys()s.values()s.entries()s.forEach(function(value, key, setReference) &#123;&#125;, thisArg)for (let el of s) &#123; console.log(el)&#125; Một số thao tác khác trên Set. 1234567const s = new Set([1, 2, 3, 4, 5])// Xóa một phần tử trong sets.delete(3) // Set (4) &#123;1, 2, 4, 5&#125;// Xóa hết phần tử trong sets.clear() WeakMap và WeakSetES6 cũng giới thiệu hai lớp WeakMap và WeakSet. So với Map, các khóa của WeakMap bắt buộc phải là object, và chúng sẽ bị giải phóng khỏi bộ nhớ (garbage-collecting – “hốt rác”) đầu tiên nếu không có tham chiếu nào. WeakMap có các phương thức tương tự như Map, ngoại trừ việc bạn không thể duyệt qua WeakMap bằng .keys(), .values(), .entries() hay for..of. Bạn cũng không thể .clear(), vì lý do an toàn dữ liệu. Một ứng dụng của WeakMap là dùng để chứa dữ liệu private mà không gây ra rò rỉ bộ nhớ. 12345678910111213141516const privates = new WeakMap()class User &#123; constructor() &#123; const data = &#123; phoneNumber: 123 &#125; privates.set(this, data) &#125; getPhoneNumber() &#123; const data = privates.get(this) return data.phoneNumber &#125;&#125;const u = new User()console.log(u) // &#123;&#125;console.log(u.getPhoneNumber()) // 123 Tương tự như WeakMap, WeakSet cũng chỉ có thể chứa object, và nếu một phần tử trong WeakSet không có tham chiếu tới, nó sẽ bị giải phóng khỏi bộ nhớ. Kết luậnVới những cải tiến so với object thông thường, Map sẽ là công cụ hữu hiệu để lưu trữ dữ liệu dạng (khóa, giá trị). Trong khi đó, Set giúp bạn lưu trữ chuỗi dữ liệu mà không lo lắng về việc trùng lắp giá trị. Tham khảo[1] Axel Rauschmayer. ECMAScript 6: maps and sets. http://2ality.com/2015/01/es6-maps-sets.html [2] Keyed Collections - JavaScript | MDN. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections [3] Steve Brownlee. WeakMap for JavaScript Private Data. https://www.stevebrownlee.com/weakmap-javascript-private-data/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Tổng hợp những tính năng ES6 nổi bật","slug":"Tong-hop-nhung-tinh-nang-ES6-noi-bat","date":"2018-07-08T01:08:00.000Z","updated":"2018-07-08T09:09:59.591Z","comments":true,"path":"2018/07/Tong-hop-nhung-tinh-nang-ES6-noi-bat.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Tong-hop-nhung-tinh-nang-ES6-noi-bat.html","excerpt":"Việc hầu hết những tính năng hay ho hấp dẫn của ES6 đều đã được các trình duyệt hỗ trợ quả là tin vui cho giới lập trình web. Nhờ nó mà nhà phát triển có thể xây dựng ứng dụng trực tiếp bằng ES6, không cần phải thông qua các công cụ chuyển đổi như Babel hay Bublé nữa, giúp ứng dụng trở nên gọn nhẹ hơn, giảm thiểu kích thước tập tin khi chuyển đến người sử dụng.","text":"Việc hầu hết những tính năng hay ho hấp dẫn của ES6 đều đã được các trình duyệt hỗ trợ quả là tin vui cho giới lập trình web. Nhờ nó mà nhà phát triển có thể xây dựng ứng dụng trực tiếp bằng ES6, không cần phải thông qua các công cụ chuyển đổi như Babel hay Bublé nữa, giúp ứng dụng trở nên gọn nhẹ hơn, giảm thiểu kích thước tập tin khi chuyển đến người sử dụng. Nội dung let và const Hàm mũi tên (arrow functions) Chuỗi bản mẫu (template strings) Object chân phương (object literals) Phân rã biến (destructuring) Rest và Spread Giá trị mặc định cho tham số Lớp (class) Promise 1. let và constNgày xa xưa ấy, bạn khai báo biến trong JavaScript bằng var, giống như ví dụ dưới đây. 123456789var foo = 1function printFoo(shouldDo) &#123; if (shouldDo) &#123; var foo = 2 &#125; return foo&#125;console.log(printFoo(false)) // undefinedconsole.log(printFoo(true)) // 2 Biến được khai báo với var sẽ có tầm vực bên trong hàm gần nhất (function scope), và sẽ được đẩy lên đầu của tầm vực (hoisting). Đó là lý do tại sao foo lại có giá trị undefined trong dòng console.log đầu tiên. ES6 giới thiệu let và const như hai cách khai báo biến mới, hỗ trợ tầm vực theo khối (block scope) và không thực hiện hoisting. 1234567891011let foo = 1function printFoo(shouldDo) &#123; if (shouldDo) &#123; let foo = 2 console.log('Value of foo in scope', foo) // 2 &#125; console.log('foo is out of block scope', foo) // 1 return foo&#125;console.log(printFoo(false)) // 1console.log(printFoo(true)) // 1 Điểm khác biệt giữa let và const là với const, bạn không thể gán giá trị mới cho biến sau khi khai báo, trong khi điều này lại có thể với let. 123456let foo = 2foo = 3console.log(foo) // 3const baz = 2baz = 3 // Error: Assignment to constant variable. const mang ý nghĩa “constant” chứ không phải “immutability”. Nghĩa là với các biến là object hay array, bạn vẫn có thể thay đổi giá trị bên trong của chúng. 123456789101112const obj = &#123; foo: 2 &#125;obj.foo = 5obj.bar = 3console.log(obj) // &#123; foo: 5, bar: 3 &#125;const arr = [1]arr.push(2)console.log(arr) // [1, 2]// Tuy vậy bạn không thể gán một đối tượng khác cho obj/arrobj = &#123; baz: 4 &#125; // Error: Assignment to constant variable.arr = [] // Error: Assignment to constant variable. Tính tương thích: Được hỗ trợ trên tất cả trình duyệt, kể cả IE11.Lời khuyên: Dùng const cho tất cả khai báo biến vì nó sẽ giúp bạn hạn chế trường hợp “vô tình” thay đổi giá trị của biến. Chỉ dùng let trong trường hợp bất khả kháng, và tránh xa var. 2. Hàm mũi tênHàm mũi tên – (fat) arrow functions – là một kiểu cú pháp rút gọn cho khai báo hàm trong JavaScript. Trước ES6, bạn khai báo một hàm trong JavaScript với từ khóa function. 12345678function add(x, y) &#123; return x + y&#125;// Hàm add() ở trên là syntactic sugar cho...var add = function(x, y) &#123; return x + y&#125; “Syntactic sugar” là cú pháp làm cho ngôn ngữ trở nên dễ đọc và dễ hiểu hơn, theo kiểu nó làm cho ngôn ngữ “ngọt ngào hơn” (sweeter) với lập trình viên. Với hàm mũi tên trong ES6, bạn có thể viết lại thành: 1234567const add = (x, y) =&gt; &#123; return x + y&#125;// Bạn cũng có thể viết dưới dạng biểu thức (expression), hàm mũi// tên sẽ tự động trả giá trị về (auto-return).const add = (x, y) =&gt; x + y Hàm mũi tên cũng hữu dụng để giải quyết vấn đề muôn thuở trong JavaScript: “which this is this?” – khái niệm con trỏ this. Với ES5, bạn hay gặp trường hợp giống như thế này: 123456789'use strict'function App() &#123; this.count = 0 setInterval(function() &#123; console.log(this.count++) &#125;, 1000)&#125;var a = new App() Trước ES6, mỗi khai báo hàm đều có một giá trị this tách biệt. Điều này làm cho đoạn code ở trên không hoạt động, vì this.count bên trong hàm của setInterval mang giá trị undefined. Cách giải quyết thông thường là đặt một biến self, that hay _this để giữ reference, hoặc sử dụng Function.prototype.bind. 123456789101112131415161718function App() &#123; this.count = 0 var self = this setInterval(function() &#123; console.log(self.count++) &#125;, 1000)&#125;// hoặcfunction App() &#123; this.count = 0 function counter() &#123; console.log(this.count++) &#125; setInterval(counter.bind(this), 1000)&#125; Với hàm mũi tên trong ES6, giá trị của this chính là this trong tầm vực gần nhất với nó (lexical this). Do đó chúng ta không cần phải khai báo biến tạm hay dùng .bind nữa. 12345function App() &#123; this.count = 0 setInterval(() =&gt; console.log(this.count++), 1000)&#125; Hàm mũi tên cũng rất hữu ích khi thao tác trên mảng và tiến hành chuyển đổi dữ liệu, giúp mã nguồn dễ đọc và rõ ràng hơn. 1const subtotal = products.filter(product =&gt; product.price &gt; 500).reduce((acc, product) =&gt; acc + product.price, 0) Tính tương thích: Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ.Lời khuyên: Nếu có dùng đến this thì hàm mũi tên rất hữu dụng. Trường hợp không dùng thì…cũng hữu dụng luôn vì mã nguồn gọn gàng dễ đọc hơn. Với những trường hợp bạn muốn bao đóng giá trị của this chỉ gói gọn trong hàm của nó, dùng function. 3. Chuỗi bản mẫuChuỗi bản mẫu (template strings) là chuỗi chân phương (string literals) nhưng cho phép đính kèm biểu thức. Nó cũng cho phép khai báo chuỗi trên nhiều dòng. Để sử dụng, bạn dùng ký tự backtick ` (dấu huyền). Ví dụ như là: 1234const name = 'John'const greetings = `Hello $&#123;name&#125;,The result of 1 + 1 is $&#123;1 + 1&#125;, and the time is now $&#123;Date.now()&#125;.` Vì chuỗi bản mẫu cũng chỉ là chuỗi nên bạn có thể gọi đến những phương thức của String.prototype. 1;`Hello World`.substr(0, 5).toUpperCase() Tính tương thích: Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ.Lời khuyên: Dùng chuỗi bản mẫu khi bạn cần gắn biểu thức hay chuỗi có nội dung ở nhiều dòng. Còn lại thì vẫn dùng chuỗi bình thường với ‘ hay “. 4. Object chân phương (object literals)Object chân phương (object literals) chỉ đơn giản là khai báo một object trong JavaScript như bạn đã làm bao năm nay. 12345678var birthYear = 2000var obj = &#123; name: 'John', birthYear: birthYear, getAge: function(currentYear) &#123; return currentYear - obj.birthYear &#125;&#125; ES6 nâng cấp object chân phương, cho phép bạn khai báo tắt thuộc tính của object với biến cùng tên, và khai báo phương thức cho object. 123456789const birthYear = 2000const obj = &#123; name: 'John', birthYear, // khai báo tắt birthYear: birthYear getAge(currentYear) &#123; // `this` được gán trực tiếp vào bản thân object return currentYear - this.birthYear &#125;&#125; Một lưu ý với this là khi bạn dùng hàm mũi tên, this sẽ được lấy từ this trong tầm vực gần với nó nhất, chứ không trỏ đến đối tượng hiện tại. Do đó… 123&#123; getAge: currentYear =&gt; currentYear - this.birthYear&#125; …sẽ không chạy như mong muốn, vì có thể this.birthYear mang giá trị undefined. Để sử dụng hàm mũi tên bạn phải viết lại như trước ES6. 123&#123; getAge: currentYear =&gt; currentYear - obj.birthYear&#125; Ngoài ra từ ES6 bạn cũng có thể khai báo thuộc tính cho object một cách linh động bằng cách sử dụng cú pháp []. 1234const attr = 'foo'const year = 2017const obj = &#123; [attr]: 1, ['now' + year]: 'wow' &#125;console.log(obj) // &#123; foo: 1, now2017: 'wow' &#125; Tính tương thích: Được hỗ trợ bởi tất cả trình duyệtLời khuyên: Tính năng khai báo tắt thuộc tính của object cực ký hữu dụng =&gt; nên dùng. Nếu không bận tâm đến this thì bạn có thể dùng hàm mũi tên khi khai báo phương thức cho object để mã nguồn gọn gàng sạch đẹp hơn. 5. Phân rã biếnPhân rã biến – destructuring – theo mình là tính năng tiện dụng nhất của ES6. Tính năng này giúp bạn tách biến từ thuộc tính của đối tượng hay phần tử trong các đối tượng có thể duyệt với for, như mảng hoặc chuỗi. Chẳng hạn như: 1234567891011const user = &#123; name: 'John', age: 21 &#125;const &#123; name &#125; = userconsole.log(name) // 'John'const arr = [1, 2, 3]const [first, second] = arrconsole.log(first, second) // 1, 2const str = 'Hello'const [first, second] = strconsole.log(first, second) // 'H', 'e' Bạn cũng có thể phân rã các thuộc tính lồng nhau. 12345678910const userList = [ &#123; name: 'John', age: 21, products: [&#123; name: 'Creamy Crustacean Omelette', price: 1200 &#125;, &#123; name: 'Galdin Gratin', price: 2300 &#125;] &#125;]const [&#123; products: [&#123; price &#125;] &#125;] = userListconsole.log(price) // 1200 Với mảng hay chuỗi, bạn có thể bỏ qua phần tử không mong muốn khi phân rã. 1234567const arr = [1, 2, 3]const [first, , third] = arrconsole.log(first, third) // 1, 3const str = 'Hello'const [fst, , , , lst] = strconsole.log(fst, lst) // 'H', 'o' Phân rã biến cũng rất thường gặp khi bạn sử dụng ES6 module. 12import &#123; Component &#125; from 'react'import &#123; render &#125; from 'react-dom' Tính tương thích: Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ. 6. Rest và spreadRest – phần còn lại – là một bổ sung của phân rã biến mảng ở trên. Bạn dùng ba dấu chấm … để biểu thị rest. 123456const [first, second, ...others] = [1, 2, 3, 4, 5]console.log(first, second, others)// 1// 2// [3, 4, 5] Rest cũng được dùng khi khai báo hàm có thể nhận nhiều tham số 1234const foo = (...args) =&gt; console.log('You passed', args)console.log(foo(1, 2, 3)) // You passed[ 1, 2, 3 ]const bar = (x, y, ...rest) =&gt; console.log(rest, x, y) Bạn lưu ý biến args ở trên khác với biến đặc biệt arguments vốn có sẵn bên trong hàm. arguments là một đối tượng giống Array, với những thuộc tính đặc biệt như callee, trong khi args chỉ là một mảng bình thường. Spread – rải – là thao tác ngược lại với rest, giúp bạn kết hợp một mảng đã có sẵn thành mảng mới. 123const arr = [3, 4, 5]const newArr = [1, 2, ...arr, 6]console.log(newArr) // [1, 2, 3, 4, 5, 6] Spread rất hữu ích để thay thế các thao tác thên mảng, như .concat(). 123const head = [1, 2]const tail = [3, 4, 5]console.log([...head, ...tail]) // [1, 2, 3, 4, 5] Spread cũng rất ngon khi thay thế cho Function.prototype.apply. 123456const mul = (x, y, z) =&gt; x * y * zconst params = [1, 2, 3]// Thay thế cho// mul.prototype.apply(null, params)mul(...params) Rest/spread cũng có thể hoạt động trên object, tương tự như Object.assign(), nhưng bạn lưu ý tính năng vẫn đang được đề xuất (proposal). Về phía trình duyệt, có Firefox và Chrome là hỗ trợ, trong khi Edge và Safari hoàn toàn không hoạt động. 123456789101112const user = &#123; name: 'John' &#125;// ES5const userWithAgeEs5 = Object.assign(&#123;&#125;, user, &#123; age: 21 &#125;)// Thời đại mới với spreadconst userWithAge = &#123; ...user, age: 21 &#125;console.log(userWithAge) // &#123; name: 'John', age: 21 &#125;// Và restconst &#123; name, ...others &#125; = userWithAgeconsole.log(others) // &#123; age: 21 &#125; Tính tương thích: Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ rest và spread với mảng hay chuỗi. Với spread object, Edge và Safari chưa hỗ trợ. 7. Giá trị mặc định cho tham sốKhi khai báo hàm, tính năng này cho phép bạn thiết lập giá trị mặc định của tham số khi nó không được truyền giá trị hoặc có giá trị undefined. 123function getDiscountedPrice(price, discountRate = 0.1) &#123; return price * (1 + discountRate)&#125; Dĩ nhiên bạn có thể dùng bất cứ giá trị nào làm giá trị mặc định. 1234567function processItems(items = []) &#123; return items.map(transformItemData)&#125;// hoặc dùng biếnconst DISCOUNT_RATE = 0.1const getDiscountedPrice = (price, discountRate = DISCOUNT_RATE) =&gt; price * (1 + discountRate) 8. Lớp (class)Với ES5, chúng ta sử dụng function để tạo lớp và thêm các phương thức vào lớp bằng cách mở rộng prototype. 12345678910function Foo(x) &#123; this.x = x&#125;Foo.prototype.add = function(y) &#123; return this.x + y&#125;var f = new Foo(3)console.log(f.add(2)) // 5 ES6 mang đến cú pháp mới giúp tạo lớp trực tiếp và dễ dàng hơn. 123456789101112131415161718class Foo &#123; constructor(x) &#123; this.x = x &#125; add(y) &#123; return this.x + y &#125; // Khai báo phương thức tĩnh (static method) static whoAmI() &#123; return 'I am a Foo class' &#125;&#125;const f = new Foo(3)console.log(f.add(2)) // 5console.log(Foo.whoAmI()) // I am a Foo class Bạn cũng có thể kế thừa từ lớp khác bằng từ khóa extends. 1234567891011121314class Bar extends Foo &#123; constructor(x, y) &#123; // Gọi đến hàm dựng của lớp cha super(x) this.y = y &#125; calculate() &#123; return this.add(4) + this.y &#125;&#125;const f = new Bar(3, 4)console.log(f.calculate()) // 11 Ngoài ra với bạn cũng có thể dùng hàm mũi tên khi khai báo phương thức trong lớp. Điều này giúp đảm bảo this luôn trỏ đến đối tượng hiện tại. Cú pháp này đặc biệt thông dụng trong các ứng dụng React, tuy nhiên vẫn chưa được hỗ trợ mặc định bởi các trình duyệt, nên bạn phải dùng Babel để chuyển đổi mã nguồn. 12345678910111213class Button extends React.Component &#123; state = &#123; name: 'Fabulous button' &#125; doClick = e =&gt; &#123; e.preventDefault() // 'You clicked Fabulous button' console.log(`You clicked $&#123;this.state.name&#125;`) &#125; render = () =&gt; &#123; return &lt;button onClick=&#123;this.doClick&#125; /&gt; &#125;&#125; Tính tương thích: Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ lớp căn bản. 9. PromiseNếu bạn chưa biết Promise là gì thì click vào đây. Vì Promise đã được công nhận như một phần của đặc tả ECMAScript 6 nên các trình duyệt có nghĩa vụ phải hỗ trợ mặc định. So với những thư viện chuyên biệt như bluebird hay q thì phiên bản mặc định có ít tính năng hơn, nhưng cũng vừa đủ để dùng. Quan trọng là không cần thư viện thứ ba. 1234567891011121314const showUser = user =&gt; console.log(`Your name is $&#123;user.name&#125;`)const getUserData = userId =&gt; new Promise((resolve, reject) =&gt; &#123; return RemoteApi.get(`/users/$&#123;userId&#125;`, (err, response) =&gt; &#123; if (err) return reject(err) resolve(response) &#125;) &#125;)getUserData(123) .then(response =&gt; response.data) .then(showUser) .catch(err =&gt; console.error('Oh no', err)) Promise còn có các hàm tĩnh khác: Promise.all(iterator)Nhận vào một mảng các promises và chỉ resolve khi tất cả promises trong mảng được resolve. Promise.race(iterator)Nhận vào một mảng các promises và resolve/reject ngay khi một trong các promises trong mảng resolve/reject. Promise.resolve()Trả về một promise được tự động resolve. Promise.reject()Trả về một promise được tự động reject. Tính tương thích: Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ. KếtES6 mang đến những tính năng tuyệt vời cho lập trình viên, giúp cho làm việc với JavaScript trở nên dễ thở hơn, đồng thời nâng cao hiệu suất, cải thiện mã nguồn và giảm dung lượng tập tin khi truyền tải trên mạng. Nếu ứng dụng của bạn hướng đến các trình duyệt hiện đại, đừng chần chờ gì, hãy dùng ES6 ngay hôm nay.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Chi phí của Javascript","slug":"Chi-phi-cua-Javascript","date":"2018-07-07T08:01:00.000Z","updated":"2018-07-08T09:31:29.960Z","comments":true,"path":"2018/07/Chi-phi-cua-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Chi-phi-cua-Javascript.html","excerpt":"Khi các website chúng ta xây dựng ngày càng phụ thuộc vào JavaScript, thỉnh thoảng chúng ta cũng phải trả giá cho những gì được gửi về phía người dùng, theo những cách không dễ nhìn thấy . Trong bài viết này, tôi sẽ nói về lý do tại sao một chút kỷ luật có thể giúp nếu bạn muốn website của mình có thể tải và phản ứng một cách nhanh chóng trên các thiết bị di động.","text":"Khi các website chúng ta xây dựng ngày càng phụ thuộc vào JavaScript, thỉnh thoảng chúng ta cũng phải trả giá cho những gì được gửi về phía người dùng, theo những cách không dễ nhìn thấy . Trong bài viết này, tôi sẽ nói về lý do tại sao một chút kỷ luật có thể giúp nếu bạn muốn website của mình có thể tải và phản ứng một cách nhanh chóng trên các thiết bị di động. tl;dr: less code = less parse/compile + less transfer + less to decompress Dài quá ngại đọc: ít mã lệnh = ít thời gian phân tách/biên dịch + ít dung lượng trao đổi + ít phải giải nén 1. Kết nối mạngKhi nghĩ về chi phí cho JavaScript, hầu hết các lập trình viên nghĩ về mặt chi phí tải và thực thi mã lệnh. Kết nối Internet của người dùng càng chậm thì gửi nhiều bytes JavaScript về phía họ càng lâu. Điều này cũng có thể là một vấn đề với cả những nước đã phát triển, vì kết nối mạng đang sử dụng của một người dùng có thể không thật sự là 3G, 4G hay WiFi. Bạn có thể đang vào mạng WiFi của một quán cà phê, nhưng đang kết nối với một hotspot di động với tốc độ 2G. Bạn có thể giảm chi phí truyền tải JavaScript bằng cách: Chỉ chuyển đến người dùng phần mã lệnh cần thiết. Kỹ thuật chia mã (code-splitting) có thể hữu ích ở đây. Tối giản hóa mã lệnh (sử dụng Uglify cho ES5, babel-minify hay uglify-es cho ES2015) Nén mã lệnh tới mức tối đa, bằng cách dùng Brotli ~ q11, Zopfli hay gzip. Brotli hoàn toàn qua mặt gzip khi xét về tỉ lệ nén. Giải thuật này đã giúp cho CertSimple giảm 17% dung lượng nén tập tin JS, và LinkedIn tiết kiệm 4% thời gian tải. Xóa mã lệnh không dùng tới. Với DevTools code coverage, bạn có thể nhận dạng phần mã nào không được thực thi. Để loại bỏ mã nguồn không cần thiết, bạn có thể sử dụng kỹ thuật “rung cây” (tree-shaking) của Webpack, các kỹ thuật tối ưu hóa nâng cao của Closure Compiler, và các plugin hỗ trợ tỉa tót mã lệnh như lodash-babel-plugin hay ContextReplacementPlugin của Webpack dành cho các thư viện như moment.js. Sử dụng babel-preset-env và browserlist để tránh tình trạng chuyển đổi những tính năng ES2015 đã được hỗ trợ mặc định trong các trình duyệt. Những lập trình viên nhiều kinh nghiệm có thể phân tích các bản đóng gói (bundles) của Webpack và tìm cách bỏ đi những thư viện phụ thuộc không cần thiết. Lưu bộ đệm để giảm tải các yêu cầu mạng. Xác định thời gian sống tối ưu cho các tập tin JS (max-age) và cung cấp các token thẩm định (ETag) để tránh phải truyền tải những bytes không cần thiết. Lưu bộ đệm bằng Service Worker có thể giúp ứng dụng của bạn trở nên chủ động hơn trong trường hợp mất kết nối, đồng thời cho phép bạn truy xuất đến những tính năng đặc biệt, chẳng hạn như bộ đệm lưu trữ mã trong V8. Hãy tìm hiểu về lưu đệm dài hạn với kỹ thuật băm tên tập tin (filename hashing). 2. Phân tách/Biên dịchSau khi đã tải, một trong những chi phí JavaScript nặng nề nhất là thời gian để một trình xử lý JS tiến hành phân tách/biên dịch mã nguồn. Trong Chrome DevTools, phân tách và biên dịch là những phần trong thời gian “Scripting” màu vàng, có thể thấy trong bảng Performance. Phần Bottom-Up/Call Tree cho phép xem chính xác thời gian phân tách và biên dịch mã: Trong bản Performance của Chrome DevTools, tìm đến phần Bottom-Up. Khi Runtime Call Stats trong V8 được kích hoạt, chúng ta có thể thấy thời gian cần thiết của những tiến trình như Phân Tách và Biên Dịch Nhưng mà, tại sao điều này lại quan trọng? Mất nhiều thời gian để phân tách/biên dịch mã nguồn có thể làm chậm đi đáng kể thời gian người dùng có thể tương tác với website. Bạn càng gửi xuống nhiều tập tin JavaScript, trình duyệt càng tốn thời gian để phân tách và biên dịch trước khi website của bạn có thể tương tác được. Ăn byte nào trả byte đó, JavaScript ngày càng trở nên đắt đỏ cho trình duyệt để xử lý hơn là một bức hình hay web font có cùng dung lượng tương ứng – Tom Dale - tác giả của Ember.js So với JavaScript, cũng có nhiều chi phí tham gia vào quá trình xử lý một bức ảnh có dung lượng tương tự (chúng vẫn cần phải được giải mã!) nhưng đối với phần cứng của thiết bị di động trung bình, có vẻ như tác động của JS có phần tiêu cực hơn đến khả năng tương tác của website. Các byte của JavaScript và hình ảnh cần đến những chi phí rất khác nhau. Hình ảnh thường không chặn luồng chính (main thread) hay ngăn cản tương tác với các giao diện trong quá trình giải mã và hiển thị lên màn hình (rasterization). Ngược lại JS có thể làm chậm quá trình tương tác vì các chi phí phân tách, biên dịch và thực thi. Khi chúng ta nói về phân tách và biên dịch bị chậm, ngữ cảnh rất quan trọng – vì ở đây chúng ta đang nói về những chiếc điện thoại ở phân khúc trung bình. Người dùng bình dân có thể dùng những thiết bị với CPUs và GPUs chậm chạp, hoàn toàn không có bộ đệm L2/L3 và thậm chí còn bị giới hạn bộ nhớ. Năng lực mạng và năng lực của thiết bị thường không đi chung với nhau. Một người dùng sử dụng kết nối Fiber siêu tốc không nhất thiết phải có CPU tốt nhất để phân tách và thực thi JavaScript được gửi đến. Điều ngược lại cũng chính xác…kết nối cùi mía, nhưng CPU lại nhanh như điện. – Kristofer Baxter, LinkedIn. Trong bài JavaScript Start-up Performance, tôi có lưu ý về chi phí phân tách một tập tin JavaScript (đơn giản) đã được giải nén có dung lượng khoảng 1MB trên phần cứng bình dân và cao cấp. Thời gian phân tách/biên tịch mã lệnh giữa chiếc điện thoại nhanh nhất với chiếc điện thoại trung bình khác nhau từ 2 đến 5 lần. Thời gian phân tách một bản đóng gói JavaScript có dung lượng 1MB (~250KB gzipped) giữa các thiết bị máy tính cá nhân và di động thuộc nhiều dòng khác nhau. Khi nhìn vào chi phí cho việc phân tách, chúng ta phải xem xét khi tập tin đã được giải nén, chẳng hạn như ~250KB gzipped khi giải nén thì khoảng 1MB. Đối với những trang trong thực tế, như CNN.com thì sao? Trên một chiếc iPhone 8 cao cấp thì mất khoảng 4 giây để phân tách/biên dịch JS trên CNN.com, so với khoảng 13 giây cho một chiếc điện thoại bình dân (Moto G4). Điều này có thể tác động rõ ràng đến khả năng tương tác của người dùng với website. So sánh thời gian phân tách mã nguồn trên chip A11 Bionic của Apple với Snapdragon 617 trên các thiết bị Android bình dân Điều này nêu bật tầm quan trọng của việc kiểm thử ứng dụng trên các phần cứng trung bình (như chiếc Moto G4) thay vì chiếc điện thoại trong túi của bạn. Nói gì thì nói, ngữ cảnh cũng quan trọng: tối ưu hóa cho thiết bị và điều kiện kết nối mà người dùng của bạn có. Các ứng dụng phân tích thống kê (analytics) có thể đưa ra một cái nhìn về dòng thiết bị di động mà người dùng thực tế của bạn đang sử dụng. Thông tin này đem đến cơ hội để hiểu hơn về các điều kiện giới hạn của CPU/GPU trên các thiết bị đó. Mà có thật là chúng ta đang gửi xuống người dùng quá nhiều JavaScript không? Hên xui :) Bằng cách sử dụng HTTP Archive (với khoảng 500K websites) để phân tích hiện trạng JavaScript trên các thiết bị di động, chúng ta có thể thấy rằng 50% website cần đến hơn 14 giây để có thể tương tác. Những trang này bỏ ra đến hơn 4 giây chỉ để phân tách và biên dịch JS. Thời gian để tải và xử lý JS và các tài nguyên khác đóng một vai trò ở đây, và có lẽ không quá ngạc nhiên khi người dùng phải chờ một lúc trước khi cảm giác website đã có thể sử dụng. Rõ ràng chúng ta có thể làm tốt hơn. Loại bỏ những phần JavaScript không quan trọng trong trang có thể giảm thiểu thời gian truyền tải, quá trình phân tách và biên dịch vốn ngốn CPU, và cả việc ngốn bộ nhớ. Nó cũng làm cho website trở nên có thể tương tác được nhanh hơn. 3. Thời gian thực thiChi phí không chỉ nằm ở quá trình phân tách và biên dịch. Quá trình thực thi JavaScript (chạy mã lệnh sau khi đã phân tách/biên dịch) là một trong những thao tác phải xảy ra trong luồng chính. Thời gian thực thi quá lâu có thể làm trì hoãn thời gian người dùng có thể tương tác với website. If script executes for more than 50ms, time-to-interactive is delayed by the entire amount of time it takes to download, compile, and execute the JS — Alex Russell Nếu một đoạn mã phải thực thi trong hơn 50ms, thời gian để tương tác bị trì hoãn bằng nguyên cả thời gian cần thiết để tải, biên dịch và thực thi JS – Alex Russell Để giải quyết vấn đề này, JavaScript tận dụng khả năng chia nhỏ thành từng phần (small chunks) để tránh không khóa hoàn toàn luồng chính. Bạn hãy tìm hiểu để xem có thể giảm thiểu công việc trong quá trình thực thi hay không. 4. Một số khuôn mẫu để giảm thiểu chi phí truyền tải JavaScriptKhi bạn đang tìm cách để giảm thiểu thời gian truyền tải, phân tách và biên dịch JavaScript, có vài khuôn mẫu có thể hữu ích, như kỹ thuật chia nhỏ theo định tuyến (route-based chunking) hay còn gọi là PRPL. PRPL là một kỹ thuật để tối ưu hóa khả năng tương tác trên website bằng cách chia nhỏ mã nguồn và lưu bộ đệm một cách quyết liệt. Hãy xem những tác động nó có thể mang lại. Chúng ta phân tính thời gian tải của những trang web di động thông dụng và các ứng dụng web tăng tiến (Progressive Web Apps – PWAs) bằng cách sử dụng Runtime Call Stats trong V8. Như chúng ta có thể thấy, thời gian phân tách (phần màu cam) chiếm một phần lớn trong tổng thời gian của các website này. Wego, một trang sử dụng PRPL, xoay xở để giữ cho thời gian phân tách ở mức thấp, giúp cho website có thể tương tác nhanh hơn. Những trang còn lại cũng đã thực hiện kỹ thuật chia mã và dự toán hiệu suất (performance budgeting) để giảm chi phí JS. 5. Những chi phí khácJavaScript cũng có thể tác động đến hiệu suất của website theo những hướng khác: Bộ nhớ. Website có thể cảm thấy bị giựt (jank) hay tạm dừng thường xuyên do bộ gom rác (garbage collector - GC) hoạt động. Khi trình duyệt tiến hành thu hồi bộ nhớ, quá trình thực thi JS bị tạm dừng. Do đó khi trình duyệt thu hồi bộ nhớ quá thường xuyên, tiến trình JS cũng bị dừng liên tục hơn chúng ta mong muốn. Lập trình viên cần tránh bị rò rỉ bộ nhớ và tiến trình dừng của GC để website có thể hoạt động ổn định hơn. Trong quá trình chạy, mã JavaScript chạy quá lâu có thể khóa luồng chính, làm cho website trở nên không tương tác được. Bằng cách chia nhỏ công việc ra thành từng phần (sử dụng requestAnimationFrame() hay requestIdleCallback() để phân lịch) có thể giúp giảm thiểu các vấn đề về tương tác. 6. Kỹ thuật Khởi động Tăng tiến (progressive bootstrapping)Nhiều website xem tính ẩn hiện của nội dung trên trang là một chi phí đắt đỏ khi tối ưu hóa tính tương tác. Để có thể thực hiện tiến trình vẽ đầu tiên (first paint) một cách nhanh chóng, lập trình viên thường sử dụng kỹ thuật tạo nội dung trước ở phía server (server-side rendering - SSR), sau đó “nâng cấp” bằng cách gắn các hàm xử lý sự kiện sau khi JavaScript đã được tải về. Nhưng hãy cẩn thận – kỹ thuật này cũng có chi phí riêng của nó. Bạn 1) nhìn chung sẽ gửi xuống một tập tin HTML nặng ký hơn và có thể ảnh hưởng đến tính tương tác của site, hoặc 2) có thể đưa người dùng vào một vùng thung lũng huyền bí (uncanny valley) nơi một nửa trải nghiệm không thật sự có thể tương tác được, cho đến khi JavaScript hoàn tất quá trình xử lý. Kỹ thuật Khởi động Tăng tiến có thể là một hướng tiếp cận tốt hơn. Bạn chỉ cần gửi xuống một trang vừa đủ có thể hoạt động, bao gồm chỉ HTML/JS/CSS cần thiết cho định tuyến hiện tại. Khi các tài nguyên khác đã được tải xong, ứng dụng có thể lazy-load vào và mở ra các chức năng khác. Kỹ thuật tải mã lệnh tương ứng với những gì đang được hiển thị chính là cứu cánh. PRPL và Khởi động Tăng tiến là hai khuôn mẫu giúp đạt được mục tiêu này. Kết luậnKích thước tập tin khi truyền tải rất quan trọng đối với những kết nối mạng cấp thấp. Thời gian phân tách mã nguồn lại quan trọng đối với những thiết bị có giới hạn về CPU. Chúng ta cần phải giữ cho các chỉ số này ở mức thấp. Nhiều nhóm phát triển đã thành công trong việc làm theo các dự toán hiệu suất nghiêm ngặt, để giảm thiểu thời gian truyền tải và phân tách/biên dịch. Bạn có thể xem hướng dẫn “Can You Afford It?: Real-world Web Performance Budgets” của Alex Russell về dự toán hiệu suất cho các thiết bị di động. Nếu bạn đang phát triển một website hướng đến các thiết bị di động, hãy cố gắng hết sức để xây dựng nó trên phần cứng tiêu biểu, giữ cho thời gian phân tách/biên dịch JavaScript ở mức thấp, và thu nhận một dự toán hiệu suất để chắc chắn rằng nhóm của bạn luôn theo sát chi phí JavaScript. Tìm hiểu thêm Bài nói chuyện của tôi ở Chrome Dev Summit 2017 về chi phí cho JavaScript. Phần sau của bài nói có nhắc đến những ví dụ thực tế từ các trang như Pinterest hay Tinder. JavaScript Start-up Performance Solving the web performance crisis — Nolan Lawson Can you afford it? Real-world performance budgets — Alex Russell Evaluating web frameworks and libraries — Kristofer Baxter Kết quả thử nghiệm của Cloudflare cho giải thuật nén Brotli (lưu ý là nén Brotli động ở chất lượng cao có thể làm chậm quá trình hiển thị trang lần đầu tiên nên bạn cần đánh giá một cách thận trọng. Có khi bạn sẽ muốn nén theo phương pháp tĩnh hơn.) Performance Futures — Sam Saccone Chân thành cám ơn Nolan Lawson, Kristofer Baxter và Jeremy Wagner vì những phản hồi của mọi người.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"10 mẹo CSS hữu ích bạn nên biết","slug":"10-meo-CSS-huu-ich-ban-nen-biet","date":"2018-06-27T01:01:00.000Z","updated":"2018-06-27T01:11:20.866Z","comments":true,"path":"2018/06/10-meo-CSS-huu-ich-ban-nen-biet.html","link":"","permalink":"http://nthung2112.github.io/2018/06/10-meo-CSS-huu-ich-ban-nen-biet.html","excerpt":"Pagespeed Optimization (tối ưu hóa tốc độ trang) là một công việc mà hầu như mọi Web developer đều quan tâm và nên biết, mục đích của nó là đưa nội dung website đến với người xem nhanh nhất có thể. Front-end developer thường làm việc với HTML, CSS, Javascript và các hình ảnh. Do đó, đây cũng là các đối tượng chính để chúng ta tối ưu tốc độ tải trang cho website. Tốc độ tải trang của website ngoài các yếu tố liên quan do server thì còn phụ thuộc vào kích thước và số lượng file phải tải về, do đó càng giảm được kích thước file lẫn số lượng file cần phải tải về thì cũng đồng thời tăng tốc độ tải file và giảm số lượng request lên server.","text":"Pagespeed Optimization (tối ưu hóa tốc độ trang) là một công việc mà hầu như mọi Web developer đều quan tâm và nên biết, mục đích của nó là đưa nội dung website đến với người xem nhanh nhất có thể. Front-end developer thường làm việc với HTML, CSS, Javascript và các hình ảnh. Do đó, đây cũng là các đối tượng chính để chúng ta tối ưu tốc độ tải trang cho website. Tốc độ tải trang của website ngoài các yếu tố liên quan do server thì còn phụ thuộc vào kích thước và số lượng file phải tải về, do đó càng giảm được kích thước file lẫn số lượng file cần phải tải về thì cũng đồng thời tăng tốc độ tải file và giảm số lượng request lên server.Ở bài này mình sẽ giới thiệu với các bạn 10 mẹo CSS hữu ích giúp giảm kích thước, số lượng file CSS, tối ưu file CSS và phát triển CSS dễ dàng hơn, nội dung bài gồm những phần sau: Hạn chế sử dụng @import Sử dụng cách viết ngắn gọn (shorthand properties) Khai báo class bổ trợ (Helper classes) Hạn chế sử dụng CSS trong element của HTML (inline CSS attributes in HTML elements) Giảm số lượng file CSS (Combine external CSS) Giảm kích thước file CSS Áp dụng OOCSS (Object Oriented CSS) Đặt tên class và id một cách khoa học Ngôn ngữ tiền xử lý CSS (CSS Preprocessor) Sử dụng Koala-app khi làm việc với CSS 1. Hạn chế sử dụng @importHạn chế sử dụng @import hoặc tốt nhất là không nên sử dụng @import trong file CSS, vì nó sẽ làm chậm quá trình tải và không sử dụng được khả năng tải file đồng thời của browser. Để dễ hiểu bạn hãy xem ví dụ sau: Mình có 2 file CSS là a.css và b.css được nhúng vào trang web như sau: 12&lt;link rel='stylesheet' type='text/css' href='a.css'&gt;&lt;link rel='stylesheet' type='text/css' href='b.css'&gt; Trong file b.css, bạn import file c.css: 1@import url(c.css); Kết quả khi browser tải trang sẽ như thế này: HTML downloada.cssb.cssc.css Chú thích: Request 1: browser gửi request để lấy HTML về Request 2: browser gửi request để lấy a.css Request 3: browser gửi request để lấy b.css Request 4: browser gửi request để lấy c.css Như các bạn thấy ở hình trên, để tải được c.css thì browser phải chờ để tải xong a.css. Lý do: Vì browser khi đã tải xong b.css và bắt đầu đọc nội dung bên trong thì thấy @import yêu cầu phải tải thêm c.css, lúc này browser phải đứng chờ cho nhóm proccess trước đó chạy xong (trong trường hợp này là chờ a.css) thì mới bắt đầu tải tiếp c.css và tiếp tục render sau khi đã tải xong. Trong khi đó nếu bạn loại bỏ @import url(c.css) trong b.css đi và nhúng trực tiếp c.css vào trang HTML 123&lt;link rel='stylesheet' type='text/css' href='a.css'&gt;&lt;link rel='stylesheet' type='text/css' href='b.css'&gt;&lt;link rel='stylesheet' type='text/css' href='c.css'&gt; thì bạn sẽ có kết quả như sau: HTML downloada.cssb.cssc.css Lúc này browser sẽ bắt đầu tải file đồng thời không cần phải chờ cho a.css tải xong, sẽ rút ngắn được thời gian tải file xuống. Như tiêu đề mình nói rằng nên Hạn chế sử dụng @import, vậy một câu hỏi nhỏ đặt ra là khi nào thì nên dùng @import?. Theo mình thì khi những định nghĩa CSS cần lệ thuộc vào một định nghĩa ở file CSS khác trước – thì khi đó nên dùng @import, ví dụ bạn sử dụng các bộ thư viện reset CSS như Normalize.css, bạn cần reset tất cả các định nghĩa CSS về một chuẩn chung trước khi viết định nghĩa CSS tiếp theo – lúc này bạn sẽ dùng @import để import file Normalize.css vào trong file định nghĩa CSS của bạn, lý do sử dụng @import ở đây là để tránh cơ chế tải file đồng thời của browser và bắt buộc browser phải tải và áp định nghĩa CSS của Normalize.css trước rồi mới đến các định nghĩ CSS ở bên dưới @import. Một câu hỏi tiếp theo Nếu nhất thiết phải dùng @import như ví dụ trên, thì các nào khác để giải quyết thay vì dùng @import hay không?. Tất nhiên là có cách, đó là bạn copy toàn bộ nội dung của file Normalize.css vào trong file CSS của bạn, hay còn gọi là Combine external CSS mình sẽ giới thiệu phía bên dưới. 2. Sử dụng cách viết ngắn gọnSử dụng cách viết ngắn gọn (shorthand properties) để dễ dàng thiết lập một số thuộc tính chỉ trên một dòng, đây cũng là một cách để bạn dễ dàng kiểm soát – theo dõi code của mình, đồng thời cũng hỗ trợ giảm số lượng ký tự trong file css và giảm kích thước file. Lấy ví dụ đơn giản về cách thiết lập thuộc tính hình ảnh cho background 12345background-color:#000;background-image:url(bg-image.jpg);background-repeat:no-repeat;background-attachment:fixed;background-position:center center; Bạn có thể viết thành 1background:#000 url(bg-image.jpg) no-repeat fixed center center; Cấu trúc shorthand của thuộc tính background như sau 1background: &lt;color&gt; &lt;image&gt; &lt;repeat&gt; &lt;attachment&gt; &lt;position&gt;; Ngoài background thì còn có một số thuộc tính khác cũng có thể sử dụng shorthand như margin, padding, border, outline, … bạn có thể tham khảo thêm trên Mozilla Developer Network (MDN). Ở cuối trang này có danh sách các thuộc tính có thể áp dụng shorthand. Bên cạnh đó, nếu bạn thích khai báo mã màu HEX thì đối với một số mã màu thông dụng bạn cũng có thể viết ngắn gọn lại ví dụ như #FFF thay cho #FFFFFF hay #000 thay cho #000000. Bạn có thể tham khảo cách chuyển đổi tại CSS Color Converter. 3. Khai báo class bổ trợClass bổ trợ (Helper classes) là những class được định nghĩa sẵn một số thuộc tính đơn giản và thường hay sử dụng. Ví dụ như text-align, font-weight, color… Class bổ trợ trong quá trình viết HTML các bạn chỉ cần thêm class đó vào mà không cần phải định nghĩa lại thuộc tính. Cách làm này khá hữu dụng khi bạn sử dụng một CSS framework và cần custom “rất ít” thuộc tính, hoặc bạn không chọn được tên class phù hợp cho element đó, hay element đó không cần xác định class để làm gì đó với javascript. Điểm lợi của việc này ngoài việc bạn không cần định nghĩa lại một số thuộc tính không cần thiết, thì nếu CSS càng nhiều thì bạn sẽ tiết kiệm được khá nhiều thuộc tính cần khai báo lại và sẽ giảm được kích thước file CSS. Ví dụ: Mình có các element sau cần viết CSS và mình đang dùng framework bootstrap: 12345&lt;p class=\"text-center\"&gt; &lt;button type=\"button\" class=\"btn btn-success btn-md text-uppercase\"&gt; Show More &lt;/button&gt;&lt;/p&gt; Thay vì mình cần phải viết CSS như sau để custom lại theo ý mình 12p &#123; text-align: center; padding-top: 20px; &#125;p &gt; button &#123; background-color: #fff; padding-right: 30px; padding-left: 30px &#125; Thì mình sẽ khai báo class bổ trợ để có thể tái sử dụng cho nhiều trường hợp khác về sau ( Những class có sẵn của bootstrap mình sẽ không liệt kê vào, vì hiện giờ mình cần custom các element này ) 1234.padding-top-20 &#123; padding-top: 20px; &#125;.padding-right-30 &#123; padding-right: 30px; &#125;.padding-left-30 &#123; padding-left: 30px; &#125;.btn.btn-bg-white &#123; background-color: #fff; &#125; Như vậy trong HTML mình sẽ khai báo như sau 123&lt;p class=\"text-center padding-top-20\"&gt; &lt;button type=\"button\" class=\"btn btn-success btn-md btn-bg-white text-uppercase padding-right-30 padding-left-30\"&gt;Show More&lt;/button&gt;&lt;/p&gt; Như vậy thì về sau những class này mình có thể tái sử dụng rất nhiều lần ở rất nhiều element, và mình có thể bỏ đi khá nhiều công đoạn phải gõ lại code CSS khi có phát sinh thêm element mới. Điều này mình học hỏi từ bootstrap và cảm thấy nó khá là hay. Bạn có thể tham khảo thêm các helper class hoặc typography của bootstrap để hiểu rõ hơn. 4. Hạn chế sử dụng Inline CSS trong các elementsỞ đây, mình chỉ khuyên các bạn nên hạn chế sử dụng, vì điều này sẽ làm các bạn khó kiểm soát code CSS của mình. “Vạn bất đắc dĩ” cần giải quyết nhanh (hotfix) thì hãy dùng hoặc nếu chỉ dùng một lần hoặc là CSS động từ javascript thì có thể chấp nhận được. Theo như Google Pagespeed Insights thì việc này sẽ làm code bị lặp lại không cần thiết và vi phạm Chính sách Bảo mật Nội dung của W3, trong một số trường hợp thì các attribute này sẽ bị chặn. 5. Giảm số lượng file CSSGom các file CSS lại với nhau (Combine external CSS) là việc dễ làm nhất, thay vì phải viết thành nhiều file như header.css, navigation.css, footer.css… vào trong văn bản HTML thì bạn hãy gom các file này thành một file duy nhất. Nội dung file này sẽ chứa toàn bộ nội dung của các file trên, như vậy bạn sẽ giảm được nhiều request đến server và giảm tải cho server khá nhiều. Thay vì sử dụng như vầy 123&lt;link rel=\"stylesheet\" href=\"/css/header.css\"&gt;&lt;link rel=\"stylesheet\" href=\"/css/navigation.css\"&gt;&lt;link rel=\"stylesheet\" href=\"/css/footer.css\"&gt; Nên gom chúng lại thành 1&lt;link rel=\"stylesheet\" href=\"/css/style.css\"&gt; 6. Giảm kích thước file CSSGiảm kích thước file CSS được thực hiện bằng cách loại bỏ các khoảng trắng không cần thiết, dấu xuống hàng, dấu chấm phẩy cuối cùng trong class hoặc id… Công đoạn này còn được gọi là minify. Để tiện phân biệt giữa file chưa minify và file đã minify thì bạn nên thêm .min vào tên file đã minify. Ví dụ style.css sau khi minify sẽ thành style.min.css. Bạn có thể truy cập vào Clean CSS để thực hiện minify css hoặc sử dụng tool Koala-app mình sẽ giới thiệu bên dưới để tự động xuất file minify trong quá trình viết code. 7. Áp dụng kỹ thuật OOCSSOOCSS (Object Oriented CSS) – CSS hướng đối tượng, thật ra hướng đối tượng ở đây có nghĩa là bạn gom các thuộc tính giống nhau của 2 class cùng áp dụng cho một element thành một class để giảm thiểu sự lặp lại. Ví dụ: Thay vì khai báo 2 class cho button như sau 123456789101112131415161718192021222324252627282930313233.btn-primary &#123; display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; font-weight: 400; line-height: 1.42857143; text-align: center; white-space: nowrap; vertical-align: middle; border: 1px solid transparent; border-radius: 4px; color: #fff; background-color: #337ab7; border-color: #2e6da4;&#125; .btn-success &#123; display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; font-weight: 400; line-height: 1.42857143; text-align: center; white-space: nowrap; vertical-align: middle; border: 1px solid transparent; border-radius: 4px; color: #fff; background-color: #5cb85c; border-color: #5cb85c;&#125; Mình sẽ gom một số thuộc tính của 2 class này thành một class khác có tên là btn: 12345678910111213141516171819202122232425.btn &#123; display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; font-weight: 400; line-height: 1.42857143; text-align: center; white-space: nowrap; vertical-align: middle; border: 1px solid transparent; border-radius: 4px;&#125; .btn.btn-primary &#123; color: #fff; background-color: #337ab7; border-color: #2e6da4;&#125; .btn.btn-success &#123; color: #fff; background-color: #5cb85c; border-color: #5cb85c;&#125; Như vậy nếu sau này có thay đổi gì về một số thuộc tính chung của 2 class thì mình chỉ cần thay đổi class btn thì sẽ dễ dàng và nhanh hơn. 8. Tổ chức class và id một cách khoa họcViệc này để hỗ trợ bạn sau này khi xem lại code của mình dễ dàng hơn và không bị rối với cách đặt tên của mình, đồng thời cũng dễ dàng nếu có áp dụng một số CSS preprocessor hay BEM. Thay vì đặt tên 12345.titlepost &#123;&#125; .headerpost &#123;&#125; .contentpost &#123;&#125; thì nên đặt thành 1234567.post &#123;&#125; .post-title &#123;&#125; .post-header &#123;&#125; .post-content &#123;&#125; hoặc tổ chức thành 1234567.post &#123;&#125; .post &gt; .title &#123;&#125; .post &gt; .header &#123;&#125; .post &gt; .content &#123;&#125; 9. Ngôn ngữ tiền xử lý CSSTiền xử lý CSS (CSS Preprocessor) – là một cách mở rộng của CSS hoặc cũng có thể coi nó là một ngôn ngữ riêng. Mục đích của CSS preprocessor là để bạn dễ dàng cấu trúc các đoạn code CSS, giảm thời gian phải viết đi viết lại một đoạn code, dễ dàng áp dụng OOCSS… Nói cách khác bạn có thể hiểu CSS preprocessor gần như là một ngôn ngữ lập trình vì nó cũng có biến, kế thừa class, và dễ dàng tạo ra một thư viện riêng cho bạn quản lý, kế thừa và tái sử dụng ở những dự án khác. CSS preprocessor hiện nay có rất nhiều nhưng phổ biến nhất hiện nay là Less và Sass. Ở đây mình giới thiệu các bạn về Sass vì mình đang sử dụng nó thay cho Less, và CSS framework phổ biến – Bootstrap, kể từ phiên bản 4 đã chuyển từ Less qua Sass. Về Sass các bạn xem hướng dẫn cài đặt trên trang chủ. Khi bắt đầu với một dự án có áp dụng Sass, việc đầu tiên mình thường làm là cấu trúc CSS thành nhiều file nhỏ để tránh nhồi nhét CSS vào một file và dễ dàng cho việc quản lý, tìm kiếm khi cần thiết. Mình thường cấu trúc các file Sass như sau: 1234567891011scss|-- style.scss|-- _variable.scss|-- _helper.scss|-- _mixins.scss|-- components|-- -- _header.scss|-- -- _footer.scss|-- mixins|-- -- button.scss|-- -- label.scss Trong file style.scss nội dung như sau: 1234567@import \"variable\";@impprt \"helper\";@import \"mixins\"; // Components@import \"components/header\";@import \"components/footer\"; Chú thích: _variable.scss: variable chứa các thông tin về các biến dùng chung _helper.scss: helper sẽ chứa/import các class helper _mixins.scss: mixins sẽ chứa/import các class custom hoặc class được tái sử dụng nhiều lần Nội dung file _helper.scss như mình đã nói sẽ tạo ra các class helper, nhưng ở đây mình áp dụng tính chất của Scss để tạo ra các class với ít dòng code nhất: 12345678910111213141516171819202122232425$numbersPX: \"10\" 10px, \"15\" 15px, \"20\" 20px, \"25\" 25px, \"30\" 30px; // padding@each $i in $numbersPX&#123; .padding-#&#123;nth($i, 1)&#125; &#123; padding: nth($i, 2) !important; &#125; .padding-top-#&#123;nth($i, 1)&#125; &#123; padding-top: nth($i, 2) !important; &#125; .padding-bottom-#&#123;nth($i, 1)&#125; &#123; padding-bottom: nth($i, 2) !important; &#125; .padding-right-#&#123;nth($i, 1)&#125; &#123; padding-right: nth($i, 2) !important; &#125; .padding-left-#&#123;nth($i, 1)&#125; &#123; padding-left: nth($i, 2) !important; &#125;&#125; khi Sass complier ra file CSS thì mình sẽ thu được kết quả như sau 12345678910111213141516171819202122232425.padding-10 &#123; padding: 10px !important; &#125;.padding-top-10 &#123; padding-top: 10px !important; &#125;.padding-bottom-10 &#123; padding-bottom: 10px !important; &#125;.padding-right-10 &#123; padding-right: 10px !important; &#125;.padding-left-10 &#123; padding-left: 10px !important; &#125;.padding-15 &#123; padding: 15px !important; &#125;.padding-top-15 &#123; padding-top: 15px !important; &#125;.padding-bottom-15 &#123; padding-bottom: 15px !important; &#125;.padding-right-15 &#123; padding-right: 15px !important; &#125;.padding-left-15 &#123; padding-left: 15px !important; &#125;.padding-20 &#123; padding: 20px !important; &#125;.padding-top-20 &#123; padding-top: 20px !important; &#125;.padding-bottom-20 &#123; padding-bottom: 20px !important; &#125;.padding-right-20 &#123; padding-right: 20px !important; &#125;.padding-left-20 &#123; padding-left: 20px !important; &#125;.padding-25 &#123; padding: 25px !important; &#125;.padding-top-25 &#123; padding-top: 25px !important; &#125;.padding-bottom-25 &#123; padding-bottom: 25px !important; &#125;.padding-right-25 &#123; padding-right: 25px !important; &#125;.padding-left-25 &#123; padding-left: 25px !important; &#125;.padding-30 &#123; padding: 30px !important; &#125;.padding-top-30 &#123; padding-top: 30px !important; &#125;.padding-bottom-30 &#123; padding-bottom: 30px !important; &#125;.padding-right-30 &#123; padding-right: 30px !important; &#125;.padding-left-30 &#123; padding-left: 30px !important; &#125; 10. Giới thiệu sơ lược Koala AppKoala app là một ứng dụng GUI hỗ trợ biên dịch Less, Sass, Compass và CoffeeScript sang CSS và JS. Koala App chạy được trên cả 3 môi trường Mac OS, Linux và Windows nên rất tiện nếu bạn cần thay đổi qua lại giữa các hệ điều hành. Ngoài ra, Koala App còn hỗ trợ minify cho cả CSS và JS. Sử dụng Koala App rất đơn giản, bạn chỉ cần mở lên và ấn dấu + trên đầu chương trình để chọn thư mục chứa các file cần xử lý, và Koala App sẽ tự động scan toàn bộ các folder bên trong và theo dõi khi có thay đổi. Nếu bạn “siêng” thì có thể tham khảo cách để tự cấu hình project để Koala-app hoạt động theo ý mình tại đây. Trên đây là những mẹo CSS rút ra từ kinh nghiệm làm việc của mình. Nếu bạn còn những mẹo hay khác thì đừng ngại chia sẻ bên dưới nhé.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"}]},{"title":"Tối ưu hiệu suất render để website mượt hơn","slug":"Toi-uu-hieu-suat-render-de-website-muot-hon","date":"2018-06-26T00:50:00.000Z","updated":"2018-06-27T01:12:25.692Z","comments":true,"path":"2018/06/Toi-uu-hieu-suat-render-de-website-muot-hon.html","link":"","permalink":"http://nthung2112.github.io/2018/06/Toi-uu-hieu-suat-render-de-website-muot-hon.html","excerpt":"Optimizing Performance (tối ưu hóa hiệu suất) cho website là một công việc mà bất kỳ front-end developer nào cũng nên biết, mục đích là để trang web đáp ứng được 3 tiêu chí: NHẸ: Giảm kích thước trang web và các thành phần đi kèm như javascript, css, hình ảnh… nhằm đảm bảo thời gian tải xuống ngắn hơn. Chúng ta có thể dùng các bộ minify cho javascript, css…, nén các tập tin hình ảnh, font chữ, svg… ngoài ra còn có các kĩ thuật như code splitting, browser caching, HTTP caching… NHANH Hiển thị nội dung trang web càng sớm càng tốt bằng cách: chia cấu trúc DOM hợp lý, hạn chế blocking CSS/JS, hạn chế chỉnh sửa DOM tree, chia các file ra thành nhiều module, tải resource bất đồng bộ, tối ưu hóa các selector của CSS và JS… MƯỢT: Sau khi nội dung trang web đã được tải về và hiển thị thì việc tiếp theo là bảo đảm các hiệu ứng animation, transition, scrolling… phải mượt, không bị lag và giật (jank).","text":"Optimizing Performance (tối ưu hóa hiệu suất) cho website là một công việc mà bất kỳ front-end developer nào cũng nên biết, mục đích là để trang web đáp ứng được 3 tiêu chí: NHẸ: Giảm kích thước trang web và các thành phần đi kèm như javascript, css, hình ảnh… nhằm đảm bảo thời gian tải xuống ngắn hơn. Chúng ta có thể dùng các bộ minify cho javascript, css…, nén các tập tin hình ảnh, font chữ, svg… ngoài ra còn có các kĩ thuật như code splitting, browser caching, HTTP caching… NHANH Hiển thị nội dung trang web càng sớm càng tốt bằng cách: chia cấu trúc DOM hợp lý, hạn chế blocking CSS/JS, hạn chế chỉnh sửa DOM tree, chia các file ra thành nhiều module, tải resource bất đồng bộ, tối ưu hóa các selector của CSS và JS… MƯỢT: Sau khi nội dung trang web đã được tải về và hiển thị thì việc tiếp theo là bảo đảm các hiệu ứng animation, transition, scrolling… phải mượt, không bị lag và giật (jank). Trong 3 tiêu chí này, có 2 tiêu chí mà front-end developer chúng ta hằng ngày đều thực hiện là nhẹ và nhanh. Bằng cách sử dụng các framework (angularjs, reactjs…) và các bộ build tool (grunt, gulp, webpack…), các resource trong project ở môi trường production lúc nào cũng được minify và đóng gói đầy đủ, gọn gàng. Do đó, trong bài này tôi sẽ hướng dẫn cho bạn cách đáp ứng được tiêu chí thứ 3, đó là MƯỢT, thứ mà ít có framework hay công cụ nào có thể hỗ trợ bạn được. Trên thực tế, các web page yêu cầu độ mượt cao thường là các webpage có nhiều hiệu ứng, chuyển động, ví dụ như các trang landing page, giới thiệu sản phẩm, HTML5 game, hoặc các ứng dụng có animation chạy trên các thiết bị có cấu hình thấp. Bạn có thể xem qua một số trang sau: http://world.mathigon.org/ http://matthew.wagerfield.com/parallax/ Làm thế nào để web page “mượt”?Mượt ở đây chính là “Rendering Performance”, để tối ưu hiệu suất render chúng ta phải hiểu được quá trình render của browser. 60… là số khung hình trên một giây mà các thiết bị phổ biến hiện nay hỗ trợ (60fps). Để cho trang web mượt thì tốc độ render phải đáp ứng được con số này. Tức là trong 1 giây chúng ta phải cho ra 60 khung hình. Với mỗi khung hình, chúng ta có 1 / 60 = 16,66 mili giây. Trên thực tế, browser còn có một số tác vụ khác phải làm bên cạnh việc render, vì thế chúng ta trừ hao còn lại khoảng 16ms. Bất cứ animation hay transition nào, muốn đảm bảo được tốc độ 60fps thì phải cũng phải đảm bảo trong vòng 16ms phải render được một khung hình, nếu không thì sẽ bị hiện tượng “frame skip”, hiệu ứng sẽ bị giật, lag. Cần phải làm những gì trong 16ms đó?Để cho ra được 1 khung hình, đây là các việc mà browser phải thực hiện (the pixel pipeline): Giải thích ngắn gọn: 1. JavaScript: là hoạt động execute code của javascript. 1document.getElementById('my-element').style.width = '300px'; 2. Style calculation: tính toán các thuộc tính theo các quy tắc từ file CSS (hoặc thẻ &lt;style&gt;, thuộc tính style). 1&lt;div id='my-element' style='width: 300px'&gt;Hello&lt;/div&gt; 3. Layout: browser thực hiện “chia vùng” cho các element khi hiển thị trên màn hình, dựa trên các thuộc tính đã tính toán được từ bước Style. 4. Paint: tô màu cho từng pixel, bao gồm việc: vẽ chữ (render font), hình ảnh, màu, vẽ các hiệu ứng CSS như border, box-shadow… Việc tô màu này được thực hiện trên nhiều “layer” cùng một lúc (phần sau sẽ giải thích rõ hơn về layer). Đây là bước chiếm nhiều thời gian nhất. 5. Composite: gộp các layer đã được vẽ (ở bước Paint) và hiển thị lên màn hình theo đúng thứ tự của các layer đó. Như vậy, chỉ với 16ms browser phải thực hiện 5 bước như trên để có thể render ra được 1 khung hình. Vậy để đảm bảo mọi thứ đều hoàn thành dưới 16ms, việc chúng ta cần làm là tối ưu từng bước. Cụ thể là: JavaScript: Dùng requestAnimationFrame. Dùng Web workers, Micro-task cho các tác vụ nặng. Profiling with Chrome DevTools. Style: Giảm độ phức tạp của selector Giảm số lượng element bị ảnh hưởng Layout: Hạn chế kích hoạt layout Sử dụng Flexbox Hạn chế forced synchronous layout. Paint: Paint là tác vụ xử lý lâu nhất Box-shadow, large image không tốt cho paint Tạo và quản lý layer hợp lý Composite: Sử dụng transform và opacity Quản lý các layer bằng Chrome DevTools Từng bước tối ưu hiệu suất renderBước 1: Javascript1.1. Sử dụng requestAnimationFrame để thực hiện các thay đổi trên UI.Khi thực hiện các thay đổi trên UI bằng JavaScript, bạn sẽ muốn thực hiện nó ngay vào lúc bắt đầu của frame, lúc đó browser sẽ có được toàn bộ 16ms để thực hiện các thay đổi (JavaScript ⇒ Style ⇒ Layout ⇒ Paint ⇒ Composite). Để làm được điều này bạn cần dùng hàm requestAnimationFrame. Hàm này có chức năng “hẹn giờ” chạy vào đúng thời điểm của frame tiếp theo. 12345678/** * If run as a requestAnimationFrame callback, this * will be run at the start of the frame. */function updateScreen(time) &#123; // Make visual updates here.&#125;requestAnimationFrame(updateScreen); Một số đoạn code trên mạng hoặc trong các framework thường sử dụng hàm setTimeout, tuy nhiên hàm được gọi bởi setTimeout sẽ không khởi chạy lúc bắt đầu frame, dẫn đến việc không tận dụng hết được khoảng thời gian 16ms, do đó gây ra hiện tượng frame skip, gây giật, lag. 1.2. Chuyển các tác vụ nặng sang Web workersĐối với các tác vụ nặng như encode/decode, xử lý dữ liệu lớn… chúng ta nên chuyển tác vụ đó sang Web Workers. Web Workers hoạt động trên một thread riêng biệt, sẽ giúp giảm tải cho UI Thread và giúp tiết kiệm được thời gian xử lý. 123456789var dataSortWorker = new Worker(\"sort-worker.js\");dataSortWorker.postMesssage(dataToSort); // The main thread is now free to continue working on other things... dataSortWorker.addEventListener('message', function(evt) &#123; var sortedData = evt.data; // Update data on screen...&#125;); Tuy nhiên, Web Workers không thể tương tác với DOM tree, do đó một số tác vụ không thể chuyển qua Web Workers được. Trong trường hợp này ta có thể áp dụng phương pháp “micro-task”: chia nhỏ task ra, sau đó sử dụng requestAnimationFrame để cập nhật UI. Lúc này, nếu mỗi task nhỏ có thời gian thực thi bé hơn 16ms thì sẽ tránh được hiện tượng giật, lag như khi chạy cả task lớn. 123456789101112131415161718192021var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);requestAnimationFrame(processTaskList); function processTaskList(taskStartTime) &#123; var taskFinishTime; do &#123; // Assume the next task is pushed onto a stack. var nextTask = taskList.pop(); // Process nextTask. processTask(nextTask); // Go again if there’s enough time to do the next task. taskFinishTime = window.performance.now(); &#125; while (taskFinishTime - taskStartTime &lt; 3); if (taskList.length &gt; 0) requestAnimationFrame(processTaskList); &#125; 1.3. Sử dụng Chrome DevTools để “điều tra” JavaScript executionChrome DevTools là công cụ cực kỳ hữu ích. Ở tab “Timeline” của Chrome DevTools, bạn có thể kiểm tra được độ mượt của web page bằng cách: Nhấn nút Record (hoặc Ctrl + R trên Windows, Command + R trên Mac) Thực hiện animation / transition trên trang web chính Nhấn nút Stop Record. Chrome DevTools sẽ hiển thị toàn bộ các thông tin liên quan đến các tác vụ JavaScript ⇒ Style ⇒ Layout ⇒ Paint ⇒ Composite. Bạn có thể kiếm tra để xem tác vụ nào chiếm nhiều thời gian nhất và gây ra frame skip. Bước 2: Style calculationCố gắng giữ cho selector của bạn càng đơn giản càng tốt, và giảm số lượng element bị ảnh hưởng bởi selector, ví dụ: Nên: 1.title &#123; /* styles */ &#125; Không nên: 1.box:nth-last-child(-n+1) .title &#123; /* styles */ &#125; Không nên: 1*, *:before, *:after &#123; /* styles */ &#125; Nên: 1body &#123; /* styles */ &#125; Việc sử dụng các selector này cần phải cân bằng giữa việc code gọn gàng đẹp đẽ và hiệu suất. Khi sử dụng các selector phức tạp thì browser cần phải thực hiện nhiều tính toán, nhưng nếu chỉ sử dụng các selector đơn giản thì lại khiến code của chúng ta khó quản lý. Giải pháp ở đây là chúng ta nên sử dụng một số kỹ thuật quản lý style như: BEM (Block, Element, Modifier), PostCSS. Các công cụ này sẽ giúp chúng ta vừa dễ quản lý code CSS ở môi trường dev, và cũng vừa đảm bảo hiệu suất ở môi trường production sau khi build. Bước 3: Layout3.1. Hạn chế kích hoạt tính toán layoutViệc thay đổi một số thuộc tính CSS của element có thể kích hoạt browser tính toán lại layout của element đó. 12345678910111213.box &#123; width: 20px; height: 20px;&#125; /** * Changing width and height * triggers layout. */.box--expanded &#123; width: 200px; height: 350px;&#125; Khi một element bị thay đổi layout thì thường là các element khác cũng sẽ bị thay đổi theo (kích thước, vị trí…). Do đó nếu trang của bạn có nhiều element và việc kích hoạt layout diễn ra quá thường xuyên thì hoàn toàn không tốt cho performance. Bạn có thể sử dụng Chrome DevTools để kiểm tra xem web page của bạn có bị kích hoạt layout quá nhiều hay không. Ví dụ trong hình này, bạn có thể thấy sự kiện Layout chiếm tới 20.636ms, vượt qua con số 16ms và tất nhiên là sẽ dẫn đến frame skip, số lượng element cần tính toán lại layout là 1618 (rất nhiều). Để biết được những thuộc tính nào sẽ kích hoạt Layout (và lý do vì sao), bạn có thể tra cứu ở trang http://csstriggers.com/ – công cụ do một Googler viết cho mục đích tra cứu. 3.2. Sử dụng các thuộc tính mới của CSS3CSS3 có cung cấp một số thuộc tính mới không những giúp chúng ta canh chỉnh layout dễ hơn mà còn giúp tăng hiệu suất rất nhiều. Điển hình là Flexbox, việc sử dụng flexbox để canh chỉnh layout sẽ dễ hơn so với cách dùng float truyền thống. Xem bài hướng dẫn tuyệt vời về Flexbox: http://css-tricks.com/snippets/css/a-guide-to-flexbox/ Về hiệu suất, dưới đây là 2 hình ảnh đo hiệu suất của việc kích hoạt layout trên 1300 elements. Sử dụng Float: Sử dụng Flexbox: Có thể thấy con số “Self Time” giảm từ ~14ms chỉ còn ~3.5ms, đó là một sự thay đổi rất đáng kể. 3.3. Hạn chế kích hoạt layout sớmHãy xem xét đoạn code sau: thay đổi kích thước của 3 elements 1234567891011121314151617// Readvar h1 = element1.clientHeight; // Write (invalidates layout)element1.style.height = (h1 * 2) + 'px'; // Read (triggers layout)var h2 = element2.clientHeight; // Write (invalidates layout)element2.style.height = (h2 * 2) + 'px'; // Read (triggers layout)var h3 = element3.clientHeight; // Write (invalidates layout)element3.style.height = (h3 * 2) + 'px'; Khi một element (DOM) được ghi giá trị mới thì layout sẽ bị đánh dấu giá trị hết hiệu lực (invalidates) và sẽ được tính toán lại tại một thời điểm nào đó. Để đảm bảo performance, browser sẽ thực hiện tính toán lại layout vào thời điểm bắt đầu của frame tiếp theo. Tuy nhiên nếu trong thời gian frame hiện tại chưa kết thúc, ta muốn lấy giá trị kích thước của element thì lúc này browser buộc phải thực hiện tính toán layout lại sớm hơn so với thông thường để có thể trả về kết quả. Hiện tượng này gọi là “forced synchronous layout” – tạm dịch “kích hoạt layout sớm”, và nó gây ra vấn đề về performance khi ta phải thực hiện nhiều tác vụ hơn trong 1 frame. Để giải quyết, cách nhanh nhất là chúng ta sẽ “đọc trước, ghi sau”. 1234567891011// Readvar h1 = element1.clientHeight;var h2 = element2.clientHeight;var h3 = element3.clientHeight; // Write (invalidates layout)element1.style.height = (h1 * 2) + 'px';element2.style.height = (h2 * 2) + 'px';element3.style.height = (h3 * 2) + 'px'; // Document reflows at end of frame Hoặc sử dụng requestAnimationFrame để “hẹn giờ” cho cả 3 thao tác ghi vào frame tiếp theo: 123456789101112131415// Readvar h1 = element1.clientHeight; // WriterequestAnimationFrame(function() &#123; element1.style.height = (h1 * 2) + 'px';&#125;); // Readvar h2 = element2.clientHeight; // WriterequestAnimationFrame(function() &#123; element2.style.height = (h2 * 2) + 'px';&#125;); Bằng cách này, cả 3 thao tác ghi đều sẽ được thực hiện một lần trong frame tiếp theo, tốt hơn cho hiệu suất. Bạn sẽ thấy rõ tác dụng của việc hạn chế layout sớm trong một số trường hợp thực tế như sau “Layout thrashing”: 1234// Puts the browser into a read-write-read-write cycle.for (var i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + 'px';&#125; Như đoạn code trên, layout sẽ liên tục bị trigger và kích hoạt sớm ở trong vòng lặp (read: box.offsetWidth, và write: paragraphs[i].style.width) điều này là thảm họa cho browser (hình: dấu chấm than vàng là báo hiệu forced synchronous layout). Nếu đã biết về vấn đề forced synchronous layout, đoạn code trên nên được viết lại như sau: 123456789// Read.var width = box.offsetWidth; function resizeAllParagraphsToMatchBlockWidth() &#123; for (var i = 0; i &lt; paragraphs.length; i++) &#123; // Now write. paragraphs[i].style.width = width + 'px'; &#125;&#125; Nếu cảm thấy việc quản lý layout quá phức tạp, bạn có thể tham khảo sử dụng thư viện FastDOM, thư viện này giúp bạn quản lý các tác vụ read/write để đảm bảo không gây ra forced synchronous layout. Bước 4: Paint4.1. Dùng Chrome Developer Tools để phát hiện vấn đề performance khi paintBất kỳ sự thay đổi nào trên màn hình browser đều yêu cầu quá trình paint, animation, transition, lúc bôi đen đoạn text hay cả con trỏ nhấp nháy ở textbox. Để biết được browser phải vẽ lại những phần nào trên màn hình, bạn có thể bật chức năng “Show paint rectangles” ở tab “Rendering” trong Chrome Developer Tools. Những vùng bị vẽ lại sẽ được tô và hiển thị màu xanh lá cây trên màn hình. Bạn có thể xem chi tiết hoạt động vẽ của browser bằng cách kích hoạt chế độ “Paint profiler” ở tab “Timeline” khi record. Ở chế độ này, bạn có thể kiểm tra quá trình vẽ của tất cả các element trong web page. Dựa vào các thông tin này bạn có thể phân tích và đưa ra hướng giải quyết phù hợp nếu quá trình paint mất quá nhiều thời gian. Một số yếu tố khiến quá trình paint diễn ra chậm: Các hiệu ứng CSS phức tạp: box-shadow, gradient, curves Các element chồng đè lên nhau. Các hình ảnh có kích thước quá lớn … 4.2. Sử dụng hợp lý các layerTrên thực tế, quá trình vẽ diễn ra song song trên nhiều các layer khác nhau, việc phân chia các layer hợp lý sẽ giúp tiết kiệm được thời gian vẽ rất nhiều. Ví dụ trong trường hợp này, khi bạn cuộn trang thì browser phải vẽ lại layer trên cùng (text), còn layer hình bên dưới có vị trí cố định, không có gì thay đổi nên không cần phải vẽ lại nữa. Các layer này sẽ được gộp lại (ở bước cuối cùng – composite) và hiển thị lên màn hình. Làm sao để tạo layer? Vẽ – Paint – là tác vụ nặng nhất, chiếm nhiều thời gian nhất trong các bước, do đó bạn có thể thấy rõ được lợi ích của việc phân chia các layer làm sao cho browser ít phải vẽ lại nhất. Một layer (compositor layer) sẽ được tạo khi bạn sử dụng thuộc tính will-change (trên Chrome, Opera, Firefox) thuộc tính này báo hiệu cho browser biết element sẽ có sự thay đổi, do đó sẽ đưa element này vào một layer mới. 1.moving-element &#123; will-change: transform; &#125; Đối với các browser không hỗ trợ will-change bạn có thể sử dụng thuộc tính 3D transform để “ép buộc” tạo layer mới: 1.moving-element &#123; transform: translateZ(0); &#125; Cần lưu ý, việc tạo layer mới sẽ yêu cầu thêm bộ nhớ và tác vụ để quản lý các layer, do đó bạn không nên tạo quá nhiều layer, và chiến lược tao layer ở đây không cố định mà còn tùy thuộc vào tính chất của các animation, transition có trên website của bạn. Không nên: (layer explosions – tạo ra quá nhiều layer không cần thiết) 1234* &#123; will-change: transform; transform: translateZ(0);&#125; Bước 5: CompositeTại bước này, browser sẽ tiến hành gộp các compositor layer đã được vẽ (ở bước 4) và hiển thị lên màn hình. Trường hợp lý tưởng nhất cho performance là bỏ qua 2 bước Layout và Paint, công việc của browser chỉ là thay đổi các compositor layer để tạo ra một frame. Để làm được điều đó, bạn chỉ được thay đổi các thuộc tính mà Compositor có thể xử lý độc lập (mà không cần phải kích hoạt Layout và Paint). Các thuộc tính đó là transform và opacity. Tuy nhiên trên thực tế chúng ta cần phải thay đổi nhiều thuộc tính hơn nữa để đáp ứng được yêu cầu khi animate các hiệu ứng. Do đó, giải pháp chính là phải tạo và quản lý được các layer một cách hợp lý. Để quản lý được các layer, bạn có thể sử dụng công cụ Chrome Developer Tools. Trong tab “Timeline” đánh dấu vào mục Paint Tiến hành record và chọn phần Paint trên kết quả hiển thị Ở đây bạn sẽ thấy thẻ “Layer” trong phần thông tin của frame Từ đây bạn có thể tra cứu toàn bộ các frame mà web page đang có. Danh sách các layer được liệt kê dưới dạng cây (layer tree), preview dạng 3D, có thông tin về kích thước, bộ nhớ, lý do layer được tạo… Tổng kếtNhư vậy là ta đã đi từng bước để có thể tối ưu hiệu suất render cho web page: JavaScript – Dùng requestAnimationFrame – Dùng Web workers, Micro-task cho tác vụ nặng – Profiling with Chrome DevTools Style – Giảm độ phức tạp của selector – Giảm số lượng element bị ảnh hưởng Layout – Hạn chế kích hoạt layout – Sử dụng Flexbox – Hạn chế forced synchronous layout. Paint – Paint là tác vụ xử lý lâu nhất – Box-shadow, large image không tốt cho paint – Tạo và quản lý layer hợp lý Composite – Sử dụng transform và opacity – Quản lý các layer bằng Chrome DevTools Sau khi đã thực hiện những bước trên, web page của bạn sẽ hoạt động mượt mà, trơn tru với 60fps. Chúc bạn thành công! 60FPS FOR THE WIN! Chuyện ngoài lềỞ Silicon Straits Saigon, chúng tôi có một bài test dành cho Front-end Developer, đó là implement hiệu ứng scrolling sau (ảnh động, load hơi lâu): http://bit.ly/1CCYx9y Các bạn có thể vận dụng những kiến thức có được trong bài viết này để “thử sức” với hiệu ứng trên. Đây là bài làm của tôi, mặc dù không được hoàn hảo nhưng có thể dùng được cho mục đích tham khảo. Link: http://trungdq88.github.io/css-stuffs/delay-scroll/ Timeline Record: Layers (một phần): Các nguồn tham khảo trong bài viết:Một số hình ảnh và code mẫu: Google Developer: https://developers.google.com/web/fundamentals/performance/ Preventing Layout Thrashing:http://wilsonpage.co.uk/preventing-layout-thrashing/ Các trang web có hiệu ứng đẹp: http://world.mathigon.org/ http://matthew.wagerfield.com/parallax/ Khóa học: Udacity Course: Browser Rendering Optimization – Building 60 FPS Web Apps: https://www.udacity.com/course/browser-rendering-optimization–ud860 Các nguồn khác: Web Workers: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage BEM: https://bem.info/ PostCSS: https://github.com/postcss/postcss CSS Trigger: http://csstriggers.com/ Guide to Flexbox: http://css-tricks.com/snippets/css/a-guide-to-flexbox/ FastDOM: https://github.com/wilsonpage/fastdom","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"10 câu hỏi phỏng vấn mà Javascript Developer nên biết","slug":"10-cau-hoi-phong-van-ma-Javascript-Developer-nen-biet","date":"2018-06-23T15:11:00.000Z","updated":"2018-06-23T15:28:47.131Z","comments":true,"path":"2018/06/10-cau-hoi-phong-van-ma-Javascript-Developer-nen-biet.html","link":"","permalink":"http://nthung2112.github.io/2018/06/10-cau-hoi-phong-van-ma-Javascript-Developer-nen-biet.html","excerpt":"Tại hầu hết các công ty, người quản lý phải tin tưởng các developers, cho họ tham gia các cuộc phỏng vấn kỹ thuật để đánh giá các kỹ năng ứng cử viên. Nếu bạn làm tốt như một ứng cử viên, bạn sẽ cần phải phỏng vấn. Đây là cách làm.","text":"Tại hầu hết các công ty, người quản lý phải tin tưởng các developers, cho họ tham gia các cuộc phỏng vấn kỹ thuật để đánh giá các kỹ năng ứng cử viên. Nếu bạn làm tốt như một ứng cử viên, bạn sẽ cần phải phỏng vấn. Đây là cách làm. It Starts With PeopleIn “How to Build a High Velocity Development Team”, Tôi đã nêu một vài điểm đáng để lặp lại: “Nothing predicts business outcomes better than an exceptional team. If you’re going to beat the odds, you need to invest here, first.” Như Marcus Lemonis đã nói, cần tập trung vào 3 P’s: “People, Process, Product” Your early hires should be very strong, senior-level candidates. People who can hire and mentor other developers, and help the mid-level and junior developers you’ll eventually want to hire down the road. Read “Why Hiring is So Hard in Tech” for a good breakdown of the general do’s and don’ts of candidate evaluation. The best way to evaluate a candidate is a pair programming exercise. Pair program with the candidate. Let the candidate drive. Watch and listen more than you talk. A good project might be to pull tweets from the Twitter API and display them on a timeline. That said, no single exercise will tell you everything you need to know. An interview can be a very useful tool as well, but don’t waste time asking about syntax or language quirks. You need to see the big picture. Ask about architecture and paradigms — the big decisions that can have a major impact on the whole project. Syntax and features are easy to Google. It’s much harder to Google for software engineering wisdom or the common paradigms and idioms JavaScript developers pick up with experience. JavaScript is special, and it plays a critical role in almost every large application. What is it about JavaScript that makes it meaningfully different from other languages? Here are some questions that will help you explore the stuff that really matters: 1. Can you name two programming paradigms important for JavaScript app developers?JavaScript is a multi-paradigm language, supporting imperative/procedural programming along with OOP (Object-Oriented Programming) and functional programming. JavaScript supports OOP with prototypal inheritance. Good to hear: Prototypal inheritance (also: prototypes, OLOO). Functional programming (also: closures, first class functions, lambdas). Red flags: No clue what a paradigm is, no mention of prototypal oo or functional programming. 2. What is functional programming?Functional programming produces programs by composing mathematical functions and avoids shared state &amp; mutable data. Lisp (specified in 1958) was among the first languages to support functional programming, and was heavily inspired by lambda calculus. Lisp and many Lisp family languages are still in common use today. Functional programming is an essential concept in JavaScript (one of the two pillars of JavaScript). Several common functional utilities were added to JavaScript in ES5. Good to hear: Pure functions / function purity. Avoid side-effects. Simple function composition. Examples of functional languages: Lisp, ML, Haskell, Erlang, Clojure, Elm, F Sharp, OCaml, etc… Mention of features that support FP: first-class functions, higher order functions, functions as arguments/values. Red flags: No mention of pure functions / avoiding side-effects. Unable to provide examples of functional programming languages. Unable to identify the features of JavaScript that enable FP. 3. What is the difference between classical inheritance and prototypal inheritance?Class Inheritance: instances inherit from classes (like a blueprint — a description of the class), and create sub-class relationships: hierarchical class taxonomies. Instances are typically instantiated via constructor functions with the new keyword. Class inheritance may or may not use the class keyword from ES6. Prototypal Inheritance: instances inherit directly from other objects. Instances are typically instantiated via factory functions or Object.create(). Instances may be composed from many different objects, allowing for easy selective inheritance. In JavaScript, prototypal inheritance is simpler &amp;more flexible than class inheritance. Good to hear: Classes: create tight coupling or hierarchies/taxonomies. Prototypes: mentions of concatenative inheritance, prototype delegation, functional inheritance, object composition. Red Flags: No preference for prototypal inheritance &amp; composition over class inheritance. 4. What are the pros and cons of functional programming vs object-oriented programming?OOP Pros: It’s easy to understand the basic concept of objects and easy to interpret the meaning of method calls. OOP tends to use an imperative style rather than a declarative style, which reads like a straight-forward set of instructions for the computer to follow. OOP Cons: OOP Typically depends on shared state. Objects and behaviors are typically tacked together on the same entity, which may be accessed at random by any number of functions with non-deterministic order, which may lead to undesirable behavior such as race conditions. FP Pros: Using the functional paradigm, programmers avoid any shared state or side-effects, which eliminates bugs caused by multiple functions competing for the same resources. With features such as the availability of point-free style (aka tacit programming), functions tend to be radically simplified and easily recomposed for more generally reusable code compared to OOP. FP also tends to favor declarative and denotational styles, which do not spell out step-by-step instructions for operations, but instead concentrate on what to do, letting the underlying functions take care of the how. This leaves tremendous latitude for refactoring and performance optimization, even allowing you to replace entire algorithms with more efficient ones with very little code change. (e.g., memoize, or use lazy evaluation in place of eager evaluation.) Computation that makes use of pure functions is also easy to scale across multiple processors, or across distributed computing clusters without fear of threading resource conflicts, race conditions, etc… FP Cons: Over exploitation of FP features such as point-free style and large compositions can potentially reduce readability because the resulting code is often more abstractly specified, more terse, and less concrete. More people are familiar with _OO_ and imperative programming than functional programming, so even common idioms in functional programming can be confusing to new team members. FP has a much steeper learning curve than OOP because the broad popularity of OOP has allowed the language and learning materials of OOP to become more conversational, whereas the language of FP tends to be much more academic and formal. FP concepts are frequently written about using idioms and notations from lambda calculus, algebras, and category theory, all of which requires a prior knowledge foundation in those domains to be understood. Good to hear: Mentions of trouble with shared state, different things competing for the same resources, etc… Awareness of FP’s capability to radically simplify many applications. Awareness of the differences in learning curves. Articulation of side-effects and how they impact program maintainability. Awareness that a highly functional codebase can have a steep learning curve. Awareness that a highly OOP codebase can be extremely resistant to change and very brittle compared to an equivalent FP codebase. Awareness that immutability gives rise to an extremely accessible and malleable program state history, allowing for the easy addition of features like infinite undo/redo, rewind/replay, time-travel debugging, and so on. Immutability can be achieved in either paradigm, but a proliferation of shared stateful objects complicates the implementation in OOP. Red flags: Unable to list disadvantages of one style or another — Anybody experienced with either style should have bumped up against some of the limitations. Learn More: The Two Pillars of JavaScript Part 1 — Prototypal OO. The Two Pillars of JavaScript Part 2 — Functional Programming. 5. When is classical inheritance an appropriate choice?The answer is never, or almost never. Certainly never more than one level. Multi-level class hierarchies are an anti-pattern. I’ve been issuing this challenge for years, and the only answers I’ve ever heard fall into one of several common misconceptions. More frequently, the challenge is met with silence. “If a feature is sometimes usefuland sometimes dangerousand if there is a better optionthen always use the better option.”~ Douglas Crockford Good to hear: Rarely, almost never, or never. A single level is sometimes OK, from a framework base-class such as React.Component. “Favor object composition over class inheritance.” 6. When is prototypal inheritance an appropriate choice?There is more than one type of prototypal inheritance: Delegation (i.e., the prototype chain). Concatenative (i.e. mixins, Object.assign()). Functional (Not to be confused with functional programming. A function used to create a closure for private state/encapsulation). Each type of prototypal inheritance has its own set of use-cases, but all of them are equally useful in their ability to enable composition, which creates has-a or uses-a or can-do relationships as opposed to the is-a relationship created with class inheritance. Good to hear: In situations where modules or functional programming don’t provide an obvious solution. When you need to compose objects from multiple sources. Any time you need inheritance. Red flags: No knowledge of when to use prototypes. No awareness of mixins or Object.assign(). 7. What does “favor object composition over class inheritance” mean?This is a quote from “Design Patterns: Elements of Reusable Object-Oriented Software”. It means that code reuse should be achieved by assembling smaller units of functionality into new objects instead of inheriting from classes and creating object taxonomies. In other words, use can-do, has-a, or uses-a relationships instead of is-a relationships. Good to hear: Avoid class hierarchies. Avoid brittle base class problem. Avoid tight coupling. Avoid rigid taxonomy (forced is-a relationships that are eventually wrong for new use cases). Avoid the gorilla banana problem (“what you wanted was a banana, what you got was a gorilla holding the banana, and the entire jungle”). Make code more flexible. Red Flags: Fail to mention any of the problems above. Fail to articulate the difference between composition and class inheritance, or the advantages of composition. 8. What are two-way data binding and one-way data flow, and how are they different?Two way data binding means that UI fields are bound to model data dynamically such that when a UI field changes, the model data changes with it and vice-versa. One way data flow means that the model is the single source of truth. Changes in the UI trigger messages that signal user intent to the model (or “store” in React). Only the model has the access to change the app’s state. The effect is that data always flows in a single direction, which makes it easier to understand. One way data flows are deterministic, whereas two-way binding can cause side-effects which are harder to follow and understand. Good to hear: React is the new canonical example of one-way data flow, so mentions of React are a good signal. Cycle.js is another popular implementation of uni-directional data flow. Angular is a popular framework which uses two-way binding. Red flags: No understanding of what either one means. Unable to articulate the difference. 9. What are the pros and cons of monolithic vs microservice architectures?A monolithic architecture means that your app is written as one cohesive unit of code whose components are designed to work together, sharing the same memory space and resources. A microservice architecture means that your app is made up of lots of smaller, independent applications capable of running in their own memory space and scaling independently from each other across potentially many separate machines. Monolithic Pros: The major advantage of the monolithic architecture is that most apps typically have a large number of cross-cutting concerns, such as logging, rate limiting, and security features such audit trails and DOS protection. When everything is running through the same app, it’s easy to hook up components to those cross-cutting concerns. There can also be performance advantages, since shared-memory access is faster than inter-process communication (IPC). Monolithic cons: Monolithic app services tend to get tightly coupled and entangled as the application evolves, making it difficult to isolate services for purposes such as independent scaling or code maintainability. Monolithic architectures are also much harder to understand, because there may be dependencies, side-effects, and magic which are not obvious when you’re looking at a particular service or controller. Microservice pros: Microservice architectures are typically better organized, since each microservice has a very specific job, and is not concerned with the jobs of other components. Decoupled services are also easier to recompose and reconfigure to serve the purposes of different apps (for example, serving both the web clients and public API). They can also have performance advantages depending on how they’re organized because it’s possible to isolate hot services and scale them independent of the rest of the app. Microservice cons: As you’re building a new microservice architecture, you’re likely to discover lots of cross-cutting concerns that you did not anticipate at design time. A monolithic app could establish shared magic helpers or middleware to handle such cross-cutting concerns without much effort. In a microservice architecture, you’ll either need to incur the overhead of separate modules for each cross-cutting concern, or encapsulate cross-cutting concerns in another service layer that all traffic gets routed through. Eventually, even monolthic architectures tend to route traffic through an outer service layer for cross-cutting concerns, but with a monolithic architecture, it’s possible to delay the cost of that work until the project is much more mature. Microservices are frequently deployed on their own virtual machines or containers, causing a proliferation of VM wrangling work. These tasks are frequently automated with container fleet management tools. Good to hear: Positive attitudes toward microservices, despite the higher initial cost vs monolthic apps. Aware that microservices tend to perform and scale better in the long run. Practical about microservices vs monolithic apps. Structure the app so that services are independent from each other at the code level, but easy to bundle together as a monolithic app in the beginning. Microservice overhead costs can be delayed until it becomes more practical to pay the price. Red flags: Unaware of the differences between monolithic and microservice architectures. Unaware or impractical about the additional overhead of microservices. Unaware of the additional performance overhead caused by IPC and network communication for microservices. Too negative about the drawbacks of microservices. Unable to articulate ways in which to decouple monolithic apps such that they’re easy to split into microservices when the time comes. Underestimates the advantage of independently scalable microservices. 10. What is asynchronous programming, and why is it important in JavaScript?Synchronous programming means that, barring conditionals and function calls, code is executed sequentially from top-to-bottom, blocking on long-running tasks such as network requests and disk I/O. Asynchronous programming means that the engine runs in an event loop. When a blocking operation is needed, the request is started, and the code keeps running without blocking for the result. When the response is ready, an interrupt is fired, which causes an event handler to be run, where the control flow continues. In this way, a single program thread can handle many concurrent operations. User interfaces are asynchronous by nature, and spend most of their time waiting for user input to interrupt the event loop and trigger event handlers. Node is asynchronous by default, meaning that the server works in much the same way, waiting in a loop for a network request, and accepting more incoming requests while the first one is being handled. This is important in JavaScript, because it is a very natural fit for user interface code, and very beneficial to performance on the server. Good to hear: An understanding of what blocking means, and the performance implications. An understanding of event handling, and why its important for UI code. Red flags: Unfamiliar with the terms asynchronous or synchronous. Unable to articulate performance implications or the relationship between asynchronous code and UI code. ConclusionStick to high-level topics. If they can answer these questions, that typically means that they have enough programming experience to pick up language quirks &amp; syntax in a few weeks, even if they don’t have a lot of JavaScript experience. Don’t disqualify candidates based on stuff that’s easy to learn (including classic CS-101 algorithms, or any type of puzzle problem). What you really need to know is, “does this candidate understand how to put an application together?” That’s it for the spoken interview. In real interviews, I place a much stronger emphasis on coding challenges and watching candidates code. Those topics are covered in depth in my “Master the JavaScript Interview” series.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Local Storage, Session Storage và Cookie","slug":"Local-Storage-Session-Storage-va-Cookie","date":"2018-06-23T11:40:00.000Z","updated":"2018-06-23T11:45:41.597Z","comments":true,"path":"2018/06/Local-Storage-Session-Storage-va-Cookie.html","link":"","permalink":"http://nthung2112.github.io/2018/06/Local-Storage-Session-Storage-va-Cookie.html","excerpt":"Sự khác nhau và cách sử dụng Local Storage, Session Storage và CookieBạn bị lẫn lộn giữa session storage, local storage và cookies? Bài viết dưới đây sẽ giúp bạn hiểu rõ được sự khác nhau giữa 3 cách lưu trữ này. Các kiểu không gian lưu trữ khác nhau có sẵn cho các dữ liệu có thể trên máy chủ hoặc máy khách, cho phép chúng ta chọn lựa theo nhu cầu.","text":"Sự khác nhau và cách sử dụng Local Storage, Session Storage và CookieBạn bị lẫn lộn giữa session storage, local storage và cookies? Bài viết dưới đây sẽ giúp bạn hiểu rõ được sự khác nhau giữa 3 cách lưu trữ này. Các kiểu không gian lưu trữ khác nhau có sẵn cho các dữ liệu có thể trên máy chủ hoặc máy khách, cho phép chúng ta chọn lựa theo nhu cầu. 1. Local storageGiới thiệu: Khả năng lưu trữ vô thời hạn: Có nghĩa là chỉ bị xóa bằng JavaScript, hoặc xóa bộ nhớ trình duyệt, hoặc xóa bằng localStorage API. Lưu trữ được 5MB: Local Storage cho phép bạn lưu trữ thông tin tương đối lớn lên đến 5MB, lưu được lượng thông tin lớn nhất trong 3 loại. Không gửi thông tin lên server như Cookie nên bảo mật tốt hơn. Trình duyệt hỗ trợ: Trình duyệt Phiên bản Chrome &gt;= 4.0 Internet Explorer / Edge &gt;= 8.0 Firefox &gt;= 3.5 Safari &gt;= 4.0 Chrome &gt;= 11.5 Để kiểm tra xem trình duyệt có hỗ trợ localStorage hay không thì chúng ta dùng typeof như sau: 12345678if (typeof(Storage) !== 'undefined') &#123; //Nếu có hỗ trợ //Thực hiện thao tác với Storage alert('Trình duyệt của bạn hỗ trợ Storage');&#125; else &#123; //Nếu không hỗ trợ alert('Trình duyệt của bạn không hỗ trợ Storage');&#125; Xem localStorage bằng trình duyệtĐể xem localstorage bằng trình duyệt các bạn vào trang web cần xem (ở đây mình ví dụ với trang web http://book.framgia.vn/) và sau đó các bạn ấn F12 (hoặc Ctrl + shift + i) sau đó làm theo như hình sau: Chọn tab Application, di chuyển đến Storage để thấy các Storage của trình duyệt. Để xem các local Storage đang được lưu trữ, mở rộng phần Local Storage như hình. Ở đây ta có thể thấy có 2 biến Local Storage đang được lưu là pusherTransportEncrypted và lang với giá trị của 2 biến được hiển thị bên cạnh (cột Value). Như vậy, cột Key chính là danh sách các biến local Storage đang được lưu và cột Value là các giá trị tương ứng. Để xóa hết các giá trị local Storage này đi, bạn có thể chọn biểu tượng cấm (Clear All) hoặc chọn bên cạnh là biểu tượng dấu X (Delete Selected). Sử dụng Khởi tạo localStorage 12345localStorage.setItem('key', 'value');// hoặclocalStorage.key = 'value';// hoặclocalStorage['key'] = 'value'; Trong đó: key là tên biến, value là giá trị của biến muốn gán vào. Để lấy giá trị localStorage và sử dụng, ta dùng getItem 123localStorage.getItem('key');// hoặclocalStorage.key; Ví dụ cụ thể như sau: Để lấy số lượng localStorage đã có trong trình duyệt, sử dụng length như sau: 1localStorage.length; Ví dụ 12345678if (typeof(Storage) !== \"undefined\") &#123; //Nếu hỗ trợ var data = localStorage.length; console.log(data);&#125; else &#123; // Nếu không hỗ trợ alert('Trình duyệt của bạn không hỗ trợ');&#125; Để xóa 1 biến trong localStorage, sử dụng removeItem(tên_key) 1localStorage.removeItem(key); Hoặc xóa tất cả các biến trong localStorage, sử dụng clear 1localStorage.clear(); 2. Session StorageGiới thiệu: Lưu trên Client: Cũng giống như localStorage thì sessionStorage cũng dùng để lưu trữ dữ liệu trên trình duyệt của khách truy cập (client). Mất dữ liệu khi đóng tab: Dữ liệu của sessionStorage sẽ mất khi bạn đóng trình duyệt. Dữ liệu không được gửi lên Server Thông tin lưu trữ nhiều hơn cookie (ít nhất 5MB) Trình duyệt hỗ trợ Trình duyệt Phiên bản Chrome &gt;= 5.0 Internet Explorer / Edge &gt;= 8.0 Firefox &gt;= 2 Safari &gt;= 4.0 Opera &gt;= 10.5 Vì sessionStorage cũng nằm trong gói Storage nên các bạn cũng có thể sử dụng lại đoạn code kiểm tra trình duyệt có hỗ trợ Storage hay không ở phía trên. Xem Session Storage bằng trình duyệtTương tự như localStorage, có thể chọn mở rộng mục Session Storage để xem các giá trị được lưu trữ. Sử dụngsessionStorage cũng có cú pháp và cách sử dụn các thuộc tính, phương thức như localStorage: 1234567891011121314if ( typeof(Storage) !== 'undefined') &#123; // Khởi tạo sesionStorage sessionStorage.setItem('name', 'Ted Mosby'); // get sessionStorage sessionStorage.getItem('name'); // lấy ra số lượng session đã lưu trữ sessionStorage.length; // xóa 1 item localStorage sessionStorage.removeItem('name'); // xóa tất cả item trong sessionStorage sessionStorage.clear();&#125; else &#123; alert('Trình duyệt của bạn không hỗ trợ!');&#125; 3. CookieGiới thiệu: Thông tin được gửi lên server: Cookie sẽ được truyền từ server tới browser và được lưu trữ trên máy tính của bạn khi bạn truy cập vào ứng dụng, mỗi khi người dùng tải ứng dụng, trình duyệt sẽ gửi cookie để thông báo cho ứng dụng về hoạt động trước đó của bạn. Vì vậy đừng bao giờ lưu trữ những thông tin quan trọng, yêu cầu tính bảo mật cao vào cookie vì nó hoàn toàn có thể bị sửa đổi và đánh cắp, thấp chí có thể lợi dụng điều này để tấn công website của bạn. Cookie chủ yếu là để đọc phía máy chủ (cũng có thể được đọc ở phía máy khách), localStorage và sessionStorage chỉ có thể được đọc ở phía máy khách. Có thời gian sống: Mỗi cookie thường có khoảng thời gian timeout nhất định do lập trình viên xác định trước. Lưu trữ: cho phép lưu trữ tối đa 4KB và vài chục cookie cho một domain. Xem cookie bằng trình duyệtTương tự như localStorage, có thể chọn mở rộng mục Cookies để xem các giá trị cookie được lưu trữ Sử dụngCookie có thể được tạo bằng nhiều cách, bài viết này sẽ trình bày về sử dụng cookie trong javascript. JavaScript có thể tạo, đọc, và xóa cookies với document.cookie. Tạo cookie: Javascript có thể tạo cookie như sau: 1document.cookie = 'username=Ted Mosby'; Chúng ta cũng có thể thêm vào ngày hết hạn cho cookie 1document.cookie = 'username=Ted Mosby; expires=Thu, 18 Dec 2018 8:00:00 UTC'; Hoặc đặt hẹn giờ sau bao lâu cookie sẽ hết hạn với max-age (tính bằng giây) 1document.cookie = 'username=Ted Mosby; max-age=9000'; Đọc cookie: 1var x = document.cookie; document.cookie sẽ trả lại tất cả cookie trong một chuỗi tring kiểu như: cookie1 = giá trị; cookie2 = giá trị; cookie3 = giá trị; Hoặc để lấy giá trị của 1 cookie, có thể viết một hàm như sau: 123456789101112131415function getCookie(cname) &#123; var name = cname + '='; var decodedCookie = decodeURIComponent(document.cookie); var ca = decodedCookie.split(';'); for(var i = 0; i &lt;ca.length; i++) &#123; var c = ca[i]; while (c.charAt(0) == ' ') &#123; c = c.substring(1); &#125; if (c.indexOf(name) == 0) &#123; return c.substring(name.length, c.length); &#125; &#125; return '';&#125; Tham số truyền vào là cname - tên cookie muốn lấy giá trị. Tạo một biến name và thêm vào “=” để tìm kiếm trong chuỗi document.cookie Chia document.cookie dựa trên dấu ; thành một mảng nhiều phần tử và gán mảng đấy cho biến ca Vòng lặp (i=0; i&lt;ca.length; i++) để đọc mỗi giá trị c = ca[i] Nếu cookie được tìm thấy (c.indexOf(name)==0), trả về giá trị của cookie (c.substring(name.length,c.length). Nếu cookie không được tìm thấy, trả về ‘’ Ví dụ muốn lấy giá trị của cookie tên là language thì ta có thể gọi getcookie(‘language’) và kêt quả trả về là giá trị của cookie có tên đó. 12var lang = getCookie('language');console.log(lang); Kết quả: Thay đổi giá trị cookie: Trong javascript, bạn có thể thay đổi một cookie giống như cách mà bạn tạo ra cookie, tức là ghi đè giá trị mới lên cookie đã có: 1document.cookie = \"username=Barney Stinson; expires=Wed, 26 Dec 2018 8:00:00 UTC\"; Kiểm tra cookie: Để kiểm tra coookie, có thể xây dựng hàm như sau: 1234567891011function checkCookie() &#123; var username = getCookie('username'); if (username != '') &#123; alert('Welcome again ' + username); &#125; else &#123; username = prompt('Please enter your name: ', ''); if (username != '' &amp;&amp; username != null) &#123; setCookie('username', username, 365); &#125; &#125;&#125; Nếu cookie được thiết lập, nó sẽ hiển thị một lời chào Nếu cookie không được thiết lập, nó sẽ hiển thị một prompt box, hỏi tên của người dùng, lưu trữ tên của người dùng ở cookie trong 365 ngày, bằng việc gọi function setCookie đã được viết ở trên Xóa cookie: Để xóa một cookie chỉ cần xét lại giá trị ngày hết hạn expires về một thời điểm đã qua 1document.cookie = 'username=; expires=Thu, 01 Jan 1970 00:00:00 UTC'; Tham khảo tại https://www.w3schools.com/js/js_cookies.asp 4. Thông tin thêm Vì localStorage và sessionStorage được lưu trữ trên trình duyệt của người dùng, nên các bạn cần phải xem xét nội dung lưu trữ có liên quan đến vấn đề bảo mật hay không. Và cũng chính vì localStorage và sessionStorage được lưu trữ trên trình duyệt nên việc sử dụng nó sẽ không ảnh hưởng đến hiệu xuất của trang web nhưng nó sẽ làm nặng trình duyệt của người dùng (không đáng kể). Về phạm vi: sessionStorage: giới hạn trong một cửa sổ hoăc thẻ của trình duyệt. Một trang web được mở trong hai thẻ của cùng một trình duyệt cũng không thể truy xuất dữ liệu lẫn nhau. Như vậy, khi bạn đóng trang web thì dữ liệu lưu trong sessionStorage hiện tại cũng bị xóa. Còn localStorage: có thể truy xuất lẫn nhau giữa các cửa sổ trình duyệt. Dữ liệu sẽ được lưu trữ không giới hạn thời gian.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"html5","slug":"html5","permalink":"http://nthung2112.github.io/tags/html5/"}]},{"title":"Load Javascript với async và defer","slug":"Load-Javascript-voi-async-va-defer","date":"2018-06-23T11:29:00.000Z","updated":"2018-06-23T11:37:52.865Z","comments":true,"path":"2018/06/Load-Javascript-voi-async-va-defer.html","link":"","permalink":"http://nthung2112.github.io/2018/06/Load-Javascript-voi-async-va-defer.html","excerpt":"Vấn đềJavascript là 1 trong những tài nguyên chặn trang, có nghĩa là việc hiển thị HTML có thể bị chặn hay làm chậm bởi Javascript. Khi parser đọc đến &lt;script&gt; tag, bất kể là inline hay là external file, quá trình parse sẽ tạm dừng để fetch script đó về và execute. Việc này có thể là vấn đề nếu chúng ta load nhiều file Javascript trên trang, làm tăng thời gian load trang mặc dù có thể việc hiển thị html ở trang không thực sự phụ thuộc vào những file javascript đó. Và may mắn thay, thẻ &lt;script&gt; có 2 thuộc tính, đó là async và defer, cho phép chúng ta kiểm soát và load những file này theo ý muốn, tránh chặn quá trình load trang.","text":"Vấn đềJavascript là 1 trong những tài nguyên chặn trang, có nghĩa là việc hiển thị HTML có thể bị chặn hay làm chậm bởi Javascript. Khi parser đọc đến &lt;script&gt; tag, bất kể là inline hay là external file, quá trình parse sẽ tạm dừng để fetch script đó về và execute. Việc này có thể là vấn đề nếu chúng ta load nhiều file Javascript trên trang, làm tăng thời gian load trang mặc dù có thể việc hiển thị html ở trang không thực sự phụ thuộc vào những file javascript đó. Và may mắn thay, thẻ &lt;script&gt; có 2 thuộc tính, đó là async và defer, cho phép chúng ta kiểm soát và load những file này theo ý muốn, tránh chặn quá trình load trang. Mô tả cách thực thi &lt;script&gt;12345678&lt;html&gt; &lt;head&gt; ... &lt;/head&gt;&lt;body&gt; ... &lt;script src=\"script.js\" /&gt; ....&lt;/body&gt;&lt;/html&gt; Với thẻ script không có thuộc tính gì khác thì HTML file sẽ được parse cho đến khi gặp phải thẻ script, đến lúc này thì quá trình parse sẽ tạm dùng và để fetch script file về (nếu là external file), sau đó execute những code script này, sau đó mới tiếp tục lại quá trình parse html &lt;script async&gt;1&lt;script async src=\"script.js\" /&gt; Với thẻ script có thuộc tính async, khi quá trình parse html gặp phải script này, nó sẽ vẫn tiếp tục parse html cho đến khi script này được download xong, thì quá trình parse html mới tạm dừng để execute những code script này, sau đó lại tiếp tiếp quá trình parse html &lt;script defer&gt;1&lt;script defer src=\"script.js\" /&gt; Với thẻ script có thuộc tính defer, quá trình parse html sẽ không bị dừng lại mà parse cho đến khi hoàn thành, quá trình download các script file được tiến hành song song, và cuối cùng thì sẽ execute những script code này khi html đã parse xong. Vậy nên dùng khi nào?Nó phụ thuộc vào từng tình huống cụ thể. Quy tắc như sau: Nếu script là 1 module tách biệt, không phụ thuộc vào script nào khác thì nên sử dụng async cho load và execute với trang luôn Nếu script phụ thuộc vào script khác, hoặc bị script khác phụ thuộc, thì nên dùng defer, để load và execute theo thứ tự Nếu script nhỏ và các script khác phụ thuộc vào nó, thì cho load inline và không cần async hay defer Ngoài ra nên cân nhắc 1 số câu hỏi trước khi thêm các thuộc tính này1. Thẻ script đang nằm ở đâu trong trangAsync và defer có thể rất cần thiết nếu thẻ script không nằm ở cuối trang. HMTL document được parse theo thứ tự, từ thẻ mở cho đến thẻ đóng . Nếu script năm ngay gần cuối thẻ đóng thì việc sử dụng async hay defer thì cũng không có ý nghĩa lắm bởi vì việc parse html đã gần xong xuôi, và javascript không còn block gì html nữa. 2. Script đó có độc lập không?Với những file script không phụ thuộc vào những file khác, thì thuộc tính async dùng cho script đó là việc nên làm, vì nó load và execute script song song, giảm thời gian tải trang, kết quả cuối cùng nhanh hơn. 3. Script có yêu cầu việc load DOM xong mới thực hiện?Trong nhiều trường hợp, các script chứa đựng code tương tác với DOM, hoặc phụ thuộc vào các thành phần trên trang, yêu cầu trang phải parse xong thì mới execute script. Thông thường thì những file như thế sẽ được đặt ở cuối trang để chắc chắn mọi thử đã được parse. Tuy nhiên chúng ta có thể dùng thuộc tính defer thay thế, đảm bảo script sẽ được execute khi trang đã tải xong. 4.Script nhỏ và các file khác phụ thuộc vào nó?Nếu script dung lượng nhỏ, và các file khác phụ thuộc vào nó, thì nên để script đó inline. Mặc dù nó block quá trình parse HTML, nhưng nó không đáng kể vì dung lượng nhỏ. Lợi íchVới việc biết cách sử dụng các thuộc tính async, defer hợp lí thì tốc độ load trang sẽ được cải thiện hơn, mang lại cảm giác thích thú cho người dùng. Vì vậy nó giúp tối ưu SEO, giúp tăng điểm Google Page Speed (https://developers.google.com/speed/pagespeed/insights)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Functional Programming - Phần 3 - Buông bỏ","slug":"Functional-Programming-Phan-3-Buong-bo","date":"2018-06-20T08:46:00.000Z","updated":"2018-06-23T08:54:01.269Z","comments":true,"path":"2018/06/Functional-Programming-Phan-3-Buong-bo.html","link":"","permalink":"http://nthung2112.github.io/2018/06/Functional-Programming-Phan-3-Buong-bo.html","excerpt":"Functional Programming là một con đường khác, một phương pháp tư duy khác trong coding. Ở tầm nhìn trừu tượng hơn, người ta xếp Functional Programming vào nhóm “Declarative”, còn OOP thuộc nhóm “Imperative”. Từ các bài học ngữ pháp chúng ta đã biết 2 kiểu câu: câu trần thuật (Declarative Sentence), và câu mệnh lệnh (Imperative Sentence). Lập trình theo lối “Imperative Programming” là sắp xếp một loạt các mệnh lệnh liên tiếp, để máy tính thực thi tuần tự từng bước. Ở đây người ta tập trung vào “how”. Nào, hãy làm thế này, rồi làm thế kia… Một hình thức “cầm tay chỉ việc”.","text":"Functional Programming là một con đường khác, một phương pháp tư duy khác trong coding. Ở tầm nhìn trừu tượng hơn, người ta xếp Functional Programming vào nhóm “Declarative”, còn OOP thuộc nhóm “Imperative”. Từ các bài học ngữ pháp chúng ta đã biết 2 kiểu câu: câu trần thuật (Declarative Sentence), và câu mệnh lệnh (Imperative Sentence). Lập trình theo lối “Imperative Programming” là sắp xếp một loạt các mệnh lệnh liên tiếp, để máy tính thực thi tuần tự từng bước. Ở đây người ta tập trung vào “how”. Nào, hãy làm thế này, rồi làm thế kia… Một hình thức “cầm tay chỉ việc”.Ví dụ trên trang web có 4 boxes màu đỏ thế này: 12345678910111213141516&lt;style&gt;.box &#123; width: 100px; height: 100px; float: left; margin: 10px; background-color: red;&#125;.hide &#123; display: none;&#125;&lt;/style&gt;&lt;div class=\"box hide\"&gt;&lt;/div&gt;&lt;div class=\"box hide\"&gt;&lt;/div&gt;&lt;div class=\"box hide\"&gt;&lt;/div&gt;&lt;div class=\"box hide\"&gt;&lt;/div&gt; Mấy boxes này đang ẩn, ta cần làm chúng hiện ra bằng cách loại bỏ class “hide” đi. Các giáo viên tin học đáng kính ở trường xưa thường dạy viết kiểu như thế này: 1234567891011// tìm hết các tags có class \"box':const els = document.querySelectorAll('.box');// quét tất cả các tags tìm thấyfor (let i = 0; i &lt; els.length; i++) &#123; // với tag thứ i let el = els[i]; // xóa bỏ class \"hide\" để cho tag hiện lên el.classList.remove('hide'); // nếu còn phần tử phía sau thì tăng i lên 1 đơn vị // quay lại với xử lý tag thứ i + 1&#125; Họ dùng code hướng dẫn cho máy tính làm từng nhiệm vụ. Người tu luyện Functional Programming không tư duy theo cách đó. No for/while“Declarative Programming” là tập trung vào “what”. Chúng ta chỉ cần định nghĩa những quy tắc đầu vào, đầu ra. Chẳng hạn “nếu input là 1 thì output là 2”. Phần còn lại để máy tính xử lý. Người tu luyện Functional Programming không cần for loop. Code như thế này nhìn mới mẻ hơn nhiều: 12345678910111213141516const getElements = (selector) =&gt; &#123; return Array.from(document.querySelectorAll(selector));&#125;;const getRemover = (el) =&gt; &#123; return (className) =&gt; &#123; el.classList.remove(className); return el; &#125;;&#125;;const els = getElements('.box') .map(getRemover) .map(removeClass =&gt; removeClass('hide'));console.log(els); Trước tiên chúng ta tạo ra 1 pure function getElements dùng để lấy các elements trên trang thông qua CSS Selector. Tập hợp này vốn là ArrayLike, ta dùng Array.from chuyển thành Array thực sự để có thể tận dụng các phương thức trong Array prototype. Ở đây ta định nghĩa input là CSS Selector, output là 1 mảng DOM Elements. Còn getRemover lại là 1 higher-order function. Có thể gọi nó bằng cách chaining getRemover(DOMElement)(classToRemove). Chúng ta lợi dụng đặc tính của higher-order function, sau 2 lần map thì chạm tới function do getRemover ném lại. Ở đây ta định nghĩa input là DOM Element, output là function() {nhận input là className và output là DOM Element đã mất đi class đó}. Code như vậy ta có thể đem logic dùng lại ở nhiều chỗ khác nhau, chỉ cần thay đổi input. Ví dụ loại bỏ class float-left khỏi tất cả các thẻ div. 123const els = getElements('div') .map(getRemover) .map(removeClass =&gt; removeClass('float-left')); No if/elseNgười tu luyện Functional Programming cũng không cần if/else. Thậm chí họ còn tạo ra cả một chiến dịch Anti-IF! Có nhiều cách để loại bỏ hoàn toàn if/else ra khỏi chương trình của bạn. Đơn giản nhất là dùng ternary. TernaryTrong JavaScript, ternary - tam phân - có tên gọi chính thức là Toán tử Điều kiện - Conditional Operator. Nó là cách viết ngắn gọn của if/else. Hãy xem đoạn code dài dòng, rẽ nhánh phức tạp như sau: 12345678let title = 'Mr.';if (person.gender === 'female') &#123; if (!person.gotMarried) &#123; title = 'Ms.'; &#125; else &#123; title = 'Mrs.'; &#125;&#125; Có thể được viết gọn lại thành: 1const title = person.gender === 'female' ? (!person.gotMarried ? 'Ms.' : 'Mrs.') : 'Mr.'; Không còn if/else nữa. Ta cũng vô hình trung loại bỏ được var, let vì không cần gán lại giá trị cho title. Logical operatorsCách thứ 2 là khai thác sức mạnh ngầm của các logical operators &amp;&amp;, ||. Đây là những toán tử logic. Hôm trước có bạn viết 1 cái TIL ngắn khá hay. Sau đây ta quan sát chúng kỹ hơn qua lăng kính Functional Programming. Giả sử có đoạn code như sau: 1234567891011121314151617181920const sayHello = () =&gt; &#123; console.log('Hello, bonjour, nihao'); return true;&#125;;const doNothing = () =&gt; &#123; console.log('Do nothing'); return false;&#125;;const greet = (hasClient) =&gt; &#123; if (hasClient) &#123; sayHello(); &#125; else &#123; doNothing(); &#125;&#125;greet(true); // =&gt; 'Hello, bonjour, nihao'greet(false); //=&gt; 'Do nothing' Về mặt logic, hàm greet() kiểm tra điều kiện nếu có khách thì chào, nếu không thì không làm gì cả. Theo định nghĩa của &amp;&amp; và ||, chúng ta biết: expr1 &amp;&amp; expr2 trả về expr1 nếu expr1 là falsy, ngoài ra nó trả về expr2. Một điều thú vị ở đây là JavaScript engine luôn ước lượng giá trị biểu thức logic dạng này từ trái sang phải và theo nguyên tắc “đoản mạch” - short-circuit evaluation“. Tiên hữu nào giỏi Vật lý chắc còn nhớ hiện tượng “đoản mạch”, đó là khi dòng điện không chạy qua tải hoặc chỉ chạy qua một phần. Vì AND chỉ trả về true nếu cả 2 mệnh đề cùng đúng, nên ngay khi bắt gặp expr1 sai, nó lập tức kết luận mệnh đề ghép là Sai và chấm dứt tại đó luôn, không chạy qua nửa bên phải expr2 nữa. expr1 || expr2 trả về expr1 nếu expr1 là truthy, ngoài ra nó trả về expr2. Vì OR trả về true nếu ít nhất 1 mệnh đề đúng, nên ngay khi bắt gặp expr1 đúng, nó lập tức kết luận mệnh đề ghép là Đúng và bỏ qua expr2. Short-circuit thần thánh! Các lập trình viên kinh nghiệm thường lợi dụng đặc điểm này để tối ưu hiệu suất chương trình. Họ để các biểu thức tính toán phức tạp ở nửa sau của biểu thức logic. Như vậy, khi chưa rơi vào hoàn cảnh thích hợp, chúng sẽ bị bỏ qua, không cần tốn resource xử lý. Tới đây, ta đã có thể viết lại hàm greet() một cách bí hiểm như sau: 123const greet = (hasClient) =&gt; &#123; return (hasClient || doNothing()) &amp;&amp; sayHello();&#125; Bắt đầu phần nằm trong ngoặc đơn bên trái &amp;&amp;. Nếu hasClient là true thì giá trị phần này cũng là true, doNothing() bị bỏ qua. Vì phần bên trái của &amp;&amp; là true nên cuối cùng, giá trị biểu thức quy về phần bên phải &amp;&amp;, tức là sayHello(). Lập luận tương tự cho trường hợp hasClient là false, dòng chảy chương trình lập tức rẽ sang doNothing(). Lúc này giá trị nửa bên trái &amp;&amp; là false, do đó không cần quan tâm đến sayHello() nữa. Viết như trên vừa độc vừa lạ, vừa khử được if/else, mà vẫn hoàn toàn ăn khớp với điều kiện quy ước. Tuy nhiên, logical operators nếu nhìn không quen thì có vẻ hơi khó hình dung mạch suy diễn của chương trình. Tôi chỉ đưa ra đây để các tin hữu tham khảo. Trong dự án thực tế, vẫn nên dùng ternary cho đỡ hại não đồng đội: 123const greet = (hasClient) =&gt; &#123; return hasClient ? sayHello() : doNothing();&#125; Logical functionsMột cách tiếp cận khác thể hiện tinh thần Functional Programming quyết liệt hơn, đó là tạo ra các hàm đặc trách nhiệm vụ xử lý logic. Ví dụ trong Ramda.js và Sanctuary đều có ifElse , unless , when, và hàng chục hàm logic khác. Hàm greet nếu viết lại với Ramda sẽ trở nên xinh xắn như thế này: 123const R = require('ramda');const greet = R.ifElse(R.identity, sayHello, doNothing); Đó là vẻ đẹp đầy tính nghệ thuật của Function Composition. Bạn cứ ngắm nhìn nó và đừng nói gì cả! Composition cũng có nghĩa là tác phẩm, như thơ của Paul Verlaine hay nhạc của Beethoven. No new/thisCó 2 thứ luôn khiến Brendan Eich cảm thấy hài lòng khi kể về lịch sử JavaScript, đó là first-class function và prototype mechanism. Ngày nay, hầu hết developer đều biết rằng thừa kế trong JavaScript là prototype-based inheritance. Nhưng ở thời kỳ web còn hoang sơ, người ta hay dùng new và các hàm constructors để lập trình OOP trong JavaScript theo kiểu class-based, giống như bên Java vẫn làm. Classical inheritanceCổ thư ghi lại rất nhiều ví dụ kiểu này: 123456789101112function Dog(name) &#123; this.name = name; this.say = function() &#123; console.log('woof-woof, my name is ' + this.name); &#125;&#125;var rocky = new Dog('Rocky');rocky.say();var molly = new Dog('Molly');molly.say(); Hàm Dog gọi là Function Constructor, các tiền bối chân giới Đại Việt thủa trước chuyển ngữ thành “hàm dựng”. Còn chúng ta thời nay có lẽ cứ nên giữ nguyên văn. Prototypal inheritanceSang đầu kỷ thứ 3, ở tông môn Yahoo! có một vị trưởng lão tu vi rất cao thâm tên là Douglas Crockford tung ra bộ kỳ thư “JavaScript: The Good Parts”, trong đó có đoạn nhấn mạnh bản chất prototype trong JavaScript, sự khác biệt giữa classical inheritance và prototypal inheritance. Ông cho rằng từ khóa new mang theo nhiều điểm bất cập, nên khuyến khích dùng Object.create để sao chép nguyên mẫu sang đối tượng kế thừa. Tư tưởng của Douglas Crockford quả thực mới mẻ. Vào lúc đó, nhiều JavaScript engine còn chưa kịp hỗ trợ Object.create. Cuốn này vừa ra mắt đã gây náo loạn cả tin giới, trở thành sách gối đầu giường của rất nhiều tu sĩ. Object.create cho phép sao chép các properties hoặc protoype của đối tượng. Hàm Dog có thể được viết lại theo hướng prototypal inheritance như thế này: 1234567891011121314function Dog() &#123;&#125;Dog.prototype.say = function() &#123; console.log('woof-woof, my name is ' + this.name);&#125;var rocky = Object.create(Dog.prototype);rocky.name = 'Rocky';var molly = Object.create(Dog.prototype);molly.name = 'Molly';rocky.say();molly.say(); Không cần new nữa! Các cường giả sau đó nhanh chóng phát triển thêm nhiều cách tiếp cận prototypal inheritance khác, nổi bật nhất phải kể đến Concatenative inheritance, Prototype delegation và Functional inheritance. ES6 Class ngày nay chỉ vay mượn syntax của classical OOP để làm interface, còn bên trong nó chính là cơ chế prototypal inheritance. Object CompositionNhưng dù sao prototypal inheritance vẫn thuộc về OOP. Người tu luyện Functional Programming không cần new. Gần 10 năm sau bom tấn “The Good Parts”, Douglas Crockford lại một lần nữa khiến tin giới chấn động bằng “JavaScript: The Better Parts”. Thời điểm này, ông đã không còn dùng Object.create() nữa, cũng từ bỏ luôn this, for loops, for in, while… Tu vi của ông đã tiến thêm một bước lớn. Trong clip, ông nói về những tính năng mới của ES6 lúc ấy vẫn còn chưa chính thức xuất xưởng. Mấy lão quái kiệt này luôn đi trước thiên hạ vài năm. Đó cũng là khi trào lưu Functional Programming đang dần nóng trở lại, người ta bắt đầu nhắc đến khái niệm Object Composition. Đi cặp với new là this. Từ khóa this chẳng qua chỉ là kỹ xảo nhằm tạo ra một ngữ cảnh khu biệt (context) để thực thi các hàm. Trong JavaScript, mỗi hàm như 1 kết giới độc lập. Function khi được gắn lên object thì gọi là method. Ngữ cảnh method đó chạy thường chính là đối tượng sở hữu nó. Sau này mới sinh ra các thủ thuật bind, apply, call để đánh tráo context. Với những người mới học JavaScript, this đôi khi trở thành nỗi khiếp sợ. Rất khó debug các vấn đề phát sinh trong hàm nếu không biết chính xác ngữ cảnh chạy nó. Mà ngữ cảnh lại thường không ổn định. Đúng hơn, phải nói rằng chúng luôn luôn mutable. Người tu luyện Functional Programming không cần this. Đoạn code với classical OOP trên kia có thể viết lại thành: 12345678910111213141516171819202122const sayName = (state) =&gt; &#123; return Object.assign( state, &#123; say: () =&gt; &#123; console.log(`woof-woof, my name is $&#123;state.name&#125;`); &#125;, &#125; );&#125;;const createDog = (name) =&gt; &#123; let state = &#123; name, &#125;; return Object.assign(state, sayName(state));&#125;;const rocky = createDog('Rocky');rocky.say();const molly = createDog('Molly');molly.say(); Nhìn đâu cũng thấy functions. Không còn for/while, if/else, new/this. Liệu bạn đã sẵn sàng rời khỏi những phàm vật ấy? Hay nói như các nhà sư, liệu bạn có thể buông bỏ? Khi lối tư duy truyền thống đã ăn sâu vào tâm trí, hễ gặp vấn đề phân cấp đối tượng thì chúng ta sẽ nghĩ ngay đến OOP, class, prototype, inheritance… thậm chí coi chúng như giải pháp tất yếu, duy nhất. Hễ xử lý tập hợp là phải looping, hễ thấy có điều kiện thì chỉ biết dựa vào if… Đây là trở ngại rất lớn cho kẻ mới nhập đạo. Phải tìm cách rũ bỏ những thứ không cần thiết, thì mới đi xa được. Rời khỏi chúng, chỉ giữ lại một ý niệm duy nhất: FUNCTION! Nhất niệm “phân sần”! Ban đầu tất nhiên là sẽ khó khăn, lúng túng. Giống như hàng ngày bạn vẫn đi trên con đường quen thuộc từ nhà đến công sở rồi lại trở về nhà. Cho đến một hôm con đường đó bị cảnh sát chặn lại, bạn đành phải rẽ sang lối khác. Trên con đường xa lạ ấy, bạn không còn trông thấy những điểm mốc hàng ngày vẫn thấy: 1 shop lưu niệm, 1 cây xăng, 1 tiệm cầm đồ, sau ngã tư là đến ven sông, cây cầu sơn màu đỏ, một tiệm tạp hóa thường có cô em rất xinh ngồi trước cửa… Bạn không còn bắt gặp những dấu hiệu đã quen mắt. Bạn chẳng biết mình đã đi đến đâu, còn cách nhà bao nhiêu km nữa. Nhưng con đường nào đi lại vài lần thì cũng thành quen. Chẳng có gì đáng ngại. Vấn đề là, ngay khi bạn nhận thấy Functional Programming là thứ gì đó rất thú vị, đáng để học hỏi, vận dụng nó, bạn nên thực hiện ngay lập tức, đừng chờ đợi dịp nào thuận tiện, đừng chờ tìm được minh sư dẫn dắt. Nếu vậy, bạn sẽ khó mà rời khỏi lối mòn xưa cũ. Krishnamurti từng diễn giải một điều gần tương tự, đại ý thế này: Nếu bạn đi về hướng Bắc suốt những ngày tháng của cuộc đời bạn, giống như con người đã đi theo một hướng đặc biệt, rồi có người nào đó xuất hiện và nói, “Hướng đó không đúng”. Sau đó ông ta bảo bạn, “Đi về hướng Nam, hướng Đông, bất kỳ hướng nào, ngoại trừ hướng đó.” Và khi bạn thực sự chuyển động khỏi hướng đó, có một sự thay đổi ngay tại chính những tế bào não bởi vì bạn đã phá vỡ cái khuôn mẫu. Và cái khuôn mẫu đó phải được phá vỡ ngay lúc này, không phải bốn mươi năm hay một trăm năm sau.","categories":[],"tags":[{"name":"functional programming","slug":"functional-programming","permalink":"http://nthung2112.github.io/tags/functional-programming/"}]},{"title":"Functional Programming - Phần 2 - Nhập đạo","slug":"Functional-Programming-Phan-2-Nhap-dao","date":"2018-06-16T08:43:00.000Z","updated":"2018-06-23T08:53:54.125Z","comments":true,"path":"2018/06/Functional-Programming-Phan-2-Nhap-dao.html","link":"","permalink":"http://nthung2112.github.io/2018/06/Functional-Programming-Phan-2-Nhap-dao.html","excerpt":"Như vậy, Functional Programming là nghệ thuật lập trình trong đó ta: sử dụng functions để điều khiển workflow tuân thủ 2 nguyên tắc immutability và purity Nói cách khác, chư vị tin hữu muốn tu luyện Functional Programming thì phải giữ đạo tâm trong sáng, ý chí kiên định, hàng ngày chiêm nghiệm, suy diễn, cảm ngộ function, tu vi theo đó sẽ không ngừng thăng tiến. Nhưng làm thế nào để cảm ngộ “phân sần ý cảnh”? Ta phải nắm bắt, quan sát, tư duy, suy tưởng về function ra sao? Sau đây là những pháp quyết nhập môn.","text":"Như vậy, Functional Programming là nghệ thuật lập trình trong đó ta: sử dụng functions để điều khiển workflow tuân thủ 2 nguyên tắc immutability và purity Nói cách khác, chư vị tin hữu muốn tu luyện Functional Programming thì phải giữ đạo tâm trong sáng, ý chí kiên định, hàng ngày chiêm nghiệm, suy diễn, cảm ngộ function, tu vi theo đó sẽ không ngừng thăng tiến. Nhưng làm thế nào để cảm ngộ “phân sần ý cảnh”? Ta phải nắm bắt, quan sát, tư duy, suy tưởng về function ra sao? Sau đây là những pháp quyết nhập môn. Higher-order functionHigher-order function là một khái niệm đến từ Toán học. Bất cứ hàm nào tiếp nhận 1 function như tham số, hoặc trả về 1 function như kết quả, thì đều được coi là higher-order function. Dưới đây là 1 ví dụ, hàm getItem nhận vào hàm by mô tả điều kiện, lại trả về 1 hàm khác. Nó thừa tiêu chuẩn để gọi là higher-order function. 12345678const getItem = by =&gt; arr =&gt; by;// hoặc phiên bản chi tiếtconst getItem = (by) =&gt; &#123; return (arr) =&gt; &#123; return by(arr); &#125;;&#125;; Lập trình phong cách Functional Programming là khiêu vũ với các functions. Trong Functional Programming, hầu như mọi functions đều là higher-order function, vì chúng đều có thể nhận vào và ném ra các functions. Nhưng như vậy thì có lợi ích gì? Nó đơn giản cung cấp cho ta một cách khác để lập luận và suy diễn. Chẳng hạn như với hàm getItem trên kia cho phép bạn biến hóa rất nhiều dạng, tùy vào cách bạn thao túng by. Khi bạn viết getItem, bạn không cần biết sau này sẽ phải kiểm tra điều kiện ra sao, cũng không quan tâm sẽ nhận được đầu vào như thế nào. Bạn có thể tạo ra hàm tìm số lớn nhất trong 1 mảng toàn số như sau: 1234567891011// tạo hàm engine lấy max number từ mảngconst maxNumber = (arr) =&gt; &#123; return Math.max(...arr);&#125;;// rồi truyền vào getItem để được hàm cần thiếtconst getMaxNumber = getItem(maxNumber);// thử xem saogetMaxNumber([4, 6, 2, 3, 1, 8, 7, 5]);// =&gt; 8 Thế sao không truyền thẳng cái mảng số kia vào maxNumber cho khỏe? Vì trong thiết kế này ta đang cư xử với maxNumber như plugin. Còn nhiều plugins khác nữa. Ta không gọi trực tiếp plugin mà gọi qua 1 giao diện tổng quát hơn. Giờ ta lại có dữ liệu 1 nhóm người như sau: 12345678910111213141516171819202122const members = [ &#123; name: 'Alice', height: 165, &#125;, &#123; name: 'Bob', height: 152, &#125;, &#123; name: 'Celina', height: 178, &#125;, &#123; name: 'Dan', height: 194, &#125;, &#123; name: 'Eric', height: 187, &#125;,]; Ta muốn tìm người cao nhất trong nhóm thì sao? Hãy thêm 1 plugin khác. 12345678910111213// bạn tạo 1 hàm engine lấy max height từ mảngconst maxHeight = (people) =&gt; &#123; return people.reduce((prev, current) =&gt; &#123; return prev.height &gt; current.height ? prev : current; &#125;);&#125;;// rồi truyền vào getItem để được hàm cần thiếtconst getTallestPerson = getItem(maxHeight);// thử xem saogetTallestPerson(members);// =&gt; &#123; name: 'Dan', height: 194 &#125; Ví dụ trên tuy tầm thường, nhưng có thể là gợi ý tốt để bạn dùng higher-order function thiết kế những chương trình linh hoạt, dễ mở rộng. Function CompositionĐây là khái niệm Toán học mà tiếng Việt ta gọi là “hàm hợp”, hay “hàm phức hợp”. Mọi thứ trong Functional Programming đều có nguồn gốc Toán học. Function Composition là sự phối hợp, liên kết nhiều hàm lại với nhau, thành một hàm lớn, nhiều chức năng hơn. Có 2 kỹ thuật căn bản trong Function Composition là compose và pipe. ComposeHãy nhớ lại, trong không gian Functional Programming tồn tại vô số pure functions nhỏ gọn, đơn giản. Đúng triết lý “do one thing and do it well” của UNIX. Vì mỗi hàm chỉ làm 1 việc, khi muốn thực hiện nhiều hành động lên cùng một input, ta chỉ việc kết hợp các hàm cần thiết lại với nhau. Bây giờ chúng ta hãy tạm ngừng tu luyện, tạm quên tu vi để nhập phàm, quan sát và cảm ngộ nhân sinh. Lần này, bạn hóa thành con trai thứ 4 trong gia đình một thôn dân sinh sống dưới chân núi Tản Viên bằng nghề bán thịt… Một hôm bạn xin được khúc cây lớn ở chỗ ông chú làm kiểm lâm kiêm lâm tặc. Từ khúc gỗ này, bạn muốn làm ra cái thớt cho nhà dùng. Là tu sĩ mới nhập môn tu luyện Functional Programming, tuy không có tu vi, nhưng bạn vẫn hình dung được sẽ cần đến các pure functions sau: cưa(): nhận vào khúc gỗ, trả về từng khoanh tròn sấy(): nhận khoanh gỗ tươi, trả về khoanh gỗ khô bào(): nhận vào khoanh gỗ, trả về khoanh gỗ bằng phẳng khoan(): nhận vào khoanh gỗ, trả về khoanh gỗ có 2 lỗ (để gắn quai treo/móc lên cho gọn) chà(): nhận vào khoanh gỗ, trả về khoanh gỗ trơn láng (dùng giấy nhám, miền ngoài gọi giấy giáp, để đánh cho nhẵn bề mặt) móc(): nhận thớt không quai, trả về thớt có quai Mỗi hàm chỉ làm đúng 1 việc. Không hơn. Không kém. Khi đi qua chừng đó công đoạn, ta sẽ được sản phẩm mong muốn. Dĩ nhiên chúng ta đang muốn khúc gỗ được sửa đổi nên tạm bỏ qua vấn đề immutability. Đây là phiên bản mô phỏng: 1234567891011121314151617181920212223const cưa = (x) =&gt; &#123; return `$&#123;x&#125; đã cưa`;&#125;;const sấy = (x) =&gt; &#123; return `$&#123;x&#125; đã sấy`;&#125;;const bào = (x) =&gt; &#123; return `$&#123;x&#125; đã bào`;&#125;;const khoan = (x) =&gt; &#123; return `$&#123;x&#125; đã khoan`;&#125;;const chà = (x) =&gt; &#123; return `$&#123;x&#125; đã chà`;&#125;;const móc = (x) =&gt; &#123; return `$&#123;x&#125; đã gắn móc`;&#125;; Để tạo ra 1 cái thớt, ở thời viễn cổ xa xưa, các man sĩ thường code thế này: 123456789var thớt = cưa('khúc gỗ');thớt = sấy(thớt);thớt = bào(thớt);thớt = khoan(thớt);thớt = chà(thớt);thớt = móc(thớt);console.log(thớt);// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc 5 vạn năm sau, khi đã xuất hiện Toán học, các tộc nhân bộ lạc Giao Chỉ thời đại Hồng Bàng lại thích code như thế này: 123var thớt = móc(chà(khoan(bào(sấy(cưa('khúc gỗ'))))));console.log(thớt);// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc Đây chính là Toán học cơ bản. Với y = f(g(x)), ta tính g(x) trước, được bao nhiêu truyền vào f() là ra kết quả. Việc tính toán đi từ ngoặc trong cùng ra ngoài, mắt thường nhìn thấy là từ phải sang trái, từ g đến f. Lại thêm 5 ngàn năm nữa trôi qua. Lúc này đã có ES6. Một số cường giả Functional Programming sáng tạo ra phương thức compose, như thế này: 123const compose = (...fns) =&gt; &#123; return fns.reduce((f, g) =&gt; (x) =&gt; f(g(x)));&#125;; Bạn có thể dùng Babel dịch sang ES2015 cho dễ hiểu. Ý tưởng của compose là xếp cuốn chiếu các hàm lại với nhau, theo thứ tự từ trái sang phải để tạo ra một hàm mới, mà khi được thực thi, nó sẽ lần lượt gọi các hàm đã truyền vào trước đó theo thứ tự ngược lại, từ phải sang trái. Tức là nếu y = compose(f, g), thì y(x) = f(g(x));Nó sẽ tính g(x) trước rồi truyền kết quả cho f;Giả sử g(x) = z thì y(x) = f(z); Nếu bạn vẫn thấy mơ hồ thì cứ xem cái này là Đạo. Chỉ có thể cảm ngộ, không thể giảng được bằng lời! Trở lại với cái thớt. Hàm compose tất nhiên là higher-order function. Ta sẽ thử xem nó làm việc ra sao: 123const quăng_cho_tao_cái_thớt = compose(móc, chà, khoan, bào, sấy, cưa);console.log(quăng_cho_tao_cái_thớt.toString());// =&gt; bạn đoán xem log ra thứ gì? Bây giờ ta có 1 hàm, gọi là quăng_cho_tao_cái_thớt(), kết quả của sự lắp ghép bằng compose tất cả các pure functions ở trên. Ta biết compose sẽ gọi từ phải sang trái, nên công đoạn nào làm trước thì để bên phải. Chạy thử 1 phát: 123const thớt = quăng_cho_tao_cái_thớt('khúc gỗ');console.log(thớt); // =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc Vậy là đủ công đoạn, khúc gỗ đã trở thành một cái thớt tốt. Nhưng chưa hết. Khi bạn treo cái thớt đó ở nhà, nhiều người quen đến chơi thấy đẹp hỏi mua. Nhiều đến mức bạn quyết định kinh doanh thớt. Làm thớt kinh doanh thì phải gán nhãn, vậy là bạn tạo ra một pure function mới và dùng compose để làm khuôn sản suất loại thớt commercial này. Dễ ợt, không ảnh hưởng gì đến loại thớt cho nhà dùng. 12345const nhãn = (x) =&gt; &#123; return `$&#123;x&#125; đã dán nhãn`;&#125;;const làm_thớt_để_bán = compose(nhãn, móc, chà, khoan, bào, sấy, cưa); Hoặc tận dụng lại khuôn mẫu cũ: 1const làm_thớt_để_bán = compose(nhãn, quăng_cho_tao_cái_thớt); Thử xem sao: 123const thớt_bán = làm_thớt_để_bán('khúc gỗ');console.log(thớt_bán);// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã móc đã dán nhãn Để mở rộng thị phần, hướng đến phân khúc giá rẻ, bạn tạo ra dòng sản phẩm thớt tầm trung, dùng chip MediaTek, bỏ qua bước sấy khô và đánh bóng để giảm giá thành. Rất đơn giản: 1const làm_thớt_loại_hai = compose(nhãn, móc, khoan, bào, cưa); Thử xem sao: 123const thớt_loại_hai = làm_thớt_loại_hai('khúc gỗ');console.log(thớt_loại_hai);// =&gt; khúc gỗ đã cưa đã bào đã khoan đã móc đã dán nhãn Lập trình như vậy phải nói là vô cùng tao nhã, lịch thiệp! Đôi khi tôi cảm thấy phong cách lập trình Functional Programming có sự thanh tịnh đầy chất quý tộc, vừa bình dân lại vừa hàn lâm, đẹp đến mức khó hiểu! Nếu dùng OOP, có thể chúng ta còn đang loay hoay giữa một đống class Máy Cưa, Máy Bào, Máy Khoan… Hoặc 1 class Máy Làm Thớt khổng lồ có đủ methods cưa, bào, khoan… Rồi còn một mớ properties mà ta phải cân nhắc xem cái nào public, cái nào private. Rồi phải tạo instance, thừa kế qua lại mấy vòng may ra mới làm được cái thớt. Muốn thêm dòng sản phẩm lại càng khó khăn. Phải tạo class Thớt_nhàdùng, extend ra Thớtđểbán, Thớtđể_bán_loại_2, phiền phức không sao kể xiết! Functional Programming thì chỉ cần mấy hàm đơn giản, rời rạc, dùng compose lắp ráp lại như lắp ráp dây chuyền công nghệ là chế được các kiểu thớt. Function Composition tựa như một nhà máy hiện đại, mỗi chi tiết linh kiện được xử lý bằng một robot chuyên trách, kết hợp lại với nhau một cách khoa học để tạo ra sản phẩm hoàn thiện. PipeMột biến thể của compose là pipe, vận hành theo chiều ngược lại. Ta có thể implement bằng cách đảo vị trí f và g thế này: 123const pipe = (...fns) =&gt; &#123; return fns.reduce((f, g) =&gt; (x) =&gt; g(f(x)));&#125;; Hoặc giữ nguyên code của compose nhưng thay reduce bằng reduceRight: 123const pipe = (...fns) =&gt; &#123; return fns.reduceRight((f, g) =&gt; (x) =&gt; f(g(x)));&#125;; Vì pipe tổ hợp các hàm theo chiều ngược lại so với compose nên ta viết: 1const làm_thớt_dỏm = pipe(cưa, bào, nhãn); Thử xem sao: 123const thớt_dỏm = làm_thớt_dỏm('khúc gỗ');console.log(thớt_dỏm);// =&gt; khúc gỗ đã cưa đã bào đã dán nhãn Dùng pipe có vẻ thuận mắt hơn. Thứ tự các bước cưa, bào… trông khá tự nhiên. Nếu bạn quen với cách suy luận Toán học thì bạn sẽ thích compose. Còn nếu bạn muốn trực quan dễ hiểu thì cứ dùng pipe. compose và pipe là những thuật pháp nhập môn dễ học, dễ dùng, nhưng không kém uy lực, thư viện Functional Programming nào cũng có. Trong Ramda.js, ngoài compose và pipe, các tác giả còn bổ sung thêm pipeK, pipeP, composeK, composeP. Khi đã thông thạo, bạn hoàn toàn có thể tạo ra compose theo cách của bạn. Ví dụ composeBinary liên kết các hàm từ giữa sang 2 bên thay vì từ đầu này đến đầu kia, composeRandom liên kết các hàm không theo trật tự cố định… Đó là không gian sáng tạo thuộc về riêng bạn. Currying functionThuật ngữ currying và các dạng curry, curried của nó trong khoa học máy tính được Christopher Strachey đặt ra từ năm 1967 để ghi nhớ công lao của Haskell Brooks Curry, một nhà Toán học và Luận lý học người Mỹ. Currying function là làm cho 1 function trở thành “curried function”. Cái function ban đầu đó hơi ngốc nghếch, nó cần bạn truyền vào N tham số để tính toán, mà nếu thiếu 1 tham số, nó sẽ không chạy. Ví dụ hàm sum thế này: 123const sum = (a, b, c) =&gt; &#123; return a + b + c;&#125;; sum cần 3 tham số để cộng dồn lại, nếu thiếu, sẽ không tính toán ra được. 12345678// có thể ra sânsum(5, 3, 2); // =&gt; 10sum(4, 4, 2); // =&gt; 10sum(4, 3, 3); // =&gt; 10sum(3, 5, 2); // =&gt; 10// nhưngsum(4, 5); // =&gt; NaN Đây là thiếu tiền đạo cả đội không chịu ra sân tập! Nhưng cuộc sống đâu phải lúc nào cũng thuận lợi, đầy đủ cho chúng ta? Dù cả mấy tiền đạo đều bị chấn thương, treo giò, trốn tập thì các anh còn lại vẫn phải có trách nhiệm ra sân chứ! Currying chính là kỹ thuật biến hàm sum ngốc đó trở thành một function vi diệu hơn, nếu bạn gọi nó với 1 tham số, nó sẽ trả về 1 hàm tạm thời, giữ lại tham số đó, chờ khi nào đủ 3 tham số thì mới thực hiện tính toán. Hình dung bạn tổ chức một buổi party, mời 3 người bạn tham gia. Lúc này đã có mặt 2 người, còn 1 người đến muộn. Bạn quyết định không cần chờ nữa. Bữa tiệc cứ bắt đầu đã, chừng nào người kia đến thì tính tiếp. Đây là 1 cách implement cho hàm curry: 123456789101112131415161718const curry = (fn) =&gt; &#123; let totalArguments = fn.length; let next = (argumentLength, rest) =&gt; &#123; if (argumentLength &gt; 0) &#123; return (...args) =&gt; &#123; return next( argumentLength - args.length, [ ...rest, ...args, ] ); &#125;; &#125; return fn(...rest); &#125;; return next(totalArguments, []);&#125;; Và curry tất nhiên cũng là higher-order function. Thử dùng với sum xem sao: 1const curriedSum = curry(sum); curriedSum bây giờ là phiên bản curried của hàm sum trước đó. 123456curriedSum(4, 4, 2); // =&gt; 10curriedSum(4, 3, 3); // =&gt; 10curriedSum(3, 5, 2); // =&gt; 10// vàcurriedSum(5, 3); // =&gt; [Function] curriedSum(5, 3) là 1 function. Nó đang chờ đợi tham số cuối cùng xuất hiện. Nếu bây giờ ta gọi nó với 1 tham số thì kết quả sẽ được tính toán ra: 1curriedSum(5, 3)(2); // =&gt; 10 Nếu ta truyền nhiều hơn số lượng tham số còn thiếu thì sao? Ở đây là 1 tham số cuối cùng. Theo cách implement trên thì nó sẽ bỏ qua các tham số dư thừa. Các phiên bản curry của Ramda.js và Lodash FP cũng hành xử như vậy. 1curriedSum(5, 3)(2, 4, 8); // =&gt; 10 Một điểm quan trọng nữa là ta có thể phân tách hàm gốc ra từ 1 đến N phần, với N là số lượng tham số của hàm gốc đó. Chẳng hạn, nếu hàm gốc có 3 tham số, ta có thể chia nó ra 1, 2 hoặc 3 phần. Những cách viết sau là tương đương: 1234curriedSum(3, 5, 2);curriedSum(3, 5)(2);curriedSum(3)(5, 2);curriedSum(3)(5)(2); curry, cũng như compose và pipe là những kỹ thuật căn bản, ai cũng phải học, phải biết. Mọi ngôn ngữ được thiết kế với tư tưởng Functional Programming như Haskell, Scalla, Elm… đều có sẵn các hàm này. Chúng rất tinh tế và được dùng ở khắp nơi. Chỉ cần thành thạo 3 pháp quyết này thì bạn đã được xem như đệ tử Functional Programming chân chính.","categories":[],"tags":[{"name":"functional programming","slug":"functional-programming","permalink":"http://nthung2112.github.io/tags/functional-programming/"}]},{"title":"Functional Programming - Phần 1 - Con đường sáng","slug":"Functional-Programming-Phan-1-Con-duong-sang","date":"2018-06-12T08:35:00.000Z","updated":"2018-06-23T08:53:43.941Z","comments":true,"path":"2018/06/Functional-Programming-Phan-1-Con-duong-sang.html","link":"","permalink":"http://nthung2112.github.io/2018/06/Functional-Programming-Phan-1-Con-duong-sang.html","excerpt":"Lúc bấy giờ, Tin giới Tây phương xuất hiện 2 lão quái Nguyên Anh hậu kỳ đỉnh phong, chỉ thiếu nửa bước cảm ngộ ý cảnh là đột phá tới cảnh giới Hóa Thần. Một người là Đồ Linh tôn giả - tức Alan Turing, nổi danh với pháp môn Turing Machine. Người kia là Khâu Kỳ thượng tiên, Alonzo Church, tung hoành tam giới bằng đạo thuật Lambda Calculus (1). Turing Machine của Alan Turing và Lambda Calculus của Alonzo Church thực ra là hai cách tiếp cận nguyên lý xử lý tính toán trong computer, thường được giới chuyên môn gọi chung là Luận đề Church - Turing (The Church-Turing Thesis).","text":"Lúc bấy giờ, Tin giới Tây phương xuất hiện 2 lão quái Nguyên Anh hậu kỳ đỉnh phong, chỉ thiếu nửa bước cảm ngộ ý cảnh là đột phá tới cảnh giới Hóa Thần. Một người là Đồ Linh tôn giả - tức Alan Turing, nổi danh với pháp môn Turing Machine. Người kia là Khâu Kỳ thượng tiên, Alonzo Church, tung hoành tam giới bằng đạo thuật Lambda Calculus (1). Turing Machine của Alan Turing và Lambda Calculus của Alonzo Church thực ra là hai cách tiếp cận nguyên lý xử lý tính toán trong computer, thường được giới chuyên môn gọi chung là Luận đề Church - Turing (The Church-Turing Thesis). Turing Machine đặt cơ sở trên việc nắm giữ state machine và trạng thái tiến trình, còn ý tưởng Lambda Calculus được xây dựng trên các tính chất của hàm toán học. Lấy tu vi của bổn tiên hiện giờ thì chưa lĩnh hội được mấy thứ cao siêu như vậy, nên không dám lạm bàn ở đây. Chỉ biết rằng, 2 thuật pháp kể trên là khởi nguồn của 2 trường phái tu luyện mạnh nhất trong tin giới hiện nay: Object Oriented Programming và Functional Programming. Có khá nhiều cơ chế lập trình - Programming Paradigm. OOP và Functional Programming chỉ là 2 trong số đó. Trong cuốn “Programming Paradigms for Dummies: What Every Programmer Should Know“, tác giả Peter Van Roy đưa ra mô hình tổng hợp quan hệ giữa các cơ chế lập trình như thế này: Trong lịch sử công nghệ, có vẻ OOP chiếm ưu thế hơn so với Functional Programming. Bạn cứ thử nhìn xung quanh mình là biết, từ thời tập tành code đã thấy thiên địa tràn ngập quy tắc OOP rồi. Các job description, các buổi interview đều nhắc đến OOP như pháp thuật căn bản. Thảo luận kỹ thuật hầu hết xoay quanh mấy khái niệm Class, Object, Inheritance, rồi cao hơn thì SOLID, Polymorphism, Encapsulation… Nhưng, trên thế giới, từ thời Lisp đến FP, rồi Haskell, Elixir, chưa bao giờ thiếu vắng những tu tin giả đi theo con đường Functional Programming. Nhất là khoảng sau 2010, không rõ vì sao người ta bắt đầu phàn nàn nhiều hơn về OOP, trích dẫn nhiều hơn luận điểm banana/gorilla của Joe Armstrong (2), theo đó, chủ đề “Functional Programming” bắt đầu nóng dần trở lại. Tôi biết đến Functional Programming vào khoảng 2015 qua một talk show trên YouTube của “chú Bob“, nhưng không hiểu lắm nên cũng không chú ý. Phải sang 2016, tôi mới chính thức tìm hiểu sâu về Functional Programming sau khi đọc 2 loạt bài viết “Composing Software“ của Eric Elliott và “So You Want to be a Functional Programmer“ của Charles Scalfani trên Medium. Eric Elliott lần lượt giải thích từng concepts của Functional Programming một cách tường tận, dễ hiểu. Còn Charles Scalfani đúng là fan cuồng Functional Programming. Anh trình bày nó dưới dạng một hệ thống triết lý, thế giới quan đặc sắc. Thậm chí, Scalfani còn đề cao Functional Programming như nấc thang tiến hóa trong lịch sử lập trình. Lối viết của anh gây ấn tượng cực mạnh. Trước đó, Scalfani còn có bài “Goodbye, Object Oriented Programming“ gây tranh luận sôi nổi. Nhưng bạn đọc nên lưu ý, Functional Programming không bài xích OOP. Chúng chỉ là những con đường tu luyện khác nhau, cùng hướng về Đại Đạo. Trong khi viết code, ta hoàn toàn có thể phối hợp nhiều cơ chế lập trình khác nhau, miễn sao đạt đến kết quả Đúng - Nhanh - Ổn - Đẹp. ReactJS là một ví dụ tiêu biểu, có thể coi nó như 7 phần Functional Programming + 3 phần OOP. Về điểm này, Anjana Vakil có một bài thuyết trình rất hay ở GOTO 2017. Dù sao, từ đó đến nay, khuynh hướng tư duy Functional Programming vẫn từng bước lan rộng, ảnh hưởng đến thiết kế của rất nhiều chương trình hiện đại. Chỉ cần để ý một chút, chúng ta có thể nhận ra các đặc tính nổi bật của Functional Programming xuất hiện trong hầu hết frameworks và các bản cập nhật ngôn ngữ mới. Thậm chí, nếu xét kỹ, những khái niệm thoạt nhìn có vẻ không liên quan như WebComponent, Serverless, Microservice… cũng ẩn hiện tư tưởng Functional Programming. Và tôi gần như không còn đụng tới class, new, this nữa. What’s Functional Programming?Vậy rốt cuộc Functional Programming là cái gì? Nếu google bạn sẽ tìm thấy hàng tá cách giải thích khác nhau. Còn tôi chủ chương nên định nghĩa ngắn gọn thế này: Functional Programming là phương pháp lập trình lấy function làm đơn vị thao tác cơ bản. Đúng vậy. Functional Programming xét về lý tưởng thì chỉ có function, function và function. Không lệnh gán (assignment statements), không cần tới các biến (variables), không lưu giữ trạng thái toàn cục (global state). Trong Functional Programming, chúng ta điều khiển dòng chảy chương trình bằng cách phối hợp các functions lại với nhau. Chúng ta tung hứng các functions qua lại, nhận vào function, nhả ra function, lồng ghép, xâu chuỗi, biến hóa chúng theo mọi cách có thể nghĩ ra. Đó gọi là không gian “first-class functions“, nơi lập trình viên đối xử với functions như “first-class citizens”. Ở đâu functions được coi trọng như vậy, ở đó ta có thể lập trình theo cơ chế Functional Programming. JavaScript, Python, Golang, ngay cả PHP chính là như vậy. Java tính từ v8.0 ra mắt năm 2017 cũng là như vậy. Dù không hoàn hảo như Haskell, F#, etc - những tu chân giới vốn được sinh ra cho Functional Programming - nhưng ta vẫn có thể tu luyện Functional Programming được… Chỉ có điều phải vận dụng khác một chút, linh hoạt hơn một chút. Đó là lý do tại sao trong các chương trình JavaScript, Python, dù viết theo phong cách Functional Programming nhưng vẫn phải dùng đến các biến, lệnh gán để thao tác. Các tu tin giả tầng thấp muốn bắt đầu con đường Functional Programming cần phải nắm bắt những khái niệm cơ bản như Immutability, Purity, Higher-order functions, Currying function, Function Composition… Sau khi thăng cấp cảnh giới cao hơn thì có thể tìm hiểu Monad, Functor, Setoid, Idempotent, Lens… và nhiều nữa. Nào, bây giờ hãy bắt đầu hành trình… ImmutabilityImmutability nghĩa là tính bất biến. Nguyên tắc thứ nhất trong Functional Programming là: cái nào đã khai báo một lần thì mãi mãi như vậy, không bao giờ thay đổi nữa. Các biến hoặc đối tượng trong kịch bản Functional Programming nếu có thì phải immutable. Code thế này không phải là Functional Programming vì x và y bị thay đổi. 123456var x = 5;var y = 2;while (x &lt; 10) &#123; y += x; x++;&#125; Mutable là điều tối kỵ trong Functional Programming. Cần phải hạn chế đến mức thấp nhất. Các mẫu coding convention và best practices thông dụng hiện nay đều khuyến khích sử dụng const để khai báo, bỏ hẳn var , và dùng let đúng liều lượng. Đối với Object, ta nên dùng Object.freeze để lock toàn bộ thuộc tính. Cũng có thể dùng Object.defineProperty, Object.defineProperties để lock một số thuộc tính quan trọng. Các giải pháp này đều chỉ hỗ trợ 1 cấp thuộc tính. Phải chủ động code thêm nếu muốn áp dụng lên các thuộc tính con. Nếu dự án đủ phức tạp, hãy cân nhắc sử dụng các thư viện chuyên dụng như Immutable.js, Baobap… PurityPurity là tính thuần khiết, thuần túy, sự trong sạch, không bị pha tạp. Đây là nguyên tắc thứ hai trong Functional Programming: tất cả các hàm đều phải là pure function, không có hiệu ứng phụ (side effect), không được tác động lên bất cứ giá trị nào bên ngoài nó, cũng nói không với chỉnh sửa tham số input. Hàm dưới đây không phải pure function vì nó chỉnh sửa DOM element bên ngoài và thay đổi giá trị chứa trong localStorage. 123456const updateView = (html) =&gt; &#123; let $view = document.getElementById('panel'); $view.innerHTML = html; localStorage.setItem('panelCache', html); return $view;&#125; Đặc điểm quan trọng nữa của pure function là với mỗi tập giá trị đầu vào nhất định, luôn có 1 và chỉ 1 kết quả trả về tương ứng. Đây là tính chất của hàm số toán học. Hàm dưới đây không phải pure function vì trả về kết quả khác nhau cho cùng đầu vào: 123const getDuration = (timestamp) =&gt; &#123; return Date.now() - timestamp;&#125;; Pure function trong Functional Programming thường ngắn gọn, đơn giản và chỉ xử lý duy nhất 1 vấn đề logic. Đây là 1 pure function kinh điển: 123const add = (a, b) =&gt; &#123; return a + b;&#125;; Dù bạn có gọi hàng triệu lần thì add(3, 2) vẫn luôn trả về 5. Viết unit test cho pure function là nhiệm vụ dễ chịu như dạo chơi cùng một thiếu nữ ngây thơ trong trắng vậy! Immutability và Purity là 2 đặc trưng cơ bản nhất của Functional Programming, cho phép phân biệt với các cơ chế lập trình khác. Tu tin giả tu luyện theo con đường này nhất định phải giữ tâm niệm “immutable” và “pure” trong từng sát na. Chú thích1, Chữ Tàu ghi Alan Turing là 艾伦图灵 - Ngải Luân Đồ Linh, Alonzo Church là 阿隆佐邱奇 - A Long Tá Khâu Kỳ. 2, “You wanted a banana but you got a gorilla holding the banana”.","categories":[],"tags":[{"name":"functional programming","slug":"functional-programming","permalink":"http://nthung2112.github.io/tags/functional-programming/"}]},{"title":"Cấu trúc projects và đặt tên components trong React","slug":"Cau-truc-projects-va-dat-ten-components-trong-React","date":"2018-05-26T16:02:00.000Z","updated":"2018-05-26T13:12:57.001Z","comments":true,"path":"2018/05/Cau-truc-projects-va-dat-ten-components-trong-React.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Cau-truc-projects-va-dat-ten-components-trong-React.html","excerpt":"Như bạn đã biết, React chỉ là một thư viện nên nó không chỉ rõ cho người dùng cách tổ chức, phân chia cấu trúc thư mục cho dự án của mình. Xét trên một khía cạnh, có thể điều này là tốt vì dev có thể thoải mái thử rất nhiều cách khác nhau để chọn ra phương pháp phù hợp với dự án của mình. Tuy nhiên, nó lại khiến cho những dev mới bắt đầu sử dụng React cảm thấy khó hiểu. Bài viết này sẽ đưa ra một vài phương pháp phân chia folders, files giúp cho ứng dụng React của bạn có thể mở rộng một cách thuận tiện, nhất là đối với những người mới bước chân vào React và không biết phải làm như thế nào cho hợp lý.","text":"Như bạn đã biết, React chỉ là một thư viện nên nó không chỉ rõ cho người dùng cách tổ chức, phân chia cấu trúc thư mục cho dự án của mình. Xét trên một khía cạnh, có thể điều này là tốt vì dev có thể thoải mái thử rất nhiều cách khác nhau để chọn ra phương pháp phù hợp với dự án của mình. Tuy nhiên, nó lại khiến cho những dev mới bắt đầu sử dụng React cảm thấy khó hiểu. Bài viết này sẽ đưa ra một vài phương pháp phân chia folders, files giúp cho ứng dụng React của bạn có thể mở rộng một cách thuận tiện, nhất là đối với những người mới bước chân vào React và không biết phải làm như thế nào cho hợp lý. Cấu trúc files và foldersMột trong những câu hỏi dev thường gặp phải khi bắt đầu code là “Làm thế nào dể phân chia files và folders”. Để thuận tiện thì chúng ta sẽ bắt đầu từ cấu trúc đơn giản nhất mà package create-react-app đã tạo ra. Cụ thể là folder src. Đây là folder chính chứa source code, vì vậy chúng ta sẽ tập trung vào phần này. Toàn bộ những files, folder khác nằm ngoài vẫn sẽ được giữ nguyên: Tách riêng thành folder Containers và ComponentsCó thể bạn đã thấy trong một vài dự án, dev thường sử dụng hai folders có tên Components và Containers 123src├─ components └─ containers Thoạt nhìn thì có vẻ ổn, nhưng cách phân chia như trên còn tồn tại những nhược điểm như sau: Định nghĩa chức năng một cách không rõ ràng - Sử dụng cấu trúc như trên có thể gây nhầm lẫn, hiểu lần về chức năng của mỗi folder Container và Component , có nhiều người sẽ hiểu chức năng của mỗi folder theo ý khác nhau. Có người thì hiểu Containers là các components thực hiện việc xử lý logic (như handle click, button) và lấy dữ liệu từ server, còn components có nghĩa Presentational Component, thực hiện nhiệm vụ hiển thị view cho người dùng. Có người lại sử dụng Containers để chứa những route components (mỗi component là một link route, nếu như bạn sử dụng react-router), còn Components thì chứa những base component để tạo nên các route components kia. Vì thế khi làm việc trong team sẽ gây ra không đồng nhất và các member khó thống nhất trong việc sử dụng hai folder này. Components không còn linh động, reusable - Ngay cả khi bạn đã code ra một components với chức năng đặc thù, sau này bạn vẫn phải sửa lại components đó do những lí do như đổi requirements, thêm chức năng,… khiến cho file chuyển qua chuyển lại giữa 2 folders components và containers. Components trùng tên - Khi sử dụng react, tên của một component nên có ý nghĩa như chức năng của nó, và quan trọng là không nên có nhiều components trùng tên nhau trong project để tránh gây nhầm lẫn. Cách tổ chức folders như trên sẽ tạo ra 2 components có tên giống nhau, một sử dụng cho container, một sử dụng cho components (presentational - hiển thị) Giảm hiệu suất code - Bạn sẽ phải thường xuyên navigate giữa 2 folder trên khi viết cho một tính năng, do một tính năng thường sẽ gồm cả 2 loại components Một cách phân chia khác cũng có cấu trúc 2 folder như trên, nhưng phân biệt dựa trên module . Giả sử ứng dụng của bạn có một module User. Trong đó sẽ tách ra thành 2 folder components và containers: 1234src└─ User ├─ components └─ containers Theo hướng tiếp cận trên, dev sẽ không phải gặp khó khăn trong việc navigate giữa các folder khi code. Bạn sẽ không phải kéo lên, kéo xuống để tìm xem components của User ở đâu, khi đang hoàn thiện file trong containers để đối chiếu. Tuy nhiên, cách này sẽ sinh ra một đống folder containers và components nếu như hệ thống của bạn lớn và cót rất nhiều modules. Như vậy, việc tách biệt 2 folder components và containers không hẳn là hợp lý. Thay vì tách riêng ra như vậy, các components sẽ được đặt hết trong folder components ngoại trừ những components sử dụng làm screens Tái cấu trúc folders dựa trên moduleTrong folder components, chúng ta sẽ nhóm các files lại theo module hoặc feature/tính năng. Với tính năng CRUD user, chúng ta chỉ cần module User, nên folder tree sẽ có dạng như sau: 12345src└─ components └─ User ├─ Form.jsx └─ List.jsx Khi component được cấu thành bời nhiều hơn một file (chẳng hạn như phải import nhiều components khác, hay file chỉnh sửa css cho component đó), chúng ta sẽ đưa component này cùng các files liên quan vào một folder có cùng tên. Ví dụ như Form.jsx cần thêm Form.css để chỉnh style, bạn sẽ có một folder như sau: 1234567src└─ components └─ User ├─ Form │ ├─ Form.jsx │ └─ Form.css └─ List.jsx UI componentsNgoài các folder dành cho module hay tính năng trong ứng dụng của bạn, có thể thêm một folder _UI_ (hoặc base/atomic) dùng cho các component dạng UI - là những phần tử nhỏ sử dụng cho UI trong ứng dụng của bạn. Đây là những component giống các thư viện open source, thường được dùng đi dùng lại nhiều lần trong ứng dụng của bạn, không nhất thiết phải là một module lớn và không thực hiện các business logic. Những ví dụ về components dạng này như Button, Checkbox, SelectBox, Modal, DatePicker, BreadCrumb,… Đặt tên cho componentsỞ phần trên chúng ta đã thấy được cách hệ thống files và folder trong ứng dụng, còn bây giờ sẽ tìm hiểu xem đặt tên components ra sao cho phù hợp. Như đã đề cập ở trên, tên của components nên rõ ràng và không bị trùng lặp để có thể dễ tìm lại và tránh nhầm lẫn cho những thành viên khác trong team. Ngoài ra, tên components rõ ràng cũng giúp cho việc debug bằng những extension tools trở nên dễ dàng hơn trên trình duyệt (chẳng hạn như React Dev Tools) - vì khi app của bạn gặp lỗi khi đang chạy thì lỗi sẽ hiển thị ở đúng components xảy ra lỗi. Để đặt tên components, chúng ta sẽ đặt theo hướng path-based-component-naming, nghĩa là cấu thành bởi đường dẫn từ folder src/components đến file chúng ta tạo component đó. Chẳng hạn, bạn có một file với đường dẫn src/components/User/List.jsx thì tên component được sử dụng trong List.jsx sẽ được đặt là UserList: 1class UserList extends React.Component Nếu một file trong folder trùng tên với tên folder, chúng ta sẽ không cần phải lặp lại cả tên folder lẫn tên file. Chẳng hạn, có một file src/components/User/Form/Form.jsx thì thay vì sử dụng UserFormForm, chúng ta sẽ đặt là UserForm. Việc đặt tên components theo đường dẫn như trên có những ích lợi như sau: Việc search file trong text editor/IDE trở nên thuận tiện hơn - Chỉ cần gõ vào ô search của IDE hay text editor mà bạn sử dụng là có thể tìm đến file một cách nhanh chóng. Hoặc navigate đến file cũng rất thuận tiện: Tránh lặp đi lặp lại tên khi import Theo cách đặt tên như vậy, bạn sẽ luôn đặt tên file giống với chức năng, nhiệm vụ của nó. Đối với component form ở trên, chính xác thì phải là user form, nhưng do file đã nằm trong folder User nên chúng ta không cần lặp lại từ đó trong tên file của component, mà chỉ cần sử dung Form.jsx Có nhiều trường hợp, dev viết app React và đặt tên file/folder cũng như tên component một cách đầy đủ, bao gồm cả tên module lớn và nhỏ, và dần dần sau này khi app scale lên thì việc đặt tên này sẽ trở nên phức tạp hơn rất nhiều. Thử so sánh hai trường hợp sau đây: 123import ScreensUserForm from './screens/User/UserForm';// vsimport ScreensUserForm from './screens/User/Form'; Đối với module nhỏ với ít thành phần như trên thì cách đặt tên thứ hai có vẻ như không tạo nhiều khác biệt lắm, ta có thể thấy cách viết thứ nhất vẫn ổn. Tuy nhiên, nếu như app của bạn scale lên với nhiều thành phần, module, chức năng phức tạp thì việc đặt tên như vậy sẽ trở nenen vô cùng kinh khủng: 123import MediaPlanViewChannel from '/MediaPlan/MediaPlanView/MediaPlanViewChannel.jsx';// vsimport MediaPlanViewChannel from './MediaPlan/View/Channel'; Chưa kể những dòng như thế này còn lặp lại nhiều lần vì phải import nhiều thành phần cùng lúc…. Ví lí do đó, chúng ta nên đặt tên file và folder đúng với chức năng/nhiệm vụ trực tiếp của nó, thay vì thêm vào tên của những module cha. Còn tên component thì nên đặt theo đường dẫn tương đối so với folder src/components. Screens components - Dùng cho một view pageỞ trên, bài viết có nhắc đến những compoents không được đặt trong folder components, được gọi là screens. Giống như tên gọi của nó, đây là những components tượng trưng cho một màn hình hiển thị trong ứng dụng của bạn Lấy ví dụ đối với tính năng CRUD users, chúng ta sẽ có những màn hình cơ bản nhất bao gồm: List users (/users Create user (/user) Edit user (/users/:id) Như vậy, chúng ta có 3 screens khác nhau. Mỗi screen là một component cấu thành lên một page trong ứng dụng react của bạn. Screen component nên là một presentational component và không nên thực hiện xử lý business logic. Các screens sẽ nằm trong một folder screens song song với components trong đường dẫn src, vì mỗi component ở trong sẽ đại diện cho route của ứng dụng, thay vì một module nào đó: 123456src ├─ components └─ screens └─ User ├─ Form.jsx └─ List.jsx Nếu ứng dụng của bạn sử dụng react-router, chúng ta sẽ giữ một file Root.jsx trong folder screens và đưa toàn bộ các view route vào trong file này: 123456789101112131415161718import React, &#123; Component &#125; from 'react';import &#123; Router &#125; from 'react-router';import &#123; Redirect, Route, Switch &#125; from 'react-router-dom';import ScreensUserForm from './User/Form';import ScreensUserList from './User/List';const ScreensRoot = () =&gt; ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path=\"/user/list\" component=&#123;ScreensUserList&#125; /&gt; &lt;Route path=\"/user/create\" component=&#123;ScreensUserForm&#125; /&gt; &lt;Route path=\"/user/:id\" component=&#123;ScreensUserForm&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt;);export default ScreensRoot; Với cách này chúng ta đã đưa toàn bộ screens vào trong một folder có cùng tên với định nghĩa route: user/ -&gt; User/. Folder User chứa màn hình List và màn hinh Form bên trong. Từ đó bạn có thể dễ dàng tìm thấy màn hình nào render route nào bằng cách nhìn vào url. Một màn hình có thể sử dụng để render nhiều route, như chúng ta thấy màn hình Form sẽ render 2 route dành cho việc Create và Edit. Chú ý rằng, chúng ta nên thêm prefix Screen khi đặt tên cho các screen, để tránh nhầm lẫn với các component trong folder components. Như vậy tên của screen component đặt trong folder src/screens/User/List.jsx nên được đặt là ScreenUserList: 12345678910111213import React from 'react';import UserForm from '../../components/User/Form/Form';const ScreensUserForm = (&#123; match: &#123; params &#125; &#125;) =&gt; ( &lt;div&gt; &lt;h1&gt; &#123;`$&#123;!params.id ? 'Create' : 'Update'&#125;`&#125; User &lt;/h1&gt; &lt;UserForm id=&#123;params.id&#125; /&gt; &lt;/div&gt;);export default ScreensUserForm; Như trong đoạn code trên thì screen component sẽ không xử lý gì liên quan đến state (data) mà chỉ thực hiện render ra component UserForm. Cuối cùng thì chúng ta sẽ có được một cấu trúc folder như sau: 1234567891011121314src├─ components │ ├─ User│ │ ├─ Form│ │ │ ├─ Form.jsx│ │ │ └─ Form.css│ │ └─ List.jsx│ └─ UI │└─ screens ├─ User │ ├─ Form.jsx │ └─ List.jsx └─ Root.jsx Tổng kếtTóm tắt lại, chúng ta cần nhớ những điểm sau đây: Presentational và Container components được đặt trong folder src/components Nhóm các components lại dựa trên module/feature Đưa những component chung được sử dụng nhiều lần (UI components) vào trong src/components/UI Viết component screens (màn hình) thật đơn giản, ít code Nhóm các màn hình lại theo route của ứng dụng. Với route /user/list thì screen sẽ nằm trong src/screens/User/List.jsx. Components được dặt tên theo đường dẫn tương đối của so với src/components hoặc src - Tên component trong file src/components/User/List.jx sẽ có tên là UserList, tên component trong file src/screens/User/List.jsx sẽ có tên là ScreensUserList. Component trong file có cùng tên với folder chứa nó sẽ không lặp lại tên của folder. Ví dụ file src/components/User/List/List.jsx sẽ có component được đặt tên là UserList, chứ KHÔNG PHẢI là UserListList Kết luậnBài viết đã đưa ra một trong những cách để tổ chức, phân chia cũng như đặt tên cho file, folder và component khi thiết kế ứng dụng bằng React. Đương nhiên, đây chỉ là ý kiến chủ quan, bạn hoàn toàn có thể tự mình thiết lập và đưa ra những pattern mà bạn cảm thấy hợp lý, thuận tiện khi làm việc với React, miễn sao cho trải nghiệm của bản thân là tốt nhất. Xin cảm ơn!","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Gooact: React trong 160 dòng code JavaScript","slug":"Gooact-React-trong-160-dong-code-JavaScript","date":"2018-05-26T08:13:00.000Z","updated":"2018-05-26T13:12:23.679Z","comments":true,"path":"2018/05/Gooact-React-trong-160-dong-code-JavaScript.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Gooact-React-trong-160-dong-code-JavaScript.html","excerpt":"","text":"Làm thế nào để xây dựng React cho riêng mình chỉ trong vài phút.Giới thiệuReact là một thư viện tuyệt vời - nhiều nhà phát triển ngay lập tức đã yêu thích nó vì tính đơn giản, hiệu suất và cách khai báo làm việc. Nhưng cá nhân tôi có một lý do cụ thể khiến nó trở nên đặc biệt đối với tôi - và đó là cách nó hoạt động bên dưới. Tôi tìm thấy những ý tưởng đứng đằng sau React đơn giản nhưng kỳ lạ thú vị - và tôi tin rằng sự hiểu biết nguyên tắc cốt lõi của nó sẽ giúp bạn viết mã nhanh hơn và an toàn hơn. Trong bài viết này, tôi sẽ chỉ cho cho bạn cách viết một bản sao của React đầy đủ chức năng, bao gồm Component API và tự triển khai Virtual DOM. Nó được chia thành bốn phần - mỗi phần là một chủ đề chính: Elements: Trong phần này chúng ta sẽ tìm hiểu cách các khối JSX được xử lý thành phiên bản nhẹ của DOM được gọi là VDOM như thế nào. Rendering: Trong phần này tôi sẽ hướng dẫn bạn cách chuyển đổi VDOM thành DOM thông thường. Patching: Trong phần này tôi sẽ trình bày lý do tại sao thuộc tính “key” quan trọng như thế và cách sử dụng VDOM để nối lại với DOM hiện tại một cách hiệu quả. Components: Phần cuối cùng sẽ cho bạn biết về các thành phần React và quy trình tạo, vòng đời và dựng hình của chúng. Mỗi phần sẽ kết thúc bằng một ví dụ có link CodePen trực tiếp, vì vậy bạn có thể ngay lập tức kiểm tra tất cả các tiến trình chúng ta đã thực hiện. Bắt đầu nào. Elements Element là một đối tượng trọng lượng nhẹ của một DOM thực tế. Nó chứa tất cả thông tin quan trọng - như node type, attributes và danh sách children — vì vậy nó có thể dễ dàng rendered trong tương lai. Thành phần giống như cây của các elements được gọi là VDOM - một ví dụ được hiển thị bên dưới: 1234567891011121314151617181920212223242526&#123; \"type\": \"ul\", \"props\": &#123; \"className\": \"some-list\" &#125;, \"children\": [ &#123; \"type\": \"li\", \"props\": &#123; \"className\": \"some-list__item\" &#125;, \"children\": [ \"One\" ] &#125;, &#123; \"type\": \"li\", \"props\": &#123; \"className\": \"some-list__item\" &#125;, \"children\": [ \"Two\" ] &#125; ]&#125; Thay vì viết object quái dị đó mọi lúc, hầu hết các nhà phát triển React đều sử dụng cú pháp JSX, trông giống như một sự kết hợp gọn gàng giữa mã JavaScript và các thẻ HTML: 12345/** @jsx createElement */const list = &lt;ul className=\"some-list\"&gt; &lt;li className=\"some-list__item\"&gt;One&lt;/li&gt; &lt;li className=\"some-list__item\"&gt;Two&lt;/li&gt;&lt;/ul&gt;; In order to get executed it needs to be transpiled into regular function calls — notice that pragma comment which defines what function must be used:Để được thực hiện, nó cần phải được chuyển thành các gọi hàm thông thường - chú ý comment pragma là phải luôn sử dụng: 1234const list = createElement('ul', &#123;className: 'some-list'&#125;, createElement('li', &#123;className: 'some-list__item'&#125;, 'One'), createElement('li', &#123;className: 'some-list__item'&#125;, 'Two'),); Cuối cùng, function mong muốn được gọi - và nó được cho là trả về cấu trúc VDOM được mô tả ở trên. Việc triển khai của chúng tôi sẽ ngắn gọn - nhưng mặc dù có vẻ nguyên thủy, nó phục vụ mục đích cần một cách hoàn hảo: 1234const createElement = (type, props, ...children) =&gt; &#123; props = props != null ? props : &#123;&#125;; return &#123;type, props, children&#125;;&#125;; CodePen đầu tiên có sẵn ở đây— nó chứa phương pháp được mô tả ở trên với một vài cây VDOM do nó tạo ra. Rendering Rendering là một quá trình biến VDOM thành DOM hiển thị. Nói chung, nó là một thuật toán khá đơn giản mà đi qua cây VDOM và tạo ra phần tử DOM tương ứng cho mỗi node: 123456789101112131415161718192021222324252627282930313233343536const render = (vdom, parent=null) =&gt; &#123; if (parent) parent.textContent = ''; const mount = parent ? (el =&gt; parent.appendChild(el)) : (el =&gt; el); if (typeof vdom == 'string' || typeof vdom == 'number') &#123; return mount(document.createTextNode(vdom)); &#125; else if (typeof vdom == 'boolean' || vdom === null) &#123; return mount(document.createTextNode('')); &#125; else if (typeof vdom == 'object' &amp;&amp; typeof vdom.type == 'function') &#123; return mount(Component.render(vdom)); &#125; else if (typeof vdom == 'object' &amp;&amp; typeof vdom.type == 'string') &#123; const dom = document.createElement(vdom.type); for (const child of [].concat(...vdom.children)) // flatten dom.appendChild(render(child)); for (const prop in vdom.props) setAttribute(dom, prop, vdom.props[prop]); return mount(dom); &#125; else &#123; throw new Error(`Invalid VDOM: $&#123;vdom&#125;.`); &#125;&#125;;const setAttribute = (dom, key, value) =&gt; &#123; if (typeof value == 'function' &amp;&amp; key.startsWith('on')) &#123; const eventType = key.slice(2).toLowerCase(); dom.__gooactHandlers = dom.__gooactHandlers || &#123;&#125;; dom.removeEventListener(eventType, dom.__gooactHandlers[eventType]); dom.__gooactHandlers[eventType] = value; dom.addEventListener(eventType, dom.__gooactHandlers[eventType]); &#125; else if (key == 'checked' || key == 'value' || key == 'id') &#123; dom[key] = value; &#125; else if (key == 'key') &#123; dom.__gooactKey = value; &#125; else if (typeof value != 'object' &amp;&amp; typeof value != 'function') &#123; dom.setAttribute(key, value); &#125;&#125;; Code ở trên có vẻ trông đáng sợ, nhưng hãy làm cho mọi thứ trở nên ít phức tạp hơn bằng cách tách nó thành các phần nhỏ hơn: Custom Attribute Setter: Các thuộc tính được chuyển đến VDOM không phải lúc nào cũng hợp lệ về DOM - những thứ như trình xử lý sự kiện, key định danh và các giá trị phải được xử lý riêng lẻ. Primitive VDOM rendering: Primitives — như strings, numbers, booleans và nulls — được chuyển thành các node văn bản thuần túy. Complex VDOM rendering: Nodes với tag string được biến thành các phần tử DOM với hiển thị children theo đệ quy. Component VDOM rendering: Nodes với tag function tag được xử lý riêng — không chú ý nhiều đến phần đó, chúng ta sẽ thực hiện nó sau. CodePen thứ hai có sẵn ở đây— nó thể hiện thuật toán render trong hành động. Patching Patching là một quá trình hòa hợp DOM hiện có với cây VDOM mới được xây dựng. Hãy tưởng tượng bạn có một số VDOM lồng nhau sâu và cập nhật thường xuyên. Khi một cái gì đó thay đổi, ngay cả phần nhỏ nhất - mà phải được hiển thị. Triển khai native sẽ yêu cầu render toàn bộ mỗi lần cập nhật như vậy. Xóa các nút DOM hiện có. Re-render mọi thứ. Đó là lý do thực tế — xây dựng DOM và vẽ lại nó là một hoạt động khá tốn kém. Nhưng chúng ta có thể tối ưu hóa điều này bằng cách viết thuật toán và sẽ yêu cầu ít sửa đổi DOM: Xây dựng một VDOM mới. Đệ quy so sánh nó với DOM hiện có. Tìm các nút đã được thêm, xóa hoặc thay đổi theo bất kỳ cách nào. Patch(Vá) chúng lại. Nhưng sau đó một vấn đề khác nổi lên — độ phức tạp tính toán. So sánh hai cây có độ phức tạp O(n³) — ví dụ: nếu bạn định patch một ngìn elements — nó sẽ yêu cầu một tỷ so sánh. Điều đó là quá nhìu. Thay vào đó, chúng ta sẽ triển khai một thuật toán độ phức tạp O(n) với hai giả định sau: Hai elements của các loại khác nhau sẽ tạo ra những cây khác nhau. Nhà phát triển có thể gợi ý các phần tử con nào có thể không đổi qua các lần render khác nhau với prop “key”. Trong thực tế, các giả định này có giá trị đối với hầu hết các trường hợp sử dụng thực tế. Bây giờ chúng tôi đã sẵn sàng cho một phần code khác: 123456789101112131415161718192021222324252627282930313233343536const patch = (dom, vdom, parent=dom.parentNode) =&gt; &#123; const replace = parent ? el =&gt; (parent.replaceChild(el, dom) &amp;&amp; el) : (el =&gt; el); if (typeof vdom == 'object' &amp;&amp; typeof vdom.type == 'function') &#123; return Component.patch(dom, vdom, parent); &#125; else if (typeof vdom != 'object' &amp;&amp; dom instanceof Text) &#123; return dom.textContent != vdom ? replace(render(vdom)) : dom; &#125; else if (typeof vdom == 'object' &amp;&amp; dom instanceof Text) &#123; return replace(render(vdom)); &#125; else if (typeof vdom == 'object' &amp;&amp; dom.nodeName != vdom.type.toUpperCase()) &#123; return replace(render(vdom)); &#125; else if (typeof vdom == 'object' &amp;&amp; dom.nodeName == vdom.type.toUpperCase()) &#123; const pool = &#123;&#125;; const active = document.activeElement; for (const index in Array.from(dom.childNodes)) &#123; const child = dom.childNodes[index]; const key = child.__gooactKey || index; pool[key] = child; &#125; const vchildren = [].concat(...vdom.children); // flatten for (const index in vchildren) &#123; const child = vchildren[index]; const key = child.props &amp;&amp; child.props.key || index; dom.appendChild(pool[key] ? patch(pool[key], child) : render(child)); delete pool[key]; &#125; for (const key in pool) &#123; if (pool[key].__gooactInstance) pool[key].__gooactInstance.componentWillUnmount(); pool[key].remove(); &#125; for (const attr of dom.attributes) dom.removeAttribute(attr.name); for (const prop in vdom.props) setAttribute(dom, prop, vdom.props[prop]); active.focus(); return dom; &#125;&#125;; Hãy điều tra tất cả các kết hợp có thể: Primitive VDOM + Text DOM: So sánh giá trị VDOM với nội dung DOM và thực hiện full render nếu chúng khác nhau. Primitive VDOM + Element DOM : Full render. Complex VDOM + Text DOM : Full render. Complex VDOM + Element DOM of different type : Full render. Complex VDOM + Element DOM of same type : Sự kết hợp thú vị nhất, nơi diễn ra sự hòa hợp của children, xem chi tiết bên dưới. Component VDOM + any kind of DOM: Cũng giống như trong phần trước, được xử lý riêng và sẽ được triển khai sau. Như bạn có thể thấy, các nút text và phức tạp nói chung không tương thích và yêu cầu full render — may mắn thay đó là một sự thay đổi hiếm hoi. Nhưng những gì về sự hòa hợp của children đệ quy - nó thực hiện như sau: Current active element is memoized — reconciliation may break focus sometimes. DOM children are moved into temporary pool under their respective keys — index is used as a key by default. VDOM children are paired to the pool DOM nodes by key and recursively patched — or rendered from scratch if pair is not found. DOM nodes that left unpaired are removed from document. New attributes are applied to final parent DOM. Focus is returned back to previously active element. CodePen thứ ba có sẵn ở đây — bao gồm ví dụ nhỏ về list patching. Components Component về mặt khái niệm tương tự như hàm JavaScript — nó có đầu vào tùy ý được gọi là “props” và trả về tập các elements mô tả những gì sẽ xuất hiện trên màn hình. Nó có thể được định nghĩa là một stateless function hoặc derived class với trạng thái bên trong của riêng và tập các phương thức và các lifecycle hooks. Tôi sẽ ngắn gọn về lý thuyết - tốt hơn hãy xem code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Component &#123; constructor(props) &#123; this.props = props || &#123;&#125;; this.state = null; &#125; static render(vdom, parent=null) &#123; const props = Object.assign(&#123;&#125;, vdom.props, &#123;children: vdom.children&#125;); if (Component.isPrototypeOf(vdom.type)) &#123; const instance = new (vdom.type)(props); instance.componentWillMount(); instance.base = render(instance.render(), parent); instance.base.__gooactInstance = instance; instance.base.__gooactKey = vdom.props.key; instance.componentDidMount(); return instance.base; &#125; else &#123; return render(vdom.type(props), parent); &#125; &#125; static patch(dom, vdom, parent=dom.parentNode) &#123; const props = Object.assign(&#123;&#125;, vdom.props, &#123;children: vdom.children&#125;); if (dom.__gooactInstance &amp;&amp; dom.__gooactInstance.constructor == vdom.type) &#123; dom.__gooactInstance.componentWillReceiveProps(props); dom.__gooactInstance.props = props; return patch(dom, dom.__gooactInstance.render()); &#125; else if (Component.isPrototypeOf(vdom.type)) &#123; const ndom = Component.render(vdom); return parent ? (parent.replaceChild(ndom, dom) &amp;&amp; ndom) : (ndom); &#125; else if (!Component.isPrototypeOf(vdom.type)) &#123; return patch(dom, vdom.type(props)); &#125; &#125; setState(nextState) &#123; if (this.base &amp;&amp; this.shouldComponentUpdate(this.props, nextState)) &#123; const prevState = this.state; this.componentWillUpdate(this.props, nextState); this.state = nextState; patch(this.base, this.render()); this.componentDidUpdate(this.props, prevState); &#125; else &#123; this.state = nextState; &#125; &#125; shouldComponentUpdate(nextProps, nextState) &#123; return nextProps != this.props || nextState != this.state; &#125; componentWillReceiveProps(nextProps) &#123; return undefined; &#125; componentWillUpdate(nextProps, nextState) &#123; return undefined; &#125; componentDidUpdate(prevProps, prevState) &#123; return undefined; &#125; componentWillMount() &#123; return undefined; &#125; componentDidMount() &#123; return undefined; &#125; componentWillUnmount() &#123; return undefined; &#125;&#125; Các static methods được gọi internally: Render: Performs initial rendering. Stateless components are called as a regular function — result is displayed immediately. Class components are instantiated and attached to the DOM — and only then are rendered. Patching: Performs further update. Sometimes DOM node already has a component instance attached to it — pass new properties to it and patch differences. Perform full render otherwise. Các Instance methods có nghĩa là có thể bị ghi đè hoặc được gọi trong các derived classes do người dùng định nghĩa: Constructor: Handles properties and defines initial state, storing them within itself. State modifier: Handles new state, fires all required lifecycle hooks and initiates patch cycle. Lifecycle hooks: Set of methods that are fired throughout component life — on mount, during updates and just before it gets removed. Lưu ý rằng phương thức render bị thiếu — nó được định nghĩa trong các child classes. CodePen cuối cùng có ở đây — với tất cả các code chúng tôi đã thực hiện cho đến đây cùng với một ví dụ to-do đơn giản. Kết luậnĐó là tất cả của tôi — chúng ta có một bản sao React đầy đủ chức năng ngay bây giờ. Tôi sẽ gọi nó là Gooact — đó sẽ là một món quà nhỏ cho người bạn tốt của tôi. Chúng ta hãy xem xét kỹ hơn các kết quả: Gooact có thể xây dựng và patch hiệu quả các cây DOM phức tạp bằng cách sử dụng VDOM làm tham chiếu. Gooact hỗ trợ cả hai functional và class components — cùng với việc xử lý chính xác internal state và hooks lifecycle hoàn chỉnh. Gooact dùng transpiled code cung cấp bởi Babel. Gooact vừa đủ trong 160 dòng code JavaScript chưa nén. Mục đích chính của bài viết này là để chứng minh các nguyên tắc cốt lõi của cấu trúc bên trong React mà không cần phải đi sâu vào các API phụ trợ - đó là lý do tại sao chúng bị thiếu một số thứ sau trong Gooact: Gooact không hỗ trợ những thứ như fragments, portals, contexts, references và một số thứ khác đã được giới thiệu trong các phiên bản mới hơn. Gooact không triển khai React Fiber do sự phức tạp của nó — nhưng tôi có thể viết một bài về nó trong tương lai. Gooact không theo dõi các key trùng lặp và đôi khi có thể gây ra lỗi. Gooact thiếu hỗ trợ callbacks thêm cho một số methods. Như bạn có thể thấy, đó là một lĩnh vực tuyệt vời cho các tính năng và cải tiến mới - repository có sẵn ở đây, do đó, vì vậy đừng ngần ngại fork và thử nghiệm. Bạn thậm chí có thể cài đặt nó bằng cách sử dụng NPM! Tôi muốn cảm ơn toàn bộ React Team đã tạo một thư viện tuyệt vời, làm cho cuộc sống của hàng nghìn nhà phát triển trở nên dễ dàng hơn. Đặc biệt cảm ơn đến Preact tác giả chính là Jason Miller — bài viết này đã được lấy cảm hứng từ cách tối giản nó được thực hiện.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Cơ chế sử dụng Virtual DOM trong React","slug":"Co-che-su-dung-Virtual-DOM-trong-React","date":"2018-05-25T15:22:00.000Z","updated":"2018-05-25T15:35:20.184Z","comments":true,"path":"2018/05/Co-che-su-dung-Virtual-DOM-trong-React.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Co-che-su-dung-Virtual-DOM-trong-React.html","excerpt":"Khi tìm hiểu về ReactJS, chắc hẳn bạn đã nghe tới khái niệm DOM ảo (Virtual DOM). Nó giúp cho hiệu suất làm việc của React cao hơn hẳn so với các thư viện và framework Javascript khác. Nhưng bạn đã bao giờ tìm hiểu DOM ảo là gì và nó hoạt động như thế nào trong React? Hôm nay, chúng ta cùng tìm hiểu về chủ đề này nhé.","text":"Khi tìm hiểu về ReactJS, chắc hẳn bạn đã nghe tới khái niệm DOM ảo (Virtual DOM). Nó giúp cho hiệu suất làm việc của React cao hơn hẳn so với các thư viện và framework Javascript khác. Nhưng bạn đã bao giờ tìm hiểu DOM ảo là gì và nó hoạt động như thế nào trong React? Hôm nay, chúng ta cùng tìm hiểu về chủ đề này nhé. Virtual DOM là gì?Điều đầu tiên tôi muốn nói ở đây là: Virtual DOM không được phát minh ra bởi React, mà React sử dụng nó. DOM ảo là một bản sao chép trừu tượng của DOM thật (HTML DOM). Bạn có thể tưởng tượng nó giống như một bản thiết kế, chứa các chi tiết cần thiết để cấu hình lên một DOM. Ví dụ, thay vì tạo một thẻ &lt;div&gt; thật chứa các thẻ &lt;ul&gt; bên trong, nó sẽ tạo một div object chứa ul object bên trong. Cụ thể ở trong React sẽ là các React.div và React.ul. Khi tương tác, ta có thể tương tác với các object đó rất nhanh mà không phải động tới DOM thật hoặc thông qua DOM API. Tiếp theo chúng ta sẽ tìm hiểu cụ thể React tương tác với DOM ảo như thế nào nhé Virtual DOM trong ReactTrước tiên, đã bao giờ bạn tự hỏi tại sao lại phải tương tác thông qua DOM ảo, sao không render trực tiếp ở DOM thật? Vậy bạn đã thực sự hiểu rõ DOM được tạo và re-render như thế nào mỗi khi các thành phần trong DOM thay đổi? Mỗi khi có sự thay đổi, vì cấu trúc của DOM là tree structure , khi muốn thay đổi các element và các thẻ con của nó, nó phải thông qua các Reflow/Layout, sau đó các thay đổi đó sẽ được Re-painted, rất mất thời gian. Vì thế, càng nhiều các item phải reflow/repaint, web của bạn sẽ càng load chậm. Vậy React đã sử dụng DOM ảo như thế nào? Để một trang lớn như Facebook mà chúng ta dùng hàng ngày có hiệu suất làm việc cao như vậy? Để dễ hình dung, chúng ta sẽ tìm hiểu thông qua một ví dụ nho nhỏ dưới đây nhé. Đó là giao diện của một app cộng hoặc trừ 2 số. Người dùng sẽ nhập vào 2 số vào 2 ô input, sau đó chọn phép toán và in ra kết quả ở phần Output. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React, &#123; Component &#125; from 'react';export default class Calculator extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; output: '' &#125;; &#125; render() &#123; let IntegerA, IntegerB, IntegerC; return ( &lt;div className=\"container\"&gt; &lt;h2&gt;using React&lt;/h2&gt; &lt;div&gt; Input 1: &lt;input type=\"text\" placeholder=\"Input 1\" ref=\"input1\" /&gt; &lt;/div&gt; &lt;div&gt; Input 2 : &lt;input type=\"text\" placeholder=\"Input 2\" ref=\"input2\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;button id=\"add\" onClick=&#123;() =&gt; &#123; IntegerA = parseInt(this.refs.input1.value); IntegerB = parseInt(this.refs.input2.value); IntegerC = IntegerA + IntegerB; this.setState(&#123; output: IntegerC &#125;); &#125;&#125; &gt; Add &lt;/button&gt; &lt;button id=\"subtract\" onClick=&#123;() =&gt; &#123; IntegerA = parseInt(this.refs.input1.value); IntegerB = parseInt(this.refs.input2.value); IntegerC = IntegerA - IntegerB; this.setState(&#123; output: IntegerC &#125;); &#125;&#125; &gt; Subtract &lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;hr /&gt; &lt;h2&gt;Output: &#123;this.state.output&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; import React, &#123; Component &#125; from 'react';import Calculator from './Calculator';export default class Layout extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Basic Calculator&lt;/h1&gt; &lt;Calculator /&gt; &lt;/div&gt; ); &#125;&#125; Và đây là DOM thật sau lần load đầu tiên Còn đây là DOM ảo mà React tạo ra tương ứng với DOM thật bên trên. Trong React, nó cũng được gọi là một Component với tree structure gồm các Component con bên trong Sau đây, chúng ta sẽ cùng thử nhập vào 2 số và click vào button Add và xem React xử lí như thế nào nhé. 1234Input 1: 100Input 2: 50Output mong đợi sẽ là 150. Điều gì xảy ra khi ta click vào button Add? Ở ví dụ này, chúng ta set output là một state, vì thế khi một output mới được hiện ra nghĩa là ta đã set cho State đó một giá trị mới đó là 150. Đánh dấu Component dirty Trong React, khi một Component có một state mới được set, React đánh dấu nó như là một dirty Component, nghĩa là mỗi khi chúng ta gọi tới function setState() thì Component đó sẽ được đánh dấu là dirty. Cụ thể ở đây, khi ta click Add, React sẽ đánh dấu Component Calculator như thế nào: Tất cả các event khi ta thao tác với DOM, nó được gói trọn trong React event listener. Vì thế khi nút Add được click, event đó được gửi tới React event listener và sau đó nó sẽ chạy một anonymous function() Trong anonymous function(), chúng ta gọi tới function this.setState với một state value mới. Function this.setState() được chạy, Component Calculator được đánh dấu là dirty. 12//ReactUpdates.js - enqueueUpdate(component) functiondirtyComponents.push(component); Và hiện tại, Calculator của chúng ta đã được đánh dấu là dirty. Cùng xem những gì sẽ diễn ra tiếp theo Chạy qua Component lifecycleComponent lifecycle trong React là một loạt các hàm mặc định sẽ được chạy ngay trước, trong và ngay sau quá trình update một Component. Ở ví dụ này, chúng ta không overwrite các hàm đó thì nó sẽ chạy ở các giá trị mặc định. Quá trình update Component được diễn ra như sau: React sẽ kiểm tra Component đó có được mark dirty hay không, sau đó bắt đầu quá trình update. 123456//ReactUpdates.jsvar flushBatchedUpdates = function () &#123; while (dirtyComponents.length || asapEnqueued) &#123; if (dirtyComponents.length) &#123; var transaction = ReactUpdatesFlushTransaction.getPooled(); transaction.perform(runBatchedUpdates, null, transaction); Sau đó, React sẽ kiểm tra xem có pending state nào phải được update hay không hoặc có forceUpdate nào không 123if (this._pendingStateQueue !== null || this._pendingForceUpdate) &#123; this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context); Trong ví dụ này của chúng ta, trong Calculator wrapper, this.pendingStateQueue, chứa State object với giá trị Output mới 3. React chạy các lifecycle methods. Đầu tiên là componentWillReceiveProps(), tiếp đó là shouldComponentUpdate() (các phương thức này có giá trị mặc định thế nào nếu chúng ta không overwrite nó thì các bạn tự tìm hiểu nhé). Trong trường hợp này, method shouldComponentUpdate() sẽ trả về true, sau đó sẽ chạy componentWillUpdate(), render() và componentDidUpdate(). Thứ quan trọng nhất trong quá trình update ở đấy chính là render(), đó chính là chỗ mà DOM ảo được tạo lại và update DOM ảo để tìm ra sự khác biệt để sau đó cập nhật ở DOM thật, hay nói các khác là tìm ra cụ thể những element thay đổi để update chỉ những element đó trong DOM thật. Xây dựng lại Component, Update DOM ảo, tìm sự thay đổi, update DOM thật React sẽ kiểm tra các element trước và sau khi được render lại ở lần vừa rồi có giống nhau hay không, sau đó bắt đầu quá trình đồng bộ. 12var prevRenderedElement = this._renderedComponent._currentElement; var nextRenderedElement = this._instance.render(); //Calculator.render() method is called and the element is build. Quá trình đồng bộ và update DOM thật như sau: Những điểm màu đỏ nghĩa là quá trình đồng bộ sẽ được lặp lại đối với những thành phần con của nó. Và đây là DOM mà chúng ta nhận được sau quá trình đó : Trong ví dụ này, chỉ có phần Output bị thay đổi, bạn có thể nhìn thấy phần được đánh dấu flash ở hình dưới, chỉ có phần đó được DOM thật re-painted Và cây component được cập nhật tại DOM thực tế. Kết luậnQua ví dụ trên mong là bạn có thể hình dung phần nào đó cách thực hoạt động của DOM ảo trong React và tính hữu dụng của nó. Nhờ có DOM ảo, React có thể tìm ra các node bị thay đổi và update ở DOM thật chỉ ở những cái node đó, thật thuận tiện và nhanh gọn phải không nào.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Tìm Hiểu Regular Expression Javascript","slug":"Tim-Hieu-Regular-Expression-Javascript","date":"2018-05-25T14:38:00.000Z","updated":"2018-05-25T14:47:51.414Z","comments":true,"path":"2018/05/Tim-Hieu-Regular-Expression-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Tim-Hieu-Regular-Expression-Javascript.html","excerpt":"Regular expression hay còn được gọi tắt là Regex hay RegExp, là một cách để biểu diễn khuôn mẫu của string. Đây là một phần của ngôn ngữ lập trình JavaScript, cũng như nhiều ngôn ngữ lập trình khác. Nếu bạn là một lập trình viên và đã từng sử dụng Regular Expression thì bạn chắc hẳn sẽ thấy rằng nó có cú pháp rất kinh khủng và có phần “bí ẩn”. Tuy nhiên, công cụ này lại cực kì mạnh mẽ và hiệu quả khi dùng để xử lý string. Sau đây, chúng ta sẽ cùng tìm hiểu về Regular Expression trong JavaScript.","text":"Regular expression hay còn được gọi tắt là Regex hay RegExp, là một cách để biểu diễn khuôn mẫu của string. Đây là một phần của ngôn ngữ lập trình JavaScript, cũng như nhiều ngôn ngữ lập trình khác. Nếu bạn là một lập trình viên và đã từng sử dụng Regular Expression thì bạn chắc hẳn sẽ thấy rằng nó có cú pháp rất kinh khủng và có phần “bí ẩn”. Tuy nhiên, công cụ này lại cực kì mạnh mẽ và hiệu quả khi dùng để xử lý string. Sau đây, chúng ta sẽ cùng tìm hiểu về Regular Expression trong JavaScript. Khởi tạo Regular ExpressionCó hai cách để tạo ra một Regular Expression là: Sử dụng hàm khởi tạo của đối tượng RegExp Viết trực tiếp sử dụng cặp dấu “/ /“ 12var re1 = new RegExp(\"abc\");var re2 = /abc/; Cả hai cách trên ta đều thu được một Regular Expression biểu diễn một string có dạng: abc. Một số phương thức của Regular ExpressionPhương thức TestĐây là phương thức đơn giản nhất dùng để kiểm tra xem một string có chứa khuôn mẫu đã định nghĩa hay không. Nếu có thì kết quả trả về là TRUE và ngược lại thì là FALSE. 123456console.log(/abc/.test(\"abcde\"));// =&gt; trueconsole.log(/abc/.test(\"12abcde\"));// =&gt; trueconsole.log(/abc/.test(\"abxcde\"));// =&gt; false Trong ví dụ trên, 2 string “abcde” và “12abcde” đều chứa “abc” nên kết quả trả về là true. String còn lại “abxcde” không chứa “abc” nên kết quả là false. Kiểm tra trùng khớp với tập hợp các kí tựNếu chỉ kiểm tra như ví dụ trên thì bạn hoàn toàn có thể sử dụng phương thức indexOf của string thay vì sử dụng Regular Expression. Tuy nhiên, với Regular Expression thì bạn có thể kiểm tra những mẫu string phức tạp hơn. Ví dụ: 12345678console.log(/[0123456789]/.test(\"in 1992\"));// =&gt; trueconsole.log(/[0-9]/.test(\"in 1992\"));// =&gt; trueconsole.log(/[0-9]/.test(\"Hello \"));// =&gt; falseconsole.log(/[0-5]/.test(\"Gold 9999\"));// =&gt; false Ví dụ 1, 2, 3 kiểm tra xem string có chứa bất kì chữ số nào từ 0 đến 9. Ví dụ cuối cùng kiểm tra xem string có chứa bất kì chữ số nào từ 0 đến 5. JavaScript sử dụng cặp dấu ngoặc vuông [] để biểu thị việc kiểm tra string có chứa bất kì kí tự nào có trong cặp dấu [] hay không. Trong đó, dấu “-“ giữa hai kí tự dùng để chỉ 1 khoảng giữa hai kí tự đó. [0-9] là các chữ số từ 0 đến 9 [a-z] là các chữ cái từ a đến z Ngoài ra, JavaScript cung cấp sẵn một số cách biểu diễn một tập hợp các kí tự: \\d : bất kì chữ số nào từ 0 đến 9 \\w : một chữ cái \\s : kí tự trắng (dấu cách, tab, dòng mới,…) \\D : kí tự không phải số \\W : kí tự không phải chữ cái \\S : kí tự không phải kí tự trắng . : bất kì kí tự nào trừ dòng mới. Ví dụ kiểm tra ngày giờ có định dạng: dd-mm-yyyy hh:mm 12345var dateTime = /\\d\\d-\\d\\d-\\d\\d\\d\\d \\d\\d:\\d\\d/;console.log(dateTime.test(\"30-01-2003 15:20\"));// =&gt; trueconsole.log(dateTime.test(\"30-jan-2003 15:20\"));// =&gt; false Đảo ngược tập hợp các kí tựTrường hợp bạn muốn kiểm tra một string chứa bất kì kí tự nào không có trong tập hợp đã cho thì bạn có thể sử dụng kí tự “^”. Ví dụ: 12345var notBinary = /[^01]/;console.log(notBinary.test(\"1100100010100110\"));// =&gt; falseconsole.log(notBinary.test(\"1100100010200110\"));// =&gt; true Lặp lại khuôn mẫuTrong ví dụ về kiểm tra ngày giờ bên trên, “\\d” xuất hiện lặp lại rất nhiều lần. Điều này gây nên sự khó theo dõi. Do đó, JavaScript cung cấp cách thức để biểu diễn sự lặp lại khuôn mẫu: “+”: biểu thị phần tử xuất hiện &gt;= 1 lần 1234console.log(/'\\d+'/.test(\"'123'\"));// =&gt; trueconsole.log(/'\\d+'/.test(\"''\"));// =&gt; false “*”: biểu thị phần tử xuất hiện &gt;= 0 lần (có thể không xuất hiện) 1234console.log(/'\\d*'/.test(\"'123'\"));// =&gt; trueconsole.log(/'\\d*'/.test(\"''\"));// =&gt; true “?”: biểu thị phần tử xuất hiện 0 hoặc 1 lần 1234567var neighbor = /neighbou?r/;console.log(neighbor.test(\"neighbour\"));// =&gt; trueconsole.log(neighbor.test(\"neighbor\"));// =&gt; trueconsole.log(neighbor.test(\"neighbouur\"));// =&gt; false {n}: biểu thị phần tử xuất hiện đúng n lần 123456console.log(/\\d&#123;4&#125;/.test(\"1234\"));// =&gt; trueconsole.log(/\\d&#123;4&#125;/.test(\"12345\"));// =&gt; trueconsole.log(/\\d&#123;4&#125;/.test(\"123\"));// =&gt; false {x,y}: biểu thị phần tử xuất hiện từ x đến y lần 12345678910console.log(/\\d&#123;2,4&#125;/.test(\"12345\"));// =&gt; trueconsole.log(/\\d&#123;2,4&#125;/.test(\"1234\"));// =&gt; trueconsole.log(/\\d&#123;2,4&#125;/.test(\"123\"));// =&gt; trueconsole.log(/\\d&#123;2,4&#125;/.test(\"12\"));// =&gt; trueconsole.log(/\\d&#123;2,4&#125;/.test(\"1\"));// =&gt; false {x, }: biểu thị phần tử xuất hiện &gt;= x lần 123456console.log(/\\d&#123;2,&#125;/.test(\"12\"));// =&gt; trueconsole.log(/\\d&#123;2,&#125;/.test(\"1234\"));// =&gt; trueconsole.log(/\\d&#123;2,&#125;/.test(\"1\"));// =&gt; false Nhóm các phần tửTrong nhiều trường hợp bạn muốn lặp lại cả một nhóm các phần tử. Khi đó, bạn phải nhóm các phần tử đó lại sử dụng cặp dấu ngoặc đơn “( )”. 123var cartoonCrying = /boo+(hoo+)+/i;console.log(cartoonCrying.test(\"Boohoooohoohooo\"));// =&gt; true Lựa chọn khuôn mẫuTrường hợp bạn có nhiều khuôn mẫu và bạn cần kiểm tra xem string đưa ra chứa một trong các khuôn mẫu đó thì bạn có thể viết các Regular Expression tương ứng để kiểm tra. Hoặc sử dụng kí tự (|) để biểu diễn “hoặc”: 12345var animalCount = /\\d+ (pig|cow|chicken)s?/;console.log(animalCount.test(\"15 pigs\"));// =&gt; trueconsole.log(animalCount.test(\"15 pigchickens\"));// =&gt; false Phương thức ExecNếu như phương thức test chỉ kiểm tra xem có tồn tại khuôn mẫu hay không thì phương thức exec sẽ trả về một đối tượng chứa thông tin thành phần trùng khớp với khuôn mẫu, ngược lại thì trả về null. 12345var match = /\\d+/.exec(\"one two 100 200\");console.log(match);// =&gt; [\"100\", index: 8, input: \"one two 100 200\"]console.log(match.index);// =&gt; 8 Ví dụ trên trả về thành phần thoả mãn khuôn mẫu đầu tiên là: “100”. Index là vị trí đầu tiên của string thoả mãn khuôn mẫu. Khi Regular Expression chứa group với cặp dấu ngoặc đơn thì phần tử đầu tiên trong kết quả sẽ là toàn bộ thành phần trùng khớp, thành phần tiếp theo là phần trùng khớp với group đầu tiên, thành phần tiếp theo là phần trùng khớp với group thứ 2,… 123456789var quotedText = /'([^']*)'/;console.log(quotedText.exec(\"she said 'hello'\"));// =&gt; [\"'hello'\", \"hello\", index: 9, input: \"she said 'hello'\"]console.log(/bad(ly)?/.exec(\"bad\"));// =&gt; [\"bad\", undefined, index: 0, input: \"bad\"]console.log(/(\\d)+/.exec(\"123\"));// =&gt; [\"123\", \"3\", index: 0, input: \"123\"] Trích xuất dữ liệu từ stringPhương thức này đặc biệt hữu ích khi bạn muốn lấy thông tin ra từ string. Ví dụ sau đưa ra một string biểu diễn ngày, tháng, năm. Sau đó chúng ta sẽ trích xuất ra thông tin về ngày, tháng và năm ở trong đó: 123456789101112function findDate(string) &#123; var dateTime = /(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;4&#125;)/; var match = dateTime.exec(string); return &#123; day : match[1], month : match[2], year: match[3] &#125;&#125;var obj = findDate(\"30-1-2003\");console.log(obj);// =&gt; Object &#123;day: \"30\", month: \"1\", year: \"2003\"&#125; Ranh giới của stringTrong ví dụ trên, hàm findDate vẫn tìm ra kết quả nếu như string là “30-1-200300” hay “1130-1-2003”,… Đây là trường hợp không mong muốn. Regular Expression JavaScript cung cấp 2 cách để giải quyết vấn đề này: Sử dụng kí tự biểu diễn bắt đầu (^) và kết thúc ($$ string 123456789101112131415161718192021function findDate(string) &#123; var dateTime = /^(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;4&#125;)$/; var match = dateTime.exec(string); if(!match) return null; return &#123; day : match[1], month : match[2], year: match[3] &#125;&#125;var obj1 = findDate(\"30-1-2003\");console.log(obj1);// =&gt; Object &#123;day: \"30\", month: \"1\", year: \"2003\"&#125;var obj2 = findDate(\"0030-1-200300\");console.log(obj2);// =&gt; nullvar obj3 = findDate(\"Hello 30-1-2003 Haha\");console.log(obj3);// =&gt; null Sử dụng kí tự biên (\\b) 123456789101112131415161718192021function findDate(string) &#123; var dateTime = /\\b(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;4&#125;)\\b/; var match = dateTime.exec(string); if(!match) return null; return &#123; day : match[1], month : match[2], year: match[3] &#125;&#125;var obj1 = findDate(\"30-1-2003\");console.log(obj1);// =&gt; Object &#123;day: \"30\", month: \"1\", year: \"2003\"&#125; var obj2 = findDate(\"0030-1-200300\");console.log(obj2);// =&gt; nullvar obj3 = findDate(\"Hello 30-1-2003 Haha\");console.log(obj3);// =&gt; Object &#123;day: \"30\", month: \"1\", year: \"2003\"&#125; Tạo đối tượng RegExp một cách linh độngTrong nhiều trường hợp, bạn muốn tạo ra một Regular Expression với nội dung chưa được biết trước. Bạn có thể sử dụng hàm khởi tạo của RegExp theo cách sau: 12345var name = \"lampv\";var text = \"LamPV is a suspicious character.\";var regexp = new RegExp(\"\\\\b(\" + name + \")\\\\b\", \"gi\");console.log(text.replace(regexp, \"_$1_\"));// =&gt; _LamPV_ is a suspicious character. Trong đó: tham số g: chỉ ra rằng khuôn mẫu áp dụng Global, nghĩa là nó áp dụng cho tất cả thành phần trùng khớp. tham số i: chỉ ra rằng khuôn mẫu không phân biệt chữ hoa và chữ thường. Ngoài ra, ở đây tôi có sử dụng phương thức replace của string - dùng để thay thế tất cả những thành phần trùng khớp với khuôn mẫu với “_$1_”. Ở đây $$ chính là nội dung của group thứ nhất. Kết luậnTrên đây là một số kiến thức cơ bản về Regular Expression. Hy vọng qua bài viết này bạn phần nào hiểu và biết cách sử dụng công cụ hiệu quả này trong công việc lập trình của mình, đặc biệt là lập trình JavaScript. Tóm tắt một số khuôn mẫu cơ bản của Regular Expression: /abc/ : chuỗi các kí tự abc /[abc]: bất kỳ kí tự nào thuộc tập hợp a, b, c /[^abc]: bất kỳ kí tự nào không thuộc tập a, b, c /[0-9]/: bất kỳ kí tự nào thuộc đoạn từ 0 đến 9 /x+/: thành phần x xuất hiện &gt;= 1 lần /x*/: thành phần x xuất hiện &gt;= 0 lần (có thể không xuất hiện) /x?/: thành phần x xuất hiện 0 hoặc 1 lần /x{2, 4}/: thành phần x xuất hiện từ 2 đến 4 lần /(abc)/: cụm abc /a|b|c/: bất kì pattern nào trong 3 loại a, b, c /\\d/: chữ số từ 0 đến 9 /\\w/: chữ cái /\\s/: kí tự trắng (dấu cách, tab, dòng mới,…) /./ : bất kỳ kí tự nào trừ dòng mới /\\b/: ranh giới từ /^/: bắt đầu string /$$: kết thúc string Tham khảo http://eloquentjavascript.net/09_regexp.html Bài thực hành của tôi: Regexp Golf, Quoting style, Numbers again. Xác thực mã màu RGB và mã màu HEX sử dụng Regex trong Javascript","categories":[],"tags":[{"name":"regex","slug":"regex","permalink":"http://nthung2112.github.io/tags/regex/"}]},{"title":"Giới thiệu về Composing Software","slug":"Gioi-thieu-ve-Composing-Software","date":"2018-05-22T01:09:00.000Z","updated":"2018-05-25T15:58:41.743Z","comments":true,"path":"2018/05/Gioi-thieu-ve-Composing-Software.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Gioi-thieu-ve-Composing-Software.html","excerpt":"Ghi chú: Đây là phần giới thiệu về loạt bài “Composing Software” về việc học các kỹ năng functional programming và compositional software trong JavaScript ES6+ từ đầu. Hãy theo dõi còn rất nhiều thứ khác nữa!Bài viết Kế tiếp &gt;","text":"Ghi chú: Đây là phần giới thiệu về loạt bài “Composing Software” về việc học các kỹ năng functional programming và compositional software trong JavaScript ES6+ từ đầu. Hãy theo dõi còn rất nhiều thứ khác nữa!Bài viết Kế tiếp &gt;Composition: “Hành động kết hợp các parts hoặc elements để tạo thành một tổng thể.” Trong lớp học lập trình đầu tiên của tôi, tôi đã nói rằng phát triển phần mềm là “hành động phá vỡ một vấn đề phức tạp thành các vấn đề nhỏ hơn, và soạn các giải pháp đơn giản để tạo thành một giải pháp hoàn chỉnh cho vấn đề phức tạp.” Một trong những hối tiếc lớn nhất của tôi trong cuộc sống là tôi đã không hiểu ý nghĩa của bài học đó từ sớm. Tôi đã học được bản chất của thiết kế phần mềm quá muộn trong cuộc sống. Tôi đã phỏng vấn hàng trăm developers. Những gì tôi đã học được từ những buổi đó là Tôi không đơn độc. Rất ít developers phần mềm làm việc mà có nắm bắt tốt về bản chất của phát triển phần mềm. Họ không nhận thức được các công cụ quan trọng nhất chúng ta có thể có để xử lý hoặc làm thế nào để đưa chúng vào sử dụng cho tốt. 100% đã đấu tranh để trả lời một hoặc cả hai câu hỏi quan trọng nhất trong lĩnh vực phát triển phần mềm: What is function composition? What is object composition? Vấn đề là bạn không thể tránh được ‘composition’ chỉ vì bạn không biết về nó. Bạn vẫn làm điều đó - nhưng bạn làm điều đó rất tệ. Bạn viết mã với nhiều lỗi hơn và làm cho các developers khác khó hiểu hơn. Đây là một vấn đề lớn. Các ảnh hưởng ấy tốn nhất nhiều chi phí. Chúng tôi dành nhiều thời gian hơn để duy trì phần mềm hơn là chúng tôi tạo ra nó từ đầu và các lỗi của chúng tôi tác động đến hàng tỷ người trên khắp thế giới. Cả thế giới chạy trên phần mềm ngày nay. Mỗi chiếc xe mới là một siêu máy tính mini trên bánh xe, và các vấn đề với thiết kế phần mềm gây ra tai nạn thực sự và chi phí cuộc sống thực của con người. Vào năm 2013, Ban giám khảo đã tìm thấy nhóm phát triển phần mềm của Toyota có tội “Liều lĩnh không để ý” sau khi một cuộc điều tra tai nạn cho thấy spaghetti code với 10000 biến global. Hackers và governments stockpile bugs để theo dõi mọi người, ăn cắp thẻ tín dụng, khai thác tài nguyên máy tính để khởi chạy các cuộc tấn công từ chối dịch vụ phân tán (DDoS), crack mật khẩu và thậm chí điều khiển cuộc bầu cử. Chúng ta phải làm tốt hơn. You Compose Software Every DayNếu bạn là nhà phát triển phần mềm, bạn lập trình các chức năng và cấu trúc dữ liệu mỗi ngày, cho dù bạn có biết hay không. Bạn có thể làm điều đó một cách có ý thức (và tốt hơn), hoặc bạn có thể làm điều đó một cách vô tình, with duct-tape and crazy glue. Quá trình phát triển phần mềm là chia nhỏ các vấn đề lớn thành các vấn đề nhỏ hơn, xây dựng các thành phần giải quyết những vấn đề nhỏ hơn, sau đó kết hợp các thành phần lại với nhau để tạo thành một ứng dụng hoàn chỉnh. Composing FunctionsFunction composition là quá trình áp dụng một function là output của function khác. Trong đại số, có hai hàm số, f và g, (f ∘ g)(x) = f(g(x)). Vòng tròn là toán tử kết hợp. Nó thường được phát âm “kết hợp với” hoặc là “theo sau”. Bạn có thể nói như “f kết hợp với g bằng f of g of x”, or “f theo sau g bằng f of g of x”. Chúng ta nói f theo sau g bởi vì g is giá trị đầu, sau đó output của nó được chuyển thành đối số f. Mỗi lần bạn viết code như thế này, nó là composing functions: 12345678const g = n =&gt; n + 1;const f = n =&gt; n * 2;const doStuff = x =&gt; &#123; const afterG = g(x); const afterF = f(afterG); return afterF;&#125;;doStuff(20); // 42 Mỗi khi bạn viết một chuỗi promise, nó là composing functions: 1234567891011121314const g = n =&gt; n + 1;const f = n =&gt; n * 2;const wait = time =&gt; new Promise( (resolve, reject) =&gt; setTimeout( resolve, time ));wait(300) .then(() =&gt; 20) .then(g) .then(f) .then(value =&gt; console.log(value)) // 42; Tương tự như vậy, mỗi khi bạn thực hiện các gọi các chuỗi phương thức mảng, các hàm lodash, observables (RxJS, etc…) nó là composing functions. Nếu là một chuỗi, thì nó là composing. Nếu bạn chuyển một giá trị trả về vào những functions khác, nó cũng là composing. Nếu bạn gọi hai hàm theo trình tự, nó là composing nếu sử dụng dữ liệu hàm này làm dữ liệu đầu vào cho hàm kia. Nếu là một chuỗi, thì nó là composing. Khi bạn viết một functions có chủ ý, bạn sẽ làm tốt hơn. Composing functions có chủ ý, chúng ta có thể cải thiện hàm doStuff() thành 1 dòng đơn giản: 1234const g = n =&gt; n + 1;const f = n =&gt; n * 2;const doStuffBetter = x =&gt; f(g(x));doStuffBetter(20); // 42 Một trong những phản đối chung về kiểu này là khó để debug. Ví dụ, chúng ta sẽ viết function composition bằng cách nào? 12345678910111213const doStuff = x =&gt; &#123; const afterG = g(x); console.log(`after g: $&#123; afterG &#125;`); const afterF = f(afterG); console.log(`after f: $&#123; afterF &#125;`); return afterF;&#125;;doStuff(20); // =&gt;/*\"after g: 21\"\"after f: 42\"*/ Đầu tiên, hãy trừu tượng rằng “after f”, “after g” và viết vào một tiện ích nhỏ gọi là trace(): 1234const trace = label =&gt; value =&gt; &#123; console.log(`$&#123; label &#125;: $&#123; value &#125;`); return value;&#125;; Now we can use it like this: 12345678910111213const doStuff = x =&gt; &#123; const afterG = g(x); trace('after g')(afterG); const afterF = f(afterG); trace('after f')(afterF); return afterF;&#125;;doStuff(20); // =&gt;/*\"after g: 21\"\"after f: 42\"*/ Thư viện functional programming phổ biến như Lodash và Ramda bao gồm các tiện ích để thực hiện function composition dễ hơn. Bạn có thể viết lại hàm trên như thế này: 12345678910111213import pipe from 'lodash/fp/flow';const doStuffBetter = pipe( g, trace('after g'), f, trace('after f'));doStuffBetter(20); // =&gt;/*\"after g: 21\"\"after f: 42\"*/ If you want to try this code without importing something, you can define pipe like this:Nếu bạn muốn thử code này mà không cần nhập gì, bạn có thể xác định pipe như thế này: 12// pipe(...fns: [...Function]) =&gt; x =&gt; yconst pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x); Đừng lo lắng nếu bạn chưa thể theo dõi cách hoạt động. Sau đó, chúng tôi sẽ khám phá function composition chi tiết hơn. In fact, it’s so essential, you’ll see it defined and demonstrated many times throughout this text. The point is to help you become so familiar with it that its definition and usage becomes automatic. Be one with the composition. pipe() creates a pipeline of functions, passing the output of one function to the input of another. When you use pipe() (and its twin, compose()) You don’t need intermediary variables. Writing functions without mention of the arguments is called point-free style. To do it, you’ll call a function that returns the new function, rather than declaring the function explicitly. That means you won’t need the function keyword or the arrow syntax (=&gt;). Point-free style can be taken too far, but a little bit here and there is great because those intermediary variables add unnecessary complexity to your functions. There are several benefits to reduced complexity: Working MemoryBộ não con người trung bình chỉ có một vài tài nguyên được chia sẻ cho lượng tử rời rạc trong bộ nhớ làm việc working memory, và mỗi biến có khả năng tiêu thụ một trong những lượng tử đó. As you add more variables, our ability to accurately recall the meaning of each variable is diminished. Working memory models typically involve 4–7 discrete quanta. Above those numbers, error rates dramatically increase. Using the pipe form, we eliminated 3 variables — freeing up almost half of our available working memory for other things. That reduces our cognitive load significantly. Software developers tend to be better at chunking data into working memory than the average person, but not so much more as to weaken the importance of conservation. Signal to Noise RatioConcise code also improves the signal-to-noise ratio of your code. It’s like listening to a radio — when the radio is not tuned properly to the station, you get a lot of interfering noise, and it’s harder to hear the music. When you tune it to the correct station, the noise goes away, and you get a stronger musical signal. Code is the same way. More concise code expression leads to enhanced comprehension. Some code gives us useful information, and some code just takes up space. If you can reduce the amount of code you use without reducing the meaning that gets transmitted, you’ll make the code easier to parse and understand for other people who need to read it. Surface Area for BugsTake a look at the before and after functions. It looks like the function went on a diet and lost a ton of weight. That’s important because extra code means extra surface area for bugs to hide in, which means more bugs will hide in it. Less code = less surface area for bugs = fewer bugs. Composing Objects “Favor object composition over class inheritance” the Gang of Four, “Design Patterns: Elements of Reusable Object Oriented Software” “In computer science, a composite data type or compound data type is any data type which can be constructed in a program using the programming language’s primitive data types and other composite types. […] The act of constructing a composite type is known as composition.” ~ Wikipedia These are primitives: 12const firstName = 'Claude';const lastName = 'Debussy'; And this is a composite: 1234const fullName = &#123; firstName, lastName&#125;; Likewise, all Arrays, Sets, Maps, WeakMaps, TypedArrays, etc… are composite datatypes. Any time you build any non-primitive data structure, you’re performing some kind of object composition. Note that the Gang of Four defines a pattern called the composite pattern which is a specific type of recursive object composition which allows you to treat individual components and aggregated composites identically. Some developers get confused, thinking that the composite pattern is the only form of object composition. Don’t get confused. There are many different kinds of object composition. The Gang of Four continues, “you’ll see object composition applied again and again in design patterns”, and then they catalog three kinds of object compositional relationships, including delegation (as used in the state, strategy, and visitor patterns), acquaintance (when an object knows about another object by reference, usually passed as a parameter: a uses-a relationship, e.g., a network request handler might be passed a reference to a logger to log the request — the request handler uses a logger), and aggregation (when child objects form part of a parent object: a has-a relationship, e.g., DOM children are component elements in a DOM node — A DOM node has children). Class inheritance can be used to construct composite objects, but it’s a restrictive and brittle way to do it. When the Gang of Four says “favor object composition over class inheritance”, they’re advising you to use flexible approaches to composite object building, rather than the rigid, tightly-coupled approach of class inheritance. We’ll use a more general definition of object composition from “Categorical Methods in Computer Science: With Aspects from Topology” (1989): “Composite objects are formed by putting objects together such that each of the latter is ‘part of’ the former.” Another good reference is “Reliable Software Through Composite Design”, Glenford J Myers, 1975. Both books are long out of print, but you can still find sellers on Amazon or eBay if you’d like to explore the subject of object composition in more technical depth. Class inheritance is just one kind of composite object construction. All classes produce composite objects, but not all composite objects are produced by classes or class inheritance. “Favor object composition over class inheritance” means that you should form composite objects from small component parts, rather than inheriting all properties from an ancestor in a class hierarchy. The latter causes a large variety of well-known problems in object oriented design: The tight coupling problem: Because child classes are dependent on the implementation of the parent class, class inheritance is the tightest coupling available in object oriented design. The fragile base class problem: Due to tight coupling, changes to the base class can potentially break a large number of descendant classes — potentially in code managed by third parties. The author could break code they’re not aware of. The inflexible hierarchy problem: With single ancestor taxonomies, given enough time and evolution, all class taxonomies are eventually wrong for new use-cases. The duplication by necessity problem: Due to inflexible hierarchies, new use cases are often implemented by duplication, rather than extension, leading to similar classes which are unexpectedly divergent. Once duplication sets in, it’s not obvious which class new classes should descend from, or why. The gorilla/banana problem: “…the problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.” ~ Joe Armstrong, “Coders at Work” The most common form of object composition in JavaScript is known as object concatenation (aka mixin composition). It works like ice-cream. You start with an object (like vanilla ice-cream), and then mix in the features you want. Add some nuts, caramel, chocolate swirl, and you wind up with nutty caramel chocolate swirl ice cream. Building composites with class inheritance: 123456789101112class Foo &#123; constructor () &#123; this.a = 'a' &#125;&#125;class Bar extends Foo &#123; constructor (options) &#123; super(options); this.b = 'b' &#125;&#125;const myBar = new Bar(); // &#123;a: 'a', b: 'b'&#125; Building composites with mixin composition: 1234567const a = &#123; a: 'a'&#125;;const b = &#123; b: 'b'&#125;;const c = &#123;...a, ...b&#125;; // &#123;a: 'a', b: 'b'&#125; We’ll explore other styles of object composition in more depth later. For now, your understanding should be: There’s more than one way to do it. Some ways are better than others. You want to select the simplest, most flexible solution for the task at hand. ConclusionThis isn’t about functional programming (FP) vs object-oriented programming (OOP), or one language vs another. Components can take the form of functions, data structures, classes, etc… Different programming languages tend to afford different atomic elements for components. Java affords classes, Haskell affords functions, etc… But no matter what language and what paradigm you favor, you can’t get away from composing functions and data structures. In the end, that’s what it all boils down to. We’ll talk a lot about functional programming, because functions are the simplest things to compose in JavaScript, and the functional programming community has invested a lot of time and effort formalizing function composition techniques. What we won’t do is say that functional programming is better than object-oriented programming, or that you must choose one over the other. OOP vs FP is a false dichotomy. Every real Javascript application I’ve seen in recent years mixes FP and OOP extensively. We’ll use object composition to produce datatypes for functional programming, and functional programming to produce objects for OOP. No matter how you write software, you should compose it well. The essence of software development is composition. A software developer who doesn’t understand composition is like a home builder who doesn’t know about bolts or nails. Building software without awareness of composition is like a home builder putting walls together with duct tape and crazy glue. It’s time to simplify, and the best way to simplify is to get to the essence. The trouble is, almost nobody in the industry has a good handle on the essentials. We as an industry have failed you, the software developer. It’s our responsibility as an industry to train developers better. We must improve. We need to take responsibility. Everything runs on software today, from the economy to medical equipment. There is literally no corner of human life on this planet that is not impacted by the quality of our software. We need to know what we’re doing. It’s time to learn how to compose software. Continued in “The Rise and Fall and Rise of Functional Programming”","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"hof","slug":"hof","permalink":"http://nthung2112.github.io/tags/hof/"}]},{"title":"Sử dụng ký pháp BEM trong CSS","slug":"Su-dung-ky-phap-BEM-trong-CSS","date":"2018-05-20T09:05:00.000Z","updated":"2018-05-20T09:16:00.943Z","comments":true,"path":"2018/05/Su-dung-ky-phap-BEM-trong-CSS.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Su-dung-ky-phap-BEM-trong-CSS.html","excerpt":"Ký pháp BEM là gìBEM viết tắt của Blocks, Elements, Modifiers, là một phương pháp đặt tên class cho HTML và CSS. Được phát triển tại Yandex giúp lập trình viên hiểu rõ hơn mối quan hệ giữa HTML và CSS trong dự án front end.","text":"Ký pháp BEM là gìBEM viết tắt của Blocks, Elements, Modifiers, là một phương pháp đặt tên class cho HTML và CSS. Được phát triển tại Yandex giúp lập trình viên hiểu rõ hơn mối quan hệ giữa HTML và CSS trong dự án front end.Ví dụ sau đây sẽ minh hoạ cách sử dụng ký pháp BEM: 123456789/* Một Block (khối) độc lập */.btn &#123;&#125;/* Element (phần tử) con, phụ thuộc vào Block ở trên */.btn__price &#123;&#125;/* Modifier (bộ điều chỉnh) thay đổi trạng thái của Block */.btn--orange &#123;&#125;.btn--big &#123;&#125; Với cách đặt tên class này, ta có Block sẽ đại diện cho một component, và trong ví dụ ở đây, là một button .btn. Block cũng sẽ đóng vai trò là một parent mà trong nó sẽ có một hoặc nhiều hơn Element con liên quan. Tên class cho Element và mối quan hệ của nó với Block sẽ được diễn tả bằng tên của Block, tiếp theo là hai gạch dưới, và cuối cùng là tên của Element .btn__price. Thành phần thứ ba của BEM là các Modifier mà chúng sẽ giúp điều chỉnh các trạng thái hoặc phái sinh khác của Block / Element. Tên của Modifier sẽ được nối với tên Block / Element phía trước bởi 02 gạch ngang .btn--orange. Trong HTML, ký pháp BEM sẽ được dùng như sau: 1234&lt;a class=\"btn btn--big btn--orange\" href=\"http://int3ractive.com\"&gt; &lt;span class=\"btn__price\"&gt;$9.99&lt;/span&gt; &lt;span class=\"btn__text\"&gt;Subscribe&lt;/span&gt;&lt;/a&gt; Ấn tượng đầu tiên với bạn có thể là tên class quá xấu và mất thời gian hơn so với việc tạo riêng một class mới cho một kiểu button mới. Tuy nhiên, ký pháp BEM sẽ mang lại nhiều lợi ích mà tôi sẽ phân tích tiếp theo sau đây: Tại sao sử dụng ký pháp BEMTrước tiên, ký pháp BEM giúp người mới tham gia dự án dễ dàng phát hiện ra các trạng thái và các đối tượng con của một component đã được viết sẵn. Điều này giúp tránh cho họ phải viết lại những kiểu CSS đã có sẵn và hạn chế việc viết thừa code hoặc trùng kiểu CSS, điều mà rất hay xảy ra trong dự án lớn có nhiều người tham gia. Thứ hai, chỉ cần đọc HTML, bạn vẫn có thể nhanh chóng nắm được các thành phần phụ thuộc lẫn nhau. Trong ví dụ trên, bạn dễ dàng nhìn thấy .btn__price phụ thuộc vào .btn mặc dù bạn chưa biết vai trò cụ thể của nó ngay lập tức. Thứ ba, với ký pháp BEM, mọi định nghĩa chỉ có một cấp class và không lồng cấp. Điều này giúp cho độ ưu tiên (specificity) chung của hệ thống CSS thấp. Đây là một lợi thế vì sau này bạn không phải “chiến đấu” với specificity của những thuộc tính đã có sẵn (VD: siêu lồng cấp .a .b .c .d .e {...}) cũng như vận dụng những kỹ thuật không hay để thay thế được style (chẳng hạn !important hay inline CSS). Quy luật thác nước cascading của CSS là con dao hai lưỡi: nó giúp dễ dàng định nghĩa những thuộc tính và kiểu chung trên những selector tổng quát mà không cần phải khai báo lặp lại trên từng phần tử, nhưng nếu không nắm được tầm ảnh hưởng, lập trình viên CSS rất dễ gây ra những tác động phụ đến các đối tượng không liên quan khi chỉnh sửa trên những class có sẵn hoặc thậm chí viết mới. Với ký pháp BEM, lập trình viên sẽ tự tin hơn khi bắt tay chỉnh sửa hoặc viết thêm style vì đã biết rõ tầm ảnh hưởng của selector mà mình đang viết ra. Tóm lại, ký pháp BEM, nếu áp dụng triệt để, sẽ giúp cải thiện sự phối hợp giữa các thành viên trong nhóm. Ngoài ra, nó buộc người viết CSS phải đầu tư suy nghĩ về việc xây dựng những component độc lập và tái sử dụng được (phù hợp với tiêu chí của OOCSS). Sử dụng BEM với SASSVới phiên bản SASS mới nhất hiện nay, việc viết theo ký pháp BEM trong SCSS dễ dàng và thuận tiện hơn bao giờ hết. Bạn vẫn sẽ sử dụng cách viết lồng để cô lập khối component và kết hợp với biểu tượng parent &amp; của SASS để đặt tên cho Element và Modifier mà không phải đánh lại tên của Block. VD: 123456.block &#123; &amp;__element &#123;&#125; &amp;--mod &#123;&#125;&#125; Mặc dù viết lồng cấp, khi được biên dịch thành CSS, chúng vẫn được trải phẳng thành một cấp class theo đúng tinh thần của BEM: 12345.block &#123;&#125;.block__element &#123;&#125;.block--mod &#123;&#125; Nếu bạn sử dụng LibSass (nhanh hơn rất nhiều lần bản gốc Ruby) để biên dịch SASS, thì hãy đảm bảo các công cụ wrapper được cập nhật các phiên bản tương đương hoặc mới hơn như sau: node-sass 3.4.0, gulp-sass 2.1.0 (nếu sử dụng GulpJS) và grunt-sass 1.1.0 (nếu sử dụng GruntJS) Thế còn LESS? Vì tôi không sử dụng LESS nên sẽ không đề cập ở đây. Bạn có thể giúp bổ sung hướng dẫn cho LESS nếu nó có cú pháp trợ giúp tương đương. Các ý kiến không đồng tìnhVẫn có một số ý kiến hoài nghi và không đồng tình với phương pháp đặt tên này. Tên class quá xấuĐồng ý với bạn rằng BEM trông kỳ quặc, tuy nhiên khả năng mà nó đem lại vô cùng lớn và sẽ hoàn toàn xoá mờ hạn chế về mặt “ngoại hình” của nó. Ngoài ra BEM đòi hỏi phải gõ nhiều chữ hơn và chiếm nhiều byte ký tự hơn, tuy nhiên với việc sử dụng SASS như trên và việc gzip file đã trở thành tiêu chuẩn như hiện nay, những điều đó không còn là vấn đề so với lợi ích mà BEM mang lại. Descendant selector vẫn giải quyết được vấn đề như trước giờCó một chỉ trích dành cho BEM thế này: Thay vì viết 123.site-search &#123;&#125;.site-search__field &#123;&#125;.site-search--full &#123;&#125; Họ đặt vấn đề rằng tại sao không viết như thế này: 123.site-search &#123;&#125;.site-search input &#123;&#125;.site-search.full &#123;&#125; Rõ ràng cả hai cách viết đều có thể giúp hiện thực được component cụ thể này và cách thứ hai có vẻ “gọn gàng” hơn. Tuy nhiên khi CSS của toàn bộ dự án trở nên lớn và phức tạp hơn, thì rất khó tránh khỏi các kiểu được định nghĩa chồng chéo lên nhau ngoài tầm kiểm soát. Thử tưởng tượng .site-search cũng nằm trong một container tên .main và những input bên trong .main cần được style với .main input. Như vậy, input bên trong .site-search sẽ bị điều chỉnh một cách không mong muốn. Tương tự, nếu như .full trong ví dụ trên hoặc một tên phổ biến như .label được dùng như modifier, thì sẽ có rủi ro (rất cao) là một ngày nào đó một lập trình viên khác định nghĩa một class global trùng tên và sẽ làm hỏng style của element kia. Ngoài ra, khi bạn đọc trong ngữ cảnh HTML, bạn sẽ khó thấy được quan hệ ràng buộc giữa input và .full với block .site-search. “Tôi đơn giản là không thích ký pháp này”Một số người khi nhìn thấy cách đặt tên BEM đã ngay lập tức bác bỏ nó. Họ không thích BEM, đó là quyền của họ, tuy nhiên sẽ là vô lý nếu phản bác việc cần có một số quy tắc đặt tên để dễ dàng nắm bắt và quản lý CSS trong dự án trung và lớn. Hơn nữa, bạn hoàn toàn có thể nghĩ ra cho mình một cách đặt tên khác cho hợp sở thích, nhưng vẫn dựa trên nguyên tắc của BEM đã đề ra. Là kết quả đúc kết từ những kiến trúc CSS lớn và phức tạp trước đây, đề xuất của BEM không phải vô tình lại có một số điểm chung với các phương pháp quản lý CSS khác như SMACSS hay OOCSS. Lấy ví dụ khái niệm module của SMACSS: 12345678/* Ví dụ một module */.btn &#123; &#125;/* Modifier của một module */.btn-primary &#123; &#125;/* Btn Module với State */.btn.is-collapsed &#123; &#125; Trong các phương pháp quản lý CSS vừa kể trên thì chỉ có BEM là làm rõ được mối quan hệ với các thành phần con bên trong. Tóm lại, mỗi phương pháp đều có ưu nhược điểm. Quan trọng là cả team phải có phương pháp tiếp cận khoa học và áp dụng triệt để thì kiến trúc CSS của cả dự án mới vững và dễ bảo trì. Câu hỏi thường gặp:❓Hỏi: Element có modifier hay không?💬️ Đáp: Có. Element có thể có modifier riêng của nó. Ví dụ: 123.accordion__copy--open &#123; display: block;&#125; ❓Hỏi: Có cần phải đặt tên class cho tất cả element (thẻ HTML) trong block hay không?💬️ Đáp: Không cần thiết, chỉ những element cần có style riêng được viết trong CSS. Tuy nhiên cũng không nên lạm dụng những thẻ wrapper (phổ biến nhất là DIV) một cách vô tội vạ và không có chức năng vai trò cụ thể nào. Như vậy việc đặt tên element con cũng khiến bạn phải suy nghĩ một tag nào đó có thật sự cần thiết thêm vào trong block hay không. ❓Hỏi: Bên trong element con foo có một tag đóng vai trò một element con bar khác của block, vậy việc đặt tên class cho element bar này như thế nào? Có nên đặt là .block__foo__bar?💬️ Đáp: Vẫn đặt bằng tên block và hai gạch dưới rồi đến tên element .block__bar, không chen giữa bằng foo__. Nói tóm lại, tên của element chỉ cần thể hiện quan hệ phụ thuộc với block, không cần phải chỉ rõ sự lồng bên trong nhau của các element con. (Xem thêm ví dụ trong câu hỏi tiếp theo) ❓Hỏi: Một thẻ HTML có thể là element của 2 block khác nhau không?💬️ Đáp: Hoàn toàn có thể. Hãy xem ví dụ sau: 1234&lt;a class=\"btn btn--big btn--orange\" href=\"http://int3ractive.com\"&gt; &lt;span class=\"btn__price\"&gt;&lt;i class=\"icon icon--dollar-sign btn__icon\"&gt;&lt;/i&gt;9.99&lt;/span&gt; &lt;span class=\"btn__text\"&gt;Subscribe&lt;/span&gt;&lt;/a&gt; Button có biểu tượng dollar-sign là một block .icon. Có thể trong block .btn, biểu tượng dollar-sign cần được style riêng, nên cần có một cái tên xác định rõ vai trò và style cho element này là .btn__icon. Nếu block .icon.icon--dollar-sign được dùng ở một ngữ cảnh khác, thì rõ ràng nó không cần class .btn__icon nữa vì tên class đã chỉ rõ sự ràng buộc với block .btn và chỉ được thêm vào khi ở bên trong nó. ❓Hỏi: Một element con có thể đóng vai trò là block của riêng nó không? Có thể xây dựng chuỗi component phụ thuộc nhau như .a__b__c không?💬️ Đáp: Câu hỏi này thật sự ngoài tầm hiểu biết và kinh nghiệm của tôi. Có thể có những hoàn cảnh đặt biệt như vậy. Tuy nhiên, theo tôi, nếu có cũng không nên quá 2 cấp, tức là element con chỉ đặt đến .a__b__c là tối đa. Điều này là để sự phụ thuộc không quá sâu, làm giảm khả năng dùng lại của block (portability) và sự linh hoạt của các đối tượng CSS theo tinh thần OOCSS. Xem ví dụ bên dưới. 1234567/* block list */.list &#123; &#125;/* item là con của list */.list__item &#123; &#125;/* link là con của block list__item, để phân biệt với list__linkhoặc chỉ rõ mối quan hệ phụ thuộc giữa item và link*/.list__item__link &#123; &#125; Sai lầm hay mắc phải khi sử dụng BEM:Tôi xin hẹn lại về vấn đề này trong một bài viết khác, khi mà bản thân đã ứng dụng nhiều và quan sát được những ví dụ thực tiễn hơn để tổng hợp những sai lầm hay mắc phải do ảnh hưởng từ phương pháp cũ cũng như cách hiểu chưa đúng về phương pháp BEM này. Xem thêm: Bài viết giới thiệu BEM của CSSWizadry Bài viết giới thiệu BEM của Smashing Magazine Sử dụng BEM và @extend của SASS Bài viết 5 sai lầm phổ biến với BEM","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"}]},{"title":"Giới thiệu Progressive Web App","slug":"Gioi-thieu-Progressive-Web-App","date":"2018-05-18T00:30:00.000Z","updated":"2018-05-18T00:43:05.756Z","comments":true,"path":"2018/05/Gioi-thieu-Progressive-Web-App.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Gioi-thieu-Progressive-Web-App.html","excerpt":"Progressive Web App (PWA) là một dạng ứng dụng web (web app) mới đang thu hút rất nhiều sự quan tâm từ các nhà phát triển web khắp thế giới đặc biệt là các doanh nghiệp hoạt động trực tuyến, tuy nhiên nó vẫn còn khá mới mẻ tại Việt Nam.","text":"Progressive Web App (PWA) là một dạng ứng dụng web (web app) mới đang thu hút rất nhiều sự quan tâm từ các nhà phát triển web khắp thế giới đặc biệt là các doanh nghiệp hoạt động trực tuyến, tuy nhiên nó vẫn còn khá mới mẻ tại Việt Nam.Đã có nhiều bài viết liên quan đến PWA dành cho lập trình viên, cho nên trong bài viết này tôi sẽ cố gắng giải thích PWA để người dùng Web phổ thông vẫn có thể hiểu. Progressive Web App là gì?PWA là ứng dụng web được viết để tận dụng những tính năng mới nhất của trình duyệt Web trên máy tính để bàn (desktop) lẫn điện thoại thông minh, nhưng đồng thời vẫn chạy được trên những trình duyệt và thiết bị cũ hơn. PWA lấy phương pháp Cải Tiến Tăng Dần (Progressive Enhancement) làm cốt lõi (nên mới có chữ Progressive). Đối với những trình duyệt và thiết bị cũ, PWA hoạt động như một mobile website thông thường. Nhưng với những trình duyệt trên thiết bị di động mới nhất, PWA hoạt động như một mobile app[^1] thực thụ. Những tác giả của khái niệm PWA (đến từ nhóm phát triển trình duyệt Chrome) đã đưa ra những đặc tính cần có của một PWA như sau: Progressive - Chạy được trên mọi (nên hiểu: tuyệt đại đa số) thiết bị, do được phát triển với phương pháp Cải Tiến Tăng Dần. Responsive - Có thiết kế giao diện tùy ứng (responsive design), hiển thị và sử dụng được trên mobile, tablet, laptop hay bất kỳ cỡ màn hình nào trong tương lai. Connectivity independent - PWA vẫn có thể hoạt động tốt với điều kiện kết nối mạng chập chờn hoặc mất hẳn (offline). App-like - Có giao diện và trải nghiệm như mobile app thực thụ. Fresh - Dù nó hoạt động như mobile app, nhưng tính năng và giao diện luôn được cập nhật tức thời nhờ nền tảng Web (không cần người dùng update từ Apple App Store hay Google Play - gọi chung là app store). Safe - PWA phải được tải thông qua giao thức TLS (hay nôm na là HTTPS), để đảm bảo việc trao đổi dữ liệu không bị bên thứ ba can thiệp. Discoverable - Thông qua file khai báo chuẩn (được thống nhất bởi tổ chức W3C), mà các PWA dễ dàng được các cỗ máy tìm kiếm đánh dấu và thông báo cho người dùng. Re-engageable - PWA cho phép việc tái tiếp cận người dùng dễ dàng hơn nhờ những tính năng đặc biệt như là push notification (thông báo chủ động). Installable - PWA cho phép người dùng dễ dàng lưu lại web app trên điện thoại (thường là trên màn hình home screen) mà không cần phải vào app store Linkable - Dễ dàng share app chỉ với đường link và không cần người nhận phải cài đặt phức tạp chỉ để xem được nội dung bạn muốn share. Những điểm khác biệt của Progressive Web App?Trước tiên cần hiểu rằng, sự tiến hóa của mobile web app cần sự hợp tác của rất nhiều bên liên quan trong đó có các nhà phát triển trình duyệt, hệ điều hành di động, và cả những chuyên gia về ngôn ngữ lập trình cho Web. Sự tiến hóa của mobile web thường đi cùng với sự phát triển và chuẩn hóa của nền tảng Web do tổ chức W3C[^2] chịu trách nhiệm. Khi tôi tư vấn và phát triển app cho khách hàng, rất nhiều lần doanh nghiệp từ chối lựa chọn giải pháp web app hoặc hybrid app với lý do chính là “HTML5 không nhanh bằng native”. Tuy nhiên điều này không còn đúng tại thời điểm hiện tại. Nhờ những cải tiến của phần cứng thiết bị, hệ điều hành di động, trình duyệt, và nhất là đặc tả Web trong vài năm gần đây mà web app đã thêm những khả năng không thua kém native app như: Giao diện tương tác mượt mà hơn, đặt biệt là hỗ trợ đồ họa 3D, animation từ phần cứng (hardware accelerated) Khả năng chơi video, audio thông qua trình duyệt mobile đã hoàn thiện và định dạng gần như đã thống nhất. Bàn phím ảo thích ứng với trường nhập web form khác nhau: email, URL, telephone… Có khả năng truy xuất các sensor và bộ phận đa phương tiện của thiết bị: định vị GPS, con quay hồi chuyển, trạng thái pin, network, camera, microphone… Cơ sở dữ liệu (CSDL) tại trình duyệt cho phép tìm kiếm và truy cập nhanh lượng dữ liệu lớn và cho phép người dùng trở lại trang web app nhanh hơn. Đặc tả mới về CSS cho phép designer và front end developer tạo giao diện tùy ứng (responsive design) và giao diện giống app dễ dàng hơn. Dù vậy, web app vẫn còn một số hạn chế so với native app. Chúng ta hãy xem PWA đã được bổ sung những khả năng gì để có thể xóa dần khoảng cách giữa web và native: Kết luậnĐược giới thiệu chính thức từ 2015, PWA đã trải qua thời gian thử nghiệm và trưởng thành đủ lâu để giờ đây chúng ta có thể khẳng định PWA chính là tương lai của Web và Web App. PWA đóng góp thêm một giải pháp ứng dụng di động nhiều hứa hẹn, giải phóng doanh nghiệp khỏi sự lệ thuộc vào app store, những hạn chế của native app. Và nếu được thiết kế hợp lý, PWA sẽ là giải pháp hợp nhất cho “mọi nền tảng” từ desktop đến mobile. Ghi chú:[^1]: Xin tóm tắt lại một số thuật ngữ về “app” trên thiết bị di động: Mobile app hoặc native app: (ở Việt Nam thường gọi tắt là “app”) là ứng dụng được cài đặt từ app store, được viết bằng ngôn ngữ lập trình dành riêng cho từng hệ điều hành di động khác nhau. (Mobile) web app: là website chạy trên trình duyệt của smart phone nhưng có trải nghiệm giống app và thường trao đổi nhiều dữ liệu giữa người dùng và website. Hybrid app: là ứng dụng được cài đặt từ app store, tuy nhiên được viết bằng cùng ngôn ngữ lập trình với web app. Dù hybrid app có thể cài được trên nhiều HĐH khác nhau nhưng nó chỉ cần được viết cùng một bộ mã nguồn với một ít điều chỉnh riêng cho mỗi loại HĐH mà nó hỗ trợ. [^2]: Tổ chức World Wide Web Consortium có trách nhiệm chuẩn hóa các đặc tả về Web và khuyến khích các trình duyệt khác nhau phải tuân theo để các website hoạt động một cách đồng nhất bất kể trình duyệt dùng để hiển thị. [^3]: URL là đường link đến một trang web bất kỳ [^4]: Các trình duyệt phổ biến nhất bao gồm: Chrome, Firefox, Safari, MS Edge, Opera, Samsung Internet, UC Browser. Tại Việt Nam, trình duyệt phổ biến thứ 2 sau Chrome là CocCoc. Tuy nhiên CocCoc cũng là một trình duyệt biến thể từ mã nguồn mở của Chrome nên những tính năng của PWA cũng sẽ được hỗ trợ. [^5]: Người dùng sẽ vẫn nhận được push notification cho dù họ không lưu app về home screen chỉ cần họ đã bấm đồng ý nhận push notification. Việc yêu cầu gửi push notification cần thận trọng và chỉ thực hiện khi người dùng đã thể hiện sự quan tâm đến dịch vụ của bạn. (Nếu không khả năng người dùng từ chối nhận push notification là rất cao)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"pwa","slug":"pwa","permalink":"http://nthung2112.github.io/tags/pwa/"}]},{"title":"Giới thiệu về redux saga","slug":"Gioi-thieu-ve-redux-saga","date":"2018-04-30T11:37:00.000Z","updated":"2018-04-30T11:52:22.931Z","comments":true,"path":"2018/04/Gioi-thieu-ve-redux-saga.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Gioi-thieu-ve-redux-saga.html","excerpt":"Redux-Saga là gì?Redux-Saga là một thư viện redux middleware, giúp quản lý những side effect trong ứng dụng redux trở nên đơn giản hơn. Bằng việc sử dụng tối đa tính năng Generators (function*) của ES6, nó cho phép ta viết async code nhìn giống như là synchronos.","text":"Redux-Saga là gì?Redux-Saga là một thư viện redux middleware, giúp quản lý những side effect trong ứng dụng redux trở nên đơn giản hơn. Bằng việc sử dụng tối đa tính năng Generators (function*) của ES6, nó cho phép ta viết async code nhìn giống như là synchronos. Saga không chỉ tồn tại trong thế giới javascript, nó còn được coi là 1 pattern. Bạn có thể xem qua về saga pattern bằng clip này: https://youtu.be/xDuwrtwYHu8 Một cách nhìn nhanh chóng thì Saga pattern là cách để quản lý những long transaction với những side effect hoặc các nguy cơ tiềm ẩn. Với mỗi transaction thành công, chúng ta đều cần có counter-transaction để revert transaction đó về trạng thái ban đầu nếu gặp trục trặc. Tham khảo thêm về saga pattern với bài viết của Roman Liutikov : Confusion about Saga pattern Side effect là gì??Ta đã biết tất cả những xử lý ở REDUCER đều phải là synchronous và pure tức chỉ là xử lý đồng bộ. Nhưng trong ứng dụng thực tế thì cần nhiều hơn vậy ví dụ như asynchronous (thực hiện một số việc như gọi một hàm AJAX để fetch dữ liệu về nhưng cần đợi kết quả chứ kết quả không trả về ngay được) hoặc là impure (thực hiện lưu, đọc dữ liệu ra bên ngoài như lưu dữ liệu ra ổ cứng hay đọc cookie từ trình duyệt… đều cần đợi kết quả). Những việc như thế trong lập trình hàm gọi nó là side effects. Generator function là gì??Khác với function bình thường là thực thi và trả về kết quả, thì Generator function có thể thực thi, tạm dừng trả về kết quả và thực thi bằng tiếp. Từ khóa để làm được việc đấy là “YIELD”. Generator được đưa ra cách đây mấy chục năm nhưng đến ES2015 mới được bổ sung, các ngôn ngữ khác đã được bổ sung tính năng này như C#, PHP, Ruby, C++, R… Redux-Saga hoạt động như thế nào??Đối với logic của saga, ta cung cấp một hàm cho saga, chính hàm này là hàm đứng ra xem xét các action trước khi vào store, nếu là action quan tâm thì nó sẽ thực thi hàm sẽ được thực thi, nếu bạn biết khái niệm hook thì hàm cung cấp cho saga chính là hàm hook. Điều đặc biệt của hàm hook này nó là một generator function, trong generator function này có yield và mỗi khi yield ta sẽ trả về một plain object. Object trả về đó được gọi Effect object. effect object này đơn giản chỉ là một object bình thường nhưng chứa thông tin đặc biệt dùng để chỉ dẫn middleware của Redux thực thi các hoạt động khác ví dụ như gọi một hàm async khác hay put một action tới store. Để tạo ra effect object đề cập ở trên thì ta gọi hàm từ thư viện của saga là redux-saga/effects. Tại sao tôi phải sử dụng Saga??Khi bắt đầu tìm tòi về redux, bạn hay tìm thấy các bài hướng dẫn sử dụng redux-thunk hoặc redux-saga để quản lý các async action. Vậy tại sao bạn lại được khuyên sử dụng redux-saga ? Trích dẫn trong document của redux-saga: Contrary to redux thunk, you don’t end up in callback hell, you can test your asynchronous flows easily and your actions stay pure. _Tạm dịch: trái với redux thunk, bạn không cần phải phát dồ lên với các callback trong mỗi action, đến với saga đi, bạn có thể test các async action với một quy trình dễ dàng mà không làm hư các action đó ! So sánh saga và thunk: redux-thunk 1234567891011121314151617181920212223import &#123; API_BUTTON_CLICK, API_BUTTON_CLICK_SUCCESS, API_BUTTON_CLICK_ERROR,&#125; from './actions/consts';import &#123; getDataFromAPI &#125; from './api';const getDataStarted = () =&gt; (&#123; type: API_BUTTON_CLICK &#125;);const getDataSuccess = data =&gt; (&#123; type: API_BUTTON_CLICK_SUCCESS, payload: data &#125;)const getDataError = message =&gt; (&#123; type: API_BUTTON_CLICK_ERROR. payload: message &#125;);const getDataFromAPI = () =&gt; &#123; return dispatch =&gt; &#123; dispatch(getDataStarted()); getDataFromAPI() .then(data =&gt; &#123; dispatch(getUserSuccess(data)); &#125;).fail(err =&gt; &#123; dispatch(getDataError(err.message)); &#125;) &#125;;&#125;; Ở đây ta có một action creator getDataFromAPI() bắt đầu async progress như sau: Đầu tiên bắn ra action cho phép store biết rằng chuẩn bị 1 API request ( dispatch(getDataStarted()) Tiếp theo thực hiện API request trả về một Promise Cuối cùng bắn ra success action nếu request thành công hoặc error action nếu có lỗi redux-saga 12345678910111213141516171819202122import &#123; call, put, takeEvery &#125; from 'redux-saga/effects';import &#123; API_BUTTON_CLICK, API_BUTTON_CLICK_SUCCESS, API_BUTTON_CLICK_ERROR,&#125; from './actions/consts';import &#123; getDataFromAPI &#125; from './api';export function* apiSideEffect(action) &#123; try &#123; const data = yield call(getDataFromAPI); yield put(&#123; type: API_BUTTON_CLICK_SUCCESS, payload: data &#125;); &#125; catch (e) &#123; yield put(&#123; type: API_BUTTON_CLICK_ERROR, payload: e.message &#125;); &#125;&#125;// the 'watcher' - on every 'API_BUTTON_CLICK' action, run our side effectexport function* apiSaga() &#123; yield takeEvery(API_BUTTON_CLICK, apiSideEffect);&#125; Cùng một process, nhưng cách implement khác nhau hoàn toàn. put thay cho dispatch function cuối (apiSaga()) giúp theo dõi tổng thể toàn bộ các action (ở đây có API_BUTTON_CLICK) Với cách gọi của redux-saga, chúng ta có thể get data từ bất kì async function nào (promise, …) Nhận xétCả 2 cách implement đều dễ đọc, tuy nhiên đối với redux-thunk , bạn phải đối đầu với một tá các promise, các callback nếu có, rất mất thời gian cho người maintain đọc và tìm code. Với redux-saga , đơn giản bạn chỉ cần track theo try/catch block để theo dõi dòng code, bên cạnh đó còn có hàm giúp bạn track các action một cách dễ dàng. Kết luậnỞ bài viết này mình đề cập đến 2 điểm nhấn chính của redux-saga là giữ cho action pure synchronos theo chuẩn redux và loại bỏ hoàn toàn callback theo javascript truyền thống. Bài viết tiếp theo mình sẽ đề cập nốt key point cuối cùng của saga là easy to test.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://nthung2112.github.io/tags/redux/"},{"name":"saga","slug":"saga","permalink":"http://nthung2112.github.io/tags/saga/"}]},{"title":"Thinking in React","slug":"Thinking-in-React","date":"2018-04-30T09:47:00.000Z","updated":"2018-04-30T10:03:55.328Z","comments":true,"path":"2018/04/Thinking-in-React.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Thinking-in-React.html","excerpt":"React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram. Một trong những phần quan trọng nhất của React là cách nó tạo ra cách nghĩ của bạn về các ứng dụng mà bạn xây dựng. Trong tài liệu này, chúng tôi sẽ hướng dẫn bạn cách để xây dựng một ứng dụng tìm kiếm sản phẩm trong table với React.","text":"React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram. Một trong những phần quan trọng nhất của React là cách nó tạo ra cách nghĩ của bạn về các ứng dụng mà bạn xây dựng. Trong tài liệu này, chúng tôi sẽ hướng dẫn bạn cách để xây dựng một ứng dụng tìm kiếm sản phẩm trong table với React. Bắt đầuGiả dụ bạn đã có sẵn một JSON API và giao diện đã sẵn sàng gọi đến nó. Cụ thể như ảnh sau: Dữ liệu trả về có dạng như sau: 12345678[ &#123;category: \"Sporting Goods\", price: \"$49.99\", stocked: true, name: \"Football\"&#125;, &#123;category: \"Sporting Goods\", price: \"$9.99\", stocked: true, name: \"Baseball\"&#125;, &#123;category: \"Sporting Goods\", price: \"$29.99\", stocked: false, name: \"Basketball\"&#125;, &#123;category: \"Electronics\", price: \"$99.99\", stocked: true, name: \"iPod Touch\"&#125;, &#123;category: \"Electronics\", price: \"$399.99\", stocked: false, name: \"iPhone 5\"&#125;, &#123;category: \"Electronics\", price: \"$199.99\", stocked: true, name: \"Nexus 7\"&#125;]; Bước 1: Chia UI thành component theo bậcViệc đầu tiên bạn sẽ phải vẽ các hộp xung quanh mỗi component ( và subcomponent ) và đặt tên cho chúng. Nhưng bạn phân vân không biết khi nào nên tạo ra component? Đối với component, một kĩ thuật được sử dụng rộng rãi để design component là sử dụng nguyên tắc đơn nhiệm. Khi các component được sinh ra quá nhiều, bạn hãy tách chúng ra thành nhiều subcomponent. Đối với việc thuường xuyên hiển thị dữ liệu JSON, bạn nên đảm bảo về tính đúng đắn của model, liệu rằng nó sẽ được map chính xác với UI ( các component ) của bạn? Bởi vì UI và các model luôn phải dính liền với cấu trúc của thông tin, có nghĩa là công việc phân chia UI sang component là không đáng kể. Cứ chia ra thành các component và hiển thị chính xác từng mẩu dữ liệu của bạn là ổn. Đối với dữ liệu trong ảnh, bạn sẽ nghĩ đến 5 component tương ứng với mỗi màu phải không? Sau đây là chi tiết cho từng component đó: FilterableProductTable (cam): chứa toàn bộ ví dụ SearchBar (xanh): nhận dữ liệu từ người dùng ProductTable (xanh lá cây): hiển thị và lọc dữ liệu dựa trên user input ProductCategoryRow (lam): hiển thị tiêu đề cho mỗi category ProductRow (đỏ): mỗi hàng là 1 sản phẩm Nếu bạn nhìn vào ProductTable , bạn sẽ thấy có header (bao gồm nhãn “Name” và “Price”) không phải là chính component của nó. Đây là vấn đề của việc tinh chỉnh. Ví dụ, chúng ta để phần header thuộc component ProductTable vì nó là một phần của việc render ra dữ liệu, đó là trách nhiệm của ProductTable. Tuy nhiên, nếu header này khi được sử dụng một cách phức tạp (như là tương tác với sắp xếp), nó sẽ phải tạo thêm một component riêng cho header gọi là ProductTableHeader chẳng hạn. Tóm lại, bạn nên phân chia cấu trúc của component và các subcomponent như sau: FilterableProductTable SearchBar ProductTable ProductCategoryRow ProductRow Bước 2: Xác định mức tối thiểu (nhưng hoàn chỉnh)Để UI của bạn tương tác tốt, bạn cần xác định các thay đổi đến dữ liệu thuộc tầng dưới (underlying data model) . Hãy sử dụng state của React. Đầu tiên bạn nên nghĩ đến việc tối giản các mutable state. Chìa khóa thành công ở đây là DRY: Don’t Repeat Yourself . Ví dụ với ứng dụng TODO, bạn chỉ cần giữ mảng các TODO item, không cần đến các state khác như để đếm số lượng. Thay vào đó, khi bạn muốn đếm số lượng của TODO item, đơn giản là lấy ra length của TODO item array. Cụ thể với dữ liệu mẫu trong bài viết này, chúng ta có: Nguyên mẫu danh sách sản phẩm Text tìm kiếm mà user nhập vào Value của checkbox Danh sách đã lọc sản phẩm Hãy suy nghĩ về việc bạn nên để cái nào là state, trong thời gian suy nghĩ, hãy đọc các câu hỏi dưới về luồng data: Có thể pass từ parent component thông qua props không? Nếu có, state là không cần thiết. Nó có giữ nguyên trạng thái dữ liệu suốt không? Nếu có, state không thể sử dụng được. Bạn có đoán được data dựa vào bất kì state hay props nào trong component không? Nếu có, chỗ này càng không phải chỗ cho state. Danh sách sản phẩm nguyên bản được pass thông qua props. Text tìm kiếm và checkbox dường như sẽ thích hợp với state vì nó có thể được thay đổi bất kì lúc nào bởi người dùng. Vậy cuối cùng, danh sách lọc sản phẩm cũng không thể nào là state bởi vì chúng có thể được tính toán thông qua list sản phẩm ban đầu dựa vào search text và checkbox. Tóm lại, bạn nên sử dụng state cho: Search text mà user nhập vào Giá trị của checkbox khi user sử dụng Bước 4: Xác định nơi sinh sống của stateHãy nhớ rằng, React là luồng dữ liệu một chiều, phụ thuộc theo luồng của các cấp component. Bạn không thể đoán ngay được component này sẽ có những state gì. Đây là việc chiếm nhiều thời gian và công sức nhất dành cho người mới tìm hiểu về react, hãy nhớ: đừng vội khẳng định state A thuộc component A. Để hình dung ra một cách rõ ràng, hãy theo các bước sau: Phân loại mỗi component sẽ render ra những gì dựa vào state đó. Tìm thử trong component cha Nếu component cha không có, tìm tiếp ở component cao hơn component cha đó Nếu bạn không tìm ra được component đang giữ state, thử tạo một conponent mới để giữ state đó và thêm nó ở đâu đó trong cấp thư mục cao hơn thư mục chứa component cha. Ví dụ cụ thể: ProductTable cần filter sản phẩm dựa vào state và SearchBar cần phải hiển thị text được nhập và state của checkbox. Component cha sẽ là FilterableProductTable Tất nhiên theo lẽ tự nhiên, search text và giá trị của checkbox sẽ được lưu ở trong FilterableProductTable. Bước 5: Thêm luồng dữ liệu… Và đây là kết quả KếtHy vọng rằng, bài viết này cho bạn ý tưởng làm thế nào để suy nghĩ về việc xây dựng các component với React. Mặc dù có thể khiến bạn gõ nhiều code hơn, hãy nhớ rằng code được đọc nhiều hơn nó được viết. Khi bạn bắt đầu xây dựng các thư viện component lớn, bạn sẽ đánh giá cao sự rõ ràng và tính mô đun, và với việc tái sử dụng code, các dòng code của bạn sẽ bắt đầu co lại.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Tổng hợp các cheat sheets tốt nhất của front-end","slug":"Tong-hop-cac-cheat-sheets-tot-nhat-cua-front-end","date":"2018-04-30T08:36:00.000Z","updated":"2018-04-30T11:52:12.794Z","comments":true,"path":"2018/04/Tong-hop-cac-cheat-sheets-tot-nhat-cua-front-end.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Tong-hop-cac-cheat-sheets-tot-nhat-cua-front-end.html","excerpt":"Chúng ta không thể nhớ thuộc lòng tất cả các API. Đây là lúc chúng ta cần các trang cheat sheets này! Dưới đây là các bản cheat sheets tốt nhất mà tôi đã thu thập được.","text":"Chúng ta không thể nhớ thuộc lòng tất cả các API. Đây là lúc chúng ta cần các trang cheat sheets này! Dưới đây là các bản cheat sheets tốt nhất mà tôi đã thu thập được. Javascript ES2015 features Javascript Javascript Regular expression React Redux Vuejs Vuex Angular 4 Flexbox SCSS Stylus GraphQL Missing your favorite cheatsheet? Please let me know in the comments!","categories":[],"tags":[{"name":"cheat sheets","slug":"cheat-sheets","permalink":"http://nthung2112.github.io/tags/cheat-sheets/"}]},{"title":"Tất cả những gì bạn cần biết về CSS-in-JS","slug":"Tat-ca-nhung-gi-ban-can-biet-ve-CSS-in-JS","date":"2018-04-30T08:19:00.000Z","updated":"2018-04-30T08:31:39.212Z","comments":true,"path":"2018/04/Tat-ca-nhung-gi-ban-can-biet-ve-CSS-in-JS.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Tat-ca-nhung-gi-ban-can-biet-ve-CSS-in-JS.html","excerpt":"TL;DR:Thinking in components — No longer do you have to maintain bunch of style-sheets. CSS-in-JS abstracts the CSS model to the component level, rather than the document level (modularity).","text":"TL;DR:Thinking in components — No longer do you have to maintain bunch of style-sheets. CSS-in-JS abstracts the CSS model to the component level, rather than the document level (modularity). Styled React Component Example You probably heard terms like CSS-in-JS, Styled Components, Radium, Aphrodite and you’re left there hanging “why is this a thing? — I’m perfectly happy with CSS-in-CSS (CSS in .css).” I’m here to shine some light on why this is a thing and hopefully we will least understand the concept and understand why it’s a thing. With that said — please feel free to use CSS-in-CSS — on no terms are you obligated to use CSS-in-JS. Whatever works best for you and makes you happy is hands down the best solution, always-always! CSS-in-JS is a delicate and controversial topic — I’m advocating having an open mind and weighing if this makes sense to you — ask yourself “will it improve my workflow?” —**in the end — that’s the only thing that matters — use tools that make you happier and more productive!** I’ve always felt awkward having to maintain a huge folder of stylesheets. I would like to try different approaches. I’ve seen many people asking if there are new styling ideas. CSS-in-JS is so far the best concept. Let’s give CSS-in-JS a shot. What is CSS-in-JS? JSS is a more powerful abstraction over CSS. It uses JavaScript as a language to describe styles in a declarative and maintainable way. It is a high performance JS to CSS compiler which works at runtime and server-side. This core library is low level and framework agnostic. It is about 6KB (minified and gzipped) and is extensible via plugins API. — source Keep in mind Inline styles and CSS-in-JS are not the same! They’re different — Quick demonstration time! How Inline Styles Works In the browser this will get attached to the DOM node like so: How CSS-in-JS works In the browser this will gets attached to the DOM like so: DifferenceSee the slight difference? CSS-in-JS attached a &lt;style&gt; tag on top of the DOM while inline styles just attached the properties to the DOM node. Why does this matter? Not all CSS features can be aliased with JavaScript event handlers , many pseudo selectors (like :disabled, :before, :nth-child) aren’t possible, styling the html and body tags isn’t supported etc. With CSS-in-JS, you have all the power of CSS at your fingertips. Since actual CSS is generated, you can use every media query and pseudo selector you can think of. Some libraries (like jss, styled-components) even add support for neat, non-CSS-native features like nesting! Brilliant article going in depth on how they’re different. “Just write the darn CSS in CSS and be done with it.” Yes — while that’s the case for how it’s been done for a long-long time — the challenge is modern web is written in components not pages. CSS was never actually made for component based approaches. CSS-in-JS solves exactly this problem. Shout-out to Vue for solving this problem beautifully even tho Vues styles have no access to components state. What are the benefits of using CSS-in-JS? Thinking in components — No longer do you have to maintain bunch of style-sheets. CSS-in-JS abstracts the CSS model to the component level, rather than the document level (modularity). CSS-in-JS leverages the full power of the JavaScript ecosystem to enhance CSS. “True rules isolation” — Scoped selectors are not enough. CSS has properties which are inherited automatically from the parent element, if not explicitly defined. Thanks to jss-isolate plugin, JSS rules will not inherit properties. Scoped selectors — CSS has just one global namespace. It is impossible to avoid selector collisions in non-trivial applications. Naming conventions like BEM might help within one project, but will not when integrating third-party code. JSS generates unique class names by default when it compiles JSON representation to CSS. Vendor Prefixing —The CSS rules are automatically vendor prefixed, so you don’t have to think about it. Code sharing — Easily share constants and functions between JS and CSS. Only the styles which are currently in use on your screen are also in the DOM (react-jss). Dead code elimination Unit tests for CSS! What are the drawbacks of using CSS-in-JS? Learning curve. New dependencies. Harder for newer teammates to adapt to the code-base. People who are new to front-end have to learn “more” things. Challenging the status quo. (not necessarily a con) The pros out-weight the cons heavily — let’s give CSS-in-JS a shot! Nothing to lose! Most popular CSS-in-JS libariesWill provide a quick hello world example for all the popular CSS-in-JS libraries— help yourself to choose which one you like the most based on the syntax. Styled Components JSS-React glamorous Radium (caveat: uses inline styles) Note: Radium uses decorators! Aphrodite Stylotron These are really simple examples which demonstrate the core functionality. All of the libraries have much more functionality included — for example, theming, dynamic props, server side rendering and much more! Excellent post going in depth about all of the features CSS-in-JS enables. Here’s the full list — go and give all the libraries a quick try! Hate it or love it — CSS-in-JS deserves a chance! Convinced CSS-in-JS is not for me? There’s another option — CSS Modules!Thanks for reading!","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Hiểu sâu về React Higher Order Components","slug":"Hieu-sau-ve-React-Higher-Order-Components","date":"2018-04-30T08:08:00.000Z","updated":"2018-04-30T08:31:59.004Z","comments":true,"path":"2018/04/Hieu-sau-ve-React-Higher-Order-Components.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Hieu-sau-ve-React-Higher-Order-Components.html","excerpt":"Giới thiệuChắc hẳn rất nhiều người trong chúng ta đã và đang sử dụng React, và tất nhiên là kèm theo hằng tá thư viện đi kèm hỗ trợ nó (lol) Và chắc hẳn bạn đã từng gặp thư viện yêu cầu bạn viết một đoạn code kiểu này để thư viện có thể hoạt động: 1234import &#123; connect &#125; from 'react-redux';...export default connect(mapStateToProps, mapDispatchToProps)(Component); // Kết nối Component với Store của Redux bằng thư viện react-redux","text":"Giới thiệuChắc hẳn rất nhiều người trong chúng ta đã và đang sử dụng React, và tất nhiên là kèm theo hằng tá thư viện đi kèm hỗ trợ nó (lol) Và chắc hẳn bạn đã từng gặp thư viện yêu cầu bạn viết một đoạn code kiểu này để thư viện có thể hoạt động: 1234import &#123; connect &#125; from 'react-redux';...export default connect(mapStateToProps, mapDispatchToProps)(Component); // Kết nối Component với Store của Redux bằng thư viện react-redux Hoặc là thế này 123456var Radium = require('radium');@Radiumclass Button extends React.Component &#123;...&#125;// Radium thư viện hỗ trợ inline style cho React element Và boom Component của chúng ta nhận được props, styles và thậm chí là render ra một view khác Các bạn đã bao giờ tự hỏi connect() @Radium kia là gì, tại sao lại viết như vậy. Vâng trong bài viết này chúng ta sẽ cùng tìm hiểu về một khái niệm nâng cao trong React - Higher-Order Components. Higher-Order Components In a NutshellWhat are Higher-Order Components (HoCs)?Về bản chất, HoC không phải là một phần của React API, nó là một pattern xuất hiện từ những thành phần đặc tính của React. Thường được implement như một function, mà về cơ bản, là một class factory (vâng, là một class factory!) Higher Order Component (HoC) là một function nhận vào một component và trả về một component mới. EnhancedComponent = higherOrderComponent(WrappedComponent); What can I do with HOCs?Ở cấp độ cao, HoC cho phép chúng ta: Code reuse, logic và tự động trừu tượng hóa (bootstrap abstraction) Chiếm quyền render (Render Highjacking) Trừu tượng hóa (abstraction) và điều khiển (manipulation) State Điều khiển Props Chúng ta sẽ xem chi tiết về những mục này, nhưng trước tiên, chúng ta sẽ học cách implement HoCs bởi vì việc implement cho chúng ta thấy những điều có thể và hạn chế mà chúng ta thực sự có thể làm với HoC. HOC factory implementationsCó 2 cách implement HoCs thường thấy trong React: Props Proxy (PP) và Inheritance Inversion (II). Cả 2 cách cho phép các cách khác nhau để thao tác với WrappedComponent. Trước khi bắt đầu chúng ta cần một project 1234create-react-app learnHOCcd learnHOC/src/touch HOC.jsnpm start Props ProxyProps Proxy (PP) được implement thông thường theo cách sau: 1234567function pP(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125;/&gt; &#125; &#125;&#125; Phần quan trọng nhất ở đây là method render của HoC trả về một React Element của kiểu WrappedComponent. Chúng ta cũng truyền props mà HoC nhận được, vì thế phương pháp này mới có tên Props Proxy. What can be done with Props Proxy? Điều khiển props Truy cập instance thông qua Refs Trừu tượng hóa (Abstracting) State Bao WrappedComponent với elements khác Điều khiển propsChúng ta có thể đọc, thêm, sửa đổi và xóa props được truyền cho WrappedComponent. Nhưng cẩn thận với việc xóa hay sửa đổi các prop quan trọng, chúng ta nên đặt namespace cho HoC props để nó không phá vỡ WrappedComponent. Ví dụ: Thêm mới props. 123456789101112131415161718// HOC.jsimport React from 'react';function pP(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; const newProps = &#123; newProps: 'something news' &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt; &#125; &#125;&#125;module.exports = &#123; pP&#125; Sửa lại file App một chút 1234567891011121314// App.jsimport &#123;pP&#125; from './HoC'class App extends Component &#123; render() &#123; console.group('App'); console.log('render'); console.log(this.props); console.groupEnd(); ... &#125;&#125;export default pP(App); Và ở console chúng ta có kết quả Truy cập instance thông qua RefsChúng ta có thể truy cập this (instance của WrappedComponent) với ref, nhưng chúng ta sẽ cần một quá trình render đầy đủ của WrappedComponent để ref có thể được tính toán. Điều này có nghĩa là chúng ta cần trả về WrappedComponent element từ method render của HoC, để React có thể làm quá trình đối chiếu (reconciliation process) và chúng ta sẽ có ref đến WrappedComponent instance. Ví dụ: Chúng ta sẽ tìm hiểu làm thế nào để truy cập instance methods và instance của chính WrappedComponent thông qua refs 123456789101112131415161718192021// HOC.jsfunction refsPP(WrappedComponent) &#123; return class RefsPP extends React.Component &#123; proc(wrappedComponentInstance) &#123; console.group('refs Proc'); console.log(wrappedComponentInstance); wrappedComponentInstance.test(); console.groupEnd(); &#125; render() &#123; const props = Object.assign(&#123;&#125;, this.props, &#123;ref: this.proc.bind(this)&#125;) return &lt;WrappedComponent &#123;...props&#125;/&gt; &#125; &#125;&#125;module.exports = &#123; pP, refsPP&#125; Sửa file App một chút 1234567891011import &#123;pP, refsPP&#125; from './HoC'class App extends Component &#123; test() &#123; console.log('call Test'); &#125; ..... &#125;&#125;export default refsPP(App); Và ở console chúng ta có kết quả Khi WrappedComponent được render xong thì ref callback sẽ được thực thi, và chúng ta sẽ có ref đến WrappedComponent instance. Điều này có thể được sử dụng để đọc/thêm các props và gọi các instance method. Trừu tượng hóa (Abstracting) StateChúng ta có thể trừu tượng hóa state bằng cách cung cấp props và callbacks cho WrappedComponent, tương tự như Container Components làm với Presentational components. Ví dụ: Chúng ta sẽ thực hiện trừu tượng hóa state để kiểm soát input 1234567891011121314151617181920212223242526272829303132333435// HOC.jsfunction statePP(WrappedComponent) &#123; return class StatePP extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; fields: &#123;&#125; &#125; &#125; getField(fieldName) &#123; if (!this.state.fields[fieldName]) &#123; this.state.fields[fieldName] = &#123; value: '', onChange: event =&gt; &#123; this.state.fields[fieldName].value = event.target.value this.forceUpdate() &#125; &#125; &#125; return &#123; value: this.state.fields[fieldName].value, onChange: this.state.fields[fieldName].onChange &#125; &#125; render() &#123; const props = Object.assign(&#123;&#125;, this.props, &#123; fields: this.getField.bind(this), &#125;); return &lt;WrappedComponent &#123;...props&#125;/&gt; &#125; &#125;&#125; Sửa file App một chút 12345678910111213141516171819202122232425// App.jsimport &#123;pP, refsPP, statePP&#125; from './HoC'class App extends Component &#123; test() &#123; console.log('call Test'); &#125; render() &#123; console.group('App'); console.log('render'); console.log('name', this.props.fields('name')); console.log('email', this.props.fields('email')); console.groupEnd(); return ( &lt;div className=\"App\"&gt; .... &lt;form&gt; &lt;label&gt;Automatically controlled input!&lt;/label&gt; &lt;input type=\"text\" placeholder=\"Name\" &#123;...this.props.fields('name')&#125;/&gt; &lt;input type=\"email\" placeholder=\"Email\" &#123;...this.props.fields('email')&#125;/&gt; &lt;/form&gt; &lt;/div&gt; ); &#125;&#125; Và chúng ta có kết quả Việc trừu tượng hóa state có nhiều ứng dụng, và được sử dụng khá nhiều trong việc giải quyết các vấn đề mà Stateless component gặp phải như không có ref chẳng hạn. Bao WrappedComponent với elements khácChúng ta có thể bao WrappedComponent với component hoặc element khác để styling, layout hoặc mục đích khác. Cách sử dụng cơ bản có thể hoàn thành bởi Parent Components nhưng chúng ta có nhiều sự linh hoạt hơn với HoCs như đã mô tả ở trên. 123456789101112// HOC.jsfunction elmWrapPP(WrappedComponent) &#123; return class ElmWrapPP extends React.Component &#123; render() &#123; return ( &lt;div style=&#123;&#123;display: 'block'&#125;&#125;&gt; &lt;WrappedComponent &#123;...this.props&#125;/&gt; &lt;/div&gt; ) &#125; &#125;&#125; Inheritance InversionInheritance Inversion (II) thường được implement như sau: 1234567function iiHOC(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; return super.render() &#125; &#125;&#125; Như các bạn thấy, HOC trả về class (Enhancer) kế thừa (extends) WrappedComponent. Phương pháp này gọi là Inheritance Inversion là do thay vì WrappedComponent mở rộng (kế thừa) Enhancer class nào đó, nó lại được mở rộng (kế thừa) bởi Enhancer. Theo cách này, mối quan hệ giữa chúng dường như bị đảo ngược. II cho phép HoC truy cập vào WrappedComponent instance thông qua this, điều này có nghĩa là HoC có quyền truy cập state, props, component lifecycle hooks và cả phương thức render. Chúng ta sẽ không đi sau vào chi tiết chúng ta có thể làm gì với component lifecycle hooks, đó không phải là những gì cụ thể HoC làm, nó là React. Nhưng lưu ý rằng chúng ta hoàn toàn có thể tạo ra lifecycle hooks mới cho WrappedComponent. Và nhớ răng luôn gọi super.[lifecycleHook] để không phá vỡ WrappedComponent. Quá trình đối chiếu (Reconciliation process)Trước khi bắt đầu chúng ta cần tóm tát vài lý thuyết. React Elements mô tả những gì sẽ hiển thị khi React chạy quá trình đối chiếu của nó. React Elements có thể có 2 loại: String và Function. String Type React Element (STRE) đại diện các DOM node và Function Type React Element (FTRE) đại diện các Component được tạo ra bằng cách mở rộng React.Component. Đọc thêm tại post. FTRE sẽ được phân giải ra thành cây STRE trong quá trình đối chiếu của React (kết quả cuối cùng luôn là các DOM Element). Điều này rất quan trọng và nó có nghĩa là: Inheritance Inversion High Order Components không đảm bảo là đã giải quyết được toàn bộ cây con. Điều này sẽ được chứng thực khi học Render Highjacking. What can you do with Inheritance Inversion? Chiếm quyền render (Render Highjacking) Điều khiển state (Manipulating state) Render HighjackingPhương pháp này gọi là Render Highjacking bởi vì HoC kiểm soát render output của WrappedComponent và chúng ta có thể làm bất kì điều gì với nó. Trong Render Highjacking chúng ta có thể Đọc, thêm, sửa, xóa props trong bất kì React Elements nào xuất ra bởi render. Đọc và sửa đổi React elements tree xuất ra bởi render. Hiển thị elements tree theo điều kiện. Bao element tree cho mục đích styling (giống như đã nói ở PP)\\ Note: render đề cấp đến WrappedComponent.render Chúng ta không thể chỉnh sửa hoặc tạo props của WrappedComponent instace, bởi vì một React Component không thể chỉnh sửa props mà nó nhận được, nhưng chúng ta có thể thay đổi các props của các element xuất ra từ phương thức render. Như chúng ta đã nói ở trên, II HoCs không đảm bảo toàn bộ cây con được giải quyết, điều này hàm ý một số giới hạn với kỹ thuật Render Highjacking. Quy tắc chung là với Render Highjacking chúng ta có thể thao tác với element tree mà WrappedComponent.render xuất ra không nhiều hơn cũng không ít hơn. Nếu Element tree đó có chưa một Function Type React Component thì chúng ta sẽ không thể thao tác được với các con của Component đó. (Do chúng được hoãn lại bởi quá trình đối chiếu của React cho đến khi nó thực sự được render) Ví dụ 1: Render có điều kiện HOC sẽ render chính xác những gì mà WrappedComponent sẽ render trừ khi this.props.loggedIn = false. (Giả định là HoC sẽ nhận được loggedIn prop). 123456789101112// HOC.jsfunction rHII(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; if (this.props.loggedIn) &#123; return super.render() &#125; else &#123; return &lt;div&gt;Not loggedIn&lt;/div&gt; &#125; &#125; &#125;&#125; Và tất nhiên App của chúng ta không có props loggedIn (Lười quá (lol) ) nên kết quả sẽ là Ví dụ 2: Sửa đổi React Element tree xuất ra bởi render. 1234567891011121314151617181920212223242526272829303132333435363738394041// HOC.jsfunction treeII(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; const elementsTree = super.render() let newProps = &#123;&#125;; var newChilds = elementsTree.props.children.map(function (child) &#123; if (child.type === 'input') &#123; var childNewProps = &#123;value: 'may the force be with you'&#125;; var childProps = Object.assign(&#123;&#125;, child.props, childNewProps) return React.cloneElement(child, childProps, child.props.children); &#125; return child; &#125;); const props = Object.assign(&#123;&#125;, elementsTree.props, newProps) const newElementsTree = React.cloneElement(elementsTree, props, newChilds) return newElementsTree &#125; &#125;&#125;&lt;span class=\"hljs-comment\"&gt;// App.js&lt;/span&gt;&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;App&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;extends&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Component&lt;/span&gt;&lt;/span&gt; &#123; render() &#123; &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ( &lt;div className=\"App\"&gt; &lt;div className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;h2&gt;Welcome to React&lt;/h2&gt; &lt;/div&gt; &lt;p className=\"App-intro\" ref=\"appIntro\"&gt; To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;input type=\"text\" placeholder=\"Name\"/&gt; &lt;/div&gt; ); &#125;&#125; export default treeII(App); Trong ví dụ trên, nếu output render bởi WrappedComponent có chứa element con có type là `input’ thì HoC sẽ thay đổi value của nó thành ‘may the force be with you’. Chúng ta có thể làm mọi thứ ở đây, chúng ta có thể duyệt qua toàn bộ các phần tử của element tree và thay đổi bất kì props của bất kì element nào trong tree. Và đây chính xác là những gì Radium thực hiện. Note: Chúng ta không thể Render Highjack với Props Proxy. Mặc dù vẫn có thể truy cập vào phương thức render thông qua WrappedComponent.prototype.render, chúng ta sẽ cần phải mô phỏng WrappedComponent instance và các props của nó, và có khả năng là phải tự xử lý component lifecycle thay vì để React làm nó. Trong thực nghiệm của tôi, nó không có giá trị nhiều lắm và nếu chúng ta muốn Render Highjacking chúng ta nên sử dụng II thay vì PP. Hãy nhớ rằng React xử lý các component instances nội bộ và cách duy nhất để chúng ta thao tác với instances là thông qua refs. Manipulating stateHOC có thể đọc, chỉnh sửa và xóa state của WrappedComponent instance, và chúng ta cũng có thể thêm state nếu cần. Hãy nhớ rằng chúng ta đang làm rối state của WrappedComponent, điều có thể dẫn chúng ta đến việc hủy hoại mọi thứ. Hầu hết các HOC nên được giới hạn để đọc hoặc thêm state, và sau đó được đặt tên (namespace) để không làm rối state của WrappedComponent. Ví dụ: Debugging bằng cách truy cập props và state của WrappedComponent 1234567891011121314function IIHOCDEBUGGER(WrappedComponent) &#123; return class II extends WrappedComponent &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;HOC Debugger Component&lt;/h2&gt; &lt;p&gt;Props&lt;/p&gt; &lt;pre&gt;&#123;JSON.stringify(this.props, null, 2)&#125;&lt;/pre&gt; &lt;p&gt;State&lt;/p&gt;&lt;pre&gt;&#123;JSON.stringify(this.state, null, 2)&#125;&lt;/pre&gt; &#123;super.render()&#125; &lt;/div&gt; ) &#125; &#125;&#125; HOC này sẽ bao WrappedComponent với element khác đồng thời hiện các props và state của WrappedComponent. NamingKhi bao một component với HOC chúng ta đánh mất tên của WrappedComponent, điều này sẽ ảnh hưởng đến chúng ta trong quá trình dev và debugging. Mọi người thường làm là tùy chỉnh tên của HOC bằng cách lấy tên của WrappedComponent và đặt trước một cái gì đó. Dưới đây trích từ React-Redux: 123456HOC.displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)`//orclass HOC extends ... &#123; static displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)` ...&#125; Function getDisplayName được định nghĩa như sau 12345function getDisplayName(WrappedComponent) &#123; return WrappedComponent.displayName || WrappedComponent.name || ‘Component’&#125; Chúng ta thực sự không phải viết lại nó vì thư viện recompose đã cung cấp function này rồi. Phụ lụcHOC and parametersĐôi khi rất hữu ích khi sử dụng các parameters cho HOCs. Điều này ẩn trong những ví dụ bên trên và nên được phát triển tự nhiên đến Javascript developers trung gian, nhưng vì lợi ích làm cho bài viết đầy đủ, chúng ta sẽ lướt qua nó một cách nhanh chóng. Ví dụ: HOC parameters với Props Proxy thông thường. Điều quan trọng là HOCFactoryFactory function. 12345678910function HOCFactoryFactory(...params)&#123; // do something with params return function HOCFactory(WrappedComponent) &#123; return class HOC extends React.Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125;/&gt; &#125; &#125; &#125;&#125; Và chúng ta có thể sử dụng như thế này 1234HOCFactoryFactory(params)(WrappedComponent)//or@HOCFatoryFactory(params)class WrappedComponent extends React.Component&#123;&#125; Difference with Parent ComponentsNhư đã nói ở phần ‘Bao WrappedComponent với elements khác’, ở một số cách cơ bản cảu HOC ta có thể hoàn thành với Parent Component. Vậy điểm khác biệt giữ HOC và Parent Component là gì? Parent Components là React Components có vài components con. React có APIs để truy cập và thao tác với component con. Ví dụ: 123456789101112class Parent extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125; &#125;&#125;render((&lt;Parent&gt;&#123;children&#125;&lt;/Parent&gt; ), mountNode); Giờ chúng ta sẽ duyệt qua xem Parent Components có và không thể làm gì khi so sánh với HOCs và thêm vài thông tin quan trọng: Có thể Render Highjacking tương tự như với II HOC Có thể điều khiển inner props tương tự như với II HOC Có thể trừu tượng hóa state, nhưng có nhược điểm. Chúng ta sẽ không thể truy cập state của Parent Component từ bên ngoài trừ khi chúng ta tạo hooks cho nó. Điều này hạn chế tính hữu ích của nó. Bao các elements với elements khác. Đây có thể là trường hợp duy nhất Parent component làm tốt hơn HOC. Nhưng tất nhiên là HOC cũng làm đc. Thao tác với child component gặp một số vấn đề. Ví dụ nếu childrent không chỉ có 1 root element (nhiều hơn 1 first level childrent), thì chúng ta phải thêm 1 element để bao tất cả children lại, mà điều này có thể gây rườm ra cho markup của chúng ta. Trong HOCs 1 top level children root được đảm bảo bởi React/JSX. Parent Components có thể được sử dụng tự do trong Elements tree, chúng không bị hạn chế 1 Component 1 lần như HOC. Nói chung, nếu chúng ta có thể làm được nó với Parent Components thì chúng ta nên làm nó, bởi vì Parent Components ít “hack não” hơn HOCs, nhưng như những điều đã nói, với State nó kém linh hoạt hơn so với HoCs. ConclusionHi vọng là sau khi đọc bài này, mọi người sẽ hiểu hơn một chút về React HOCs. Chúng thực sự có ý nghĩa và đã được chứng minh khá tốt trong nhiều thư viện khác nhau. React mang lại rất nhiều sự đổi mới và những thư viện như Radium, React-Redux, React-Router trong số rất nhiều thư viện khác là những bằng chứng về điều đó.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"hoc","slug":"hoc","permalink":"http://nthung2112.github.io/tags/hoc/"}]},{"title":"Cách phân nhánh và chia việc trong nhóm với Git","slug":"Cach-phan-nhanh-va-chia-viec-trong-nhom-voi-Git","date":"2018-04-26T14:50:00.000Z","updated":"2018-04-30T08:06:42.792Z","comments":true,"path":"2018/04/Cach-phan-nhanh-va-chia-viec-trong-nhom-voi-Git.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Cach-phan-nhanh-va-chia-viec-trong-nhom-voi-Git.html","excerpt":"Bạn vốn làm việc một mình một cõi, “thầu nguyên con” dự án. Dù phải code sấp mặt nhưng cuộc đời vẫn thật êm xuôi: tốc độ thần thánh 500 dòng/giờ, commit code mới pặc pặc vào master, cuối ngày chỉ việc git push, tắt máy, rồi dắt gấu đi nhậu (hoặc lội suối băng đèo về nhà thay tã cho con). Ngờ đâu sếp (hoặc co-founder) xót thương bạn vất vả, bèn tuyển ngay 2 em đào nhí vào trợ giúp. Và mọi chuyện bắt đầu phức tạp từ đây: code trong team bị chồng chéo và xung đột liên tục, branch master đang thẳng thớm đẹp xinh bỗng phân nhánh như điên, tốc độ code của bạn giảm trong khi tốc độ chửi thề ngày một tăng nhanh. Bạn không còn thời giờ dắt gấu đi nhậu, cũng không thể lội kịp về nhà thay tã cho con nữa. Cuộc đời bế tắc.","text":"Bạn vốn làm việc một mình một cõi, “thầu nguyên con” dự án. Dù phải code sấp mặt nhưng cuộc đời vẫn thật êm xuôi: tốc độ thần thánh 500 dòng/giờ, commit code mới pặc pặc vào master, cuối ngày chỉ việc git push, tắt máy, rồi dắt gấu đi nhậu (hoặc lội suối băng đèo về nhà thay tã cho con). Ngờ đâu sếp (hoặc co-founder) xót thương bạn vất vả, bèn tuyển ngay 2 em đào nhí vào trợ giúp. Và mọi chuyện bắt đầu phức tạp từ đây: code trong team bị chồng chéo và xung đột liên tục, branch master đang thẳng thớm đẹp xinh bỗng phân nhánh như điên, tốc độ code của bạn giảm trong khi tốc độ chửi thề ngày một tăng nhanh. Bạn không còn thời giờ dắt gấu đi nhậu, cũng không thể lội kịp về nhà thay tã cho con nữa. Cuộc đời bế tắc. Thôi đừng vội lật bàn quýnh cả sếp lẫn đào. Hãy thử làm theo một số quy ước sau đây, đảm bảo team dev nho nhỏ xinh xinh của bạn sẽ không còn “giẫm chân” nhau nữa. Công việc xuôi buồm mát mái, tình đồng nghiệp sẽ lại thương mến thương nè. Vậy, vấn đề chính ở đây là gì?Không có gì nghiêm trọng cả, chỉ là chúng ta chưa có một quy ước phân chia nhánh (branch) hợp lý thôi. So với các chương trình quản lý phiên bản khác như SVN, khả năng phân nhánh của Git phải nói là siêu nhẹ và cực kì dễ dàng. Do đó, bạn có thể chia dự án thành 2 nhánh chính: master dev Nhánh master sẽ là nơi chứa phần code ổn định nhất, sẵn sàng để triển khai bất cứ lúc nào. Trong khi đó, nhánh dev ban đầu được tách ra từ master, và sẽ chứa phần code mới nhất được phát triển. Nói nhỏ: Một số tài liệu sẽ đặt tên nhánh tách ra là develop. Tùy bạn chọn tên gì cũng được, nhưng theo Ehkoo thì gõ dev nhanh hơn gõ develop :p Nhắc bài chút xíuĐể tạo nhánh mới trong Git, bạn dùng lệnh: 1git checkout -b &lt;tên nhánh mới&gt; [nhánh gốc] Chẳng hạn, để tạo nhánh dev từ master, bạn gõ git checkout -b dev master. Nếu không cung cấp tham số [nhánh gốc], nhánh mới tạo sẽ dựa trên nhánh hiện tại bạn đang ở. Để xem nhánh hiện tại là nhánh nào, bạn có thể dùng lệnh git branch. 123456$ git branch auth* auth-session dev graphql master Trong ví dụ trên thì nhánh hiện tại chính là auth-session. Phân chia công việcMỗi khi phát triển tính năng mới, bạn sẽ tạo một nhánh từ dev. 1git checkout -b login dev Đặt tên nhánh là gì đây?Tùy bạn thôi. Một số tài liệu sẽ khuyến khích bạn dùng tiền tố feature/&lt;tên tính năng&gt; để dễ phân biệt. Nhưng theo kinh nghiệm của Ehkoo, ngoài nhánh master, dev, và các nhánh fix-xxx, thì tất cả các nhánh còn lại đều có thể ngầm hiểu là nhánh chức năng. Nhánh này dưới quyền cai quản của bạn, nên mặc sức muốn làm gì thì làm nhé. Hãy commit thường xuyên, dù chỉ là những thay đổi nhỏ nhất. Cũng đừng ngần ngại rằng commit nhỏ sẽ khiến git log khó theo dõi. Chúng ta sẽ có cách xử lý chúng sau. Câu hỏi: Ê, lỡ như có hai hay nhiều người cùng làm chung một tính năng thì sao?Nếu vậy, bạn có thể tiếp tục chia nhỏ hơn nữa, để đảm bảo mỗi người làm việc trên một nhánh độc lập. Cũng theo kinh nghiệm riêng của Ehkoo, thì một tính năng _to_ sẽ có nhiều nhất là 2-3 người cùng phát triển. Nếu vượt quá con số này, thì nên xem lại định nghĩa và cách phân chia việc cho tính năng đó. Chuẩn bị merge vào devSau khi code hoàn tất và tất cả unit tests đã chạy thành công, giờ là lúc bạn merge/gửi code để review tính năng mới vào dev. Thông thường, sẽ có 2 trường hợp xảy ra: Trường hợp 1: Không có gì mới trong dev Giả sử lúc đó Git history của dự án giống như thế này: Như bạn thấy, nhánh login màu vàng được rẽ ra từ nhánh dev màu xanh, và trong nhánh dev không có code gì mới. Đây là trường hợp lý tưởng, đảm bảo khi merge vào dev chúng ta sẽ không bị xung đột code. Trường hợp 2: Có commits mới trong nhánh dev Trong trường hợp này, branch dev (màu xanh) đang có 2 commits phía trước branch login (màu vàng). Nếu trong 2 commits đó có chứa thay đổi liên quan đến dev, chẳng hạn như package.json, thì khả năng cao là sẽ xảy ra xung đột khi merge trực tiếp login vào. Mà dù có may mắn không xảy ra xung đột code, thì merge vào cũng sẽ làm history xấu đi. Do đó, chúng ta sẽ cần sửa lại history của nhánh login bằng cách dùng git rebase. git rebase là gì?git rebase sẽ đem những commits bên trong nhánh login và áp dụng lại vào sau commit mới nhất trong nhánh dev. Cú pháp của lệnh này là: 1git rebase &lt;tên nhánh muốn áp dụng lại&gt; Trong trường hợp hiện tại, chúng ta sẽ chạy những lệnh sau: 1234567# Cập nhật repo hiện tại, đồng thời lấy về commits mới nhất của `dev`git pull# Chuyển qua nhánh `login`, có thể bỏ qua bước này nếu bạn chắc chắn# mình đang ở `login`git checkout login# Tiến hành rebasegit rebase dev Nếu xảy ra xung đột code, bạn có thể phát hiện và giải quyết chúng sớm. Nguyên tắc chung là không sửa code của người khác, và chỉ kết hợp thêm những gì bạn làm. Việc thực hiện rebase tại nhánh chức năng do bạn phụ trách giúp giảm thiểu khả năng mất code, vì bạn là người hiểu rõ nhất phần code bạn viết. Sau khi giải quyết hết các xung đột trong code, bạn chạy git rebase –continue để tiếp tục tiến trình rebase. Bạn cũng có thể chạy git rebase –abort để hủy bỏ rebase và đưa nhánh login về lại trạng thái ban đầu. Mách nhỏ:Một cách giúp cho việc giải quyết xung đột trong code dễ dàng hơn là dùng git mergetool. Có rất nhiều công cụ hỗ trợ, và Meld là một trong số đó. Nếu chưa quen rebase, bạn có thể tạo một branch mới từ login, ví dụ: git checkout -b test login, và tiến hành rebase trên branch này. Sau khi chắc chắn là mọi thứ ổn thỏa, bạn có thể quay lại và tiến hành rebase cho login. Khi rebase xong, mong là history của bạn trông sẽ giống như thế này: Bạn thấy quen không? Chính là trường hợp 1 đã nói ở trên đó. rebase interactivelyỞ phần trên, chúng ta có băn khoăn là commit thường xuyên dễ tạo ra nhiều commit nhỏ đôi khi không cần thiết. Bạn có thể dùng git rebase để dọn dẹp chúng bằng cách thêm tham số -i (interactively) như sau: 1234# Chắc chắn rằng bạn đang ở nhánh `login`git checkout login# Rebase lên dev interactivelygit rebase dev -i Bạn sẽ được chuyển đến một giao diện tương tự như bên dưới. 12345678910pick ff80e85 A way to organize routes per modulepick 67cf18d Try Netlify Functionspick 5546901 Add Dashboard viewpick 2a66ae3 Change layoutpick 58755b4 Add Books module, 404 page.pick fd79cb9 Refactor. Reduce inline styling.pick c671f60 Restyling 404 page.pick 33ef874 Basic layout for book management page.pick 49c423a Clean up UI a bitpick 3aa2840 Init Theo lý thuyết, rebase sẽ đem từng commit và áp dụng lại theo thứ tự từ trên xuống dưới. Bởi vậy, bạn có thể thoải mái sắp xếp lại thứ tự của các commits trên. Bạn để ý lệnh pick ở phía trước mỗi commit. Lệnh này sẽ báo cho git biết hành động bạn muốn làm với commit, trong trường hợp này là áp dụng lại commit. Ngoài pick (p), chúng ta còn có: reword (r): áp dụng lại commit, và sửa commit message edit (e): áp dụng commit, nhưng dừng quá trình rebase lại để sửa code squash (s): kết hợp commit hiện tại vào commit trước nó fixup (f): giống như squash nhưng bỏ đi commit message exec (x): chạy một lệnh shell nào đó drop (d): bỏ, không sử dụng commit này Bằng cách dùng rebase interactively, chúng ta có thêm nhiều quyền để quản lý và sửa đổi commits theo ý mình, làm cho history sạch đẹp hơn. Merge vào devSau khi dọn dẹp nhánh login sạch đẹp, chúng ta có thể merge nhánh này vào dev. Thông thường, bạn – dev cứng nhất team – sẽ là người tiến hành kiểm tra và merge. Bạn có thể chọn hai cách tiếp cận: mergeBạn có thể merge trực tiếp vào dev như thế này: 1234# Chuyển qua nhánh `dev`git checkout dev# Merge `login` vào `dev`git merge login Kết quả sẽ là: Như bạn thấy, một commit mới được tạo ra, giúp bạn dễ dàng nhận biết thời điểm nhánh login được merge vào. Cách thức này gọi là merge fast-forward. Khi dự án phát triển dần theo thời gian, history của dev sẽ như thế này. Bên cạnh đó, chúng ta cũng có cách merge non-fast-forward: 1git merge login --no-ff Và đây là kết quả: Tất cả commits của login đã được kết hợp vào dev. Boom! login biến mất khỏi thế gian như chưa hề tồn tại. SAD! Lợi ích dễ thấy nhất của merge non-fast-forward là giúp cho history của bạn thẳng thớm gọn gàng, còn bất lợi là bạn không phân biệt được commits nào là của nhánh tính năng, cũng như thời điểm merge diễn ra. Trong trường hợp nhánh tính năng có quá nhiều commits nhỏ và dư thừa, chẳng hạn như những commits sửa lỗi chính tả, cập nhật thư viện…, history của bạn sẽ bị nhiễu. rebase, squash và mergeNgoài cách merge các commits của nhánh tính năng vào dev, bạn có thể rebase và squash tất cả commits lại làm một, sau đó tiến hành merge. Cách làm này giúp cho dev luôn ở trạng thái gọn gàng nhất, không chứa commit dư thừa. Trong trường hợp lý tưởng, history của dev sẽ giống như sau: Để cách làm này phát huy tối đa hiệu quả, yêu cầu commit message phải được viết thật rõ ràng và chi tiết. Merge vào masterYay! Sau một thời gian quằn quại, cuối cùng team của bạn đã ra được sản phẩm tương đối ổn. Giờ là lúc merge vào master và triển khai lên server. Lúc này, cũng như khi merge vào dev, bạn có thể chọn merge (fast-forward hoặc non-fast-forward) hay rebase, squash và merge, nhưng theo kinh nghiệm của Ehkoo, merge –no-ff sẽ là lựa chọn tốt nhất, giúp cho master và dev luôn song song với nhau. HotfixHôm nay, thứ 6, ngày 1X. Bạn chạy npm run build rồi rsync code ở master lên server. Mọi thứ hoàn toàn bình thường. Bạn vào website, click vài cái. “Ngon, chạy rồi”, bạn thầm nghĩ, “đi nhậu thoy!” Nhưng vừa vươn vai định gọi điện cho gấu, thì “ó e ò e”, chuông điện thoại reng, số máy của sếp. “Hí hí, chắc được thưởng nóng chăng?” Bạn bắt máy, và nghe giọng sếp âu yếm GẦM ở đầu dây: “LỖI RỒI MÁÁÁ!!!” Xin đừng trụy tim. Hãy hít một hơi thật sâu, rồi bình tĩnh tạo một branch mới từ master, fix-xxx chẳng hạn. Nhờ lắng nghe tiếng sếp gầm, bạn đã mau chóng mò ra lỗi trong đống code (vì bạn là dev cứng mà hihi). Bạn khẽ rủa thầm ku đào nhí viết code không kĩ, tự rủa nhẹ bản thân vì review sót. Nhưng thôi kệ, fix nhanh rồi còn về, kẻo gấu xé xác T^T. Bạn bèn merge –no-ff nhánh fix-xxx vào cả hai nhánh master và dev. Bằng cách này, phần sửa lỗi sẽ xuất hiện ở cả hai branches, giúp history không bị rẽ nhánh bất ngờ. Bạn push, và chuông điện thoại lại vang lên… Vài vấn đề linh tinh khácCó cần nhánh staging không?Trong một số dự án, ngoài dev, còn có một đội ngũ “thần bí” được gọi là QA/QC. Họ được sinh ra trong team là để bới lỗi của anh em nhà dev, nên quan hệ đôi bên không được tình thương mến thương cho lắm. Dầu vậy, họ vẫn cần một nhánh riêng có tên gọi staging. Nhánh này sẽ chứa phần code ở giữa master và dev. staging được tách ra từ dev, có nhiều tính năng hơn master, và tương đối ổn định để có thể merge vào master. Tùy vào tình hình cụ thể của team mà bạn quyết định có cần staging hay không. Viết commit message như thế nào cho chuẩn?Nếu bạn theo chuẩn rebase, squash và merge thì chuyện viết commit message tốt rất quan trọng, vì nó sẽ là tài liệu để mô tả toàn bộ một tính năng. Nhưng nên viết thế nào? Có một vài gợi ý cho bạn đây: Dòng đầu tiên không dài quá 80 chữ, luôn bắt đầu bằng động từ ở thì hiện tại, ngắn gọn súc tích, ví dụ: Add module Authentication. Bạn có thể chọn thêm tiền tố nếu cần thiết, chẳng hạn: Feature: Add module Authentication hay Fix: unable to get location params from URL Bỏ trống hai dòng Sau đó mô tả chi tiết về tính năng đang làm, những điểm cần lưu ý, phần nào của tính năng cần được cải thiện… Khuyến khích bạn kèm theo chữ ký signature khi commit bằng git commit -s Một ví dụ 1234567891011121314151617Feature: Add module AuthenticationSigned-off-by: Long Dep Trai &lt;long@ehkoo.com&gt;This module allows users to register/login into our website usingAWS Cognito account. Added routes:* /auth/register* /auth/loginUsers after registration will receive a SMS to confirm their account.TODO:* Implement social identities* Add Logout feature* Add Forgot password feature Tiếng Anh hay tiếng Việt?Tùy thuộc vào team của bạn, nhưng phải thống nhất trong toàn dự án, và viết tiếng Việt thì nhớ đừng sai chính tả kẻo bị công an bắt nhé. Có nên tag version hay không?Câu trả lời là HÊN XUI, tùy tính chất từng team. Nếu tần suất triển khai code từ master của team không cao, khoảng vài tháng/lần thì tag version là cách tốt để theo dõi những thay đổi. Hoặc nếu bạn đang xây dựng lib hoặc làm việc open source. Còn nếu team bạn theo chuẩn “move fast, break things”, thì có lẽ không cần tag version đâu. Thêm nữa, để tag version phát huy hiệu quả tối đa, thì CHANGELOG cần phải được viết kỹ càng. Đồng thời, đừng quên tag version theo semver nhé. Kết luậnChúng ta có thể tóm tắt bài này lại như sau: Dự án được chia thành nhiều nhánh, bao gồm master, dev và có thể có staging Các nhánh tính năng được chia ra từ dev, phát triển độc lập, được rebase trước khi merge lại vào dev Rebase có thể thay đổi một chút history, hoặc squash lại thành một commit duy nhất Merge có thể là fast-forward hoặc non-fast-forward dev sẽ được merge vào master mỗi khi triển khai. Trường hợp có staging, dev sẽ được merge vào staging, và staging sẽ được merge vào master. Các nhánh hotfix sẽ được chia ra từ master, sau đó merge –no-ff vào master và dev Dĩ nhiên bài viết này chỉ mang tính tham khảo, vì mỗi team mỗi công ty sẽ có những cách làm riêng. Tuy nhiên, nếu bạn không may lâm vào cảnh trái ngang như ở đầu bài, thì đây là một workflow rất nên nghiên cứu và áp dụng. Mong rằng trong tương lai, dự án của bạn sẽ không trở thành “kim tự tháp” như hình dưới đây.","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://nthung2112.github.io/tags/git/"}]},{"title":"Tìm hiểu về một số khái niệm trong Git","slug":"Tim-hieu-ve-mot-so-khai-niem-trong-Git","date":"2018-04-26T07:39:00.000Z","updated":"2018-04-30T08:06:42.823Z","comments":true,"path":"2018/04/Tim-hieu-ve-mot-so-khai-niem-trong-Git.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Tim-hieu-ve-mot-so-khai-niem-trong-Git.html","excerpt":"Giới thiệuĐối với các lập trình viên, việc sử dụng công cụ quản lý phiên bản git là điều không thể thiểu trong công việc hằng ngày và là một trong những kĩ năng cơ bản nhất mà ai cũng cần có được. Git có rất nhiều các khái niệm khác nhau nên nếu bạn chỉ là người mới làm quen với git thì đây chính là bài viết dành cho bạn. Bài viết sẽ giải thích tại sao chúng ta nên sử dụng git cũng như một số khái niệm thường gặp khi sử dụng git.","text":"Giới thiệuĐối với các lập trình viên, việc sử dụng công cụ quản lý phiên bản git là điều không thể thiểu trong công việc hằng ngày và là một trong những kĩ năng cơ bản nhất mà ai cũng cần có được. Git có rất nhiều các khái niệm khác nhau nên nếu bạn chỉ là người mới làm quen với git thì đây chính là bài viết dành cho bạn. Bài viết sẽ giải thích tại sao chúng ta nên sử dụng git cũng như một số khái niệm thường gặp khi sử dụng git. Tại sao cần sử dụng git? Thử tưởng tượng khi làm một project và bạn muốn bổ sung hoặc làm thêm tính năng mới cho project của mình. Tuy nhiên để đảm bảo rằng bạn có thể quay lại sử dụng phần code trước đó bạn đã code trong trường hợp tính năng mới gây lỗi và bạn không nhớ phải xóa những gì để khôi phục lại trạng thái code trước đó thì bạn cần phải thực hiện copy toàn bộ project đó và paste ra đâu đó để lưu trữ rồi mới bắt đầu thực hiện code tính năng mới. Như vậy mỗi lần muốn làm tính năng mới, bạn phải lặp đi lặp lại thao tác trên và rất mất thời gian. Sử dụng Git có thể giải quyết vấn đề này chỉ trong 1 vài dòng lệnh Nếu project bạn đang làm có 2 thành viên cùng làm, mỗi lần một người hoàn thành một tính năng lại phải gửi toàn bộ source code đó thông qua usb, google driver hoặc công cụ lưu trữ online nào đó cho thành viên còn lại có thể download về và paste đè lại lên phần code của người đó. Công việc này cũng mất rất nhiều thời gian và tồn tại nhiều rủi rõ khi paste code chồng lên nhau. Để giải quyết vấn đề này, ta cũng có thể sử dụng git và một remote repository Các khái niệm cơ bản trong git1. Repository là gì? Khi sử dụng git, lệnh đầu tiên mà chúng ta thường gõ: 1$ git init Lệnh này sẽ tạo ra một thư mục ẩn có tên .git và đây chính là repository (hay kho chứa). Còn phần code hay hay thư mục của project nằm cùng với thư mục .git được gọi là Working Directory. Git sử dụng repository này để lưu trữ, giám sát toàn bộ thông tin về các trạng thái của và bất cứ thay đổi nào với project lúc này sẽ được git lưu trữ lại. Có hai loại repository gồm local repository - là repository nằm trên chính máy tính của chúng ta và remote repository - là repository nằm trên một máy chủ từ xa được cung cấp bởi các nhà phân phối như Github, Gitlab hay Bitbucket, … 2. Branch là gì? Như đã nói ở trên về vấn đề khi ta muốn thêm một tính năng mới mà đảm bảo vẫn có thể dễ dàng khôi phục lại trạng thái trước đó thì ta có thể sử tạo 1 branch mới nhau sau: 1$ git branch &lt;tên-branch&gt; hoặc 1$ git checkout -b &lt;tên-branch&gt; Branch mặc định là master Branch mới được tạo ra sẽ chứa toàn bộ trạng thái và những thay đổi đã thực hiện trên project trước khi được tạo Với mỗi repository ta có thể tạo nhiều branch khác nhau và các nhánh này là độc lập với nhau nên khi ta có thay đổi đối với project trên branch này sẽ không ảnh hưởng đến các branch khác Khi tính năng được ta thử nghiệm trên nhánh mới hoàn thiện và đã được kiểm tra đầy đủ, ta có thể tiến hành hợp nhất 2 nhánh với nhau (đưa những thay đổi của nhánh này gộp vào với nhánh khác) Có hai loại branch là local branch - là branch nằm trên máy tính của chúng ta và remote branch - là branch nằm trên máy chủ từ xa 3. Làm thế nào để xóa một branch? Trong trường hợp branch chúng ta tạo ra trước đó không còn cần thiết nữa, ta có thể tiến hành xóa chúng đi bằng cách sử dụng các lệnh như sau: Đối với local branch:1$ git branch -d &lt;tên-branch&gt; Với cách xóa trên, nếu branch cần xóa chưa được gộp thay đổi với branch khác sẽ lập tức báo lỗi vào yêu cầu gộp với branch khác trước khi thực hiện xóa bằng lệnh này 1$ git branch -D &lt;tên-branch&gt; Với cách xóa này thì branch được chỉ định sẽ lập tức bị xóa kể cả trong trường hợp nó chưa được gộp với branch khác Đối với remote branch:1$ git push --delete &lt;tên-remote&gt; &lt;tên-branch&gt; hoặc 1$ git push &lt;tên-remote&gt; --delete &lt;tên-branch&gt; Lưu ý: đối với cả local branch và remote branch ta có thể tiến hành xóa đồng thời nhiều branch bằng cách liệt kê tên các branch cần xóa liền nối tiếp nhau và cách nhau một khoảng trắng 4. Push local branch lên remote server với một tên khác Thông thường khi chúng ta tiến hành push một local branch lên remote server thì tên branch mặc định của remote branch lúc này sẽ là tên của local branch, lệnh push như sau: 1$ git push &lt;tên-remote&gt; &lt;tên-branch&gt; Nhưng nếu ta muốn đổi tên của remote branch đó trên server thì ta cần sử dụng lệnh như sau: 1$ git push &lt;tên-remote&gt; &lt;tên-branch&gt;:&lt;tên-remote-branch&gt; 5. Phân biệt rebase và merge Khi muốn tiến hành gộp 2 branch lại với nhau, ta có thể sử dụng một trong hai lệnh sau: 1$ git merge &lt;tên-branch&gt; hoặc 1$ git rebase &lt;tên-branch&gt; Sẽ tiến hành gộp branch hiện tại với branch mà ta lựa chọn. Tuy có cùng chức năng là gộp nhánh nhưng cách hoạt động của merge và rebase lại khác với nhau, ta có thể so sánh sự khác biệt thông đó như sau: Giả sử ta có 2 branch cần gộp với nhau như hình sau: Đối với sử dụng merge kết quả thu được sẽ như sau: Việc sử dụng merge sẽ tạo ra một commit mới là kết hợp từ 2 commit cuối cùng của 2 nhánh cần gộp vào với nhau Log commit sẽ không bị thay đổi và thứ tự các commit sẽ được sắp xếp theo thời gian tạo commit Đối với sử dụng rebase kết quả thu được sẽ như sau: Rebase sẽ đưa toàn bộ branch Feature lên trên ‘đầu’ branch master Làm thay đổi lịch sử commit 6. Khác nhau giữa fetch và pull Khi muốn cập nhật các thay đổi từ trên remote server về local repository ta cũng có hai cách để thực hiện điều này như sau: 1$ git pull &lt;tên-remote&gt; &lt;tên-remote-branch&gt; Lệnh này sẽ tiến hành kéo các thay đổi từ trên remote server về local của chúng ta đồng thời tiến hành merge các thay đổi đó ngay 1$ git fetch &lt;tên-remote&gt; &lt;tên-remote-branch&gt; Đối với lệnh fetch, các thay đổi từ remote server sẽ được kéo về máy nhưng không tự động merge vào source code của chúng ta mà chúng ta có thể thực hiện việc này sau khi đã review lại các thay đổi đó trước khi tiến hành merge. Các thay đổi này được đẩy sang một branch khác và ta có thể sử dụng lệnh: 1$ git branch -a Để xem được các branch sau khi fetch đồng thời cũng có thể checkout sang branch đó để xem các thay đổi. Có thể hiểu đơn giản lại sự khác nhau giữa fetch và pull như sau: git pull = git fetch + git merge 7. Thế nào là git stash? Trong quá trình chúng làm việc, có những lúc chúng ta đang code dở một chức năng nào đó nhưng bất ngờ ở một chức năng trên branch khác đang có lỗi cần phải sửa gấp và chúng ta muốn lưu lại thay đổi đã làm trên nhánh hiện tại nhưng không muốn thực hiện commit dư thừa thì git stash là lệnh mà chúng ta có thể dùng để giải quyết vấn đề này. git stash cho bạn khả năng lưu lại trạng những thay đổi mà bạn đã tạo ra mà không cần thiết phải commit nó giúp bạn có thể dễ dàng chuyển sang nhánh khác làm việc và sau đó quay lại và tiếp tục những gì bạn đang làm ở nhánh đó. Các lệnh liên quan đến git stash Để lưu được những thay đổi mà không cần commit nó, ta cần thực hiện những lệnh sau:1$ git add . Để đưa toàn bộ các thay đổi đó vào trạng tháy staged, sau đó sử dụng lệnh sau để lưu thay đổi đó mà không cần commit: 1$ git stash # hoặc &quot;git stash save&quot; Để xem lại các thay đổi đã lưu, ta có thể dùng các lệnh sau: 1234$ git stash liststash@&#123;0&#125;: WIP on &lt;branch-name&gt;: &lt;lastest commit&gt;stash@&#123;1&#125;: WIP on &lt;branch-name&gt;: &lt;lastest commit&gt;stash@&#123;2&#125;: WIP on &lt;branch-name&gt;: &lt;lastest commit&gt; Để xem lại danh sách các lần đã lưu, trong trường hợp muốn xem nội dung thay đổi thì ta gõ lệnh sau: 1$ git stash list -p Hoặc nếu muốn xem cụ thể nội dung thay đổi của một lần lưu cụ thể, ta dùng lệnh: 123$ git stash show &quot;stash@&#123;n&#125;&quot;// với n là lần lưu tương ứng trong danh sách// Lưu ý phần stash@&#123;n&#125; phải nằm trong cặp ngoặc đôi Để lấy lại thay đổi được lưu trong danh sách trên ta dùng lệnh: 1$ git stash apply &quot;stash@&#123;n&#125;&quot; Hoặc lấy thay đổi gần nhất và xóa lần lưu đó 1$ git stash pop Để xóa danh sách các thay đổi đã lưu, ta dùng lệnh: 1$ git stash drop &quot;stash@&#123;n&#125;&quot; Để drop một lần lưu chỉ định hoặc 1$ git stash clear Để xóa toàn bộ những lần đã lưu 8. Làm thể nào để xóa bỏ trạng thài vài commit gần đây?Để thưc hiện công việc này chúng ta có thể sử dụng 1 trong 2 lệnh sau: 1$ git revert &lt;commit-hash-code&gt; Lệnh này sẽ tạo ra một commit mới đảo ngược lại những thay đổi trong commit được chỉ định. 1$ git reset --hard &lt;commit-hash-code&gt; Keehnh này sẽ xóa toàn bộ các commit trước đó và đưa branch hiện tại trở về trạng thái của commit-hash-code đã chọn 9. Gộp một vài commit thành một commit duy nhất? Đôi khi trong lúc làm việc, ta thường tạo ra một số commit dư thừa và sau đó muốn gộp chung số commit đó lại với một message rõ ràng hơn về mục đích chung của toàn bộ các commit đó. Để làm được điểu này, ta có thể sử dụng những lệnh sau: 1$ git rebase -i &lt;commit-hash-code&gt; Với commit-hash-code là hash code của commit cuối cùng của nhóm cần gộp hoặc: 1$ git rebase -i HEAD~&lt;index&gt; Với index là số lượng commit cần gồm so với commit cuối cùng. Ngoài ra khi thực hiện việc rebase để gộp commit, ta có các lựa chọn khác như pick|squash|fixup để quyết định kiểu gộp. Cuối cùng ta cũng có thể dùng lệnh sau để gộp commit: 123$ git reset --soft &lt;commit-hash-code&gt;$ git add .$ git commit -m&quot;New commit&quot; Với commit-hash-code là mã hash của commit trước đó mà ta muốn gộp lại từ commit cuối cùng đến commit chỉ định. 10. Phân biệt giữa git reset, reset –soft, reset –hard1$ git reset &lt;commit-hash-code&gt; Sẽ di chuyển HEAD về phía commit được chỉ định nhưng vẫn giữ nguyên trạng thái thay đổi của các file và đồng thời loại bỏ các file đó khỏi trạng thái staged 1$ git reset --soft &lt;commit-hash-code&gt; Tương tư như git reset nhưng toàn bộ các fle vẫn giữ được trạng thái staged. 1$ git reset --hard &lt;commit-hard-code&gt; Tương tự như 2 lệnh trên nhưng toàn bộ sự thay đổi của các file sẽ bị loại bỏ hoàn toàn nên hãy chú ý khi dùng lệnh này để tránh rơi vào trường hợp bao nhiêu công sức đổ xuống sông xuống biển Thế nào là cherry-pick? Bạn có thể hiểu cherry-pick cũng có một số điểm tương đồng với merge và rebase là lấy thay đổi từ một branch này và gộp vào branch khác. Nhưng điểm khác nhau lớn nhất giữa cherry-pick và merge, rebase là cherry-pick chỉ gộp một commit được chỉ định từ một nhánh khác vào nhánh hiện tại trong khi merge và rebase sẽ gộp toàn bộ các commit lại. Để sử dụng cherry-pick, ta cần xem lại log các commit sau đó lấy mã hash của commit cần được cherry-pick và checkout sang nhánh cần được gộp commit của mã hash kia và thực hiện lệnh: 1$ git cherry-pick &lt;commit-hash-code&gt; Một hình ảnh minh họa cho cherry-pick: Giả sử ta muốn lấy commit C từ branch master và gộp vào branch cherry-pick Sau khi thực hiện lệnh cherry-pick như đề cập ở trên, đây sẽ là kết quả ta thu được Như ta có thể thấy commit C từ branch master được gộp vào với branch cherry–pick dưới tên commit là C’ Git flow là gì? Git flow là một quy trình làm việc với git được thiết kế bởi Vincent Driessen. Git flow đưa ra một mô hình phân nhánh giúp hỗ trợ việc quản lý các dự án lớn dễ dàng hơn. Sơ đồ tổng quan: Các branch trong gitflow: Master branch: là branch dùng cho sản phẩm chính thức. Đây luôn là branch ổn định nhất và nó chưa lịch sử các lần release của dự án Develop branch: là nhánh dùng cho sản phẩm trong quá trình phát triển Feature: mỗi tính năng mới cho sẩn phẩm sẽ được tạo và phát triển trên một branch mới với tên quy ước feature/tên_branch. Các feature này sẽ tạo ra từ develop branch và khi được hoàn thiện sẽ được gộp trở lại với develop branch (Lưu ý: các Feature không được phép gộp trực tiếp với master branch) Release: khi develop branch đã có đủ số tính năng cần thiết để có thể release, ta có thể tạo branch mới với tên quy ước release/tên_version. Branch này sau khi được tạo xong sẽ tiến hành merge nó với đồng thời cả master branch và develop branch Hotfix branch: khi sản phẩm trên master branch của chúng ta gặp phải trục trặc và cần có bản vá ngay lập tức thì ta sẽ tạo ra hotfix branch. Branch này tương tự như release branch nhưng nó được tạo ra từ master branch thay vì từ develop branch như release (*Chú ý hotfix branch cũng cần được gộp lại với master branch với develop branch) Các lệnh trong gitflow Để khởi tạo một git-flow cho một project, ta dùng lệnh sau 1$ git flow init Lệnh này sẽ tạo ra hai branch ban đầu là master và develop Để bắt đầu một feature ta dùng lệnh 1$ git flow feature start &lt;tên-feature&gt; Sẽ tạo ra một branch mới có tên dạng feature/&lt;tên-feature&gt; Sau khi feature đó được thực hiện xong, ta có thể công bố feature đó lên remote server để mọi người cùng có thể cập nhật bằng cách gõ lệnh: 1$ git flow feature publish &lt;tên-feature&gt; Để tiến hành gộp branch đó vào develop branch ta dùng lệnh: 1$ git flow feature finish &lt;tên-feature&gt; Để tạo một bản release ta dùng lệnh: 1$ git flow release start &lt;verion-no&gt; Để tiến hành merge bản release đó vào master branch và develop branch ta dùng lệnh: 1$ git flow release finish &lt;version-no&gt; Để tạo một bản hotfix ta dùng lệnh: 1$ git flow hotfix start &lt;tên-hotfix&gt; Sau khi bản hotfix hoàn thiện ta có thể tiến hành merge lại với master branch và develop branch như sau: 1$ git flow hotfix finish &lt;tên-hotfix&gt; Kết luậnBài viết ở trên chủ yếu giới thiệu cho mọi người về các khái niệm trong git cũng như cách sử dụng nó trong công việc thường ngày của mình một cách hiệu quả hơn. Cám ơn bạn đã theo dõi.","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://nthung2112.github.io/tags/git/"}]},{"title":"Progressive Web App tương lai của nền tảng web","slug":"Progressive-Web-App-tuong-lai-cua-nen-tang-web","date":"2018-04-25T11:15:00.000Z","updated":"2018-04-30T08:06:42.807Z","comments":true,"path":"2018/04/Progressive-Web-App-tuong-lai-cua-nen-tang-web.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Progressive-Web-App-tuong-lai-cua-nen-tang-web.html","excerpt":"Tóm tắt“Mobile first” hay “Think mobile” là một trong những hot trend mà chúng ta thường được nghe gần đây, khi mà số lượng thiết bị di động và số lượng người sử dụng các thiết bị di động ngày càng lớn. Nhưng think như thế nào cho đúng là điều cần làm rõ. Bài viết này sẽ cung cấp thông tin cho bạn về cách tư duy theo PWA. PWA không hoàn toàn là một giải pháp về công nghệ, mà là một tập các tiêu chuẩn được định nghĩa cho các ứng dụng web hướng theo, nhằm mang lại trải nghiệm tốt nhất cho người dùng, với sự hỗ trợ của browser về các API có liên quan như Service Worker, Push Notification v.v…","text":"Tóm tắt“Mobile first” hay “Think mobile” là một trong những hot trend mà chúng ta thường được nghe gần đây, khi mà số lượng thiết bị di động và số lượng người sử dụng các thiết bị di động ngày càng lớn. Nhưng think như thế nào cho đúng là điều cần làm rõ. Bài viết này sẽ cung cấp thông tin cho bạn về cách tư duy theo PWA. PWA không hoàn toàn là một giải pháp về công nghệ, mà là một tập các tiêu chuẩn được định nghĩa cho các ứng dụng web hướng theo, nhằm mang lại trải nghiệm tốt nhất cho người dùng, với sự hỗ trợ của browser về các API có liên quan như Service Worker, Push Notification v.v… Trước khi bàn đến các tiêu chuẩn của PWA và cùng tìm hiểu các nghiên cứu mới về trải nghiệm của người dùng, các công nghệ hứa hẹn… Chúng ta sẽ cùng điểm qua một vài cảm nhận và suy nghĩ trong lược sử thời gian của ngành công nghệ web. Bên cạnh đó, chúng ta cũng sẽ nói đôi chút về Native App đến Hybird App và từ đó hiểu thêm về lý do ra đời của PWA. Bài viết sẽ cung cấp cho chúng ta cái nhìn tổng quát về các vấn đề ưu nhược khi phát triển ứng dụng web theo các tiêu chuẩn của PWA, những khó khăn mà lập trình viên có thể gặp phải, hơn nữa, bài viết sẽ cung cấp view nhìn để có thể scale được một dự án PWA về yếu tố con người cũng như về chi phí, hạ tầng. Bài viết khá dài, nên bạn có thể phải kiên nhẫn đọc hết những phần bên dưới, hoặc lướt qua các các heading để có thể chọn các đề mục mà mình tâm. Một vài cảm nhận về nền tảng Web &amp; App.Từ Web App đến Single Page (Web) Application Bạn có thể tìm thấy các nét sơ lược về lịch sử của trong ngành web theo Wikipedia với các cột mốc quan trọng ở đây evolutionoftheweb, và theo quan điểm cá nhân của tác giả thì trong hơn 10 năm qua có thể kể đến hai nhóm sự kiện tiêu biểu: Sự ra đời của các browsers chịu thay đổi và mau lẹ trong sự thay đổi như Firefox, Chrome. Vì chính sự ra đời này, các tiến bộ mới được nhanh chóng cài đặt, phổ biến đến cộng đồng lập trình viên và người sử dụng. Sự ra đời của AJAX có thể nói là cột mốc đáng chú ý nhất của nền tảng web, đã có thời chúng ta đi đâu cũng nghe người ta nói về điều này như là một phương tiện mang đến sức mạnh to lớn cho bất kì một website nào. Một trong các ứng dụng mang đậm dấu ấn của sự thay đổi này là Gmail, nó thay đổi cách chúng ta suy nghĩ về một phần mềm quản lý email trên nền web. Trình duyệt mới đi kèm công nghệ tiên tiến, chúng biến công việc phát triển website, ứng dụng web trở nên thú vị dành cho lập trình viên và không gian sáng tạo không giới hạn dành cho designer. Cùng với sự bùng nổ của internet, cho đến sự ra đời của AJAX, đã khiến các website từng vốn chậm chạp giờ trở nên nhanh hơn, có hiệu năng và trải nghiệm giống như một phần mềm trên desktop và được gọi là một Single Page Application (SPA). Từ Native App đến Hybird AppNgay từ những ngày bắt đầu, các ứng dụng di động đã tạo ra những điều “thật không thể tin nổi” về sự trải nghiệm đa dạng. Các thiết bị di động với cấu hình ngày càng mạnh mẽ với chu kỳ nâng cấp 1 đến 2 lần mỗi năm và người sử dụng ngày càng chịu móc hầu bao, bỏ thời gian cho các ứng dụng trên di động của mình. Bên cạnh đó, các nền tảng di động còn có sự phong phú về chủng loại, phù hợp túi tiền, sở thích của người tiêu dùng đã nhanh chóng trở thành mảnh đất màu mỡ để các nhà khởi nghiệp nghĩ về các ứng dụng nhằm tạo kết nối giữa mọi người, giải quyết công ăn việc làm, nhu cầu học tập giải trí, cải thiện cuộc sống, chăm sóc sức khoẻ… như Grab là một ví dụ về ứng dụng di động đã tạo ra không chỉ việc làm cho cho sinh viên, mà căn bản là đã thay đổi cái nhìn và thói quen truyền thống về ngành dịch vụ xe ôm. Có thể kể đến các nền tảng huy hoàng một thời như: Symbian của đế chế Nokia, Windows Phone với điện thoại O2 một thời làm mưa gió, dâu đen Blackberry những ngày hoàng kim đình đám… cho đến khi chỉ còn hai cái tên thống trị thị trường rộng lớn và màu mỡ này là iOS, Android như chúng ta đã biết. Dù vậy, trong trò chơi vương quyền vốn nguy hiểm này, tuy chưa biết kẻ nào sẽ chiến thắng cuối cùng, song có rất nhiều ông lớn vẫn không cam chịu, không dễ dàng bỏ cuộc chơi và tham vọng của mình. Và ngày nay, các ứng dụng phát triển trên hai nền tảng Android của Google, và iOS của Apple đã lên đến những con số khổng lồ tạo ra một cộng đồng người sử dụng trung thành. Điều đó cũng có nghĩa là nếu bạn muốn xây dựng ứng dụng Native App bạn cũng phải sẵn sàng phát triển hai phiên bản khác nhau. Thật không may là chi phí phát triển cho hai nền tảng này không hề nhỏ, khi mà bạn biết rằng chi phí đó kèm theo việc maintain theo thời gian là một ác mộng, và phần lớn code của chúng gần như là không thể tái sử dụng cho nhau. Đó là lúc người ta nghĩ đến điều làm thế nào để có thể viết một lần và chạy trên nhiều nền tảng, và có nhiều giải pháp cho điều này, ví dụ: Các nền tảng build/compile ra Native App như: (a) Xamarin, bạn có thể code với C# và build ra các nền tảng khác nhau như Android, iOS, Windows Phone. (b) React Native, bạn có thể Javascript để build ra Android, iOS. Các nền tảng cho phép porting các trang web hiện có, hoặc xây dựng app trên nền tảng html/css/js để build ra các ứng dụng chạy trên cả Andriod, iOS như PhoneGap, gọi là Hybird App bằng cách cung cấp bên dưới một Native App như là một Brigde Software để giúp ứng dụng có thể tương tác với phần cứng bên dưới. Hybird app ra đời tận dụng được những ưu điểm của nền tảng web, tận dụng nguồn nhân lực to lớn từ nền tảng này, giờ đây dân lập trình web cũng có thể viết app, porting ứng dụng của mình lên nền tảng mobile một cách dễ dàng. Thật vi diệu phải không? Các so sánh giữa Web và AppWeb AppƯu điểm Chạy được trên nhiều nền tảng, từ mobile đến desktop, từ Andriod đến iOS, từ Windows đến Linux v.v… Người dùng không phải cài đặt ứng dụng nặng nề có khi hàng trăm Mb, không phải nâng cấp version, chúng luôn được cập nhật mới nhất. Có thể searchable từ Google Scale ứng dụng dễ dàng với một cộng đồng lập trình viên năng động và đông đảo dễ thuê mướn. Nhược điểm Không thể can thiệp được sâu vào hệ thống mà phụ thuộc vào trình duyệt của người dùng. Các chức năng về offline có giới hạn như phụ thuộc vào trình duyệt có support hay không. Nhiều trình duyệt và các phiên bản khác nhau bạn sẽ tốn thời gian để đảm bảo chúng chạy giống nhau. Bonus: Bạn có thể xem qua hình bên dưới để nhìn thấy những gì mà Chrome có thể support Native AppƯu điểm Có thể sử dụng hầu hết các tính năng của thiết bị như camera, la bàn… Cảm giác và cái nhìn (feel and look) thân thiện với người dùng vì sử dụng các control native của thiết bị, do hệ điều hành của thiết bị cung cấp. Do sử dụng Native App, nên khi hệ điều hành của thiết bị được nâng cấp (ví dụ khi nâng cấp lên IOS 10, thì sẽ thừa kế được) Có thể work offline, truy cập vào danh bạ v.v… Có thể tận dụng các chức năng như tăng tốc nên tốc độ của Native App sẽ có peformance tốt. Nhược điểm Chi phí phát triển cao, phải gần như làm cho 2 bản dành cho iOS, Android Phải optimize cho các dòng điện thoại không phải flagship Phải cài đặt, không thể được searchable Dung lượng cài đặt rất lớn chiếm một khoảng đáng kể đặc biệt với các thiết bị có bộ nhớ thấp, việc cài đặt còn làm tăng chí phí về mặt dung lượng sử dụng 3G và người sử dụng có thể sẽ phải cân nhắc thời điểm tải. Người dùng sau khi đã cài đặt thường cũng sẽ không nhớ tới ứng dụng và họ cũng dễ dàng remove vì chiếm tài nguyên và cảm thấy chật chội. Thời gian submit và release rất lâu phải chờ đội ngũ Reviewers của App Stores duyệt qua. Điều đó có nghĩa là, khi có một bug xảy ra việc fix bug để giảm đi tác động đến khách hàng là không thể thực hiện ngay được. Điều đó cũng có nghĩa là chi phí dành cho việc testing cũng trở nên lớn hơn. Hybird AppƯu điểm Viết một lần và chạy trên nhiều nền tảng, chúng ta chỉ code một lần cái app của mình, phần còn lại cái cầu nối (Bridge Software) lo. Với các ứng dụng có porting từ web, hoặc có tính năng giống như mobile web, liên quan nặng về xử lý dữ liệu thì loại ứng dụng này là phù hợp. Có thể chạy background, offline. Nhược điểm Peformance kém: Có thể nói các ứng dụng Hybird gặp phải các vấn đề lớn về performance, bởi phải chạy trên một bridge app được viết tất cả trong 1 cồng kềnh, chúng thật sự gần như là một một trình duyệt di động mở rộng (Extended Mobile Browser) có bổ sung thêm các API. Khó customize và optimize phù hợp với chức năng của mình, đặc biệt cho các ứng dụng như Game. Các API vẫn chưa hỗ trợ đầy đủ để theo kịp sự phát triển của phần cứng và sự đa dạng của các nền tảng khác nhau. PhoneGap - Nền tảng nổi bật của Hybird AppPhoneGap là một đại diện tiêu biểu cho nhóm nền tảng Hybird App, được phát triển bởi Adobe System dùng để phát triển mobile app, nhưng không đòi hỏi user có kiến thức về Andriod, hay iOS, mà chỉ cần kiến thức về web như hình minh họa bên dưới. Bảng thống kê so sánh các công nghệNếu bạn cảm thấy quá mệt và loạn vì đống chữ ở phía trên, thì có thể nhìn vào bảng tổng hợp bên dưới để có cái nhìn nhanh về so sánh tương đối giữa các nền tảng này. Sự ra đời của PWACác thống kê thú vị 5 tỉ thiết bị đã và sẵn sàng cho nền tảng web. Có hơn 1 tỉ trang web trên thế giới. Tới quý 2, 2015, cho thấy 90% thời gian người sử dụng điện thoại ở Mỹ là tương tác với Native App, chỉ có 10% sử dụng browser. Nhưng điều này không có nghĩa là bạn cần phải xây dựng một Native App cho ứng dụng của mình, vì phần lớn thời gian người sử dụng bỏ ra lại cho những App phổ biến như Facebook, Twitter, YouTube, Instagram v.v.. Người dùng download app dễ dàng nhưng cũng dễ dàng gỡ bỏ app, bởi phần lớn các app được chạy các chương trình marketing hấp dẫn để thu hút người cài đặt, nhưng vì điện thoại rất dễ bị hết dung lượng nên user sẽ gỡ những app mà họ ít khi dùng đến. 65% người sử dụng điện thoại không hề download ứng dụng mới hàng tháng. Điều này có nghĩa là chi phí cài đặt ứng dụng ngày càng cao. Tất cả những điều này cho thấy mobile web vẫn còn rất quan trọng. Nhưng lại có thêm một nghịch lý là, trong khi tỉ lệ người dùng mobile web so với tỉ lệ người dùng desktop web tăng trưởng rất nhanh và cao, nhưng tỉ lệ convert thành giá trị như đơn hàng lại rất thấp. Một phần trong đó là vì các ứng dụng web hiện tại không được optimize cho mobile cho các vấn đề về UX/UI và trong điều kiện mạng chậm. Một website có thể tải về dưới 3s người sử dụng sẽ happy với website của bạn, và có nghĩa là tỉ lệ rời bỏ thấp, đơn hàng sẽ tăng lên. Còn từ 3s-10s thì người sử dụng chỉ có thể nói là sẽ cố kiên nhẫn. Quá 10s người sử dụng sẽ rời bỏ trang web của bạn vì họ nghĩ nó không hoạt động. (Phần viết này dựa trên sự suy đoán của tác giả) Sự phát triển mạnh mẽ của Native App, thách thức sự thống trị của Google Search Engine, nếu người sử dụng dùng app, họ sẽ không còn cần vào Google để tìm kiếm thông tin nữa và sản phẩm cốt lõi của Google sẽ gặp rất nhiều vấn đề, mà có thể kể đến là sự sụt giảm người sử dụng do các thông tin không còn đưa lên web để có thể crawl được, và kèm theo đó là sự sụt giảm về khả năng kiếm tiền của Google. Tác giả nghĩ đó cũng có thể là lý do khiến Google phải đẩy mạnh phát triển PWA để hỗ trợ cho nền tảng web, níu giữ người sử dụng ở lại nền tảng này. Có thể nói, sự ra đời của Hybird App là một cộc mốc khá quan trọng thể hiện rõ cách nhìn và sự mong mỏi của các nhà phát triển trong việc optimize chi phí. Và câu hỏi đặt ra là, tại sao các trình duyệt bản thân nó không nên là một Bridge Software cung cấp các API để các ứng dụng web có thể truy cập vào phần cứng của thiết bị. Do vậy, chúng ta có thể tin rằng, điều đó sắp tới sẽ là một phần trong những thay đổi, bổ sung của các browsers. Các tiêu chí về PWA: Progressive - Hoạt động cho tất cả mọi người, không liên quan tới việc lựa chọn browser, bởi chúng được xây dựng với những sự cải tiến như là một nguyên lý cốt lõi. Responsive - Có thể hoạt động tốt trên mọi thiết bị như desktop, mobile, tablet, với mọi kích thước màn hình. Connectivity independent - Có thể hoạt động ngay cả khi offline (dựa trên Service Worker) và hoạt động tốt trong điều kiện network chậm. App-like - Sử dụng app-shell để cung cấp các chức năng định hướng và sự tương tác giống như app. Fresh - Luôn update phiên bản mới nhất (dựa trên Service Worker) Safe - Tất cả phải được phục vụ thông qua HTTPS để tránh bị nghe lén và đảm bảo nội dung không bị giả mạo. Discoverable - Có để được nhận dạng như là ứng dụng (dựa trên Service Worker, và W3C manifests ) và cho phép Search Engines có thể tìm thấy. Re-engageable - Tạo ra sự tương tác lại ứng dụng dễ dàng thông qua các chức năng chẳng hạn như Push Notification. Installable - Có thể Add to Homescreen để giữ lại ứng dụng trên màn hình. Linkable - Dễ dàng share, chia sẽ điều mình muốn đến với người khác thông qua URL mà không cần phải cài đặt. 10 tiêu chí nhận dạng một ứng dụng được xem là PWA với sự giúp đỡ của Google Translator. PWA không hoàn toàn là một giải pháp về công nghệ, mà là một tập các tiêu chuẩn được định nghĩa cho các ứng dụng web hướng theo nhằm mang lại trải nghiệm tốt nhất cho người dùng, với sự hỗ trợ của browser về các API có liên quan như Service Worker, Push Notification v.v… Điều ý nghĩa của một ứng dụng theo tiêu chuẩn của PWA không phải là nó có thể tận dụng được sức mạnh từ phần cứng của người sử dụng hay không, như cách mà nhiều lập trình viên lần đầu nghe qua quan tâm, mà là nó giúp cho các ứng dụng web trở nên tốt hơn từ góc độ performance đến những cải tiến về UX/UI. Để hiểu được PWA là gì, cần phải nhìn về Native App và Web App ở góc độ ưu nhược điểm của từng đối tượng. Và khi nhìn thấy nhược điểm của chúng, cũng là lý do đầy đủ để chúng ta hiểu PWA ra đời như là một giải pháp hoàn thiện cả hai nền tảng này bằng cách mang ưu điểm của cả hai. Nghiên cứu mới về trải nghiệm người sử dụngNgày trước, một website tốt là một website có Page Speed cao, trong thời gian vài giây nó phải tải toàn bộ nội dung về thiết bị, tiếp theo đó trình duyệt hiển thị giao diện, cuối cùng là cho người dùng tương tác. Điều đó có nghĩa là, trong thời gian tải toàn bộ nội dung của website, người dùng chỉ nhìn thấy một màn hình trắng tinh khôi, hoặc là một dấu hiện đang tải trang với animation nhàm chán và có thể họ sẽ bắt đầu thấy mất kiên nhẫn trong các điều kiện như network bị chậm. Theo nghiên cứu của Google, một website tốt phải cho một sự trải nghiệm liên tục không gián đoạn, nhằm thuyết phục người dùng tin rằng là nó đang hoạt động để họ không rời bỏ đi chỗ khác, cũng như không cảm thấy phải khó chịu khi phải chờ đợi. Sự tải trang, các nội dung cần thiết để có thể tạo ra một ứng dụng hoàn chỉnh có thể chia thành nhiều giai đoạn phù hợp với nhu cầu và khả năng tương tác của người dùng. Ứng dụng không cần phải load tất cả mọi thứ lên sẵn trong khi có rất nhiều tính năng người dùng có thể chưa cần dùng tới hoặc là ít khi dùng tới. Các giai đoạn trải nghiệm cơ bản First Paint - Định nghĩa việc website cần tải thật nhanh để người sử dụng thấy nó hoạt động chứ không phải là một màn hình trắng tinh vô hồn. First Meaningful Paint - Định nghĩa về việc website cần phải hiển thị những điều có ý nghĩa để người sử dụng có thể nhìn thấy ví dụ như những hình ảnh banner, video v.v… gọi là Hero Element Time to Interactive - Định nghĩa về cách làm thế nào người sử dụng có thể bắt đầu tương tác với website của bạn cũng trong thời gian nhanh nhất, có thể thao tác với điều họ cần, mà không cần phải đợi tải hoàn toàn trang, ví dụ như họ đã có thể bắt đầu với search box, hoặc xem video, đi vào sản phẩm chi tiết. Google đã phát triển một công cụ gọi là Lighthouse để phân tích website của bạn theo các tiêu chí này. Tại sao PWA có thể trở thành tương lai của ngành webNhư đã nói, việc mobile web vẫn có những thế mạnh mà không thể bị đánh bại, bởi những giá trị cốt lõi chưa thể bị thay thế trong tương lai gần như đã đề cập vốn rất chi tiết ở trên. Nhưng với sự thay đổi nhanh về phần cứng cũng như về hệ sinh thái các phần mềm từ hệ điều hành cũng như Native App trên các thiết bị di động, đòi hỏi các ứng dụng web phải thay đổi để thích nghi với sự kỳ vọng cao hơn về nhu cầu trải nghiệm của người dùng. Rất khó để chấp nhận với một thiết bị đẹp, cấu hình mạnh mẽ, và đắt đỏ lại tải một trang web lên có vẻ chậm chạp, hiệu năng kém và thiết kế cẩu thả. Những lý luận và tư tưởng của PWA là tuyệt vời và có thể áp dụng để làm cho sản phẩm của chúng ta tốt hơn, điều đó hứa hẹn một thị trường hấp dẫn về các website đã có cần phải thay đổi và các website mới cần phải được build trên các nền tảng công nghệ mới và tư tưởng mới. Nếu chúng ta không nắm bắt đúng thời điểm, đúng điểm rơi của công nghệ, chúng ta sẽ bị bỏ lại phía sau, lạc hậu và khi phần lớn khách hàng quay lưng đi với mình thì đã muộn. Có rất nhiều bài học về điều này như của Nokia, của Yahoo… có thể sự đổ vỡ của các tập đoàn khổng lồ này đến từ nhiều nguyên nhân, nhưng trong số đó chắc chắn phần lớn từ các sản phẩm thiếu sáng tạo, kém hấp dẫn đối với người tiêu dùng, thậm chí không muốn nói là lạc hậu trong tồn tại của nó so với đối thủ. Những khó khăn khi ứng dụng PWA Nguồn nhân lực về PWA hiện tại đang thiếu hụt mà chưa dễ dàng được khoả lấp trong thời gian ngắn sắp tới, do các công nghệ và nền tảng vẫn còn mới. Tác giả sẽ viết một bài sắp tới để nói sâu hơn về vấn đề này cũng như giải pháp khắc phục cho các tổ chức muốn phát triển sản phẩm theo tư tưởng của PWA. Sự thiếu hỗ trợ đầy đủ từ các nhà phát triển chẳng hạn như từ Apple, nhưng điều này đang và sẽ sớm được khắc phục, bạn có thể tham khảo ở đây để thấy tính năng này đang được phát triển bởi Apple Những lo ngại của cộng đồng developer do cách hiểu sai là nó không thể sử dụng được phần cứng của thiết bị. Các lãnh đạo, cấp trên vẫn chưa thấy được nhiều value để chuyển đổi từ những website truyền thống sang nền tảng mới. Nhưng các con số và thống kê cũng cho thấy việc chuyển đổi theo tương tưởng và mô hình công nghệ mới hơn là điều không thể nào né tránh. Những nhà phát triển tiêu biểuBạn có thể nhìn qua các website này để tìm hiểu các website đó hoạt động như thế nào để tham khảo cho website của mình. Ở nước ngoài có thể kể đến: Flipkart - Ấn độ, xem chi tiết tại đây. Với phiên bản PWA mobile thời gian user ở lại website là: 3.5 phút so với phiên bản mobile cũ không PWA là 70s. 3x tăng thời gian user ở lại website. 40% tỉ lệ tương tác tăng thêm. 70% nhiều hơn CR đến từ Add to Homescreen. 3x giảm tỉ lệ sử dụng dữ liệu. Aliexpress - Trung Quốc, xem chi tiết tại đây. 104% CR cho người dùng mới tất cả trình duyệt; 82% CR tăng thêm trên iOS 2X số trang mà người sử dụng xem thêm với mỗi session cho tất cả trình duyệt. 74% tăng thêm thời gian người sử dụng với mỗi session tất cả trình duyệt. Ở thị trường Việt Nam, các site nổi tiếng có thể kể đến: Tiki - đã released version PWA vào mùa hè 2017 Sendo - dự kiến released vào cuối năm 2017 PWA dưới góc nhìn cho doanh nghiệpĐối với doanh nghiệp điều quan trọng là giảm chi phí, tăng doanh thu và lợi nhuận thì việc phát triển một ứng dụng PWA với các phương pháp luận và các giải pháp mới khiến cho chi phí phát triển dự án xét về lâu dài càng giảm, và lợi nhuận ngày càng được tối đa hoá. Sản phẩm theo nền tảng này được thừa hưởng một hệ thống lý luận và phương pháp lập trình tốt để dễ dàng scale, maintain, improve, và thay đổi trong tương lai. Điều đó có nghĩa là các tính năng được thêm mới dễ dàng với chi phí thấp, rủi ro về lỗi được giảm. PWA dưới góc nhìn cho lập trình viênBạn cần học gì, làm gì.Nếu bạn chưa từng biết làm thế nào thì đọc bài viết này Làm thế nào để trở thành Frontend developer Khả năng scale của dự án PWAPWA đã được đưa ra từ cách đây từ vài năm trước, nhưng đây là điểm rơi để các ứng dụng có thể chuyển đổi sang nền tảng này, do sự phát triển vô cùng mạnh mẽ của các framework, thư viện được xây dựng và phát triển trên nền Nodejs, đáng để kể đến như React, Angular, Polymer dựa trên trên các công cụ bundle như Grunt, Gulp, Webpack… Chúng khiến cho việc tổ chức, tối ưu code được dễ dàng, tổ chức team hiệu quả và tránh được các rủi ro. Khả năng scale của dự án là dễ dàng cả về yếu tố con người, vật lý, và chi phí. Không có sự hỗ trợ về các công cụ phát triển phần mềm từ hệ sinh thái của Nodejs, rất khó để có thể ứng dụng được các triết lý mà PWA đã đề ra, vì có thể dự án sẽ có chi phí phát triển cực lớn và rủi ro phát sinh theo nó là không thể nào dự đoán hay kiểm soát. Từ góc nhìn outsourcing Làm thế nào để decoupling các task chức năng của ứng dụng, sao cho khi có nhiều tính năng thì có thể đẩy người vào, vì nếu không thể decoupling được tính năng, các chức năng được code độc lập, mỗi người làm một phần thì khi càng push người vào, thì sự phát triển của dự án chưa chắc tương xứng. Giúp debug dễ dàng, khi có vấn đề gì xảy ra không được như mong đợi. Dự án dễ testable, có thể viết chức năng test một cách dễ dàng. Từ góc nhìn production Bao gồm cả các yếu tố của outsourcing. Điều quan tâm là việc tính scale như thế nào khi có sự tăng tưởng của người sử dụng, đặc biệt là khi các phương pháp xây dựng một ứng dụng PWA phụ thuộc nặng nào Nodejs ngay cả khi bạn dùng framework/library nào đi chăng nữa thì các công cụ để xây dựng và tổ chức source code, build source code, debug sẽ cần đến gulp/grunt hoặc là Webpack. Nodejs về hiệu năng có thể được mọi người nghĩ là kém so với các ngôn ngữ khác và khó scale. Nhưng cái nhìn đơn giản đó là chưa đúng. Chúng ta cần nhìn về ứng dụng với các công nghệ được build stack với nhau như: Nginx, Redis, Database v.v… một ứng dụng chạy nhanh cần một thiết kế tốt, có thể hoạt động ổn định và scale theo chiều ngang chứ không nên được thiết kế chỉ dựa vào ngôn ngữ. Ở góc nhìn production, các kỳ vọng về sản phẩm, về chi phí, thời gian, con người đều có đủ phương pháp lý luận và tổ chức để có thể đi đến việc dễ dàng kiểm soát và đạt được các tiêu chí đề ra. Ở một bài viết tiếp theo, chúng ta sẽ xem xét một ứng dụng open source PWA mẫu, để tìm hiểu các công nghệ được stacked như thế nào. Kết luậnQua một bài viết khá dài, tác giả hi vọng sẽ mang lại cho bạn một trong những bài viết đầy đủ và chi tiết nhằm cung cấp các view nhìn mang giá trị tham khảo về một trong những nền tảng rất hứa hẹn thay đổi tương lai của ngành lập trình và phát triển ứng dụng web. Bài viết sẽ không tránh khỏi các thiếu sót mang tính chủ quan của tác giả và cả các sai sót về các thông số, cách trình bày, bố cục, lỗi chính tả… nên hi vọng bạn đọc thông cảm bỏ qua. Nếu bạn có bất kì câu hỏi hay phản biện bổ sung nào vui lòng để lại comment bên dưới. Rất cảm ơn quý đọc giả và các bạn vì đã kiên nhẫn đọc hết bài viết. Tham khảo Getting started with Progressive Web Apps Mobile Web Hay Mobile App? Why “Progressive Web Apps vs. native” is the wrong question to ask","categories":[],"tags":[{"name":"pwa","slug":"pwa","permalink":"http://nthung2112.github.io/tags/pwa/"},{"name":"web","slug":"web","permalink":"http://nthung2112.github.io/tags/web/"}]},{"title":"Biên niên sử về bố cục trong trang web","slug":"Bien-nien-su-ve-bo-cuc-trong-trang-web","date":"2018-04-25T10:57:00.000Z","updated":"2018-04-25T11:06:06.716Z","comments":true,"path":"2018/04/Bien-nien-su-ve-bo-cuc-trong-trang-web.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Bien-nien-su-ve-bo-cuc-trong-trang-web.html","excerpt":"Giới thiệuBài viết bàn về công nghệ các lập trình viên web áp dụng để thiết kế bố cục trong trang web (website layout) - qua các thời kỳ: table, float, block-inline, flexbox, JS, Twitter Bootstrap và grid.","text":"Giới thiệuBài viết bàn về công nghệ các lập trình viên web áp dụng để thiết kế bố cục trong trang web (website layout) - qua các thời kỳ: table, float, block-inline, flexbox, JS, Twitter Bootstrap và grid. Thời trước 2010Đây là thời kỳ tối cổ với công nghệ website, người ta hầu như ít đầu tư giao diện web, việc dựng bố cục, xương sườn cho trang web sử dụng thẻ HTML &lt;table&gt; là chính. Layout Table rất đơn giản, với 1 table 3 rows, 1 row làm header, 1 row làm content, cái cuối làm footer.Nhược điểm của layout table là: rất khó khăn khi tái cấu trúc lại bố cục, khó khăn khi thiết kế vì table mục đích chính là biểu diễn dữ liệu. Các cột có chiều rộng cố định không linh hoạt, nan giải khi xử lý trên nhiều kích thước màn hình.Năm 2012, khi mới ra trường, công việc đầu tiên của tôi là đập bỏ và thay thế các layout dạng table. Tới nay thì không còn ai nghĩ tới việc việc thiết kế layout bằng table nữa.Tuy nhiên còn rất nhiều tài liệu trong các trường đại học chưa được cập nhật nên đừng ngạc nhiên khi bạn được dạy thiết kế layout bằng thẻ table nhé. Từ 2012 - Float lật đổ TableKhi layout table quá bất cập thì giải pháp thay thế tuyệt vời nhất trong giai đoạn này là dùng các thẻ HTML kết hợp với CSS property: Float.Các khối block sẽ được tách ra và “trôi” qua trái, phải, tùy theo ý muốn của lập trình viên. Ưu điểm: code sạch sẽ hơn khi dùng table, dễ thay đổi chỉnh sửa, linh hoạt trên nhiều kích thước màn hình.Khuyết điểm: dễ bị “vỡ trang”, nếu lập trình viên chưa làm chủ được float, chưa biết cách sử dụng các tuyệt chiêu như: clear, overflow… Lạm dụng float trên các bố cục phức tạp. 2013 - thời của các CSS FrameworksVào giai đoạn này, các CSS Frameworks như Bootstrap, Foundation,…Các thư viện này hỗ trợ rất đắc lực cho các lập trình viên, dễ sử dụng, dễ thiết kế bố cục, chỉ cần gắn các class phù hợp. Bên cạnh đó chúng còn liên tục cập nhật và cải tiến không ngừng.Phải nói trong thời gian đó, các CSS Frameworks nhất là Bootstrap, trở thành 1 xu hướng tới mức khi đi phỏng vấn code web, chắc ăn thế nào họ cũng hỏi bạn vài câu.Để dùng tốt Bootstrap, bạn phải học các khái niệm như Grid View System, học thuộc các class thông dụng , tận dụng tối đa các chức năng có sẵn, người giỏi nhất lúc này là người code CSS, style ít nhất.Hạn chế của các CSS Framework này là quá kềnh càng nếu ta không tận dụng hết chức năng (có thể khắc phục bằng bản tùy chỉnh).Nâng cấp phiên bản cần sửa đổi lại tên các class (v2 xài span1 - span12, v3 xài col-, v4 xài col- ). Ngày nay các CSS Frameworks như Bootstrap đã phát triển hơn khái niệm CSS rất nhiều, ta nên gọi nó với tên front-end component library, vì nó còn tích hợp nhiều thư viện JavaScript bên trong. Số lượng các front-end libraries ngày nay 2015 - CSS3 và FlexboxCSS3 đã hỗ trợ một công nghệ thiết kế layout mới, hiện đại hơn Float đó chính là Flexbox. Đúng như tên gọi flexible (linh hoạt), nó thực sự rất mạnh. Flexbox sẽ giúp bạn điều khiển được không những chiều ngang (horizontal) mà còn chiều dọc (vertical) điều mà CSS thường với position rất cứng nhắc. Flexbox có thể điều khiển được các phần tử bên trong, giúp bạn dễ dàng biểu diễn nội dung và bố cục trên các thiết bị di động. Khuyết điểm: flexbox mạnh và mới nên bạn phải bỏ nhiều công sức để học và làm chủ được nó, khó hơn so với dùng float và Bootstrap. Không khuyến khích dùng flexbox để làm bố cục toàn trang trừ trường hợp đặc biệt, chỉ dùng để bố cục các thành phần bên trong. Lý do vì flexbox phụ thuộc vào nội dung bên trong nó, nên khi bài viết dài ngắn có thể làm “biến dạng” bố cục website của bạn, chưa kể tình huống khi web load chưa kịp. Kết hợp khôn ngoan là dùng grid system để làm bố cục bên ngoài, những phần bố cục cần sự linh hoạt thì dùng flexbox. Bootstrap 4 đã tích hợp flexbox vào grid view của mình, chứng tỏ sức mạnh của flexbox và không thể bàn cãi, đồng thời cho thấy cái tiện lợi khi dùng Bootstrap. 2017 - CSS GridGrid và 1 thuộc tính CSS rất mới, ra đời 3-2017. Tuy nhiên nó đã và đang được giới công nghệ web đặc biệt quan tâm vì những tính năng ưu việt.Nếu như Flexbox phân bố các phần tử theo 1 chiều duy nhất thì Grid cho phép bạn điểu khiển phần tử theo 2 chiều - ngang và dọc.Vì đây là 1 công nghệ mới, nên các tài liệu chất lượng về nó hầu hết là bằng tiếng anh, sắp tới mình sẽ có bài viết về công nghệ này, mới các bạn theo dõi.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"}]},{"title":"[Regex] Học rồi mà như chưa học","slug":"Regex-Hoc-roi-ma-nhu-chua-hoc","date":"2018-04-25T10:23:00.000Z","updated":"2018-04-25T10:44:38.060Z","comments":true,"path":"2018/04/Regex-Hoc-roi-ma-nhu-chua-hoc.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Regex-Hoc-roi-ma-nhu-chua-hoc.html","excerpt":"Người dẫn lại bài này cũng được phen lao đao khi lục lọi lại mớ kiến thức cơ bản cũ. Đối với sự nghiệp của một coder thì phải được thực hiện liên tục, nếu không sẽ rất dễ quên và lóng ngóng dù chỉ là những kiến thức cơ bản nhất. Dẫu biết rằng search là sẽ thấy nhưng nhiều phen cũng không khỏi thẹn vì giải thích sai cho đàn em =)) Cũng may đọc lại được bài của cu em công ty, kiến thức lại nhanh chóng được khỏa lấp, vì kiến thức nội bộ nên xin được trích lại bài chia sẻ của em nó để đây cho đỡ quên.!","text":"Người dẫn lại bài này cũng được phen lao đao khi lục lọi lại mớ kiến thức cơ bản cũ. Đối với sự nghiệp của một coder thì phải được thực hiện liên tục, nếu không sẽ rất dễ quên và lóng ngóng dù chỉ là những kiến thức cơ bản nhất. Dẫu biết rằng search là sẽ thấy nhưng nhiều phen cũng không khỏi thẹn vì giải thích sai cho đàn em =)) Cũng may đọc lại được bài của cu em công ty, kiến thức lại nhanh chóng được khỏa lấp, vì kiến thức nội bộ nên xin được trích lại bài chia sẻ của em nó để đây cho đỡ quên.! 1. Tựa đềMình vẫn còn nhớ cái hôm đấy. Trong khi mãi ngắm nhìn những dòng code đến hoa mắt là lúc mặt trời đã lặn khuất sau những toà nhà đô thị từ lúc nào cũng không ai hay. Bên ngoài mưa gió bão bùng, lúc mà mình đang cố release cho cái dự án lụt không cần nước, cho nó có thể chạy được. Nhưng hôm đấy cũng không nằm ngoài dự tính, nó vẫn bị fail như bao lần trước, lần này nguyên nhân là do validate dữ liệu bị sai. Lúc đấy phải cần fix luôn ngay nhưng thật không may là anh phụ trách làm phần đấy đã tốc biến về nhà lúc nào không rõ. Còn bản thân thì chả biết tí tẹo về regex cả. Mọi thứ dường như bế tắc! Đã đến lúc mình phải đọc cái regex mà anh kia đã viết! Nhìn những dòng đấy chỉ có thể thốt lên “wth, mình đang đọc cái nồi gì thế này”. Thật không thể nếu bạn chả có kiến thức gì về nó cả. Thực ra mình và nhiều người hay mắc tật lúc cần làm gì là chỉ cần search từ khoá trên anh google rồi copy vào code của mình, tuy không hiểu rõ nhưng thấy nó chạy ổn thì ok. Đến lúc lỗi lên thì chả biết fix thế nào. Cũng vì nguyên nhân đấy mà mình mới biết là đang làm một cách sai lầm và mù quáng và bắt đầu học một cách đúng đắn hơn. Trước mắt là phải tìm hiểu về regex xem nó có gì mà nhìn vào đã thấy sợ rồi. Bạn đã từng bao giờ rơi vào trường hợp như mình chưa, cần kiểm tra định dạng một chuỗi có hợp lệ, hoặc tìm kiếm một chuỗi nằm trong một chuỗi dài khác. Đa số các bạn cần dùng đến việc validate (xác minh) tính hợp lệ của dữ liệu đều đã từ gặp phải câu hỏi đấy. Nếu bạn gặp trường hợp lúc đấy giải pháp đầu tiên bạn nghĩ đến là gì nếu chưa biết gì về regex? Có thể nó sẽ trở thành một bài toán khá hóc búa nếu bạn chỉ xử lý thuần tuý bằng cách duyệt chuỗi mà không có công cụ và thư viện xử lý. Vậy regex là gì? Nó giải quyết bài toán không tưởng ở trên như thế nào? Nó cao siêu và ảo diệu ra sao? Chúng ta hãy cùng đi tìm hiểu nào! 2. Giới thiệuTheo anh wiki Biểu thức chính quy (regular expression, viết tắt là regexp, regex hay regxp) là một chuỗi miêu tả một bộ các chuỗi khác, theo những quy tắc cú pháp nhất định. Cùng điểm một chút về lịch sử nhỉ. Khái niệm regex được bắt đầu đưa ra từ những năm 1950 khi mà nhà toán học người Mỹ Stephen Cole Kleene chính thức mô tả một ngôn ngữ chính quy Khái niệm này được sử dụng phổ biến trong các tiện ích xử lý văn bản Unix. Sau đấy, từ những năm 1980, tồn tại các cú pháp khác nhau để tạo ra các biểu thức chính quy. Các chuẩn được đưa ra và sử dụng rộng rãi nhất là cú pháp Perl Mỗi lần mình tìm hiểu xong một thời gian không dùng đến, lúc quay lại đọc đều có cảm giác như mới :). 3. Công dụngRegex được sử dụng với rất nhiều mục đích khác nhau nhưng thường được dùng nhiều với mục đích đối sánh văn bản và kiểm tra cú pháp trong các trình biên tập văn bản và các tiện ích tìm kiếm và xử lý văn bản dựa trên các mẫu được quy định. Ví dụ: Nếu bạn muốn tạo bộ lọc và muốn loại bỏ dữ liệu là những trang web mà người khác tạo ra, bạn có thể sử dụng biểu thức chính quy để loại trừ bất kỳ dữ liệu nào từ toàn bộ dải địa chỉ IP người khác sử dụng. Giả sử các địa chỉ IP đó có dải từ 198.51.100.1 - 198.51.100.25. Thay vì nhập 25 địa chỉ IP khác nhau, bạn có thể tạo biểu thức chính quy như 198.51.100.\\d* để đối sánh với toàn bộ dải địa chỉ. 4. Cách dùngCác kí tự đặc biệtBảng 4.1 Các kí tự đặc biệt trong biểu thức chính quy. Kí tự (kí hiệu, cờ) Ý nghĩa \\ Tìm với luật dưới đây: Một dấu gạch chéo ngược sẽ biến một kí tự thường liền kế phía sau thành một kí tự đặc biệt, tức là nó không được sử dụng để tìm kiếm thông thường nữa. Ví dụ, trường hợp kí tự ‘b’ không có dấu gạch chéo ngược này sẽ được khớp với các kí tự ‘b’ in thường, nhưng khi nó có thêm dấu gạch chéo ngược, ‘\\b’ thì nó sẽ không khớp với bất kì kí tự nào nữa, lúc này nó trở thành kí tự đặc biệt. Xem thêm phần word boundary character để biết thêm chi tiết. Tuy nhiên nếu đứng trước một kí tự đặc biệt thì nó sẽ biến kí tự này thành một kí tự thường, tức là bạn có thể tìm kiếm kí tự đặc biệt này trong xâu chuỗi của bạn như các kí tự thường khác. Ví dụ, mẫu /a/ có ‘’ là kí tự đặc biệt và mẫu này sẽ bị phụ thuộc vào kí tự này, nên được hiểu là sẽ tìm khớp với 0 hoặc nhiều kí tự a. Nhưng, với mẫu /a/ thì kí tự ‘’ lúc này được hiểu là kí tự thường nên mẫu này sẽ tìm kiếm xâu con là ‘a*’. Đừng quên \\ cũng là một kí tự đặc biệt, khi cần so khớp chính nó ta cũng phải đánh dấu nó là kí tự đặc biệt bằng cách đặt \\ ở trước (). ^ Khớp các kí tự đứng đầu một chuỗi. Nếu có nhiều cờ này thì nó còn khớp được cả các kí tự đứng đầu của mỗi dòng (sau kí tự xuống dòng). Ví dụ, /^A/ sẽ không khớp được với ‘A’ trong “an A” vì ‘A’ lúc này không đứng đầu chuỗi, nhưng nó sẽ khớp “An E” vì lúc này ‘A’ đã đứng đầu chuỗi. Ý nghĩa của ‘^’ sẽ thay đổi khi nó xuất hiện như một kí tự đầu tiên trong một lớp kí tự, xem phần complemented character sets để biết thêm chi tiết. $ So khớp ở cuối chuỗi. Nếu gắn cờ multiline (đa dòng), nó sẽ khớp ngay trước kí tự xuống dòng.Ví dụ, /t$/ không khớp với ‘t’ trong chuỗi “eater” nhưng lại khớp trong chuỗi “eat”. * Cho phép kí tự trước nó lặp lại 0 lần hoặc nhiều lần. Tương đương với cách viết {0,}.Ví dụ, /bo*/ khớp với ‘boooo’ trong chuỗi “A ghost booooed” nhưng không khớp trong chuỗi “A birth warbled”. + Cho phép kí tự trước nó lặp lại 1 lần hoặc nhiều lần. Tương đương với cách viết {1,}.Ví dụ, /a+/ khớp với ‘a’ trong chuỗi “candy” và khớp với tất cả kí tự a liền nhau trong chuỗi “caaaaaaandy”. ? Cho phép kí tự trước nó lặp lại 0 lần hoặc 1 lần duy nhất. Tương đương với cách viết {0,1}.Ví dụ, /e?le?/ khớp với ‘el’ trong chuỗi “angel” và ‘le’ trong chuỗi “angle” hay ‘l’ trong “oslo”.Nếu sử dụng kí tự này ngay sau bất kì kí tự định lượng nào trong số *,+,? hay {}, đều làm bộ định lượng “chán ăn” (dừng so khớp sau ngay khi tìm được kí tự phù hợp), trái ngược với đức tính “tham lam” vốn sẵn của chúng (khớp tất cả kí tự chúng tìm thấy). Ví dụ, áp dụng biểu mẫu /\\d+/ cho “123abc” ta được “123”. Nhưng áp /\\d+?/ cho chính chuỗi trên ta chỉ nhận được kết quả là “1”.Bạn có thể đọc thêm trong mục x(?=y) và x(?!y) của bảng này. . Dấu . khớp với bất kì kí tự đơn nào ngoại trừ kí tự xuống dòng.Ví dụ, /.n/ khớp với ‘an’ và ‘on’ trong chuỗi “no, an apple is on the tree”, nhưng không khớp với ‘no’. (x) Khớp ‘x’ và nhớ kết quả so khớp này, như ví dụ ở dưới. Các dấu ngoặc tròn được gọi là các dấu ngoặc có nhớ.Biểu mẫu /(foo) (bar) \\1 \\2/ khớp với ‘foo’ và ‘bar’ trong chuỗi “foo bar foo bar”. \\1 và \\2 trong mẫu khớp với 2 từ cuối.Chú ý rằng \\1, \\2, \\n được sử dụng để so khớp các phần trong regex, nó đại diện cho nhóm so khớp đằng trước. Ví dụ: /(foo) (bar) \\1 \\2/ tương đương với biểu thức /(foo) (bar) foo bar/. Cú pháp $1, $2, $n còn được sử dụng trong việc thay thế các phần của một regex. Ví dụ: ‘bar foo’.replace(/(…) (…)/, ‘$2 $1’) sẽ đảo vị trí 2 từ ‘bar’ và ‘foo’ cho nhau. (?:x) Khớp ‘x’ nhưng không nhớ kết quả so khớp. Những dấu ngoặc tròn được gọi là những dấu ngoặc không nhớ, nó cho phép bạn định nghĩa những biểu thức con cho những toán tử so khớp. Xem xét biểu thức đơn giản /(?:foo){1,2}/. Nếu biểu thức này được viết là /foo{1,2}/, {1,2} sẽ chỉ áp dụng cho kí tự ‘o’ ở cuối chuỗi ‘foo’. Với những dấu ngoặc không nhớ, {1,2} sẽ áp dụng cho cả cụm ‘foo’. x(?=y) Chỉ khớp ‘x’ nếu ‘x’ theo sau bởi ‘y’.Ví dụ, /Jack(?=Sprat)/ chỉ khớp với ‘Jack’ nếu đằng sau nó là ‘Sprat’. /Jack(?=Sprat x(?!y) Chỉ khớp ‘x’ nếu ‘x’ không được theo sau bởi ‘y’.Ví dụ: /\\d+(?!.)/ chỉ khớp với số không có dấu . đằng sau. Biểu thức /\\d+(?!.)/.exec(“3.141”)​ cho kết quả là ‘141’ mà không phải ‘3.141’. x y {n} Kí tự đứng trước phải xuất hiện n lần. n phải là một số nguyên dương.Ví dụ, /a{2}/ không khớp với ‘a’ trong “candy”, nhưng nó khớp với tất cả kí tự ‘a’ trong “caandy”, và khớp với 2 kí tự ‘a’ đầu tiên trong “caaandy”. {n,m} Kí tự đứng trước phải xuất hiện từ n đến m lần. n và m là số nguyên dương và n &lt;= m. Nếu m bị bỏ qua, nó tương đương như ∞.Ví dụ, /a{1,3}/ không khớp bất kì kí tự nào trong “cndy”, kí tự ‘a’ trong “candy”, 2 kí tự ‘a’ đầu tiên trong “caandy”, và 3 kí tự ‘a’ đầu tiên trong “caaaaaaandy”. Lưu ý là “caaaaaaandy” chỉ khớp với 3 kí tự ‘a’ đầu tiên mặc dù chuỗi đó chứa 7 kí tự ‘a’. [xyz] Lớp kí tự. Loại mẫu này dùng để so khớp với một kí tự bất kì trong dấu ngoặc vuông, bao gồm cả escape sequences. Trong lớp kí tự, dấu chấm (.) và dấu hoa thị (*) không còn là kí tự đặc biệt nên ta không cần kí tự thoát đứng trước nó. Bạn có thể chỉ định một khoảng kí tự bằng cách sử dụng một kí tự gạch nối (-) như trong ví dụ dưới đây:Mẫu [a-d] so khớp tương tự như mẫu [abcd], khớp với ‘b’ trong “brisket” và ‘c’ trong “city”. Mẫu /[a-z.]+/ và /[\\w.]+/ khớp với toàn chuỗi “test.i.ng”. [^xyz] Lớp kí tự phủ định. Khi kí tự ^ đứng đầu tiên trong dấu ngoặc vuông, nó phủ định mẫu này.Ví dụ, [^abc] tương tự như [^a-c], khớp với ‘r’ trong “brisket” và ‘h’ trong “chop” là kí tự đầu tiên không thuộc khoảng a đến c. [\\b] Khớp với kí tự dịch lùi - backspace (U+0008). Bạn phải đặt trong dấu ngoặc vuông nếu muốn so khớp một kí tự dịch lùi. (Đừng nhầm lẫn với mẫu \\b). \\b Khớp với kí tự biên. Kí tự biên là một kí tự giả, nó khớp với vị trí mà một kí tự không được theo sau hoặc đứng trước bởi một kí tự khác. Tương đương với mẫu (^\\w \\B Khớp với kí tự không phải kí tự biên. Mẫu này khớp tại vị trí mà kí tự trước và kí tự sau nó cùng kiểu: hoặc cả hai là kí tự hoặc cả hai không phải là kí tự. Bắt đầu và kết thúc chuỗi không được xem là những kí tự.Ví dụ, /\\B../ khớp với ‘oo’ trong “noonday”, và /y\\B./ khớp với ‘ye’ trong “possibly yesterday.” \\cX X là một kí tự trong khoảng A tới Z. Mẫu này khớp với một kí tự điều khiển trong một chuỗi.Ví dụ: /\\cM/ khớp với control-M (U+000D) trong chuỗi. \\d Khớp với một kí tự số. Tương đương với mẫu [0-9].Ví dụ: /\\d/ hoặc /[0-9]/ khớp với ‘2’ trong chuỗi “B2 is the suite number.” \\D Khớp với một kí tự không phải là kí tự số. Tương đương với mẫu [^0-9].Ví dụ; /\\D/ hoặc /[^0-9]/ khớp với ‘B’ trong “B2 is the suite number.” \\f Khớp với kí tự phân trang - form feed (U+000C). \\n Khớp với kí tự xuống dòng - line feed (U+000A). \\r Khớp với kí tự quay đầu dòng - carriage return (U+000D). \\s Khớp với một kí tự khoảng trắng, bao gồm trống - space, tab, phân trang - form feed, phân dòng - line feed. Tương đương với [ \\f\\n\\r\\t\\v​\\u00a0\\u1680​\\u180e\\u2000​\\u2001\\u2002​\\u2003\\u2004​\\u2005\\u2006​\\u2007\\u2008​\\u2009\\u200a​\\u2028\\u2029​​\\u202f\\u205f​\\u3000].Ví dụ: /\\s\\w*/ khớp với ‘ bar’ trong “foo bar.” \\S Khớp với một kí tự không phải khoảng trắng. Tương đương với [^ \\f\\n\\r\\t\\v​\\u00a0\\u1680​\\u180e\\u2000​\\u2001\\u2002​\\u2003\\u2004​\\u2005\\u2006​\\u2007\\u2008​\\u2009\\u200a​\\u2028\\u2029​\\u202f\\u205f​\\u3000].Ví dụ: /\\S\\w*/ khớp với ‘foo’ trong chuỗi “foo bar.” \\t Khớp với kí tự tab (U+0009). \\v Khớp với kí tự vertical tab (U+000B). \\w Khớp với tất cả kí tự là chữ, số và gạch dưới. Tương đương với mẫu [A-Za-z0-9_].Ví dụ, /\\w/ khớp với ‘a’ trong “apple,” ‘5’ trong “$5.28,” và ‘3’ trong “3D.” \\W Khớp với tất cả kí tự không phải là chữ. Tương đương với mẫu [^A-Za-z0-9_].Ví dụ, /\\W/ hoặc /[^A-Za-z0-9_]/ khớp với ‘%’ trong “50%.” \\n Trong đó, n là một số nguyên dương, một tham chiếu ngược tới chuỗi khớp thứ n trong biểu thức (đếm từ trái sang, bắt đầu bằng 1).Ví dụ, /apple(,)\\sorange\\1/ hay /apple(,)\\sorange,/ khớp với ‘apple, orange,’ trong chuỗi “apple, orange, cherry, peach.” \\0 Khớp với kí tự NULL (U+0000). Lưu ý: không được thêm bất kì một kí tự số nào sau 0, vì \\0 là một biểu diễn hệ bát phân escape sequence. \\xhh Khớp với kí tự với mã code là hh (2 số trong hệ thập lục phân) \\uhhhh Khớp với kí tự có mã hhhh (4 số trong hệ thập lục phân). Làm việc với biểu thức chính quyBảng 4.2 Những phương thức được sử dụng trong biểu thức chính quy Phương thức Mô tả exec Một phương thức của RegExp dùng để tìm kiếm chuỗi phù hợp với mẫu so khớp. Nó trả về một mảng chứa kết quả tìm kiếm. test Một phương thức của RegExp dùng để kiểm tra mẫu có khớp với chuỗi hay không. Nó trả về giá trị true hoặc false. match Một phương thức của chuỗi dùng để tìm kiếm chuỗi phù hợp với mẫu so khớp. Nó trả về một mảng chứa kết quả tìm kiếm hoặc null nếu không tìm thấy. search Một phương thức của chuỗi dùng để tìm kiếm chuỗi phù hợp với mẫu so khớp và trả về vị trí của chuỗi đó hoặc -1 nếu không tìm thấy. replace Một phương thức của chuỗi dùng để tìm kiếm một chuỗi theo mẫu so khớp và thay thế chuỗi con được khớp với một chuỗi thay thế. split Một phương thức của chuỗi dùng một biểu mẫu chính quy hoặc một chuỗi bất biến để ngắt chuỗi đó thành một mảng các chuỗi con. Ví dụMã hóa escapse chuỗi người dùng nhập vào bằng một hàm thay thế đơn giản sử dụng biểu thức chính quy: 123function escapeRegExp(string)&#123; return string.replace(/[.*+?^$&#123;&#125;()|[\\]\\\\]/g, \"\\\\$&amp;\");&#125; Bạn có thể sử dụng trang web Regex101.com , dán một đoạn regex vào đấy, nó sẽ giải thích đoạn mã đấy làm gì. Lưu ýGiữ biểu thức chính quy của bạn đơn giản. Regex đơn giản giúp người dùng khác hiểu và sửa đổi dễ dàng hơn. Biểu thức chính quy về bản chất đối sánh rất nhiều dữ liệu: nếu bạn không chỉ định cho regex biết không nên đối sánh dữ liệu nào, chúng sẽ đối sánh với những gì bạn chỉ định và bất kỳ ký tự liền kề nào. Ví dụ: site đối sánh với mysite, yoursite, theirsite, parasite–bất kỳ chuỗi có chứa “site”. Nếu bạn cần thực hiện đối sánh cụ thể, hãy thiết lập cấu trúc regex của bạn cho phù hợp. Ví dụ: nếu bạn chỉ cần đối sánh với chuỗi “site”, hãy thiết lập cấu trúc regex của bạn để “site” vừa là bắt đầu chuỗi vừa là kết thúc chuỗi: ^site$. 5. Tham khảoAnalytics Trợ giúpNguồn N.T.Giáp - Kaopiz","categories":[],"tags":[{"name":"regex","slug":"regex","permalink":"http://nthung2112.github.io/tags/regex/"}]},{"title":"Học Regular Expression và cuộc đời bạn sẽ bớt khổ","slug":"Hoc-Regular-Expression-va-cuoc-doi-ban-se-bot-kho","date":"2018-04-25T08:27:00.000Z","updated":"2018-04-30T08:06:42.792Z","comments":true,"path":"2018/04/Hoc-Regular-Expression-va-cuoc-doi-ban-se-bot-kho.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Hoc-Regular-Expression-va-cuoc-doi-ban-se-bot-kho.html","excerpt":"Regular Expression (RegEx) à? Nghe quen quen.","text":"Regular Expression (RegEx) à? Nghe quen quen. Đã bao giờ bạn ở vào các tính huống sau đây? Bạn cần xử lý validate (kiểm tra tính hợp lệ) các trường dữ liệu nhập vào ô Text Bạn cần copy và paste rất nhiều text từ chỗ này sang chỗ kiaVí dụ từ XML sang C# hoặc CSV, Excel sang C# Tìm kiếm một chuỗi nằm ở nhiều dòng trong Visual Studio hoặc Notepad++Ví dụ tôi cần tìm và xóa bỏ (replace all) các comment như thế này ở code cũ. Bạn cần bóc tách dữ liệu của một trang web.Ví dụ extract (crawling) tách lấy dữ liệu từ một trang web để lưu lại vào cơ sở dữ liệu của bạn Cơn ác mộng đọc một chuỗi string từ DB và cố gắng chuyển đổi nó sang DateTimeChuỗi ngày tháng lưu vào CSDL rất đa dạng. Rất khó để dùng hàm DateTime.TryParse() để tự động chuyển đổi một chuỗi thành Datetime ngon lành cành đào. Tìm kiếm một chuỗi, lưu chuỗi đó lại và lấy chuỗi đã lưu chèn vào chỗ nào đóHay nói cách khác, ta cần thay một chuỗi bằng một chuỗi khác, trong chuỗi mới đó lại có chứa cả chuỗi vừa bị thay thế. Như ví dụ dưới đây sẽ cho các bạn thấy. Ta cần tìm ra ClassName, nhưng không phải thay thế ClassName đó bằng Class khác mà ta sẽ nhét nó vào 2 vị trí thay vì chỉ có 1 vị trí như hiện tại. Vậy RegEx có thể giúp gì cho chúng ta trong các trường hợp trên?Regular Expression sinh ra là để giúp cho cuộc đời của bạn bớt khổ. Hãy tưởng tượng xem bạn phải nai lưng ra copy-paste bao nhiêu code. Bạn hoàn toàn có thể download các tool về để replace giúp bạn. Nhưng bạn cần bao nhiêu tool cho đủ đây. Thay vào đó, bạn hãy thử học RegEx. Bộ cú pháp này sẽ giúp cho bạn thao tác với chuỗi như dao chém chuối. Như ta thấy các ví dụ bên trên, tất cả đều là XỬ LÝ CHUỖI ví dụ Cut Copy Paste hoặc Replace chuỗi. RegEx là ngôn ngữ giúp xử lý chuỗi rất mạnh. RegEx không phải là một ngôn ngữ lập trình. Nó chỉ là một BỘ CÚ PHÁP dùng để bắt chuỗi. Nhưng nó cực kỳ phổ biến và bất kỳ ngôn ngữ lập trình nào cũng hỗ trợ. Nó có cả trăm ngàn ứng dụng và công cụ ăn theo. Hãy lần lượt xem qua các ví dụ sau đây để học cách sử dụng Regular Expression nhé. Bắt đầu sử dụng Regular ExpressionĐể bắt đầu sử dụng và học cách dùng RegEx, mình hay dùng trang web https://regex101.com/. Giao diện như sau: Trước hết các bạn hãy đọc qua một lượt các quy tắc bắt chuỗi (matching) đơn giản nhất của RegEx [xyz] Tìm và so sánh tất cả ký tự nằm trong dấu ngoặc vuông và trùng khớp với 1 ký tự trong dấu ngoặc vuông. Ví dụ: [31] sẽ trùng khớp với 3 hoặc 1, [0123456789] sẽ trùng khớp với bất kỳ một ký tự nào trong khoảng từ 0 đến 9. [a-z] So sánh và trùng khớp với một ký tự nằm trong khoảng chỉ định. Ví dụ: [a-z] sẽ trùng khớp với một ký tự trong khoảng từ a đến z nằm trong chuỗi cần test. [0-9] sẽ trùng khớp với bất kỳ một ký tự nào trong khoảng từ 0 đến 9. [^xyz] So sánh và không trùng khớp với những ký tự nằm trong khoảng chỉ định. Dấu ^ (dấu mũ) nằm trong dấu ngoặc vuông là một dấu phủ định. Ví dụ: [^a-z] sẽ không trùng khớp với tất cả các ký tự nằm trong khoảng từ a đến z. ^ Trùng khớp với phần đầu của chuỗi đích. Ví dụ: ^a sẽ trùng khớp với chữ a trong chuỗi abc, ^\\w+ sẽ trùng khớp với chữ đầu tiên – chữ “the” của chuỗi “The quick brown fox jumps over the lazy dog”. $ Trùng khớp với phần cuối của chuỗi đích. Ví dụ: c$ sẽ trùng khớp với chữ c trong chuỗi abc, \\w+$ sẽ trùng khớp với chữ cuối – chữ “dog” của chuỗi “The quick brown fox jumps over the lazy dog”. Trùng khớp với 1 hoặc nhiều lần ký tự đứng trước nó. Ví dụ \\d+ sẽ chỉ trùng với chuỗi có từ 1 con số trở lên. Trùng khớp với 0 hoặc nhiều lần ký tự đứng trước nó. Ví dụ \\d* sẽ trùng với chuỗi có chứa 1 chữ số hoặc k có chữ số nào cũng đc. ? Trùng khớp với 0 hoặc 1 lần ký tự đứng trước nó. Tương tự như nhưng nó lại chỉ nhân lên 1 lần. thì nhân lên nhiều lần. . Trùng khớp với 1 ký tự đơn bất kỳ ngoại trừ ký tự ngắt dòng (line-break) và cũng không lấy được ký tự có dấu (unicode). Ví dụ: . sẽ trùng khớp với ký tự a hoặc b hoặc c trong chuỗi abc. Nhưng . sẽ không bắt được các chữ ă hoặc ê. x{n} Trùng khớp đúng với n lần ký tự đứng trước nó. n là một số không âm. Ví dụ \\d{2} sẽ bắt đc các số có 2 chữ số đứng liền nhau. x{n,} Trùng khớp với ít nhất n lần ký tự đứng trước nó. n là một số không âm.Ví dụ \\d{2,} sẽ bắt đc các số có từ 2 chữ số trở lên đứng liền nhau. x{n,m} Trùng khớp với ít nhất n lần và nhiều nhất là m lần ký tự đứng trước nó. n và m là một số không âm và n &lt;= m. Ví dụ: a{1,3} sẽ khớp với hah, haah, haaah nhưng không khớp với haaaah. x|y Trùng khớp với x hoặc y. Ví dụ: slow|fast sẽ khớp với chữ slow hoặc fast trong chuỗi đích. \\b Trùng khớp với toàn bộ ký tự đứng trước nó. Ví dụ: hello\\b sẽ trùng khớp với toàn bộ từ hello trong chuỗi hello world nhưng sẽ không khớp với chuỗi helloworld. \\B Ngược lại với \\b, \\B sẽ không khớp với toàn bộ mà chỉ 1 phần ký tự đứng trước nó. Ví dụ: hello\\B sẽ trùng khớp với chữ hello trong chuỗi helloworld nhưng sẽ không khớp với chuỗi hello world. \\d Trùng khớp 1 ký tự số (digit). \\D Trùng khớp 1ký tự không phải số (non-digit). \\s Trùng khớp 1 ký tự khoảng trắng (whitespace) bao gồm khoảng trắng tạo ra bởi phím Tab. \\S Trùng khớp với 1 ký tự không phải là khoảng trắng (non-whitespace). \\w Trùng khớp với các ký tự là từ (word) bao gồm dấu _ (underscore) và chữ số. \\W Trùng khớp với các ký tự không phải là từ (non-word). Ví dụ: \\W sẽ khớp với ký tự % trong chuỗi “100%”. \\uxxxx Trùng khớp với 1 ký tự unicode. Ví dụ: \\u00FA sẽ khớp với ký tự “ú”, \\u00F9 sẽ khớp với ký tự “ù”. \\pL Trùng khớp với một ký tự Unicode bất kỳ ngoại trừ dấu cách. Đây chính là cú pháp viết hoàn hảo hơn của dấu .,Ví dụ \\pL+ sẽ lấy được chuỗi truyền, thuyết trong chuỗi “truyền thuyết”. Đừng lo, hãy xem qua các ví dụ từ từ rồi bạn sẽ hiểu Ví dụ đơn giảnTìm chuỗi số Tìm ngày tháng Link demo: https://regex101.com/r/3dNzjU/1 Tìm ngày tháng chính xácTrong ví dụ trên thì ta thấy có chuỗi “60/60/2018” cũng được coi là ngày tháng, như thế là không chính xác. Ta hãy viết lại cho chuẩn. Link demo: https://regex101.com/r/3dNzjU/2 Cách “tóm lấy” string cần tìm đưa vào Group Cách tạo ra code để dùng RegEx trong các ngôn ngữ lập trìnhRegEx là bộ cú pháp, tuy nhiên để áp dụng nó vào các ngôn ngữ lập trình lại phải tuân thủ theo các thư viện và quy tắc lập trình để lấy ra được các Group đã capture (thu) được. Hãy xem các tạo code ngay sau đây: Cách bắt lấy chuỗi bất kỳ Link demo: https://regex101.com/r/3dNzjU/3 Sử dụng RegEx trong thực tếTrong thực tế RegEx có thể được gõ trực tiếp ở bất kỳ trình Editor nào. Ví dụ mình hay dùng Notepad++, hoặc Visual Studio Tham khảoTham khảo thêm toàn bộ cú pháp RegEx bằng tiếng Anh tại: https://www.cheatography.com/davechild/cheat-sheets/regular-expressions/ Một số công cụ test RegEx Online https://regex101.com/ http://regexr.com/ http://www.regexpal.com/ http://regexper.com/ Bài tập về nhàBạn ngứa tay muốn thử học RegEx ngay và luôn cho nóng. Vậy hãy thử thực hành bằng một số bài tập từ dễ đến khó sau đây nhé. Bài tập nhập môn: Lấy ra các chữ có chữ test trong chuỗi sau: “that tested test is testing the tester’s tests” Lấy ra các số điện thoại trong chuỗi sau: “p:444-555-1234 f:246.555.8888 m:1235554567” Lấy ra các mã màu RGB trong chuỗi sau: “#FF006C ABC 99AAB7FF 0xF0F73611” Lấy ra các chữ có 4 ký tự trong chuỗi sau: “drink beer, it’s very nice!” Lấy ra tên file trong chuỗi URL sau: “rapidshare.com/asd/asd/File.avi.html” Đáp án ở phần comment nhé. Bài tập dành cho học sinh giỏi (lớp học thêm) Tìm cách lấy các URL trong chuỗi HTML sau: 1234567Lorem gyum&lt;b&gt;Betrag&lt;/b&gt; von &lt;a href=\"http://www.vektor.de\"&gt;Vektoren&lt;/a&gt;(Länge eines Vektors)&lt;a href=\"gcfa.com\"&gt;GCFA&lt;/a&gt; &lt;a href=\"//cdn.com/test.js\"&gt;CDN&lt;/a&gt; ist das Maß einer Menge sozu… Tìm cách loại bỏ toàn bộ COMMENT trong đoạn code sau: 123456789var sample = 0; var my_string = \"Hello World!\"; // This is a comment! function do_stuff()&#123; // This is another comment! alert(‘somethings’);/* this is a multiline comment */&#125; Tìm cách lấy ra chuỗi tiếng Nhật trong chuỗi sau: “ 1This is a demo story 前に来た時は北側からで、当時の光景はいまでも思い出せる。And it is true. Lấy ra những file ảnh và độ phân giải của ảnh từ chuỗi sau: 12345678.bash_profileworkspace.docimg0912.jpg (1280x720)updated_img0912.png (1024x768)documentation.htmlfavicon.gif img0912.jpg (1920x1600)access.htaccess Đọc nội dung từ trang tin rss sau: http://rss.cnn.com/rss/edition.rss Lấy ra các Tiêu đề, ngày giờ đăng, nội dung tin vắn Đáp án các bạn post vào phần comment và cùng trao đổi nhé. Nếu các bài tập trên đây vẫn chưa đủ, các bạn hãy làm thêm các bài tập tại trang https://regexone.com nhé, rất nhiều ví dụ hay. Kết luậnHi vọng bài viết nhỏ này đã giúp bạn học được cú pháp viết RegEx và áp dụng vào công việc thường ngày. Mình dùng Regex rất nhiều và nó là trợ thủ đắc lực trong quá trình code. Các bạn thì sao? bạn đã dùng Regex vào những việc gì? Hãy kể tên bên dưới comment để mình cùng học hỏi với nhé. Thanks các bạn đã đọc!","categories":[],"tags":[{"name":"regex","slug":"regex","permalink":"http://nthung2112.github.io/tags/regex/"}]},{"title":"Tìm hiểu Higher-Order Function (HOF) và Currying qua một số ví dụ","slug":"Tim-hieu-Higher-Order-Function-HOF-va-Currying-qua-mot-so-vi-du-3","date":"2018-04-03T04:20:00.000Z","updated":"2018-05-18T01:02:21.693Z","comments":true,"path":"2018/04/Tim-hieu-Higher-Order-Function-HOF-va-Currying-qua-mot-so-vi-du-3.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Tim-hieu-Higher-Order-Function-HOF-va-Currying-qua-mot-so-vi-du-3.html","excerpt":"HOF và Currying là hai kỹ thuật không khó, thậm chí có thể bạn đang dùng nó hàng ngày mà không để ý. Cùng tìm hiểu chúng thông qua một số ví dụ. BackgroundTôi cho rằng một kỹ sư phần mềm pro không phải là người viết ra những dòng code đánh đố người đọc hay đồng nghiệp, mà là người viết những dòng code mà khi người khác đọc nó liền cảm thấy trong sáng, dễ hiểu, dễ bảo trì. Cũng như sự tiến hóa của con người, khi mà “ăn no, ăn sạch rồi ăn ngon”, thì coding cũng có slogan tương tự: “chạy được, chạy đúng, sau cùng là chạy nhanh”.Vậy, sau khi chạy được và chạy đúng rồi, chúng ta nên suy nghĩ xem ngoài việc có thể chạy nhanh hơn ko, thì đoạn code này đã sáng sủa chưa? Nếu bị/được sửa thì có dễ ko? HOF và Currying là 2 trong số ti tỉ kỹ thuật nhằm giúp chúng ta, những lập trình viên huyền thoại, đạt được tiêu chí trên.","text":"HOF và Currying là hai kỹ thuật không khó, thậm chí có thể bạn đang dùng nó hàng ngày mà không để ý. Cùng tìm hiểu chúng thông qua một số ví dụ. BackgroundTôi cho rằng một kỹ sư phần mềm pro không phải là người viết ra những dòng code đánh đố người đọc hay đồng nghiệp, mà là người viết những dòng code mà khi người khác đọc nó liền cảm thấy trong sáng, dễ hiểu, dễ bảo trì. Cũng như sự tiến hóa của con người, khi mà “ăn no, ăn sạch rồi ăn ngon”, thì coding cũng có slogan tương tự: “chạy được, chạy đúng, sau cùng là chạy nhanh”.Vậy, sau khi chạy được và chạy đúng rồi, chúng ta nên suy nghĩ xem ngoài việc có thể chạy nhanh hơn ko, thì đoạn code này đã sáng sủa chưa? Nếu bị/được sửa thì có dễ ko? HOF và Currying là 2 trong số ti tỉ kỹ thuật nhằm giúp chúng ta, những lập trình viên huyền thoại, đạt được tiêu chí trên.Trước khi đi vào khái niệm cụ thể, chúng ta cùng xem ví dụ dưới đây: Ví dụ 1Nhóc con nhà bạn nhờ bạn tìm những số tự nhiên khác 0 nhỏ hơn 20 và là số lẻ.Là một ông bố mẫu mực với niềm kiêu hãnh nhiều năm kinh nghiệm fixed hàng trăm bug nhỏ và tạo ra hàng tá bug to, bạn muốn viết một chương trình hoành tráng để lấy le với con mình. Ok, you win!.Dưới đây chắc hẳn là đoạn code đầu tiên xuất hiện trong đầu: 1234567891011function pickOddNumbers(maximum) &#123; const result = []; for (let i = 1; i &lt;= maximum; i += 1) &#123; if (i % 2 === 1) result.push(i); &#125; return result;&#125;pickOddNumbers(20); Nhưng đời không bao giờ là mơ, khi hôm sau nhóc con lại mếu máo: “Cô giáo cho thêm bài: Tìm những số tự nhiên khác 0 nhỏ hơn 20 mà nếu gấp 3 số đó rồi từ đi 2 thì thu được số chẵn.”.Bố chiều cô luôn. Vậy là bạn lại cho ra phiên bản mới: 1234567891011function pickSpecialNumbers(maximum) &#123; const result = []; for (let i = 1; i &lt;= maximum; i += 1) &#123; if (((i * 3) - 2) % 2 === 0) result.push(i); &#125; return result;&#125;pickSpecialNumbers(20); Đời vẫn ko như mơ khi cô giáo lại cho thêm bài tập: “Tìm những số tự nhiên khác 0 nhỏ hơn 20 mà nếu lấy phần dư số đó cho 9 rồi cộng thêm 2 thì thu số lẻ.”Ơ cô giáo từ từ, để bố em sửa function bên trên đã :)))) Cứ như vậy, mỗi lần cô giáo cho thêm yêu cầu là bạn lại phải sửa phiên bản cũ hoặc cho ra một bản mới, tuy yêu cầu khác nhau nhưng xử lý cơ bản là giống nhau, chỉ khác ở đoạn xử lý điều kiện cho số được chọn.Và bạn chợt nhớ tới HOF, một ứng cử viên sáng giá cho việc làm đoạn code trên sạch hơn, gọn hơn, dễ sửa hơn. Định nghĩa HOFTheo wikipedia thì: 1234A higher-order function (also functional, functional form or functor) is a function that does at least one of the following:・takes one or more functions as arguments,・returns a function as its result. Vietsub: 123HOF là một function mà cho phép thực hiện ít nhất 1 trong 2 khả năng sau:・Nhận vào một hoặc nhiều function như là tham số, hoặc/và・Trả về kết quả là một function. // Bạn có thể thấy có rất nhiều ngôn ngữ hỗ trợ HOF ở link wiki trên. Đến Java còn hỗ trợ nữa là :v Trăm nghe không bằng một thấy, trăm thấy không bằng một sờ, và chúng ta lại cùng sờ với ví dụ bên trên.Lần này là bản nâng cấp có giá trị về mặt học thuật, vì được áp dụng HOF vào cơ mà :))) 12345678910111213141516171819function pickNumbers(maximum, pickingCondition) &#123; const result = []; for (let i = 1; i &lt;= maximum; i += 1) &#123; if (pickingCondition(i)) result.push(i); &#125; return result;&#125;// Chọn ra những số lẻpickNumbers(20, function(number) &#123; return number % 2 === 1;&#125;);// Chọn ra những số mà gấp 3 số đó rồi trừ đi 2 thu số chẵnpickNumbers(20, function(number) &#123; return ((number * 3) - 2) % 2 === 0;&#125;); Với việc đưa HOF vào function bên trên, giờ thì cô giáo thích gì cũng chiều được nhé,chỉ cần thay đổi function kiểm tra điều kiện vào thôi, ko cần phải copy thành function mới nữa. Định nghĩa CurryingLại theo wikipedia: 123Currying is the technique of translating the evaluation of a functionthat takes multiple arguments (or a tuple of arguments)into evaluating a sequence of functions, each with a single argument. Vietsub: 123Currying là kỹ thuật mà cho phép chuyển đổi một function với nhiều tham sốthành những functions liên tiếp có một tham số.// Ví dụ f(a,b,c) có thể được convert thành g(a)h(b, c) hay g(a)h(b)k(c), thậm chí là đổi thứ tự của các function tương ứng... Vậy dễ dàng nhận thấy Currying là một trường hợp của HOF, vì nó thỏa mãn điều kiện trả về kết quả là một function. Cụ thể áp dụng cho ví dụ trên, có thể viết thành dạng sau: 123456789101112131415161718192021function pickNumbers(maximum) &#123; return function (pickingCondition) &#123; const result = []; for (let i = 1; i &lt;= maximum; i += 1) &#123; if (pickingCondition(i)) result.push(i); &#125; return result; &#125;;&#125;// Chọn ra những số lẻpickNumbers(20)(function (number) &#123; return number % 2 === 1;&#125;);// Chọn ra những số mà gấp 3 số đó rồi trừ đi 2 thu số chẵnpickNumbers(20)(function (number) &#123; return (number * 3 - 2) % 2 === 0;&#125;); So sánh ví dụ áp dụng Currying này với ví dụ sử dụng HOF ở trên, rõ ràng là ta chưa thấy sự ưu việt của Currying so với HOF, thậm chí còn thấy hơi rườm rà nữa.Tuy nhiên, hãy cùng xem xét ví dụ dưới đây: Ví dụ 2Viết một function lấy ra giá trị của một key của object, được chọn ra từ một mảng các objects với điều kiện. Đơn giản vậy thôi, nên việc cài đặt cũng có vẻ là đơn giản. Với HOF: 123456789101112function getValue(objects, key, pickingCondition) &#123; var object = null; for (var i = 0; i &lt; objects.length; i++) &#123; if (pickingCondition(objects[i])) &#123; object = objects[i]; break; &#125; &#125; return object ? object[key] : null;&#125;; Mỗi khi gọi function với key khác nhau, hẳn là sẽ phải gọi kiểu như vầy: 12var valueByKey1 = getValue(objects, 'key1', pickingCondition);var valueByKey2 = getValue(objects, 'key2', pickingCondition); Nếu như coi key là biết trước, chỉ thay đổi objects và pickingCondition, thì việc áp dụng Currying là hợp lý: 12345678910111213141516171819202122function getValue(key) &#123; return function (objects, pickingCondition) &#123; let object = null; for (let i = 0; i &lt; objects.length; i++) &#123; if (pickingCondition(objects[i])) &#123; object = objects[i]; break; &#125; &#125; return object ? object[key] : null; &#125;;&#125;;// Wrap getValue thành những function ngắn hơn với tên sáng nghĩa:var getValueByKey1 = getValue('key1');var getValueByKey2 = getValue('key2');// Sử dụng:var valueByKey1 = getValueByKey1(objects, pickingCondition);var valueByKey2 = getValueByKey2(objects, pickingCondition); Khá là gọn gàng. // Ngoài lề: Nếu bạn làm việc với ReactJs, hẳn bạn đã biết tới thuật ngữ Higher-Order Component, hay các selectors mà redux-form cung cấp, thì chúng đều áp dụng kỹ thuật Currying này, cũng như HOF. Dưới đây là một vài ví dụ cho thấy tác dụng tốt của Currying: Ví dụ 3Viết function để kiểm tra độ dài của một xâu s có vượt quá n hay ko. 1234567891011// Cách 1: Không dùng Curryingfunction isLengthOver(s, n)&#123; return s.length &gt; n&#125;// Cách 2: Có Curryingfunction isLengthOver(n)&#123; return function(s)&#123; return s.length &gt; n; &#125;&#125; Giả sử cả 2 cách viết trên được sử dụng cho việc validate của một field trên form, với n = 10 thì có sự khác biệt như sau: Với cách 1: 1&lt;input type=\"text\" validate=&#123;value =&gt; isLengthOver(value, 10)&#125; /&gt; Với cách 2: 1&lt;input type=\"text\" validate=&#123;isLengthOver(10)&#125; /&gt; Quá khác bọt! Ví dụ 4Viết function hiển thị tên group mà một nhân viên đang làm việc, với: Input: employeeGroupId là id của group mà nhân viên đang làm việc, Mảng chứa toàn bộ groups có trong công ty. Điều kiện rằng buộc: Một group luôn có id khác null, Nếu groupB là group con của groupA, thì groupB sẽ có parentGroupId là id của groupA. Group không là con khi parentGroupId của nó là null, Không có quan hệ vòng tròn. (Kiểu: groupA là con groupB, groupB là con groupC, groupC là con groupA) Output: Full path của group mà nhân viên đang làm việc, phân cách bởi dấu /. Ví dụ Group A / Group B / Group C Chắc hẳn bạn sẽ nghĩ tới cách dùng vòng lặp, kiểm tra chừng nào còn tìm thấy group có id bằng parentGroupId. Và tôi cũng nghĩ vậy :D 1234567891011const getGroupFullPathName = (groups, employeeGroupId) =&gt; &#123; const groupNames = []; let group = groups.find(grp =&gt; grp.id === employeeGroupId); while (group) &#123; groupNames.unshift(group.name); group = groups.find(grp =&gt; grp.id === group.parentGroupId); &#125; return groupNames.join('/');&#125;; Nhưng đoạn code trên vẫn chưa ngon, do vi phạm rule Don’t make functions within a loop của ESLint.Cụ thể: Mỗi khi vòng while được chạy thì groups.find(grp =&gt; grp.id === group.parentGroupId) lại sinh ra một anonymous function, chính là grp =&gt; grp.id === group.parentGroupId. Cách khắc phục là ta viết một currying bên ngoài vòng while là được: 123456789101112const getGroupFullPathName = (groups, employeeGroupId) =&gt; &#123; const groupNames = []; const condition = parentGroupId =&gt; group =&gt; group.id === parentGroupId; let group = groups.find(grp =&gt; grp.id === employeeGroupId); while (group) &#123; groupNames.unshift(group.name); group = groups.find(condition(group.parentDepartmentId)); &#125; return groupNames.join('/');&#125;; Kết luận:Bài quá dài. // Nếu mấy ví dụ trên dùng cú pháp của es6 và dùng các api của Array thì sẽ ngắn hơn nhiều, nhưng lại khó nhìn rõ đâu là function được nhận vào/trả ra, nên các bạn chịu khó đọc với cú pháp cơ bản vậy :D","categories":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"hof","slug":"hof","permalink":"http://nthung2112.github.io/tags/hof/"}]},{"title":"CSS Grid vs Flexbox sử dụng như thế nào","slug":"CSS-Grid-vs-Flexbox-su-dung-nhu-the-nao","date":"2018-03-25T13:52:00.000Z","updated":"2018-03-25T07:39:52.137Z","comments":true,"path":"2018/03/CSS-Grid-vs-Flexbox-su-dung-nhu-the-nao.html","link":"","permalink":"http://nthung2112.github.io/2018/03/CSS-Grid-vs-Flexbox-su-dung-nhu-the-nao.html","excerpt":"Tìm hiểu cách chúng khác nhau, và khi bạn nên sử dụng nó.CSS Flexbox đã trở nên cực kỳ quen thuộc với các lập trình viên front-end trong vài năm gần đây. Điều này không đáng ngạc nhiên, bởi vì nó giúp chúng ta tạo ra các bố cục động (dynamic layout) và sắp xếp nội dung trong các container dễ dàng hơn rất nhiều. Tuy nhiên, có một mô-đun mới gọi là CSS Grid và nó có nhiều khả năng giống như Flexbox. Trong một vài trường hợp nó tốt hơn so với Flexbox, và một số trường hợp khác thì không. Điều này có vẻ gây nhầm lẫn cho các lập trình viên. Vì vậy, bài viết này sẽ so sánh hai mô-đun, cả mức độ vi mô và vĩ mô.","text":"Tìm hiểu cách chúng khác nhau, và khi bạn nên sử dụng nó.CSS Flexbox đã trở nên cực kỳ quen thuộc với các lập trình viên front-end trong vài năm gần đây. Điều này không đáng ngạc nhiên, bởi vì nó giúp chúng ta tạo ra các bố cục động (dynamic layout) và sắp xếp nội dung trong các container dễ dàng hơn rất nhiều. Tuy nhiên, có một mô-đun mới gọi là CSS Grid và nó có nhiều khả năng giống như Flexbox. Trong một vài trường hợp nó tốt hơn so với Flexbox, và một số trường hợp khác thì không. Điều này có vẻ gây nhầm lẫn cho các lập trình viên. Vì vậy, bài viết này sẽ so sánh hai mô-đun, cả mức độ vi mô và vĩ mô. Một chiều vs hai chiềuNếu bạn rút ra một bài học từ bài viết này, thì đây là nó: Flexbox được tạo ra cho các bố cục một chiều và Grid được tạo ra cho các bố cục hai chiều. Điều này có nghĩa là nếu bạn đang đặt các item theo một hướng (ví dụ ba nút bên trong header), thì bạn nên sử dụng Flexbox: Nó sẽ linh hoạt hơn CSS Grid. Và cũng dễ dàng hơn để bảo trì và yêu cầu mã ít hơn. Tuy nhiên nếu bạn định tạo bố cục theo hai chiều - với cả các hàng và các cột - thì bạn nên sử dụng CSS Grid: Trong trường hợp này, CSS Grid sẽ linh hoạt hơn, làm cho code của bạn đơn giản hơn và dễ bảo trì hơn. Tất nhiên bạn có thể kết hợp cả hai. Trong ví dụ ở trên, giải pháp hoàn hảo là sử dụng Grid cho việc bố cục trang, và sau đó dùng Flexbox để sắp xếp nội dung bên trong header. Điều này sẽ cung cấp cho bạn những chức năng tốt nhất của cả hai mô-đun. Content-first vs layout-firstMột khác biệt quan trọng nữa giữa 2 mô-đun là Flexbox tập trung vào nội dung trong khi Grid tập trung vào bố cục. Điều này có vẻ trừu tượng, vì vậy hãy xem một ví dụ cụ thể, nó sẽ dễ hiểu hơn. Chúng ta sẽ sử dụng header. Đây là code HTML cho nó: 12345&lt;header&gt; &lt;div&gt;Home&lt;/div&gt; &lt;div&gt;Search&lt;/div&gt; &lt;div&gt;Logout&lt;/div&gt;&lt;/header&gt; Trước khi chúng ta style nó với Flexbox, các div này sẽ được xếp chồng lên nhau như thế này: Flexbox headerTuy nhiên, khi chúng ta style nó với display: flex; các item sẽ được đặt trên một dòng. 123header &#123; display: flex;&#125; Để di chuyển nút logout sang phía bên phải, chúng ta chỉ cần chọn phần tử đó và style với margin: 123header &gt; div:nth-child(3) &#123; margin-left: auto;&#125; Kết quả sẽ như thế này: Cái tôi muốn bạn để ý ở đây là chúng ta để các item tự quyết định vị trí của mình. Chúng ta không phải xác định trước bất cứ điều gì khác ngoài display: flex;. Đây là khác biệt chính giữa Flexbox và Grid, và nó sẽ trở nên rõ ràng hơn khi chúng ta tạo header này bằng cách sử dụng Grid. Mặc dù CSS Grid không được tạo ra cho header một chiều, nhưng vẫn là một ý hay khi làm điều này vì nó dạy cho chúng ta về sự khác biệt cốt lõi giữa Flexbox và Grid. Grid headerChúng ta có thể tạo header theo nhiều cách khác nhau với CSS Grid. Tôi sẽ sử dụng một cách khá đơn giản, trong đó grid của chúng ta có mười cột. 1234header &#123; display: grid; grid-template-columns: repeat(10, 1fr);&#125; Nó sẽ giống hệt với giải pháp Flexbox. Tuy nhiên, chúng ta có thể sử dụng Chrome inspector để kiểm tra các dòng cột: Sự khác biệt chính với cách tiếp cận này là chúng ta phải xác định các cột - bố cục - đầu tiên. Chúng ta bắt đầu với việc xác định chiều rộng của các cột, và sau đó chúng ta đặt nội dung vào các ô có sẵn trong grid. Cách tiếp cận này buộc chúng ta phải xác định số lượng cột mà chúng ta muốn chia trong header. Trừ khi thay đổi grid, còn không chúng ta luôn có 10 cột. Một hạn chế mà chúng ta sẽ không phải đối mặt trong Flexbox. Để thay đổi logout sang phía bên tay phải, chúng ta sẽ đặt nó vào cột thứ mười, như sau: 123header &gt; div:nth-child(3) &#123; grid-column: 10;&#125; Dùng Chrome inspector chúng ta sẽ thấy: Chúng ta không thể chỉ đơn giản style nó với margin-left: auto; vì nút logout đã được đặt trong một ô cụ thể trong bố cục, trong cột thứ ba. Để di chuyển nó, chúng ta phải tìm một ô khác cho nó. Kết hợp cả haiBây giờ chúng ta hãy xem cách kết hợp cả hai, sát nhập header vào bố cục trang web. Chúng ta sẽ bắt đầu bằng cách xây dựng bố cục trang web. Đây là HTML: 123456&lt;div class=\"container\"&gt; &lt;header&gt;HEADER&lt;/header&gt; &lt;aside&gt;MENU&lt;/aside&gt; &lt;main&gt;CONTENT&lt;/main&gt; &lt;footer&gt;FOOTER&lt;/footer&gt;&lt;/div&gt; Đây là CSS: 12345.container &#123; display: grid; grid-template-columns: repeat(12, 1fr); grid-template-rows: 50px 350px 50px;&#125; Chúng ta sẽ đặt các item trên grid như sau: 12345678910111213header &#123; grid-column: span 12;&#125;aside &#123; grid-column: span 2;&#125;main &#123; grid-column: span 10;&#125;footer &#123; grid-column: span 12;&#125; Tiếp theo, chúng ta sẽ chỉ cần thêm style cho header. Chúng ta sẽ biến header - một item trong CSS Grid - thành một Flexbox container. 123header &#123; display: flex;&#125; Chúng ta có thể thiết lập nút logout sang bên phải: 123header &gt; div:nth-child(3) &#123; margin-left: auto;&#125; Kết quả, chúng ta có một bố cục hoàn hảo sử dụng những tính năng tốt nhất từ cả Grid và Flexbox. Hai container sẽ trông như thế này: Bây giờ, bạn đã hiểu rõ sự khác biệt nói chung và cụ thể giữa Flexbox và Grid, và biết cách sử dụng chúng cùng với nhau. Trình duyệt hỗ trợTrước khi kết thúc, tôi cũng cần đề cập đến các trình duyệt hỗ trợ CSS Grid. Vào thời điểm này (25/03/2018), 84.14% website toàn cầu hỗ trợ CSS Grid, và nó đang tăng dần. Tôi tin năm 2018 sẽ là năm của CSS Grid. Nó sẽ đột phá, và sẽ trở thành một kỹ năng phải có của các lập trình viên front-end. Giống như những gì đã xảy ra với CSS Flexbox trong vài năm gần đây.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"flexbox","slug":"flexbox","permalink":"http://nthung2112.github.io/tags/flexbox/"},{"name":"grid","slug":"grid","permalink":"http://nthung2112.github.io/tags/grid/"}]},{"title":"Một số thủ thuật Chrome DevTools có thể bạn đã biết","slug":"Mot-so-thu-thuat-Chrome-DevTools-co-the-ban-da-biet","date":"2018-03-25T07:54:00.000Z","updated":"2018-03-25T15:14:28.961Z","comments":true,"path":"2018/03/Mot-so-thu-thuat-Chrome-DevTools-co-the-ban-da-biet.html","link":"","permalink":"http://nthung2112.github.io/2018/03/Mot-so-thu-thuat-Chrome-DevTools-co-the-ban-da-biet.html","excerpt":"1. Drag-and-drop in the Elements panelIn the Elements panel, you can drag and drop any HTML element and change its position across the page","text":"1. Drag-and-drop in the Elements panelIn the Elements panel, you can drag and drop any HTML element and change its position across the page 2. Reference the currently selected element in the ConsoleSelect a node in the Elements panel, and type $0 in the console to reference it. If you’re using jQuery, you can enter $($0) to access the jQuery API on this element. 3. Use the value of the last operation in the ConsoleUse $_ to reference the return value of the previous operation executed in the Console 4. Add CSS and edit the element stateIn the Elements panel there are two super useful buttons. The first lets you add a new CSS property with any selector you want, but pre-filling the currently selected element: The second one lets you trigger a state for the selected element, so you can see the styles applied when it’s active, hovered, or on focus. 5. Save to file the modified CSSClick the name of the CSS file that you edited. The inspector opens it into the Sources pane, and from there you can save it with the live edits you applied. This trick does not work for new selectors added using +, or into the element.style properties, but only for modified, existing ones. 6. Screenshot a single elementSelect an element and press cmd-shift-p (or ctrl-shift-p in Windows) to open the Command Menu, and select Capture node screenshot 7. Find an element using CSS selectorsPressing cmd-f (ctrl-f in Windows) opens the search box in the Elements panel. You can type any string in there to match the source code, or you can also use CSS selectors to have Chrome generate an image for you: 8. Shift-enter in the ConsoleTo write commands that span over multiple lines in the Console, press shift-enter. Once you’re ready, press enter at the end of the script to execute it: You can clear the console using the Clear button on the top-left of the console, or by pressing ctrl-l or cmd-k. 9. Go to…In the Sources panel: cmd-o (ctrl-o in Windows), shows all the files loaded by your page. cmd-shift-o (ctrl-shift-o in Windows) shows the functions (or classes) in the current file. cmd-l (ctrl-l in Windows) goes to a specific line. 10. Watch ExpressionInstead of writing again and again a variable name or an expression you are going to check a lot during a debug session, add it to the Watch Expression list. 11. XHR/Fetch debuggingFrom the debugger open the XHR/Fetch Breakpoints panel. You can set it to break any time a XHR/Fetch call is sent, or just on specific ones: 12. Debug on DOM modificationsRight-click an element and enable Break on Subtree Modifications. Whenever a script traverses that element’s children and modifies them, the debugger stops automatically to let you inspect what’s happening.","categories":[{"name":"Tips","slug":"Tips","permalink":"http://nthung2112.github.io/categories/Tips/"}],"tags":[{"name":"tips","slug":"tips","permalink":"http://nthung2112.github.io/tags/tips/"},{"name":"chorme","slug":"chorme","permalink":"http://nthung2112.github.io/tags/chorme/"}]},{"title":"Kiến thức cho phỏng vấn Javascript developer","slug":"Kien-thuc-cho-phong-van-Javascript-developer","date":"2018-01-02T15:12:14.000Z","updated":"2018-03-25T04:12:04.733Z","comments":true,"path":"2018/01/Kien-thuc-cho-phong-van-Javascript-developer.html","link":"","permalink":"http://nthung2112.github.io/2018/01/Kien-thuc-cho-phong-van-Javascript-developer.html","excerpt":"JavaScript is the most popular programming language and has been since 2014, according to Stack Overflow Survey. It is no wonder that over 1/3rd of all developer jobs require some JavaScript knowledge. So, if you plan to work as a developer in the near future, you should be familiar with this extremely popular language. The post’s purpose is to bring together all JavaScript concepts that are frequently brought up in developer interviews. It was written so you can review everything you need to know about JavaScript in a single place.","text":"JavaScript is the most popular programming language and has been since 2014, according to Stack Overflow Survey. It is no wonder that over 1/3rd of all developer jobs require some JavaScript knowledge. So, if you plan to work as a developer in the near future, you should be familiar with this extremely popular language. The post’s purpose is to bring together all JavaScript concepts that are frequently brought up in developer interviews. It was written so you can review everything you need to know about JavaScript in a single place. Types &amp; CoercionThere are 7 built-in types: null, undefined , boolean, number, string, object and symbol (ES6). All of these are types are called primitives, except for object. Null vs. Undefined Undefined is the absence of a definition. It is used as the default value for uninitialized variables, function arguments that were not provided and missing properties of objects. Functions return undefined when nothing has been explicitly returned. Null is the absence of a value. It is an assignment value that can be assigned to a variable as a representation of ‘no-value’. Implicit coercion Take a look at the following example: In this case, the string variable name is coerced to true and you have ‘Joey doesn’t share food!’ printed in our console. But how do you know what will be coerced to true and what will be coerced to false? Falsy values are values that will be coerced to false when forced a boolean coercion on it. Falsy values: “”, 0, null, undefined, NaN, false. Anything not explicitly on the falsy list is truthy —boolean coerced to true. Yes. You read it right. Empty arrays, objects and functions are boolean coerced to true! String &amp; Number coercion The first thing you need to be aware of is the + operator. This is a tricky operator because it works for both number addition and string concatenation. But, the *, /, and - operators are exclusive for numeric operations. When these operators are used with a string, it forces the string to be coerced to a number. == vs. === It is widely spread that == checks for equality and === checks for equality and type. Well, that is a misconception. In fact, == checks for equality with coercion and === checks for equality without coercion — strict equality. Coercion can be tricky. Take a look at the following code: What would you expect for the following comparison?console.log(a == b); (1) This comparison actually returns True. Why?What really happens under the hood is that if you are comparing a boolean with something other than a boolean, JavaScript coerces that boolean to a number and compares. (2) This comparison is now between a number and a string. JavaScript now coerces that string to a number and compares both numbers. (3) In this case, the final comparison 0 == 0 is True. 123'0' == false (1)'0' == 0 (2) 0 == 0 (3) For a fully comprehension on how such comparisons are performed, you can check ES5 documentation here. For a cheat sheet, you can click here. Some tricky comparisons to look out for: Value vs. ReferenceSimple values (also known as primitives) are always assigned by value-copy: null, undefined , boolean, number, string and ES6 symbol. Compound values always create a copy of the reference on assignment: objects, which includes arrays, and functions. To copy a compound value by value, you need to makea copy of it. The reference does not point to the original value. Scop_e_Scope refers to the execution context. It defines the accessibility of variables and functions in the code. Global Scope is the outermost scope. Variables declared outside a function are in the global scope and can be accessed in any other scope. In a browser, the window object is the global scope. Local Scope is a scope nested inside another function scope. Variables declared in a local scope are accessible within this scope as well as in any inner scopes. You may think of Scopes as a series of doors decreasing in size (from biggest to smallest). A short person that fits through the smallest door — innermost scope — also fits through any bigger doors — outer scopes. A tall person that gets stuck on the third door, for example, will have access to all previous doors — outer scopes — but not any further doors — inner scopes. HoistingThe behavior of “moving” var and function declarations to the top of their respective scopes during the compilation phase is called hoisting. Function declarations are completely hoisted. This means that a declared function can be called before it is defined. Variables are partially hoisted. var declarations are hoisted but not its assignments. let and const are not hoisted. Function Expression vs. Function Declaration Function Expression A Function Expression is created when the execution reaches it and is usable from then on — it is not hoisted. Function Declaration A Function Declaration can be called both before and after it was defined — it is hoisted. Variables: var, let and constBefore ES6, it was only possible to declare a variable using var. Variables and functions declared inside another function cannot be accessed by any of the enclosing scopes — they are function-scoped. Variables declared inside a block-scope, such as if statements and for loops, can be accessed from outside of the opening and closing curly braces of the block. Note: An undeclared variable — assignment without var, let or const — creates a var variable in global scope. ES6 let and const are new. They are not hoisted and block-scoped alternatives for variable declaration. This means that a pair of curly braces define a scope in which variables declared with either let or const are confined in. A common misconception is that const is immutable. It cannot be reassigned, but its properties can be changed! ClosureA closure is the combination of a function and the lexical environment from which it was declared. Closure allows a function to access variables from an enclosing scope — environment — even after it leaves the scope in which it was declared. The above example covers the two things you need to know about closures: Refers to variables in outer scope.The returned function access themessage variable from the enclosing scope. It can refer to outer scope variables even after the outer function has returned.sayHiToJon is a reference to the greeting function, created when sayHi was run. The greeting function maintains a reference to its outer scope — environment — in which message exists. One of the main benefits of closures is that it allows data encapsulation. This refers to the idea that some data should not be directly exposed. The following example illustrates that. By the time elementary is created, the outer function has already returned. This means that the staff variable only exists inside the closure and it cannot be accessed otherwise. Let’s go deeper into closures by solving one of the most common interview problems on this subject:What is wrong with the following code and how would you fix it? Considering the above code, the console will display four identical messages “The value undefined is at index: 4”. This happens because each function executed within the loop will be executed after the whole loop has completed, referencing to the last value stored in i, which was 4. This problem can be solved by using IIFE, which creates a unique scope for each iteration and storing each value within its scope. Another solution would be declaring the i variable with let, which creates the same result. Immediate Invoked Function Expression (IIFE)An IIFE is a function expression that is called immediately after you define it. It is usually used when you want to create a new variable scope. The (surrounding parenthesis) prevents from treating it as a function declaration. The final parenthesis() are executing the function expression. On IIFE you are calling the function exactly when you are defining it. Using IIFE: Enables you to attach private data to a function. Creates fresh environments. Avoids polluting the global namespace. ContextContext is often confused as the same thing as Scope. To clear things up, lets keep the following in mind:Context is most often determined by how a function is invoked. It always refers to the value of this in a particular part of your code.Scope refers to the visibility of variables. Function calls: call, apply and bindAll of these three methods are used to attach thisinto function and the difference is in the function invocation. .call() invokes the function immediately and requires you to pass in arguments as a list (one by one). .apply() invokes the function immediately and allows you to pass in arguments as an array. .call() and .apply() are mostly equivalent and are used to borrow a method from an object. Choosing which one to use depends on which one is easier to pass the arguments in. Just decide whether it’s easier to pass in an array or a comma separated list of arguments. Quick tip: Apply for Array — Call for Comma. Note: If you pass in an array as one of the arguments on a call function, it will treat that entire array as a single element.ES6 allows us to spread an array as arguments with the call function. 1char.knows.call(Snow, ...[\"nothing\", \"Jon\"]); // You know nothing, Jon Snow .bind() returns a new function, with a certain context and parameters. It is usually used when you want a function to be called later with a certain context. That is possible thanks to its ability to maintain a given context for calling the original function. This is useful for asynchronous callbacks and events. .bind() works like the call function. It requires you to pass in the arguments one by one separated by a comma. ‘this’ keywordUnderstanding the keyword thisin JavaScript, and what it is referring to, can be quite complicated at times. The value of thisis usually determined by a functions execution context. Execution context simply means how a function is called. The keyword thisacts as a placeholder, and will refer to whichever object called that method when the method is actually used. The following list is the ordered rules for determining this. Stop at the first one that applies: new binding — When using the new keyword to call a function, thisis the newly constructed object. Explicit binding — When call or apply are used to call a function, thisis the object that is passed in as the argument.Note: .bind() works a little bit differently. It creates a new function that will call the original one with the object that was bound to it. Implicit binding — When a function is called with a context (the containing object), thisis the object that the function is a property of.This means that a function is being called as a method. Default binding — If none of the above rules applies, thisis the global object (in a browser, it’s the window object).This happens when a function is called as a standalone function.A function that is not declared as a method automatically becomes a property of the global object. Note: This also happens when a standalone function is called from within an outer function scope. Lexical this — When a function is called with an arrow function =&gt;, thisreceives the thisvalue of its surrounding scope at the time it’s created.thiskeeps the value from its original context. Strict ModeJavaScript is executed in strict mode by using the “use strict” directive. Strict mode tightens the rules for parsing and error handling on your code. Some of its benefits are: Makes debugging easier — Code errors that would otherwise have been ignored will now generate errors, such as assigning to non-writable global or property. Prevents accidental global variables — Assigning a value to an undeclared variable will now throw an error. Prevents invalid use of delete — Attempts to delete variables, functions and undeletable properties will now throw an error. Prevents duplicate property names or parameter values — Duplicated named property in an object or argument in a function will now throw an error. (This is no longer the case in ES6) Makes eval() safer — Variables and functions declared inside an eval() statement are not created in the surrounding scope. “Secures” JavaScript eliminating this coercion — Referencing a this value of null or undefined is not coerced to the global object. This means that in browsers it’s no longer possible to reference the window object using this inside a function. new keywordThe new keyword invokes a function in a special way. Functions invoked using the new keyword are called constructor functions. So what does the new keyword actually do? Creates a new object. Sets the object’s prototypeto be the prototypeof the constructor function. Executes the constructor function with this as the newly created object. Returns the created object. If the constructor returns an object, this object is returned. What is the difference between invoking a function with the new keyword and without it? Prototype and InheritancePrototype is one of the most confusing concepts in JavaScript and one of the reason for that is because there are two different contexts in which the word prototype is used. Prototype relationship Each object has a prototypeobject, from which it inherits all of its prototype’s properties..proto is a non-standard mechanism (available in ES6) for retrieving the prototypeof an object (*). It points to the object’s “parent” —the object’s prototype.All normal objects also inherit a .constructor property that points to the constructor of the object. Whenever an object is created from a constructor function, the .proto property links that object to the .prototype property of the constructor function used to create it.(*) _Object.getPrototypeOf()_is the standard ES5 function for retrieving the prototype of an object. Prototype property Every function has a .prototype property.It references to an object used to attach properties that will be inherited by objects further down the prototype chain. This object contains, by default, a .constructor property that points to the original constructor function.Every object created with a constructor function inherits a constructor property that points back to that function. Prototype ChainThe prototype chain is a series of links between objects that reference one another. When looking for a property in an object, JavaScript engine will first try to access that property on the object itself. If it is not found, the JavaScript engine will look for that property on the object it inherited its properties from — the object’s prototype. The engine will traverse up the chain looking for that property and return the first one it finds. The last object in the chain is the built-in Object.prototype, which has null as its prototype. Once the engine reaches this object, it returns undefined. Own vs Inherited PropertiesObjects have own properties and inherited properties. Own properties are properties that were defined on the object. Inherited properties were inherited through prototype chain. Object.create(obj) — Creates a new object with the specified prototypeobject and properties. Inheritance by referenceAn inherited property is a copy by reference of the prototype object’sproperty from which it inherited that property. If an object’s property is mutated on the prototype, objects which inherited that property will share the same mutation. But if the property is replaced, the change will not be shared. Classical Inheritance vs. Prototypal InheritanceIn classical inheritance, objects inherit from classes — like a blueprint or a description of the object to be created — and create sub-class relationships. These objects are created via constructor functions using the new keyword. The downside of classical inheritance is that it causes:inflexible hierarchytight coupling problemsfragile base class problemsduplication problemsAnd the so famous gorilla/banana problem — “What you wanted was a banana, what you got was a gorilla holding the banana, and the entire jungle.” In prototypal inheritance, objects inherit directly from other objects. Objects are typically created via Object.create(), object literals or factory functions. There are three different kinds of prototypal inheritance: Prototype delegation — A delegate prototype is an object which is used as a model for another object. When you inherit from a delegate prototype, the new object gets a reference to the prototype and its properties.This process is usually accomplished by using Object.create(). Concatenative inheritance — The process of inheriting properties from one object to another by copying the object’s prototype properties, without retaining a reference between them.This process is usually accomplished by using Object.assign(). Functional inheritance — This process makes use of a factory function(*) to create an object, and then adds new properties directly to the created object.This process has the benefit of allowing data encapsulation via closure.(*)Factory function is a function that is not a class or constructor that returns an object without using the new keyword. You can find a complete article on this topic by Eric Elliott here. Favor composition over class inheritanceMany developers agree that class inheritance should be avoided in most cases. In this pattern you design your types regarding what they are, which makes it a very strict pattern. Composition, on the other hand, you design your types regarding what they do, which makes it more flexible and reusable. Here is a nice video on this topic by Mattias Petter Johansson Asynchronous JavaScriptJavaScript is a single-threaded programming language. This means that the JavaScript engine can only process a piece of code at a time. One of its main consequences is that when JavaScript encounters a piece of code that takes a long time to process, it will block all code after that from running. JavaScript uses a data structure that stores information about active functions named Call Stack. A Call Stack is like a pile of books. Every book that goes into that pile sits on top of the previous book. The last book to go into the pile will be the first one removed from it, and the first book added to the pile will be the last one removed. The solution to executing heavy pieces of code without blocking anything is asynchronous callback functions. These functions are executed later — asynchronously. The asynchronous process begins with an asynchronous callback functions placed into a Heap or region of memory. You can think of the Heap as an Event Manager. The Call Stack asks the Event Manager to execute a specific function only when a certain event happens. Once that event happens, the Event Manager moves the function to the Callback Queue. Note: When the Event Manager handles a function, the code after that is not blocked and JavaScript continues its execution. The Event Loop handles the execution of multiple pieces of your code over time. The Event Loop monitors the Call Stack and the Callback Queue. The Call Stack is constantly checked whether it is empty or not. When it is empty, the Callback Queue is checked if there is a function waiting to be invoked. When there is a function waiting, the first function in the queue is pushed into the Call Stack, which will run it. This checking process is called a ‘tick’ in the Event Loop. Let’s break down the execution of the following code to understand how this process works: Initially the Browser console is clear and the Call Stack and Event Manager are empty. first() is added to the Call Stack. console.log(“First message”) is added to the Call Stack. console.log(“First message”) is executed and the Browser console displays “First message”_._ console.log(“First message”) is removed from the Call Stack. first() is remove from the Call Stack. setTimeout(second, 0) is added to the Call Stack. setTimeout(second, 0) is executed and handled by the Event Manager. And after 0ms the Event Manager moves second() to the Callback Queue. setTimeout(second, 0) is now completed and removed from the Call Stack. third() is added to the Call Stack. console.log(“Third message”) is added to the Call Stack. console.log(“Third message”) is executed and the Browser console displays “Third message”_._ console.log(“Third message”) is removed from the Call Stack. Call Stack is now empty and the second() function is waiting to be invoked in the Callback Queue. The Event Loop moves second() from the Callback Queue to the Call Stack. console.log(“Second message”) is added to the Call Stack. console.log(“Second message”) is executed and the Browser console displays “Second message”. console.log(“Second message”) is removed from the Call Stack. second() is removed from the Call Stack. Note: The second() function is not executed after 0ms. The time you pass in to setTimeout function does not relate to the delay of its execution. The Event Manager will wait the given timebefore moving that function into the Callback Queue. Its execution will only take place on a future ‘tick’ in the Event Loop.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cải thiện tốc độ Web App với Tinder","slug":"Cai-thien-toc-do-Web-App-voi-Tinder","date":"2017-12-25T11:29:59.000Z","updated":"2018-03-24T03:25:31.654Z","comments":true,"path":"2017/12/Cai-thien-toc-do-Web-App-voi-Tinder.html","link":"","permalink":"http://nthung2112.github.io/2017/12/Cai-thien-toc-do-Web-App-voi-Tinder.html","excerpt":"Tinder recently swiped right on the web. Their new responsive Progressive Web App — Tinder Online — is available to 100% of users on desktop and mobile, employing techniques for JavaScript performance optimization, Service Workers for network resilience and Push Notifications for chat engagement. Today we’ll walk through some of their web perf learnings.","text":"Tinder recently swiped right on the web. Their new responsive Progressive Web App — Tinder Online — is available to 100% of users on desktop and mobile, employing techniques for JavaScript performance optimization, Service Workers for network resilience and Push Notifications for chat engagement. Today we’ll walk through some of their web perf learnings. Journey to a Progressive Web AppTinder Online started with the goal of getting adoption in new markets, striving to hit feature parity with V1 of Tinder’s experience on other platforms. The MVP for the PWA took 3 months to implement using React as their UI library and Redux for state management. The result of their efforts is a PWA that delivers the core Tinder experience in 10% of the data-investment costs for someone in a data-costly or data-scarce market: Comparing the data-investment for Tinder Online vs the native apps. It’s important to note that this isn’t comparing apples to apples, however. The PWA loads code for new routes on demand, and the cost of additional code is amortized over the lifetime of the application. Subsequent navigations still don’t cost as much data as the download of the app. Early signs show good swiping, messaging and session length compared to the native app. With the PWA: Users swipe more on web than their native apps Users message more on web than their native apps Users purchase on par with native apps Users edit profiles more on web than on their native apps Session times are longer on web than their native apps PerformanceThe mobile devices Tinder Online’s users most commonly access their web experience with include: Apple iPhone &amp; iPad Samsung Galaxy S8 Samsung Galaxy S7 Motorola Moto G4 Using the Chrome User Experience report (CrUX), we’re able to learn that the majority of users accessing the site are on a 4G connection: Note: Rick Viscomi recently covered CrUX on PerfPlanet and Inian Parameshwaran covered rUXt for better visualizing this data for the top 1M sites. Testing the new experience on WebPageTest and Lighthouse (using the Galaxy S7 on 4G) we can see that they’re able to load and get interactive in under 5 seconds: There is of course lots of room to improve this further on median mobile hardware (like the Moto G4), which is more CPU constrained: Tinder are hard at work on optimizing their experience and we look forward to hearing about their work on web performance in the near future. Performance OptimizationTinder were able to improve how quickly their pages could load and become interactive through a number of techniques. They implemented route-based code-splitting, introduced performance budgets and long-term asset caching. Route-level code-splittingTinder initially had large, monolithic JavaScript bundles that delayed how quickly their experience could get interactive. These bundles contained code that wasn’t immediately needed to boot-up the core user experience, so it could be broken up using code-splitting. It’s generally useful to only ship code users need upfront and lazy-load the rest as needed. To accomplish this, Tinder used React Router and React Loadable. As their application centralized all their route and rendering info a configuration base, they found it straight-forward to implement code splitting at the top level. In summary: React Loadable is a small library by James Kyle to make component-centric code splitting easier in React. Loadable is a higher-order component (a function that creates a component) which makes it easy to split up bundles at a component level. Let’s say we have two components “A” and “B”. Before code-splitting, Tinder statically imported everything (A, B, etc) into their main bundle. This was inefficient as we didn’t need both A and B right away: After adding code-splitting, components A and B could be loaded as and when needed. Tinder did this by introducing React Loadable, dynamic import() and webpack’s magic comment syntax (for naming dynamic chunks) to their JS: For “vendor” (library) chunking, Tinder used the webpack CommonsChunkPlugin to move commonly used libraries across routes up to a single bundle file that could be cached for longer periods of time: Next, Tinder used React Loadable’s preload support to preload potential resources for the next page on control component: Tinder also used Service Workers to precache all their route level bundles and include routes that users are most likely to visit in the main bundle without code-splitting. They’re of course also using common optimizations like JavaScript minification via UglifyJS: 12345678new webpack.optimize.UglifyJsPlugin(&#123; parallel: true, compress: &#123; warnings: false, screw_ie8: true &#125;, sourceMap: SHOULD_SOURCEMAP &#125;), ImpactAfter introducing route-based code-splitting their main bundle sizes went down from 166KB to 101KB and DCL improved from 5.46s to 4.69s: Long-term asset cachingEnsuring long-term caching of static resources output by webpack benefits from using [chunkhash] to add a cache-buster to each file. Tinder were using a number of open-source (vendor) libraries as part of their dependency tree. Changes to these libraries would originally cause the [chunkhash] to change and invalidate their cache. To address this, Tinder began defining a whitelist of external dependencies and splitting out their webpack manifest from the main chunk to improve caching. The bundle size is now about 160KB for both chunks. Preloading late-discovered resourcesAs a refresher, is a declarative instruction to the browser to load critical, late-discovered resources earlier on. In single-page applications, these resources can sometimes be JavaScript bundles. Tinder implemented support for to preload their critical JavaScript/webpack bundles that were important for the core experience. This reduced load time by 1s and first paint from 1000ms to about 500ms. Performance budgetsTinder adopted performance budgets for helping them hit their performance goals on mobile. As Alex Russell noted in “Can you afford it?: real-world performance budgets”, you have a limited headroom to deliver an experience when considering slow 3G connections being used on median mobile hardware. To get and stay interactive quickly, Tinder enforced a budget of ~155KB for their main and vendor chunks, asynchronous (lazily loaded) chunks are ~55KB and other chunks are ~35KB. CSS has a limit of 20KB. This was crucial to ensuring they were able to avoid regressing on performance. Webpack Bundle AnalysisWebpack Bundle Analyzer allows you to discover what the dependency graph for your JavaScript bundles looks like so you can discover whether there’s low-hanging fruit to optimize. Tinder used Webpack Bundle Analyzer to discover areas for improvement: Polyfills: Tinder are targeting modern browsers with their experience but also support IE11 and Android 4.4 and above. To keep polyfills &amp; transpiled code to a minimum, they use For polyfills, they use babel-preset-env and core-js. Slimmer use of libraries: Tinder replaced localForage with direct use of IndexedDB. Better splitting: Split out components from the main bundles which were not required for first paint/interactive Code re-use: Created asynchronous common chunks to abstract chunks used more than three times from children. CSS: Tinder also removed critical CSS from their core bundles (as they had shifted to server-side rendering and delivered this CSS anyway) Using bundle analysis led to also also taking advantage of Webpack’s Lodash Module Replacement Plugin. The plugin creates smaller Lodash builds by replacing feature sets of modules with noop, identity or simpler alternatives: Webpack Bundle Analyzer can be integrated into your Webpack config. Tinder’s setup for it looks like this: 12345678910plugins: [ new BundleAnalyzerPlugin(&#123; analyzerMode: 'server', analyzerPort: 8888, reportFilename: 'report.html', openAnalyzer: true, generateStatsFile: false, statsFilename: 'stats.json', statsOptions: null &#125;) The majority of the JavaScript left is the main chunk which is trickier to split out without architecture changes to Redux Reducer and Saga Register. CSS StrategyTinder are using Atomic CSS to create highly reusable CSS styles. All of these atomic CSS styles are inlined in the initial paint and some of the rest of the CSS is loaded in the stylesheet (including animation or base/reset styles). Critical styles have a maximum size of 20KB gzipped, with recent builds coming in at a lean &lt; 11KB. Tinder use CSS stats and Google Analytics for each release to keep track of what has changed. Before Atomic CSS was being used, average page load times were ~6.75s. After they were ~5.75s. Tinder Online also uses the PostCSS Autoprefixer plugin to parse CSS and add vendor prefixes based on rules from Can I Use: 12345678910111213141516new webpack.LoaderOptionsPlugin(&#123; options: &#123; context: paths.basePath, output: &#123; path: './' &#125;, minimize: true, postcss: [ autoprefixer(&#123; browsers: [ 'last 2 versions', 'not ie &lt; 11', 'Safari &gt;= 8' ] &#125;) ] &#125;&#125;), Runtime performanceDeferring non-critical work with requestIdleCallback()To improve runtime performance, Tinder opted to use requestIdleCallback() to defer non-critical actions into idle time. 1requestIdleCallback(myNonEssentialWork); This included work like instrumentation beacons. They also simplified some HTML composite layers to reduce paint count while swiping. Using requestIdleCallback() for their instrumentation beacons while swiping: before.. and after.. Dependency upgradesWebpack 3 + Scope Hoisting In older versions of webpack, when bundling each module in your bundle would be wrapped in individual function closures. These wrapper functions made it slower for your JavaScript to execute in the browser. Webpack 3 introduced “scope hoisting” — the ability to concatenate the scope of all your modules into one closure and allow for your code to have a faster execution time in the browser. It accomplishes this with the Module Concatenation plugin: 1new webpack.optimize.ModuleConcatenationPlugin() Webpack 3’s scope hoisting improved Tinder’s initial JavaScript parsing time for vendor chunk by 8%. React 16 React 16 introduced improvements that decreased React’s bundle size compared to previous versions. This was in part due to better packaging (using Rollup) as well as removing now unused code. By updating from React 15 to React 16, Tinder reduced the total gzipped size of their vendor chunk by ~7%. The size of react + react-dom used to be~50KB gzipped and is now just ~35KB. Thanks to Dan Abramov, Dominic Gannaway and Nate Hunzaker who were instrumental in trimming down React 16’s bundle size. Workbox for network resilience and offline asset cachingTinder also use the Workbox Webpack plugin for caching both their Application Shell and their core static assets like their main, vendor, manifest bundles and CSS. This enables network resilience for repeat visits and ensures that the application starts-up more quickly when a user returns for subsequent visits. OpportunitiesDigging into the Tinder bundles using source-map-explorer (another bundle analysis tool), there are additional opportunities for reducing payload size. Before logging in, components like Facebook Photos, notifications, messaging and captchas are fetched. Moving these away from the critical path could save up to 20% off the main bundle: Another dependency in the critical path is a 200KB Facebook SDK script. Dropping this script (which could be lazily loaded when needed) could shave 1 second off initial loading time. ConclusionsTinder are still iterating on their Progressive Web App but have already started to see positive results from the fruits of their labor. Check out Tinder.com and stay tuned for more progress in the near future! With thanks and congrats to Roderick Hsiao, Jordan Banafsheha, and Erik Hellenbrand for launching Tinder Online and their input to this article. Thanks to Cheney Tsai for his review. Related reading: A Pinterest PWA performance case study A Treebo React &amp; Preact performance case study Twitter Lite and high-performance PWAs at scale This article was cross-posted from Performance Planet. If you’re new to React, I’ve found React for Beginners a comprehensive starting point.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"JavaScript Start-up Performance","slug":"JavaScript-Start-up-Performance","date":"2017-12-16T07:46:39.000Z","updated":"2017-12-16T07:59:58.668Z","comments":true,"path":"2017/12/JavaScript-Start-up-Performance.html","link":"","permalink":"http://nthung2112.github.io/2017/12/JavaScript-Start-up-Performance.html","excerpt":"JavaScript Start-up PerformanceAs web developers, we know how easy it is to end up with web page bloat. But loading a webpage is much more than shipping bytes down the wire. Once the browser has downloaded our page’s scripts it then has to parse, interpret &amp; run them. In this post, we’ll dive into this phase for JavaScript, why it might be slowing down your app’s start-up &amp; how you can fix it. Historically, we just haven’t spent a lot of time optimizing for the JavaScript Parse/Compile step. We almost expect scripts to be immediately parsed and executed as soon as the parser hits a &lt;script&gt; tag. But this isn’t quite the case. Here’s a simplified breakdown of how V8 works: A simplified view of how V8 works. This is our idealized pipeline that we’re working towards. Let’s focus on some of the main phases.","text":"JavaScript Start-up PerformanceAs web developers, we know how easy it is to end up with web page bloat. But loading a webpage is much more than shipping bytes down the wire. Once the browser has downloaded our page’s scripts it then has to parse, interpret &amp; run them. In this post, we’ll dive into this phase for JavaScript, why it might be slowing down your app’s start-up &amp; how you can fix it. Historically, we just haven’t spent a lot of time optimizing for the JavaScript Parse/Compile step. We almost expect scripts to be immediately parsed and executed as soon as the parser hits a &lt;script&gt; tag. But this isn’t quite the case. Here’s a simplified breakdown of how V8 works: A simplified view of how V8 works. This is our idealized pipeline that we’re working towards. Let’s focus on some of the main phases. What slows our web apps from booting up?Parsing, Compiling and Executing scripts are things a JavaScript engine spends significant time in during start-up. This matters as if it takes a while, it can delay how soon users can interact with our site. Imagine if they can see a button but not click or touch it for multiple seconds. This can degrade the user experience. Parse &amp; Compile times for a popular website using V8’s Runtime Call Stats in Chrome Canary. Notice how a slow Parse/Compile on desktop can take far longer on average mobile phones. Start-up times matter for performance-sensitive code. In fact, V8 - Chrome’s JavaScript engine, spends a large amount of time parsing and compiling scripts on top sites like Facebook, Wikipedia and Reddit: The pink area (JavaScript) represents time spent in V8 and Blink’s C++, while the orange and yellow represent parse and compile. Parse and Compile have also been highlighted as a bottleneck by a number of large sites &amp; frameworks you may be using. Below are tweets from Facebook’s Sebastian Markbage and Google’s Rob Wormald: Sam Saccone calls out the cost of JS parse in ‘Planning for Performance’As we move to an increasingly mobile world, it’s important that we understand the time spent in Parse/Compile can often be 2–5x as long on phones as on desktop. Higher-end phones (e.g the iPhone or Pixel) will perform very differently to a Moto G4. This highlights the importance of us testing on representative hardware (not just high-end!) so our users’ experiences don’t suffer.Parse times for a 1MB bundle of JavaScript across desktop &amp; mobile devices of differing classes. Notice how close a high-end phone like an iPhone 7 is to perf on a Macbook Pro vs the performance as we go down the graph towards average mobile hardware.If we’re shipping huge bundles for our app, this is where endorsing modern bundling techniques likecode-splitting, tree-shaking and Service Worker caching can really make a huge difference. That said, even a small bundle, written poorly or with poor library choices can result in the main thread being pegged for a long time in compilation or function call times. It’s important to holistically measure and understand where our real bottlenecks are.### What Are JavaScript Parse &amp; Compile bottlenecks for the average website?“Buuuut, I’m not Facebook”, I hear you say dear, reader. “How heavy are Parse &amp; Compile times for average sites out in the wild?”, you might be asking. Let’s science this out!I spent two months digging into the performance of a large set of production sites (6000+) built with different libraries and frameworks — like React, Angular, Ember and Vue. Most of the tests were recently redone on WebPageTest so you can easily redo them yourself or dig into the numbers if you wish. Here are some insights.Apps became interactive in 8 seconds on desktop (using cable) and 16 seconds on mobile (Moto G4 over 3G)What contributed to this? Most apps spent an average of 4 seconds in start-up (Parse/Compile/Exec)..on desktop.On mobile, parse times were up to 36% higher than they were on desktop.Was everyone shipping huge JS bundles? Not as large as I had guessed, but there’s room for improvement. At the median, developers shipped 410KB of gzipped JS for their pages. This is in line with the 420KB over ‘average JS per page’ reported by the HTTPArchive. The worst offenders were sending anywhere up to 10MB of script down the wire. Oof.HTTPArchive stat: the average page ships down 420KB of JavaScriptScript size is important, but it isn’t everything. Parse and Compile times don’t necessarily increase linearly when the script size increases. Smaller JavaScript bundles generally do result in a faster load time (regardless of our browser, device &amp; network connection) but 200KB of our JS !== 200KB of someone else’s and can have wildly different parse and compile numbers.### Measuring JavaScript Parse &amp; Compile todayChrome DevToolsTimeline (Performance panel) &gt; Bottom-Up/Call Tree/Event Log will let us drill into the amount of time spent in Parse/Compile. For a more complete picture (like the time spent in Parsing, Preparsing or Lazy Compiling), we can turn on V8’s Runtime Call Stats. In Canary, this will be in Experiments &gt; V8 Runtime Call Stats on Timeline.Chrome Tracingabout:tracing — Chrome’s lower-level Tracing tool allows us to use the disabled-by-default-v8.runtime_stats category to get deeper insights into where V8 spends its time. V8 have a step-by-step guide on how to use this that was published just the other day.WebPageTestWebPageTest’s “Processing Breakdown” page includes insights into V8 Compile, EvaluateScript and FunctionCall time when we do a trace with the Chrome &gt; Capture Dev Tools Timeline enabled.We can now also get out the Runtime Call Stats by specifying disabled-by-default-v8.runtime_stats as a custom Trace category (Pat Meenan of WPT now does this by default!).For a guide on how to get the most out of this, see this gist I wrote up.User TimingIt’s possible to measure Parse times through the User Timing API as Nolan Lawson points out below: The third &lt;script&gt; here isn’t important, but it’s the first &lt;script&gt; being separate from the second (performance.mark() starting before the &lt;script&gt; has been reached) that is. This approach can be affected on subsequent reloads by V8’s preparser. This could be worked around by appending a random string to the end of the script, something Nolan does in his optimize-js benchmarks. I use a similar approach for measuring the impact of JavaScript Parse times using Google Analytics: A custom Google Analytics dimension for ‘parse’ allows me to measure JavaScript parse times from real users and devices hitting my pages in the wild. DeviceTiming Etsy’s DeviceTiming tool can help measure parse &amp; execution times for scripts in a controlled environment. It works by wrapping local scripts with instrumentation code so that each time our pages are hit from different devices (e.g laptops, phones, tablets) we can locally compare parse/exec. Daniel Espeset’s Benchmarking JS Parsing and Execution on Mobile Devices goes into more detail on this tool. What can we do to lower our JavaScript parse times today? Ship less JavaScript. The less script that requires parsing, the lower our overall time spent in the parse &amp; compile phases will be. Use code-splitting to only ship the code a user needs for a route and lazy load the rest. This probably is going to help the most to avoid parsing too much JS. Patterns like PRPL encourage this type of route-based chunking, now used by Flipkart, Housing.com and Twitter. Script streaming: In the past, V8 have told developers to use async/defer to opt into script streaming for parse-time improvements of between 10–20%. This allows the HTML parser to at least detect the resource early, push the work to the script streaming thread and not halt the document parsing. Now that this is done for parser-blocking scripts too, I don’t think there’s anything actionable we need to do here. V8 recommend loading larger bundles earlier on as there’s only one streamer thread (more on this later) Measure the parse cost of our dependencies, such as libraries and frameworks. Where possible, switch them out for dependencies with faster parse times (e.g switch React for Preact or Inferno, which require fewer bytes to bootup and have smaller parse/compile times). Paul Lewis covered framework bootup costs in a recent article. As Sebastian Markbage has also noted, a good way to measure start-up costs for frameworks is to first render a view, delete and then render again as this can tell you how it scales. The first render tends to warm up a bunch of lazily compiled code, which a larger tree can benefit from when it scales. If our JavaScript framework of choice supports an ahead-of-time compilation mode (AoT), this can also help heavily reduce the time spent in parse/compile. Angular apps benefit from this for example: Nolan Lawson’s ‘Solving the Web Performance Crisis’ What are browsers doing to improve Parse &amp; Compile times today?Developers are not the only ones to still be catching up on real-world start-up times being an area for improvement. V8 discovered that Octane, one of our more historical benchmarks, was a poor proxy for real-world performance on the 25 popular sites we usually test. Octane can be a poor proxy for 1) JavaScript frameworks (typically code that isn’t mono/polymorphic) and 2) real-page app startup (where most code is cold). These two use-cases are pretty important for the web. That said, Octane isn’t unreasonable for all kinds of workloads. The V8 team has been hard at work improving start-up time and we’ve already seem some wins here: We also estimate a 25% improve on V8 parse times for many pages looking at our Octane-Codeload numbers: And we’re seeing wins in this area for Pinterest too. There are a number of other explorations V8 has started over the last few years to improve Parsing and Compile times. Code caching From using V8’s code caching Chrome 42 introduced code caching — a way to store a local copy of compiled code so that when users returned to the page, steps like script fetching, parsing and compilation could all be skipped. At the time we noted that this change allowed Chrome to avoid about 40% of compilation time on future visits, but I want to provide a little more insight into this feature: Code caching triggers for scripts that are executed twice in 72 hours. For scripts of Service Worker: Code caching triggers for scripts that are executed twice in 72 hours. For scripts stored in Cache Storage via Service Worker: Code caching triggers for scripts in the first execution. So, yes. If our code is subject to caching V8 will skip parsing and compiling on the third load. We can play around with these in chrome://flags/#v8-cache-strategies-for-cache-storage to look at the difference. We can also run Chrome with — js-flags=profile-deserialization to see if items are being loaded from the code cache (these are presented as deserialization events in the log). One caveat with code caching is that it only caches what’s being eagerly compiled. This is generally only the top-level code that’s run once to setup global values. Function definitions are usually lazily compiled and aren’t always cached. IIFEs (for users of optimize-js ;)) are also included in the V8 code cache as they are also eagerly compiled. Script Streaming Script streaming allows async or defer scripts to be parsed on a separate background thread once downloading begins and improves page loading times by up to 10%. As noted earlier, this now also works for sync scripts. Since the feature was first introduced, V8 have switched over to allowing all scripts, even parser blocking &lt;script src=””&gt; to be parsed on a background thread so everyone should be seeing some wins here. The only caveat is that there’s only one streaming background thread and so it makes sense to put our large/critical scripts in here first. It’s important to measure for any potential wins here. Practically, &lt;script defer&gt; in the &lt;head&gt; so we can discover the resource early and then parse it on the background thread. It’s also possible to check with DevTools Timeline whether the correct scripts get streamed — if there’s one big script that dominates the parse time, it would make sense to make sure it’s (usually) picked up by the streaming. Better Parsing &amp; Compiling Work is ongoing for a slimmer and faster Parser that frees up memory and is more efficient with data structures. Today, the largest cause of main thread jank for V8 is the nonlinear parsing cost. Take a snippet of UMD: (function (global, module) { … })(this, function module() { my functions }) V8 won’t know that module is definitely needed so we won’t compile it when the main script gets compiled. When we decide to compile module, we need to reparse all of the inner functions. This is what makes V8’s parse-times non-linear. Every function at n-th depth is parsed n times and causes jank. V8 are already working on collecting info about inner functions during the initial compile, so any future compilations can ignore their inner functions. For module-style functions, this should result in a large perf improvement. See ‘The V8 Parser(s) — Design, Challenges, and Parsing JavaScript Better’ for the full story. V8 are also exploring offloading parts of JavaScript compilation to the background during startup. Precompiling JavaScript? Every few years, it’s proposed engines offer a way to precompile scripts so we don’t waste time parsing or compiling code pops up. The idea is if instead, a build-time or server-side tool can just generate bytecode, we’d see a large win on start-up time. My opinion is shipping bytecode can increase your load-time (it’s larger) and you would likely need to sign the code and process it for security. V8’s position is for now we think exploring avoiding reparsing internally will help see a decent enough boost that precompilation may not offer too much more, but are always open to discussing ideas that can lead to faster startup times. That said, V8 are exploring being more aggressive at compiling and code-caching scripts when you update a site in a Service Worker and we hope to see some wins with this work. We discussed precompilation at BlinkOn 7 with Facebook and Akamai and my notes can be found here. The Optimize JS lazy-parsing parens ‘hack’ JavaScript engines like V8 have a lazy parsing heuristic where they pre-parse most of the functions in our scripts before doing a complete round of parsing (e.g to check for syntax errors). This is based on the idea that most pages have JS functions that are lazily executed if at all. Pre-parsing can speed up startup times by only checking the minimal a browser needs to know about functions. This breaks down with IIFEs. Although engines try to skip pre-parsing for them, the heuristics aren’t always reliable and this is where tools like optimize-js can be useful. optimize-js parses our scripts in advance, inserts parenthesis where it knows (or assumes via heuristics) functions will be immediately executed enabling faster execution. Some of the paren-hacked functions are sure bets (e.g IIFEs with !). Others are based on heuristics (e.g in a Browserify or Webpack bundle it’s assumed all modules are eagerly loaded which isn’t necessarily the case). Eventually, V8 hopes for such hacks to not be required but for now this is an optimization we can consider if we know what you’re doing. V8 are also working on reducing the cost for cases where we guess wrong, and that should also reduce the need for the parens hack ConclusionsStart-up performance matters. Acombination of slow parse, compile and execution times can be a real bottleneck for pages that wish to boot-up quickly. Measure how long your pages spend in this phase. Discover what you can do to make it faster. We’ll keep working on improving V8 start-up performance from our end as much as we can. We promise ;) Happy perfing! Read More Planning for Performance Solving the Web Performance Crisis by Nolan Lawson JS Parse and Execution Time Measuring Javascript Parse and Load Unpacking the Black Box: Benchmarking JS Parsing and Execution on Mobile Devices (slides) When everything’s important, nothing is! The truth about traditional JavaScript benchmarks Do Browsers Parse JavaScript On Every Page Load With thanks to V8 (Toon Verwaest, Camillo Bruni, Benedikt Meurer, Marja Hölttä, Seth Thompson), Nolan Lawson (MS Edge), Malte Ubl (AMP), Tim Kadlec (Synk), Gray Norton (Chrome DX), Paul Lewis, Matt Gaunt and Rob Wormald (Angular) and for their reviews of this article. Update: Thanks to some awesome members of the community, this article is now available in Chinese and Russian too.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Hiểu rõ về Regular Expressions: RegEx không khó như tưởng tượng","slug":"Hieu-ro-ve-Regular-Expressions-RegEx-khong-kho-nhu-tuong-tuong","date":"2017-12-15T15:23:22.000Z","updated":"2018-09-07T13:27:14.704Z","comments":true,"path":"2017/12/Hieu-ro-ve-Regular-Expressions-RegEx-khong-kho-nhu-tuong-tuong.html","link":"","permalink":"http://nthung2112.github.io/2017/12/Hieu-ro-ve-Regular-Expressions-RegEx-khong-kho-nhu-tuong-tuong.html","excerpt":"Are you one of those people who stays away from regular expressions because it looks like a foreign language? I was one. Not anymore. Think of all those sounds, traffic signs and smells that you can recognize. Regular expressions are no different. It’s like a sign language to analyze strings. We are going to get our head around regular expressions today. At least, regularly used expressions. Much like any programming language, a regular expression is a succinct language in its own right. We will know how to put regular expressions to good use by the end of this article. We will solve simple problems and learn loads in the process. Are you willing to invest 30 minutes and come out enlightened in RegEx? Settle down then.","text":"Are you one of those people who stays away from regular expressions because it looks like a foreign language? I was one. Not anymore. Think of all those sounds, traffic signs and smells that you can recognize. Regular expressions are no different. It’s like a sign language to analyze strings. We are going to get our head around regular expressions today. At least, regularly used expressions. Much like any programming language, a regular expression is a succinct language in its own right. We will know how to put regular expressions to good use by the end of this article. We will solve simple problems and learn loads in the process. Are you willing to invest 30 minutes and come out enlightened in RegEx? Settle down then. Why regular expressions?We each have our own ‘why’, don’t we? One may be to test if the string is a valid hex color code. You may be writing a processor library such as Sass that leverages RegEx. I’ll let the universe throw the why at you and help you cover the how. 0. Get Your Playground ReadyReferencesMost of the time, I find this page adequate to get going: Regular Expressions from MDN. In fact, that page is all you need. You can stop reading this post. Right now. Close this tab. 😉 Still with me? Thanks. You need a sandbox to play around in. Luckily, one is available on your browser. Just use the DevTools in your browser’s console. Familiarize yourself with the syntaxTo start with, we are going to use the /expression/.test(‘string’) syntax. An expression is any regular expression that we build. A string is the string under test. The test method returns true or false depending on the match. Slashes mark the start and end of the expression. Treat them like the double quotes (“) and single quotes (‘) that you use to the mark start and end of a plain string. The expression between / is a literal. They are treated as literal characters. Variable names wouldn’t be resolved down to their contents. To make it dynamic, we’ll have to go via the constructor route, using new RegEx(variable_name) syntax. This will come to rescue towards the end of the post. Do it right now. Just type this into your browser console. 12/a/.test(\"a\"); //true/a/.test(\"b\"); //false If that works, you are ready. Don’t worry about what it is. That’s what we are going to breakdown into pieces in the following lines. Let’s dive in… 1. Start Small With LettersLet’s start small. We need to find if a string has a particular character. Look for the character a in a string. Here is the expression in all its glory: 123/a/.test(\"abc\"); //true /a/.test(\"bcd\"); //false /a/.test(\"cba\"); //true The expression does what we asked for, “Look for a in the string under test”. In our case, abc and bca do have the character a. But bcd does not have it. BreakdownNow, that’s a lot of slashes and backslashes. Let’s break them down. We’ve seen that /expression/ is how we build regular expressions. So no question about slash there. In fact, we can even assign it to a variable and make it look better. The same code: 1234let e=/a/; e.test(\"abc\"); //true e.test(\"bcd\"); //false e.test(\"cba\"); //true The expression between slashes is just a single character a in our case. We are looking only for that one character. Reach Multi-CharactersLet’s scale the solution. What if you want to find more than one character? Put them in sequence. Treat them as a substring. Here is an example: 1234/ab/.test(\"abacus\"); //true /bac/.test(\"abacus\"); //true /abc/.test(\"abacus\"); //false /abas/.test(\"abacus\"); //false The string under test should contain the exact expression within slashes. We get a match if that condition is met. bac is within abacusbut abas is not in abacus as it is. Even though we have those characters scrambled, we do not get an exact match. Review Ground CoveredSymbol /…/ . Slash (/) marks the start and end of the regular expression. Ignore the dots, that’s where we place the pattern. The /a/ character between slashes is a pattern matched on string under test. The /abc/ characters between slashes are looked up as a sub-string during the pattern matching test on string under test. 2. Patterns in NumbersLet’s spice it up a bit. Let’s say you want to find out if a string is full of numeric characters. Here it is: 123let e=/0|1|2|3|4|5|6|7|8|9/;e.test(\"42\"); //true e.test(\"The answer is 42\"); //true First of all, the pattern looks pretty long. But the same long streak of characters can be expressed in just two characters. I reserved it towards end of this section for a dramatic closure. The second case shouldn’t be true. We’ll deal with it a bit later. For now, the pipe symbol (|) means or. Outside of regular expressions, we’ve used it as a bitwise or and conditional or with double pipes (||). That’s the same guy. I could call that easy and call it a day. But you would scream for something better, right? We are developers. We spend the best part of our day thinking about better Bash and Git aliases to save few keystrokes. Should I type in nine pipe symbols? Nah. Here we go again: 123e=/[0123456789]/; e.test(\"42\"); //true e.test(\"The answer is 42\"); //still true This is better. 9 pipes were replaced with 2 square brackets. 7 characters were saved. That’s 77.7% less keystrokes. By the way, anything within square brackets is considered as Either this or that. It is a character set. In our case, the string should contain either 0, or 1, or 2, or…bear with me, I promised myself to write 1000 words a day, or 3 or 4 or 5. All right, let’s stop. You get it. What are you saying? It still looks quite lengthy? Not satisfied? Okay, here we go once again: 1234e=/[0-9]/; e.test(42); //true e.test(\"42\"); //true e.test(\"The answer is 42\"); //true! How about that? Looks much cleaner, doesn’t it? Anything within square brackets [] means or. 0-9 marks a range, meaning zero to nine. So the test looks for characters from zero to nine in the test string. As you can see, the test takes numbers too. The prefix and suffix patternsLet’s now address that failing second case. The answer is 42 matches our test because our pattern looks for numeric characters somewhere within the string. Not start to end. Let’s bring in ^ and $ to help us. ^ means the start of the string. He is a double agent and he’ll trip us off. His second avatar is unmasked only in the last section. $ means the end of the string. Let’s get the prefix pattern sorted out: 123/^a/.test(\"abc\"); //true /^a/.test(\"bca\"); //false /^http/.test(\"https://pineboat.in\"); //true /^http/.test(\"ftp://pineboat.in\"); //false Any pattern that follows ^ should be at the start of the string under test. The second string starts with b while our pattern looks for a. The fourth one looks for http while the string starts with ftp. This is the reason they fail. The suffix patternsThe suffix pattern follows. $ at the end of the pattern directs the test to look for end of string. 12/js$/.test(\"regex.js\"); //true /js$/.test(\"regex.sj\"); //false That should sound in your head like, “Look for js and then the end of the string”. Better yet, “Look for a string that ends in js”. Pattern match End to EndThat paves the road to pattern match start to end, you might as well call it end to end. 1234let e=/^[0-9]$/ e.test(\"42\"); //false - NO! e.test(\"The answer is 42\"); //false e.test(\"7\"); //true Surprisingly, the first one failed when we added ^ and $. /^[0-9]$/ reads like, “Go to the start of the string. Look for a single numeral from the character set. Check if the string ends right there.” That’s the reason the last entry returned true. It is just a single number, start to end. That’s not what we wanted. We wanted to test if the string had one or more numerals. We are very close. One last thing we need to learn is how to instruct the pattern to look for more than one character in the set. Tale of Three MusketeersA question mark (?), a plus (+) and an asterisk (*) met at a battle ground. Each is differently sighted. The humble question mark (?)says, “I can see none or just one.” Plus (+) says, “I need to see at least one or more.” Asterisk (*) says, “I get you both. I can see none, one, or more.” One of them is cleverly hiding what he is capable of. The question mark gets on stage first: 12345/a?/.test(\"\"); //true /a?/.test(\"a\"); //true /a?/.test(\"b\"); //true! /a?/.test(\"aa\"); //true /^a?$/.test(\"aa\"); //false Matches empty string “”as ? stands for 0 or 1 Matches aone match Matches b matches 0 occurrence Matches aaone match and the second a is not part of the pattern /^a?$/ does not match aa It looks for zero or one a, start to end, nothing more, nothing less The plus (+) looks at question mark and remarks, “I’m impressed, but your focus is so binary!”. And takes the stage to show off: 1234567/a+/.test(\"a\"); //true /a+/.test(\"aa\"); //true /a+/.test(\"ba\"); //true! /^a+$/.test(\"aa\"); //true /a+/.test(\"\"); //false /a+/.test(\"b\"); //false /^a+$/.test(\"ab\"); //false Remember what plus (+) said? It can match one or more occurrences of preceding pattern. All those returning true have one or more a. We even managed to get a whole string comprised only of a in the last one that returned true with /^a+$/. false should make sense now, but a word on the last one that returned false. /^a+$/ looks for a start to end, no other characters allowed. This is why ab failed the test. Finally, star (*) of the show gets on stage. He boasts that, “I can duel alone or duel you both at once” and says, “I can match zero, one or more”. 12345678/a*/.test(\"a\"); //true /a*/.test(\"aa\"); //true /a*/.test(\"ba\"); //true /a*/.test(\"\"); //true /a*/.test(\"b\"); //true /^a*$/.test(\"aa\"); //true /^a*$/.test(\"\"); //true /^a*$/.test(\"ab\"); //false Except the last one, was able to handle all else. /^a$/ reads like, 0 or more a start to end. Which is why empty string “” passed the test and “ab” failed. Back to the Universal AnswerRemember where were we before we met the three musketeers? Yes, “The answer is 42”. Now if we need to look for only numerals, one or more, start to end, what do we do? 12345//Let's throw in a plus let e=/^[0-9]+$/ e.test(\"4\"); //true e.test(\"42\"); //true e.test(\"The answer 42\"); //false - Hurray The plus sign (+) in [0-9]+ comes to our rescue. Plus means more than one occurrence of the character or pattern in front of it. In our case, more than one numerals. It also fails the match for our last case The answer is 42 because, there are no numerals at the start of the string. Practice Patterns Can you try to write a pattern for hexadecimal numbers (consisting of numerals 0–9 and letters a-f, with an optional # in front)? How about a binary number? Can you test if a string is full of just 0 and 1? That Dramatic EndOh, I almost forgot. [0-9] stands for any of the numeric character set and also has a shorthand version \\d. 1let e=/^\\d+$/; e.test(\"4\"); //true e.test(\"42\"); //true e.test(\"The answer 42\"); //false - Hurray Just two characters denoting numerals. And No, it doesn’t get any shorter than that. There are a whole bunch of such special patterns to specify clusters such as numbers (\\d), alpha numeric characters (\\w), white spaces (\\s). Review [123] The expression within square brackets are a character setAny one of the characters match will pass the test. Just ONE character. [0-9]Looks for a single numeric digit between 0 to 9 [0-5]Looks for a single numeric digit between 0 to 5 [a-z]Looks for a single letter between a to z [A-F]Looks for a single letter between A to F [123]+Plus (+) looks for one or more occurrence of the characters within the set This one matches a “23132” sub-string that consists of 1, 2 and 3 within a larger string “abc23132”. | Pipe symbol stands for or \\dA shorthand for numeralsMatches a single numeric digit. \\DA shorthand for non-numeric charactersAnything other than numerals that’ll be matched by \\d 3. Recurrence Match to Find DuplicatesThis is the actual problem I was trying to solve. I dove deep into regular expressions, which eventually led to this post. You’ve been given a string. Find out if it has been infused with duplicate characters before sunset. Here is the solution for duplicate characters appearing immediately after an occurrence: 123let e=/(\\w)\\1/; e.test(\"abc\"); //false e.test(\"abb\"); //true The expression does not match any part of the string abc as there are no duplicate characters in sequence. So it returns false. But it matches bb part of the string abb and returns true. Go ahead, type that on your DevTool console. Look at this! Let’s break it down to understandable pieces. Backslash \\ UnleashedI’ve been a little quiet about the backslash that was introduced in the last section. To those who have been there and done that, it may not have been a surprise. They might have escaped the confusion. But if you are new to programming world, you need to know more about backslash. In the regular expression language, backslash is special. The backslash alters the meaning of the characters that follow them. Ring a bell? What do you call \\n when you encounter it in a string? Yes, a new line. We’ve got something similar here. In fact, \\n is what you use as a pattern if you want to look for a new line. That’s called escaping the usual meaning of n and giving it a whole new attire called new line. \\d A shorthand for numeralsMatches a single numeric digit \\D A shorthand for non-numeric charactersAnything other than numerals that’ll be matched by \\d \\sShorthand for single white space character such as space, new line or tab. \\S Antonym of \\sanything other than white space \\wShorthand for alpha-numeric characterMatches a-z, A-Z, 0–9 and underscore _. \\WAntonym of \\w Recallable MatchesWe started this section with the solution for finding duplicate characters. /(\\w)\\1/ matched “abb”. That shows use of memory and recall within regular expressions. Consider the use of brackets in this format (expression). The resulting string that matches the expression within a bracket is remembered for later use. \\1 remembers and uses the match from first expression that is within brackets. Likewise, \\2 from second set of brackets. And so on. Let’s translate our expression (\\w)\\1 to plain English: Match any alpha-numeric character on a given string. Remember it as \\1. Check if that character appears right next to the first occurrence. Extension 1 — Reverse PairsLet’s say we want to find two characters appearing in reverse order right next to each other. That is like abba. ab is reversed as ba and is right next to each other. Here is the expression: 1234let e=/(\\w)(\\w)\\2\\1/; e.test(\"aabb\"); //false e.test(\"abba\"); //true e.test(\"abab\"); //false The first (\\w) matches a and remembers it as \\1. The second (\\w) matches b and remembers it as \\2. Then the expression expects \\2 to occur first followed by \\1. Hence, abba is the only string that matches the expression. Extension 2 — No duplicatesThis time, we are going to look at sequence of characters with no duplicates. No character should be followed by the same character. Plain and simple. Here, take a look at the solution: 1234let e=/^(\\w)(?!\\1)$/; e.test(\"a\"); //true e.test(\"ab\"); //false e.test(\"aa\"); //false Not the one we wanted, but close. The middle one shouldn’t be false. But we threw in a few more symbols that need explaining. That means confronting the most powerful musketeer once again. Return of the Question MarkRemember the three musketeers we met earlier. The humble question mark is actually the most powerful manipulator that can get other symbols to do his bidding. That is, if you take the backslash for granted. A combination of brackets, question mark and exclamation mark (?!), is called a look ahead. A negative look ahead to be precise. a(?!b) matches a only if it is not followed by b. Across JavaScript ecosystem, the exclamation mark means not. But its cousin CSS takes a u-turn and !important means it is actually very important and should not be overridden. I almost scrolled past Chen’s tweet thinking it is marked not important. I digress. On the other hand, (?=) is a positive look ahead. a(?=b) matches a only if it is followed by b. We had a solution. (\\w)(?!\\1) looks for a character without recurrence. But only for one character. We need to group it and look for 1 or more occurrences of characters with the use of plus (+). That’s all. 123let e=/^((\\w)(?!\\1))+$/; e.test(\"madam\"); //false e.test(\"maam\"); //false But it doesn’t seem to be working. If we group the pattern within plain brackets like ((\\w)(?!\\1)), the \\1 does not represent(\\w), it represents higher level bracket pair that groups the pattern. So it fails. What we need is a forgetful grouping option. That’s where the question mark, ?, strikes back. It pairs with a colon, (?:) and wipes out any function of memory that the brackets can bring in. One last time: 123let e=/^(?:(\\w)(?!\\1))+$/; e.test(\"madam\"); //true e.test(\"maam\"); //false This time, the first level of brackets are not remembered, thanks to ?:, hence, \\1 remembers the match returned by \\w. It helps us use the plus + against the overall grouping to find similar pairs of characters start to end, which works like magic. In English, “Look for a character. Look ahead to ensure it is not followed by the same character. Do this from start to end for all characters.” Review \\w represents all the alpha-numeric charactersIf you capitalize ‘w’ and use \\W’, that would mean all characters other than alpha-numeric ( )The expression within a bracket is remembered for later use \\1 remembers and uses the match from first expression that is within brackets \\2 from second set of brackets. And so on. a(?!b)A combination of brackets, question mark and exclamation mark (?!), is called a look ahead This matches a only if it is not followed by b a(?=b) The other side of the coinMatch a only if it is followed by b. (?:a)Forgetful grouping Look for a but don’t remember itYou can’t use \\1 pattern to reuse this match 4. Alternating SequenceThe usecase is simple. Match a string that uses only two characters. Those two characters should alternate throughout the length of the string. Two sample tests for “abab” and “xyxyx” will do. It wasn’t easy. I got it wrong on several attempts. This answer directed me down the right street. Here is the solution: 123456let e=/^(\\S)(?!\\1)(\\S)(\\1\\2)*$/; e.test(\"abab\"); //true e.test(\"$#$#\"); //true e.test(\"#$%\"); //false e.test(\"$ $ \"); //false e.test(\"xyxyx\"); //false This is where you say, “I’ve had enough!” and throw in the towel. But wait for the Aha moment! You are 3 feet away from the gold ore, not the right time to stop digging. Let’s first make sense out of results before we arrive at ‘how?’ abab matches. $#$# matches, this is no different from abab. #$% fails as there is a third character. $ $ fails though they are pairs, because space is excluded in our pattern. All is well except, xyxyx fails, because our pattern doesn’t know how to handle that last x. We’ll get there. Let’s take a look at the tools added to our belt. It’ll start to make sense soon. One piece at a timeYou already know most of the pieces. \\S is the opposite of \\s. \\S looks for non white space characters. Now comes the plain English version of /^(\\S)(?!\\1)(\\S)(\\1\\2)*$/. Start from the start /^ Look for a non-white space character (\\S) Remember it as \\1 Look ahead and see if the first character is not followed by the same character (?!\\1).Remember this is a negative look ahead. If we are good so far, look for another character (\\S) Remember it as \\2 Then look for 0 or more pairs of first two matches (\\1\\2)* Look for such pattern until end of the string $/ Apply that to our test cases. “abab” and “$#$#” match. Tail EndAfter looking at the solution you may think this does not demand a separate section. But the simplicity of it is elegant. Let’s fix that one failing case xyxyx. As we’ve seen, the last trailing x is the problem. We have a solution for xyxy. All we need is a pattern to say “Look for an optional occurrence of first character”. As usual, let’s start with the solution. 1let e=/^(\\S)(?!\\1)(\\S)(\\1\\2)*\\1?$/; e.test(\"xyxyx\"); //true e.test(\"$#$#$\"); //true The question mark strikes again. There is no escaping him. It’s better we make him our ally than our enemy. A question mark ? after a character or pattern means 0 or 1 match for the preceding pattern. It is non-greedy in gobbling up characters. In our case, \\1? means, 0 or 1 match of the first character remembered through first set of brackets. Easy. Relax. Review \\SRepresents all characters excluding white space such as a space and new linesNote that it is capital S a*The asterisk or star, looks for 0 or more occurrences of the preceding character. In this case, it is 0 or more aRemember plus (+) which looks for 1 or more? Yeah, these guys are cousins. a(?!b)This combination of brackets, question mark and exclamation mark (?!) is called a look ahead.This matches a only if it is not followed by b.For example, it matches a in aa, ax, a$ but does not match ab Though it uses bracket, it does not remember the matching character after a. \\sSmall caps s matches a single white space character such as a space or new line. a(?=b)This matches a that is followed by b. ^ab*$You may think this translates to 0 or more occurrences of ab, but it matches a followed by 0 or more b For example: This matches abbb, aand ab, but does not match abab ^(ab)*$This matches 0 or more pairs of ab That means it will match empty string “”, aband abab, but not abb a?? matches 0 or 1 occurrence of preceding character or pattern\\1? matches 0 or 1 recurrence of first remembered match 5. Match an email addressWarning for ProductionRegular expressions alone may not help validate emails. Some would even argue that regular expressions should not be used as it can never match 100% of the emails. Think about all the fancy domain names popping up. Also consider inclusion of symbols within email addresses, such as dot (.) and plus (+). You need to validate email twice. Once on the client side to help users avoid misspelled addresses. Start with a semantic input tag type &lt;input type=&#39;email&#39;&gt;. Some of the browsers automatically validate it without any extra scripting on the front end. Validate it once again on the server by actually sending a confirmation email. Haven’t you seen one such lately? Just try to subscribe to this pineboat. You’ll get an actual email asking you to confirm that it is yours. That confirmation is a solid proof that your email is valid. That was smooth sailing, wasn’t it? RegEx for EmailNow that we added the disclaimer, you’d actually want to see a pattern right? No, search for regular expression for an email address. One such result from perl module goes for more than a page. So, I am not even going to attempt it. Such long regular expressions are generated by computers through pattern builders. Not for mere mortals like us. 6. Match a Strong PasswordIf you are a coffee person, this is the right time to get a strong one. Because we are at last section of this post, but the longest one so far. It introduces very few new operators and patterns. But it reuses many patterns. As usual, we reserve the shortest optimized one for last. The ASCII range is the best part of this post. Because, I learned it while researching for this post. Now, the problem. Remember that registration form that took several attempts before you could meet their strong password requirements? Weak, good, strong, and very strong? Yeah, we are going to build that validation. The password should: have a minimum of 4 characters contain lowercase contain uppercase contain a number contain a symbol This is a tricky one. Once you start consuming letters, you can’t come back to check if they meet any other condition.There in lies our clue. We can’t look back, but we can look ahead! Length of the stringLet’s first test if the string password is 4 characters long. Pretty simple. Use .length on the password string. Done, right? No, who needs a simple solution? Let’s spice it up. 123456789//expression with just lookahead//wouldn't consume any charactere1=/^(?=.&#123;4,&#125;)$/; e1.test(\"abc\") //falsee1.test(\"abcd\") //false //after lookahead, //pattern to consume character is needed.e2=/^(?=.&#123;4,&#125;).*$/; e2.test(\"abc\") //false e2.test(\"abcd\") //true You may remember (?=) from our previous work on “no duplicates” That’s a look ahead useIt does not consume any character The dot (.) is an interesting characterIt means, any character. {4,}Stands for at least 4 preceding characters with no maximum limit \\d{4}Would look for exactly 4 numerals \\w{4,20}Would look for 4 to 20 alpha-numeric characters Let’s translate /^(?=.{4,})$/. “Start from the beginning of the string. Look ahead for at least 4 characters. Don’t remember the match. Come back to the beginning and check if the string ends there.” Doesn’t sound right. Does it? At least the last bit. Which is why we brought in the variation /^(?=.{4,}).$/. An extra dot and a star. It reads like this, “Start from the beginning. Look ahead for 4 characters. Don’t remember the match. Come back to the beginning. Consume all the characters using . and see if you reach the end of the string.” This makes sense now. Doesn’t it? Which is why abc fails and abcd passes the pattern. At least One NumberThis is going to be easy. 123456e=/^(?=.*\\d+).*$/ e.test(\"\"); //false e.test(\"a\"); //false e.test(\"8\"); //true e.test(\"a8b\"); //true e.test(\"ab890\"); //true Start from the beginning of the string /^. Look ahead for 0 or more characters ?=.. Check if 1 or more numbers follow \\d+. Once it matches, come back to the beginning (because we were in look ahead). Consume all the characters in the string until end of the string .$/. At Least One Lowercase LetterThis one follows the same patter as above. 1234e=/^(?=.*[a-z]+).*$/; e.test(\"\"); //false e.test(\"A\"); //false e.test(\"a\"); //true Translation? Sure. “Start from the… okay.” Instead of \\d+, we have [a-z]+ which is a character set of letters from a to z. At least One Uppercase LetterLet’s not overkill. [A-Z] instead of [a-z] from the previous section will do. At least One SymbolThis is going to be challenging. One way to match symbols is to place a list of symbols in a character set. /^(?=.[-+=_)(\\&amp;\\^%\\$#@!~”’:;|}]{[/?.&gt;,&lt;]+).*$/.test(“$”) That’s all the symbols in a character set. Properly escaped where necessary. It’ll take months for me to write it in plain English. So to save all of us from eternal pain, here is a simple one: 1234567891011121314//considers space as symbol let e1; e1=/^(?=.*[^a-zA-Z0-9])[ -~]+$/ e1.test(\"_\"); //true e1.test(\" \"); //true //does not take space let e2; e2=/^(?=.*[^a-zA-Z0-9])[!-~]+$/ e2.test(\" \"); //false e2.test(\"_\"); //true //the underscore exception let e3; e3=/^(?=.*[\\W])[!-~]+$/ e3.test(\"_\"); //false Wait, what’s that ^ coming again from the middle of no where? If you have reached this far, this is where you realize that unassuming innocent ^ that marks start of a string is a double agent. Which means, the end is not too far. He has been exposed. Within a character set, ^ negates the character set. That is, [^a-z] means, any character other than a to z. [^a-zA-Z0-9] then stands for any character other than lower case alphabets, upper case alphabets, and numerals. We could have used \\W instead of the long character set. But \\W stands for all alpha-numeric characters including underscore _. As you can see in the third set of examples above, that will not accept underscore as a valid symbol. CharSet RangeThe curious case of [!-~]. They stand next to each other in the keyboard, but their ASCII values are diagonally opposite. Remember a-z? A-Z? 0–9? These are not constants. They are actually based on the ASCII range of their values. The ASCII table has 125 characters. zero (0) to 31 are not relevant to us. Space starts from 32 going all the way up to 126 which is tilda(~). The exclamation mark is 33. So [!-~] covers all the symbols, letters and numbers we need. The seed for this idea came from another solution to the symbol problem. Assemble the TroopsBringing it all together, we get this nice looking piece of regular expression /^(?=.{5,})(?=.[a-z]+)(?=.\\d+)(?=.[A-Z]+)(?=.[^\\w])[ -~]+$/. That’s starting to haunt and intimidate us. Though we’ve been studying them individually. This is where the syntax for dynamically building expression object comes in handy. We are going to build each piece separately and assemble them later. 123456789101112131415161718192021222324252627282930313233//start with prefix let p = \"^\"; //look ahead // min 4 chars p += \"(?=.&#123;4,&#125;)\"; // lower case p += \"(?=.*[a-z]+)\"; // upper case p += \"(?=.*[A-Z]+)\"; // numbers p += \"(?=.*\\\\d+)\"; // symbols p += \"(?=.*[^ a-zA-Z0-9]+)\"; //end of lookaheads //final consumption p += \"[ -~]+\"; //suffix p += \"$\"; //Construct RegEx let e = new RegEx(p); // tests e.test(\"aB0#\"); //true e.test(\"\"); //false e.test(\"aB0\"); //false e.test(\"ab0#\"); //false e.test(\"AB0#\"); //false e.test(\"aB00\"); //false e.test(\"aB!!\"); //false // space is in our control e.test(\"aB 0\"); //false e.test(\"aB 0!\"); //true If your eyes are not tired yet, you’d have noticed two strange syntax in the above code. One, we didn’t use /^, instead we used just ^. We didn’t use $/ to end the expression either, instead just $.The reason is that the RegEx constructor automatically adds starting and trailing slashes for us. Two, to match numbers we used \\d instead of the usual \\d. This is because the variable p is just a normal string within double quotes. To insert a backslash, you need to escape the backslash itself.\\d resolves to \\d within the RegEx constructor Apparently, there should be server side validations for passwords too. Think about SQL injection vulnerabilities if your framework or language doesn’t handle it already. 7. ConclusionThat brings us to the end of the story. But this is the beginning of a journey. We just scratched the pattern matching portion of RegEx with test method. exec method builds on this foundation to return matched sub-strings based on pattern. String object has methods such as match, search, replace, and split that widely uses regular expressions. Hope this sets you off to explore those capabilities further with a solid understanding on composing patterns for RegEx. 8. Call To ActionNo, after all this difficulty we’ve been through, I am not going to ask you to subscribe. Just make good software. If any code blocks presented here do not work, leave a comment on this github issue I created specially for this post. Hope it was useful! Share it if others would benefit. You’ve been wonderful. Appreciate your time. This content is far long by recent standards. Thanks for reading. Originally published at www.pineboat.in.","categories":[],"tags":[{"name":"regex","slug":"regex","permalink":"http://nthung2112.github.io/tags/regex/"}]},{"title":"React, Inline Functions, and Performance","slug":"React-Inline-Functions-and-Performance","date":"2017-12-08T07:43:28.000Z","updated":"2017-12-12T15:03:58.752Z","comments":true,"path":"2017/12/React-Inline-Functions-and-Performance.html","link":"","permalink":"http://nthung2112.github.io/2017/12/React-Inline-Functions-and-Performance.html","excerpt":"My wife and I just got through a huge remodel. We were beyond excited to show people the new digs. We showed my mother-in-law. She walked in the beautifully remodeled bedroom, looked up at the fantastically framed window and said: “No blinds?” 😐 Our new bedroom; holy crap it looks like a magazine picture. Also, no blinds. I find myself with the same emotion when I’m talking about React. I’ll be getting through the first lecture of a workshop, showing off some cool new OSS, and invariably somebody says: “inline functions? I heard those are slow.”","text":"My wife and I just got through a huge remodel. We were beyond excited to show people the new digs. We showed my mother-in-law. She walked in the beautifully remodeled bedroom, looked up at the fantastically framed window and said: “No blinds?” 😐 Our new bedroom; holy crap it looks like a magazine picture. Also, no blinds. I find myself with the same emotion when I’m talking about React. I’ll be getting through the first lecture of a workshop, showing off some cool new OSS, and invariably somebody says: “inline functions? I heard those are slow.”It wasn’t always this way. But the last few months it comes up literally every day. As an instructor and library author, it gets exhausting. Unfortunately, I’m a dummy and I rant on twitter instead of writing something that might be insightful to others. So, this is my attempt at the better option 😂. What is an “inline function”In the context of React, an inline function is a function that is defined while React is “rendering”. There are two meanings of “render” in React that people often get confused about: (1) getting the React elements from your components (calling your component’s render method) during an update and (2) actually rendering updates to the DOM. When I refer to “rendering” in this article, I’m talking about #1. Here are a few examples of inline functions: Premature optimization is the root of all evilBefore we go any further, we need to talk about how to optimize a program. Ask any performance expert and they will tell you not to prematurely optimize your program. All of them. Yes, every single one of them. 100% of people with deep performance experience will tell you not to prematurely optimize your code. If you aren’t measuring, you can’t even know if your optimizations are better, and you certainly won’t know if they make things worse! I remember a talk my friend Ralph Holzmann gave about how gzip works that really solidified this idea for me. He talks about an experiment he did with LABjs, an old script loading library. You can watch from 30:02 to about 32:35 in this video to hear about it, or just keep reading. At the time, the source for LABjs did something a little awkward for performance. Instead of using normal object notation (obj.foo) it stored the keys in strings and used bracket notation to access the objects (obj[stringForFoo]). The idea was that after minifying and gzipping, the unnaturally written code would be smaller than the naturally written code. You can see it here. Ralph forked the code and removed the optimizations by writing the code naturally, without thinking about how to optimize for minification and gzip. Turns out, removing the “optimizations” shaved off 5.3% of the file size! If you aren’t measuring, you can’t even know if your optimizations are better, and you certainly won’t know if they make things worse! Not only can premature optimization explode development time while hurting code cleanliness, it can even backfire and cause performance problems as it did for LABjs. Had the author been measuring, rather than just imagining performance issues, he would have saved development time, had cleaner code, and better performance. Don’t prematurely optimize. Alright, back to React. Why do people say inline functions are slow?Two reasons: Memory/garbage collection concerns, and shouldComponentUpdate. Memory and garbage collectionFirst, folks (and eslint configs) are concerned about memory and garbage collection costs around creating inline functions. This mostly spilled over from the days before arrow functions became ubiquitous. Lots of code would call bind inline, which has historically had poor performance. For example: Performance issues with Function.prototype.bind got fixed here and arrow functions are either a native thing or are transpiled by babel to plain functions; in both cases we can assume it’s not slow. Remember, you don’t sit back and imagine “I bet that code is slow”. You write your code naturally, then you measure it. If there are performance problems, fix them. We don’t need to prove an inline arrow function is fast, somebody else needs to prove it’s slow. Otherwise it’s a premature optimization. As far as I’ve seen, nobody has presented an analysis of their app that indicates inline arrow functions are slow. Until then, it’s not even worth talking about — but I’ll offer one more thought anyway 😝 If the cost of creating an inline function is high enough to warrant an eslint rule against it, why would we want to move that expense to the hot path of initialization? By prematurely optimizing we’ve slowed down the initialization of the component by 3x! If all the handlers were inline, the initial render would only have to create one function. Instead, we’ve created three. We haven’t measured anything though, so we have no reason to believe any of this is a problem. If you want to completely miss the point, go make an eslint rule that requires inline functions everywhere to speed up the initial render 🤦🏾‍♀️. PureComponent and shouldComponentUpdateThis is where the real meat of the problem lives. You can see real performance improvements by understanding two things: shouldComponentUpdate and JavaScript strict equality comparisons. If you don’t understand them well, you can inadvertently make your React code harder to work with in the name of performance. When you call setState, React will compare the old React elements to a new set of React elements (this is called r_econciliation_, you can read about it here) and then use that information to update the real DOM elements. Sometimes that can get slow if you’ve got a lot of elements to check (like a big SVG). In these cases, React provides an escape hatch called shouldComponentUpdate. If your component has shouldComponentUpdate defined, before React compares the old and new elements, it will ask shouldComponentUpdate if anything changed. If it returns false, then React will completely skip the element diff, saving some time. If your component is large enough, this can have considerable impact on performance. The most common way to optimize a component is to extend React.PureComponent instead of React.Component. A PureComponent will diff your props and state in shouldComponentUpdate so you don’t have to. 1class Avatar extends React.PureComponent &#123; ... &#125; Avatar will now use a “strict equality comparison” on its props and state when being asked to update, hopefully speeding things up. Strict Equality ComparisonThere are six primitive types in JavaScript: string, number, boolean, null, undefined, and symbol. When you do a “strict equality comparison” on two primitives that hold the same value, you’ll get true. For example: 123const one = 1const uno = 1one === uno // true When PureComponent diffs props it uses a strict equality comparison. This works out great for inlined primitive values: . The prop diffing problem arises because of non-primitive types — err, excuse me, type. There is only one other type and that’s Object. What about functions and arrays you say? Well, actually those are just objects. Functions are regular objects with the additional capability of being callable. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures LOL, okay JavaScript. So anyway, strict equality checks on objects, even with seemingly similar values, will evaluate to false: So, if you inline an object in your JSX, it will fail the PureComponent prop diff and move on to diffing the more expensive React elements. The element diff will come up empty and now we’ve wasted time on both diffs. Since functions are objects and PureComponent does a strict equality check on props, an inline function will always fail the prop diff and move on to the element diff in the reconciler. You can see this isn’t just about inline functions. The function is simply the lead singer of the object, function, array three-piece performance postulation proliferation. In order to make shouldComponentUpdate happy, you have to keep referential identity of the function. For experienced JavaScript developers, it’s not too bad. But, Michael and I have led workshops with over 3,500 people at varying levels of experience and it ain’t easy for a lot of folks. ES classes don’t offer any help either, leading us down all sorts of JavaScript paths: Learning how to keep referential identity of a function leads to surprisingly long conversations. There’s usually no reason why we’re forcing people to do this other than an eslint config yelled at them. I’d like to show that you can have inline functions and performance optimizations both at the same time. But first, I have a personal performance story. My own experience with PureComponentWhen I first learned about PureRenderMixin (the thing from earlier versions of React that later became PureComponent) I put in a bunch of measurements and measured my app’s performance. I then added PureRenderMixin to every single component. When I took the optimized set of measurements I was hoping to have a cool story to tell about how much faster everything got. Much to my surprise, my app got slower 🤔. Why? Well, think about it. If you have a Component how many diffs are there? If you have a PureComponent how many diffs are there? The answers are “just one” and “at least one and sometimes two”, respectively. If a component usually changes when there’s an update, then a PureComponent will be doing two diffs instead of just one (props and state in shouldComponentUpdate, and then the normal element diff). Which means it’s going to be slower usually but faster occasionally. Apparently, most of my components changed most of the time, so on the whole, my app got slower. Oops. There are no silver bullets when it comes to performance. You have to measure. The three scenariosAt the start of the article I showed three types of inline functions. Now that we have some background, let’s talk about each one them. But please remember to keep PureComponent on the shelf until you have a measurement to justify it. DOM component event handler123&lt;button onClick=&#123;() =&gt; this.setState(…)&#125;&gt;click&lt;/button&gt; It’s common to do nothing more than setState inside of event handlers for buttons, inputs, and other DOM components. This often makes an inline function the cleanest approach. Instead of bouncing around the file to find the event handlers, they’re colocated. The React community generally welcomes colocation. The button component (and every other DOM component) can’t even be a PureComponent, so there are no shouldComponentUpdate referential identity concerns here. So, the only reason to think this is slow is if you think simply defining a function is a big enough expense to worry about. We’ve discussed that there is no evidence anywhere that it is. It’s simply armchair performance postulation. These are fine until proven otherwise. A “custom event” or “action”123&lt;Sidebar onToggle=&#123;(isOpen) =&gt; &#123; this.setState(&#123; sidebarIsOpen: isOpen &#125;)&#125;&#125;/&gt; If Sidebar is a PureComponent we will be breaking the prop diff. Again, since the handler is simple, the colocation can be preferable. With an event like onToggle, why is Sidebar even diffing it? There are only two reasons to include a prop in the shouldComponentUpdate diff: You use the prop to render. You use the prop to perform a side-effect in componentWillReceiveProps, componentDidUpdate, or componentWillUpdate. Most on props do not meet either of these requirements. Therefore, most PureComponent usages are over-diffing, forcing developers to maintain referential identity of the handler needlessly. We should only diff the props that matter. That way people can colocate handlers and still get the performance gains you’re seeking (and since we’re concerned about performance, we’re diffing less!). For most components, I’d recommend creating a PureComponentMinusHandlers class and inherit from that instead of inheriting from PureComponent. It could just skip all checks on functions. Have your cake and eat it too. Well, almost. If you receive a function and pass that function directly into another component, it’ll get stale. Check this out: Here’s a codesandbox running that app. So, if you like the idea of inheriting from a PureRenderWithoutHandlers, make sure you don’t ever pass your ignored handlers directly to other components — you need to wrap them one way or another. Now we either have to maintain referential identity, or we have to avoid referential identity! Welcome to performance optimization. At least with this approach it’s the optimized component that has to deal with it, not the code using it. I’m going to be candid, that example app is an edit I made after publishing that Andrew Clark brought to my attention. And here you thought I was smart enough to know when to manage referential identity and when not to! 😂 A render prop Render props are a pattern used to create a component that exists to compose and manage shared state. (You can read more about them here.) The contents of the render prop are unknowable to the component. For example: That means an inline render prop function won’t cause problems with shouldComponentUpdate: It can’t ever know enough to be a PureComponent. So, the only other objection is back to believing that simply defining functions is slow. Repeating from the first example: there’s no evidence to support that. It’s simply armchair performance postulation. In summary Write your code naturally, code to the design. Measure your interactions to find slow paths. Here’s how. Use PureComponent and shouldComponentUpdate only when you need to, skipping prop functions (unless they are used in lifecycle hooks for side-effects).","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Cải thiện tốc độ Web App với Pinterest ","slug":"Cai-thien-toc-do-Web-App-voi-Pinterest","date":"2017-12-08T06:57:03.000Z","updated":"2017-12-12T15:03:58.744Z","comments":true,"path":"2017/12/Cai-thien-toc-do-Web-App-voi-Pinterest.html","link":"","permalink":"http://nthung2112.github.io/2017/12/Cai-thien-toc-do-Web-App-voi-Pinterest.html","excerpt":"Pinterest’s new mobile web experience is a Progressive Web App. In this post we’ll cover some of their work to load fast on mobile hardware by keeping JavaScript bundles lean and adopting Service Workers for network resilience. Login to https://pinterest.com on your phone to experience their new mobile site","text":"Pinterest’s new mobile web experience is a Progressive Web App. In this post we’ll cover some of their work to load fast on mobile hardware by keeping JavaScript bundles lean and adopting Service Workers for network resilience. Login to https://pinterest.com on your phone to experience their new mobile site Why a Progressive Web App (PWA)? Some history.The Pinterest PWA started because they were focused on international growth, which led them to the mobile web. After analyzing usage for unauthenticated mobile web users, they realized that their old, slow web experience only managed to convert 1% of users into sign-ups, logins or native app installs. The opportunity to improve this conversation rate was huge, leading them to an investment in the PWA. Building and shipping a PWA in a quarter Over 3 months, Pinterest rebuilt their mobile web experience using React, Redux and webpack. Their mobile web rewrite led to several positive improvements in core business metrics. Time spent is up by 40% compared to the old mobile web experience, user-generated ad revenue is up 44% and core engagements are up 60%: Their mobile web rewrite also led to several improvements in performance. Loading fast on average mobile hardware over 3GPinterest’s old mobile web experience was a monolith — it included large bundles of CPU-heavy JavaScript that pushed out how quickly Pin pages could load and get interactive. Users often had to wait 23 seconds before any UI was usable at all: Pinterest’s old mobile web site took 23 seconds to get interactive. They would send down over 2.5MB of JavaScript (~1.5MB for the main bundle, 1MB lazily loaded in) taking multiple seconds to get parsed and compiled before the main thread finally settled down enough to be interactive. Their new mobile web experience is a drastic improvement. Not only did they break-up &amp; shave hundreds of KB off their JavaScript, taking down the size of their core bundle from 650KB to 150KB but they also improved on key performance metrics. First Meaningful Paint was down from 4.2s to 1.8s and Time To Interactive reduced from 23s to 5.6s. This is on average Android hardware over a slow 3G network connection. On repeat visits, the situation was even better. Thanks to Service Worker caching of their main JavaScript, CSS and static UI assets they were able to bring down time to interactive on repeat visits all the way down to 3.9s: Although Pinterest vend iOS &amp; Android apps, they were able to deliver the same core home feed experience these apps do on the web in a fraction of the upfront download cost — just ~150KB minified &amp; gzipped. This contrasts with the 9.6MB required to deliver this experience for Android and 56MB for iOS: It’s important to note that this isn’t comparing apples to apples, however. The PWA loads code for new routes on demand, and the cost of additional code is amortized over the lifetime of the application. Subsequent navigations still don’t cost as much data as the download of the app. Pinterest’s Progressive Web App in Firefox, Edge and Safari on mobile. Route-based JavaScript chunkingGetting a web page to load and get interactive quickly benefits from only loading the code a user needs upfront. This reduces network transmission &amp; JavaScript parse/compile times. Non-critical resources can then be lazily loaded as needed. Pinterest started breaking up their multi-megabyte JavaScript bundles by splitting them into three different categories of webpack chunks that worked quite well: a vendor chunk which contained external dependencies (react, redux, react-router, etc) ~ 73KB an entry chunk which contained a majority of the code required to render the app (i.e. common libs, the main shell of the page, our redux store) ~ 72KB async route chunks which contained code pertaining to individual routes ~13–18KB A Network waterfall for the experience highlights how a shift to progressively delivering code as needed avoids the need for monolithic bundles: For long-term caching, Pinterest also use a chunk-specific hash substitution for each filename. Pinterest uses webpack’s CommonsChunkPlugin to break out their vendor bundles into their own cacheable chunk: They also used React Router for adding code-splitting to the experience: Use babel-preset-env to only transpile what target browsers needPinterest use Babel’s babel-preset-env to only transpile ES2015+ features unsupported by the modern browsers they target. Pinterest targets the last two versions of modern browsers, and their .babelrc setup looks a little like: There are further optimizations they can do to only conditionally serve polyfills as needed (e.g the Internationalization API for Safari) but this is planned for the future. Analyzing room for improvement with Webpack Bundle Analyzer Webpack Bundle Analyzer is an excellent tool for really understanding what dependencies you’re sending down to your users in JavaScript bundles. Below, you’ll see a lot of purple, pink and blue blocks in its output for an earlier build of Pinterest. These are async chunks for routes being lazily loaded in. Webpack Bundle Analyzer allowed Pinterest to visualize that most of these chunks contained duplicate code: Webpack Bundle Analyzer helped visualize the size ratio of this problem between all their chunks. Using the information about duplicate code in chunks, Pinterest were able to make a call. They moved duplicate code in async chunks to their main chunk. It increased the size of the entry chunk by 20% but decreased the size of all lazily loaded chunks by up to 90%! Image OptimizationMost of the lazy-loading of content in the Pinterest PWA is handled by an infinite Masonry grid. It has built-in support for virtualization and only mounting children that are in the viewport. Pinterest also uses a progressive loading technique for images in their PWA. A placeholder with the dominant color is initially used for each Pin. Pin images are served as Progressive JPEGs, which improve image quality with each scan: React performance pain-pointsPinterest ran into some rendering performance issues with React as part of their use of this Masonry grid. Mounting and unmounting large trees of components (like Pins) can be slow. There’s a lot that goes into a Pin: Although at the time of writing Pinterest are using React 15.5.4, their hope is that React 16 (Fiber) will help a lot with reducing time spent unmounting. In the mean time, Virtualizing the grid helped significantly with component unmount time. Pinterest also throttle insertion of Pins so that they can measure/render the first Pins quicker, but means there’s more overall work for the device’s CPU. Navigation TransitionsTo improve perceived performance, Pinterest also update the selected state of navigation bar icons independent of the route. This enables navigations from one route to another to not feel slow due to blocking on the network. The user gets visual UI painted quickly while we’re waiting for the data to arrive: Experience using ReduxPinterest use normalizr (which normalizes nested JSON according to a schema) for all of their API data. This is viewable from the Redux DevTools: The downside to this process is that denormalization is slow so they ended up heavily relying on reselect’s selector pattern for memoizing denormalization during renders. They also always denormalize at the lowest level possible to ensure individual updates don’t cause large re-renders. As an example, their grid item lists are just Pin IDs with the Pin component denormalizing itself. If there are changes to any given Pin, the full grid does not have to re-render. The trade-off is that there are a lot of Redux subscribers in the Pinterest PWA, though this hasn’t resulted in noticeable perf issues. Caching assets with Service WorkersPinterest use the Workbox libraries for generating and managing their Service Workers: Today, Pinterest cache any JavaScript or CSS bundles using a cache-first strategy and also cache their user-interface (the application shell). In a cache-first setup, if a request matches a cache entry, respond with that. Otherwise try to fetch the resource from the network. If the network request succeeds, update the cache. To learn more about caching strategies with Service Worker, read Jake Archibald’s Offline Cookbook. They define a precache for the initial bundles loaded by the application shell (webpack’s runtime, vendor and entryChunks) too. As Pinterest is a site with a global presence, supporting multiple languages, they also generate a per-locale Service Worker configuration so they can precache locale bundles. Pinterest also use webpack’s named chunks to precache top-level async route bundles. This work was rolled out in several smaller, iterative steps. 1st: Pinterest’s Service Worker only did runtime caching of scripts lazy-loaded on demand. This was to take advantage of V8’s code caching, helping skip some of the parse/compile cost on repeat views so they can load quicker. Scripts served from Cache Storage where a Service Worker is present can eagerly opt into code caching as there’s a good chance the browser knows the user will end up using these resources on repeat views. After this, Pinterest progressed to pre-caching their vendor and entry chunks. Next, Pinterest started precaching a few of the most used routes (like the home page, pin page, search page etc). Finally, they started generating a Service Worker for each locale so that they could also cache the locale bundle. This was important for not just repeat load performance, but also enabling basic offline rendering for most of their audience: Application Shell challengesPinterest found implementing their application shell a little tricky. Because of desktop-era assumptions about how much data could be sent down over a cable connection, initial payloads were large containing a lot of non-critical info, like user’s experiment groups, user info, contextual information etc. They had to ask themselves: “do we cache this stuff in the application shell? or take the perf hit of making a blocking network request before rendering anything to fetch it at all”. They decided to cache it in the application shell, which required some management of when to invalidate the app shell (logout, user information updates from settings etc). Each request response has an appVersion — if the app version changes, they unregister the Service Worker, register the new one then on the next route change they do a full page reload. Adding this information to the application shell is a little trickier, but worth avoiding the render blocking request for. Auditing with LighthousePinterest used Lighthouse for one-off validations that their performance improvements were on the right track. It was useful for keeping an eye on metrics such as Time to Consistently Interactive. Next year they hope to use Lighthouse as a regression mechanism to verify that page loads remain fast. The FuturePinterest just deployed support for Web Push notifications and have also been working on the unauthenticated (logged-out) experience for their PWA. They are interested in exploring support for to preload critical bundles &amp; reducing the amount of unused JavaScript delivered to users on first load. Stay tuned for more awesome perf work in the future!","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"22 React projects open source","slug":"22-React-projects-open-source","date":"2017-12-08T06:37:30.000Z","updated":"2017-12-12T15:03:58.737Z","comments":true,"path":"2017/12/22-React-projects-open-source.html","link":"","permalink":"http://nthung2112.github.io/2017/12/22-React-projects-open-source.html","excerpt":"This is a collection of open source apps built with React.JS library. In this observation, we compared nearly 1,000 popular React projects to pick the top 22. (React Native: 11, React: 11) React is an open source JavaScript library built by Facebook, providing a view for data rendered as HTML. To evaluate the quality, Mybridge AI considers a variety of factors to determine how useful the projects are for programmers. To give you an idea on the quality, the average number of Github stars from the 22 projects was 3,584. Open source projects can be useful both for beginners to learn from reading the code and for advanced programmers to save time by using the existing code. The aim of this collection is to help you pick a great project right away without having to spend hours of searching.","text":"This is a collection of open source apps built with React.JS library. In this observation, we compared nearly 1,000 popular React projects to pick the top 22. (React Native: 11, React: 11) React is an open source JavaScript library built by Facebook, providing a view for data rendered as HTML. To evaluate the quality, Mybridge AI considers a variety of factors to determine how useful the projects are for programmers. To give you an idea on the quality, the average number of Github stars from the 22 projects was 3,584. Open source projects can be useful both for beginners to learn from reading the code and for advanced programmers to save time by using the existing code. The aim of this collection is to help you pick a great project right away without having to spend hours of searching. Note that React UI components, boilerplates, tools and frameworks are separated out to make this curation more specific to full-working apps built with React. No 1) Redux The Complete React Web Course (2nd Edition): Build apps using Redux, Webpack, React-Router [10,556 recommends, 4.8/5 stars] No 2) React Native The Complete React Native and Redux Course: Build iOS and Android App fast from scratch. [46,695 recommends, 4.6/5 stars] No 3) Beginner React for Beginners. By Wes Bos [14,955 recommends] React native iOS and Android apps that give attendees a schedule for the F8 conference. Courtesy of Alex Kotlyarskiy [11,081 Stars] Hacker News iOS and Android App: Made with React Native. Courtesy of Simar Singh [3,224 Stars] Dribbble app built with React Native. Courtesy of Catalin MIRON [1,778 Stars] Ready-to-use chat interface for iOS and Android React-Native apps. Courtesy of Farid from Safi [4,006 Stars] iOS’s Stocks App clone: Written in React Native available both iOS and Android. Courtesy of kf [1,352 Stars] A Zhihu Daily App client implemented using React Native (Android and iOS). Courtesy of Race604 [3,521 Stars] A Camera app for React Native (also supports barcode scanning). Courtesy of @CharlieHawker [4,248 Stars] Github client written with react-native. Courtesy of David Tse [1,635 Stars] iOS and Android NBA App built with React Native. Courtesy of WangZixiao [1,715 Stars] React Native Reddit Reader. Courtesy of Andrei Hrabouski [323 Stars] FB Basketball game clone built in React.JS Native. Courtesy of Farid from Safi [344 Stars] A Soundcloud client built with React / Redux. Courtesy of Andrew Nguyen [3,888 Stars] Calculator built with React (Website), Electron (Desktop), and React Native (iOS &amp; Android). Courtesy of Benoit VALLON [4,080 Stars] React-color: Color Pickers from Sketch, Photoshop, Chrome &amp; more. Courtesy of Case Sandberg [4,460 Stars] Gatsby: Transform plain text into dynamic blogs and websites using React.js. Courtesy of kylemathews [15,427 Stars] Sentry is cross-platform crash reporting built with React. Courtesy of Armin Ronacher [14,749 Stars] Isomorphic500: A web application featuring photos from 500px, built on express using React and Flux with yahoo/fluxible. Courtesy of gp [1,311 Stars] A React &amp; react-router-powered implementation of Hacker News using its Firebase API. Courtesy of Arthur Stolyar [1,765 Stars] A playground for in-browser interpreters. Built with React/Redux. Courtesy of Mican [659 Stars] Perseus: Khan Academy’s new exercise question editor and renderer built with React [756 Stars] React-based Imgur-like isomorphic demo app. Courtesy of Brandon Tilley [86 Stars] Flatris: Tetris app for Cosmos, built with React. Courtesy of Ovidiu Cherecheș [304 Stars] That’s it for Amazing React Projects. If you like this curation, read best daily articles based on your programming skills on our website Recommend &amp; share..","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"React Component Patterns","slug":"React-Component-Patterns","date":"2017-11-28T03:53:16.000Z","updated":"2017-11-30T14:56:01.140Z","comments":true,"path":"2017/11/React-Component-Patterns.html","link":"","permalink":"http://nthung2112.github.io/2017/11/React-Component-Patterns.html","excerpt":"Stateful x Stateless, Container x Presentational, HOCs, Render Callbacks and moreIt’s been a while since I’ve been working with React — a Facebook library to build user interfaces using JavaScript — and there are a few concepts I wish I knew when I was just starting. This text is an attempt to summarize some patterns I learned during my experience so far — and also may be useful for developers who are just about to enter this awesome component-based world.","text":"Stateful x Stateless, Container x Presentational, HOCs, Render Callbacks and moreIt’s been a while since I’ve been working with React — a Facebook library to build user interfaces using JavaScript — and there are a few concepts I wish I knew when I was just starting. This text is an attempt to summarize some patterns I learned during my experience so far — and also may be useful for developers who are just about to enter this awesome component-based world. Stateful x Stateless ComponentsJust as Stateful and Stateless web services, React components can also hold and manipulate state during application usage (Stateful) — or just be a simple component that takes the input props and returns what to display (Stateless). A simple Stateless button component that depends on props only: And a Stateful counter component example (using Button component): As you can see, the last one’s constructor holds a component state, while the first one is a simple component that renders a text via props. This separation of concerns may look simple but makes Button component highly reusable. Container x Presentational ComponentsWhen working with external data, we can divide components into this two new categories. Containers are responsible to reach data that lives outside React scope, like connecting to Redux or Relay — while Presentational components are free of dependencies from the rest of the app, depending only on its own state or props received. Let’s take a users list as a Presentational component example: This list can be updated using our Container component: This approach divides data-fetching from rendering and also makes UserListreusable. If you want to learn more about this pattern, there’s an awesome article from Dan Abramov explaining it precisely. Higher-Order ComponentsHigher-Order Components — or just HOCs_ — _are useful when you want to reuse a component logic. They are JavaScript functions that take a component as an argument and returns a new component. Let’s say you need to build an expandable menu component that shows some children content when user clicks on it. So, instead of controlling the state on its parent component, you can simply create a generic HOC to handle it: This approach allows us to apply our logic to our ToggleableMenu component using the JavaScript decorator syntax: Now we can pass any children to ToggleableMenu component: If you’re familiar with Redux’s connect or React Router’s withRouter functions, you’re already using HOCs! Render CallbacksAnother great way to make a component logic reusable is by turning your component children into a function — that’s why Render Callbacks are also called Function as Child Components. We can take an example of our expandable menu HOC and rewrite it using the Render Callback pattern: Now we can pass a function as our Toggleable component children: The code above is already using a function as children, but, if we want to reuse it just as we did in our HOC example (multiple menus), we could simply create a new component that uses Toggleable logic: Our brand new ToggleableMenu component is ready to be used: Our Menu component looks exactly the same as our HOC example! This approach is really useful when we want to change the rendered content itself regardless of state manipulation: as you can see, we’ve moved our render logic to our ToggleableMenu children function, but kept the state logic to our Toggleablecomponent!","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"The Front-End Checklist","slug":"The-Front-End-Checklist","date":"2017-11-28T03:36:59.000Z","updated":"2017-11-30T14:56:01.153Z","comments":true,"path":"2017/11/The-Front-End-Checklist.html","link":"","permalink":"http://nthung2112.github.io/2017/11/The-Front-End-Checklist.html","excerpt":"An Exhaustive List of all the Elements you need to have/test Before Launching your Website To Production. The Front-End Checklist is an exhaustive list of all elements you need to have / to test before launching your site / HTML page to production. It is based on Front-End developers’ years of experience, with additions coming from other open-source checklists. David Dias is the main author/creator and posted the guide to GitHub where it has taken off! The guide is also available below. Don’t forget to thank David for an awesome guide!","text":"An Exhaustive List of all the Elements you need to have/test Before Launching your Website To Production. The Front-End Checklist is an exhaustive list of all elements you need to have / to test before launching your site / HTML page to production. It is based on Front-End developers’ years of experience, with additions coming from other open-source checklists. David Dias is the main author/creator and posted the guide to GitHub where it has taken off! The guide is also available below. Don’t forget to thank David for an awesome guide! Table of Contents Head HTML Webfonts CSS Images JavaScript Security Performance Accessibility SEO How To UseAll items in the Front-End Checklist are required for the majority of the projects, but some elements can be omitted or are not essential (in the case of an administration web app, you may not need RSS feed for example). Some resources possess an emoticon to help you understand which type of content / help you may find on the checklist: 📖: documentation or article 🛠: online tool / testing tool 📹: media or video content Head Notes: You can find a list of everything that could be found in the of an HTML document. Meta tag Doctype: The Doctype is HTML5 and is at the top of all your HTML pages. 12&lt;!-- Doctype HTML5 --&gt;&lt;!doctype html&gt; 📖 Determining the character encoding — HTML5 W3C The next 3 meta tags (Charset, X-UA Compatible and Viewport) need to come first in the head. Charset: The charset declared (UTF-8) is declared correctly. 12&lt;!-- Set character encoding for the document --&gt;&lt;meta charset=\"utf-8\"&gt; X-UA-Compatible: The X-UA-Compatible meta tag is present. 12&lt;!-- Instruct Internet Explorer to use its latest rendering engine --&gt;&lt;meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\"&gt; 📖 Specifying legacy document modes (Internet Explorer) Viewport: The viewport is declared correctly. 12&lt;!-- Viewport for responsive web design --&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; Title: A title is used on all pages (SEO: Google calculate the pixel width of the characters used in the title, cut off between 472 and 482 pixels. Average character limit would be around 55-characters). 12&lt;!-- Document Title --&gt;&lt;title&gt;Page Title less than 65 characters&lt;/title&gt; 📖 Title — HTML — MDN 🛠 SERP Snippet Generator Description: A meta description is provided, it is unique and doesn’t possess more than 150 characters. 12&lt;!-- Meta Description --&gt;&lt;meta name=\"description\" content=\"Description of the page less than 150 characters\"&gt; 📖Meta Description — HTML — MDN Favicons: Each favicon has been created and displays correctly. If you have only a favicon.ico, put it at the root of your site. Normally you won’t need to use any markup. However, it’s still good practice to link to it using the example below. Today, PNG format is recommended over .ico format (dimensions: 32x32px). 1234&lt;!-- Standard favicon --&gt;&lt;link rel=\"icon\" type=\"image/x-icon\" href=\"https://example.com/favicon.ico\"&gt;&lt;!-- Recommended favicon format --&gt;&lt;link rel=\"icon\" type=\"image/png\" href=\"https://example.com/favicon.png\"&gt; 🛠 Favicon Generator 🛠 RealFaviconGenerator 📖 Favicon Cheat Sheet 📖 Favicons, Touch Icons, Tile Icons, etc. Which Do You Need? — CSS Tricks 📖 PNG favicons — caniuse Apple Touch Icon: Apple touch favicon apple-mobile-web-app-capable are present. (Create your Apple Icon file with at least 200x200px dimension to support all dimensions that you may need) 12&lt;!-- Apple Touch Icon --&gt;&lt;link rel=\"apple-touch-icon\" href=\"/custom-icon.png\"&gt; 📖 Configuring Web Applications Windows Tiles: Windows tiles are present and linked. 12&lt;!-- Microsoft Tiles --&gt;&lt;meta name=\"msapplication-config\" content=\"browserconfig.xml\" /&gt; Minimum required xml markup for the browserconfig.xml file is as follows: 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;browserconfig&gt; &lt;msapplication&gt; &lt;tile&gt; &lt;square70x70logo src=\"small.png\"/&gt; &lt;square150x150logo src=\"medium.png\"/&gt; &lt;wide310x150logo src=\"wide.png\"/&gt; &lt;square310x310logo src=\"large.png\"/&gt; &lt;/tile&gt; &lt;/msapplication&gt;&lt;/browserconfig&gt; 📖 Browser configuration schema reference Canonical: Use rel=”canonical” to avoid duplicate content. 12&lt;!-- Helps prevent duplicate content issues --&gt;&lt;link rel=\"canonical\" href=\"http://example.com/2017/09/a-new-article-to-red.html\"&gt; 📖 Use canonical URLs — Search Console Help — Google Support 📖 5 common mistakes with rel=canonical — Google Webmaster Blog HTML tags Language attribute: The lang attribute of your website is specified and related to the language of the current page. 1&lt;html lang=\"en\"&gt; Direction attribute: The direction of lecture is specified on the html tag (It can be used on another HTML tag). 1&lt;html dir=\"rtl\"&gt; 📖 dir — HTML — MDN Alternate language: The language tag of your website is specified and related to the language of the current page. 1&lt;link rel=\"alternate\" href=\"https://es.example.com/\" hreflang=\"es\"&gt; Conditional comments: Conditional comments are present for IE if needed. 📖 About conditional comments (Internet Explorer) — MSDN — Microsoft RSS feed: If your project is a blog or has articles, an RSS link was provided. inline critical CSS: CSS which styles content that is immediately visible during pageload (“above the fold content”) is called “critical CSS”. It is embedded before your principal CSS call and between in a single line (minified). 🛠 Critical by Addy Osmani on Github automates this CSS order: All CSS files are loaded before any JavaScript files in the . (Except the case where sometimes JS files are loaded asynchronously on top of your page). Social metaFacebook OG and Twitter Cards are, for any website, highly recommended. The other social media tags can be considered if you target a particular presence on those and want to ensure the display. Facebook Open Graph: All Facebook Open Graph (OG) are tested and no one is missing or with a false information. Images need to be at least 600 x 315 pixels, 1200 x 630 pixels recommended. 1234567&lt;meta property=\"og:type\" content=\"website\"&gt;&lt;meta property=\"og:url\" content=\"https://example.com/page.html\"&gt;&lt;meta property=\"og:title\" content=\"Content Title\"&gt;&lt;meta property=\"og:image\" content=\"https://example.com/image.jpg\"&gt;&lt;meta property=\"og:description\" content=\"Description Here\"&gt;&lt;meta property=\"og:site_name\" content=\"Site Name\"&gt;&lt;meta property=\"og:locale\" content=\"en_US\"&gt; 📖 A Guide to Sharing for Webmasters 🛠 Test your page with the Facebook OG testing Twitter Card: 1234567&lt;meta name=\"twitter:card\" content=\"summary\"&gt;&lt;meta name=\"twitter:site\" content=\"@site_account\"&gt;&lt;meta name=\"twitter:creator\" content=\"@individual_account\"&gt;&lt;meta name=\"twitter:url\" content=\"https://example.com/page.html\"&gt;&lt;meta name=\"twitter:title\" content=\"Content Title\"&gt;&lt;meta name=\"twitter:description\" content=\"Content description less than 200 characters\"&gt;&lt;meta name=\"twitter:image\" content=\"https://example.com/image.jpg\"&gt; 📖 Getting started with cards — Twitter Developers 🛠 Test your page with the Twitter card validator HTMLBest practices HTML5 Semantic Elements: HTML5 Semantic Elements are used appropriately (header, section, footer, main…). 📖 HTML Reference Error pages: Error 404 page and 5xx exist. Remember that the 5xx error pages need to have their CSS integrated (no external call on the current server). Noopener: In case you are using external links with target=”_blank”, your link should have a rel=”noopener” attribute to prevent tab nabbing. If you need to support older versions of Firefox, use rel=”noopener noreferrer”. 📖 About rel=noopener Clean up comments: Unnecessary code needs to be removed before sending the page to production. HTML testing W3C compliant: All pages need to be tested with the W3C validator to identify possible issues in the HTML code. 🛠 W3C validator HTML Lint: I use tools to help me analyze any issues I could have on my HTML code. 🛠 Dirty markup Link checker: There are no broken links in my page, verify that you don’t have any 404 error. 🛠 W3C Link Checker Adblockers test: Your website shows your content correctly with adblockers enabled (You can provide a message encouraging people to disable their adblocker). Webfonts Webfont format: WOFF, WOFF2 and TTF are supported by all modern browsers. 📖 WOFF — Web Open Font Format — Caniuse. 📖 WOFF 2.0 — Web Open Font Format — Caniuse. 📖 TTF/OTF — TrueType and OpenType font support 📖 Using @font-face — CSS-Tricks Webfont size: Webfont sizes don’t exceed 2 MB (all variants included). CSS Notes: Take a look at CSS guidelines and Sass Guidelines followed by most Front-End developers. If you have a doubt about CSS properties, you can visit CSS Reference_._ Responsive Web Design: The website is using responsive web design. CSS Print: A print stylesheet is provided and is correct on each page. Preprocessors: Your page is using a CSS preprocessor (Sass is preferred). Unique ID: If IDs are used, they are unique to a page. Reset CSS: A CSS reset (reset, normalize or reboot) is used and up to date. (If you are using a CSS Framework like Bootstrap or Foundation, a Normalize is already included into it.) 📖 Reset.css 📖 Normalize.css 📖 Reboot JS prefix: All classes (or id- used in JavaScript files) begin with js- and are not styled into the CSS files. 123&lt;div id=\"js-slider\" class=\"my-slider\"&gt;&lt;!-- Or --&gt;&lt;div id=\"id-used-by-cms\" class=\"js-slider my-slider\"&gt; Embedded or inline CSS: Avoid at all cost embeding CSS in &lt;style&gt; tags or using inline CSS: only use for valid reasons (e.g. background-image for slider, critical CSS). Vendor prefixes: CSS vendor prefixes are used and are generated accordingly with your browser support compatibility. 🛠 Autoprefixer CSS online Performance Concatenation: CSS files are concatenated in a single file. (Not for HTTP/2) Minification: All CSS files are minified. Non-blocking: CSS files need to be non-blocking to prevent the DOM from taking time to load. 📖 loadCSS by filament group 📖 Example of preload CSS using loadCSS Unused CSS: Remove unused CSS. 🛠 UnCSS Online 🛠 🛠 PurifyCSS 🛠 Chrome DevTools Coverage CSS testing Stylelint: All CSS or SCSS files are without any errors. 🛠 stylelint, a CSS linter 📖 Sass guidelines Responsive web design: All pages were tested at the following breakpoints: 320px, 768px, 1024px (can be more / different according to your analytics). CSS Validator: The CSS was tested and pertinent errors were corrected. 🛠 CSS Validator Desktop Browsers: All pages were tested on all current desktop browsers (Safari, Firefox, Chrome, Internet Explorer, EDGE…). Mobile Browsers: All pages were tested on all current mobile browsers (Native browser, Chrome, Safari…). OS: All pages were tested on all current OS (Windows, Android, iOS, Mac…). Pixel perfect: Pages are close to pixel perfect. Depending on the quality of the creatives, you may not be 100% accurate, but your page needs to be close to your template. Pixel Perfect — Chrome Extension Reading direction: All pages need to be tested for LTR and RTL languages if they need to be supported. 📖 Building RTL-Aware Web Apps &amp; Websites: Part 1 — Mozilla Hacks 📖 Building RTL-Aware Web Apps &amp; Websites: Part 2 — Mozilla Hacks Images Notes: For a complete understanding of image optimization, check the free ebook Essential Image Optimizationfrom Addy Osmani. Best practices Optimization: All images are optimized to be rendered in the browser. WebP format could be used for critical pages (like Homepage). 🛠 Imagemin 🛠 Use ImageOptim to optimise your images for free. Picture/Srcset: You use picture/srcset to provide the most appropriate image for the current viewport of the user. 📖 How to Build Responsive Images with srcset Retina: You provide layout images 2x or 3x, support retina display. Sprite: Small images are in a sprite file (in the case of icons, they can be in an SVG sprite image). Width and Height: Set width and height attributes on if the final rendered image size is known (can be omitted for CSS sizing). Alternative text: All have an alternative text which describe the image visually. 📖 Alt-texts: The Ultimate Guide Lazy loading: Images are lazyloaded (A noscript fallback is always provided). JavaScriptBest practices JavaScript Inline: You don’t have any JavaScript code inline (mixed with your HTML code). Concatenation: JavaScript files are concatenated. Minification: JavaScript files are minified (you can add the .min suffix). 📖 Minify Resources (HTML, CSS, and JavaScript) JavaScript security: 📖 Guidelines for Developing Secure Applications Utilizing JavaScript Non-blocking: JavaScript files are loaded asynchronously using async or deferred using defer attribute. 📖 Remove Render-Blocking JavaScript Modernizr: If you need to target some specific features you can use a custom Modernizr to add classes in your tag. 🛠 Customize your Modernizr JavaScript testing ESLint: No errors are flagged by ESLint (based on your configuration or standards rules). 📖 ESLint — The pluggable linting utility for JavaScript and JSX SecurityScan and check your web site securityheaders.io Observatory by Mozilla ASafaWeb — Automated Security Analyser for ASP.NET Websites Best practices HTTPS: HTTPS is used on every pages and for all external content (plugins, images…). 🛠 Let’s Encrypt — Free SSL/TLS Certificates 🛠 Free SSL Server Test 📖 Strict Transport Security HTTP Strict Transport Security (HSTS): The HTTP header is set to ‘Strict-Transport-Security’. 🛠 Check HSTS preload status and eligibility 📖 HTTP Strict Transport Security Cheat Sheet — OWASP 📖 Transport Layer Protection Cheat Sheet — OWASP Cross Site Request Forgery (CSRF): You ensure that requests made to your server-side are legitimate and originate from your website / app to prevent CSRF attacks. 📖 Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet — OWASP Cross Site Scripting (XSS): Your page or website is free from XSS possible issues. 📖 XSS (Cross Site Scripting) Prevention Cheat Sheet — OWASP 📖 DOM based XSS Prevention Cheat Sheet — OWASP Content Type Options: Prevents Google Chrome and Internet Explorer from trying to mime-sniff the content-type of a response away from the one being declared by the server. 📖 X-Content-Type-Options — Scott Helme X-Frame-Options (XFO): Protects your visitors against clickjacking attacks. 📖 X-Frame-Options — Scott Helme 📖 RFC7034 — HTTP Header Field X-Frame-Options PerformanceBest practices Weight page: The weight of each page is between 0 and 500 KB. 🛠 Website Page Analysis 📖 Size Limit: Make the Web lighter Minified: Your HTML is minified. 🛠 W3C Validator Lazy loading: Images, scripts and CSS need to be lazy loaded to improve the response time of the current page (See details in their respective sections). Cookie size: If you are using cookies be sure each cookie doesn’t exceed 4096 bytes and your domain name doesn’t have more than 20 cookies. 📖 Cookie specification: RFC 6265 📖 Cookies 🛠 Browser Cookie Limits Third party components: Third party iframes or components relying on external JS (like sharing buttons) are replaced by static components when possible, thus limiting calls to external APIs and keeping your users activity private. 🛠 Simple sharing buttons generator Preparing upcoming requests 📖 Explanation of the following techniques DNS resolution: DNS of third-party services that may be needed are resolved in advance during idle time using dns-prefetch. 1&lt;link rel=\"dns-prefetch\" href=\"https://example.com\"&gt; Preconnection: DNS lookup, TCP handshake and TLS negociation with services that will be needed soon is done in advance during idle time using preconnect. 1&lt;link rel=\"preconnect\" href=\"https://example.com\"&gt; Prefetching: Resources that will be needed soon (e.g. lazy loaded images) are requested in advance during idle time using prefetch. 1&lt;link rel=\"prefetch\" href=\"image.png\"&gt; Preloading: Resources needed in the current page (e.g. scripts placed at the end of ) in advance using preload. 1&lt;link rel=\"preload\" href=\"app.js\"&gt; 📖 Difference between prefetch and preload Performance testing Google PageSpeed: All your pages were tested (not only the homepage) and have a score of at least 90/100. 🛠 Google PageSpeed 🛠 Test your mobile speed with Google 🛠 WebPagetest — Website Performance and Optimization Test Accessibility Notes: You can watch the playlist A11ycasts with Rob Dodson _📹_ Best practices Progressive enhancement: Major functionality like main navigation and search should work without JavaScript enabled. 📖 Enable / Disable JavaScript in Chrome Developer Tools Color contrast: Color contrast should at least pass WCAG AA (AAA for mobile). 🛠 Contrast ratio Headings H1: All pages have an H1 which is not the title of the website. Headings: Headings should be used properly in the right order (H1 to H6). 📹 Why headings and landmarks are so important — A11ycasts #18 Landmarks Role banner: has role=”banner”. Role navigation: has role=”navigation”. Role main: has role=”main”. 📖 Using ARIA landmarks to identify regions of a page Semantics Specific HTML5 input types are used: This is especially important for mobile devices that show customized keypads and widgets for different types. 📖 Mobile Input Types Form Label: A label is associated with each input form element. In case a label can’t be displayed, use aria-labelinstead. 📖 Using the aria-label attribute — MDN Accessibility testing Accessibility standards testing: Use the WAVE tool to test if your page respects the accessibility standards. 🛠 Wave testing Keyboard navigation: Test your website using only your keyboard in a previsible order. All interactive elements are reachable and usable. Screen-reader: All pages were tested in a screen-reader (VoiceOver, ChromeVox, NVDA or Lynx). Focus style: If the focus is disabled, it is replaced by visible state in CSS. 📹 Managing Focus — A11ycasts #22 SEO Google Analytics: Google Analytics is installed and correctly configured. Headings logic: Heading text helps to understand the content in the current page. sitemap.xml: A sitemap.xml exists and was submitted to Google Search Console (previously Google Webmaster Tools). robots.txt: The robots.txt is not blocking webpages. 🛠 Test your robots.txt with Google Robots Testing Tool Structured Data: Pages using structured data are tested and are without errors. Structured data helps crawlers understand the content in the current page. 📖 Introduction to Structured Data — Search — Google Developers 🛠 Test your page with the Structured Data Testing Tool 🛠 Complete list of vocabularies that can be used as structured data. Schema.org Full Heirarchy Sitemap HTML: An HTML sitemap is provided and is accessible via a link in the footer of your website. 📖 Sitemap guidelines — Google Support 🛠 Sitemap generator","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"front-end","slug":"front-end","permalink":"http://nthung2112.github.io/tags/front-end/"}]},{"title":"Nghiên cứu cải thiện tốc độ web app với React và Preact: Treebo","slug":"Nghien-cuu-cai-thien-toc-do-web-app-voi-React-va-Preact-Treebo","date":"2017-11-15T01:26:38.000Z","updated":"2017-11-15T01:33:31.147Z","comments":true,"path":"2017/11/Nghien-cuu-cai-thien-toc-do-web-app-voi-React-va-Preact-Treebo.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Nghien-cuu-cai-thien-toc-do-web-app-voi-React-va-Preact-Treebo.html","excerpt":"Treebo is India’s top rated budget hotel chain, operating in a segment of the travel industry worth $20 billion. They recently shipped a new Progressive Web App as their default mobile experience, initially using React and eventually switching to Preact in production. What they saw compared to their old mobile site was a 70%+ improvement in time to first paint , 31% improvement in time-to-interactive. and loaded in under 4 seconds over 3G for many typical visitors and on their target hardware. It was interactive in under 5s using WebPageTest’s slower 3G emulation in India.","text":"Treebo is India’s top rated budget hotel chain, operating in a segment of the travel industry worth $20 billion. They recently shipped a new Progressive Web App as their default mobile experience, initially using React and eventually switching to Preact in production. What they saw compared to their old mobile site was a 70%+ improvement in time to first paint , 31% improvement in time-to-interactive. and loaded in under 4 seconds over 3G for many typical visitors and on their target hardware. It was interactive in under 5s using WebPageTest’s slower 3G emulation in India. Switching from React to Preact was responsible for a 15% improvement in time-to-interactive alone. You can check out Treebo.com for their full experience but today we would like to dive into some of the technical journey that made shipping this PWA possible. Treebo’s Progressive Web App A Performance JourneyThe old mobile siteTreebo’s old mobile site was powered by a monolithic Django setup. Users had to wait for a server side request for every page transition on the website. This original setup had a first paint time of 1.5s, a first meaningful paint time of 5.9s and was first interactive in 6.5s. A basic single-page React appFor their first iteration of the rewrite Treebo started off with a Single Page Application built using React and a simple webpack setup. You can take a look at the actual code used below. This generates some simple (monolithic) JavaScript and CSS bundles. This experience had a first paint of 4.8s, was first interactive in about 5.6s and their meaningful header images painted in about 7.2s. Server-side RenderingNext, they went about optimizing their first paint a little so they tried out Server-side Rendering. It’s important to note, server side rendering is not free. It optimizes one thing at the cost of another. With server-side rendering, your server’s response to the browser is the HTML of your page that is ready to be rendered so the browser can start rendering without having to wait for all the JavaScript to be downloaded and executed. Treebo used React’s renderToString() to render components to an HTML string and injecting state for the application on initial boot up. In Treebos’ case, using server side rendering dropped their first paint time to 1.1s and first meaningful paint time down to 2.4s — this improved how quickly users perceived the page to be ready, they could read content earlier on and it performed slightly better at SEO in tests. But the downside was that it had a pretty negative impact on time to interactive. Although users could view content, the main thread got pegged while booting up their JavaScript and just hung there. With SSR, the browser had to fetch and process a much larger HTML payload than before and then still fetch, parse/compile and execute the JavaScript. It was effectively doing more work. This meant that first interactive happened about 6.6s, regressing. SSR can also push TTI back by locking up the main thread on lower-end devices. Code-splitting &amp; route-based chunkingThe next thing Treebo looked at was route-based chunking to help bring down their time-to-interactive numbers. Route-based chunking aims to serve the minimal code needed to make a route interactive, by code-splitting the routes into “chunks” that can be loaded on demand. This encourages delivering resources closer to the granularity they were authored in. What they did here was they split out their vendor dependencies, their Webpack runtime manifests and their routes — into separate chunks. This reduced the time to first interactive down to 4.8s. Awesome! The only downside was that it started the current route’s JavaScript download only after their initial bundles were done executing, which was also not ideal. But it did at least have some positive impact on the experience. For route-based code-splitting and this experience, they’re doing something a little bit more implicit. They’re using React Router’s declarative support for getComponent with a webpack import() call to asynchronously load in chunks. The PRPL Performance PatternRoute-based chunking is a great first step in intelligently bundling code for more granular serving and caching. Treebo wanted to build on this and looked to the PRPL patternfor inspiration. PRPL is a pattern for structuring and serving PWAs, with an emphasis on the performance of app delivery and launch. PRPL stands for: Push critical resources for the initial URL route. Render initial route. Pre-cache remaining routes. Lazy-load and create remaining routes on demand. A PRPL visualization by Jimmy Moon The “Push” part encourages serving an unbundled build designed for server/browser combinations that support HTTP/2 to deliver the resources the browser needs for a fast first paint while optimizing caching. The delivery of these resources can be triggered efficiently using or HTTP/2 Push. Treebo opted to use to preload the current route’s chunk ahead of time. This had the impact of dropping their first interactive times since the current route’s chunk was already in the cache when webpack made a call to fetch it after their initial bundles finished executing. It shifted the time down a little bit and so the first interactive happened at the 4.6s mark. The only con they had with preload is that it’s not implemented cross-browser. However, there’s an implementation of link rel preload in Safari Tech Preview. I’m hopeful that it’s going to land and stick this year. There’s also work underway to try landing it in Firefox. HTML Streaming One difficulty with renderToString() is that it is synchronous, and it can become a performance bottleneck in server-side rendering of React sites. Servers won’t send out a response until the entire HTML is created. When web servers stream out their content instead, browsers can render pages for users before the entire response is finished. Projects like react-dom-stream can help here. To improve perceived performance and introduce a sense of progressive rendering to their app, Treebo looked to HTML Streaming. They would stream the head tag with link rel preload tags set up to early preload in their CSS and their JavaScripts. They then perform their server side rendering and send the rest of the payload down to the browser. The benefit of this was that resource downloads started earlier on, dropping their first paint to 0.9s and first interactive to 4.4s. The app was consistently interactive around the 4.9/5 second mark. The downside here was that it kept the connection open for a little bit longer between the client and server, which could have issues if you run into longer latency times. For HTML streaming, Treebo defined an early chunk with the content, then they have the main content and the late chunks. All of these being injected into the page. This is what it looks like: Effectively, the early chunk has got their rel=preload statements for all of their different script tags. The late chunk has got the server rendered html and anything that’s going to include state or actually use the JavaScript that’s being loaded in. Inlining critical-path CSS CSS Stylesheets can block rendering. Until the browser has requested, received, downloaded and parsed your stylesheets, the page can remain blank. By reducing the amount of CSS the browser has to go through, and by inlining (critical-path styles) it on the page, thus removing a HTTP request, we can get the page to render faster. Treebo added support for Inlining their critical-path CSS for the current route and asynchronously loading in the rest of their CSS using loadCSS on DOMContentLoaded. It had the effect of removing the critical-path render blocking link tag for stylesheets and inlining fewer lines of core CSS, improving first paint times to about 0.4s. The downside was that time to first interactive went up a bit to 4.6s as the payload size was larger with inline styles and took time to parse before JavaScript could be executed. Offline-caching static assets A Service Worker is a programmable network proxy, allowing you to control how network requests from your page are handled. Treebo added support for Service Worker caching of their static assets as well a custom offline page. Below we can see their Service Worker registration and how they used sw-precache-webpack-plugin for resource caching” Caching static assets like their CSS and JavaScript bundles means pages load up (almost) instantly on repeat visits as they load from the disk cache rather than having to go back out to the network each time. Diligently defined caching headers can have this same effect with respect to disk cache hit-rates, but it’s Service Worker that gives us offline support. Serving JavaScript cached using Service Worker using the Cache API (as we covered in JavaScript Start-up Performance) also has the nice property of early-opting Treebo into V8’s code cache so they save a little time on start-up during repeat visits. Next, Treebo wanted to try getting their vendor bundle-size and JS execution time down, so they switched from React to Preact in production. Switching from React to PreactPreact is a tiny 3KB alternative to React with the same ES2015 API. It aims to offer high performance rendering with an optional compatibility later (preact-compat) that works with the rest of the React ecosystem, like Redux. Part of Preact’s smaller size comes from removing Synthetic Events and PropType validations. In addition it: Diffs Virtual DOM against the DOM Allows props like class and for Passes (props, state) to render Uses standard browser events Supports fully async rendering Subtree invalidation by default In a number of PWAs, switching to Preact has led to smaller JS bundle sizes and lower initial JavaScript boot-up times for the application. Recent PWA launches like Lyft, Uber and Housing.com all use Preact in production. Note: Working with a React codebase and want to use Preact? Ideally, you should use preact and preact-compat for your dev, prod and test builds. This will enable you to discover any interop bugs early on. If you would prefer to only alias preact and preact-compat in Webpack for production builds (e.g if your preference is using Enzyme), make sure to thoroughly test everything works as expected before deploying to your servers. In Treebo’s case, this switch had the impact of dropping their vendor bundle sizes from 140kb all the way down to 100kb. This is all gzipped, by the way. It dropped first interactive times from 4.6s to 3.9s on Treebo’s target mobile hardware which was a net win. You can do this in your Webpack config by aliasing react to preact-compat, and react-dom to preact-compat as well. The downside to this approach was that they did have to end up putting together a few workarounds in order to get Preact working exactly with all the different pieces of the React ecosystem that they wanted to use. Preact tends to be a strong choice for the 95% of cases you would use React; for the other 5% you may end up needing to file bugs to work around edge-cases that are not yet factored in. Notes: As WebPageTest does not currently offer a way to test real Moto G4s directly from India, performance tests were run under the “Mumbai — EC2 — Chrome — Emulated Motorola G (gen 4) — 3GSlow — Mobile” setting. Should you wish to look at these traces they can be found here_._ Skeleton screens “A skeleton screen is essentially a blank version of a page into which information is gradually loaded.” ~Luke Wroblewski Treebo like to implement their skeleton screens using preview enhanced components (a little like skeleton screens for each component). The approach is basically to enhance any atomic component (Text, Image etc) to have a preview version, such that if the source data that is required for the component is not present, it shows the preview version of the component instead. For example, if you look at the hotel name, city name, price etc in the list items above, they’re implemented using Typography components like which take two extra props, preview and previewStyle which is used like so. Basically, if the hotel.name does not exist then the component changes the background to a greyish color with the width and other styles set according to the previewStyle passed down (width defaults to 100% if no previewStyle is passed). Treebo likes this approach because the logic to switch to the preview mode is independent of the data actually being shown which makes it flexible. If you look at the “Incl. of all taxes” part, it’s just static text, which could have been shown right at the start but that would’ve looked very confusing to the user since the prices are still loading during the api call. So to get the static text “Incl. of all prices” into a preview mode alongside the rest of the ui they just use the price itself as the logic for the preview mode. This way while the prices are loading you get a preview UI and once the api succeeds you get to see the data in all its glory. Webpack-bundle-analyzerAt this point, Treebo wanted to perform some bundle analysis to look at what other low-hanging fruit they could optimize. Note: If you’re using a library like React on mobile, it’s important to be diligent about the other vendor libraries you are pulling in. Not doing so can negatively impact performance. Consider better chunking your vendor libraries so that routes only load those that are needed Treebo used webpack-bundle-analyzer to keep track of their bundle size changes and to monitor what modules are contained in each route chunk. They also use it to find areas where they can optimize to reduce bundle sizes such as stripping moment.js’ locales and reusing deep dependencies. Optimizing moment.js with webpackTreebo relies heavily on moment.js for their date manipulations. When you import moment.js and bundle it with Webpack, your bundle will include all of moment.js and it’s locales by default which is ~61.95kb gzipped. This seriously bloats your final vendor bundle size. To optimize the size of moment.js, there are two webpack plugins available: IgnorePlugin, ContextReplacementPlugin Treebo opted to remove all locale files with the IgnorePlugin since they didn’t need any of the them. new webpack.IgnorePlugin(/^.\\/locale$/, /moment$/) With the locales stripped out, the moment.js’ bundled size dropped to ~16.48kb gzipped. The biggest improvement as a side effect of stripping out moment.js’ locales was that the vendor bundle size dropped from ~179kb to ~119kb. That’s a massive 60kb drop from a critical bundle that has to be served on first load. All this translates to a considerable decrease in first interaction times. You can read more about optimizing moment.js here. Reusing existing deep dependenciesTreebo was initially using the “qs” module to perform query string operations. Using the webpack-bundle-analyzer output they found that “react-router” included the “history” module which in-turn included the “query-string” module. Since there were two different modules both accomplishing the same operations, replacing “qs” with this version of “query-string” (by installing it explicitly) in their source code, dropped their bundle size by a further 2.72kb gzipped (size of the “qs” module). Treebo have been good open source citizens. They’ve been using a lot of open source software. In return, they’ve actually open sourced most of their Webpack configuration, as well as a boilerplate that contains a lot of the set up they’re using in production. You can find that here: https://github.com/lakshyaranganath/pwa They’ve also committed to trying to keep that up to date. As they evolve you can take advantage of them as another PWA reference implementation. Conclusions and the futureTreebo knows that no application is perfect, they actively explore many methods to keep improving the experience they deliver to their users. Some of which are: Lazy Loading ImagesSome of you might have figured out from the network waterfall graphs before that the website image downloads are competing for bandwidth with the JS downloads. Since image downloads are triggered as soon as the browser parses the img tags, they share the bandwidth during JS downloads. A simple solution would be lazy loading images only when they come into the user’s viewport, this will see a good improvement in our time to interactive. Lighthouse highlights these problems well in the offscreen images audit: Dual Importing Treebo also realise that while they are asynchronously loading the rest of the CSS for the app (after inlining the critical css), this approach is not viable for their users in the long run as their app grows. More features and routes means more CSS, and downloading all of that leads to bandwidth hogging and wastage. Merging approaches followed by loadCSS and babel-plugin-dual-import, Treebo changed their approach to loading CSS by using an explicit call to a custom implemented importCss(‘chunkname’) to download the CSS chunk in parallel to their import(‘chunkpath’) call for their respective JS chunk. With this new approach, a route transition results in two parallel asynchronous requests, one for JS and the other for CSS unlike the previous approach where all of the CSS was being downloaded on DOMContentLoaded. This is more viable since a user will only ever download the required CSS for the routes they are visiting. A/B Testing Treebo are currently implementing an AB testing approach with server side rendering and code splitting so as to only push down the variant that user needs during both server and client side rendering. (Treebo will follow up with a blog post on how they tackled this). Eager Loading Treebo ideally don’t want to always load all the split chunks of the app on load of the initial page since they want to avoid the bandwidth contention for critical resource downloads — this also wastes precious bandwidth for mobile users especially if you’re not caching it with service-worker for their future visits. If we look at how well Treebo is doing on metrics like consistently interactive, there’s still much room for improvement: This is an area they’re experimenting with improving. One example is eager loading the next route’s chunk during the ripple animation of a button. onClick Treebo make a webpack dynamic import() call to the next route’s chunk entry and delay the route transition with a setTimeout. They also want to make sure that the next route’s chunk is small enough to be downloaded within the given 400ms timeout on a slow 3g network. That’s a wrap.It’s been fun collaborating on this write-up. There’s obviously more work to be done, but we hope you found Treebo’s performance journey an interesting read :) You can find us over on twitter at @addyosmani and @__lakshya (yep, double underscore xD) we would love to hear your thoughts. With thanks to _@zouhir_,_ _@developit and @samcccone for their reviews and input.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"preact","slug":"preact","permalink":"http://nthung2112.github.io/tags/preact/"}]},{"title":"Cách chính xác 100% để cấu trúc ứng dụng React","slug":"Cach-chinh-xac-100-de-cau-truc-ung-dung-React","date":"2017-11-13T16:51:55.000Z","updated":"2017-11-15T01:22:22.141Z","comments":true,"path":"2017/11/Cach-chinh-xac-100-de-cau-truc-ung-dung-React.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Cach-chinh-xac-100-de-cau-truc-ung-dung-React.html","excerpt":"When it comes to structuring a React app, the ideal structure is the one that allows you to move around your code with the least amount of effort. In this post, I’d like to tell you how _I_ structure my React apps, and what drove my decisions. Along the way I’ll mention some options I don’t use because they don’t suit me, but that might serve you well. I’d also like to hear how you do things and what you’ve found works well down in the comments.","text":"When it comes to structuring a React app, the ideal structure is the one that allows you to move around your code with the least amount of effort. In this post, I’d like to tell you how _I_ structure my React apps, and what drove my decisions. Along the way I’ll mention some options I don’t use because they don’t suit me, but that might serve you well. I’d also like to hear how you do things and what you’ve found works well down in the comments. What works for youMaybe this was always obvious to you, but it’s only just clicked for me: the structure of an app has nothing to do with computers. Imagine for a moment an app with only one file for all your components, reducers, the store, utilities, everything. A terrible idea, of course. Now, have a think about why the above would be a bad thing. We both know you didn’t really stop and ponder, so I’ll just tell you what I think. The problem with this giant file is that it’s going to be difficult to navigate. But what if you could have bookmarks for each area of the code, maybe one bookmark per function. Maybe the ability to have nested bookmarks. How about a table of contents for all of these bookmarks? This might seem like a daft thought experiment, but I think it’s worth establishing that the only thing you’re trying to do when deciding on a file structure is to maximise how easily you can navigate through your code. Your ‘files’ are nothing more than markers to parts of the code that will wind up being a single chunk of JS at the end of the day. And this is why you can never get a straight answer to the question “what’s the best way to structure my app” — it depends so much on your own navigation habits and preferences that it’s not a question anyone else can answer for you. To work out what the 100% correct application structure was for me, I set out to quantify my most common code-related activities: Create a new component. Usually this is a copy/paste of some existing component. Import one module into another. Here I mean the actual typing out of import { SomeComponent } from ‘../blah/de/blah.js’;. Jump to source. This is when I’m looking at a file, and it has a reference to something external, say a component, and I jump to where that component is defined. Open a known file. Probably doesn’t need a description, but I want my bullet points to look nice and uniform, so this is where I think in my head “I want to open the header nav”, so I use a keyboard shortcut and type the file name to open it. Dammit, now this is the bullet point with the longest description and it didn’t even need one in the first place. Browse for a file I don’t know the name of. Maybe I didn’t work on the little widget that shows the drop down below the user profile photo and don’t know what it’s called. So I want to go browsing the directory structure for this component. Change tab to another open file. This is exactly what it sounds like. I currently have 7 files open, and I want to switch from one tab to another, by clicking on a tab name (or using the keyboard). Next, I had a think about how often I do each of these things. I went back and counted the components I’ve created in the last year, the average number of imports per file, and took some wild guesses at the others, to come up with the following: Sorted by the order that I thought of the things With this data in my hot little hands, I was ready to objectively look at all the aspects of structuring a React app. Let us go through them one by one. Directory structureAs a general rule, if a module (a utility, component, etc.) is only used within another module, then I want it nested in the directory structure like so: &lt;HeaderNav&gt; will only be referenced from within the &lt;Header&gt; component, so it lives as a child. A &lt;Button&gt; could be referenced from anywhere, so it lives at the top level. That rule is great, but I also know that following a super strict set of rules here can be annoying. Technically everything resides under App and under Page too. But I’m not going to represent that in my directory structure, because I don’t want to. This might sound flippant but it’s quite fundamental. If following your own rules creates a structure that is harder to navigate, you’ve taken your eyes off the prize. Outside of components, I don’t think directory structure is very important. You can agonise over whether your reducers and your action creators should be in the same directory as your services until you’re a shade of blue. But if you ask me, any basic structure with sane folder names (actionCreators, reducers, data, etc.) is all you need. This may be the first point where we differ in our needs and wants. I have established that I rarely open files by browsing through a directory structure, so naturally I apply a lower importance to directory structures. I’ve also never worked on a project with more than a few hundred components. If you rely more heavily on navigating a directory structure, or you’re Facebook with 30,000 components, then your needs will likely vary. Another thing: I would suggest naming your components in a ‘fully qualified’ (and globally unique) way. For example, HeaderNav is inside Header, so you could argue that it could just be named Nav. If that suits you, cool. But I open files by typing their names, and look at the text on tabs to switch files. In both these cases, having a fully qualified name is useful. And of course if you’re following BEM where the block matches the component name, you’re going to need globally unique component names anyway. What about container components?Container components are a tricky one, because they’re sort of components, but sort of not. I see two broad approaches to fitting container components into your structure: Treat them exactly like presentational components Leave them out of the directory structure. They will live ‘in the background’, just providing data to a component In the first case, you would actually reference the container component in your markup. So, with the example of a header component that has its own container, it might be included like so: So here I’m passing through some specific data to the and components, while it’s quite clear that the is going to look after its own data needs. If this is how you roll, the logical structure will be something like this: The second option is to leave container components out of the structure; to think of them like implementation details of the component that they wrap. So maybe your would wrap itself in a container component at the point of export. Something like this: And then you reference it like this: The downside is that it isn’t immediately clear that will be provided data from somewhere else. The upside is one less step in the component hierarchy. If this is how you want to do things, you can then just have the container as a function that lives in the same directory as the component it provides data to: (Also note that I exported the ‘raw’ Header as well as the default export of the container-wrapped Header. The former is for unit tests, and your linter might tell you that you’re being confusing by exporting a non-default constant with the same name as the file. I tend to agree with the linter.) I have used the first approach in a medium sized project and it worked quite well. I recently tried out the second example in a new project (that only has 6 container components) and it didn’t quite feel right, so I’ll stick with the first option. I see no problem with either approach. Side note: I think there’s a fine art to recognising the point at which it makes sense to say “you know what, it doesn’t really matter” and moving on with your day. This article nails it and is a nice short read. (Warning: there’s a swear word in the title of that article, so don’t click the link if you’re offended by the word fuck.) Self-contained componentsMy rule: if I have a project with more components than a Klein bottle has sides, I put each component in a directory along with a CSS file and a test. This rule is common for good reason, but even if you do have everything neatly tucked away in the same directory, you’re still quite free to make one huge mistake… Take a look at your nearest file that contains a component. At the top of that file you will probably see a list of all other files that the component relies on as a neat set of imports. Unless, that is, you share CSS classes between components. Then you also have a bunch of dependencies that aren’t listed. Sure, you will save 7 seconds by using that .modal-wrapper class in your component because it already had the shadow you wanted, but oh boy do you even know the world of pain that you have just inflicted upon your future self… [deleted scene: 14 paragraph rant about why this is a bad idea] Trying to convince some people to not share CSS classes between components is like trying to convince people to “avoid using global variables in JavaScript” or “vaccinate your chickens” — some folks just aren’t gonna listen. CSS-module users are no doubt wiggling their butts feeling pretty darn pleased with themselves right now. And they have good reason to be — they have a setup that can enforce the explicit import of CSS classes. If you care about keeping your CSS tightly coupled with your components, you should be using CSS modules too. File namingOne rule that I find immensely useful is this: name your file the same as the thing you’re exporting from that file To some this is not even worth typing out it’s so obvious. But I’ve seen plenty of code where this isn’t the case and boy does it make it slow to move around. (Don’t forget, all of this is personal. When I say “slow to move around”, it’s totally OK for you to think “it wouldn’t make it slow for me”, and therefore decide that there is no point in naming a file the same as its default export.) Something I do very often is open a file by typing its name. If I have a utility function called toString then I fully expect that I will have a file called toString that I can open by typing exactly that. Something else that I do very often is switch tabs to a file that I already have open. For this I’ll expect that tab to have “toString.js” as it’s name. Structures like the below make me want to curl up in a ball in a fireplace that is in use: It staggers me that some people are happy to work like this. Even if your IDE is clever and puts the directory in the tab name for non-unique filenames, you still have a bunch of redundancy there, and will run out of tab room sooner, and you still can’t type the filename to open it. I don’t even need to try this approach to know I won’t like it. Like my cousin’s new band, Mass Spectrometer that “don’t really fit into any known genre”. Get someone else to drive you to the gig. Having said that, I understand that there is reasoning behind this — it means your import statement is this: 1**import** Link **from** '../Link'; Instead of this: 1**import** Link **from** '../Link/Link'; It’s a clear trade-off. Shorter import statements vs file names that match exports. Let’s me just look this up… I import a module into another module, on average, 18 times a week. I open a file by typing its name roughly 840 times a week, and I look for a name on a tab roughly 1,892 times a week. So I’ll take one extra (auto-completed) word in my import path, thanks. Savvy readers will be shouting at their screens: there are two solutions to this that allow you have the file name match the thing being exported, and avoid having to type it twice in the import statement. The first is to put an index.js file in every directory that exports a component, like so: Since Node will look for an index.js file when resolving an import path, a path to ../Link is really a path to ../Link/index.js which is a file that points to the actual component file. If typing fewer characters in your imports is important, then maybe an extra file for every directory sounds like good value. I think it’s a bad deal and I will repeat one more time that it’s seriously OK to have a different opinion on the matter. The second ‘solution’ is this monstrosity: By this point you will know that if Node doesn’t find ../Link/index.js it’s going to check to see if ../Link/package.json exists. If it does, it’s going to resolve to the value of the main property. I think you have to really really hate typing one extra word in your import statements to go as far as creating a package.json file for every component. It’s just weird. And the more weird shit you put in your code, the weirder you become. These two types of ‘redirecting’ files both mean that your import statement no longer points to the file where the thing is defined. In the olden days, this would break the ability to ‘jump to source’ — something that is crucial to me being able to move throughout my code with ease and speed. WebStorm is clever and will resolve these hops (it will ‘know’ that I don’t want to jump into the index.js file, I want to jump all the way to the Link.js file), but if your text editor isn’t so clever, this might leave you with a lot of index.js files open, or jumping to source might not work at all. So before subscribing to an approach, try it out and see if it’s going to be a hindrance to the way you work. .js vs .jsx extensionsUntil recently I’d always used .jsx extensions for any file that contained JSX, and used .js for anything that was vanilla JavaScript. This gave a clear distinction when opening/viewing files and as a bonus, you’ll get proper JSX syntax highlighting in GitHub. However Facebook suggests not using the .jsx extension, so I’ve recently been using just .js and I’m glad I didn’t waste too much time weighing the pros and cons because it makes zero difference to me. I recommend flipping a coin to decide. Index files for utilsAs a result of writing this article, and really thinking about what matters to me, I have actually made a change to one small aspect of my personal preference for app structure. I used to create an index.js file for my utils, like so: So that I could import multiple utilities in one go like this: So neat! Whenever I added a new util (0.8 times per week) I would simply add the util file and a new entry in the index file. Whenever I saw a PR that added a util and forgot to add it to index.js I would remind the developer to add that in. I would also occasionally discover utilities that weren’t in index.js, so would have to add them myself. Such an elegant solution. For some reason it took until September 2017 for me to realise that this only added complexity. And that actually ditching the index.js and doing this was better: It’s fewer lines, one less file, and one less thing to explain to new developers. But those long import paths burn my eyes, so let’s take a look at a couple of solutions. There are two of them, as is often the case with couples. Solution one is to use Webpack’s alias resolving to refer to my utils directory without a relative path. Here I’ve mapped Utils to src/app/utils; the result is pretty, and aligns nicely with the way I import other utilities. Capital ‘U’ by convention to differentiate it from npm packages In the olden days this would confuse some text editors because they wouldn’t know what or where Utils/formatDate was. My IDE is clever and reads my Webpack config (it actually runs webpack under the hood), and makes the connection to the correct file (so I can jump to source, get autocomplete, etc). (The theme continues: the tools we use and the way we use them should most definitely be taken into account when thinking about how to structure our apps.) So… it’s a beautiful, neat, solution. But what’s behind the scenes? This is a nice solution but it has two negative impacts. It adds complexity. We now have more moving parts to achieve the exact same outcome. It reduces clarity. Someone unfamiliar with your Webpack config can’t look at an import statement and know what it’s referring to. The second solution is to convince myself that I don’t care about the dots and leave them as they are. To convince myself, I thought about how often I type out an import path, and as it turns out it’s exactly as often as I make coffee. Then I thought about how really, it’s not so hard to type eight dots and five slashes, compared to the time it takes to put the little coffee pod in the machine, measure out a teaspoon of sugar into a cup, milk the cow just a little bit (shout out to Daisy) and press the picture of a cup. The trade-offs between these two options are representative of many different decisions (in life, and in programming), so this feels like a good time to debut my clarity/obscurity-simplicity/complexity matrix. ClObSiCo for short For me, the decision between these two is a close call. In the end though, I will favour clarity and simplicity wherever possible, so even though having ../../../../ in an import statement is an eyesore, it is the clear and simple winner. Index files for componentsIt’s not my cup of tea, but another thing you might like to do in the battle against the import dots is to create a library for your components. Maybe this gets your motor running: You already know how to do this in your Webpack config: Then in your components directory add an index.js file with a row for each component like so: Boom. n exports per fileHaving one export per file — where the thing being exported and the filename are the same — works a lot of the time and I think is a good general rule for components and utility functions. But I don’t think this works for constants. I also like to start with a single file for all action creators, until it becomes a burden. Same for reducers. In my experience it doesn’t make much difference whether you have eight, 10-line reducers in a single file or eight different files. If you think it has a significant impact on how quickly you can locate a particular piece of code, then do what works for you. Heck, maybe Redux ducks make your boat float. Sure, whatever. What works for the teamNow seems like a good time to explain the title of this post. If you’re working on a project that is just you, then you might be able to find a React structure that is 100% correct, for you. In fact I think it’s well worth aiming for this. But the more people there are on a team, the less likely it is that you’ll find something ‘optimal’, and the more likely other factors will come into play. The big one is compromise. Be aware of distinction bias. You can probably tell from the above that for some items I would be happy to go another way if a team member expressed a strong preference. If someone really wanted to use .jsx extensions or have a Utils alias, I’d be cool with that because although it’s not my preference, it won’t reduce my ability to work quickly. But if someone really really wanted every damn file to be named index.js then it’d be on like Donkey Kong. Another consideration: if you have, say, 30 developers on a team and you’re starting a new project, you might want to structure it as closely to previous projects as possible, no use reinventing the wheel. Or maybe you’ll want to learn from past mistakes and have a different structure, fix that badly-invented wheel. Another little thing: as your team gets bigger, git conflicts will become a bigger part of your day, and erring on the side of smaller files will be a benefit. If you have a mixture of skill levels on the team, that should encourage you to favour simplicity and clarity. On the flip side, if you have a team of seasoned front end engineers (mmm, seasoned), then go nuts and make it as complex as you like. As long as everyone is on the same wavelength, it doesn’t matter how weird it looks from the outside. SummaryI have a confession to make. I always struggle with summaries. It’s like, I just wrote you a whole blog post, what more do you want from me! So it’s not a summary, but I think the most interesting aspect of all the different approaches to application structure is the way people deal with disagreements. There’s a whole class of internet comments that can be summarised as “I disagree and that makes me ANGRY”. Which is a pity, because when two reasonable people disagree, there’s very often something interesting going on, just waiting to be discovered. And since I’m already doing a terrible job of wrapping this up, how about a movie recommendation? If you liked District 9, and haven’t watched Chappie yet, then watching Chappie is something you should immediately go and do. Thanks for reading. Bye!","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Làm thế nào để tổ chức tốt hơn những ứng dụng React","slug":"Lam-the-nao-de-to-chuc-tot-hon-nhung-ung-dung-React","date":"2017-11-13T16:48:00.000Z","updated":"2017-11-13T16:49:59.849Z","comments":true,"path":"2017/11/Lam-the-nao-de-to-chuc-tot-hon-nhung-ung-dung-React.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Lam-the-nao-de-to-chuc-tot-hon-nhung-ung-dung-React.html","excerpt":"I’ve been working on very large web applications for the past few years, starting from ground zero and, with a dozen other developers, making them scale up to now be used by millions of people. And sometimes, if you didn’t start with a good architecture, it can become difficult to keep your code organized. Nathanael Beisiegel wrote an interesting article where he explains his strategy in the organization of large React applications, but I still wasn’t completely satisfied by his approach. So I decided to spend some time to figure out what could be the best way to organize my future React projects.","text":"I’ve been working on very large web applications for the past few years, starting from ground zero and, with a dozen other developers, making them scale up to now be used by millions of people. And sometimes, if you didn’t start with a good architecture, it can become difficult to keep your code organized. Nathanael Beisiegel wrote an interesting article where he explains his strategy in the organization of large React applications, but I still wasn’t completely satisfied by his approach. So I decided to spend some time to figure out what could be the best way to organize my future React projects.Note: I use Redux files in all the examples of this article. If you don’t know what Redux is, you can have a look to the documentation here. Note2: All examples are based on ReactJS, but you can use exactly the same structure for a React-Native application. What are the challenges when you build an application?This has happened or will happen to pretty much all developers over the course of their career: You build an application for a client with a team of a few developers, everything works very well all together. Your client requires new features, fine, you add them. Your client asks you to remove some features and add new ones, it starts to get complicated, you didn’t think about that, but you make it work even though it’s not perfect. Your client now wants you to change another feature, remove some others and add another one that wasn’t expected. At that point, you grab the scotch tape and start patching some code. You are not really proud of it but it works. 6 months later, after some other iterations, the code of the application gets really complicated to read and understand, everything looks like some Italian spaghetti pasta. Until the day your client decides to create a new version of the application, with some fresh new code and features. In some cases, you end-up keeping complicated legacy code that lives with the new code, and this becomes even harder to maintain. And all of this happened because your app wasn’t properly designed from the beginning. When I started to learn React, I found a few very good articles explaining how to create Todo lists or very simple games. Those articles were very useful to understand the basics of React, but I quickly got to a point where I wasn’t able to find much about how I could use React to build actual applications, something with a few dozens pages and hundreds of components. After some research, I learned that every React boilerplate project on Github results to similar structures, they organize all the files by type. This might look familiar to you: 12345678910111213141516171819202122232425262728293031/src /actions /notifications.js /components /Header /Footer /Notifications /index.js /containers /Home /Login /Notifications /index.js /images /logo.png /reducers /login.js /notifications.js /styles /app.scss /header.scss /home.scss /footer.scss /notifications.scss /utils index.js This architecture might be okay to build your website or application, but I believe that it is not the best architecture. When you organize your files by type, as your application grows, it often becomes difficult to maintain. By the time you realize this, it’s too late and you will have to invest a lot of time and money to change everything, or to support what you have for the next few years. The good thing with React is that you can structure your application in any way you like. You are not forced to follow a certain folder structure, React is simply a javascript library. What could be a better approach to organize your application?For a couple of years I worked for a financial institution which used Ember as their main javascript framework to build all their new web applications. One interesting thing about Ember is the ability to structure your project by features, instead of by type. And this changes everything. Pods in Ember are great but still limited, and I wanted something much more flexible. After a few experiments, trying to find what would be the best structure, I got to a point where I decided to group all related features together, and nest them as needed. This is what I use now: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/src /components /Button /Notifications /components /ButtonDismiss /images /locales /specs /index.js /styles.scss /index.js /styles.scss /scenes /Home /components /ButtonLike /services /processData /index.js /styles.scss /Sign /components /FormField /scenes /Login /Register /locales /specs /index.js /styles.scss /services /api /geolocation /session /actions.js /index.js /reducer.js /users /actions.js /api.js /reducer.js index.js store.js Each component, scene or service (a feature) has everything it needs to work on its own, such as its own styles, images, translations, set of actions as well as unit or integration tests. You can see a feature like an independent piece of code you will use in your app (a bit like node modules). To work properly, they should follow these rules: A component can define nested components or services. It cannot use or define scenes. A scene can define nested components, scenes or services. A service can define nested services. It cannot use or define components or scenes. Nested features can only use from its parent. Note: By parent feature, I mean a parent, grandparent, great-grandparent etc… You cannot use a feature that is a “cousin”, this is not allowed. You will need to move it to a parent to use it. Let’s break this down. ComponentsYou all already know what a component is, but one important thing in this organization is the ability to nest a component into another component. Components defined at the root level of your project, in the components folder, are global and can be used anywhere in your application. But if you decide to define a new component inside another component (nesting), this new component can only be used its direct parent. Why would you want to do that? When you develop a large application, it happens quite often that you need to create a component that you definitively know you won’t reuse anywhere else, but you need it. If you add it at the root level of your components folder, it will get lost with hundreds of components. Sure, you could categorize them, but when it’s time to do some clean-up, you won’t remember what they are all for or if they are still being used somewhere. Although, if you define at the root level only the main components of your application, such as buttons, form fields, thumbnails, but also more complicated one like listComments, formComposer with their own children components, it gets much easier to find what you need. Example: 1234567891011/src /components /Button /index.js /Notifications /components /ButtonDismiss /index.js /actions.js /index.js /reducer.js Button can be used anywhere in your application. Notifications can also be used anywhere. This component defines a component ButtonDismiss. You cannot use ButtonDismiss anywhere else than in the Notifications component. ButtonDismiss uses Button internally, this is authorized because Button is defined at the root level of components. ScenesA scene is a page of your application. You can see a scene just like any component, but I like to separate them into their own folder. If you use React-Router or React Native Router, you can import all your scenes in your main index.js file and setup your routes. With the same principle components can be nested, you can also nest a scene into a scene, and also define components or services into a scene. You have to remember that if you decide to define something into a scene, you can only use it within the scene folder itself. Example: 12345678910111213141516171819202122232425/src /scenes /Home /components /ButtonShare /index.js /index.js /Sign /components /ButtonHelp /index.js /scenes /Login /components /Form /index.js /ButtonFacebookLogin /index.js /index.js /Register /index.js /index.js Home has a component ButtonShare, it can only be used by the Home scene. Sign has a component ButtonHelp. This component can be used by Login or Register scenes, or by any components defined in those scenes. Form component uses ButtonHelp internally, this is authorized because ButtonHelp is defined by a parent. The Register scene cannot use any of the components defined in Login, but it can use the ButtonHelp. ServicesNot everything can be a component, and you will need to create independent modules that can be used by your components or scenes. You can see a service like a self-contained module where you will define the core business logic of your application. This can eventually be shared between several scenes or even applications, such as a web and native version of you app. 1234567891011/src /services /api /services /handleError /index.js /index.js /geolocation /session /actions.js /index.js /reducer.js I recommend you to create services to manage all api requests. You can see them as a bridge/an adapter between the server API and the view layer (scenes and components) of your application. It can take care of network calls your app will make, get and post content, and transform payloads as needed before being sent or saved in the store of your app (such as Redux). The scenes and components will only dispatch actions, read the store and update themselves based on the new changes. Wrapping upI’ve been working with this architecture for the past few months on a personal project built with React-Native, and I can tell you this saved me a lot of time. It’s much more simpler to have all related entities grouped together, it makes things easier to work with. This architecture is one of many other ways to organize your project, that’s the way I like it now and I hope this will help you improve yours! If you are interested to see working projects, I have a few on my Github account that follows this architecture: https://github.com/alexmngn/react-rock-paper-scissors (ReactJS) https://github.com/alexmngn/react-native-authentication (React-Native) Feel free to add a comment below or contact me directly if you have any question, I’ll be more than happy to help. Have fun!","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Làm thế nào để cấu trúc các components trong React? ","slug":"Lam-the-nao-de-cau-truc-cac-components-trong-React","date":"2017-11-13T16:41:33.000Z","updated":"2017-11-13T16:46:09.489Z","comments":true,"path":"2017/11/Lam-the-nao-de-cau-truc-cac-components-trong-React.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Lam-the-nao-de-cau-truc-cac-components-trong-React.html","excerpt":"Programming is quite a complex task. Especially crafting clean code is hard. We need to take care of many elements — naming variables, scoping functions, handling errors, ensuring security, monitoring performance etc. Still to name single most difficult thing in programming I would go with writing loosely coupled &amp; highly cohesive components. It doesn’t matter if we’re talking about object-oriented or functional programming. Structuring system is the hardest thing and it has a big impact on the overall project. It takes years to become proficient in designing software architecture (&amp; probably one can never really master it — in such a fast moving industry mastery is always one step ahead, there is always a way to improve design).","text":"Programming is quite a complex task. Especially crafting clean code is hard. We need to take care of many elements — naming variables, scoping functions, handling errors, ensuring security, monitoring performance etc. Still to name single most difficult thing in programming I would go with writing loosely coupled &amp; highly cohesive components. It doesn’t matter if we’re talking about object-oriented or functional programming. Structuring system is the hardest thing and it has a big impact on the overall project. It takes years to become proficient in designing software architecture (&amp; probably one can never really master it — in such a fast moving industry mastery is always one step ahead, there is always a way to improve design). I really enjoy working with React &amp; I think its biggest advantage is how simple React is. There is a difference between simple &amp; easy https://www.infoq.com/presentations/Simple-Made-Easy. And I really mean React is simple. Of course, you need to spend some time to get to know it. But after you understand core concepts, everything else is just a consequence. The hard part comes next. Coupling &amp; CohesionThose are the metrics that more or less describe how difficult it will be to change the behaviour of the code. Coupling &amp; cohesion are used in object-oriented programming and refer to some form of classes. We’ll use them in reference to React components since the same rules apply. Coupling is connection or dependency between elements. If changing one element requires changing another element then we say there is tight coupling. If elements are loosely coupled, changing one element does not imply changes in the other. For example, let’s take a look at displaying bank transfer amount. If displaying amount knows how rates are calculated, then anytime internal structure of transfer changes, displaying code also needs to be updated. If we design system to be loosely coupled, based on the interface of an element, then changes to transfer shouldn’t result in changes to the view layer. Loosely coupled components are easier to manage and maintain. Cohesion tells if element’s responsibilities form one thing. That metric is connected with Single Responsibility Principle or Unix principle: Do one thing and do it well. If account balance formatter also calculates interest rates and checks the permission to display history, then it has many responsibilities and those are not related to each other. Probably, there should be different components for permission handling or interest rates. On the other hand, if there are multiple components one for integer part, one for floating and one for currency, then anytime programmer wants to display balance, they would need to find all elements. The challenge is to create highly cohesive components. Structuring componentsThere are many ways we can structure components. We want components to be reusable, but only to the degree that is reasonable. We want to build small components that can be used to build bigger concepts. Ideally, we want to build loosely coupled &amp; highly cohesive components, so our system is easier to maintain and grow. In React components props can be treated like function arguments and that’s exactly the case for functional stateless components. How we define props in a component, defines how a component can be reused. We’ll use expense manager domain and we’ll analyze expense details formatter. Let’s suppose that expense model looks like this: There are several possibilities to model expense details formatter: no props at all passing expense object passing only required properties passing map of properties passing format as a child We’ll discuss each of them to see what are benefits and flaws of using each and every. Keep in mind that context is the king and everything depends on the system. That’s exactly what we’re paid for — building proper abstraction. No props at allThe simplest solution &amp; the one that is often the starting point is building a component with hard-coded data. Passing no props, of course, doesn’t give us any flexibility and component is suitable to be used only in single place. Of course, in the example of expense details, we can see from the beginning that component needs to accept some props. Nevertheless, there are cases that components without any props is good solution. Firstly, we can use components without props for “constant” content like badges, logos, company info etc. Building even small components makes a system more maintainable. Keeping information in one place allows making changes in one place. Don’t repeat yourself. Passing expense objectIn case of expense details definitely, we need to pass data to the component. First, we’ll take a look at passing expense object. Passing expense object to expense details component makes perfect sense. Expense details formatter is highly coherent -&gt; it displays data of expense. Whenever we want to change formatting, this is the only place that’s going to change. Also changing expense details formatter does not introduce any side effects to expense object itself. The component is tightly coupled to expense object. Is that a bad thing? Definitely not, but we must be aware how that influences our system. Passing expense object as props, results that expense details component relies on the internal structure of expense. Whenever we change the internal structure of expense, we’ll also need to change expense details. Of course, we’ll only need to make changes in one place. How does that design affect future changes? If we want to add, change or remove a field, we’ll only need to change one component. What if we want to add different date formatters? We could add another prop for date formatting. We start adding additional properties to make the component more flexible. As long as there are only a few options, everything is great. The problem starts after system grows and we have a lot of props for different use cases. 1const ExpenseDetails = (&#123; expense, dateFormat, withCurrency, currencyFormat, isOverdue, isPaid ... &#125;) Adding props makes the component more reusable, but it can also be a sign that there are multiple responsibilities of the component. The same rule applies to the function. We can create a function with a number of parameters, but as soon as that number is greater than 3–4, it starts to do a lot of things. And probably that’s the time to split function into smaller one. As number of component props grow, we can decide to split component into more defined ones like: OverdueExpenseDetails, PaidExpenseDetails etc. Passing only required propertiesTo be less coupled with expense object itself, we can pass only required properties. We’re passing each and every property separately, so we’re moving the responsibility a bit to one who is using component. If internal structure of expense changes, it’s not affecting expense details formatter itself -&gt; but probably it can affect every place that is using component because props need to be changed. When passing props as separate properties, a component is more abstract. How passing only required fields affect future design? Adding/updating/removing fields is not easy now. Whenever we want to add a field, we not only need to change the implementation of expense details but also change every place where component is used :( 1const ExpenseDetails = (&#123; category, description, amount, date, account, comment, case ... &#125;) =&gt; ( ... ) On the other hand, supporting multiple date formatting is done almost out-of-the-box. Since we’re passing date as a prop, we can pass formatted date. Deciding how to display particular field is in the hands of the one who uses the component. That is no longer the case of expense details component implementation. Passing map/array of propertiesGoing even more abstract, we could pass a map of properties. The one who uses component is in control over formatting expense details. The object passed to the component has to be properly formatted. That solution has many flaws. We have very little control over how the component will look. The order of reduce is not specified, so we’ll need to add some kind of order. Instead of a map, we could pass an array with objects to overcome that problem, but it still will have drawbacks. Passing map/array as props is not coupled to expense at all but is also not coherent at all. Adding/removing new properties is only a matter of changing prop, but we have no control over the formatting of the component itself. If we want to change only the formatting of the category, it’s not possible it this solution. (To be precise, there is always a way to tweak stuff. For example by passing another props with formatting config. Yet that solution is no longer clean and straightforward.) Passing format as a childWe could also take as little responsibility as possible and pass data as a child. In that case, expense details is only a container to provide some structure and styling. To display details the one using component has to provide all information. Probably in case of expense details, it’s not a good solution, since we’ll need to repeat a lot. Still, flexibility is huge and there are a lot of different formatting possibilities. Adding/removing/updating fields is only a matter of changing the use of the component. The same goes with date formatting. We lose coherence, but that’s the price we had to pay. Context is the kingAs you can see, we’re exchanging different advantages and possibilities. Which one is the best? It depends on: on project itself on stage of project on the component — do we want more specific components or few with options on one’s preferences on requirements — is that component supposed to change frequently &amp; used frequently There is no single good solution. One size doesn’t fit all. How we structure our components has a great impact on how we’ll maintain a system and how expandable it will be. It all depends on the context. Thankfully we have plenty of options and we can pick and choose. Components are a great abstraction to build both small and big systems. It’s only a case of picking right solution.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cách hoạt động của JavaScript: Quản lý bộ nhớ + 4 cách xử lý memory leaks thông dụng","slug":"Cach-hoat-dong-cua-JavaScript-Quan-ly-bo-nho-4-cach-xu-ly-memory-leaks-thong-dung","date":"2017-11-13T16:26:26.000Z","updated":"2017-11-13T16:31:14.306Z","comments":true,"path":"2017/11/Cach-hoat-dong-cua-JavaScript-Quan-ly-bo-nho-4-cach-xu-ly-memory-leaks-thong-dung.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Cach-hoat-dong-cua-JavaScript-Quan-ly-bo-nho-4-cach-xu-ly-memory-leaks-thong-dung.html","excerpt":"A few weeks ago we started a series aimed at digging deeper into JavaScript and how it actually works: we thought that by knowing the building blocks of JavaScript and how they come to play together you’ll be able to write better code and apps. The first post of the series focused on providing an overview of the engine, the runtime, and the call stack. Thе second post examined closely the internal parts of Google’s V8 JavaScript engine and also provided a few tips on how to write better JavaScript code.","text":"A few weeks ago we started a series aimed at digging deeper into JavaScript and how it actually works: we thought that by knowing the building blocks of JavaScript and how they come to play together you’ll be able to write better code and apps. The first post of the series focused on providing an overview of the engine, the runtime, and the call stack. Thе second post examined closely the internal parts of Google’s V8 JavaScript engine and also provided a few tips on how to write better JavaScript code.In this third post, we’ll discuss another critical topic that’s getting ever more neglected by developers due to the increasing maturity and complexity of programming languages that are being used on a daily basis — memory management. We’ll also provide a few tips on how to handle memory leaks in JavaScript that we at SessionStack follow as we need to make sure SessionStack causes no memory leaks or doesn’t increase the memory consumption of the web app in which we are integrated. OverviewLanguages, like C, have low-level memory management primitives such as malloc() and free(). These primitives are used by the developer to explicitly allocate and free memory from and to the operating system. At the same time, JavaScript allocates memory when things (objects, strings, etc.) are created and “automatically” frees it up when they are not used anymore, a process called garbage collection. This seemingly “automatical” nature of freeing up resources is a source of confusion and gives JavaScript (and other high-level-language) developers the false impression they can choose not to care about memory management. This is a big mistake. Even when working with high-level languages, developers should have an understanding of memory management (or at least the basics). Sometimes there are issues with the automatic memory management (such as bugs or implementation limitations in the garbage collectors, etc.) which developers have to understand in order to handle them properly (or to find a proper workaround, with a minimum trade off and code debt). Memory life cycleNo matter what programming language you’re using, memory life cycle is pretty much always the same: Here is an overview of what happens at each step of the cycle: Allocate memory — memory is allocated by the operating system which allows your program to use it. In low-level languages (e.g. C) this is an explicit operation that you as a developer should handle. In high-level languages, however, this is taken care of for you. Use memory — this is the time when your program actually makes use of the previously allocated memory. Read and write operations are taking place as you’re using the allocated variables in your code. Release memory — now is the time to release the entire memory that you don’t need so that it can become free and available again. As with the Allocate memory operation, this one is explicit in low-level languages. For a quick overview of the concepts of the call stack and the memory heap, you can read our first post on the topic. What is memory?Before jumping straight to memory in JavaScript, we’ll briefly discuss what memory is in general and how it works in a nutshell. On a hardware level, computer memory consists of a large number offlip flops. Each flip flop contains a few transistors and is capable of storing one bit. Individual flip flops are addressable by a unique identifier, so we can read and overwrite them. Thus, conceptually, we can think of our entire computer memory as a just one giant array of bits that we can read and write. Since as humans, we are not that good at doing all of our thinking and arithmetic in bits, we organize them into larger groups, which together can be used to represent numbers. 8 bits are called 1 byte. Beyond bytes, there are words (which are sometimes 16, sometimes 32 bits). A lot of things are stored in this memory: All variables and other data used by all programs. The programs’ code, including the operating system’s. The compiler and the operating system work together to take care of most of the memory management for you, but we recommend that you take a look at what’s going on under the hood. When you compile your code, the compiler can examine primitive data types and calculate ahead of time how much memory they will need. The required amount is then allocated to the program in the call stack space. The space in which these variables are allocated is called the stack space because as functions get called, their memory gets added on top of the existing memory. As they terminate, they are removed in a LIFO (last-in, first-out) order. For example, consider the following declarations: 123int n; // 4 bytesint x[4]; // array of 4 elements, each 4 bytesdouble m; // 8 bytes The compiler can immediately see that the code requires4 + 4 × 4 + 8 = 28 bytes. That’s how it works with the current sizes for integers and doubles. About 20 years ago, integers were typically 2 bytes, and double 4 bytes. Your code should never have to depend on what is at this moment the size of the basic data types. The compiler will insert code that will interact with the operating system to request the necessary number of bytes on the stack for your variables to be stored. In the example above, the compiler knows the exact memory address of each variable. In fact, whenever we write to the variable n, this gets translated into something like “memory address 4127963” internally. Notice that if we attempted to access x[4] here, we would have accessed the data associated with m . That’s because we’re accessing an element in the array that doesn’t exist — it’s 4 bytes further than the last actual allocated element in the array which is x[3], and may end up reading (or overwriting) some of m’s bits. This would almost certainly have very undesired consequences for the rest of the program. When functions call other functions, each gets its own chunk of the stack when it is called. It keeps all its local variables there, but also a program counter that remembers where in its execution it was. When the function finishes, its memory block is once again made available for other purposes. Dynamic allocationUnfortunately, things aren’t quite as easy when we don’t know at compile time how much memory a variable will need. Suppose we want to do something like the following: 123int n = readInput(); // reads input from the user...// create an array with \"n\" elements Here, at compile time, the compiler does not know how much memory the array will need because it is determined by the value provided by the user. It, therefore, cannot allocate room for a variable on the stack. Instead, our program needs to explicitly ask the operating system for the right amount of space at run-time. This memory is assigned from the heap space. The difference between static and dynamic memory allocation is summarized in the following table: Differences between statically and dynamically allocated memory To fully understand how dynamic memory allocation works, we need to spend more time on pointers, which might be a bit too much of a deviation from the topic of this post. If you’re interested in learning more, just let me know in the comments and we can go into more details about pointers in a future post. Allocation in JavaScriptNow we’ll explain how the first step (allocate memory) works in JavaScript. JavaScript relieves developers from the responsibility to handle memory allocations — JavaScript does it by itself, alongside declaring values. 1234567891011121314151617var n = 374; // allocates memory for a numbervar s = 'sessionstack'; // allocates memory for a string var o = &#123; a: 1, b: null&#125;; // allocates memory for an object and its contained valuesvar a = [1, null, 'str']; // (like object) allocates memory for the // array and its contained valuesfunction f(a) &#123; return a + 3;&#125; // allocates a function (which is a callable object)// function expressions also allocate an objectsomeElement.addEventListener('click', function() &#123; someElement.style.backgroundColor = 'blue';&#125;, false); Some function calls result in object allocation as well: 12var d = new Date(); // allocates a Date objectvar e = document.createElement('div'); // allocates a DOM element Methods can allocate new values or objects: 123456789var s1 = 'sessionstack';var s2 = s1.substr(0, 3); // s2 is a new string// Since strings are immutable, // JavaScript may decide to not allocate memory, // but just store the [0, 3] range.var a1 = ['str1', 'str2'];var a2 = ['str3', 'str4'];var a3 = a1.concat(a2); // new array with 4 elements being// the concatenation of a1 and a2 elements Using memory in JavaScriptUsing the allocated memory in JavaScript basically, means reading and writing in it. This can be done by reading or writing the value of a variable or an object property or even passing an argument to a function. Release when the memory is not needed anymoreMost of the memory management issues come at this stage. The hardest task here is to figure out when the allocated memory is not needed any longer. It often requires the developer to determine where in the program such piece of memory is not needed anymore and free it. High-level languages embed a piece of software called garbage collector which job is to track memory allocation and use in order to find when a piece of allocated memory is not needed any longer in which case, it will automatically free it. Unfortunately, this process is an approximation since the general problem of knowing whether some piece of memory is needed is undecidable (can’t be solved by an algorithm). Most garbage collectors work by collecting memory which can no longer be accessed, e.g. all variables pointing to it went out of scope. That’s, however, an under-approximation of the set of memory spaces that can be collected, because at any point a memory location may still have a variable pointing to it in scope, yet it will never be accessed again. Garbage collectionDue to the fact that finding whether some memory is “not needed anymore” is undecidable, garbage collections implement a restriction of a solution to the general problem. This section will explain the necessary notions to understand the main garbage collection algorithms and their limitations. Memory referencesThe main concept garbage collection algorithms rely on is the one of reference. Within the context of memory management, an object is said to reference another object if the former has an access to the latter (can be implicit or explicit). For instance, a JavaScript object has a reference to its prototype (implicit reference) and to its properties’ values (explicit reference). In this context, the idea of an “object” is extended to something broader than regular JavaScript objects and also contains function scopes (or the global lexical scope). Lexical Scoping defines how variable names are resolved in nested functions: inner functions contain the scope of parent functions even if the parent function has returned. Reference-counting garbage collectionThis is the simplest garbage collection algorithm. An object is considered “garbage collectible” if there are zero references pointing to it. Take a look at the following code: 1234567891011121314151617181920212223242526272829var o1 = &#123; o2: &#123; x: 1 &#125;&#125;;// 2 objects are created. // 'o2' is referenced by 'o1' object as one of its properties.// None can be garbage-collected var o3 = o1; // the 'o3' variable is the second thing that // has a reference to the object pointed by 'o1'. o1 = 1; // now, the object that was originally in 'o1' has a // single reference, embodied by the 'o3' variablevar o4 = o3.o2; // reference to 'o2' property of the object. // This object has now 2 references: one as // a property. // The other as the 'o4' variableo3 = '374'; // The object that was originally in 'o1' has now zero // references to it. // It can be garbage-collected. // However, what was its 'o2' property is still // referenced by the 'o4' variable, so it cannot be // freed.o4 = null; // what was the 'o2' property of the object originally in // 'o1' has zero references to it. // It can be garbage collected. Cycles are creating problemsThere is a limitation when it comes to cycles. In the following example, two objects are created and reference one another, thus creating a cycle. They will go out of scope after the function call, so they are effectively useless and could be freed. However, the reference-counting algorithm considers that since each of the two objects is referenced at least once, neither can be garbage-collected. 12345678function f() &#123; var o1 = &#123;&#125;; var o2 = &#123;&#125;; o1.p = o2; // o1 references o2 o2.p = o1; // o2 references o1\\. This creates a cycle.&#125;f(); Mark-and-sweep algorithmIn order to decide whether an object is needed, this algorithm determines whether the object is reachable. The Mark-and-sweep algorithm goes through these 3 steps: Roots: In general, roots are global variables which get referenced in the code. In JavaScript for example, a global variable that can act as a root is the “window” object. The identical object in Node.js is called “global”. A complete list of all roots gets built by the garbage collector. The algorithm then inspects all roots and their children and marks them as active (meaning, they are not garbage). Anything that a root cannot reach will be marked as garbage. Finally, the garbage collector frees all memory pieces that are not marked as active and returns that memory to the OS. A visualization of the mark and sweep algorithm in action This algorithm is better than the previous one since “an object has zero reference” leads to this object being unreachable. The opposite is not true as we have seen with cycles. As of 2012, all modern browsers ship a mark-and-sweep garbage-collector. All improvements made in the field of JavaScript garbage collection (generational/incremental/concurrent/parallel garbage collection) over the last years are implementation improvements of this algorithm (mark-and-sweep), but not improvements over the garbage collection algorithm itself, nor its goal of deciding whether an object is reachable or not. In this article, you can read in a greater detail about tracing garbage collection that also covers mark-and-sweep along with its optimizations. Cycles are not a problem anymoreIn the first example above, after the function call returns, the two objects are not referenced anymore by something reachable from the global object. Consequently, they will be found unreachable by the garbage collector. Even though there are references between the objects, they’re not reachable from the root. Counter intuitive behavior of Garbage CollectorsAlthough Garbage Collectors are convenient they come with their own set of trade-offs. One of them is non-determinism. In other words, GCs are unpredictable. You can’t really tell when a collection will be performed. This means that in some cases programs use more memory that it’s actually required. In other cases, short-pauses may be noticeable in particularly sensitive applications. Although non-determinism means one cannot be certain when a collection will be performed, most GC implementations share the common pattern of doing collection passes during allocation. If no allocations are performed, most GCs stay idle. Consider the following scenario: A sizable set of allocations is performed. Most of these elements (or all of them) are marked as unreachable (suppose we null a reference pointing to a cache we no longer need). No further allocations are performed. In this scenario, most GCs will not run any further collection passes. In other words, even though there are unreachable references available for collection, these are not claimed by the collector. These are not strictly leaks but still, result in higher-than-usual memory usage. What are memory leaks?Just like the memory suggests, memory leaks are pieces of memory that the application have used in the past but is not needed any longer but has not yet been return back to the OS or the pool of free memory. Programming languages favor different ways of managing memory. However, whether a certain piece of memory is used or not is actually an undecidable problem. In other words, only developers can make it clear whether a piece of memory can be returned to the operating system or not. Certain programming languages provide features that help developers do this. Others expect developers to be completely explicit about when a piece of memory is unused. Wikipedia has good articles on manual and automatic memory management. The four types of common JavaScript leaks1: Global variablesJavaScript handles undeclared variables in an interesting way: when a undeclared variable is referenced, a new variable gets created in the global object. In a browser, the global object would be window, which means that 123function foo(arg) &#123; bar = \"some text\";&#125; is the equivalent of: 123function foo(arg) &#123; window.bar = \"some text\";&#125; Let’s say the purpose of bar is to only reference a variable in the foo function. A redundant global variable will be created, however, if you don’t use var to declare it. In the above case, this won’t cause much harm. You can surely imagine a more damaging scenario though. You can also accidentally create a global variable using this: 12345function foo() &#123; this.var1 = \"potential accidental global\";&#125;// Foo called on its own, this points to the global object (window)// rather than being undefined.foo(); You can avoid all this by adding ‘use strict’; at the beginning of your JavaScript file which would switch on a much stricter mode of parsing JavaScript which prevents the unexpected creation of global variables. Unexpected globals is certainly an issue, however, more often than not your code would be infested with explicit global variables which by definition cannot be collected by the garbage collector. Special attention needs to be given to global variables used to temporarily store and process large bits of information. Use global variables to store data if you must but when you do, make sure to assign it as null or reassign it once you are done with it. 2: Timers or callbacks that are forgottenLet’s take setInterval for example as it’s often used in JavaScript. Libraries which provide observers and other instruments that accept callbacks usually make sure all references to the callbacks become unreachable once their instances are unreachable too. Still, the code below is not a rare find: 1234567var serverData = loadData();setInterval(function() &#123; var renderer = document.getElementById('renderer'); if(renderer) &#123; renderer.innerHTML = JSON.stringify(serverData); &#125;&#125;, 5000); //This will be executed every ~5 seconds. The snippet above shows the consequences of using timers that reference nodes or data that’s no longer needed. The renderer object may be replaced or removed at some point which would make the block encapsulated by the interval handler redundant. If this happens, neither the handler, nor its dependencies would be collected as the interval would need to be stopped first (remember, it’s still active). It all boils down to the fact that serverData which surely stores and processes loads of data will not be collected either. When using observers, you need to make sure you make an explicit call to remove them once you are done with them (either the observer is not needed anymore, or the object will become unreachable). Luckily, most modern browsers would do the job for you: they’ll automatically collect the the observer handlers once the observed object becomes unreachable even if you forgot to remove the listener. In the past some browsers were unable to handle these cases (good old IE6). Still, though, it’s in line with best practices to remove the observers once the object becomes obsolete. See the following example: 123456789101112131415var element = document.getElementById('launch-button');var counter = 0;function onClick(event) &#123; counter++; element.innerHtml = 'text ' + counter;&#125;element.addEventListener('click', onClick);// Do stuffelement.removeEventListener('click', onClick);element.parentNode.removeChild(element);// Now when element goes out of scope,// both element and onClick will be collected even in old browsers // that don't handle cycles well. You no longer need to call removeEventListener before making a node unreachable as modern browsers support garbage collectors that can detect these cycles and handle them appropriately. If you leverage the jQuery APIs (other libraries and frameworks support this too) you can also have the listeners removed before a node is made obsolete. The library would also make sure there are no memory leaks even when the application is running under older browser versions. 3: Closures A key aspect of JavaScript development are closures: an inner function that has access to the outer (enclosing) function’s variables. Due to the implementation details of the JavaScript runtime, it is possible to leak memory in the following way: 1234567891011121314151617var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) // a reference to 'originalThing' console.log(\"hi\"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(\"message\"); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); Once replaceThing is called, theThing gets a new object which consists of a big array and a new closure (someMethod). Yet, originalThing is referenced by a closure that’s held by the unused variable (which is theThing variable from the previous call to replaceThing). The thing to remember is that once a scope for closures is created for closures in the same parent scope, the scope is shared. In this case, the scope created for the closure someMethod is shared with unused. unused has a reference to originalThing. Even though unused is never used, someMethod can be used through theThing outside of the scope of replaceThing (e.g. somewhere globally). And as someMethod shares the closure scope with unused, the reference unused has to originalThing forces it to stay active (the whole shared scope between the two closures). This prevents its collection. In the above example, the scope created for the closure someMethod is shared with unused, while unused references originalThing. someMethod can be used through theThing outside of the replaceThing scope, despite the fact that unused is never used. The fact that unused references originalThing requires that it remains active since someMethod shares the closure scope with unused. All this can result in a considerable memory leak. You can expect to see a spike in memory usage when the above snippet is run over and over again. Its size won’t shrink when the garbage collector runs. A linked list of closures is created (its root is theThing variable in this case), and each the closure scopes carries forward an indirect reference to the big array. This issue was found by the Meteor team and they have a great article that describes the issue in great detail. 4: Out of DOM referencesThere are cases in which developers store DOM nodes inside data structures. Suppose you want to rapidly update the contents of several rows in a table. If you store a reference to each DOM row in a dictionary or an array, there will be two references to the same DOM element: one in the DOM tree and another in the dictionary. If you decide to get rid of these rows, you need to remember to make both references unreachable. 123456789101112131415var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image')&#125;;function doStuff() &#123; elements.image.src = 'http://example.com/image_name.png';&#125;function removeImage() &#123; // The image is a direct child of the body element. document.body.removeChild(document.getElementById('image')); // At this point, we still have a reference to #button in the //global elements object. In other words, the button element is //still in memory and cannot be collected by the GC.&#125; There’s an additional consideration that has to be taken into account when it comes to references to inner or leaf nodes inside a DOM tree. If you keep a reference to a table cell (a tag) in your code and decide to remove the table from the DOM yet keep the reference to that particular cell, you can expect a major memory leak to follow. You might think that the garbage collector would free up everything but that cell. This will not be the case, however. Since the cell is a child node of the table and children keep references to their parents, this single reference to the table cell would keep the whole table in memory. We at SessionStack try to follow these best practices in writing code that handles memory allocation properly, and here’s why: Once you integrate SessionStack into your production web app, it starts recording everything: all DOM changes, user interactions, JavaScript exceptions, stack traces, failed network requests, debug messages, etc.With SessionStack, you replay issues in your web apps as videos and see everything that happened to your user. And all of this has to take place with no performance impact for your web app.Since the user can reload the page or navigate your app, all observers, interceptors, variable allocations, etc. have to be handled properly, so they don’t cause any memory leaks or don’t increase the memory consumption of the web app in which we are integrated. There is a free plan so you can give it a try now. Resources http://www-bcf.usc.edu/~dkempe/CS104/08-29.pdf https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156 http://www.nodesimplified.com/2017/08/javascript-memory-management-and.html https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Giải thích React Lifecycle - componentDidMakeSense","slug":"Giai-thich-React-Lifecycle-componentDidMakeSense","date":"2017-11-04T16:42:53.000Z","updated":"2017-11-04T16:45:48.181Z","comments":true,"path":"2017/11/Giai-thich-React-Lifecycle-componentDidMakeSense.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Giai-thich-React-Lifecycle-componentDidMakeSense.html","excerpt":"Learn the React lifecycle methods and when/how to use them React is incredible because it allows you to build your UI using a declarative API. You tell React what you want the interface to look like, and it handles the rest. As users interact with the application, the state changes which causes updates to the DOM. React provides a set of methods to seamlessly intercept the changes at any point during the updates and take control of the UI. The component lifecycle is typically one of the final pieces to truly mastering React, and this article will ensure that you have a firm grasp. The lifecycle of a component can be defined as the time from when the component is first being inserted into the DOM, the entire time the component is in the DOM, and the point when the component is being removed from the DOM. There is a unique lifecycle for every React component in your code.","text":"Learn the React lifecycle methods and when/how to use them React is incredible because it allows you to build your UI using a declarative API. You tell React what you want the interface to look like, and it handles the rest. As users interact with the application, the state changes which causes updates to the DOM. React provides a set of methods to seamlessly intercept the changes at any point during the updates and take control of the UI. The component lifecycle is typically one of the final pieces to truly mastering React, and this article will ensure that you have a firm grasp. The lifecycle of a component can be defined as the time from when the component is first being inserted into the DOM, the entire time the component is in the DOM, and the point when the component is being removed from the DOM. There is a unique lifecycle for every React component in your code. Check out gitconnected &gt;The community and network for developers and software engineers. Overview of the lifecycleThe lifecycle methods are hooks to allow you to read state changes and control UI updates. The lifecycle can be broken down into 3 categories: Mounting: The component is being added to the DOM. Updates: The component receives changes props or state and is called when the component is being re-rendered. Unmounting: The component is being removed from the DOM. The lifecycle methods provide entry points to take over any of these steps. Any method that begins with componentWill means you access it before the event occurs and any method prepended with componentDid means you capture it after the event occurs. Mounting constructor() componentWillMount() render() componentDidMount() Updating componentWillReceiveProps() shouldComponentUpdate() componentWillUpdate() render() componentDidUpdate() Unmounting componentWillUnmount() constructorThis method is called when your component is being created and before mounting (being added to the DOM). Its primary use is to initialize state and .bind(this) for the component’s methods. If you do neither of these, then there is no need for a constructor. componentWillMountThis method is executed right before a component is added to the DOM / render(). It is generally recommended that you use the constructor, but this method is still included in the API mostly for backwards compatibility. You should avoid calling any functions that cause side effects in this method as setState won’t trigger a change and there is no DOM to interact with. Note that this is also the only lifecycle method called on the server. componentDidMountYour component has now been rendered and exists in the DOM. This is the point when you should initiate AJAX requests, add event listeners, and perform any set up that requires a DOM. Calling setState during this method or any time after will cause a re-render. componentWillReceivePropsWhen your component receives new props from its parent, componentWillReceiveProps(nextProps) is triggered. This is a great time to check if there are changes in the incoming props when compared to your current props and trigger a state change based on the new values. A common use-case for this is resetting state based on a change. shouldComponentUpdateThis method exists purely for performance improvements. Renders and reconciliations are expensive in React. shouldComponentUpdate(nextProps, nextState) provides the developer the ability to return a boolean true/false from this method which controls whether React should perform the reconciliation operations and DOM updates. The default behavior is for React to render every update, which works in most cases. If shouldComponentUpdate() returns false, then componentWillUpdate(), render(), and componentDidUpdate() will not be invoked. componentWillUpdateReact invokes this method immediately before rendering when new props or state are being received. There is not much use for componentWillUpdate(nextProps, nextState) and should probably be avoided (similar to componentWillMount). You should not do anything that would change the state at this point — use componentWillReceiveProps if you need to do anything before a render. Note that this method is not called on the initial render. componentDidUpdateImmediately after React builds you a shiny new UI, componentDidUpdate(prevProps, prevState) is invoked. This is a great time to interact with the DOM or instantiate a new network request based on what the new interface should look like. componentWillUnmountYour component had a great life and now it’s time for it to leave the UI. This is the moment to clean up everything that was associated with adding and maintaining your component while it was living on the UI. BONUS: componentDidCatchcomponentDidCatch(error, info) is a new lifecycle that was added in React 16. React was notorious for crashing the an entire application if a JavaScript error was thrown inside the React app. It corrupted React’s internal state which blew up the app and yielded cryptic error messages. componentDidCatch solves this by catching any JavaScript error occurring in a component’s tree for the children of the component that implements the method. It is able to capture the error and display a fallback UI.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Hướng dẫn xây dựng ứng dụng React Redux CRUD","slug":"Huong-dan-xay-dung-ung-dung-React-Redux-CRUD","date":"2017-11-04T16:38:19.000Z","updated":"2017-11-04T16:40:27.398Z","comments":true,"path":"2017/11/Huong-dan-xay-dung-ung-dung-React-Redux-CRUD.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Huong-dan-xay-dung-ung-dung-React-Redux-CRUD.html","excerpt":"Building a single-page CRUD app using React and Redux can be challenging because you’ll have to deal w/ new techniques and terms like “Reducers”, “Actions”, “Middlewares”, “Stores” and so on. Perhaps the trickiest part is making async requests and handling responses. While there are many examples, there is no well established pattern for making async requests and handling responses in Redux apps(just yet). In this blog I’ll provide a general approach on how to build a Blog app that has 3 pages and show navigate b/w them. Further, I’ll also establish a pattern for making async requests and handling four async states: “loading”, “success”, “error” and “success-and-navigate”. Source code: https://github.com/rajaraodv/react-redux-blog Let’s get started.","text":"Building a single-page CRUD app using React and Redux can be challenging because you’ll have to deal w/ new techniques and terms like “Reducers”, “Actions”, “Middlewares”, “Stores” and so on. Perhaps the trickiest part is making async requests and handling responses. While there are many examples, there is no well established pattern for making async requests and handling responses in Redux apps(just yet). In this blog I’ll provide a general approach on how to build a Blog app that has 3 pages and show navigate b/w them. Further, I’ll also establish a pattern for making async requests and handling four async states: “loading”, “success”, “error” and “success-and-navigate”. Source code: https://github.com/rajaraodv/react-redux-blog Let’s get started. STEP 1 — Write Detailed Mocks For Each Page And Phases.In our app we have 3 pages: An Index page that shows a list of Posts, a Post details page and a New Post page. Each page has “Success”, “Loading” and “Error” phases because they all make AJAX calls to load/delete posts, so we need to mock those things as well. 1.1 Success Phase — Detailed Mocks when things are working Note: You can click on the pictures to Zoom and read 1.2 Loading Phase — Detailed Mocks when they are loading 1.3 Error Phase — Detailed Mocks when there is an Error STEP 2 — Divide Each Page Into ComponentsLook at all the phases of each page and roughly divide each page into components based on “purpose” and based on physical location. This helps you identify reusable components across different pages and also any additional ones in a specific phase. For example, you may need a “Spinner” or an “Error” component for different phases. Note: this doesn’t need to be perfect. You can make changes later on. 2.1 — Success Phase: Divide Each Page Into Components Index page: 1. Shows list of posts, 2. Allows navigating to Post form page to create new post. So we end up w/ PostsList and Header components. Post details page: 1. Shows details of the post, 2. Allows navigating back to Index page 3. Index page. So we end up with PostDetails and Header components. 3. New Post page: 1. Allows creating posts and 2. allows navigating back to Index. Again we end up with PostForm and Header component. Notice that we can reuse Header across all 3 pages because of the physical location. So we end up with four components (instead of 6): 1. PostsList, 2. PostDetails 3. PostForm and 4. Header components. 2.2 — Loading Phase: Divide Each Page Into ComponentsIf you look at the mock, we are simply displaying “loading..” text in each page and not using some fancy spinner or “toast”. So we don’t have any more components. 2.3 — Error Phase: Divide Each Page Into ComponentsIf you look at the mock, we are simply throwing an alert popup and not using any custom modals. So we don’t have any more components. So net-net, we have 4 components (1. PostsList, 2. PostDetails 3. PostForm and 4. Header) Redux Terms:Redux Terms — “Actions” And “States”Every component does two things: 1. Listen to the user and server events and send them to JS functions. In Redux, events are represented as a JSON object called “Actions”. 1&#123;\"type\": \"FETCH_POST\", \"id\": 1234&#125; // &lt;-- Action 2. Render DOM based on some data. This data is called a“state”, which is also a JSON object. 1&#123;\"post\": &#123;\"id\": 1234, \"title\": \"My Redux Post\"&#125;&#125; // &lt;-- state Redux Terms — “Action Creators”These are functions that listen to DOM or server events and return formal JSON “Action” object. 123456function fetchPost(id) &#123;return &#123; type: FETCH_POST, result: makeServerRequest(\"http://postsServer.com/api/id\") &#125;;&#125; See Action Creators for our app. Redux Terms — “Dispatching an Action”Redux provides a function called “dispatch” which allows us to pass the “Action” JSON object to all other components. Dispatching an Action means simply calling the dispatch function w/ the action JSON object. 1//Call the \"Action Creator\" w/ post's id and then use it's return //value (Action JSON object) to finally dispatch it to \"reducers\"dispatch(fetchPost(id)) or dispatch(&#123;type:\"FETCH_POST\", id:1234&#125;) The components calls Action creators to receive Actions and then dispatches the actions. Redux then send the actions to “Reducers” Redux Terms — “Reducers”Reducers are functions that take an Action and the current state that was sent to them via “dispatch”, apply action to the current state and return a new state. And Redux re-renders all components whenever there is a new state. 1234//If the action is FETCH_POST_SUCCESS, return a new \"activePost\" //state w/ new post)case FETCH_POST_SUCCESS: return &#123;activePost: &#123;post: action.payload.data, error:null, loading: false&#125;&#125;; See Reducers “reducer_posts.js” and main “index.js” (this combines multiple reducers into one) OK, before we go ahead to step 3, let’s understand how to deal with Async Actions because every page makes AJAX calls. PATTERN: Dealing With Async ActionsIf component is loading an object(e.g. list of Posts) via AJAX call to the server, that object’s state should keep track of all the potential states. Initial state for such objects should look like: {objName: {obj:null, loading: false, error:null}}. Further, such components should dispatch up to 4 actions such as “FETCH_OBJ”(for loading), “FETCH_OBJ_SUCCESS”, “FETCH_OBJ_FAILURE” and “OBJ_RESET”(to cleanup dirty previous state). For example, if we are loading list of posts.. Note: You can click on the pictures to zoom and read Initial State: Initial state should look like, 1&#123;postsList:&#123;posts:[], loading:false, error:null&#125;&#125; Actions: FETCH_OBJ — Dispatch this to make the server request and also let other components know we are loading. This helps current/other components show “loading” or hide or do something. 1dispatch(&#123;“type”: “FETCH_POSTS”, loading: true&#125;) Once Redux gets this and passes it through reducers, the new state will look something like: 1&#123;postList: &#123;posts:null, error: null, loading: true&#125;&#125; 2. FETCH_OBJ_SUCCESS: Dispatch this when you get successful response. This is to show the actual data and also to cancel “loading” 1dispatch(&#123;\"type\": \"FETCH_POSTS_SUCCESS\", \"posts\":[post1, post2]) Once Redux gets this and passes it through reducers, the new state will look something like: 1&#123;postsList:&#123;posts:[post1, post2], error:null, loading: false&#125;&#125; 3.FETCH_OBJ_FAILURE: Dispatch this when you get a failed response. This is to show some error message and also to cancel “loading”. 1dispatch(&#123;\"type\": \"FETCH_POSTS_FAILURE\", \"error\": \"Error message\"&#125;) Once Redux gets this and passes it through reducers, the new state will look something like: 1&#123;postList:&#123;posts:null, error:&#123;msg: \"Error msg\"&#125;, loading: false&#125;&#125; 4.RESET_OBJ: Dispatch this to reset the component’s state after success/failure. This is optional but can be useful when you want to reuse a “dirty” component from previous AJAX request. 1dispatch(&#123;\"type\": \"RESET_POST\", loading: false, \"post\": null, \"error\": \"Error message\"&#125;) Once Redux gets this and passes it through reducers, the new state will look something like: 1&#123;postList:&#123;post:null, error:null, loading: false&#125;&#125; STEP 3 — List State and Actions For Each Component (AND For Each Phase)Take a look at each component one by one and each phase and list of state and actions. We have 4 components: 1. PostsList, 2. PostDetails 3. PostForm and 4. Header components. 3.1 PostList Component — List State And Actions States: List out various data that may change the display of the component in all phases of the component. Shows list of Posts. Let’s call the state as “posts” (an array). Shows “Loading..”, if it’s in the processing fetching the posts. Let’s call this state “loading”(boolean) Shows “Error” if there is an error. Let’s call this state as “error”(null or error info). Since all the above are related to PostList, let’s put them in a single state object called postList. 1&#123; postsList: &#123;posts: [], error:null, loading: false&#125; //initial state Actions: This component makes a “AJAX” call to load posts, so we’ll use the above mentioned pattern and create 4 actions. 1.Asks server for list of posts. Let’s call this action as: “FETCH_POSTS”. 123456export function fetchPosts() &#123; const request = axios.get(`$&#123;ROOT_URL&#125;/posts`);return &#123; type: FETCH_POSTS, payload: request &#125;;&#125; 2.Tells every component that it received posts (success case). Let’s call this “FETCH_POSTS_SUCCESS” 123456export function fetchPostsSuccess(posts) &#123; return &#123; type: FETCH_POSTS_SUCCESS, payload: posts &#125;;&#125; 3.Tells every component that there was an error(failure case). Let’s call this “FETCH_POSTS_FAILURE” 123456export function fetchPostsFailure(error) &#123; return &#123; type: FETCH_POSTS_FAILURE, payload: error &#125;;&#125; 4. Resetting data is not required because this is the 1st page (you’ll see how this is useful in other 2 pages) 3.2 PostDetails Component — List State And Actions Note: You can click on the pictures to zoom and read 3.3 PostForm Component — State And Actions 3.4 Header Component — List State And Actions STEP 4 — Create Action Creators For Each ActionWe have a total of 12 actions(4 actions x 3 pages), create action creators for each one. Please see the source code here. 12345678910111213141516//Example Action creators...export function fetchPosts() &#123; const request = axios.get(`$&#123;ROOT_URL&#125;/posts`);return &#123; type: FETCH_POSTS, payload: request &#125;;&#125;export function fetchPostsSuccess(posts) &#123; return &#123; type: FETCH_POSTS_SUCCESS, payload: posts &#125;;&#125;... Redux Term: “Reducers”Reducers are functions that take “state” from Redux and “action” JSON object and returns a new “state” to be stored back in Redux. 1. Reducer functions are called by the “Container” containers when there is a user or server action.2. If the reducer changes the state, Redux passes the new state to each component and React re-renders each component 1234The below function takes the current \"postsList\" inside \"...state\" and merges new \"postList\" and creates a **new** state(json), if the action is \"FECTH_POSTS_SUCCESS\"case FETCH_POSTS_SUCCESS: return &#123; …state, postsList: &#123;posts: action.payload, error:null, loading: false&#125; &#125;; STEP 5 — Write Reducers For Each ActionWe have 12 actions, we need to write reducers for each one of them. Please look at the source code for details here. Redux Term: “Presentational” and “Container” ComponentsKeeping React and Redux logic inside each component can make it messy, so Redux recommends creating a dummy presentation only component called “Presentational” component and a parent wrapper component called “Container” component that deals w/ Redux, dispatch “Actions” and more. The parent Container then passes the data to the presentational component, handle events, deal with React on behalf of Presentational component. Legend: Yellow dotted lines = “Presentational” components. Black dotted lines = “Container” components. STEP 6 — Implement Every Presentational ComponentWe have 4 components: PostsList, PostDetails, PostForm and Header. Let’s create presentational components for each one. 6.1 Implement Presentational Component — PostsList Note: You can click on the pictures to zoom and read 6.2 Implement Presentational Component — PostDetails 6.3 Implement Presentational Component — PostForm Note: In the actual code, I am using the awesome redux-form library for form-validation. I’ll blog about it in a different post. 6.4 Implement Presentational Component — Header Note: You can click on the pictures to zoom and read STEP 7 — Create Container Component For Some/All Presentational ComponentWe have 4 components: PostList, PostDetails, PostForm and Header. Let’s create container components for each one. 7.1 Create Container Component — PostsListContainer 7.2 Create Container Component — PostDetailsContainer 7.3 Create Container Component — PostFormContainer 7.4 Create Container Component — HeaderContainer STEP 8 — Finally Bring Them All TogetherBelow code is a simplified version of wiring everything together. Please see source code of the main index.js and reducers.js to get started. 123456789101112131415161718192021222324import React from 'react'; &lt;-- Main React libimport ReactDOM from 'react-dom'; &lt;-- Main React DOM libimport &#123; Provider &#125; from 'react-redux';&lt;-- Injects Redux to compsimport &#123; createStore, applyMiddleware &#125; from 'redux';&lt;- Reduximport &#123; Router, browserHistory &#125; from 'react-router';&lt;- Navigationimport reducers from './reducers'; &lt;- Import reducersimport promise from 'redux-promise';//Configure middleware w/ redux-promise for AJAX requestsconst createStoreWithMiddleware = applyMiddleware( promise)(createStore);const store = createStoreWithMiddleware(reducers);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;- Inject global redux state to comps &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=”/” component=&#123;App&#125;&gt; &lt;- Wrapper for all pages &lt;IndexRoute component=&#123;PostsIndex&#125; /&gt; &lt;-wrapper Index page &lt;Route path=”posts/new” component=&#123;PostsNew&#125; /&gt; &lt;- New page &lt;Route path=”posts/:id” component=&#123;PostsShow&#125; /&gt; &lt;-Details &lt;/Route&gt; &lt;/Router&gt;&lt;/Provider&gt; , document.getElementById('body')); That’s it for now!","categories":[],"tags":[]},{"title":"Làm thế nào để kết hợp NodeJS Back End với ReactJS Front End","slug":"Lam-the-nao-de-ket-hop-NodeJS-Back-End-voi-ReactJS-Front-End","date":"2017-11-04T16:34:28.000Z","updated":"2017-11-04T16:36:30.636Z","comments":true,"path":"2017/11/Lam-the-nao-de-ket-hop-NodeJS-Back-End-voi-ReactJS-Front-End.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Lam-the-nao-de-ket-hop-NodeJS-Back-End-voi-ReactJS-Front-End.html","excerpt":"In this post, I want to show how you can build the front and back end of a website using NodeJS for the back end. We’ll use node to create endpoints, and set up a database in JSON format. Then, we’ll create a front end application using React that will post to the database, and also fetch data from it.","text":"In this post, I want to show how you can build the front and back end of a website using NodeJS for the back end. We’ll use node to create endpoints, and set up a database in JSON format. Then, we’ll create a front end application using React that will post to the database, and also fetch data from it.For this example, I’ll be making a guestbook, where users can submit their names and leave messages. Because users won’t need to log in, or retrieve any data, I won’t need to store anything in a session. Here’s the way this will likely work: Basically, we will have this all one one page, with a form for submitting a message, alongside the actual guestbook. To make this work we’’ll start by creating the endpoints for our POST and GET requests. We’ll set up our database, deploy it, so that we can create a React app, and pull data from the online API. Here’s the order in which I like to do things. You may prefer to work differently. This process makes sense to me, because each step builds on the step before it. During this tutorial, I’ll go through each step in more detail. To see how the finished project could work, here’s a link to my project: http://ethan.jarrell.webdeveloper.surge.sh/GuestBook STEP 1 -Our database collection will contain 2 items: The name of the user The message the user writes If you haven’t already done so, go ahead and install MongoDB, and get it running on port 27017. Then, on the command line, we’ll create the database. We’ll call our database signatures. And the collection, guest_signatures. 12345&gt; Show dbs&gt; Use signaturesswitched to db signatures&gt; show collections&gt; db.createCollection(guest_signatures) Now that we have that set up, we can switch to the text editor, and create the models for the database. STEP 2 -Use the command line to start a new express app. Make the new directory, and then use npm init to create the app. This will automatically create your pkg.JSON file. Since this will be a very basic app, we’ll only need 2 other files in our express app. One for our routes. I like to include all my dependencies in this file as well. Then our second fill will be for our models/schema. We’ll tackle the model file first. It should look something like this: 12345678910111213141516const mongoose = require('mongoose');let Schema = mongoose.Schema;const signatureSchema = new Schema(&#123; guestSignature: &#123; type: mongoose.Schema.Types.Mixed, required: true, &#125;, message: &#123; type: mongoose.Schema.Types.Mixed, required: true, &#125;,&#125;)const Signature = mongoose.model('Signature', signatureSchema);module.exports = Signature; STEP 3 -Before we create our endpoints here, let’s go ahead an list our dependencies at the top of our file. We don’t need too many. 1234567891011//====LIST DEPENDENCIES===//const express = require('express');const parseurl = require('parseurl');const bodyParser = require('body-parser');const path = require('path');const expressValidator = require('express-validator');const mongoose = require('mongoose');const Signature = require('./models/signature.js')const app = express();const url = 'mongodb://localhost:27017/signatures';//=========================// You don’t necessarily need to connect with mongoose, so feel free to use MongoClient, if you prefer that. We’re also using the Signature schema that we just created in the previous step. Now, let’s create our endpoints. We only have one model, and we’re only going to read and write to it for now, so we’re only going to have 2 endpoints. Our root directory “/”, where we’ll redirect to our API Our api, we’ll call “/api/signatures, where we’ll read and write to. At our API endpoint, we’ll have a GET and a POST. We’ll reference our models, using the find() and create() methods for GET and POST respectively. And our response will need to be in JSON format, so that we can easily access the data there from React later on. Here’s how those endpoints might look: 12345678910111213141516171819202122232425262728//====ROOT DIRECTORY===//app.get('/', function(req, res) &#123; res.json('you did it');&#125;);//==========================////====GET ALL SIGNATURES===//app.get('/api/signatures', function(req, res) &#123; Signature.find(&#123;&#125;).then(eachOne =&gt; &#123; res.json(eachOne); &#125;) &#125;)//==========================////====POST NEW SIGNATURE===//app.post('/api/signatures', function(req, res) &#123; Signature.create(&#123; guestSignature: req.body.SignatureOfGuest, message: req.body.MessageofGuest, &#125;).then(signature =&gt; &#123; res.json(signature) &#125;);&#125;);//==========================// The only thing I didn’t really mention was the req.body.SignatureOfGuest and req.body.MessageofGuest. Everything else in this section refers to something we’ve already created, like our database, collections and models. This refers to the name of the field that we’ll use in our React App, Our input will have to use the names SignatureOfGuest and MessageofGuest, so we’ll need to remember that. STEP 4 -Now, we’ll want to connect to our local database from out text editor. If you remember, we had this constant in our list: 1const url = 'mongodb://localhost:27017/signatures'; We’ll write a function using this constant to connect to our local database. 123456789//====MONGOOSE CONNECT===//mongoose.connect(url, function (err, db) &#123; if (err) &#123; console.log('Unable to connect to the mongoDB server. Error:', err); &#125; else &#123; console.log('Connection established to', url); &#125;&#125;);//==========================// In order to make sure everything is working properly, we’ll also need to add an app.listen at the end of our file. At this point, it’s a good idea to pause, and make sure the endpoints and local connection works. You can do that by using Postman to make GET and POST requests. If the endpoints or connections don’t work, you should be able to diagnose the problem here based on the error messages you receive. If everything is working, it should allow you to appropriately read and write to the database. Once everything is working, it’s time to set up our account on Heroku and Mlab. STEP 5-Sign up for a Heroku account here. And create an mLab account here. STEP 6 - After creating your mLab account, click on the Create New button and select a Single node sandbox. There are paid options as well, but the sandbox has plenty of space for getting started. Give your database a name. Since my local database is signatures, I’m using the same name for my mLab database. Now that you have your database created, you can start a new collection from here. You will also need to add a User or Users who can access your database. Without doing this step, and adding yourself as a User with access, authentication will always fail when you try to deploy it. Now your database is running on mLab. When you click on the database, you should see some information at the top, telling you how to integrate the connection. It should look something like this: 1mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;[@ds7](http://twitter.com/ds129024 \"Twitter profile for @ds129024\")9234.mlab.com:9234/signatures The actual url of the database will just have the username and password replaced with your username and password. Now let’s head back to our text editor. We currently have the database running locally at this location: 1const url = 'mongodb://localhost:27017/signatures'; To change it, so that we are connected to mLab, simply update the url variable with the information from mLab. It should look something like this: 1const url = 'mongodb://username:password@ds79234.mlab.com:9234/signatures'; However, you’ll likely be putting this on github, or another public place. You don’t want your mlab username and password in a public sphere where anyone can see it. To fix that, we’ll set an environment variable on the command line, and then update our url variable one more time in the text editor. On the command line, use this command: 1export MONGOLAB_URI=\"mongodb://username:password@ds79234.mlab.com:9234/signatures'; Of course, replacing it with your own username, password, numbers and database name. Now, back in our text editor, we will change our url variable to the following: 1const url = process.env.MONGOLAB_URI; We’ll also want to change our app.listen to reflect the new port. It could look like this: 12app.listen(process.env.PORT || 3000);console.log('starting applicaiton. Good job!'); This way, it will try to run from mongolab, but if it can’t make the connection, it will still listen on port 3000 by default. This will also allow you to run the app locally or from mlab, in case you want to test changes on the local version. The final step in making the connection is deploying your code to your Heroku App. to do this, you can use the following code from the command line: 1heroku config:set MONGOLAB_URI=mongodb://username:password@ds79234.mlab.com:9234/signatures Your app should be successfully deployed on heroku, and you can open it from there now. If you are getting errors, double check to make sure it’s running locally. If so, then it’s probably an error along the way in the connection. In these last two steps, there’s quite a bit of repetitive code. I’m going to outline the high level code here. STEP 7 -Use ‘create-react-app’ from the command line to create a new react app. STEP 8 -Now, we’ll want to create a form, to allow for user input. Here’s how we do that. In a new component, we’ll create a new class. 1class GuestBook extends Component 2. We’ll use a constructor and super method to pass props down. 12constructor(props) &#123; super(props); 3. Use the this keyword to handle the name and message of guest, and bind it to (this). 12this.handleSignatureOfGuest = this.handleSignatureOfGuest.bind(this); this.handleMessageofGuest = this.handleMessageofGuest.bind(this); 4. Set the state of the name and message of guest to an empty string. 1234this.state = &#123; SignatureOfGuest: \"\", MessageofGuest: \"\", &#125;; 5. Listen for an event on the state of both the name and message input. 123456handleSignatureOfGuest(event) &#123; this.setState(&#123; SignatureOfGuest: event.target.value &#125;); &#125; handleMessageofGuest(event) &#123; this.setState(&#123; MessageofGuest: event.target.value &#125;); &#125; 6. Create a function that changes the name and message to the value of the target input. 123456addToGuestBook = event =&gt; &#123; event.preventDefault(); this.setState(&#123; SignatureOfGuest: event.target.value, MessageofGuest: event.target.value,&#125;); 7. I’m now using axios to post the input data to our database, which is on heroku. 12345678910axios.post('&lt;[your-heroku-url here&gt;'](https://ancient-sea-87841.herokuapp.com/api/signatures%27), &#123; SignatureOfGuest: this.state.SignatureOfGuest, MessageofGuest: this.state.MessageofGuest, &#125;) .then(response =&gt; &#123; console.log(response, 'Signature added!'); &#125;) .catch(err =&gt; &#123; console.log(err, 'Signature not added, try again'); &#125;); 8. Then I’m resetting the state of the input to an empty string. 12345this.setState(&#123; SignatureOfGuest: \"\", MessageofGuest: \"\", &#125;);&#125;; 9. Finally, we’ll make a render method, and return our page with the input fields. Inside the input of each field, we’ll give it an onChange, name, and value. the onChange will be set to the.handlemessage or this.handlename, for each field. The name of each field will be set to what we called it in our node app. The value will use state, and we’ll set that to this.state.message, and this.state.name. 1234567891011121314&lt;input onChange=&#123;this.handleSignatureOfGuest&#125; name=\"SignatureOfGuest\" className=\"NameinputForm\" value=&#123;this.state.SignatureOfGuest&#125; placeholder=\"Enter your name\" /&gt; &lt;textarea onChange=&#123;this.handleMessageofGuest&#125; name=\"MessageofGuest\" className=\"MessageinputForm\" value=&#123;this.state.MessageofGuest&#125; placeholder=\"Type a message\" /&gt; 10. Then we’ll add a submit button, where we call the function from earlier. 1234567&lt;button className=\"submitbuttonguestbook\" type=\"submit\" onClick=&#123;this.addToGuestBook&#125; &gt; Submit to Guestbook&lt;i className=\"GuestBookButton2\" aria-hidden=\"true\" /&gt; &lt;/button&gt; STEP 9-Now we’ll make another component where we’ll render the data that’s being stored in our database. Then we can export that component, and put it on our guestbook page. Inside this component we’ll do the following: In a new component, we’ll create a new class. 1class GuestNames extends Component &#123; 2. We’ll use a constructor and super method to pass props down. 12constructor(props) &#123; super(props); 3. Use this.state to set the state of our guestbook messages to an empty string. 123this.state = &#123; messages: \"\", &#125;; 4. Use a componentDidMount lifecycle method 1componentDidMount() &#123; 5. Inside that method we’ll use fetch and the url of our heroku api to fetch the information from the database. 123fetch('&lt;your-heroku-url-goes-here&gt;['](https://ancient-sea-87841.herokuapp.com/api/signatures%27)) .then(results =&gt; &#123; return results.json(); 6. We’ll map over the data, and return the data we want. 12345data.map((msg) =&gt; &#123; return( &lt;div key=&#123;msg.results&#125;&gt; &lt;h3 className=\"h3msg\"&gt;&#123;msg.message&#125;&lt;/h3&gt;&lt;h2 className=\"h2sig\"&gt;-&#123;msg.guestSignature&#125;&lt;/h2&gt; &lt;/div&gt; 7. Now we’ll use this.setState to set the state of the messages to the new state using the data we just fetched. 1this.setState(&#123;messages: messages&#125;); 8. Now we’ll create render mehod. 1render() &#123; 9. Inside the render method, we’ll create JSX elements to render our data inside the component. I’m using this.state.messages inside an &lt;h6&gt; tag. 1234return (&lt;div className=\"guestdataContainer\"&gt; &lt;h6&gt;Guestbook Messages&lt;/h6&gt; &#123;this.state.messages&#125; &lt;/div&gt; 10. Finally, we’ll export the component, so we can use it on other pages. 1export default GuestNames; Again, if you have any questions feel free to reach out. Thanks!","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"nodejs","slug":"nodejs","permalink":"http://nthung2112.github.io/tags/nodejs/"}]},{"title":"Tổng hợp các cheatsheets tốt nhất của Front-end","slug":"Tong-hop-cac-cheatsheets-tot-nhat-cua-Front-end","date":"2017-11-04T16:28:52.000Z","updated":"2017-11-04T16:31:09.386Z","comments":true,"path":"2017/11/Tong-hop-cac-cheatsheets-tot-nhat-cua-Front-end.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Tong-hop-cac-cheatsheets-tot-nhat-cua-Front-end.html","excerpt":"It’s rather impossible to remember all the APIs by heart. This is when cheatsheets jump in! Here are the best front-end cheatsheets I’ve gathered.","text":"It’s rather impossible to remember all the APIs by heart. This is when cheatsheets jump in! Here are the best front-end cheatsheets I’ve gathered. Javascript ES2015 featureshttps://devhints.io/es6 Javascripthttp://overapi.com/javascript Javascript Regular expressionhttps://www.debuggex.com/cheatsheet/regex/javascript Reacthttps://devhints.io/react Reduxhttps://github.com/linkmesrl/react-journey-2016/blob/master/resources/egghead-redux-cheat-sheet-3-2-1.pdf Vuejshttps://vuejs-tips.github.io/cheatsheet/ Vuexhttps://vuejs-tips.github.io/vuex-cheatsheet/ Angular 4https://angular.io/guide/cheatsheet Flexboxhttps://yoksel.github.io/flex-cheatsheet/ SCSShttps://devhints.io/sass Stylushttps://devhints.io/stylus GraphQLhttps://raw.githubusercontent.com/sogko/graphql-shorthand-notation-cheat-sheet/master/graphql-shorthand-notation-cheat-sheet.png","categories":[],"tags":[{"name":"front-end","slug":"front-end","permalink":"http://nthung2112.github.io/tags/front-end/"}]},{"title":"Đi ăn và hiểu những điều cơ bản của Express.js","slug":"Di-an-va-hieu-nhung-dieu-co-ban-cua-Express-js","date":"2017-11-04T16:25:21.000Z","updated":"2017-11-04T16:33:58.328Z","comments":true,"path":"2017/11/Di-an-va-hieu-nhung-dieu-co-ban-cua-Express-js.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Di-an-va-hieu-nhung-dieu-co-ban-cua-Express-js.html","excerpt":"If you have ever visited a sit-down restaurant, then you can understand the basics of Express. But if you are just starting to build your first Node.js back end…you might be in for a bumpy ride. Yes — it is certainly easier to learn Node if you have past experience with JavaScript. But the challenges you will face while building a back end are completely different than the ones you face while using JavaScript on the front end. When I learned Node, I chose the hard way. I studied eBooks, written tutorials, and videos over and over until I finally understood why I was doing what I was doing. There is an easier way. I am going to use a restaurant analogy to explain four key parts of your first Express app. Express.js is a popular framework for organizing your code, and I would recommend it for any beginner. I’ll explain further in a moment.","text":"If you have ever visited a sit-down restaurant, then you can understand the basics of Express. But if you are just starting to build your first Node.js back end…you might be in for a bumpy ride. Yes — it is certainly easier to learn Node if you have past experience with JavaScript. But the challenges you will face while building a back end are completely different than the ones you face while using JavaScript on the front end. When I learned Node, I chose the hard way. I studied eBooks, written tutorials, and videos over and over until I finally understood why I was doing what I was doing. There is an easier way. I am going to use a restaurant analogy to explain four key parts of your first Express app. Express.js is a popular framework for organizing your code, and I would recommend it for any beginner. I’ll explain further in a moment.Here are the four key parts we will cover: The require statements Middleware Routing App.listen()/ Starting the server In this analogy, you are a restaurant owner looking to hire a general manager — the person who creates all the processes and manages the place so that it runs smoothly and customers leave happy. Here is a preview of what is next: By the end, you will understand the functionality of every part of a basic Express app. Step 1: hiring the manager (require statements)In this example, you are the restaurant owner. And you need to hire an expert to run the day-to-day operations of your new restaurant. You certainly aren’t an expert, and you can’t leave it to the waitstaff and kitchen to figure out. If you want to run an efficient and safe restaurant, you need someone to keep your staff working at maximum efficiency. Express is the new manager. The first part is pretty straightforward. Like with any other NPM package, you need to npm install the express module and then use a require statement to load the module. Unlike many other NPM packages, you also need to use this line: 1const app = express(); This is because you need a variable to hold your new Express application. Express is not a default part of Node. Step 2: making decisions at the restaurant (middleware)Let’s take a step back here. What are some common routines that happen at restaurants? There are three that immediately jump into my head: Seating new customers Taking food orders Presenting the check at the end of the meal For each one, there are a series of checks that you need to run before you can execute the action. For example, before you seat customers you need to know: Are they wearing a shirt and shoes (and pants)? Otherwise, they cannot be seated. If they want to sit at the bar, are they 21 years old (if you are in the United States)? This ain’t a beach bar! Similarly, in your code, you will need to validate that requests have certain criteria before they can continue. For example, if a person tries to log in to your site: Do they have an account? Did they enter the correct password? This is where the concept of middleware comes in. Middleware functions allow you to take action on any incoming request and modify it before sending back a response. In your restaurant, you need a series of rules to decide if you should seat incoming people or not. Let’s say a couple walks through your door. You have one rule before giving them a table: are they wearing a shirt and shoes? First, you start with app.use(). This means that these are simply rules that need to be applied for the routes coming up next. They are not a GET, POST, PUT or DELETE. In line 4, you have an anonymous function with the parameters req, res and next. For the purposes of this code block, you are just inspecting the request (req) to see if it has shirt and shoes. You also need to use the next() function at the end because you are simply validating clothing here. Later, in the routes, you will allow the guests to get an actual table. In lines 5 and 6, you check if they have a shirt and shoes. And in lines 7–9, you only proceed if they have both. The code block above is missing one important thing: A path. This is the specific string included with the request. And since it is missing a path, it will run on every single request. Can you imagine? When customers entered the restaurant… ordered food… asked for the check… employees would be forced to look up and down at them to make sure they were clothed! That is a quick way to go out of business. So, we change line 4 in the example above. Now, we will only run this code when a user requests along the ‘/table’ route. The full explanation: Step 3: executing common routines (routing)Let’s continue with the seating example. So far, we only know how to validate whether someone should be seated or not. But we do not actually know how to lead them to a table and sit them down. This is where routes come in. Routes allow us to script specific actions based on the path. The options are GET, POST, PUT and DELETE, but we will focus on GET and POST for now. In the context of a restaurant, we need to create a GET request in order to choose a specific table and seat the guests. GETs do not modify or add to your database. They just retrieve information based on specific parameters. In this case, let’s say that you need to create a procedure to seat a party of two. The number 2 came from the customer request. Okay, before I explain: Yes, this is only sending a message at the end. It has not actually found a specific table to seat the customer yet. I would need to search an array for an open table, have more of a back story…that is outside of the scope of this tutorial. In line 12, we define the procedure for finding a table when a guest requests along the ‘/table’ route. Just like the middleware example above, we have request and response parameters available. It also has a parameter, amount. This is two, in this example. In fact, everything after the function declaration in line 12 is technically middleware since it modifies a user request. You will see in the diagram at the end. In line 13, we access the number of people in the party from the parameters of the request object. That is not declared anywhere since the request came from the user, and we do not have any front-end code. So here is what the request might look like if this was a real app: 12345req = &#123; params: &#123; amount: 2; &#125;&#125; In line 13, our party variable accesses the amount property of the params object within the request. Finally in line 14, we send a response back to the customer: we are looking for the appropriately sized table. That is a lot at once. Here is a diagram: Step 3.5: making your restaurant efficient (router)Now you can trace the full path from request to response. But as your app grows in size, you will not want to code the rules for each route individually. You will find that some routes share the same rules, so you need to find a way to apply one set of rules to multiple routes. In terms of seating, you can either seat your customers at the bar or at a table. Those have rules in common like shirt + shoes, but seating at the bar requires every member of the party to be 21. And, in terms of serving customers, you will need to use a slightly different procedure for serving the appetizer, main course, and dinner. But, those three routes have plenty in common as well. This is where the router comes in. The router lets you group your routes so that you can create common rules. We need to create middleware to cover each of these cases. I will just cover the seating cases for now since it will overwrite the code above. Here is the full code snippet: I am going to cover each part individually. In line 4, we declare our router. In lines 6 and 14, we now have seatingRouter.use() in place of app.use() to indicate that this middleware is only related to seatingRouter routes. Finally, in line 21, we add more middleware to show that every seatingRouter route begins with ‘/seating’. So, if someone requested a seat at the bar, the full path would be ‘/seating/bar.’ This may feel a little out of order, since you might expect the path to be defined when you create the router in line 4. That is normal! Here is that in diagram form: And, when you add a GET route, it goes above the last statement where you assign routes to the router. Step 4: opening for business (ports)Okay, last part. So far, you have hired a manager, defined what to do before accepting customer requests, and determined what to do with specific customer requests once they come in. Now, you just need to determine the address for the location where all this will happen. Your server has ports that are kind of like the address for the restaurant itself.Since your server can handle many types of restaurants (or server-side scripts) at once, you need to tell it where each script should run. In the example above, the port is 3000 and it is located on your computer. So if you type: 1[https://localhost:3000/](https://localhost:3000/) into your browser, and you are running your Node app, the server knows to run the specific script. In this case, as soon as you enter the URL, you will log the message in the console and be able to use any of your routes. If the restaurant itself is your entire app, then it is now open for business at the address 3000.","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://nthung2112.github.io/tags/nodejs/"},{"name":"expressjs","slug":"expressjs","permalink":"http://nthung2112.github.io/tags/expressjs/"}]},{"title":"Các nguyên tắc cơ bản của Redux","slug":"Cac-nguyen-tac-co-ban-cua-Redux","date":"2017-10-10T15:41:15.000Z","updated":"2017-10-10T15:48:47.120Z","comments":true,"path":"2017/10/Cac-nguyen-tac-co-ban-cua-Redux.html","link":"","permalink":"http://nthung2112.github.io/2017/10/Cac-nguyen-tac-co-ban-cua-Redux.html","excerpt":"Redux là gì và tại sao phải cần nó trong React/React Native Ngoài Redux ra thì còn cái nào để quản lý state nữa không? 3 Nguyên tắc của Redux Nguyên tắc 1: Store ( Single Source of Truth ) Nguyên tắc 2: Action ( State is Read-Only ) Nguyên tắc 3: Reducer ( Changes are made with Pure Functions ) Tóm tắt cách hoạt động: Bức tranh tổng quát của Redux Cách học Redux Chia sẻ cách học Redux: Một số resources hay","text":"Redux là gì và tại sao phải cần nó trong React/React Native Ngoài Redux ra thì còn cái nào để quản lý state nữa không? 3 Nguyên tắc của Redux Nguyên tắc 1: Store ( Single Source of Truth ) Nguyên tắc 2: Action ( State is Read-Only ) Nguyên tắc 3: Reducer ( Changes are made with Pure Functions ) Tóm tắt cách hoạt động: Bức tranh tổng quát của Redux Cách học Redux Chia sẻ cách học Redux: Một số resources hay Redux là gì và tại sao phải cần nó trong React/React NativeTóm tắt React: Nguyên tắc một app React là dựa vào component. Mỗi component có state và props. Nếu state của một component thay đổi thì nó sẽ được render lại. Props để truyền data từ component cha sang component con Vấn đề là khi ta muốn truyền props từ 2 component không phải cha-con thì sẽ xảy ra vấn đề Ví dụ sau, một app nhỏ chỉ có Main -&gt; Parent -&gt; Child như sau thì truyền props đơn giản Nhưng với app phức tạp hơn một tý, khi muốn truyền props giữa 2 component không phải cha-con thì rất phức tạp: Đó là lý do tại sao nên dùng Redux: Tóm lại cần một cơ chế để quản lý state trong React/React Native. Không phải cứ React/React Native là phải dùng Redux. Cũng không phải Redux chỉ được dùng trong React/React Native Ngoài Redux ra thì còn cái nào để quản lý state nữa không?Thực ra Redux dựa theo ý tưởng của Flux. Ngoài Redux ra bạn có thể dùng: Mobx ( Cài này phổ biến chỉ sau Redux ) Jumpsuit ( đặt tên ngáo thật ) Nhưng lập trình React Native thì nên dùng Redux với Mobx. 3 Nguyên tắc của ReduxĐáng lẽ ra mình sẽ viết bài “Tại sao cần Redux và cách dùng”. Nhưng để hiểu được tại sao và cách dùng thì nên hiểu nguyên tắc chính của nó, từ đó khi học chúng ta sẽ để ý những nguyên tắc này mà học theo. Nơron thần kinh trong não mới bắt đầu liên kết lại. Cũng giống như bạn học lập trình hướng đối tượng sẽ có 4 nguyên tắc: trừu tượng, đóng gói, kế thừa, đa hình vậy. Từ đó mới học class , object, properties, method, access modifier, khởi tạo, kế thừa, interface, vv Nguyên tắc này từ đâu? Đương nhiên từ nhóm tạo ra nó rồi, một trong đó là Dan Abramov Nguyên tắc 1: Store (Single Source of Truth)Chỉ có một cây object trong một ứng dụng, và người ta đặt nó là store.Ví dụ mình có viết một ứng dụng tìm việc làm đơn giản: Thì sẽ được một store như sau: auth: dùng để quản lý đăng nhập jobs: danh sách job tải từ web service likedJobs: danh sách job đã thích Nguyên tắc 2: Action (State is Read-Only)Không update store trực tiếp được, muốn thay đổi cái store thì phải truyền action vào. Mà action nghe cao siêu vậy thôi, chứ nó chỉ là một object trong Javascript. Quy định duy nhất của của object này là phải có type. ( type thường là chuỗi string )Ví dụ action đăng nhập Facebook thành công: Ví dụ action thích một công việc nào đó: Nguyên tắc 3: Reducer (Changes are made with Pure Functions)Sẽ có một cái hàm nhận cái action ở trên, rồi trả về state mới. Mà hàm này phải là pure function. Mà pure function là sao? Cái pure function này viết cả bài cũng được. Nhưng đại ý chính là pure function không gây side effects như: thay đổi giá trị tham số, không gọi web service hay database trong hàm này. Tóm tắt cách hoạt động:Khi người dùng nhấn like một job ( nhấn button like ) -&gt; tạo action: Sau đó Reducer là một cái hàm, nó trả về state mới Sau đó ở component nào muốn xài thì liên hệ store để truy cập dữ liệu trong store. Bức tranh tổng quát của ReduxHình này mới mô tả một chiều của dữ liệu: giữa action, reducer và store Đây mới là hình đầy đủ: Cách học ReduxĐương nhiên còn có nhiều phần chi tiết bên trong mình chưa đề cập đến như: Action Creator: dùng để tạo action, thao tác logic. Chúng cũng là những hàm bình thường nhưng sẽ trả về là action thôi chứ không có gì gê gớm. createStore: tạo store applyMiddleware: thành phần trung gian như lưu store offline ( local storage ), async action như tải data trên web service, vv connect, mapStateToProps: kết nối store với component, để component có thể xài được state trong store. Chia sẻ cách học Redux: Xem video hướng dẫn từ chính anh tạo ra Redux:https://egghead.io/courses/getting-started-with-redux Lên youtube xem cách dùng redux trong một ứng dụng React/React Native để hiểu được những phần còn thiếu ở trên cũng như cách tổ chức code trong ứng dụng. Đọc document của Redux từ đầu đến cuối, trong này có hướng dẫn code app To Do List:http://redux.js.org/docs/introduction/ Muốn master thì viết lại các hàm, các middleware như connect, applyMiddleware. Mà muốn làm được thì cũng phải master React tại phải dùng Higher-Order Components Một số resources hayThe Complete React Native and Redux Course Advanced React and Redux Hình chôm từ: https://www.udemy.com/full-stack-universal-react-with-redux-express-and-mongodb/ https://www.theodo.fr/blog/2016/03/getting-started-with-react-redux-and-immutable-a-test-driven-tutorial-part-2/","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://nthung2112.github.io/tags/redux/"}]},{"title":"Kiến trúc tổng quan của Angular 2/4 - P2","slug":"Kien-truc-tong-quan-cua-Angular-2-4-P2","date":"2017-10-01T09:02:02.000Z","updated":"2017-10-01T10:01:15.067Z","comments":true,"path":"2017/10/Kien-truc-tong-quan-cua-Angular-2-4-P2.html","link":"","permalink":"http://nthung2112.github.io/2017/10/Kien-truc-tong-quan-cua-Angular-2-4-P2.html","excerpt":"Data bindingHãy tưởng tượng rằng, bạn đang phải code 1 ứng dụng web mà việc tương tác, thay đổi giá trị trên DOM diễn ra liên tục. Sẽ thực sự là 1 cơn ác mộng nếu bạn phải tự tay thực hiện toàn bộ các thao tác update, create value trên các HTML DOM khi có hành động của người dùng mà không sử dụng 1 framework nào khác ngoài mấy thư viện kiểu jQuery :-s Với Angular, chúng ta có 1 thuật ngữ là data binding, một cơ chế phối hợp nhịp nhàng các thành phần của template với component. Việc này rất đơn giản, chúng ta chỉ cần thêm binding markup vào HTML là Angular tự hiểu và connect chúng tới Component. Như diagram bên dưới, có 4 kiểu data binding syntax. Mỗi kiểu đều có chiều dữ liệu từ DOM tới COMPONENT, từ COMPONENT tới DOM, và có cả kiểu có 2 chiều dữ liệu.","text":"Data bindingHãy tưởng tượng rằng, bạn đang phải code 1 ứng dụng web mà việc tương tác, thay đổi giá trị trên DOM diễn ra liên tục. Sẽ thực sự là 1 cơn ác mộng nếu bạn phải tự tay thực hiện toàn bộ các thao tác update, create value trên các HTML DOM khi có hành động của người dùng mà không sử dụng 1 framework nào khác ngoài mấy thư viện kiểu jQuery :-s Với Angular, chúng ta có 1 thuật ngữ là data binding, một cơ chế phối hợp nhịp nhàng các thành phần của template với component. Việc này rất đơn giản, chúng ta chỉ cần thêm binding markup vào HTML là Angular tự hiểu và connect chúng tới Component. Như diagram bên dưới, có 4 kiểu data binding syntax. Mỗi kiểu đều có chiều dữ liệu từ DOM tới COMPONENT, từ COMPONENT tới DOM, và có cả kiểu có 2 chiều dữ liệu. Ở ví dụ HeroListComponent, template có 3 kiểu: app/hero-list.component.html (binding) 123&lt;li&gt;&#123;&#123;hero.name&#125;&#125;&lt;/li&gt;&lt;hero-detail [hero]=\"selectedHero\"&gt;&lt;/hero-detail&gt;&lt;li (click)=\"selectHero(hero)\"&gt;&lt;/li&gt; Markup có chức năng hiển thị giá trị của component’s hero.name property với thẻ . Markup [hero] property binding truyền giá trị của selectedHero từ parent HeroListComponent tới các hero property của HeroDetailComponent. (click) event binding gọi phương thức selectHero khi user click vào hero’s name. Kiểu quan trọng thứ 4, được gọi là Two-way data binding. Chỉ với 1 markup notation đơn giản sử dụng ngModel directive, ta có thể kết hợp việc binding event và property. app/hero-detail.component.html (ngModel) 1&lt;input [(ngModel)]=\"hero.name\"&gt; Angular xử lý toàn bộ data bindings trên mỗi JavaScript event, xuất phát từ gốc của cây application component duyệt tới toàn bộ components lá. Data binding đóng một vai trò quan trọng trong việc giao tiếp giữa template và component. Data binding còn là công cụ giao tiếp giữa parent và child components. DirectivesAngular templates là dynamic. Khi ứng dụng Angular thực hiện render template, chúng transforms DOM theo các lệnh nhận được từ directives. Một directive là một class bắt đầu với @Directive decorator. Có thể coi một component là một directive-với-một-template; @Component decorator thực chất là một @Directive decorator kế thừa từ template-oriented features. While a component is technically a directive, components are so distinctive and central to Angular applications that this architectural overview separates components from directives. Câu trích dẫn trên cho chúng ta lý do tại sao chúng ta lại tách Component ra khỏi Directive trong kiến trúc Angular. Có 2 loại directives: structural và attribute directives. Chúng xuất hiện giữa element tag như 1 thuộc tính (attributes). Structural directives tùy chỉnh layout bằng cách thêm mới, xóa bỏ và thay thế elements trong DOM. Ví dụ dưới đây sử dụng 2 loại built-in structural directives: app/hero-list.component.html (structural) 12&lt;li *ngFor=\"let hero of heroes\"&gt;&lt;/li&gt;&lt;hero-detail *ngIf=\"selectedHero\"&gt;&lt;/hero-detail&gt; *ngFor giúp liệt kê các hero từ mảng heroes trong mỗi thẻ &lt;li&gt; *ngIf include HeroDetail component nếu có một hero được select. Attribute directives thay thế appearance hoặc behavior của các element. Bên trong templates, chúng chẳng có gì khác các HTML attributes thông thường, ngoại trừ tên :)) ngModel directive, implements two-way data binding, là một ví dụ của attribute directive. ngModel thay đổi behavior của element (Ví dụ tiêu biểu là các &lt;input&gt;) bằng cách thiết lập value property hiển thị ra cũng như thay đổi chúng theo events. app/hero-detail.component.html (ngModel) 1&lt;input [(ngModel)]=\"hero.name\"&gt; Ngoài ra, chúng ta còn nhiều directives có thể chỉnh sửa cấu trúc layout (ngSwitch) hoặc thay đổi DOM elements và components (ngStyle và ngClass). Dĩ nhiên, bạn cũng có thể tự viết một directives. Components như HeroListComponent chính là một loại custom directive. Services Service có thể là bấy kỳ giá trị, hàm, class,… tính năng nào cần thiết cho ứng dụng của bạn hoạt động. Hầu hết mọi thứ đề có thể trở thành service (lol). Một service điển hình là một class được thu hẹp lại trong một mục đích rõ ràng. Ví dụ: logging service data service message bus tax calculator application configuration Không có một chút đặc trưng của Angular về services. Angular cũng không có bất kỳ định nghĩa nào về service. No service base class, and no place to register a service. Tuy nhiên services lại là nền tảng của bất kỳ ứng dụng Angular nào. Components cũng là một services. Dưới đây là một service class có nhiệm vụ logs lên browser console: app/logger.service.ts (class) 12345export class Logger &#123; log(msg: any) &#123; console.log(msg); &#125; error(msg: any) &#123; console.error(msg); &#125; warn(msg: any) &#123; console.warn(msg); &#125;&#125; Còn đây là HeroService có nhiệm vụ lấy về mảng các heroes và trả về chúng cùng với resolved Promise. HeroService phụ thuộc vào Logger service và BackendService khác nắm giữ việc communication với server. app/hero.service.ts (class) 12345678910111213141516export class HeroService &#123; private heroes: Hero[] = []; constructor( private backend: BackendService, private logger: Logger) &#123; &#125; ) getHeroes() &#123; this.backend.getAll(Hero).then( (heroes: Hero[]) =&gt; &#123; this.logger.log(`Fetched $&#123;heroes.length&#125; heroes.`); this.heroes.push(...heroes); // fill cache &#125;); return this.heroes; &#125;&#125; Services are everywhere. Component classes như một miếng thịt nạc không có mỡ =)) . Không có bất kì đoạn code nào fetch data từ server, validate user input, hoặc log lên console. Tất các các tasks đó được giao cho services. Công việc của một component lúc này không hơn việc cho phép người sử dụng trải nghiệm dịch vụ. Đứng giữa view (rendered bởi template) và tầng application logic. Khi code Angular, không ai ép bạn làm theo parttern này, cũng không quy định nguyên tắc gì về service, tuy nhiên chắc hẳn mọi người sẽ không phàn nàn nếu bạn hoàn thành 1 component với hơn 3000 lines code =)) Angular giúp ta thực hiện các nguyên tác này dễ dàng hơn bằng cách support Dependency injection. Dependency injection Dependency injection là một cách cung cấp các new instance của một class cùng với các dependencies phụ thuộc mà nó cần. Hầu hết các dependencies là services. Angular sử dụng dependency injection để chuẩn bị một new component cùng với các services mà nó cần.@Việc khai báo các services cần thiết cho một component cũng với kiểu dữ liệu của nó được thực hiện trong chính constructor parameters. Ví dụ về constructor của HeroListComponent và HeroService ở đây chính là một dependency : app/hero-list.component.ts (constructor) 1constructor(private service: HeroService) &#123; &#125; Khi Angular khởi tạo một component, nó sẽ hỏi injector về các services mà component cần. Một injector lưu giữ container các service instances đã được tạo trước đó. Nếu có một yêu cầu về service instance không có trong container, injector sẽ tạo và thêm mới nó rồi add nó vào container trước khi trả lại service cho Angular. Khi tất cả các request services được giải quyết (resolved) và được hoàn thành (returned), Angular có thể gọi các component’s constructor cùng với các tham số là các services. Đó chính là dependency injection. Quá trình injection của HeroService có thể trông giống sơ đồ sau: Nếu injector không có HeroService, Vậy làm thể nào để Angular biết nơi cần lấy và tạo ra nó Như đã mô tả trước đó, bạn cần phải đăng ký (registered) HeroService với provider của HeroComponent cùng injector. Một provider có thể create và return một service. Bạn có thể register providers trong modules hoặc trong components. Thông thường, chúng ta add providers vào root module, ez, ta có instance của service tồn tại ở mọi nơi (ngon). app/app.module.ts (module providers) 12345providers: [ BackendService, HeroService, Logger], Một cách khác, ta có thể register ở level component trong providers property của @Component metadata: app/hero-list.component.ts (component providers) 123456@Component(&#123; moduleId: module.id, selector: 'hero-list', templateUrl: 'hero-list.component.html', providers: [ HeroService ]&#125;) Registering ở level component nghĩa là bạn có thể lấy ra các new instance của service với mỗi một new instance của component đó. Các điểm cần nhớ về dependency injection: Dependency injection được móc vào Angular framework và có thể sử dụng ở mọi nơi. Injector có 2 cơ chế chính. Injector duy trì một container các service instances mà chúng đã tạo ra. Injector có thể tạo mới service instance từ provider. Provider là nơi khai báo cách tạo ra service. Register providers với injectors. THE ENDTham khảohttps://angular.io/docs/ts/latest/guide/architecture.html","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://nthung2112.github.io/tags/angular/"},{"name":"architecture","slug":"architecture","permalink":"http://nthung2112.github.io/tags/architecture/"}]},{"title":"Kiến trúc tổng quan của Angular 2/4  - P1","slug":"Kien-truc-tong-quan-cua-Angular-2-4-P1","date":"2017-10-01T08:43:49.000Z","updated":"2017-10-01T09:59:54.207Z","comments":true,"path":"2017/10/Kien-truc-tong-quan-cua-Angular-2-4-P1.html","link":"","permalink":"http://nthung2112.github.io/2017/10/Kien-truc-tong-quan-cua-Angular-2-4-P1.html","excerpt":"Đôi điều về Angular 2 Hiểu đơn giản là một framework để giúp lập trình viên xây dựng các ứng dụng client với HTML và JavaScript/Typescript … Việc render HTML templates sẽ được thực hiện bởi Angularized-markup, việc cần làm của một developer là viết các component để quản lý template, thêm mới các xử lý logic bên trong các service, đóng gói component và service thành một module. Một ứng dụng Angular2 được chạy dựa trên việc bootstrapping root module vào Angular’s bootstrapper.","text":"Đôi điều về Angular 2 Hiểu đơn giản là một framework để giúp lập trình viên xây dựng các ứng dụng client với HTML và JavaScript/Typescript … Việc render HTML templates sẽ được thực hiện bởi Angularized-markup, việc cần làm của một developer là viết các component để quản lý template, thêm mới các xử lý logic bên trong các service, đóng gói component và service thành một module. Một ứng dụng Angular2 được chạy dựa trên việc bootstrapping root module vào Angular’s bootstrapper. Dựa vào sơ đồ kiến trúc trên ta có thể liệt kê ra 8 thành phần chính tạo ra một ứng dụng Angular 2: Module Component Template Metadata Data Binding Service Directive Dependency Injection ModulesAngular apps sử dụng hệ thống module, hay còn gọi là Angular modules hoặc NgModules.Trong bài viết này chủ yếu là giới thiệu các modules; Để tìm hiểu sâu hơn xin vui lòng tham khảo Angular modules.Mỗi ứng dụng Angular đều phải có ít nhất một Angular module class, là root module, hay còn được đặt tên theo quy ước là AppModule. Trong các ứng dụng nhỏ, đôi khi chỉ có duy nhất 1 module chính là root module , tuy nhiên ở hầu hết các ứng dụng, còn có thêm nhiều feature modules.Dù là root hay là feature module, thì mỗi class đều có @NgModule decorator. Decorators là design pattern thường được dùng để thay đổi hành vi, chức năng của JavaScript classes. Angular cung cấp sẵn nhiều decorators gắn các metadata vào các classes để dễ dàng biết được ý nghĩa và cách thức hoạt động. NgModule là một decorator function (single metadata object) có các thuộc tính mô tả các module. Các thuộc tính quan trọng là: declarations - Khai báo các View classes thuộc về module. Angular có 3 loại view classes: components, directives, pipes. exports - Một tập con của declarations khả dụng trong component templates của các module khác. imports - Các module khác được exported các classes cần thiết bởi component templates được declarations bên trong module này. providers - Tạo ra các global collection of services có thể truy cập ở mọi ngõ ngách của ứng dụng. bootstrap - Main application view, hay còn được gọi là root component, chứa tất cả các app views. Duy nhất root module có thuộc tính bootstrap. Dưới đây là một root module đơn giản: app/app.module.ts 12345678910import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';@NgModule(&#123; imports: [ BrowserModule ], providers: [ Logger ], declarations: [ AppComponent ], exports: [ AppComponent ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; Trong trường hợp này, thuộc tính export của AppComponent chỉ đơn giản mô tả cách export; nó thì không cần thiết trong thực tế. Một root module không có lý do gì để export bất cứ điều gì, đơn giản là các component khác ko cần thiết phải import root module. Khởi chạy ứng dụng bằng cách bootstrapping root module. Trong quá trình development, chúng ta sẽ bootstrap AppModule trong file main.ts. app/main.ts 1234import &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; AppModule &#125; from './app.module';platformBrowserDynamic().bootstrapModule(AppModule); Angular modules vs. JavaScript modulesAngular Module: Class decorator với @NgModule — đây là 1 một tính tăng cơ bản Angular. Javascript Module: JavaScript cũng có một hệ thống module để quản lý các JavaScript objects. Nó hoàn toàn khác biệt và không liên quan tới Angular module system. Trong JavaScript mỗi file là một module và tất cả các đối tượng được định nghĩa trong file đều thuộc về module đó. Các module khai báo đối tượng public bằng cách sử dụng từ khóa export. Các module JavaScript khác sử dụng từ khóa import để truy cập vào đối tượng public từ các module khác. 12import &#123; NgModule &#125; from '@angular/core';import &#123; AppComponent &#125; from './app.component'; 1export class AppModule &#123; &#125; Tìm hiểu thêm về Javascript Module. Angular libraries Angular được ví như 1 con tàu chuyên chở các JavaScript modules. Cũng có thể ví là các library modules. Mỗi Angular library name đều bắt đầu với tiền tố @angular.Bạn cài đặt chúng với npm package manager và import các phần lại bằng câu lệnh JavaScript import. Lấy ví dụ, import Angular’s Component decorator từ @angular/core library như sau: 1import &#123; Component &#125; from '@angular/core'; Bạn cũng có thể import Angular modules từ Angular libraries sử dụng câu lệnh JavaScript import: 1import &#123; BrowserModule &#125; from '@angular/platform-browser'; Trong ví dụ về root module bên trên, application module cần BrowserModule. Để truy cập tới BrowserModule, ta thêm vào @NgModule metadata imports: 1imports: [ BrowserModule ], Theo cách này, ta đang sử dụng cả Angular and JavaScript module systems cùng nhau. ComponentsMột component điều khiển từng chức năng trên màn hình view.Ví dụ, view sau được điều khiển bởi các components: The app root với navigation links. The list of heroes. The hero editor. Chúng ta cần định nghĩa component’s application logic—những gì sẽ support trên view—bên trong một class. Class sẽ tương tác với view thông qua API của các properties và methods. Ví dụ, HeroListComponent có một heroes property trả về 1 mảng các heroes lấy từ service. HeroListComponent cũng có sẵn phương thức selectHero() để get các thuộc tính của selectedHero khi người dùng chọn user từ danh sách. app/hero-list.component.ts (class) 123456789101112export class HeroListComponent implements OnInit &#123; heroes: Hero[]; selectedHero: Hero; constructor(private service: HeroService) &#123; &#125; ngOnInit() &#123; this.heroes = this.service.getHeroes(); &#125; selectHero(hero: Hero) &#123; this.selectedHero = hero; &#125;&#125; Angular creates, updates, và destroys components cùng với user di chuyển xuyên suốt trong application. App có thể lấy các action ở từng thời điểm tron lifecycle thông qua lifecycle hooks, như ngOnInit() được khai báo bên trên. TemplatesChúng ta định nghĩa component’s view với template của nó. Một template là mã code HTML giúp Angular render component. Một template có thể có đôi chút khác biệt với HTML thông thường, đây là 1 ví dụ cho template của HeroListComponent: app/hero-list.component.html 12345678&lt;h2&gt;Hero List&lt;/h2&gt;&lt;p&gt;&lt;i&gt;Pick a hero from the list&lt;/i&gt;&lt;/p&gt;&lt;ul&gt; &lt;li *ngFor=\"let hero of heroes\" (click)=\"selectHero(hero)\"&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;hero-detail *ngIf=\"selectedHero\" [hero]=\"selectedHero\"&gt;&lt;/hero-detail&gt; Mặc dù template này sử dụng các thành phần cơ bản HTML như &lt;h2&gt; và &lt;p&gt;, nhưng cũng có đôi chút khác biệt như *ngFor, , (click), [hero], và &lt;hero-detail&gt; sử dụng Angular’s template syntax. Trên dòng cuối cùng của template, &lt;hero-detail&gt; tag là custom element thể hiện cho new component, HeroDetailComponent. HeroDetailComponent là một component khác với HeroListComponent chúng ta đang xem. HeroDetailComponent mô tả chi tiết từng hero, mà người dùng đã select từ HeroListComponent. HeroDetailComponent là con (child) của HeroListComponent. Element có thể được code thoải mái giữa native HTML elements MetadataMetadata giúp Angular biết cách xử lý các class. Quay trở lại code HeroListComponent bên trên, ta thấy rằng đó chỉ đơn giản là 1 class, ko có dấu ấn gì của 1 framework cả, no “Angular” omg Thực tế, HeroListComponent thực chất chỉ là 1 class. Nó không phải là 1 component cho tới khi ta khai báo nó với Angular. Để khai báo với Angular rằng HeroListComponent là 1 component, ta sẽ gắn thẻ metadata vào class này. Trong TypeScript, việc gắn thẻ metadata sử dụng decorator. Dưới đây là metadata cho HeroListComponent: app/hero-list.component.ts (metadata) 123456789@Component(&#123; moduleId: module.id, selector: 'hero-list', templateUrl: 'hero-list.component.html', providers: [ HeroService ]&#125;)export class HeroListComponent implements OnInit &#123;/* . . . */&#125; Decorator ở đây chính là @Component, định nghĩa class ngay bên dưới như một component class. @Component decorator khởi tạo một object với các thông tin mà Angular cần thể tạo và biểu diễn một component &amp; view. Dưới đây là một số option cấu hình cho @Component: moduleId: Tập hợp các source dựa trên address (module.id) với module-relative URLs như templateUrl. selector: CSS selector ra lệnh cho Angular create và insert một thể hiện component khi nó tìm thấy tag trong parent HTML. Ví dụ, nếu một app’s HTML có chứa , thì Angular sẽ inserts một instance của HeroListComponent view giữa các tags. templateUrl: module-relative address của component’s HTML template. providers: Mảng các dependency injection providers cho services cần thiết để component hoạt động. Đây là 1 cách khai báo với Angular rằng, component’s constructo yêu cầu 1 HeroService để nó có thể thu được danh sách các heroes phục vụ việc hiển thị lên màn hình. Metadata trong @Component giúp Angular biết cách lấy những thành phần chính tạo nên component.Template, Metadata, và Component được sử dụng cùng với nhau với mục đích tạo nên View.Ngoài @Component, chúng ta còn có @Injectable, @Input, và @Output là những decorators rất hay được sử dụng. Tham khảohttps://angular.io/docs/ts/latest/guide/architecture.html","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://nthung2112.github.io/tags/angular/"},{"name":"architecture","slug":"architecture","permalink":"http://nthung2112.github.io/tags/architecture/"}]},{"title":"Các kỹ thuật SEO tối thiểu mà developer cần nắm vững trong lập trình web","slug":"Cac-ky-thuat-SEO-toi-thieu-ma-developer-can-nam-vung-trong-lap-trinh-web","date":"2017-10-01T08:28:15.000Z","updated":"2017-10-01T08:40:38.907Z","comments":true,"path":"2017/10/Cac-ky-thuat-SEO-toi-thieu-ma-developer-can-nam-vung-trong-lap-trinh-web.html","link":"","permalink":"http://nthung2112.github.io/2017/10/Cac-ky-thuat-SEO-toi-thieu-ma-developer-can-nam-vung-trong-lap-trinh-web.html","excerpt":"Trong khi đang làm việc tại công ty Basic (1 công ty của Nhật hoạt động trong lĩnh vực Web &amp; Media Marketing, vận hành 2 website ferret và ferretOne), tôi được giao nhiệm vụ tối ưu hoá công cụ tìm kiếm cho website phocase (1 website bán phụ kiện điện thoại), để hoàn thành công việc này tôi đã phải tìm hiểu và học thêm các kiến thức, tiện đây xin được tổng hợp lại và chia sẻ với các bạn những điều cần nhớ về SEO với vai trò là 1 kỹ sư. TLDR; Bài viết này dành cho nhiều đối tượng nên tương đối dài, hãy chọn lọc các kiến thức cần thiết cho mình thôi nhé :v","text":"Trong khi đang làm việc tại công ty Basic (1 công ty của Nhật hoạt động trong lĩnh vực Web &amp; Media Marketing, vận hành 2 website ferret và ferretOne), tôi được giao nhiệm vụ tối ưu hoá công cụ tìm kiếm cho website phocase (1 website bán phụ kiện điện thoại), để hoàn thành công việc này tôi đã phải tìm hiểu và học thêm các kiến thức, tiện đây xin được tổng hợp lại và chia sẻ với các bạn những điều cần nhớ về SEO với vai trò là 1 kỹ sư. TLDR; Bài viết này dành cho nhiều đối tượng nên tương đối dài, hãy chọn lọc các kiến thức cần thiết cho mình thôi nhé :v ★ Bạn có thể nhận được gì khi đọc bài viết này ? Sự tương tác giữa các Marketer và Director trở nên dễ dàng hơn Nhận biết các đoạn code mà vô tình làm giảm thứ hạng của website trên bộ máy tìm kiếm Đề xuất các giải pháp SEO có thể thực hiện được ở phía Developer Nắm bắt được bức tranh/bối cảnh SEO năm 2017 Nắm bắt chính xác tài liệu được Google chính thức công khaiCó thể tìm kiếm rất nhiều thông tin trên các trang web, nhưng tối thiểu thì hãy thực hiện những chính sách được Google đưa ra về rule của 1 website. Search Engine Optimization Starter Guide Ngoài ra bạn cũng có thể tìm hiểu thêm các thông tin tại website chính thức của Google: Official news on crawling and indexing sites for the Google index ★ Kiểm tra lại các biện pháp SEO trước đó để nắm được các thông tin hữu íchHãy tìm kiếm trong Search Console Help các từ khoá liên quan tới các công việc đã thực hiện từ trước, rất có thể bạn sẽ phát hiện ra những kỹ thuật bị bỏ sót mà mình không hề nghĩ tới. Chẳng hạn nếu như bạn có sử dụng thẻ alt với ảnh trên website, thì tôi khuyên bạn nên thử tìm kiếm trong Search Console Help các ảnh đã được đánh tag trước đó.Việc nhồi nhét quá nhiều keyword trong thẻ alt có thể khiến search engineer đưa vào danh sách spam, đây cũng có thể là cách để bạn phòng tránh việc đó.Search Console Help Chính sách của Google đối với Mobile SiteMobile First Index (MFI)Ngày 5/11/2016, Google chính thức công bố chính sách của mình đối với Mobile site: Mobile-first Indexing Về cơ bản, cho tới thời điểm hiện tại ngoài rank được đánh cho các website hướng PC Desktop, Google còn bổ sung thêm rank cho các website chú trọng nội dung và thiết kế tới SP (Smart phone) Ngày 5/4/2017, Tại hội nghị Next10x Conference, Các kỹ sư của Google đã chính thức công bố mục tiêu áp dụng vào trong năm nay, tuy nhiên chưa công bố chính thức khoảng thời gian. Trước khi áp dụng MFI (Hiện tại) PC Search: Hiển thị theo trình tự của rank cho nội dung PC site SP Search: Hiển thị theo trình tự của rank cho nội dung PC site Sau khi áp dụng MFI (Chưa xác định thời gian) PC Search: Hiển thị theo trình tự chú trọng vào rank cho nội dung SP site (Không có nghĩa là không tính đến rank của PC site) SP Search: Hiển thị theo trình tự của rank cho nội dung SP site ★ Các site có khả năng chịu ảnh hưởng Có sự khác biện lớn giữa phiên bản PC và SP Còn nhiều thông tin tồn tại trên phiên bản cho PC nhưng lại ko có trên phiên bản SP Đã hỗ trợ và có chiến lược SEO cho PC site nhưng lại chưa có cho SP site Ngoài header vs footer ra, các nội dung chính là khác nhau Cấu trúc HTML khác nhau Tốc độ hiển thị cho SP site quá chậm Mobile FriendlyNgày 21/4/2015, Google công bố : thứ tự xuất hiện trên kết quả tìm kiếm có liên quan tới UI, UX trong trường hợp truy cập trang web trên Smart Phone DeviceRolling out the mobile-friendly update Chỉ ảnh hưởng tới thứ tự xuất hiện kết quả tìm kiếm trên Mobile DeviceẢnh hưởng trong phạm vi toàn bộ các ngôn ngữ trên thế giớiÁp dụng cho các page riêng rẽ, chứ không phải toàn bộ trang web Nếu như website đó không được coi là Mobile Friendly sẽ có thứ tự thấp và không được ưu tiên xuất hiện trên kết quả tìm kiếm. Điều này có tác động trực tiếp tới doanh thu của các website thương mại điện tử (EC site) Sử dụng website sau, có thể kiểm tra tính thân thiện với thiết bị mobile của 1 trang webMobile Friendly Check ★ Các hạng mục cần kiểm tra Font size có thích hợp (&gt;= 16px) không? Có sử dụng thẻ meta và chỉ định viewport cho mobile không? Khoảng cách của các liên kết có bị quá hẹp không? (phòng ngừa lỗi) Nội dung trang web có bị tràn ra ngoài màn hình không? Website có được hiển thị trong vòng 3s không? (Nếu việc hiển thị tốn quá &gt; 3s, thì 40% người dùng sẽ thoát trang web đó) Đối với các website không thoả mãn tối thiểu các điều kiện trên sẽ có thể có có thứ hạng thấp trong kết quả tìm kiếm. ★ Mobile Friendly Support &amp; Yêu cầu craw lại websiteBằng cách sử dụng GoogleSearchConsole, bạn có thể nắm rõ được chi tiết các thành phần trên website mình không thoả mãn các hạng mục kiểm tra phía trên.Google Webmaster Home Sau khi giải quyết các vấn đề trên, hãy gửi yêu cầu cho Google crawl lại các URL đó.Chi tiết các bạn có thể tham khảo link sau về việc Yêu cầu Google crawl lại các URL ★ Các hạng mục để đánh giá về UX First view của trang web sẽ được hiển thị trong vòng 1 giây (Google recommended) Chuẩn bị riêng biệt kích thước hình ảnh với PC Site, để giảm dung lượng của một trang web Sử dụng công cụ YUI Compressor và JSMin để rút ngắn đoạn code dài như thư viện Thiết lập các nội dung có thể tab được lớn hơn 48px Để xác nhận tốc độ hiển thị của web site, bạn có thể dụng công cụ: PageSpeed Insights ★ Chuyển tiếp quảng cáoĐối với các quảng cáo chuyển tiếp thì đến khi hiển thị target page, thì hiển thị quảng cáo với link [Skip this page] giống như ảnh bên dưới, từ tháng 11 năm 2016 sẽ vi phạm điều luật của Google. Quote: https://london3.jp/2014/12/skip/ ★ Các tác động dẫn tới việc giảm thứ hạng rank Nội dung chính nằm trong Popup (kể cả Modal) Trước khi dẫn tới main content (nội dung chính) của website thì hiển thị quảng cáo giống trong ảnh trên First view có chưa quảng cáo với kích thước lớn, nếu không scroll thì không thấy được nội dung chính ★ Các tác động không ảnh hưởng tới thứ hạng rank Pop-up cấp quyền sử dụng Cookie Các hiển thị như xác minh độ tuổi với cơ sở dựa vào pháp luật Các page mà chỉ một bộ phận cụ thể người dùng được hiển thị, chẳng hạn như một trang đăng nhập. Banner quảng cáo Pop-up mà không chiếm nhiều diện tích màn hình Hơn nữa, trong cuộc đối thoại giữa Google với người sử dụng có câu hỏi: Về nội dung Pop-up (Quảng cáo) thì, liệu có khả năng nội dung ẩn bên trong nó lại được Googlebot ưu tiên ko ? Về phía Google đã trả lời là:「Chính xác là có khả năng đó」, như vậy thì việc hiển thị quảng cáo dù là = Pop-up hay Modal cũng là không nên. Cài đặt XML Sitemap &amp; Đăng ký RSS FeedCông việc này đã được Google hướng dẫn rất chi tiết tại link sau:Best practices for XML sitemaps &amp; RSS/Atom feeds RSS, Atom Register và PubSubHubbub(PuSH)Được sử dụng như Sitemap, có format tương tự RSS và Atom trong RSS Reader.。 ★ Lợi ích khi đăng ký Feed Chỉ URL được cập nhật gần đây nhất được đăng ký. Tần suất Crawl cao hơn Sitemap thông thường Việc thông báo cho Google các Page được create/update gần đây nhất là một phương pháp sử dụng Feed có tần suất Crawl cao hơn một cách hiệu quả. ★ Thực hiện index theo thời gian thực dựa vào PubSubHubbub (PuSH)Một cách để thực hiện index realtime khác đó là: Sử dụng phương thức PubSubHubbub (hay còn gọi là PuSH) giúp thông báo tới Google các thay đổi tại thời điểm mà các trang được update. Danh sách các repository thực hiện việc implement PuSH được viết trên nhiều ngôn ngữ lập trình Trường hợp code bằng PHP, có thể sử dụng file được Download từ thư viện sau đây:pubsubhubbub-php-master/library/publisher.php 123require_once './publisher.php' ;$publisher = new Publisher('http://pubsubhubbub.appspot.com/');$publisher-&gt;publish_update('http://example.com/article/1'); Đăng ký Sitemap★ HTML Sitemap Sitemap cho người sử dụng truy cập trang web Thường xuyên quản lý để tránh các liên kết lỗi Việc phân loại sẵn các Category giúp cải thiện khả năng sử dụng ★ XML SitemapViệc tạo sẵn một Sitemap có định dạng XML chính là công cụ đắc lực, trợ giúp Search Engine index website của bạnDưới đây là các loại Sitemap: Loại File XML Vai trò sitemap.xml Mô tả cấu trúc website, bao gồm cả mobile sitemap movie.xml Hiển thị các nội dung video trong tìm kiếm image.xml Hiển thị các nội dung ảnh trong tìm kiếm news.xml Khai báo các tệp tin được gửi tới Google News Với mỗi file XML được cài đặt chính xác, góp phần xúc tiến việc index website của bạn Tuy nhiên nếu crawler không visit, chúng ta cần thực hiện cải thiện lại Sitemap đã tạo trước đó Trên SP site việc giới hạn quyền truy cập webiste mobile trên device = .htaccess có thể khiến Search Engine Bot không vô được, vì vậy hãy cho phép Googlebot-Mobile có quyền truy cập. Trong thực tế, đối với việc create/submit Sitemap chúng ta có thể tham khảo thêm tại link Build and submit a sitemap , có hướng dẫn chi tiết các loại tool giúp tạo và test sitemap, rất tiện lợi. ★ Video, Image SitemapViệc Crawler thu thập thông tin tìm kiếm liên quan tới Video và Ảnh là tương đối khó khăn, do đó chúng ta cần sử dụng Sitemap chuyên dụng có chứa thông tin cho Video và Image.Về cách create thì bạn có thể tạo file XML chỉ chứa các video và ảnh mới tạo hoặc bổ sung chúng vào 1 file XML đã tồn tại đều ok, tuy nhiên hãy thiết lập một sitemap chứa nhiều thông tin.Sitemap Protocol : Video extension, Title, Duration, Description Hơn nữa, bằng cách sử dụng Video Sitemap, khi tiến hành tìm kiếm Video lẫn Image trong Search Engine, Video có thể được tìm thấy trong kết quả.Ví dụ file movie.xml như sau: 1xmlns:video=&quot;http://www.google.com/schemas/sitemap-video/1.1&quot; Khi vận hành 1 EC site (Website thương mại điện tử) sử dụng Image Sitemap, doanh nghiệp có thể thu hút và tiếp cận được đối tượng người dùng tìm kiếm sản phẩm muốn mua bằng ảnh trên máy tìm kiếm. Những điều cần lưu ý khi sử dụng tag HTML【Title】Trong SEO, thẻ Title là một trong số những thẻ tag có tầm ảnh hưởng nhất, Trong 1 page chỉ được có 1 thẻ title trong head tag.index.html 123&lt;head&gt; &lt;title&gt;Page title&lt;/title&gt;&lt;/head&gt; Nếu trong thẻ title có từ khóa tìm kiếm của user sẽ được bôi đậm trên kết quả tìm kiếm Mỗi Page nên có 1 thẻ title với nội dung khác nhau Trên kết quả tìm kiếm của Search Engine sẽ chỉ hiển thị tối đa ~32 ký tự trong nội dung của thẻ title Nếu trong thẻ title có chứa các từ khóa không cần thiết sẽ làm giảm trọng số của từ khóa mong muốn được tìm kiếm Nên lựa chọn nội dung của thẻ title sao cho dựa vào đó có thể đoán được phần nào nội dung của web page Cần lưu ý rằng trên Search Engine sẽ chỉ hiển thị khoảng 32 ký tự cho tiêu đề (title) của 1 website, và thậm chí là 24 ký tự khi người dùng tìm kiếm trên thiết bị di dộng.Nếu đặt tiêu đề cho page không liên quan tới nội dung của page sẽ làm giảm lượng người dùng truy cập, dẫn tới rank website bị giảm. Cho dù người dùng có truy cập vào nhưng do nội dung chính và tiêu đề không giống nhau, họ sẽ mau chóng rời đi -&gt; tỷ lệ bounce rate sẽ ngày càng tăng. 【Description】Trước tiên khi thiết lập Description, nội dung hiển thị trên search engine sẽ thay đổi tại đây: Việc thêm mô tả cho nội dung mà người dùng mong muốn tìm kiếm, góp phần làm tăng tỷ lệ click rate trên search result.Tuy nhiên nếu xét về mức độ ảnh hưởng về ranking trong thứ hạng xuất hiện trên Search Engine thì có vẻ là không lớn lắm. Hơn nữa ở thời điểm hiện tại dù không có mô tả rõ ràng cho page thì Google cũng hiện thị Description mà nó tự động tạo ra cho web page. Dựa vào các mô tả mà Google tự động sinh ra cho trang web, với các trường hợp đưa ra Description phán đoán chính xác thông tin trên website: Khuyến khích để Google tự động tạo description cho web page Các page khác nhau phải có nội dung khác nhau Nội dung description cần nhất quán với title tag Trên search engine chỉ hiển thị khoảng 124 ký tự cho phần description Khi tìm kiếm bằng thiết bị di động thì chỉ hiển thị khoảng 80 ký tự cho phần description Không bắt buộc văn phong phải chính xác tuy nhiên nội dung của tag phải rõ ràng, chuẩn xác. Bạn có thể sử dụng tool sau để đánh giá description trên 1 web page: http://seolaboratory.jp/description/ 【h1】Do việc lạm dụng thẻ h1 quá nhiều dẫn tới Google đã hạ chỉ số đánh giá của nó, tuy nhiên do vẫn còn xuất hiện trên kết quả tìm kiếm, nên đối với SEO vẫn còn khá quan trọng. Mỗi page chỉ nên có 1 thẻ h1 Mặc dù Google có công bố chính thức rằng có thể thiết lập nhiều thẻ h1, tuy nhiên nếu làm vậy sẽ gây khó khăn cho việc nhận biết chủ đề của nội dung web page Có thể thiết thể ảnh bên trong thẻ tag h1 /iphone6/?color=”white” 123&lt;h1&gt; &lt;img src=&quot;/images/iphone6_white.jpg&quot; alt=&quot;Danh sách bao da cho điện thoại iPhone 6 được nữ giới ưa chuộm&quot; /&gt;&lt;/h1&gt; Với cách đặt ảnh như trên thì nó cũng được nhận diện như 1 phần của h1 tag, do đó hãy mô tả chính xác ảnh bằng cách thêm nội dung vào thuộc tính alt (văn bản thay thế). ★ Keyword truyền tải bởi TDH (Title Description H1)Nếu bạn đặt từ khóa mình muốn SEO trong tất cả các thẻ TDH（Title Description H1）sẽ là cách đầu tiên giúp Google nhận biết chính xác từ khóa cần SEO.Do đó, cần xem xét 3 thẻ trên có chứa từ khóa mình cần lên top không? Lưu ý với thẻ【img】và thuộc tính 【alt】Bằng cách sử dụng thuộc tính alt mô tả nội dung trong ảnh và video, thì người khiếm thị (Sử dụng tính năng đọc văn bản) hoặc người dùng có tốc độ mạng internet chậm cũng có thể dễ dàng nhận được thông tin về website của bạn, điều này được Google đánh giá rất cao. Tham khảo source code bên dưới về Google Search ConsoleNguồn: https://support.google.com/webmasters/answer/114016?hl=vi Cách sử dụng không tốt thẻ img với thuộc tính alt 123456&lt;img src=\"puppy.jpg\" alt=\"\"/&gt;&lt;img src=\"puppy.jpg\" alt=\"puppy dog baby dog pup pups puppies doggies pups litter puppies dog retriever labrador wolfhound setter pointer puppy jack russell terrier puppies dog food cheap dogfood puppy food\"/&gt; Việc nhồi nhét quá nhiều từ khóa vào thuộc tính alt dẫn tới việc bị google nhận diện thành Spam content. Cách sử dụng tối ưu thẻ img với thuộc tínhalt 123&lt;img src=\"puppy.jpg\" alt=\"puppy\"/&gt;&lt;img src=\"puppy.jpg\" alt=\"Dalmatian puppy playing fetch\"&gt; Nếu có thể thì tốt nhất hãy mô tả bằng câu văn thay vì chỉ sử dụng 1 từ khóa cho các img tag. ★ Các hạng mục khác được khuyến khi khi sử dụng thẻ 【img】 (Không bắt buộc) Thống nhất file name và nội dung thuộc tính alt Có thể thiết lập nội dung trong alt mà không có khoảng trắng Cố gắng thiết lập mô tả cho ảnh sao cho gần với nội dung trong bức ảnh đó nhất có thể Các ảnh tương tự nhau thì nên để trong cùng 1 thư mục host Nếu một ảnh giống nhau được sử dụng ở nhiều nơi, thì hãy mô tả thật chi tiết ảnh đó trên website của mình, khi đó Google sẽ nhận diện ảnh của site bạn là original image, và hiển thị trên search result ! ★ Khả năng index và thu thập dữ liệu ở cùng thời điểm【Khả năng thu thập dữ liệu】Để crawler của GoogleBot dễ dàng thu thập dữ liệu, chúng ta cần Cấu trúc, sử dụng thẻ HTML phải đúng chuẩn Với các page có nội dung liên quan cần có liên kết tới nhau, để đảm bảo khả năng crawler trải dài trên toàn bộ website 【Khả năng index - đánh chỉ mục tìm kiếm】Nếu đã chuẩn bị sẵn các thuộc tính alt cho ảnh, âm thanh, video trên website của mình thì khi GoogleBot crawl sẽ index được chính xác nội dung của chúng. 【a】tagHãy thiết lập chuẩn xác anchor link (text), việc này sẽ giúp truyền tải thông tin tới Google dễ dàng hơn. Các implement có thể ảnh hưởng tới khả năng crawler Sử dụng javascript để di chuyển tới link cần vô (Google có khả năng nhận biết điều đó) Tìm kiếm bên trong website bằng cách gửi form Link content sử dụng FLASH 【rel=”next” or “prev”】Khi thiết lập Pagination cho website cần chỉ định thuộc tính rel với giá trị next hoặc prev ★ rel=”prev/next” được xếp hạng ưu tiên hơn rel=”canonical”Ví dụ vể rel=”canonical” cho mọi người dễ hiểu 1&lt;link rel=\"canonical\" href=\"http://example.com/wordpress/seo-plugin/\"&gt; Cho dù bạn có để link trên các page 2, 3, 4 về page 1 bằng thuộc tính canonical, thì next và prev vẫn được đánh giá ưu tiên hơn canonical, do đó với các URL không có parameter giống nhau như bên dưới sẽ không được tính là next và prev. Ví dụ chưa tối ưu 1234http://example.com/iphone7?page=1http://example.com/iphone7?color=red&amp;page=2http://example.com/iphone7?page=3http://example.com/iphone7?page=4 Ví dụ tối ưu: được tính là next và prev 123456789101112131415// page=http://example.com/iphone7?color=red&amp;page=1http://example.com/iphone7?color=red&amp;page=2http://example.com/iphone7?color=red&amp;page=3http://example.com/iphone7?color=red&amp;page=4// viết tắt p=http://example.com/foo.htmlhttp://example.com/foo.html?p=2http://example.com/foo.html?p=3// Sử dụng URL path thay thế cho param pagehttp://example.com/foo/1/http://example.com/foo/2/http://example.com/foo/3/ ★ Các điểm cần lưu ý 1 page chỉ được phép có 1 next và 1 prev Absolute path thì ngon hơn Relative path URL (Không bắt buộc) Trường hợp hiển thị kết quả tìm kiếm của 1 page có sử dụng điều kiện filter, thì ở trong trang điều kiện đó cũng cần bổ sung thuốc tính next và prev Nếu bạn không muốn hiển thị một page trên kết quả tìm kiếm, hãy học cách sử dụng canonical 【rel=”nofollow”】Với các target link có gắn thuộc tính rel=”nofollow” sẽ không được search engine visit. Thuộc tính này xuất hiện ở thẻ meta và thẻ a.Hơn nữa, khi GoogleBot visit target link, nó cũng tính toán độ tin cậy của các target link trên website và đánh giá thứ hạng site đó. ★ Khuyến khích sử dụng “nofollow” với link trỏ tới các website sau Các bảng tin và ô comment có thể được người dùng nhập Liên kết tới bookmark site Liên kết tới ranking site Liên kết khi nhận được đánh giá bằng tiền powerd by… link ★ Các liên kết có thể gây ảnh hướng xấu tới website cần lưu ý Các link mà người dùng không nhìn thấy, bị ẩn đi cũng như không click được Liên kết qua lại bằng các trang web hỗ trợ liên kết lẫn nhau Các liên kết đến các trang web được Google xác định là có mã nguồn độc hại Sử dụng【robots.txt】để không bị crawl thừaNếu không muốn search engin crawl trong những trường hợp dưới đây, hãy thiết lập file robot.txt Các web page có chất lượng thấp, các web page không muốn xuất hiện trên kết quả tìm kiếm File robots.txt được đặt ở thư mục gốc (root directory) của website, Các Bot search engine sẽ tự động đọc và lấy ra. Ví dụ về nội dung file robots.txt 12345User-Agent: *Disallow: /*/matome/Disallow: /ajax/*.jsonDisallow: /image/Disallow: /search Hơn nữa Google cũng hỗ trợ tool kiểm tra file robots.txt : Google robots.txt Tester 【rel=”noindex”】Hãy sử dụng nó khi bạn có chủ ý muốn 1 page nào đó trên website của mình không xuất hiện trên kết quả tìm kiếm của Google. ★ Điểm khác biệt với robots.txtSử dụng robots.txt đồng nghĩa với việc không cho Bot Search Enginer thu thập dữ liệu cũng như xếp hạng page đó. Trong khi sử dụng noindex thì sau một thời điểm nào đó khi link tới website của bạn được share nhiều trên mạng xã hội, thì SEO rank vẫn còn và link tới web page đó vẫn được xếp hạng. ★ Mục đích chính của việc sử dụng “noindex” Với các page chất lượng thấp, nếu có gắn thuộc tính noindex sẽ ko bị xếp hạng thấp website Support các page chưa được setting trong robots.txt cho tới thời điểm hiện tại 404 Page (Thiết lập ở các page trả về status lỗi 404) Cách thức setting: 1&lt;meta name=”robots” content=”noindex”&gt; ★ Cách kiểm tra tình trạng index của một websiteCó thể dùng Google Search Console - Index Status Hiển thị Rich snippetsRich Snippets là đoạn thông tin đặc biệt dùng để hiển thị các thông tin thêm có trong những bài viết đặc biệt (bài đánh giá, sản phẩm, ứng dụng, công thức nấu ăn, địa chỉ công ty..v.v..) trên các máy tìm kiếm (Google, Yahoo, Bing) nhằm cung cấp thêm những thông tin giá trị đến người tìm kiếm giúp họ xác định kết quả tìm kiếm mà họ đang cần. Nhìn vào kết quả tìm kiếm sau, ta thấy có một điều rất đặc biệt: Xuất hiện ảnh thumbnail trong kết quả :v Rich Snippets có 10 loại phổ biến sau: Author Breadcrumbs Event Organizations People Products Recipes Review Software Application Facebook Share Việc sử dụng các markup bằng cấu trúc được công bố trên schema.org sẽ làm tăng khả năng hiển thị rich snippet trên kết quả tìm kiếm của google.Hiện tại thì rich snippet không ảnh hưởng tới rank của 1 website, tuy nhiên có thể ảnh hưởng tới thứ hạng trong kết quả tìm kiếm: Google Webmaster Central office-hours hangout Ví dụ về 1 page có hiển thị snippets 123456789&lt;section itemscope itemtype=\"http://schema.org/Game\"&gt; &lt;h1&gt;Monster Hunter Game Series&lt;/h1&gt; &lt;span itemprop=\"name\"&gt;Monster Hunter Double Cross&lt;/span&gt; &lt;p itemprop=\"description\"&gt;Latest Monhan Series with 6 large main Monsters&lt;/p&gt; &lt;div itemprop=\"author\" itemscope itemtype=\"http://schema.org/Corporation\"&gt; &lt;p itemprop=\"name\"&gt;CONAMI&lt;/p&gt; &lt;p itemprop=\"email\"&gt;example@conamikan.jp&lt;/p&gt; &lt;/div&gt;&lt;/section&gt; Những lưu ý về URL (Đường dẫn)【Soft 404】Tình trang một page có status=200 nhưng nội dung page đó lại cho biết URL này không tồn tại được gọi là soft 404 Chi tiết thêm về lỗi này bạn có thể tham khảo tại đây: https://support.google.com/webmasters/answer/181708?hl=vi Sử dụng Google Search Console, để dễ dàng confirm lại các page dính lỗi soft 404 Gần đây Google Bot có khả năng phân biệt được lỗi soft 404, nên sẽ ko có hình phạt nào được áp dụng với site dính lỗi này. Trả về status code = 404 khi có lỗi trong CakePHP 1throw new NotFoundException(); Ngoài ra, bạn có thể tìm hiểu thêm về lỗi soft 404 ở đây: https://www.suzukikenichi.com/blog/does-google-penalize-your-site-for-having-soft-404/ Chuẩn hóa URLViệc hiển thị 1 web page có nội dung giống nhau nhưng với nhiều URL khác nhau trên trình duyệt xảy ra khá phổ biến. Tuy nhiên, nếu việc này xảy ra với Google search engine thì có thể website của bạn sẽ bị áp dụng các hình phạt làm giảm thứ hạng tìm kiếm. Chính vì lẽ đó chúng ta cần chuẩn hóa lại URL. ★ Các lợi ích có được khi quy chuẩn hóa đường dẫnGiả sử: Việc url một website có chứa www và ko chưa www được coi là các page khác nhauVấn đề: Lúc này việc đánh giá rank cho website bị phân tán giữa các link có và ko có wwwHướng giải quyết: Có thể chuyển hướng (301 redirect) các page có www sang page ko có www ★ 301 Redirect Wiki: List of HTTP status codes Khi thay đổi tên miền/url, hãy sử dụng chuyển hướng 301 sang đường dẫn mới Từ sau khi thiết lập 301 Redirect, có thể mất tới một tháng đẻ Bot Search crawl lại website ★ Ví dụ sử dụng 301 Redirect Sử dụng 301 Redirect trong việc có và không có www trên URL Loại bỏ việc thêm index.html vào sau URL Trường hợp Pagination /search/?page=1 và /search/ hiển thị nội dung giống nhau Trường hợp có và ko có dấu slash (/) sau URL. Ex: /search/ và /search Lưu ý khi code: tùy vào chức năng của trình duyệt web, nếu thực hiện điều hướng 301 từ 1 URL tới 1 URL nhất định thì việc di chuyển page này sẽ được lưu vào cache cho tới khi trình duyệt xóa nó đi. 【Canonical】Cùng một nội dung tương tự nhau (Có thể là 1 bài viết được chia làm nhiều phần), thì không chỉ người dùng mà Google Bot cũng muốn biết bài viết nào là bài viết gốc, câu trả lời cho vấn đề này chính là thuộc tính rel=”canonical”. Mặt khác chắc hẳn bạn cũng gặp phải trường hợp Single Page và Search Page có chứa 1 lượng lớn nội dung trùng lặp. Nhờ việc thiết lập canonical cho 1 page, mà ta có thể ngăn ngừa được việc Google đánh tụt thứ hạng tìm kiếm từ nội dung bị trùng lặp Ví dụ khi website có 2 phiên bản cho Desktop và Mobile: 12345&lt;head&gt; ... &lt;link rel=\"canonical\" href=\"http://www.example.com/\" /&gt; ...&lt;/head&gt; Ngoài canonical, còn có thể sử dụng đồng thời với alternate được giải thích chi tiết bên dưới. ★ Ví dụ về sử dụng Canonical Trên kết quả tìm kiếm xuất hiện nhiều page có content giống nhau Mobile page và Desktop page có nội dung tương tự nhau Thiết lập URL để Google Analytics tiến hành đo lường các thông số Khi công khai cùng 1 nội dung trên nhiều website Trường hợp không sử dụng 301 redirect Trường hợp sử dụng mirror site để giảm tải cho web/detect DDOS. (Tuyên nhiên việc này ko được khuyến khích sử dụng vì dễ bị nhận diện là spam) 【Alternate】Thẻ alternate được khuyến khích sử dụng khi bạn có : Một phiên bản website được phiên dịch hoàn toàn sang một ngôn ngữ khác 2 trang với cấu trúc, nội dung tương tự nhau và chỉ có một vài điểm nhấn khác biệt về ngôn ngữ trong nội dung Ví dụ: Website example.com 12345&lt;head&gt; ... &lt;link rel=\"alternate\" href=\"http://example.com/\" /&gt; ...&lt;/head&gt; Khi sử dụng alternate, chúng ta thông báo cho Bot biết website cho smart phone là sp.example.com. Khi sử dụng canonical, chúng ta thông báo cho Bot biết phiên bản website chính thức của hệ thống là example.com Website sp.example.com 12345&lt;head&gt; ... &lt;link rel=\"canonical\" href=\"http://sp.example.com/\" /&gt; ...&lt;/head&gt; canonical dùng để thông báo với Search Engine đâu là page gốc (original page). Có thể ví như quan hệ n:1alternate trở thành quan hệ 1:1 khi cùng tham chiếu tới canonical và alternate Thuộc tính canonical và alternate trên website https://ferret-plus.com/1426 đã giúp Bot Search Engine biết được phiên bản nào là website dành cho thiết bị di động. CloakingCloaking là sự che đậy hay che dấu một cái gì đó. Trong kỹ thuật SEO thì cloaking ám chỉ hành động của webmaster che dấu bot của search engine như Google crawl các nội dung mà người dùng nhìn thấy, đồng thời đề xuất cho các cậu Bot nhìn thấy các nội dung được Onpage optimize tốt nhằm mục đích đạt được các vị trí cao trên Search Engine. Việc tồn tại các thông tin trên website mà hiển thị giữa GoogleBot và người sử dụng khác biệt nhau sẽ ảnh hưởng tới thứ hạng hiển thị của website trên kết quả tìm kiếm. (Website có hành vi này sẽ bị google áp dụng các hình phạt) Website khi truy cập = PC hiện ra thông báo「Hãy truy cập bằng smart phone」, dù cho khi User-Agent là smart phone truy cập có hiển thị chính xác đi chăng nữa cũng rất có thể bị Google hiểu là Cloaking ??? Website ở tình trạng bị hack cũng có thể bị đưa vào trạng thái Cloaking, hãy thường xuyên quan sát log để tìm ra các hành động khả nghi và tiến hành deploy lại nếu cần. Đánh giá độ ổn định của URLCác bộ máy tìm kiếm có tiêu chí để xếp hạng URL là: URL đã cung cấp thông tin cho người sử dụng trong một thời gian dài bao lâu?.Do đó khi bạn thay đổi URL, sử dụng 301 Redirect thì cũng ko có gì đảm bảo là toàn bộ ranking của URL trên site cũ sẽ được chuyển hết sang URL site mới. ★ Các hạng mục cần kiểm tra khi thiết kế URL Có chứa ext của file như .php hay không ? Việc này sẽ gây ảnh hưởng nếu chuyển framework ví dụ từ CakePHP sang Rails chẳng hạn. Có thể dùng dấu - hoặc _ trong URL, tuy nhiên Google khuyến khích sử dụng dấu - để phân tách từ khóa Toàn bộ ký tự trong URL phải được viết thường URL dài cũng không vấn đề (Sẽ giải thích sau) URL không nên chia quá nhiều cấp, nằm sâu trong nhiều directory Chứa từ khóa thì càng tốt (Có thể chứa tiếng Nhật) URL không die cho dù sau này có áp dùng nhiều thay đổi SEO đi chăng nữa Không sinh ra duplicated content ★ Đảm bảo việc thiết kế URL không sinh ra nội dung trùng lặpWeb Page bên dưới sinh ra nội dung trùng lặp, dó đó kiểu thiết kế URL này không được khuyến khíchVí dụ：Anime Home Page Hero list page All characters list page Khi đó giả sử ta có nhân vật tên là “yamada”, khi đó nội dung 2 trang sau là giống nhau và đều mô tả về “yamada” heros/yamada.html characters/yamada.html Cùng 1 nội dung nhưng lại khác URL là một thiết kế tồi và bị xếp vào duplicated content. URL dài cũng không vấn đềTheo Google công bố thì độ dài của URL có thể ngắn hoặc dài tùy ý Độ dài của URL thì không ảnh hưởng tới rankingTuy nhiên cần đủ để nhận diện được URL Mặc dù không ảnh hưởng tới SEO, tuy nhiên trình duyệt IE chỉ support URL có độ dài tối đa 2083 ký tự, nên hãy setting URL length &lt;= 2083 ★ Các khuyến khích về URL Vì URL là thứ hiển thị trên kết quả search, nên hãy chọn các từ đơn trong URL có liên quan tới nội dung bài viết Khi URL có chứa từ ngữ trùng với từ khóa mà user search thì sẽ được bôi đậm trên kết quả Search engine sử dụng dấu “-“ để tách từ, nên URL cũng nên sử dụng dấu “-“ để ngăn cách các từ khóa trong nó. Mặt khác việc sử dụng quá nhiều GET parameter như ?color=2 trong URL có thể khiến URL khó nhớ, dễ nhầm lẫn, và khó chia sẻ. Dẫn tới việc truy cập phải URL không chính xác nếu không đủ parameter. Cấu trúc liên kết cần được chú trọng hơn cấu trúc thư mụcChúng ta có 2 đường dẫn sau: https://viblo.asia/cau-truc-duong-dan-nao-tot-cho-seo-file-name-hay-thu-muc.htmlhttps://viblo.asia/seo/seo-onpage/cau-truc-duong-dan-nao-tot-cho-seo-file-name-hay-thu-muc.html Như bạn đã biết, hai đường dẫn trên đều là 2 đường dẫn tối ưu cho SEO. Đường dẫn thứ nhất là đường dẫn kiểu file name và đường dẫn thứ hai là đường dẫn theo kiểu thư mục. Câu hỏi đặt ra ở đây là đường dẫn nào tốt hơn? ★ Nếu cấu trúc thư mục quá sâu có thể khiến Bot ko crawl đượcTham khảo link : https://support.google.com/webmasters/answer/156184?hl=viGoogle Bot sẽ crawl theo thứ tự từ nông tới sâu, dó đó URL ở các cấp sâu mà không được liên kết tới bởi page nào trong site có thể rơi vào tình trạng được crawl chậm và không được đánh index.Với tư cách là developer, bạn đừng quên tạo các link trong site internal liên kết tới các page quan trọng của site. Lưu ý: Việc tạo cấu trúc thư mục đơn giản chỉ giúp cho Google Bot crawl dễ dàng hơn chứ không ảnh hưởng tới thứ hạng trên Search Result. ★ Cấu trúc liên kết ảnh hưởng tới SEOCấu trúc liên kết được tóm gọn trong câu sau: “Khi bạn click vào liên kết bao nhiêu lần cũng vẫn access được page đó”. Cấu trúc link nếu vượt quá 5 cấp có thể khiến Google index chậm. Về cơ bản chỉ nên setting dưới 4 cấp đổ lại. Tham khảo: http://s-supporter.hatenablog.jp/entry/seo-difference-of-the-hierarchy#ディレクトリ階層とリンク階層の違い Lưu ý khi thêm Parameter vào URLTheo kỹ sư John Muelle từ Google thì việc thêm params vào URL của các dynamic page để dễ dàng thay đổi nội dung được khuyến khích. Just wanted to add that from Google’s point of view, the clean, parameterized URL is generally preferred to any unnecessary URL-rewriting. If you want a nice-looking URL-line in search, use breadcrumb markup instead. Tuy nhiên trên kết quả search thì với những page động sử dụng params để thay đổi nội dung cần thiết lập thêm Canonical để tránh xảy ra hiện tượng duplicated content. Dùng GET params sẽ làm giảm indexViệc sử dụng quá nhiều GET params có thể làm khả năng index giảm đi, do đó cần tránh thêm quá nhiều param là URL quá dài, hoặc thực hiển chuyển đổi url động sang url tĩnh với param ngắn hơn. ★ Chuyển đối URL tĩnhViệc chuyển đổi URL động sang tĩnh có thể hiểu đơn giản như sau: loại bỏ bớt GET params, chuyển nó vào path của URL Ví dụ:Ta có 1 URL khá dài với 3 GET params 1https://phocase.jp/iphone7/?color=3&amp;material=3&amp;category=cute Ta sẽ đưa category vào path của URL, lúc này số lượng params chỉ còn là 2 1https://phocase.jp/iphone7/cute/?color=3&amp;material=3 ★ Các điểm cần lưu ý khi chuyển đổi sang URL tĩnh Loại bỏ các params không cần thiết Không quản lý param theo session ID Thực hiển chuyển đổi các params có thẻ đưa vào URL path Không nên đưa quá nhiều param vào URL path dẫn tới URL quá dài, giảm khả năng index cũng như crawl URL càng có ý nghĩa càng tốt ★ Các thức đơn giản để thực chuyển đổi tĩnhĐể chuyển đổi sang URL tĩnh có thể implement lại routing của system, tuy nhiên cách đơn giản nhất là thiết lập lại file .htaccess 123RewriteEngine OnRewriteRule http://phocase.jp/([0-9]+)/$ http://phocase.jp/?color=$1 [L,NC] How To Create Temporary and Permanent Redirects with Apache and Nginx Các điểm cần lưu ý với Site contentSite có số lượng index lớnTheo nguồn tin chính thức từ Google thì việc 1 website có quá nhiều page không được chú trọng vào nội dung sẽ được coi là 1 website vô nghĩa, chỉ nên tập trung vào 1 số lượng page có nội dung được chú trọng thay vì tạo ra hàng loạt các page có nội dung nghèo nàn. ★ Site ranking Thông tin chỉ được tồn tại/sở hữu duy nhất bởi website Có chứ nhiều nội dung dễ hiểu như ảnh và video Mô tả thông tin chi tiết, rõ ràng và dễ hiểu Khi implement các page động thì số lượng page được index sẽ tăng lên, do đó cần xác định trước số lượng tối đa page sẽ được sinh ra. ★ Cách thức đối ứng Sử dụng chức năng URL parameter trong Google Search Console Sử dụng noindex content bằng file robots.txtJapanese search quality guidelines Tồn tại nội dung hữu ích với First View không?Khi truy cập 1 website mà ko thực hiện scroll xuống dưới, thì phạm vi người dùng quan sát được trên màn hình lúc này được gọi là First view Về cơ bản First view có kích thước khoảng 500×950px thì cần lưu ý những điểm sau: ★ Các điểm cần lưu ý Không setting external link Setting keyword cho SEO vừa phải Thiết lập alt cho ảnh, và tên file ảnh phải có liên quan tới nội dung bức ảnh Các công cụ mà tác giả đang sử dụng https://adwords.google.co.jp/KeywordPlanner http://www.related-keywords.com https://www.google.com/intl/ja_jp/analytics https://www.similarweb.com","categories":[],"tags":[{"name":"seo","slug":"seo","permalink":"http://nthung2112.github.io/tags/seo/"}]},{"title":"Tạo loading Facebook bằng CSS thật đơn giản!","slug":"Tao-loading-Facebook-bang-CSS-that-don-gian","date":"2017-09-27T04:31:18.000Z","updated":"2017-10-01T08:27:03.106Z","comments":true,"path":"2017/09/Tao-loading-Facebook-bang-CSS-that-don-gian.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Tao-loading-Facebook-bang-CSS-that-don-gian.html","excerpt":"Dạo gần đây nhà mình hay mất mạng, mà ai cũng biết rồi dân IT, Design, Gaming, XXX, mà không có internet thì hỡi ơi cứ như là sống ở thời kì đồ đá. Nhưng cũng nhờ thế mà tình cờ phát hiện được cái loading hay hay của facebook, twitter, bitbucket … nếu mạng bạn quá chậm nó sẽ show ra tương tự giống này. Sau đây là chút tò mò và mô phỏng để có được sự nhấp nháy kì lạ đó.","text":"Dạo gần đây nhà mình hay mất mạng, mà ai cũng biết rồi dân IT, Design, Gaming, XXX, mà không có internet thì hỡi ơi cứ như là sống ở thời kì đồ đá. Nhưng cũng nhờ thế mà tình cờ phát hiện được cái loading hay hay của facebook, twitter, bitbucket … nếu mạng bạn quá chậm nó sẽ show ra tương tự giống này. Sau đây là chút tò mò và mô phỏng để có được sự nhấp nháy kì lạ đó. Vẽ Photoshop cái khungBước này chỉ để chảnh chó là biết Photoshop thôi nha, chớ ai dùng gì vẽ cũng được, hoặc đếch cần vẽ cũng chẳng sao :D! Mình chụp cái hình nó lại, mở cái gì đó lên check lại được mấy cái mã màu của nó.Cụ thể là: Thumnail: #f6f7f9; background: #e9ebee; background line: #ebedf0; box-shadow: #d0d1d5; còn thiếu màu trắng tinh của trung tình cho các box bự.Các bác có thắc mắc vụ lấy mã màu gì không? Nói chung các bác lấy mã nào cũng được tại đang chém nên vẽ bậy đó thôi. Okay, xong vụ lấy mã màu, giờ thì xác định vị trí cũng như kích thước của từng thành phần trong của cái box này. Cụ thể là: Thumbnail: 40x40 Line: height 6px còn width thì tuỳ chỉnh thấy đụp đụp là ổn nhé các bác Khoản cách của line: 13px, số hơi xui tí. Cái box bự: 520x325. Thế là có dữ liệu thô rồi, nhào vào phần lên cúc trúc html nào. Lên cấu trúc HTMLRồi bây giờ chúng ta tạo 1 thưc mục, tạo 1 file tên là index.html mở nó lên bằng editor nào mà bạn thích, rồi chiến: Nghía qua cái box bằng đôi mắt không được lé của chúng ta thì các thành phần chính như sao: Cái box to class=”box-loading” Cái thumbnail class=”box-thumbnail” Có khoản 5 cái line với các kích thước khác nhau nên chúng ta có thể đặt tên là “box-line-xs, -sm, -df, -lg, -lgx” 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Loading-facebook&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box-loading\"&gt; &lt;div class=\"box-thumbnail\"&gt;&lt;/div&gt; &lt;div class=\"box-line-sm\"&gt;&lt;/div&gt; &lt;div class=\"box-line-xs\"&gt;&lt;/div&gt; &lt;div class=\"box-line-df\"&gt;&lt;/div&gt; &lt;div class=\"box-line-lgx\"&gt;&lt;/div&gt; &lt;div class=\"box-line-lg\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Okay vậy là xong rồi cái phần html nhé, quá nhanh và quá huy hiểm. Lên cấu trúc CSSĐã done html rồi thì bây giờ ta tạo 1 file style.css nhé. Để tô màu chơi cho vui thôi.Nhớ link vào file html nhé 1&lt;link href=\"style.css\"&gt; Sau đó ta mở file style.css và viết vào giống thế lầy. 123456789101112131415161718body &#123; background: #e9ebee;&#125;.box-loading &#123; background: #fff; height: 325px; width: 520px; display: block; box-shadow: 0 1px 1px rgba(0,0,0,0.1); -o-box-shadow: 0 1px 1px rgba(0,0,0,0.1); -moz-box-shadow: 0 1px 1px rgba(0,0,0,0.1); -webkit-box-shadow: 0 1px 1px rgba(0,0,0,0.1); border-radius: 3px; -o-border-radius: 3px; -moz-border-radius: 3px; -webkit-border-radius: 3px; margin: 0 auto;&#125; Để có được kết quả là cái box: Canh chỉnh box content Phần box-shadow mình viết như thế để nó gần giống với mã màu của cái line trên facebook và cũng như là all device, để vào phần Sass các bạn sẽ thấy thú vị hơn ở chổ này nhé. Tiếp đến là mấy cái line: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556body &#123; background: #e9ebee;&#125;// cái nào có class là box- thì nó sẽ nhận css[class*=\"box-\"] &#123; height: 6px; width: 400px; background: #f6f7f9; margin-bottom: 13px; margin-right: 5px;&#125;.box-loading &#123; background: #fff; height: 305px; width: 500px; padding: 10px; display: block; box-shadow: 0 1px 1px rgba(0,0,0,0.1); -o-box-shadow: 0 1px 1px rgba(0,0,0,0.1); -moz-box-shadow: 0 1px 1px rgba(0,0,0,0.1); -webkit-box-shadow: 0 1px 1px rgba(0,0,0,0.1); border-radius: 3px; -o-border-radius: 3px; -moz-border-radius: 3px; -webkit-border-radius: 3px; margin: 0 auto;&#125;.box-thumbnail &#123; height: 40px; width: 40px; float: left; margin-right: 20px; display: inline-block;&#125;// chịu khó viết style cho từng line nhé.box-line-sm &#123; width: 120px; margin-top: 10px; margin-left: 50px;&#125;.box-line-xs &#123; width: 80px; margin-left: 50px;&#125;.box-line-df &#123; margin-top: 30px; width: 380px;&#125;.box-line-lg &#123; width: 200px;&#125;.box-line-lgx &#123; width: 450px;&#125; Animation CSS loadingCác bạn thấy nãy giờ toàn là trò mèo đúng không? Giờ chúng ta mới vào phần trọng tâm của cái loading facebooking 1234567891011121314151617[class*=\"box-line\"],.box-thumbnail &#123; animation: timeline; // tên của animation để truyền action animation-duration: 1s; // thời gian thực thi action animation-timing-function: linear; // hiệu ứng cho action, có nhiều lắm thực chất nó là cubic-bezier, ai muốn custom thì xem link này http://cubic-bezier.com animation-iteration-count: infinite; // số lần chạy action, mình cho nó vô tận luôn background: linear-gradient(to right, #eeeeee 8%, #dddddd 18%, #eeeeee 33%); // gradient cho từng cái line background-size: 800px auto; // kích thước của cái bóng mờ mờ (gradient)&#125;// hành động của animation cho nó chạy từ trái sang phải@keyframes timeline &#123; 0% &#123; background-position: -350px 0;&#125; 100% &#123; background-position: 400px 0; &#125;&#125; Recode CSS thành SASSCái này cũng chẳng có gì hấp dẫn lắm, nhưng viết luôn cho bác nào thích chơi với thằng thứ ba thì chơi: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081body &#123; background: #e9ebee;&#125;[class*=\"box-\"] &#123; height: 6px; width: 400px; background: #f6f7f9; margin-bottom: 13px; margin-right: 5px;&#125;@mixin box-shadow($box_shadow) &#123; box-shadow: $box_shadow; -o-box-shadow: $box_shadow; -moz-box-shadow: $box_shadow; -webkit-box-shadow: $box_shadow;&#125;@mixin border-radius($border_radius) &#123; border-radius: $border_radius; -o-border-radius: $border_radius; -moz-border-radius: $border_radius; -webkit-border-radius: $border_radius;&#125;.box &#123; &amp;-loading &#123; background: #fff; height: 305px; width: 500px; padding: 10px; display: block; margin: 0 auto; @include box-shadow(0 0 0 rgba(0,0,0,0.1)); @include border-radius(3px); &#125; &amp;-thumbnail &#123; height: 40px; width: 40px; float: left; margin-right: 20px; display: inline-block; &#125;&#125;.box-line &#123; &amp;-sm &#123; width: 120px; margin-top: 10px; margin-left: 50px; &#125; &amp;-xs &#123; width: 80px; margin-left: 50px; &#125; &amp;-df &#123; margin-top: 30px; width: 380px; &#125; &amp;-lg &#123; width: 200px; &#125; &amp;-lgx &#123; width: 450px; &#125;&#125;[class*=\"box-line\"],.box-thumbnail &#123; animation: timeline; animation-duration: 1s; animation-timing-function: linear; animation-iteration-count: infinite; background: linear-gradient(to right, #eeeeee 8%, #dddddd 18%, #eeeeee 33%); background-size: 800px auto; background-position: 100px 0;&#125;@keyframes timeline &#123; 0% &#123; background-position: -350px 0;&#125; 100% &#123; background-position: 400px 0; &#125;&#125; Các bác có thể xem trên này luôn cho tiện nhá. Lời kếtOkay thế là có cái loading của facebook rồi, mặt dù là hàng face nhưng hi vọng cũng có thế giúp ít cho bác nào muốn dùng. Lưu ý: Bạn nên đọc lại kỹ một chút về các thuộc tínhbackground: linear-gradient, background-size, background-position và các thuộc tính animation, trước khi làmNên tự gõ, đừng copy rồi paste, vì như thế bạn chẳng nhớ gì đâu.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"trick","slug":"trick","permalink":"http://nthung2112.github.io/tags/trick/"}]},{"title":"Một bộ phim hoạt hình giới thiệu về Redux","slug":"Mot-bo-phim-hoat-hinh-gioi-thieu-ve-Redux","date":"2017-09-22T07:25:25.000Z","updated":"2017-10-01T08:24:53.462Z","comments":true,"path":"2017/09/Mot-bo-phim-hoat-hinh-gioi-thieu-ve-Redux.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Mot-bo-phim-hoat-hinh-gioi-thieu-ve-Redux.html","excerpt":"One thing that causes even more confusion than Flux is the difference between Flux and Redux, a pattern that was inspired by Flux. In this article I’ll explain the differences between the two. If you haven’t read the last article about Flux, you should do that first.","text":"One thing that causes even more confusion than Flux is the difference between Flux and Redux, a pattern that was inspired by Flux. In this article I’ll explain the differences between the two. If you haven’t read the last article about Flux, you should do that first. Why change Flux?Redux solves the same problems as Flux, plus some. Just like Flux, it makes state changes in apps more predictable. If you want to change state, you have to fire off an action. There’s no way to change the state directly because the thing holding the state (the store) only has a getter, not setters. These basics of Flux and Redux are pretty similar. So why a different pattern? Redux creator Dan Abramov saw an opportunity to improve on Flux. He wanted better developer tools. He saw that if you moved a couple of things around, you could make better developer tools possible, but still have the same predictability that Flux gives you. He wanted hot reloading and time travel debugging (there’s another cartoon to explain these). But there were some problems which made developer tooling hard to do with Flux. Problem 1: The code for stores can’t be reloaded without wiping out the stateIn Flux, the store contains two things: The state change logic The current state itself Having these two on the same object is a problem for hot reloading. When you reload the store object to see the effect that the new state change logic has, you lose the state that the store is holding on to. Plus, you mess up the event subscriptions that tie the store to the rest of the system. Solution Separate these two functions. Have one object that holds on to the state. This object doesn’t get reloaded. Have another object that contains all of the state change logic. This object can be reloaded because it doesn’t have to worry about holding on to any state. Problem 2: The state is being rewritten with every actionIn time travel debugging, you keep track of each version of a state object. That way, you can go back to an earlier state. Each time the state is changed, you need to add the old state to an array of previous state objects. But because of the way JavaScript works, simply adding the variable to the array won’t work. This doesn’t create a snapshot of the object, it just creates a new pointer to the same object. To make it work, each version needs to be an entirely separate object so that you aren’t accidentally changing past versions. SolutionWhen an action comes in to the store, don’t handle it by changing the state. Instead, copy the state and make changes to the copy. Problem 3: There aren’t good places for third-party plugins to jump inWhen you’re making developer tools, you need to be able to write them generically. A user should be able to just drop the tool in without having to custom fit their own code around it. For this to work, you need extension points… places where the code expects to have things added to it. An example is logging. Let’s say you want to console.log() every action as it comes in, and then console.log() the state that results from it. In Flux, you’d have to subscribe to the dispatcher’s updates and to updates from each store. But that’s custom code, not something a third-party module can easily do. SolutionMake it easy to wrap parts of the system in other objects. These other objects add their bit of functionality on top of the original. You can see these kinds of extension points in things like “enhancers” or “higher order” objects, as well as middleware. In addition, use a tree to structure the state change logic. This makes it so the store only emits one event to notify the views that the state has changed. This event comes after the whole state tree has been processed. Note: With these problems and solutions, I‘m focusing on the developer tooling use case. These changes help in other use cases, too. On top of that, there are other differences between Redux and Flux. For example, Redux also reduces boilerplate and it makes it easier to reuse logic in the store. Here’s a list of some other upsides to Redux_._ So let’s see how Redux makes these things possible. The new cast of charactersThe cast of characters changes a little bit from Flux to Redux. Action creators Redux keeps the action creator from Flux. Whenever you want to change the state of the application, you shoot off an action. That’s the only way that the state should be changed. As I said in the article on Flux, I think of the action creator as a telegraph operator. You go to the action creator knowing basically what message you want to send, and then the action creator formats that in a way that the rest of the system can understand. Unlike Flux, action creators in Redux do not send the action to the dispatcher. Instead, they return a formatted action object. The storeI described stores in Flux as over-controlling bureaucrats. All state changes must be made personally by a store and have to go through the action pipeline, instead of being requested directly. The store in Redux is still controlling and bureaucratic, but it’s a little bit different. In Flux, you can have multiple stores. Each store has its own little fiefdom, and it is in total control. It holds on to its little slice of state, and has all the logic for changing that little slice of state. The Redux store tends to delegate more. And it has to. In Redux, there is only one store… so if it did everything itself, it would be taking on too much work. Instead, it takes care of holding on to the whole state tree. It then delegates the work of figuring out what state changes need to happen. The reducers, headed up by the root reducer, take on this task. You might have noticed there’s no dispatcher. That’s because, in a bit of a power grab, the store has also taken over dispatching. The reducersWhen the store needs to know how an action changes the state, it asks the reducers. The root reducer takes charge and slices the state up based on the state object’s keys. It passes each slice of state to the reducer that knows how to handle it. I think of the reducers as a department of white-collar workers who are a little overzealous about photocopying. They don’t want to mess anything up, so they don’t change the state that has been passed in to them. Instead, they make a copy and make all their changes on the copy. This is one of the key ideas of Redux. The state object isn’t manipulated directly. Instead, each slice is copied and then all of the slices are combined into a new state object. The reducers pass their copies back to the root reducer, which pastes the copies together to form the updated state object. Then the root reducer sends the new state object back to the store, and the store makes it the new official state. If you have a small application, you might only have one reducer making a copy of the whole state object and making its changes. Or if you have a large application, you might have a whole tree of reducers. This is another difference between Flux and Redux. In Flux, the stores aren’t necessarily connected to each other and they have a flat structure. In Redux, the reducers are in a heirarchy. This hierarchy can have as many levels as needed, just like the component hierarchy. The views: smart and dumb componentsFlux has controller views and regular views. The controller views act as middle managers, managing the communication between the store and their child views. In Redux, there’s a similar concept: smart and dumb components. The smart components are the managers. They follow a few more rules than the controller views, though: Smart components are in charge of the actions. If a dumb component underneath them needs to trigger an action, the smart component passes a function in via the props. The dumb component can then just treat that as a callback. Smart components do not have their own CSS styles. Smart components rarely emit DOM of their own. Instead, they arrange dumb components, which handle laying out DOM elements. Dumb components don’t depend on action files directly, since all actions are passed in via props. This means that the dumb component can be reused in a different app that has different logic. They also contain the styles that they need to look reasonably good (though you can allow for custom styling — just accept a style prop and merge it in to the default styles). The view layer binding To connect the store to the views, Redux needs a little help. It needs something to bind the two together. This is called the view layer binding. If you’re using React, this is react-redux. The view layer binding is kind of like the IT department for the view tree. It makes sure that all of the components can connect to the store. It also takes care of a lot of technical details so that the rest of the hierarchy doesn’t have to understand them. The view layer binding introduces three concepts: The Provider component: This is wrapped around the component tree. It makes it easy for the root component’s children to hook up to the store using connect(). connect(): This is a function provided by react-redux. If a component wants to get state updates, it wraps itself using connect(). Then the connect function will set up all the wiring for it, using the selector. selector: This is a function that you write. It specifies what parts of the state a component needs as properties. The root component All React applications have root components. This is just the component at the top level of the component hierarchy. But in Redux applications, this component takes on more responsibility. The role it plays is kind of like a C-level executive. It puts all of the teams in place to tackle the work. It creates the store, telling it what reducer to use, and brings together the view layer binding and the views. The root component is pretty hands-off after it initializes the app, though. It doesn’t get caught up in the day-to-day concerns of triggering rerenders. It leaves that to the components below it, assisted by the view layer binding. How they all work togetherLet’s see how these parts work together to create a functioning app. The setupThe different parts of the app need to be wired up together. This happens in setup. 1. Get the store ready. The root component creates the store, telling it what root reducer to use, using createStore(). This root reducer already has a team of reducers which report to it. It assembled that team of reducers using combineReducers(). 2. Set up the communication between the store and the components. The root component wraps its subcomponents with the provider component and makes the connection between the store and the provider. The Provider creates what’s basically a network to update the components. The smart components connect to network using connect(). This ensures they’ll get state updates. 3. Prepare the action callbacks. To make it easier for dumb components to work with actions, the smart components can setup action callbacks by using bindActionCreators(). This way, they can just pass down a callback to the dumb component. The action will be automatically dispatched after it is formatted. The data flowNow that the application is set up, the user can start interacting with it. Let’s trigger an action to see the data flow. 1. The view requests an action. The action creator formats it and returns it. 2. The action is either dispatched automatically (if bindActionCreators() was used in setup), or the view dispatches the action. 3. The store receives the action. It sends the current state tree and the action to the root reducer. 4. The root reducer cuts apart the state tree into slices. Then it passes each slice to the subreducer that knows how to deal with it. 5. The subreducer copies the slice and makes changes to the copy. It returns the copy of the slice to the root reducer. 6. Once all of the subreducers have returned their slice copies, the root reducer pastes all of them together to form the whole updated state tree, which it returns to the store. The store replaces the old state tree with the new one. 7. The store tells the view layer binding that there’s new state. 8. The view layer binding asks the store to send over the new state. 9. The view layer binding triggers a rerender. So that’s how I think of Redux and its differences from Flux. Hope it helps! Coming up nextI’m making a list of topics. If you have any suggestions, or there are any parts of the React ecosystem that you find confusing and you’d like to see explained, let me know on Twitter. Resources Redux docs Dan Abramov’s React Europe talk The Evolution of Flux Frameworks Smart and Dumb Components The upsides of using Redux The downsides of using Redux JS Jabber: The Evolution of Flux Libraries with Andrew Clark and Dan Abramov","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"redux","slug":"redux","permalink":"http://nthung2112.github.io/tags/redux/"}]},{"title":"Redux thật là đơn giản (Phần 2)","slug":"Redux-that-la-don-gian-Phan-2","date":"2017-09-22T07:13:23.000Z","updated":"2017-10-01T08:24:53.492Z","comments":true,"path":"2017/09/Redux-that-la-don-gian-Phan-2.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Redux-that-la-don-gian-Phan-2.html","excerpt":"Redux với React Native Bài trước Nguyên Lý của Redux các bạn đã nắm được cơ bản phần lý thuyết về Redux và dùng cho việc gì, sau đây chúng ta sẽ đi vào áp dụng nó với React hoặc React Native, ở đây mình chọn React Native vì nó vẫn đang còn khá HOT :D (Thực ra React hay React Native thì đều dùng Redux là y hệt nhau)","text":"Redux với React Native Bài trước Nguyên Lý của Redux các bạn đã nắm được cơ bản phần lý thuyết về Redux và dùng cho việc gì, sau đây chúng ta sẽ đi vào áp dụng nó với React hoặc React Native, ở đây mình chọn React Native vì nó vẫn đang còn khá HOT :D (Thực ra React hay React Native thì đều dùng Redux là y hệt nhau)Đầu tiên các bạn vào link:https://facebook.github.io/react-native/docs/getting-started.html để làm theo và tạo 1 project với React Native. Lưu ý: Máy phải được cài sẵn yarn (https://yarnpkg.com/en/) hoặc dùng npm sau khi đã cài node, vì nếu cài yarn thì nó sẽ đồng thời cài node luôn cho bạn. Phần 1: Tạo giao diện màn hình với React NativeSau khi install xong, tạo thêm thư mục src -&gt; file Main.js như sau: Ở đây mình sẽ minh họa tạo chức năng hết sức đơn giản là Bấm — Tăng — Giảm 1 số dùng React Native + Redux có màn hình hiển thị lên như sau: Main.js Trong thư mục components ta tạo thêm 1 component có tên Button.js, thực tế bạn không cần phải viết hẳn 1 component chỉ render mỗi cái Button như này, do mình muốn tách nhỏ component nên tạm lấy ví dụ viết 1 component con riêng ra. (trong component này mình có dùng react-native-elements cài đặt nó qua yarn bằng lệnh sau:yarn add react-native-elements Component để hiển thị text number: Okay tới đây coi như xong giao diện, như vậy bạn đã có 1 app counter khá đơn giản :D và hoàn toàn có thể làm dùng React Native đơn giản hơn nhiều, nhưng để hiểu về Redux thì chúng ta nên bắt đầu từ việc đơn giản đã. Phần 2: Cài đặt ReduxStep1: install Redux, React-Redux dependencies yarn add redux react-redux Step 2: Tạo cấu trúc thư mục project như hình: 3 nhân tố của Redux là actions, reducers và store tương ứng với 3 thư mục trong project. actions: index.js chứa các action (nó sẽ export ra cho các class có thể gọi tới các function bên trong nó) types.js định nghĩa các hằng số về kiểu của actions: reducers: Tạo 1 reducer counterReducer: làm nhiệm vụ update state counter mỗi khi có action click Tiếp theo tạo file index.js, file này có nhiệm vụ combine các reducers con thành 1 reducer duy nhất để đưa vào store Store:tạo 1 file index.js trong thư mục store. (Mình có config thêm redux-devtools-extension để tiện debug và xem store khi redux hoạt động trên extention của chrome). Step 3: connect React component với store của Redux Việc cần làm là làm sao để kết nối toàn bộ components của app với store của Redux. Thư viện react-redux đã cung cấp 1 thằng có tên Provider để làm cầu nối cho React và Redux, chúng ta chỉ việc bọc nó bao ngoài root component của React và truyền 1 tham số duy nhất là store vào (store đã được tạo ở thư mục store và được import vào file này). Step 4: Gọi 1 action từ 1 component và map data từ store ra View Quay lại bài trước như đã biết thì flow của redux: action → reducer → store → View 3 bước đã thực hiện xong ở trên, việc còn lại là store và View tương tác như nào, câu hỏi đặt ra là : Phát đi 1 action từ component → store như thế nào? Cập nhật data thay đổi từ store → View ra sao? Nhiệm vụ quan trọng này được thực hiện bởi hàm connect() trong react-redux. Hàm connect() có 2 tham số: mapDispatchToProps(dispatch) nhiệm vụ map hàm dispatch() của store trở thành 1 thuộc tính của props của component đó, cụ thể ở code bên dưới thì actions chính là 1 props của component đó và giờ muốn phát đi 1 action ta chỉ việc gọi this.props.actions.tên_action_ mapStateToProps(state) nhiệm vụ hết sức đơn giản giống như cái tên của nó, biến các state từ store thành props của component và sau đó show ra View Để đơn giản và ngắn gọn hơn ta sẽ bỏ đi hàm mapDispatchToProps(dispatch) và thay bằng việc truyền trực tiếp actions vào hàm connect() cuối cùng sẽ là: connnect(mapStateToProps, actions)(COMPONENT) Quay trở lại code React Native ở trên, ở phần View ta có: main.js Giải thích: Actions được import từ thư mục actions → được truyền vào là tham số thứ 2 của hàm connect() Mỗi khi button đc bấm thì ta gọi tới hàm handle tương ứng để xử lý actions, nhớ rằng đã thực hiện connnect(null, actions) ở trên thì bây giờ các actions export ra từ file index trong thư mực actions trở thành các thuộc tính của props trong component Main.js → khi gọi tới action thì ta chỉ việc gọi this.props.action_name_tương_ứng_ Tiếp theo là hiển thị ra View ở component child.js Ở file này ta vừa gán thuộc tính counter : state.counter lúc này counter cũng trở thành 1 props của component Child → gọi show ra View ta chỉ cần gọi như thông thường {this.props.counter} Như vậy là 1 app counter đơn giản bằng React Native và Redux đã thực hiện xong tóm lại flow như sau: 1. View gồm 2 button Increase và Decrease và 1 component hiển thị number 2. Khi Button được click → dispatch() tới 1 action creator có têncounterIncrease() 3. counterIncrease() sẽ tạo ra 1 Object (Trong redux action phải là 1 plain object có thuộc tính là type và payload, type là bắt buộc) ở đây chỉ có 1 thuộc tính {type:”INCREASE”} sau đó nó truyền tới counterReducer() để xử lý. 4. counterReducer(state, action) =&gt; kiểm tra xem action có kiểu type = “increase” trả ra 1 state mới là: state + 1 (state của redux là immutable) 5 ở component View(Child) hiển thị number ta sẽ dùng hàm mapStateToProps(state) đẻ nhận state là counter rồi update vào View. → App đã chạy ngon lành :D Giả sử bây giờ yêu cầu bài toán có thay đổi chút như sau: Nếu click vào nút tăng hoặc giảm mà sau 1s con số mới thay đổi. Nâng cao hơn chút là nếu click vào button increase number thì number chạy từ 0 cho tới 1 con số bất kỳ trong khoảng 1s rồi dừng lại. Bình thường ở bài toán trên ta bấm nút thì ngay lập tức action đáp trả kết quả, nhưng trong thực tế có nhiều bài toán ko lập tức có thay đổi luôn điển hình như call api tới server để fetch data, thì phải mất 1 lúc kết quả mới được trả về. Hay như bài toán bấm nút thì sau 1s mới thay đổi → thì những điều này người ta gọi đó là side-effect . Như đã biết thì Redux yêu cầu 1 object được trả ra phải là Plain object: {type: ACTION_TYPE, payload:params} và reducer phải là pure function,hay nói cách khác là hoàn toàn ko có side-effect. Okay có lẽ bài thứ 2 về redux đến đây là dài rồi :)) Mình sẽ giải quyết vấn đề side-effect ở bài sau dùng Redux-middleware Hẹn gặp lại các bạn về bài cuối của Redux. Source code ví dụ trên: check out branch lesson_2 https://github.com/tridungbk2010/react-native-class","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"redux","slug":"redux","permalink":"http://nthung2112.github.io/tags/redux/"}]},{"title":"Redux thật là đơn giản! (Phần 1)","slug":"Redux-that-la-don-gian-Phan-1","date":"2017-09-22T07:02:19.000Z","updated":"2017-10-01T08:24:53.481Z","comments":true,"path":"2017/09/Redux-that-la-don-gian-Phan-1.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Redux-that-la-don-gian-Phan-1.html","excerpt":"Nguyên lý cơ bản của ReduxRedux nổi lên trong vòng 2 năm nay như 1 hiện tượng, nó thậm chí thay thế luôn kiến trúc Flux của Facebook dùng cho React, và hiện tại Facebook cũng khuyến cáo dev chuyển qua dùng Redux vì nhiều ưu điểm được cải tiến từ Flux. Mặc dù nó ko còn tính thời sự như hơn 1 năm trước nhưng mình vẫn quyết định viết series Redux để giúp các bạn mới học React và Redux tiếp cận dễ dàng hơn.","text":"Nguyên lý cơ bản của ReduxRedux nổi lên trong vòng 2 năm nay như 1 hiện tượng, nó thậm chí thay thế luôn kiến trúc Flux của Facebook dùng cho React, và hiện tại Facebook cũng khuyến cáo dev chuyển qua dùng Redux vì nhiều ưu điểm được cải tiến từ Flux. Mặc dù nó ko còn tính thời sự như hơn 1 năm trước nhưng mình vẫn quyết định viết series Redux để giúp các bạn mới học React và Redux tiếp cận dễ dàng hơn.Series gồm 3 phần: Phần 1: Nguyên lý cơ bản của Redux Phần 2: Cài đặt và sử dụng với React Native Phần 3: Redux-middleware (Thunk, Saga, Observable) nên dùng cái nào? Mời các bạn đón đọc! Lịch sử Redux (Câu chuyện vui) Năm Quý Tị (2013), Facebook gia tộc bố cáo thiên hạ rằng Ăn Gô La đại pháp (Angular) của Google gia tộc chậm chạp, nặng nề, cho xuất thế một bộ chiêu thức gọi là Rối An Tâm Pháp (React). Thế nhưng Rối An Tâm Pháp lại chỉ là một bộ tâm pháp cường thân kiện thể, không thể dùng để rèn luyện nội công (chỉ là một library để render view). Do đó, không lâu sau Facebook gia tộc tiếp tục cho ra đời một bộ tâm pháp cơ bản (kiến trúc thiết kế) và một công pháp cùng tên là Phờ Lắc thần công (Flux). Nghe đồn Rối An Tâm Pháp và Phờ Lắc Thần Công kết hợp lại sẽ thành tuyệt học dời non lấp bể, không gì không làm đc. Nhân sĩ giang hồ (coder) vốn nhẹ dạ cả tin lại rủ nhau tu luyện. Phờ Lắc thần công rối rắm khó học, nhân sĩ 10 phần học thì 4–5 phần tẩu hỏa nhập ma, phần còn lại cũng trầy da tróc vẩy mà công lực cũng chẳng được như lời Facebook gia tộc quảng cáo. Bấy giờ có một nhân sĩ giang hồ tự là Đan (Dan Abramov), đang tu luyện đồng thời Phờ lắc thần công và Ê La thần công (Elm) mới nhận ra rằng hai môn võ công có nhiều điểm chung, chỉ khác chiêu thức, Đan bèn nảy ra ý định hợp nhất hai môn này lại. Không lâu sau (5/2015), Đan cho xuất thế một bộ công pháp mang tên Rì Đắt thần công (Redux), mang ưu điểm của cả hai môn võ công đồng thời loại bỏ những phức tạp dư thừa của Phờ Lắc thần công. Nhân sĩ giang hồ nghe vậy mừng lắm, thế là lại kéo nhau đi học Rì Đắt, còn Đan thì được Facebookgia tộc mời về làm tộc nhân. Trích “JavaScript Lược Sử Giang Hồ” Đọc qua đoạn đậm màu sắc kiếm hiệp ở trên chắc các bạn phần nào cũng hình dung được Redux sinh ra để làm gì đúng ko? 1. Redux sinh ra để làm gì?Do yêu cầu cho các ứng dụng single-page sử dụng Javascript ngày càng trở lên phức tạp thì code của chúng ta phải quản lý nhiều state hơn. State có thể bao gồm là data trả về từ phía Server và được cached lại hay như dữ liệu được tạo ra và thao tác ở phía client mà chưa được đẩy lên phía server. UI state cũng trở lên phức tạp vì chúng ta cần quản lý việc active Routes, selected tabs, spinners, điều khiển phân trang …vv. Việc quản lý từng thay đổi của state là rất khó: Vì nếu như khi ta thay đổi 1 Model -&gt; Model khác cũng thay đổi theo và nếu 1 View thay đổi -&gt; Model thay đổi -&gt; Model khác nữa cũng thay đổi theo. Về phía Front-end development, thì được kỳ vọng xử lý các vấn đề như “optimistic updates” (Hiểu như thể một thay đổi trên giao diện được thực hiện thành công trước khi được xác nhận từ phía server), render phía server, featching data trước khi thực hiện chuyển trang …vv. Nếu như ko có một luồng xử lý khoa học và rõ ràng thì việc quản lý dữ liệu với các dự án lớn là vô cùng phức tạp. Vấn đề phức tạp như đề cập ở trên sẽ còn càng khó xử lý hơn nữa vì chúng ta đang trộn lẫn 2 khái niệm mà nó ko tự nhiên với tư duy thông thường của con người đó là: Biến đổi dữ liệu (Mutation) và tính bất đồng bộ (Asynchronicity), mặc dù chúng sẽ là tuyệt vời nếu dùng tách rời nhau, nhưng hoạt động cùng nhau sẽ gây ra sự hỗn độn. React JS đã cố gắng giải quyết điều này ở trong tầng View bằng việc loại bỏ Bất đồng bộ và Không thao tác trực tiếp trên DOM, tuy nhiên việc quản lý state là tùy thuộc vào cách của bạn do vậy đây chính là lí do Redux xuất hiện để giúp bạn quản lý state một cách khoa học và hiệu quả hơn. 2. Tại sao người ta hay dùng React với Redux?Redux ra đời lấy cảm hứng từ tư tưởng của ngôn ngữ Elm và kiến trúc Flux của Facebook . Do vậy Redux thường dùng kết hợp với React. Tuy nhiên hoàn toàn có thể sử dụng với các framework khác như Angular, Angular2, Backbone, Falcor, Deku, Swift. Vậy bạn có cần biết Flux trước khi đến với Redux ko? câu trả lời là KHÔNG vì thật sự nếu bạn đã dùng flux thì cũng tốt, còn không thì bạn lại dễ tiếp cận hơn (tránh lối mòn :D). 3. Quản lý state bằng Redux như thế nào?Giả xử chúng ta có 1 ứng dụng mà các node như trong hình là tượng trưng cho một single page application được mô hình tree-node. Hình dung app của chúng ta vận hành bằng việc chuyển đổi qua lại data gữa các node, mỗi node (trang con) chứa một state và các node con nhận data được truyền từ node cha vào node con. Giả sử nếu có 1 action ở node d3 được kích hoạt và ta muốn thay đổi state d4 và c3 thì luồng dữ liệu sẽ được truyền từ node d3 trở về node gốc là a, xong sau đó từ node a lại phát đi data đến các node con: Cập nhật state cho node d4: d3-c2-b1-a-b2-c4-d4 Cập nhật state cho node c3: d3-c2-b1-a-b2-c3 Với những bài toán nhỏ (chỉ cần dùng React JS ko cần Redux) thì update state qua lại giữa các page có thể dễ dàng nhưng bạn thử hình dung ứng dụng lớn hơn có rất nhiều nhánh và node con thì việc thao tác update state qua lại giữa các page trở nên phức tạp hơn khiến cho flow của code cũng khó đọc và khó debug hơn. Và giải pháp Redux đưa ra là như sau: Quay lại bài toán ở trên thì ta chỉ cần map Action từ node d3 về store của redux rồi ở node c3 và d4 chỉ cần connect với store và cập nhật data thay đổi -&gt; hết sức đơn giản phải ko? 4. Nguyên tắc hoạt động của ReduxVừa xong phần lý thuyết để phần nào các bạn mường tượng ra triết lý của Redux tiếp theo sau đây mình sẽ đi sâu vào giải thích cụ thể hơn các thành phần của Redux a. Khái niệm cốt lõi: Hãy tưởng tượng state của app của bạn được mô tả như 1 object thuần dưới đây: 12345678910&#123; todos: [&#123; text: 'Eat food', completed: true &#125;, &#123; text: 'Exercise', completed: false &#125;], visibilityFilter: 'SHOW_COMPLETED'&#125; Thật sự thì nó trông giống như 1 model ko có phương thức setters ( nghĩa là chỉ có thể lấy ra data mà ko cho phép thay đổi data đó), điều này để tránh các thay đổi tùy tiện trong khi code gây ra việc khó debug. Để thay đổi state, chỉ có 1 cách duy nhất là dispatch 1 action (Mình sẽ nói ở phần sau). b. 3 nguyên tắc của Redux Single source of truth: State của toàn bộ ứng dụng được lưu trong trong 1 store duy nhất là 1 Object mô hình tree. - State is read-only: Chỉ có 1 cách duy nhất để thay đổi state đó là tạo ra một action (là 1 object mô tả những gì xảy ra) Changes are made with pure functions: Để chỉ rõ state tree được thay đổi bởi 1 action bạn phải viết pure reducers c. Nguyên lý vận hành ActionsTrong Redux action là 1 pure object định nghĩa 2 thuộc tính là : type: kiểu mô tả action, và payload: giá trị tham số truyền lên 1234&#123; type: \"KIEU_ACTION\", payload: //tham số&#125; ReducersAction có nhiệm vụ mô tả những gì xảy ra nhưng lại không chỉ rõ phần state nào của response thay đổi -&gt; Việc này sẽ là của Reducer đảm nhiệm: Reducer nhận 2 tham số vào: 1 state cũ và action được gửi lên sau đó trả ra một state mới, ko làm thay đổi state cũ. 1(previousState, action) =&gt; newState StoreStore là 1 object lưu trữ state của toàn bộ ứng dụng có 3 phương thức sau: getState(): Giúp lấy ra state hiện tại dispatch(action): Thực hiện gọi 1 action subscrible(listener):Nó có vai trò cực quan trọng, luôn luôn lắng nghe xem có thay đổi gì ko rồi ngay lập tức cập nhật ra View Để cho dễ hiểu hơn mình sẽ minh họa bằng ví dụ sau: Ta có 1 reducer, khở tạo store thông qua hàm createStore(reducer), trong Redux. Phân tích vị dụ trên ta có: Step 1: Khởi tạo store cho project mà nó nhận tham số đầu vào là reducer counter ở trên: 1const store = createStore(counter); Step 2: Sau đó giả sử ta muốn tăng giá trị lên 1 thì call action với type là “INCREMENT” dùng hàm dispatch() của store: 123document.addEventListener('click', () =&gt; &#123; store.dispatch(&#123;type:\"INCREMENT\"&#125;);&#125;); Step 3: lúc này là nhệm vụ của reducer, sẽ xem kiểu action gọi lên là gì “INCREMENT” hay “DECREMENT” để nó return ra 1 new state cụ thể ở đây là state + 1. Step 4: thằngsubcrible() trong store sẽ làm nhiệm vụ cập nhật tình hình thay đổi ra View: 123store.subcrible(() =&gt; &#123; document.body.innerText = store.getState(); &#125;); Đến đây thì cơ bản bạn đã nắm được nguyên lý hoạt động cơ bản nhất của Redux mà tôi tạm rút gọn lại flow là: action -&gt; reducer -&gt; store -&gt; View 5. Tóm lạiỞ phạm vi bài này mình đã trình bày nguyên lý cơ bản và cách thức hoạt động của Redux để các bạn có thể nắm được cũng như hình dung nó sinh ra để làm việc gì, bài viết mới thể hiện được các tình huống đơn giản nhất thông qua ví dụ đơn giản, còn trong khi làm dự án thực tế công việc chủ yếu là tương tác với server (fetch data) và xử lý data sau đó, thì đó là về bất đồng bộ asynchronous và xử lý side-effect sau mỗi action được gọi. Việc này sẽ được Redux xử lý với Redux-middleware Hẹn gặp lại các bạn ở phần 2 về Redux: “Redux-middleware” 6. Nguồn tham khảo: http://redux.js.org/ https://toidicodedao.com/2016/08/18/js-truyen-ki-chuong-2-vo-lam-day-song/ https://egghead.io/lessons/javascript-redux-store-methods-getstate-dispatch-and-subscribe","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"redux","slug":"redux","permalink":"http://nthung2112.github.io/tags/redux/"}]},{"title":"Những khái niệm Javascript bạn cần biết khi phỏng vấn","slug":"Nhung-khai-niem-Javascript-ban-can-biet-khi-phong-van","date":"2017-09-09T02:11:28.000Z","updated":"2018-05-18T01:01:57.921Z","comments":true,"path":"2017/09/Nhung-khai-niem-Javascript-ban-can-biet-khi-phong-van.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Nhung-khai-niem-Javascript-ban-can-biet-khi-phong-van.html","excerpt":"Tự họcCó hàng ngàn người đang học JavaScript và web development với hy vọng có được một công việc. Thường xuyên tự học những kiến thức hổng trong sự hiểu biết của con người về ngôn ngữ JavaScript. Thật ngạc nhiên là cần ít ngôn ngữ để tạo ra các trang web phức tạp. Những người làm toàn bộ các trang web thường không nắm được các nguyên tắc cơ bản của Javascript. Khá dễ dàng để tránh các chủ đề phức tạp và thực hiện các tính năng sử dụng các kỹ năng cơ bản. Cũng khá dễ để tạo ra một trang web bằng cách dựa vào Stack Overflow mà không hiểu code đang được copied.","text":"Tự họcCó hàng ngàn người đang học JavaScript và web development với hy vọng có được một công việc. Thường xuyên tự học những kiến thức hổng trong sự hiểu biết của con người về ngôn ngữ JavaScript. Thật ngạc nhiên là cần ít ngôn ngữ để tạo ra các trang web phức tạp. Những người làm toàn bộ các trang web thường không nắm được các nguyên tắc cơ bản của Javascript. Khá dễ dàng để tránh các chủ đề phức tạp và thực hiện các tính năng sử dụng các kỹ năng cơ bản. Cũng khá dễ để tạo ra một trang web bằng cách dựa vào Stack Overflow mà không hiểu code đang được copied. Nếu bạn đang tìm kiếm để làm chủ phỏng vấn JavaScript, hãy vào đây Step Up Your JS: A Comprehensive Guide to Intermediate JavaScript Phỏng vấnVấn đề là các câu hỏi kiểm tra sự hiểu biết của bạn về JS là chính xác là những công ty công nghệ yêu cầu trong các cuộc phỏng vấn của họ. Nó trở nên rất nhanh khi người ứng tuyển biết đủ để vượt qua, nhưng không có sự hiểu biết chắc chắn về ngôn ngữ này. Đây là những khái niệm được hỏi thường xuyên trong cách cuộc phỏng vấn về phát triển web. Điều này giả định bạn đã biết những điều cơ bản như loops, functions, và callbacks. Khái niệm Value vs. Reference — Understand how objects, arrays, and functions are copied and passed into functions. Know that the reference is what’s being copied. Understand that primitives are copied and passed by copying the value. Scope — Understand the difference between global scope, function scope, and block scope. Understand which variables are available where. Know how the JavaScript engine performs variable lookup. Hoisting — Understand that variable and function declarations are hoisted to the top of their available scope. Understand that function expressions are not hoisted. Closures — Know that a function retains access to the scope that it was created in. Know what this lets us do, such as data hiding, memoization, and dynamic function generation. this — Know the rules of this binding. Know how it works, know how to figure out what it will be equal to in a function, and know why it’s useful. new — Know how it relates to object oriented programming. Know what happens to a function called with new. Understand how the object generated by using new inherits from the function’s prototype property. apply, call, bind — Know how each of these functions work. Know how to use them. Know what they do to this. Prototypes &amp; Inheritance — Understand that inheritance in JavaScript works through the [[Prototype]] chain. Understand how to set up inheritance through functions and objects and how new helps us implement it. Know what the __proto__ and prototype properties are and what they do. Asynchronous JS — Understand the event loop. Understand how the browser deals with user input, web requests, and events in general. Know how to recognize and correctly implement asynchronous code. Understand how JavaScript is both asynchronous and single-threaded. Higher Order Functions — Understand that functions are first-class objects in JavaScript and what that means. Know that returning a function from another function is perfectly legal. Understand the techniques that closures and higher order functions allow us to use. Tài nguyên khácNếu các link trên chưa đủ, có vô số tài nguyên trên mạng để giúp bạn tìm hiểu những khái niệm này. Cá nhân tôi đã tạo Step Up Your JS: A Comprehensive Guide to Intermediate JavaScript để giúp các dev nâng cao kiến thức của họ. Nó bao gồm các khái niệm này và nhiều hơn nữa. Đây là những resources Tôi đã đọc hoặc xem ít nhất và có thể gợi ý cho bạn: Step Up Your JS You Don’t Know JS JavaScript is Sexy javascript.com Frontend Masters Eloquent JavaScript Chúc may mắn trong cuộc phỏng vấn của bạn.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"interview","slug":"interview","permalink":"http://nthung2112.github.io/tags/interview/"}]},{"title":"Truy cập và thay đổi các biến CSS với Javascript","slug":"Truy-cap-va-thay-doi-cac-bien-CSS-voi-Javascript","date":"2017-09-08T13:46:11.000Z","updated":"2017-09-09T01:20:21.873Z","comments":true,"path":"2017/09/Truy-cap-va-thay-doi-cac-bien-CSS-voi-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Truy-cap-va-thay-doi-cac-bien-CSS-voi-Javascript.html","excerpt":"Tại sao nó tốt hơn sử dụng biến SASSBiến trong SASS đã được sử dụng trong một thời gian. Chúng cho phép bạn định nghĩa một biến một lần lúc runtime và sử dụng biến đó ở nhiều nơi.↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓","text":"Tại sao nó tốt hơn sử dụng biến SASSBiến trong SASS đã được sử dụng trong một thời gian. Chúng cho phép bạn định nghĩa một biến một lần lúc runtime và sử dụng biến đó ở nhiều nơi.↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ Tương tác với các biến CSS với JS post-runtime.Trong bản demo này chúng ta sẽ xây dựng một form đơn giản và sẽ sử dụng JS để tự động cập nhật các biến CSS (trong trường hợp này là thay đổi color và margin của một dấu chấm) jsfiddle result JSFiddle Demo Chúng ta hãy nhìn vào những phần dưới đây: CSScss with root vars Đây là một vài thông tin về CSS :root, ở đây cũng vậy. Từ MDN: The :root CSS pseudo-class matches the root element of a tree representing the document. In HTML, :root represents the html element and is identical to the selector html, except that its specificity is higher. Các biến CSS được định nghĩa trong :root và được sử dụng ở dòng 13–14. -- là định nghĩa chuẩn của CSS cho các biến. HTMLform markup Dễ dàng ở đây, lưu ý các thuộc tính input trên type=&quot;range&quot;. Chúng giữ giá trị min và max cũng như giá trị khởi tạo value. Tương tự cho loại input type=&quot;color&quot;. Giá trị màu khởi tạo là #2cba92. JAVASCRIPTjs accessing css vars Thông tin từng dòng: 4 — lấy phần tử footer 5 — lấy tất cả input trên trang NodeList 7 — input CHANGE EventListener 8 — input MOUSEMOVE EventListener(updates dynamic margin on slide) 10 — hàm đặt lại giá trị mong muốn CSS var(chú ý chúng ta thêm px vào biến cho margin ở dòng line 14) Và đó tất cả cho Truy cập và thay đổi các biến CSS với Javascript.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"}]},{"title":"Cheatsheet cơ bản về Flexbox","slug":"Cheatsheet-co-ban-ve-Flexbox","date":"2017-09-06T00:05:26.000Z","updated":"2017-09-06T00:55:37.240Z","comments":true,"path":"2017/09/Cheatsheet-co-ban-ve-Flexbox.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Cheatsheet-co-ban-ve-Flexbox.html","excerpt":"Tổng quan về cách sử dụng flexible box layoutI spent the last days wrapping my head around flexbox, and how to use it correctly. Maybe you can relate to when I say, that it is not that easy to understand how it exactly works, or why some CSS rules don’t behave as expected under certain circumstances. In this article, I just want to give a summary of what I think is important to know. So please keep in mind that this will not be an exhaustive description of all possible CSS rules and scenarios.","text":"Tổng quan về cách sử dụng flexible box layoutI spent the last days wrapping my head around flexbox, and how to use it correctly. Maybe you can relate to when I say, that it is not that easy to understand how it exactly works, or why some CSS rules don’t behave as expected under certain circumstances. In this article, I just want to give a summary of what I think is important to know. So please keep in mind that this will not be an exhaustive description of all possible CSS rules and scenarios. What’s flexbox? Flexbox is a layout mode which is designed for laying out more complex applications and webpages. — w3.org When using the flexbox layout model we distinguish between the two main elements: flex container and flex items. The flex container is the parent element of your flex items. You set display: flex or display: inline-flex on this element to activate the flex layout mode. Before outlining the details of a flex container or flex items, I want to talk about the terminology of the flex box layout model, which I found somehow confusing in the beginning. Here’s what I found about that in the flexbox specification: An illustration of the various directions, sizing and positioning terms as applied to a ‘row’ flex container. First of all, in flexbox layout there is no horizontal or vertical. Instead, we orientate ourselves by a main axis and a cross axis. Flex items are always laid out along the main-axis. In the image above, you can see, that the main-axis for a row flex container goes from the left end of the flex container (main start) to the right end (main end). Basically, a column flex container is just a row flex container tilted by 90 degrees to the right. An illustration of the various directions, sizing and positioning terms as applied to a ‘column’ flex container. For a column flex container things would look a bit different. As you can see in the image on the left, as soon as you use flex-direction: column, the main-axis points towards the bottom of the screen, while the cross-axis goes from the right end to the left end of the flex container. So basically the whole picture is just tilted to the right, by 90 degrees. This helped me a lot to orientate myself within a column flex container, since the CSS properties change their effective direction between row and column flex containers. Now that’s all we need for now. In the following sections I’m going to describe the different CSS rules which are applicable for flex container and flex items. The Flex Container CSS RulesLet’s start with the CSS rules which are used on the flex container. I included some screenshots and put the respective CSS setting into the caption of the images. flex-directionThis rule determines if the flex-items are aligned in a row or in a column. Additionally, there is an option to align them in reverse order, heading from main-end to main-start. flex-direction: row; (default) flex-direction: column; flex-wrapIf you add more flex-items to a line, you will get to the point where there is not enough space for more. Since the flex-items shrink by default (see: flex-shrink the flex-items section) the items will get smaller the more items you add. By using flex-wrap you can control this behaviour if the items should stay in the same line (this is the default behaviour; flex-wrap: nowrap;) or wrap to the next line ( flex-wrap: wrap; or flex-wrap: wrap-reverse;) flex-wrap: nowrap; as as applied to a ‘row’ flex-containerflex-wrap: wrap; flex-flowThis is the first shorthand I will show you today. You can combine the CSS rules flex-direction and flex-wrap within one single CSS rule. The following list should speak for itself: flex-flow: row wrap; flex-flow: row wrap-reverse; flex-flow: column wrap; flex-flow: column wrap-reverse; justify-contentTo position the flex-items alongside the main axis, you can use justify-content: justify-content: flex-start; (default behaviour)justify-content: flex-end;justify-content: center;justify-content: space-between;justify-content; space-around; align-itemsNow that you learned about justify-content to lay out items along the main axis, this is an easier one. align-items is used to align items along the cross-axis on the current line. align-items: flex-start; (default behaviour)align-items: flex-end;align-items: center;align-items: stretch;align-items: baseline; As you see, align-items also allows to stretch items to use the available space in the current line, as well as align-items: baseline;aligns items along the bottom line of their first line of text. But what do you do if you don’t want to align the items within one line, but rather align the whole bunch of items within the available space of the flex-container? That’s what align-content is used for. align-contentLet’s have a look how we can align the whole bunch of flex-items within our flex container: align-content: flex-start; (default behaviour)align-content: flex-end;align-content: center;align-conent; stretch; That was a rather short overview of what you are capable to do with flex-container CSS rules. In the next section I’m going to show you how you can adjust the behaviour of flex-items. The Flex Item CSS RulesIn the last section you learned how to align all flex items at once — either within their line or within the available space of their flex container. Now it’s time to have a look at flex-grow ,flex-shrink ,flex-basis and the flex shorthand for those three rules. flex-growDefines if items cang row to use the available space along the main-axis. The default value is 0, which means that flex-items don’t grow automatically. In the following pictures you can see which effect flex-grow has on flex items in a ‘row’ and in a ‘column’ container. flex-grow: 0; (default behaviour) in a ‘row’ containerflex-grow: 1; in a ‘row’ containerflex-grow: 0; (default behaviour) in a ‘column’ containerflex-grow: 1; in a ‘column’ container With flex-grow it is also possible to let certain items grow more than others. Example: We have three items. Two of them have flex-grow set to 1, while one of them got flex-grow set to 2. What happened here? First of all, all flex-grow values of a line are added, which results in a total of 4 which represents 100% of our available space.Then each item is sized according to the relational size of its flex-grow setting to the sum of all flex-grow settings of said line. According to that calculation, the first two items get 25% of the available space and the third one gets 50%. Please note that I did not consider the padding and margin which is set in the image. flex-shrinkBy default, the shrink rule is set to 1. This means that as soon as the window is resized, the flex items will shrink if necessary. Possible values are 0 and 1. Example: The flex item of the following picture has a width of 500px. With flex-shrink set to it’s default value 1, resizing the window means that the item will shrink to less than 500px width. When setting flex-shrink to 0, the item will not shrink and would exceed the window size and a scrollbar appears. The item has a width of 500px. (Sidenote: flex-grow is switched off)flex-shrink is turned on — resizing the window also resizes the item.flex-shrink turned off. The item exceeds the window (scrollbars omitted in this picture) flex-basisThe flex basis defines the initial main-size of a flex item. This setting will be evaluated before the available space is distributed to flex-grow, or the items are resized by flex-shrink. The initial main size of the flex item before free space is distributed to the flex factors. — w3.org flex-basis accepts either a length in px || em || rem or percentages, as well as auto. If flex-basis is set to auto, the width will be calculated based on content size. So the more you increase the content of a flex item, the bigger it gets. As soon as you set a fixed size to flex-basis, the content of the item will adjust to fit into the item. flex-basis: auto;flex-basis: auto; with more contentflex-basis: 100px; The flex shorthandBecause it is way more comfortable to set the above rules all at once, there is a shorthand to do so: The default setting for this is flex: 0 1 auto; With the shorthand you define flex-grow with the first, flex-shrink with the second, and flex-basis with the third argument. It is also possible to omit the last parameter: flex: 0 1 which defaults flex-basis to zero_._ The following pictures show some examples how you can arrange flex-items using the flex shorthand. flex: 0 1 auto (default behaviour) The item size is defined by its content. flex: 0 1 auto; (default behaviour) flex: 1 1 auto flex: 1 1 auto; flex: 0 0 autoThis is the same as the example in the above section “flex-shrink”. Shrinking is turned off, which leads to the item overflowing the window size. flex: 0 0 auto; Relative size of flex-items To use the same “relative” sizing technique I described in the section “flex-grow”, you have to set flex-basis to zero. In the next picture, the first item has flex: 2 1 0; while the second item has flex: 1 1 0; The first item got 2/3 of the available size while the second one got 1/3 ConclusionWell that article grew a bit bigger than it was planned, but in the end, I hope you enjoyed the read. Maybe this article can serve as a handy guide to look up the different CSS rules if you want to brush up your knowledge, as this is something one might not memorize completely. As I said in the beginning, this was never meant to be an exhaustive list of szenarios and rules which can apply, if you are interested in this in detail, I would suggest to read the articles I mentioned in the beginning of the article, as well as parts of the specification (if you don’t want to read the whole thing) Understanding Flexbox: Everything you need to know (Ohans Emmanuel) 11 things I learned reading the flexbox spec (David Gilbertson) CSS Flexible Box Layout Module Level 1 At first, I planned to also create this as a handy cheatsheet, but then I found a really good one by Chris Coyier which I want to share with you: A Complete Guide to Flexbox Thanks for reading this article!","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"flexbox","slug":"flexbox","permalink":"http://nthung2112.github.io/tags/flexbox/"}]},{"title":"Một số SASS Mixins nên sử dụng","slug":"Mot-so-SASS-Mixins-nen-su-dung","date":"2017-09-01T02:53:15.000Z","updated":"2017-09-05T01:12:39.032Z","comments":true,"path":"2017/09/Mot-so-SASS-Mixins-nen-su-dung.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Mot-so-SASS-Mixins-nen-su-dung.html","excerpt":"Danh sách một số SASS mixins mà các Web designers nên có để công việc của họ nhanh hơn. Tôi đã sử dụng SASS không quá lâu, nhưng kể từ khi tôi bắt đầu với nó, Tôi đã sử dụng một số mixins để auto một số thứ trong dự án của tôi. Mixins giống như các hàm tự động tạo ra code CSS và giúp bạn tiết kiệm viết code giống nhau lặp đi lặp lại. Có một số lượng tốt thư viện SASS mixin sẵn có trên web (eg. bourbon) một hoặc một số trong số đó bạn có thể đã sử dụng. Hoặc như tôi, bạn có thể đã tạo ra một bộ tùy chỉnh bằng cách thu thập các mixins siêu hữu ích từ web.","text":"Danh sách một số SASS mixins mà các Web designers nên có để công việc của họ nhanh hơn. Tôi đã sử dụng SASS không quá lâu, nhưng kể từ khi tôi bắt đầu với nó, Tôi đã sử dụng một số mixins để auto một số thứ trong dự án của tôi. Mixins giống như các hàm tự động tạo ra code CSS và giúp bạn tiết kiệm viết code giống nhau lặp đi lặp lại. Có một số lượng tốt thư viện SASS mixin sẵn có trên web (eg. bourbon) một hoặc một số trong số đó bạn có thể đã sử dụng. Hoặc như tôi, bạn có thể đã tạo ra một bộ tùy chỉnh bằng cách thu thập các mixins siêu hữu ích từ web.Tạo thư viện tùy chỉnh luôn luôn phục vụ tốt và gọn gàng. Bằng cách này bạn tránh thêm code không cần thiết và chỉ thêm những gì bạn thực sự cần. Dưới đây là danh sách một số SASS mixins tiện dụng Tôi đã sử dụng hằng ngày với các dự án của tôi. Một số trong số chúng được thu thập từ web, một số đơn giản là đủ để viết cho mình. Kiểm tra các đoạn mixins dưới đây, cách sử dụng ví dụ, và output của chúng: 1. Thêm kích thướcMột mixin đơn giản để cho kích thước vào một box. 1234@mixin box($width, $height=$width) &#123; width: $width; height: $height;&#125; UsageBạn phải cung cấp ít nhất một tham số để làm cho nó hoạt động: 1234567.square &#123; @include box(50px);&#125;.rectangle &#123; @include box(100px, 50px);&#125; Output123456789.square &#123; width: 50px; height: 50px;&#125;.rectangle &#123; width: 100px; height: 50px;&#125; 2. ClearfixImplementing micro-clearfix hack the SASS way. 1234567@mixin clearfix &#123; &amp;:after &#123; content: \"\"; display: table; clear: both; &#125;&#125; Usage123.cf &#123; @include clearfix;&#125; Output12345.cf:after &#123; content: \"\"; display: table; clear: both;&#125; 3. OpacityCSS Opacity with fallback for IE8+. 12345@mixin opacity($opacity) &#123; opacity: $opacity; $opacity-ie: $opacity * 100; filter: alpha(opacity = $opacity-ie); //IE8&#125; Output123.fade &#123; @include opacity(.4);&#125; Output1234.fade &#123; opacity: .4; filter: alpha(opacity = 40); //IE8&#125; 4. PositioningEasy and quick CSS positioning, thanks to Hugo Giraudel. 12345678910111213141516171819202122@mixin position($position, $args) &#123; @each $o in top right bottom left &#123; $i: index($args, $o); @if $i and $i + 1 &lt;= length($args) and type-of(nth($args, $i + 1)) == number &#123; #&#123;$o&#125;: nth($args, $i + 1); &#125; &#125; position: $position;&#125;// Positioning helpers@mixin absolute($args: '') &#123; @include position(absolute, $args);&#125;@mixin fixed($args: '') &#123; @include position(fixed, $args);&#125;@mixin relative($args: '') &#123; @include position(relative, $args);&#125; UsageYou should only use absolute(), relative(), and fixed() functions to add the respective positioning to the elements. Parameters are optional and can be given as demonstrated below: 1234567891011.menu li &#123; @include relative;&#125;.sub-menu &#123; @include absolute(top 100% left 0);&#125;.sticky-bar &#123; @include fixed(top 0 left 0);&#125; 5. Rem unitsImplementing CSS rem units with pixel fallback. 1234@mixin font-size($size, $base: 16) &#123; font-size: $size; // fallback for old browsers font-size: ($size / $base) * 1rem;&#125; Usage1234567body &#123; @include font-size(16);&#125;p &#123; @include font-size(12, 10);&#125; Bạn phải cung cấp ít nhất một giá trị khi sử dụng mixin, giá trị này sẽ được coi là font-size và sẽ được xuất ra sau khi được tính toán với font-size mặc định (16). Hoặc bạn có thể cung cấp một giá trị cơ sở khác nếu bạn muốn. Output1234body &#123; font-size: 16px; font-size: 1rem;&#125; 6. Vendor prefixingVendor prefixing made easy with full control over prefixes, customize as you use: 12345678910@mixin prefix($property, $value, $vendors: webkit moz ms o, $default: true) &#123; @if $vendors &#123; @each $vendor in $vendors &#123; #&#123;\"-\" + $vendor + \"-\" + $property&#125;: #&#123;$value&#125;; &#125; &#125; @if $default &#123; #&#123;$property&#125;: #&#123;$value&#125;; &#125;&#125; Usage123456789html &#123; @include prefix('box-sizing', 'border-box', moz webkit);&#125;*,*:before,*:after &#123; @include prefix('box-sizing', 'inherit', moz webkit);&#125; As shown above, you may provide the vendor prefixes as the 3rd parameter in the mixin, each separated by a space. Output12345678910111213html &#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;&#125;*,*:before,*:after &#123; -moz-box-sizing: inherit; -webkit-box-sizing: inherit; box-sizing: inherit;&#125; 7. Media queriesHandling CSS Media queries was never this easy: 12345678910111213141516171819202122232425@mixin screen($size) &#123; $desktop: \"(min-width: 1024px)\"; $tablet: \"(min-width: 768px) and (max-width: 1023px)\"; $mobile: \"(max-width: 767px)\"; @if $size == desktop &#123; @media only screen and #&#123;$desktop&#125; &#123; @content; &#125; &#125; @else if $size == tablet &#123; @media only screen and #&#123;$tablet&#125; &#123; @content; &#125; &#125; @else if $size == mobile &#123; @media only screen and #&#123;$mobile&#125; &#123; @content; &#125; &#125; @else &#123; @media only screen and #&#123;$size&#125; &#123; @content; &#125; &#125;&#125; Usage1234567891011.wrapper &#123; margin: 0 auto; width: 100%; @include screen('tablet') &#123; width: 90%; &#125; @include screen('desktop') &#123; width: 85%; &#125;&#125; Output1234567891011121314.wrapper &#123; margin: 0 auto; width: 100%;&#125;@media only screen and (min-width: 768px) and (max-width: 1023px) &#123; .wrapper &#123; width: 90%; &#125;&#125;@media only screen and (min-width: 1024px) &#123; .wrapper &#123; width: 85%; &#125;&#125; In place of ‘mobile’, ‘tablet’, or ‘desktop’, you may also provide a custom breakpoint values, for eg: 12345.wrapper &#123; @include screen('(min-width: 1367px)') &#123; width: 1280px; &#125;&#125; 8. Retina ImagesShow the retina images on retina-friendly devices only: 1234567891011@mixin retina($image, $width, $height) &#123; @media (min--moz-device-pixel-ratio: 1.3), (-o-min-device-pixel-ratio: 2.6/2), (-webkit-min-device-pixel-ratio: 1.3), (min-device-pixel-ratio: 1.3), (min-resolution: 1.3dppx) &#123; /* Serving 2x image on Retina display */ background-image: url($image); background-size: $width $height; &#125;&#125; Usage1234.logo &#123;background-image: url(\"img/logo.png\"); @include retina(\"img/logo@2x.png\", 100px, 21px);&#125; Output12345678910.logo &#123; background-image: url(\"img/logo.png\");&#125;@media (min--moz-device-pixel-ratio: 1.3), (-o-min-device-pixel-ratio: 2.6 / 2), (-webkit-min-device-pixel-ratio: 1.3), (min-device-pixel-ratio: 1.3), (min-resolution: 1.3dppx) &#123; .logo &#123; /* Serving HQ image on Retina display */ background-image: url(\"img/logo@2x.png\"); background-size: 100px 21px; &#125;&#125; The above example usage may not be perfect and you may add more rules for specifying width and height of the element to be optimized for retina screen. 9. CSS3 KeyframesCSS3 keyframes can’t be implemented with the vendor prefixing mixin mentioned above. The below mixin is meant to render keyframes correctly with the vendor prefixes: 12345678910111213@mixin keyframes($name) &#123; @-webkit-keyframes #&#123;$name&#125; &#123; @content; &#125; @-moz-keyframes #&#123;$name&#125; &#123; @content; &#125; @keyframes #&#123;$name&#125; &#123; @content; &#125;&#125; Usage12345678@include keyframes(animate) &#123; 50% &#123; transform: rotate(90deg); &#125; 100% &#123; transform: rotate(-90deg); &#125;&#125; Output123456789101112131415161718192021222324@-webkit-keyframes animate &#123; 50% &#123; transform: rotate(90deg); &#125; 100% &#123; transform: rotate(-90deg); &#125;&#125;@-moz-keyframes animate &#123; 50% &#123; transform: rotate(90deg); &#125; 100% &#123; transform: rotate(-90deg); &#125;&#125;@keyframes animate &#123; 50% &#123; transform: rotate(90deg); &#125; 100% &#123; transform: rotate(-90deg); &#125;&#125; 10. Background GradientQuick and simple SASS mixin to implement CSS linear gradients: 12345678910111213@mixin gradient($start-color, $end-color, $orientation) &#123; background: $start-color; @if $orientation == 'vertical' &#123; background: -webkit-linear-gradient(top, $start-color, $end-color); background: linear-gradient(to bottom, $start-color, $end-color); &#125; @else if $orientation == 'horizontal' &#123; background: -webkit-linear-gradient(left, $start-color, $end-color); background: linear-gradient(to right, $start-color, $end-color); &#125; @else &#123; background: -webkit-radial-gradient(center, ellipse cover, $start-color, $end-color); background: radial-gradient(ellipse at center, $start-color, $end-color); &#125;&#125; Usage123.gradient &#123; @include gradient(#07c, #06f, vertical);&#125; Output12345.gradient &#123; background: #07c; background: -webkit-linear-gradient(top, #07c, #06f); background: linear-gradient(to bottom, #07c, #06f);&#125; 11. @font-face123456789101112@mixin font-face($font-name, $file-name, $weight: normal, $style: normal) &#123; @font-face &#123; font-family: quote($font-name); src: url($file-name + '.eot'); src: url($file-name + '.eot?#iefix') format('embedded-opentype'), url($file-name + '.woff') format('woff'), url($file-name + '.ttf') format('truetype'), url($file-name + '.svg##&#123;$font-name&#125;') format('svg'); font-weight: $weight; font-style: $style; &#125;&#125; Usage1@include font-face(\"MyFont\", \"path/to/MyFont\", $style: normal, $weight: normal); Output1234567@font-face &#123; font-family: \"MyFont\"; src: url(\"path/to/MyFont.eot\"); src: url(\"path/to/MyFont.eot?#iefix\") format(\"embedded-opentype\"), url(\"path/to/MyFont.woff\") format(\"woff\"), url(\"path/to/MyFont.ttf\") format(\"truetype\"), url(\"path/to/MyFont.svg#MyFont\") format(\"svg\"); font-weight: normal; font-style: normal;&#125; 12. Centering a block12345@mixin center-block &#123; display: block; margin-left: auto; margin-right: auto;&#125; Usage123.wrapper &#123; @include center-block;&#125; Output12345.wrapper &#123; display: block; margin-left: auto; margin-right: auto;&#125; 13. Vertical centering123456@mixin center-vertically &#123; position: absolute; top: 50%; left: 50%; @include prefix(transform, translate(-50%, -50%), 'webkit' 'ms');&#125; Usage123.vc-box &#123; @include center-vertically;&#125; Output12345678.vc-box &#123; position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); transform: translate(-50%, -50%);&#125; Kết thúc ở đây, hy vọng nó có ích. Vui lòng chỉ ra vấn đề hoặc chia sẻ các đề xuất của bạn qua nhận xét. Thanks :)","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"sass","slug":"sass","permalink":"http://nthung2112.github.io/tags/sass/"}]},{"title":"Hướng dẫn toàn tập về Flexbox","slug":"Huong-dan-toan-tap-ve-Flexbox","date":"2017-08-31T08:32:14.000Z","updated":"2017-09-05T01:12:39.022Z","comments":true,"path":"2017/08/Huong-dan-toan-tap-ve-Flexbox.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Huong-dan-toan-tap-ve-Flexbox.html","excerpt":"BackgroundThe Flexbox Layout (Flexible Box) module nhằm cung cấp một cách hiệu quả hơn việc bố trí, sắp xếp và cân đối không gian giữa các phần tử trong một Container, ngay cả khi kích thước của các phần tử này chưa được biết hay nói cách khác là động (flex). Mục đích chính của Flex layout là cung cấp một flex container có khả năng thay đổi các item bên trong nó chiều rộng, chiều cao, thứ tự của các item giúp cho Flex container này hiển thị tốt trên mọi thiết bị và mọi kích cỡ màn hình. Các item trong một flex container sẽ tự mở rộng để lấp đầy không gian hoặc tự co lại để ngăn chặn chống tràn (Overflow).","text":"BackgroundThe Flexbox Layout (Flexible Box) module nhằm cung cấp một cách hiệu quả hơn việc bố trí, sắp xếp và cân đối không gian giữa các phần tử trong một Container, ngay cả khi kích thước của các phần tử này chưa được biết hay nói cách khác là động (flex). Mục đích chính của Flex layout là cung cấp một flex container có khả năng thay đổi các item bên trong nó chiều rộng, chiều cao, thứ tự của các item giúp cho Flex container này hiển thị tốt trên mọi thiết bị và mọi kích cỡ màn hình. Các item trong một flex container sẽ tự mở rộng để lấp đầy không gian hoặc tự co lại để ngăn chặn chống tràn (Overflow).Quan trọng nhất, Flexbox layout dựa trên phương hướng bố trí ngược với cách bố trí bình thường (block theo chiều dọc và inline theo chiều ngang). Mặc dù những trang này hoạt động tốt, nhưng chúng thiếu tính linh hoạt để hỗ trợ các ứng dụng lớn hoặc phức tạp (đặc biệt liên quan đến thay đổi hướng, thay đổi kích cỡ, kéo dài, co lại, etc.). Chú ý: Flexbox layout là thích hợp nhất với các thành phần của một ứng dụng, và bố trí quy mô nhỏ, trong khi đó Grid layout là dành cho bố trí quy mô lớn hơn. Khái niệm cơ bản &amp; Thuật ngữFlexbox là một module toàn bộ chứ không phải một thuộc tính duy nhất, nó bao gồm rất nhiều thứ kể cả các thuộc tính. Một số trong chúng là để được đặt cho container (element cha, được gọi là “flex container”) trong khi những thứ khác là để được đặt cho children (gọi là “flex items”). Flex container là thành phần lớn bao quanh chứa các phần tử (Flex items) bên trong. Flex items là phần tử con nằm trong thành phần lớn bao quanh gọi là những Flex items, các bạn có thể sắp xếp thứ tự của các Flex items này. Nếu cách bố trí thông thường dựa trên luồng block và inline, flex layout là dựa vào “flex-flow directions”. Nhìn vào những thông số kỹ thuật và giải thích ý tưởng của flex layout ở hình bên dưới. Về cơ bản, những items sẽ được sắp xếp theo một trong hai trục chính (từ main-start đên main-end) hoặc trục dọc (từ cross-start đến cross-end). main axis - The main axis of a flex container is the primary axis along which flex items are laid out. Beware, it is not necessarily horizontal; it depends on the flex-direction property (see below). main-start | main-end - The flex items are placed within the container starting from main-start and going to main-end. main size - A flex item’s width or height, whichever is in the main dimension, is the item’s main size. The flex item’s main size property is either the ‘width’ or ‘height’ property, whichever is in the main dimension. cross axis - The axis perpendicular to the main axis is called the cross axis. Its direction depends on the main axis direction. cross-start | cross-end - Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side. cross size - The width or height of a flex item, whichever is in the cross dimension, is the item’s cross size. The cross size property is whichever of ‘width’ or ‘height’ that is in the cross dimension. Properties for the Parent (flex container) displayĐây là định nghĩa một flex container; inline hoặc block tùy thuộc vào giá trị nhất định. Nó cho phép một flex context cho tất cả con trực tiếp của nó. 123.container &#123; display: flex; /* or inline-flex */&#125; Chú ý rằng CSS columns không có tác dụng trong vùng flex container. flex-direction Định nghĩa này cho trục chính, do đó định nghĩa direction flex items đặt ở trong flex container. Flexbox là một khái niệm layout đơn hướng. Hãy nghĩ flex items là chủ yếu đặt trong hàng ngang hoặc cột dọc. 123.container &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row (default): từ trái sang phải trong ltr; từ phải sang trái rtl row-reverse: phải sang trái trong ltr; trái sang phải trong rtl column: giống như row nhưng từ trên xuống dưới column-reverse: giống như row-reverse nhưng từ trên xuống dưới flex-wrap Mặc định, flex items sẽ cố gắng đặt vào 1 dòng. Bạn có thể thay đổi điều đó và những items sẽ wrap khi có thuộc tính này. 123.container&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap (default): các flex items sẽ được hiển thị trên một dòng wrap: các flex items sẽ hiển thị thành nhiều dòng, từ trên xuống dưới. wrap-reverse: các flex items sẽ hiển thị thành nhiều dòng từ dưới lên trên. Có một vài ví dụ thực tế của flex-wrap ở đây. flex-flow (Áp dụng cho: phần tử cha flex container)Đây là cách viết gọn của thuộc tính flex-direction và flex-wrap, chúng cùng nhau định nghĩa flex container’s trục chính hay trục dọc. Mặc định là row nowrap. 1flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt; justify-contentĐiều này xác định sự sắp xếp theo trục chính. It helps distribute extra free space left over when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size. It also exerts some control over the alignment of items when they overflow the line. 123.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;&#125; flex-start (default): items are packed toward the start line flex-end: items are packed toward to end line center: items are centered along the line space-between: items are evenly distributed in the line; first item is on the start line, last item on the end line space-around: items are evenly distributed in the line with equal space around them. Note that visually the spaces aren’t equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies. space-evenly: items are distributed so that the spacing between any two items (and the space to the edges) is equal. align-itemsThis defines the default behaviour for how flex items are laid out along the cross axis on the current line. Think of it as the justify-content version for the cross-axis (perpendicular to the main-axis). 123.container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start: cross-start margin edge of the items is placed on the cross-start line flex-end: cross-end margin edge of the items is placed on the cross-end line center: items are centered in the cross-axis baseline: items are aligned such as their baselines align stretch (default): stretch to fill the container (still respect min-width/max-width) align-contentThis aligns a flex container’s lines within when there is extra space in the cross-axis, similar to how justify-content aligns individual items within the main-axis. Note: this property has no effect when there is only one line of flex items. 123.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start: lines packed to the start of the container flex-end: lines packed to the end of the container center: lines packed to the center of the container space-between: lines evenly distributed; the first line is at the start of the container while the last one is at the end space-around: lines evenly distributed with equal space around each line stretch (default): lines stretch to take up the remaining space Thuộc tính của Children (flex items) orderMặc định các phần tử được sắp xếp theo giá trị nguồn html, với thuộc tính order chúng ta có thể xắp xếp lại thứ tự các phần tử theo ý muốn mà ko cần thay đổi giá trị nguồn html. 123.item &#123; order: &lt;integer&gt;;&#125; flex-growThis defines the ability for a flex item to grow if necessary. It accepts a unitless value that serves as a proportion. It dictates what amount of the available space inside the flex container the item should take up. If all items have flex-grow set to 1, the remaining space in the container will be distributed equally to all children. If one of the children has a value of 2, the remaining space would take up twice as much space as the others (or it will try to, at least). 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; Số âm không hợp lệ với thuộc tính này. flex-shrinkĐịnh nghĩa một flex item có thể khả năng thu nhỏ nếu cần thiết. 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; Số âm không hợp lệ với thuộc tính này. flex-basisĐịnh nghĩa kích thước mặc định của một phần tử trước khi phân bố không gian của phần còn lại. Nó có thể là một chiều dài (e.g. 20%, 5rem, etc.) hay một từ khóa. Từ khóa auto có nghĩa là “nhìn vào thuộc tính width hoặc height của tôi” (which was temporarily done by the main-size keyword until deprecated). The content keyword means “size it based on the item’s content” - this keyword isn’t well supported yet, so it’s hard to test and harder to know what its brethren max-content, min-content, and fit-content do. 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; If set to 0, the extra space around content isn’t factored in. If set to auto, the extra space is distributed based on its flex-grow value. See this graphic. flexĐây là viết tắt cho flex-grow, flex-shrink và flex-basis. Các thông số thứ hai và thứ ba (flex-shrink và flex-basis) là tùy chọn. Mặc định là 0 1 auto. 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; It is recommended that you use this shorthand property rather than set the individual properties. The short hand sets the other values intelligently. align-selfThis allows the default alignment (or the one specified by align-items) to be overridden for individual flex items. Please see the align-items explanation to understand the available values. 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; Note that float, clear and vertical-align have no effect on a flex item. ExamplesLet’s start with a very very simple example, solving an almost daily problem: perfect centering. It couldn’t be any simpler if you use flexbox. 12345678910.parent &#123; display: flex; height: 300px; /* Or whatever */&#125;.child &#123; width: 100px; /* Or whatever */ height: 100px; /* Or whatever */ margin: auto; /* Magic! */&#125; This relies on the fact a margin set to auto in a flex container absorb extra space. So setting a vertical margin of auto will make the item perfectly centered in both axis. Now let’s use some more properties. Consider a list of 6 items, all with a fixed dimensions in a matter of aesthetics but they could be auto-sized. We want them to be evenly and nicely distributed on the horizontal axis so that when we resize the browser, everything is fine (without media queries!). 1234567891011121314.flex-container &#123; /* We first create a flex layout context */ display: flex; /* Then we define the flow direction and if we allow the items to wrap * Remember this is the same as: * flex-direction: row; * flex-wrap: wrap; */ flex-flow: row wrap; /* Then we define how is distributed the remaining space */ justify-content: space-around;&#125; Done. Everything else is just some styling concern. Below is a pen featuring this example. Be sure to go to CodePen and try resizing your windows to see what happens. See the Pen Demo Flexbox 1. Let’s try something else. Imagine we have a right-aligned navigation on the very top of our website, but we want it to be centered on medium-sized screens and single-columned on small devices. Easy enough. 1234567891011121314151617181920212223/* Large */.navigation &#123; display: flex; flex-flow: row wrap; /* This aligns items to the end line on main-axis */ justify-content: flex-end;&#125;/* Medium screens */@media all and (max-width: 800px) &#123; .navigation &#123; /* When on medium sized screens, we center it by evenly distributing empty space around items */ justify-content: space-around; &#125;&#125;/* Small screens */@media all and (max-width: 500px) &#123; .navigation &#123; /* On small screens, we are no longer using row direction but column */ flex-direction: column; &#125;&#125; See the Pen Demo Flexbox 2. Let’s try something even better by playing with flex items flexibility! What about a mobile-first 3-columns layout with full-width header and footer. And independent from source order. 12345678910111213141516171819202122232425262728293031323334353637.wrapper &#123; display: flex; flex-flow: row wrap;&#125;/* We tell all items to be 100% width */.header, .main, .nav, .aside, .footer &#123; flex: 1 100%;&#125;/* We rely on source order for mobile-first approach * in this case: * 1\\. header * 2\\. nav * 3\\. main * 4\\. aside * 5\\. footer *//* Medium screens */@media all and (min-width: 600px) &#123; /* We tell both sidebars to share a row */ .aside &#123; flex: 1 auto; &#125;&#125;/* Large screens */@media all and (min-width: 800px) &#123; /* We invert order of first sidebar and main * And tell the main element to take twice as much width as the other two sidebars */ .main &#123; flex: 2 0px; &#125; .aside-1 &#123; order: 1; &#125; .main &#123; order: 2; &#125; .aside-2 &#123; order: 3; &#125; .footer &#123; order: 4; &#125;&#125; See the Pen Demo Flexbox 3. Prefixing FlexboxFlexbox requires some vendor prefixing to support the most browsers possible. It doesn’t just include prepending properties with the vendor prefix, but there are actually entirely different property and value names. This is because the Flexbox spec has changed over time, creating an “old”, “tweener”, and “new” versions. Perhaps the best way to handle this is to write in the new (and final) syntax and run your CSS through Autoprefixer, which handles the fallbacks very well. Alternatively, here’s a Sass @mixin to help with some of the prefixing, which also gives you an idea of what kind of things need to be done: 1234567891011121314151617181920212223242526272829303132@mixin flexbox() &#123; display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex;&#125;@mixin flex($values) &#123; -webkit-box-flex: $values; -moz-box-flex: $values; -webkit-flex: $values; -ms-flex: $values; flex: $values;&#125;@mixin order($val) &#123; -webkit-box-ordinal-group: $val; -moz-box-ordinal-group: $val; -ms-flex-order: $val; -webkit-order: $val; order: $val;&#125;.wrapper &#123; @include flexbox();&#125;.item &#123; @include flex(1 200px); @include order(2);&#125; Related Properties A Complete Guide to Grid Almanac entries on Grid properties, like grid-row / grid-column BugsFlexbox is certainly not without its bugs. The best collection of them I’ve seen is Philip Walton and Greg Whitworth’s Flexbugs. It’s an open source place to track all of them, so I think it’s best to just link to that.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"flexbox","slug":"flexbox","permalink":"http://nthung2112.github.io/tags/flexbox/"}]},{"title":"Cách thức hoạt động của Flexbox - Giải thích với ảnh gif đầy màu sắc","slug":"Cach-thuc-hoat-dong-cua-Flexbox","date":"2017-08-31T02:45:26.000Z","updated":"2017-08-31T15:55:28.617Z","comments":true,"path":"2017/08/Cach-thuc-hoat-dong-cua-Flexbox.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Cach-thuc-hoat-dong-cua-Flexbox.html","excerpt":"Flexbox hứa hẹn sẽ giải quyết nhiều vấn đề hiện đang tồn tại trong CSS thuần (ví dụ như căn chỉnh chiều dọc). Nhưng để có thể làm chủ và sử dụng được flexbox thì lại là việc không hề dễ dàng. Nguyên tắc cơ bản của Flexbox là làm cho việc dàn trang linh hoạt và trực quan hơn. Để thực hiện được điều này, các thành phần bao ngoài (containers) được tự quyết định cách phân bố các phần tử con (items) – bao gồm cả kích thước và khoảng cách giữa chúng. Điều này về nguyên tắc nghe có vẻ tốt. Nhưng chúng ta hãy xem nó có vẻ như trong thực tế.","text":"Flexbox hứa hẹn sẽ giải quyết nhiều vấn đề hiện đang tồn tại trong CSS thuần (ví dụ như căn chỉnh chiều dọc). Nhưng để có thể làm chủ và sử dụng được flexbox thì lại là việc không hề dễ dàng. Nguyên tắc cơ bản của Flexbox là làm cho việc dàn trang linh hoạt và trực quan hơn. Để thực hiện được điều này, các thành phần bao ngoài (containers) được tự quyết định cách phân bố các phần tử con (items) – bao gồm cả kích thước và khoảng cách giữa chúng. Điều này về nguyên tắc nghe có vẻ tốt. Nhưng chúng ta hãy xem nó có vẻ như trong thực tế.Trong bài viết này, chúng ta sẽ nghiên cứu 5 thuộc tính nổi trội nhất của Flexbox, khám phá chức năng cũng như cách sử dụng chúng và kết quả đạt được. Thuộc tính #1: Display: FlexHãy xem ví dụ trang web dưới đây: Có 4 thẻ divs kích cỡ khách nhau được đánh dấu với các màu khác nhau đặt trong thẻ div container màu xám. Mặc định mỗi thẻ div sẽ có thuộc tính là display: block. Mỗi ô vuông vì vậy sẽ chiếm hết bề ngang của mỗi dòng. Để bắt đầu với Flexbox, bạn cần đưa container của bạn về dạng của flex container như sau: 123#container &#123; display: flex;&#125; Chưa có thay đổi gì ngoài việc các thẻ div hiển thị trên cùng một dòng. Tuy nhiên đây lại là một sự thay đổi rất đáng kể. Chúng ta đặt tên cho vùng xung quanh đó gọi là flex context. Bây giờ bạn có thể bắt đầu định vị trí cho chúng mà không gặp nhiều khó khăn như khi sử dụng CSS thông thường Thuộc tính #2: Flex DirectionMột Flexbox container có hai trục: một trục chính và một trục dọc, mặc định hiển thị như dưới đây: Mặc định, các items được sắp xếp theo hướng của trục chính, từ trái qua phải. Đây là lí do tại sao các ô vuông hiển thị trên cùng một dòng khi bạn sử dụng display: flex. Tuy nhiên, bạn có thể thay đổi trục chính bằng thuộc tính Flex-direction. 1234#container &#123; display: flex; flex-direction: column;&#125; Có một sự khác biệt quan trọng tạo ra ở đây: flex-direction: column không sắp xếp các ô vuông trên trục dọc (across axis) thay vì trục chính (main axis). Nó làm trục chính thay đổi, xoay từ ngang thành dọc. Bạn có thể sắp xếp flex-direction theo một số cách khác như: row-reverse and column-reverse. Thuộc tính #3: Justify ContentJustify-content sắp xếp các items theo theo main axis. Chúng ta sẽ nghiên cứu chi tiết hơn về sự khác nhau giữa trục chính và trục dọc. Trước hết, hãy quay lại với flex-direction: row. 12345#container &#123; display: flex; flex-direction: row; justify-content: flex-start;&#125; Bạn có năm thuộc tính để sử dụng với justify-content: Flex-start Flex-end Center Space-between Space-around Sự khác nhau giữa space-around và space-between hơi khó để nhận ra. Với space-between, các ô vuông sẽ được căn cách đều nhau, không bao gồm khoảng cách giữa ô vuông đầu và cuối với container Space-around đặt một khoảng cách ở hai bên cạnh mỗi ô vuông — có nghĩa là khoảng cách giữa ô vuông ngoài cùng phía đầu và cuối với container sẽ bằng một nửa khoảng cách giữa các ô vuông với nhau (Giả sử mỗi ô vuông đều có một giá trị căn lề bằng nhau và không bị ghi đè, vì vậy khoảng cách giữa 2 ô vuông sẽ gấp đôi). Chú ý: Hãy nhớ rằng thuộc tính justify-content hoạt động theo trục chính, và flex-direction làm thay đổi trục chính. Đây là điều quan trọng nhất để bạn chuyển sang phần tiếp theo… Thuộc tính #4: Align ItemsNếu như bạn đã nắm được thuộc tính justify-content, align-items sẽ không khó khăn. Trong khi justify-content hoạt động theo trục chính, align-items áp dụng đối với trục dọc. Hãy thiết lập lại flex-direction thành row, để hai trục hiển thị như hình trên. Sau đó, bắt đầu đi sâu vào giá trị của align-items. flex-start flex-end center stretch baseline Ba giá trị đầu tiên chính xác là giống như justify-content, vì vậy không có gì quá lạ ở đây. Tuy nhiên, hai giá trị kế tiếp có một chút khác biệt. Với giá trị stretch, các items sẽ chiếm toàn bộ trục chính, và baseline, đáy của những tags paragraph sẽ được canh đều. (Chú ý với align-items: stretch, Tôi đã phải đặt chiều cao của ô vuông là auto. Nếu không, thuộc tính chiều cao sẽ ghi đè lên stretch.) Với baseline, hãy lưu ý rằng nếu bạn bỏ đi tags paragraph, các ô vuông sẽ được căn lề dưới như hình sau: Để minh họa rõ hơn cho trục chính và trục dọc với nó, hãy kết hợp thuộc tính justify-content và align-items và xem sự khác biệt giữa 2 giá trị center của thuộc tính flex-direction: Với dòng, các ô vuông được thiết lập dọc theo một trục chính ngang. Với cột, chúng xếp dọc theo trục chính thẳng đứng. Các ô vuông được căn giữa cả theo trục ngang và dọc trong 2 trường hợp, cả 2 trường hợp đều ko thay đổi! Thuộc tính #5: Align SelfAlign-self cho phép bạn thao tác thủ công liên kết của một phần tử riêng biệt. Nó sẽ đè lên thuộc tính align-items của 1 ô vuông. Tất cả thuộc tính đều như nhau, bởi vì mặc định nó là auto, nên các ô vuông sẽ theo thuộc tính align-items của container bao nó. 1234567#container &#123; align-items: flex-start;&#125;.square#one &#123; align-self: center;&#125;// Only this square will be centered. Hãy xem kết quả. Bạn sẽ đặt thuộc tính align-self cho 2 ô vuông, và thuộc tính align-items: center và flex-direction: row với các ô vuông còn lại. ConclusionMặc dù chỉ là những tìm hiểu cơ bản về Flexbox, tôi tin những điều này cũng cung cấp cho bạn những kiến thức để dàn trang một cách cơ bản nhất cũng như sắp xếp nội dung chính bài viết của bạn. Cảm ơn vì đã đọc!","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"flexbox","slug":"flexbox","permalink":"http://nthung2112.github.io/tags/flexbox/"}]},{"title":"Trở thành Functional Programmer - Phần 6","slug":"Tro-thanh-Functional-Programmer-Phan-6","date":"2017-08-23T16:30:13.000Z","updated":"2017-08-23T16:30:49.096Z","comments":true,"path":"2017/08/Tro-thanh-Functional-Programmer-Phan-6.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Tro-thanh-Functional-Programmer-Phan-6.html","excerpt":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP.","text":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP. Bước tiếp theo Thông qua 5 phần trước, tôi đã giới thiệu đến các bạn tất cả các concepts tuyệt vời mà FP mang lại, nhưng đồng thời cũng dấy lên trong các bạn câu hỏi : “Giờ thì sao? Liệu những kiến thức đó có thể có ích gì cho tôi trong công việc hàng ngày chứ?” Câu trả lời sẽ là tùy theo từng người. Nếu bạn có thể/đang làm việc với các ngôn ngữ Pure Functional Language như là Elm hay Haskell, thì bạn có thể tận dụng toàn bộ những kiến thức đã đề cập đến, đồng thời các ngôn ngữ đó sẽ hỗ trợ bạn trong việc vận dụng chúng một cách thuận tiện nhất. Còn nếu bạn vẫn đang tiếp tục sử dụng các ngôn ngữ Imperative như Javascript - giống như hầu hết các lập trình viên hiện nay, thì bạn vẫn có thể vận dụng những concepts đã học được, nhưng sẽ cần một vài tùy chỉnh và nguyên tắc cần tuân thủ. Functional Javascript - Code JS theo hướng Functional Javascript có thể thực hiện rất nhiều concepts của FP. Mặc dù nó không thuần khiết (pure) cho lắm, nhưng JS vẫn có lựa chọn để sử dụng khả năng immutability (tính bất biến) hoặc nếu sử dụng các thư viện đã có, thì việc hỗ trợ FP concepts còn mạnh mẽ hơn. Mặc dù áp dụng FP vào JS không hoàn toàn lý tưởng, nhưng nếu bạn có thể tận dụng một vài lợi ích từ FP thì tại sao không thử nhỉ? Immutability - Tính bất biếnĐiều đầu tiên mà ta có thể xem xét áp dụng là tính bất biến. Trong phiên bản ES2015 - hay còn gọi là ES6, có một từ khóa mới đã được giới thiệu có tên là const. Và đúng như tên gọi của từ khóa này, nó được dùng để khai báo một biến mà giá trị không thể gán lại được : 123const a = 1;a = 2; // sẽ có exception có tên là TypeError trong Chrome, Firefox hoặc Node // nhưng không có nếu dùng Safari (bản 10/2016) Ở đây biến a được khai báo là một hằng số (const) nên nó sẽ không thể được set lại giá trị nữa. Vì thế mà đoạn code a = 2 sẽ sinh ra Exception (ngoại trừ Safari). Tuy nhiên, có một vấn đề với const, đó là nó vẫn chưa hoàn toàn implement tính bất biến một cách đầy đủ. Đoạn code dưới đây sẽ thể hiện hạn chế này: 123456const a = &#123; x: 1, y: 2&#125;;a.x = 2; // KHÔNG CÓ EXCEPTION!a = &#123;&#125;; // có exception TypeError Bạn sẽ thấy rằng khi set a.x = 2 thì sẽ không gây ra lỗi. Thứ duy nhất mà từ khóa const áp dụng để kiểm tra tính bất biến chỉ là biến a. Còn tất cả những thành phần mà a có thể liên kết đến thì vẫn có thể thay đổi được (Ở đây sẽ hiểu là keyword const chỉ check a có là object vẫn tạo ra từ đầu hay không, mà không check được các thuộc tính của a bị thay đổi). Tôi thấy khá là thất vọng khi nhận ra điều này, vì nếu được implement một cách hoàn hảo, JS đã có thể trở nên tốt hơn rất nhiều. Vậy liệu có cách nào để chúng ta có thể áp dụng tính bất biến vào JS một cách toàn diện nhất không? Câu trả lời là Có thể, nhưng chúng ta phải sử dụng một thư viện có tên là Immutable. Thư viện này sẽ hỗ trợ tính bất biến tốt hơn so với const nhưng lại khiến code của chúng ta giống Java hơn là Javascript. Currying và CompositionỞ các series trước đó, chúng ta đã học được cách viết hàm hỗ trợ khả năng Currying. Dưới đây là một ví dụ phức tạp hơn: 1const f = a =&gt; b =&gt; c =&gt; d =&gt; a + b + c + d Để ý rằng phiền toái đầu tiên là chúng ta phải chỉ rõ phần currying (a =&gt; b =&gt; c =&gt; d) Và nếu phải gọi hàm f, thì mọi thứ sẽ còn phức tạp hơn 1console.log(f(1)(2)(3)(4)); // prints 10 Quá nhiều dấu ngoặc đơn như trên là đủ để khiến lập trình Lisp phải khóc ròng rồi (Lisp dùng nhiều dấu ngoặc đơn, nên nếu lập trình viên Lisp còn phải khóc trước số lượng dấu ngoặc đơn như này thì đủ thấy sự kinh khủng của dòng code trên là như nào :D) Và vì thế có rất nhiều thư viện để giải quyết vấn đề này. Và thư viện mà tôi thích nhất có tên là Ramda Khi dùng Ramda thì chúng ta có thể viết lại đoạn code trên như sau: 1234const f = R.curry((a, b, c, d) =&gt; a + b + c + d);console.log(f(1, 2, 3, 4)); // prints 10console.log(f(1, 2)(3, 4)); // also prints 10console.log(f(1)(2)(3, 4)); // also prints 10 Phần định nghĩa hàm không được cải thiện nhưng lắm, nhưng chúng ta đã loại bỏ được việc yêu cầu phải viết dấu ngoặc đơn ở phần gọi hàm phía sau. Đồng thời mỗi lần gọi hàm ‘f’, chúng ta có thể áp dụng đúng hoặc ít hơn số lượng tham số nếu muốn. Dưới đây sẽ là code viết lại hàm mult5AfterAdd10 (ở Phần 4) sử dụng Ramda: 123const add = R.curry((x, y) =&gt; x + y);const mult5 = value =&gt; value * 5;const mult5AfterAdd10 = R.compose(mult5, add(10)); Ngoài khả năng trên, Ramda còn có một số hàm đã được viết sẵn để hỗ trợ việc viết các hàm theo phong cách Currying, ví dụ như là R.add hoặc R.multiply, giúp chúng ta đỡ phải viết nhiều code hơn: 1const mult5AfterAdd10 = R.compose(R.multiply(5), R.add(10)); Các hàm Map, Reduce, Filter trong JSMột khả năng nữa của thư viện Ramda là việc cung cấp sẵn các hàm map, filter, reduce. Mặc dù các hàm này đã có trong Array.prototype của JS core, nhưng các hàm này của Ramda cao cấp hơn ở chỗ chúng là các curried function. 12345678const isOdd = R.flip(R.modulo)(2);const onlyOdd = R.filter(isOdd);const isEven = R.complement(isOdd);const onlyEven = R.filter(isEven);const numbers = [1, 2, 3, 4, 5, 6, 7, 8];console.log(onlyEven(numbers)); // prints [2, 4, 6, 8]console.log(onlyOdd(numbers)); // prints [1, 3, 5, 7] Hàm R.modulo yêu cầu 2 tham số, đầu tiên là dividend (số bị chia), tiếp theo là divisor (số chia). Biến isOdd sẽ là hàm được dùng để lấy ra phần dư của việc lấy số bị chia chia cho 2. Nếu phần dư là 0 sẽ tương đương với giá trị false, thể hiện số bị chia không phải là số lẻ, còn nếu phần dư là 1 thì sẽ tương đương với giá trị true, thể hiện số bị chia là số lẻ. Hàm R.flip được dùng để đổi vị trí giữa 2 tham số của hàm R.modulo, khiến giá trị tham số truyền vào lúc đầu sẽ là số chia (ở đây là 2).(kết quả cuối cùng khi gọi isOdd với 1 tham số sẽ trả về kết quả là tham số đó có phải là số chẵn hay không. VD isOdd(4) = false hay isOdd(5) = true). Và hàm isEven sẽ là phần bù của hàm isOdd (tức là giá trị trả về của isEven sẽ ngược với isOdd nên ta có thể sử dụng hàm R.complement) Tiếp theo, hàm onlyOdd là kết quả của hàm filter với hàm dùng để lọc dữ liệu là isOdd, và hàm này sẽ cần tham số là một mảng các số nguyên để thực hiện. Tương tự với hàm onlyEven, chỉ khác là hàm này dùng isEven là hàm để lọc dữ liệu. Khi chúng ta truyền một mảng vào tham số numbers tới hàm onlyOdd hoặc onlyEven, hàm isOdd và isEven sẽ nhận tham số là từng phần tử trong mảng và thực hiện trả về kết quả 0 hoặc 1, tương ứng với true và false, và từ đó hàm onlyOdd hoặc onlyEven sẽ giữ lại các giá trị mong muốn (chỉ số lẻ hoặc số chẵn). Những thiếu sót của Javascript Với tất cả những thư viện và những tính năng được chính JS hỗ trợ, chúng ta có thể có những bước tiến nhất định trong việc áp dụng FP vào JS. Tuy nhiên, có một sự thật không thể chối cãi rằng JS vẫn chỉ là một Imperative Language đang cố để thỏa mãn tất cả mọi người. Rất nhiều lập trình viên frontend đang mắc kẹt với JS bởi lẽ đến thời điểm hiện tại, đó hầu như là lựa chọn duy nhất và không thể tránh khỏi. Nhưng xu hướng hiện nay thì rất nhiều lập trình viên JS đang viết code JS một cách không trực tiếp. Thay vào đó, họ viết một ngôn ngữ khác và biên dịch, hay nói chính xác hơn, biến đổi chúng thành Javascript. Một trong số các ngôn ngữ cho việc trên là CoffeScript. Và với AngularJS 2, TypeScript đã được giới thiệu với tính năng tương tự. Ngoài ra thì Babel cũng được coi như một công cụ để biến đổi JS. Xu thế hiện nay cho thày càng ngày càng có nhiều người sử dụng cách tiếp cận này trong sản phẩm của mình. Nhưng hạn chế rõ ràng nhất là các ngôn ngữ này đều xuất phát từ JS và chỉ có thể làm nó tốt hơn một chút mà thôi. Vậy thì sao chúng ta không triệt để hẳn, biến đổi từ một ngôn ngữ Pure Functional Language sang JS nhỉ? Và đó chính là cách mà Elm được phát triển. Elm Trong suốt series này, chúng ta đã từng sử dụng Elm để hỗ trợ trong việc hiểu về FP. Vậy Elm là gì? Và chúng ta có thể dùng Elm như thế nào?Elm là một ngôn ngữ hoàn toàn là Pure Functional Language, mà source code được viết bởi Elm sau đó sẽ được biến đổi thành code Javascript. Và vì thế, ta có thể sử dụng Elm để tạo ra các Web Application theo Kiến Trúc Elm, hay còn gọi là TEA (kiến trúc này thực tế đã gây cảm hứng cho các kỹ sư tạo ra Redux). Ngôn ngữ Elm sẽ không có bất kỳ lỗi Runtime Error nào (lỗi khi thực hiện code). Elm đã được sử dụng trong môi trường production (môi trường sản phẩm thật) bởi các công ty như là NoRedink, mà công ty đó hiện đang có Evan Czapliki - người tạo ra Elm - làm việc (trước đây ông đã làm cho Prezi). Để biết thêm chi tiết, mời các bạn tham khảo bài nói chuyện 6 tháng làm Elm với production, được tạo ra bởi Richard Feldman và những tín đồ Elm. Liệu tôi có phải thay đổi tất cả code JS của mình bằng Elm không?Không. Bạn có thể thay thế từng phần một. Bài viết sau đây sẽ mô tả chi tiết khả năng này : Làm thế nào để sử dụng Elm trong công việc Vì sao học Elm? Làm việc với một ngôn ngữ Pure Functional Language vừa có sự hạn chế và sự tự do. Sự hạn chế đến từ việc bạn không thể làm những thứ đã làm được trước đó (mà những thứ này hầu hết lại giới hạn output mà bạn có thể tạo ra), nhưng đồng thời, sự tự do sẽ được thể hiện ở những phần mềm không có lỗi, có thiết kế tốt, bởi lẽ các phần mềm được viết bởi Elm sẽ tuân theo TEA (Kiến trúc Elm), một mô hình phù hợp với FP. FP sẽ giúp bạn trở thành một lập trình viên chất lượng hơn. Tất cả các ý tưởng trong series bài viết này chỉ là những phần trên của tảng băng trôi. Chỉ khi áp dụng chúng vào trong thực tế, bạn mới biết được sự lợi hại và hữu ích của FP trong việc phát triển các phần mềm phù hợp với nhiều yêu cầu, đồng thời tăng trưởng một cách ổn định. Javascript là một ngôn ngữ được viết trong 10 ngày, sau đó được chỉnh sửa trong 2 thập kỉ gần đây để cố gắng trở thành một ngôn ngữ vừa functional, vừa hướng đối tượng, trong khi bản chất vẫn là một imperative language. Trong khi đó, Elm được thiết kế dựa trên 30 năm kinh nghiệm làm việc với Haskell, và hàng thập kỷ nghiên cứu trong toán học cũng như khoa học máy tính. Đồng thời kiến trúc Elm(TEA) đã được thiết kế và tinh chỉnh hàng năm trời, và là kết quả từ luận văn của Evan về vấn đề hỗ trợ functional của các ngôn ngữ lập trình. Bạn có thể tham khảo bài nói Watch Controlling Time and Space để biết rõ hơn Evan đã hiện thực hóa ý tưởng của mình như thế nào khi thiết kế ra TEA Elm được thiết kế cho lập trình viên frontend. Mục tiêu của nó là khiến cuộc đời lập trình viên dễ thở hơn. Mời tham khảo bài nói Let’s be Mainstream để hiểu rõ hơn mục tiêu này. Tương lai Việc biết trước tương lai sẽ diễn biến như thế nào là bất khả thi, nhưng chúng ta có thể có một vài dự đoán có cơ sở. Dưới đây là các dự đoán của tôi về tương lai: Sẽ có thêm nhiều ngôn ngữ được viết để biến đổi ra JS.Các ý tưởng của FP đã tồn tại trên 40 năm sẽ được tái nhìn nhận và sử dụng để giải quyết những vấn đề phức tạp của phần mềm hiện nayHiện trạng của các thiết bị phần cứng hiện nay, như hàng Gigabytes bộ nhớ giá rẻ và chip xử lý nhanh sẽ biến các kỹ thuật FP thành khả thiCPUs sẽ tăng trưởng theo hướng có nhiều nhân hơn là tăng tốc độ xử lýPhần mềm có trạng thái biến đổi khi thực hiện sẽ được coi là một trong những vấn đề lớn nhất trong các hệ thống phần mềm phức tạp. Lý do khiến tôi viết series này là bởi vì tôi tin rằng FP sẽ là tương lai của ngành phần mềm, và bởi vì tôi cũng đã tốn vài năm để học nó (hiện tại tôi vẫn đang tiếp tục học FP) Nên mục tiêu của tôi với bài viết này là để giúp mọi người có thể hiểu được những concepts của FP một cách dễ dàng và nhanh chóng hơn so với tôi, đồng thời nếu có thể - giúp các bạn trở thành những lập trình viên tốt hơn, và có sự nghiệp sáng giá trong tương lai. Kể cả việc dự đoán rằng Elm sẽ là một ngôn ngữ phát triển trong tương lai của tôi có thể sai, thì tôi vẫn có thể tự tin khẳng định rằng FP và Elm sẽ nằm trên quỹ đạo chuyển động của tương lai - cho dù đó là tương lai nào đi nữa. Hy vọng rằng sau series này, mọi người sẽ tự tin hơn vào khả năng của mình, cũng như củng cố, nắm vững được những concepst mà tôi đã giới thiệu. Lời cuối cùng, chúc mọi người may mắn trong những nỗ lực phía trước. Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: Learn Elm Programming Và đây là Twitter của tác giả : @cscalfani","categories":[],"tags":[]},{"title":"Trở thành Functional Programmer - Phần 5","slug":"Tro-thanh-Functional-Programmer-Phan-5","date":"2017-08-23T16:28:13.000Z","updated":"2017-08-24T00:53:11.555Z","comments":true,"path":"2017/08/Tro-thanh-Functional-Programmer-Phan-5.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Tro-thanh-Functional-Programmer-Phan-5.html","excerpt":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP.","text":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP. Concept 8 : Referential Transparency - Tham chiếu minh bạch Referential Transparency - Tham chiếu minh bạch là một cụm từ khá là màu mè được dùng để mô tả khả năng của pure function (nếu chưa rõ pure function là gì, mời xem lại Phần 1) khi các vị trí sử dụng pure function đều có thể được thay thế bằng phần định nghĩa của chính nó (nói đơn giản là chỗ nào gọi hàm thì đều có thể thay thế bằng phần thân - các biểu thức định nghĩa hàm). Ví dụ dưới đây sẽ giúp chúng ta hiểu rõ hơn. Giả sử ta có một biểu thức toán học khá quen thuộc như sau : y = x + 10 Và khi gán giá trị cụ thể cho x: x = 3 Thì chúng ta có thể thay thế 3 ở vị trí của x vào biểu thức, khiến biểu thức trở thành : y = 3 + 10 Có thể thấy là y = 3 + 10 vẫn là một biểu thức hoàn toàn hợp lệ. Và với pure function, việc thay thế tương tự như trên là hoàn toàn có thể. Dưới đây là một hàm trong Elm được dùng để thêm dấu nháy đơn vào trước và sau một String : 12quote str = &quot;&apos;&quot; ++ str ++ &quot;&apos;&quot; Và đây là một ngữ cảnh dùng hàm ở trên: 12findError key = &quot;Unable to find &quot; ++ (quote key) Ở đấy hàm findError sẽ xuất ra một message thông báo lỗi khi việc tìm kiếm key không thành công. Vì hàm quote là một pure function, chúng ta có thể thay thế việc gọi hàm đó trong thân hàm findError bằng chính phần thân hàm của hàm quote như sau : 12findError key = &quot;Unable to find &quot; ++ (&quot;&apos;&quot; ++ str ++ &quot;&apos;&quot; ) Việc thay thế này tôi gọi là Tái cấu trúc ngược - Reverse Refactoring (vì nó nghe hợp tai thôi), và được định nghĩa là quá trình có thể được sử dụng bởi lập trình viên hoặc chương trình phần mềm (ví dụ như bộ biên dịch - compiler hay là phần mềm test) để hiểu về ý nghĩa và luồng hoạt động của code, đặc biệt khi tìm hiểu các hàm đệ quy. Execution Order - Thứ tự thực hiện Hầu hết các phần mềm hiện nay đều là đơn luồng (single-thread), có nghĩa là trong một thời điểm, có một và chỉ một đoạn code được thực hiện. Ngay cả khi bạn làm ra một phần mềm theo hướng đa luồng, hầu hết các luồng sẽ bị chặn và phải chờ cho các tác vụ xử lý I/O hoàn thành (tác vụ I/O là các tác vụ liên quan đến xử lý input và output của hệ thống như file, network,... Dưới đây là một cách lý giải cho việc chúng ta thường sẽ nghĩ theo các bước tuần tự khi viết code. Trước hết hãy xem ví dụ sau : 1234567891. Lấy bánh mỳ 2. Đặt 2 lát bánh mỳ vào máy nướng3. Chọn mức nướng4. Bấm nút bắt đầu nướng5. Chờ cho đến khi bánh mỳ nướng xong6. Cất máy nướng 7. Lấy bơ 8. Lấy dao cắt bơ9. Phết bơ vào bánh mỳ nướng Nhìn vào các bước thực hiện cho việc tạo ra bánh mỳ nướng bơ ở trên, chúng ta có thể thấy có 2 luồng hoạt động độc lập : Lấy bơ và nướng bánh. Và 2 luồng hoạt động này chỉ tương tác với nhau ở bước cuối cùng - bước thứ 9. Vì thế chúng ta có thể thực hiện 2 công việc sau song song với nhau : 1 việc bao gồm các bước từ 1 đến 6, và 1 việc bao gồm 2 bước 7 và 8. Và ta sẽ đưa 2 công việc này thành 2 luồng. Nhưng khi chúng ta làm như vậy, mọi thứ sẽ trở nên phức tạp hơn : Luồng thứ 1 Lấy bánh mỳ Đặt 2 lát bánh mỳ vào máy nướng Chọn mức nướng Bấm nút bắt đầu nướng Chờ cho đến khi bánh mỳ nướng xong Cất máy nướng Luồng thứ 2 Lấy bơ Lấy dao cắt bơ Chờ luồng thứ nhất thực hiện xong Phết bơ vào bánh mỳ nướng Ở đây luồng thứ 2 có thêm một công việc là chờ luồng thứ 1 thực hiện xong. Vậy điều gì sẽ xảy ra với luồng thứ 2 nếu luồng thứ 1 thất bại? Nguyên tắc và cách thức để 2 luồng có thể giao tiếp và hợp tác với nhau là gì? Ai sẽ sở hữu bánh mỳ nướng: Luồng 1, luồng 2, hay cả hai? Tất cả các câu hỏi trên sẽ xảy ra khi chúng ta muốn làm đa luồng, và nếu cứ để nguyên ở dạng đơn luồng, chúng ta có thể bỏ qua không cần phải suy nghĩ gì đến các vấn đề phức tạp ở trên. Vậy là bạn đã hiểu lý do vì sao con người luôn tự nhiên suy nghĩ và thực hiện công việc theo một luồng có thứ tự duy nhất rồi chứ. Nhưng chúng ta cần nâng cao tối đa hiệu năng của phần mềm bằng mọi cách có thể, nên việc áp dụng đa luồng sẽ trở thành một điều ta cần nỗ lực để có thể đạt được những kết quả đáng ghi nhận. Tuy nhiên, sẽ có 2 vấn đề khi làm việc với đa luồng. Đầu tiên, các phần mềm đa luồng sẽ rất khó để viết, đọc, lý giải, test và debug (đương nhiên rồi). Thứ hai, một số ngôn ngữ như Javascript thì không hỗ trợ đa luồng, hoặc các ngôn ngữ có hỗ trợ thì hỗ trợ một cách nghèo nàn. Nhưng sẽ ra sao nếu thứ tự thực hiện bỗng chốc trở nên không còn quan trọng nữa, mọi thứ có thể thực hiện song song? Điều này nghe có vẻ điên rồ, nhưng tôi sẽ cho bạn thấy rằng nó có thể. Hãy xem một đoạn code Elm mô tả cho lý luận trên: 12345678buildMessage message value = let upperMessage = String.toUpper message quotedValue = &quot;&apos;&quot; ++ value &quot;&apos;&quot; in upperMessage ++ &quot;: &quot; ++ value Ở đây hàm buildMessage nhận 2 tham số là message và value, sau đó sẽ trả về message phiên bản chữ hoa, kèm với một dấu hai chấm và value nằm trong dấu nháy đơn. Trong hàm này 2 biến upperMessage và quotedValue là độc lập với nhau. Ta sẽ cùng tìm hiểu lý do vì sao có thể kết luận được như vậy? Để xét về tính độc lập, sẽ có 2 nội dung cần được xác nhận là đúng. Thứ nhất, các đối tượng được xét đến đều phải là pure function. Điều này là cực kỳ quan trọng bởi vì các đối tượng này phải biệt lập với các xử lý khác bên ngoài. Nếu các đối tượng này không pure, chúng ta sẽ không bao giờ biết được chúng có độc lập hay không. Và trong trường hợp đó, ta sẽ phải dựa vào thứ tự được gọi của các hàm này được viết trong code để xác định thứ tự thực hiện của chúng. Và đó là cách mà các ngôn ngữ Imperative hoạt động. Thứ hai, để xác định tính độc lập, thì output của một hàm không được các hàm còn lại lấy làm input. Nếu điều này bị vi phạm, thì chúng ta sẽ phải chờ một hàm được thực hiện xong thì mới thực hiện tiếp hàm còn lại, và điều này thì khiến chúng không còn độc lập nữa. Trong ví dụ tôi vừa nêu, cả upperMessage và quotedValue đều là kết quả của 2 hàm pure và chúng đều không yêu cầu output của lẫn nhau. Do đó, 2 hàm này có thể thực hiện theo BẤT KỲ THỨ TỰ NÀO. Bộ biên dịch (compiler) - vì thế có thể tự quyết định thứ tự thực hiện của 2 hàm trên mà không cần sự chỉ đạo cụ thể của người lập trình. Việc này chỉ có thể khả thi với các ngôn ngữ được xác định là Pure Functional Language (là các ngôn ngữ FP mà các biểu thức - expression đều là pure - hay nói cách khác, không tạo ra side-effect), bởi vì nếu không sẽ rất khó, thậm chí là không thể xử lý các side-effect khi chúng xảy ra. Thứ tự thực hiện trong các ngôn ngữ Pure Functional Language có thể được quyết định bởi trình biên dịch (compiler). Đây thực sự là một lợi ích hiển nhiên khi trong thời đại ngày nay, các bộ vi xử lý thay vì được nâng cao tốc độ thì chúng sẽ được trang bị ngày càng nhiều nhân hơn. Việc thứ tự thực hiện có thể được quyết định bởi trình biên dịch sẽ khiến cho code có thể được chạy song song trên nhiều nhân một lúc, và vì thế, hiệu năng sẽ được nâng cao. Đáng tiếc là với các ngôn ngữ Imperative, chúng ta không thể tận dụng tối đa việc CPU có nhiều nhân, trừ khi có sự thay đổi ở phần thấp, thậm chí là lõi của ngôn ngữ, mà khi đó thì sẽ kéo theo rất nhiều thay đổi trong kiến trúc của các phần mềm viết ra dựa trên các ngôn ngữ đó. Với các ngôn ngữ Pure Functional Language, chúng ta sẽ có tiềm năng vận dụng các nhân của CPU một cách hiệu quả nhất mà không cần phải thay đổi bất cứ dòng code nào. Type Annotation - Xác định kiểu dữ liệu Trong các ngôn ngữ có kiểu dữ liệu tĩnh (Statically Typed Language), kiểu được định nghĩa trong cùng 1 dòng. Dưới đây là một đoạn code Java để tham khảo : 123public static String quote(String str) &#123; return &quot;&apos;&quot; + str + &quot;&apos;&quot;;&#125; Bạn hãy để ý phần xác định kiểu trả về của hàm và của tham số đều được viết trong cùng dòng với phần định nghĩa hàm. Và khi ta dùng generics, thì nhìn còn tệ hơn nữa : 123private final Map&lt;Integer, String&gt; getPerson(Map&lt;String, String&gt; people, Integer personId) &#123; // ...&#125; Ở đây các phần dùng để xác định kiểu dữ liệu sẽ là Map&lt;Integer, String&gt;, Map&lt;String, String&gt;, Integer, và bởi vì chúng nằm lẫn với phần định nghĩa hàm, chứa cả tên hàm và các biến, nên chúng ta sẽ mất thời gian và cần nhiều sự tập trung để có thế tìm ra tên các tham số. Ngược lại, với các ngôn ngữ có kiểu dữ liệu động (Dynamically Typed Language), chúng ta không gặp phải vấn đề ở trên. Ví dụ như với Javascript, hàm ở trên sẽ chỉ cần viết như sau là đủ : 123var getPerson = function(people, personId) &#123; //...&#125;; Có thể thấy rằng phiên bản bằng JS ở trên dễ đọc hơn rất nhiều vì ko có những khai báo kiểu dữ liệu loằng ngoằng như với phiên bản của Java. Vấn đề duy nhất ở đây là mặc dù dễ đọc hơn, nhưng chúng ta đã phải bỏ qua sự an toàn khi định nghĩa rõ kiểu dữ liệu. Ta có thể dễ dàng truyền vào các biến có kiểu không phù hợp, như là một số cho biến people hoặc một Object cho biến personID. Và việc truyền nhầm kiểu dữ liệu này chỉ có thể phát hiện đến khi các đoạn code được thực hiện, nên có thể sẽ xảy ra lỗi sau khi chúng ta đã đưa code lên môi trường thật hàng tháng trời. Nhưng với Java thì sẽ không gặp lỗi này, và sẽ được phát hiện khi code được biên dịch (compile). Đó là những điểm lợi và bất lợi giữa kiểu dữ liệu động và tĩnh, và nếu chúng ta có thể kết họp ưu điểm của cả hai, bao gồm syntax đơn giản dễ hiểu bên phía Javascript và sự an toàn khi định rõ kiểu dữ liệu bên Java, thì chẳng phải sẽ rất tuyệt hay sao? Và thực tế là chúng ta có thể làm được. Đây là một ví dụ về một hàm trong Elm với việc định rõ kiểu dữ liệu: 123add : Int -&gt; Int -&gt; Intadd x y = x + y Hãy để ý rằng thông tin về kiểu dữ liệu của tham số và giá trị trả về của hàm được viết bằng một dòng riêng biệt. Và sự tách riêng như này đem đến rất rất nhiều điều khác biệt. Nếu lần đầu nhìn vào đoạn code trên, bạn có thể nghĩ rằng phần khai báo thông tin kiểu dữ liệu (dòng đầu tiên) có lỗi đánh máy. Tôi cũng đã từng cảm thấy như vậy. Lúc đó tôi đã nghĩ dấu -&gt; đầu tiên nên là dấu phẩy. Nhưng thực tế thì câu lệnh đó hoàn toàn chính xác. Nếu đặt thêm vài dấu đóng mở ngoặc, bạn sẽ bắt đầu thấy nó có vẻ hợp lý hơn : 1add : Int -&gt; ( Int -&gt; Int) Biểu thức ở trên chỉ ra rằng hàm add là một hàm có một tham số có kiểu Int và trả về một hàm cũng có một tham số kiểu Intvới kết quả trả về là một giá trị Int. Dưới đây là một khai báo hàm phức tạp hơn một chút: 123doSomething : String -&gt; (Int -&gt; (String -&gt; String))doSomething prefix value suffix = prefix ++ (toString value) ++ suffix Đoạn code trên được dùng để khai báo một hàm có tên là doSomething sẽ nhận một tham số có kiểu String, và trả về 1 hàm (tạm gọi là hàm A). Hàm A là hàm nhận một tham số có kiểu Int, và trả về 1 hàm (hàm B). Hàm B là hàm nhận một tham số có kiểu String, và trả về kết quả là giá trị kiểu String. Có thể thấy rằng tất cả các hàm đều chỉ có một tham số. Đó là bởi tất cả các hàm trong Elm đều hỗ trợ Currying. Và bởi vì dấu ngoặc đơn luôn được đặt vào từ phía ngoài cùng bên phải, lần lượt theo từng dấu mũi tên nên chúng ta có thể bỏ qua không cần chỉ định rõ, và kết quả sẽ là: 1doSomething : String -&gt; Int -&gt; String -&gt; String Dấu ngoặc đơn chỉ thực sự cần thiết khi chúng ta muốn truyền hàm trong tham số. Nếu không sử dụng chúng thì việc xác định kiểu dữ liệu sẽ trở nên mù mờ. Ví dụ: 123takes2Params : Int -&gt; Int -&gt; Stringtakes2Params num1 num2 = -- do something sẽ khác hoàn toàn so với : 123takes1Param : (Int -&gt; Int) -&gt; Stringtakes1Param f = -- do something take2Params là một hàm yêu cầu 2 tham số Int, để có thể trả về giá trị kiểu String. Nhưng take1Param là hàm yêu cầu 1 tham số là một hàm f, mà hàm f đó có 1 tham số là Int và trả về kết quả là Int. Và đây là phần định kiểu dữ liệu cho hàm map chúng ta đã dùng ở phần trước 123map : (a -&gt; b) -&gt; List a -&gt; List bmap f list = // ... Ở đây dấu ngoặc đơn là cần thiết bởi vì hàm f dùng trong hàm map sẽ có kiểu là (a -&gt; b), với ý nghĩa là một hàm nhận vào giá trị kiểu a và trả về giá trị kiểu b. Chữ a ở đây được hiểu với nghĩa là bất kỳ kiểu nào. Nếu một kiểu có ký tự hoa, thì nó sẽ là một kiểu cụ thể, ví dụ như String. Còn nếu một kiểu chỉ có ký tự thường, nó có thể là bất cứ kiểu dữ liệu nào. Vì thế kiểu a có thể là String hay Int đều được. Nếu bạn nhìn thấy kiểu định nghĩa hàm là (a -&gt; a) thì nó sẽ có ý nghĩa là kiểu dữ liệu của tham số và giá trị trả về PHẢI giống nhau, mặc dù có thể là bất kỳ kiểu dữ liệu nào (tức là nếu hàm nhận input kiểu Int thì phải trả về kiểu Int, nhận input kiểu String thì phải trả về kiểu String). Nhưng trong trường hợp của hàm map được viết là (a -&gt; b). Điều đó có nghĩa là hàm f Có thể trả về kiểu dữ liệu khác với tham số nhưng CŨNG có thể trả về kiểu dữ liệu giống với kiểu của tham số. Nhưng khi kiểu của a đã được xác định, thì a sẽ mang kiểu đó trong suốt phần định nghĩa kiểu dữ liệu của hàm. Ví dụ nếu a là kiểu Int và b là String thì định nghĩa kiểu dữ liệu phía trên của hàm map sẽ tương đương với : 1(Int -&gt; String) -&gt; List Int -&gt; List String Bạn sẽ thấy rằng tất cả các chỗ dùng a trong định nghĩa kiểu dữ liệu đã được thay thế bằng Int (ở phần định nghĩa hàm f có (a -&gt; b), cũng như phần tham số thứ 2 là List a), và tất cả các chỗ dùng b đều được thay thế bằng String. Kiểu dữ liệu List Int có nghĩa là một danh sách chứa các phần tử có kiểu Int, và List String tương đương với một danh sách chứa các phần tử có kiểu String. Nếu bạn đã từng sử dụng generics trong Java hoặc các ngôn gnữu khác, thì hẳn bạn sẽ thấy quen thuộc với concept này (ví dụ trong Java là List&lt;T&gt;). Đầu của tôi!!!! Hôm nay đến đây thôi là đủ. Trong phần tiếp theo, cũng là phần cuối cùng của series này, tôi sẽ đề cập đến việc sử dụng tất cả những concept mà tôi đã giới thiệu vào công việc hàng ngày như thế nào, cụ thể sẽ là trong việc lập trình Javascript nhưng theo hướng functional, và lập trình với Elm. Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: Learn Elm Programming Và đây là Twitter của tác giả : @cscalfani","categories":[],"tags":[]},{"title":"Trở thành Functional Programmer - Phần 4","slug":"Tro-thanh-Functional-Programmer-Phan-4","date":"2017-08-23T16:26:54.000Z","updated":"2017-08-24T00:53:04.969Z","comments":true,"path":"2017/08/Tro-thanh-Functional-Programmer-Phan-4.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Tro-thanh-Functional-Programmer-Phan-4.html","excerpt":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP.","text":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP. Concept 7 : Currying Tiếp tục câu chuyện ở cuối Phần 3 , lý do khiến chúng ta gặp phải vấn đề trong việc kết hợp hai hàm mul5 và add là bởi vì hàm mult5 có 1 tham số, trong khi hàm add lại có 2. Chúng ta có thể giải quyết vấn đề này bằng cách giới hạn lại mỗi hàm chỉ lấy một tham số. Nghe có vẻ hơi kỳ kỳ, nhưng tin tôi đi, ý tưởng này không tệ một chút nào đâu. Chúng ta sẽ chỉ đơn giản là viết một hàm add vẫn có hai tham số, nhưng có khả năng nhận giá trị cho một tham số trong một thời điểm. Và hàm hỗ trợ khả năng này được biết đến với cái tên là Curried Function. Một Curried Fuction là một hàm chỉ nhận một tham số trong một thời điểm. Điều này sẽ cho phép chúng ta gán giá trị tham số đầu tiên của hàm add trước khi kết hợp với hàm mult5. Và sau đó khi hàm mult5AfterAdd10 được gọi, hàm add sẽ nhận giá trị tham số thứ hai. Trong Javascript, chúng ta có thể đạt được điều này bằng cách viết lại hàm add như sau: 1var add = x =&gt; y =&gt; x + y Phiên bản này của hàm add sẽ nhận hai tham số gồm x và y, nhưng một tham số (x) sẽ được set khi gọi hàm lần đầu tiên và tham số còn lại (y) sẽ được set khi gọi hàm lần thứ 2. Cụ thể hơn, đầu tiên, hàm add sẽ nhận giá trị cho tham số x, và trả về một hàm mới với một tham số có tên là y, với giá trị kết quả trả về là tổng của hai tham số x và y. Và bây giờ chúng ta có thể sử dụng phiên bản trên của hàm add để tạo ra hàm mult5AfterAdd10 như mong muốn : 12var compose = (f, g) =&gt; x =&gt; f(g(x));var mult5AfterAdd10 = compose(mult5, add(10)); Hàm compose sẽ nhận 2 tham số là f và g, và trả về một hàm nhận 1 tham số x, mà khi được gọi sẽ thực hiện lần lượt 2 hàm g và f lên với tham số nhận được (gọi hàm g(x), kết quả nhận được truyền vào hàm f, tương đương với việc gọi f(g(x))). Vậy chính xác ta đã làm gì? Theo lý thuyết thì ta đã tạo ra một phiên bản curried function của hàm add truyền thống. Việc này làm hàm add trở nên linh động hơn, bởi vì 2 tham số có thể được set ở 2 thời điểm khác nhau. Tham số đầu tiên, 10 được truyền vào để tạo ra hàm mult5AfterAdd10, và tham số thứ 2 được truyền vào khi thực hiện hàm mul5AfterAdd10 với một tham số bất kỳ. Đến đây, bạn có thể nghĩ rằng làm thế nào để viết lại hàm add theo phong cách trên bằng ngôn ngữ Elm. Tôi xin giải đáp luôn là bạn không cần phải làm thế đâu. Trong Elm và các ngôn ngữ FP khác, tất cả các hàm đều là curried function. Vậy là hàm add trong Elm vẫn giữ nguyên cách khai báo : 12add x y = x + y Và đây là cách mà hàm mult5AfterAdd10 nên được viết: 12mult5AfterAdd10 = (mult5 &lt;&lt; add 10) Về mặt cú pháp, có thể nói rằng Elm đã đánh bại hoàn toàn Javascript cũng như các ngôn ngữ Imperative khác bởi vì nó đã được tối ưu cho những concept cơ bản của FP như là Currying hay Composition. Currying và Tái cấu trúc code Ngoài khả năng dùng để tạo ra các hàm hợp như đã mô tả ở trên, Currying còn rất hữu ích khi chúng ta thực hiện tái cấu trúc code. Đó là khi ta muốn tạo một hàm tổng với rất nhiều tham số, và sau đó sử dụng nó để tạo ra các hàm cụ thể phù hợp với từng ngữ cảnh sử dụng, mà yêu cầu ít tham số hơn. Lấy ví dụ, khi chúng ta có 2 hàm sau đây dùng để thêm 1 hoặc 2 dấu ngoặc nhọn vào trước và sau 1 String: 1234bracket str = &quot;&#123;&quot; ++ str ++ &quot;&#125;&quot;doubleBracket str = &quot;&#123;&#123;&quot; ++ str ++ &quot;&#125;&#125;&quot; Và đây là một số ngữ cảnh chúng ta sẽ sử dụng 2 hàm đó : 1234bracketedJoe = bracket &quot;Joe&quot;doubleBracketedJoe = doubleBracket &quot;Joe&quot; Chúng ta có thể tổng quát hóa 2 hàm bracket và doubleBracket thành 1 hàm như sau : 12generalBracket prefix str suffix = prefix ++ str ++ suffix Nhưng như vậy thì mỗi khi sử dụng hàm generalBracket, chúng ta sẽ phải truyền thêm giá trị dấu đóng/mở ngoặc : 1234bracketedJoe = generalBracket &quot;&#123;&quot; &quot;Joe&quot; &quot;&#125;&quot;doubleBracketedJoe = generalBracket &quot;&#123;&#123;&quot; &quot;Joe&quot; &quot;&#125;&#125;&quot; Cái chúng ta thực sự muốn là tập hợp các lợi ích của cả 2 cách: sử dụng đơn giản (truyền mỗi String vào hàm), nhưng không được lặp code. Nếu chúng ta sắp xếp lại thứ tự các tham số của hàm generateBracket, chúng ta có thể tạo ra 2 hàm bracket và doubleBracket vì hàm generateBracket vốn đã hỗ trợ Currying rồi: 123456generalBracket prefix suffix str = prefix ++ str ++ suffixbracket = generalBracket &quot;&#123;&quot; &quot;&#125;&quot;doubleBracket = generalBracket &quot;&#123;&#123;&quot; &quot;&#125;&#125;&quot; Để ý rằng bằng việc đưa các tham số có vẻ như sẽ được set cố định trước lên đầu tiên, trong ví dụ này là prefix và suffix, và đưa các tham số sẽ được set sau cùng vào phía sau, chúng ta có thể tạo ra các phiên bản cụ thể và phù hợp với nhu cầu sử dụng từ hàm generalBracket. Thứ tự các tham số là rất quan trọng trong việc tận dụng khả năng Currying. Đồng thời, ta cũng có thể nhận thấy là các hàm bracket và doubleBracket đều được viết dưới dạng Point-free Notation, cụ thể trong trường hợp này tham số str được loại bỏ. Cả 2 hàm bracket và doubleBracket đều là những hàm đang chờ đợi tham số cuối cùng. Và giờ chúng ta có thể sử dụng 2 hàm đó như trước khi tái cấu trúc code : 1234bracketedJoe = bracket &quot;Joe&quot;doubleBracketedJoe = doubleBracket &quot;Joe&quot; Nhưng lần này chúng ta đã sử dụng một hàm tổng quát hỗ trợ Currying có tên generalBracket. Một số hàm functional cơ bản Giờ chúng ta sẽ đến với 3 hàm cơ bản thường được sử dụng trong Functional Programming. Nhưng trước tiên, tôi muốn mời bạn xem đoạn code sau trong Javascript: 123for (var i = 0; i &lt; something.length; ++i) &#123; // do stuff&#125; Có một vấn đề khá điển hình với đoạn code trên. Mặc dù không phải là bug, nhưng đoạn code trên sẽ được chúng ta viết hoặc copy paste mỗi lần muốn sử dụng vòng lặp (boilerplate code - code khuôn mẫu), nên sẽ khiến việc viết đọc code trở nên mệt mỏi dần theo thời gian. Nếu làm việc với các ngôn ngữ Imperative như là Java, C#, Javascript, PHP, Python,… bạn sẽ dễ dàng nhận thấy mình phải liên tục viết đi viết lại các dòng code tương tự như trên nhiều hơn bất cứ thứ gì khác. Và đó chính là vấn đề mà tôi muốn nói đến. Vì vậy tiếp theo đây chúng ta sẽ bàn về việc khử các đoạn code nhàm chán đó. Hãy đưa chúng và một hàm (hoặc một vài hàm) và ta sẽ không bao giờ phải viết một vòng lặp for một lần nào nữa. Thực tế thì điều đó khá là bất khả thi, nếu như chúng ta không biết đến FP. Trước hết, hãy bắt đầu bằng việc thay đổi một mảng có tên là things: 12345var things = [1, 2, 3, 4];for (var i = 0; i &lt; things.length; ++i) &#123; things[i] = things[i] * 10; // MUTATION ALERT !!!!&#125;console.log(things); // [10, 20, 30, 40] Bạn có nhận thấy điều gì ở đây ko? Đó chính là Mutability - biến things đã bị thay đổi giá trị Chúng ta sẽ thử lại, lần này sẽ không thay đổi giá trị biến things nữa: 123456var things = [1, 2, 3, 4];var newThings = [];for (var i = 0; i &lt; things.length; ++i) &#123; newThings[i] = things[i] * 10;&#125;console.log(newThings); // [10, 20, 30, 40] Lần này thì chúng ta không thay đổi giá trị của biến things, nhưng về mặt kỹ thuật thì chúng ta vẫn thay đổi giá trị của biến newThings, nhưng chúng ta sẽ bỏ qua và chấp nhận điều đó, vì hiện tại ta vẫn đang sử dụng Javascript. Khi chuyển sang các ngôn ngữ FP, bạn sẽ không thay đổi biến được nữa đâu. Mục đích mà tôi muốn nói ở đây là giải thích rõ ràng hơn cách hoạt động của những hàm cơ bản trong FP (map, reduce, filter,… ), cũng như tác dụng của chúng trong việc giảm bớt những phiền phức không đáng có trong code của mình. Do đó code JS có thể không mô tả đúng hoàn toàn cách các hàm đó thực hiện, nhưng về concept thì các bạn cứ yên tâm mà theo dõi nhé. Giờ với đoạn code ở trên (không thay đổi biến things), chúng ta sẽ đưa nó vào một hàm cơ bản đầu tiên có tên là map, với nhiện vụ là ánh xạ (map) từng giá trị của mảng cũ đến một mảng mới, thông qua một hàm biến đổi f: 1234567var map = (f, array) =&gt; &#123; var newArray = []; for (var i = 0; i &lt; array.length; ++i) &#123; newArray[i] = f(array[i]); &#125; return newArray;&#125;; Ta có thể thấy hàm map ngoài tham số là một mảng cần biến đổi, sẽ nhận thêm một tham số là f, đại diện cho việc mà chúng ta muốn xử lý với từng phần tử trong mảng cũ trước khi đưa vào mảng mới. (VD : nhân đôi từng phần tử thì hàm f sẽ là var f = x =&gt; x *2, hoặc cộng mỗi phần tử thêm 1 thì hàm f sẽ là var f = x =&gt; x+1, …) Và với code ban đầu, chúng ta có thể viết lại bằng cách sử dụng hàm map như sau : 12var things = [1, 2, 3, 4];var newThings = map(v =&gt; v * 10, things); Bạn có thể thấy là chúng ta đã không còn sử dụng vòng lặp for nữa, đồng thời code cũng trở nên dễ hiểu hơn (chúng ta có thể hiểu đoạn code trên là tạo ra một newThings là một mảng gồm các phần tử như mảng things, nhưng mỗi phần tử có giá trị được nhân lên 10 lần). Về mặt kỹ thuật thì vẫn có vòng lặp for ở trong hàm map. Nhưng ít ra thì chúng ta sẽ không phải copy paste hoặc gõ lại cái đoạn code mẫu đó thêm một lần nữa. Giờ thì chúng ta sẽ viết thêm một hàm có filter để lọc các phần tử của một mảng theo điều kiện bất kỳ: 12345678var filter = (pred, array) =&gt; &#123; var newArray = [];for (var i = 0; i &lt; array.length; ++i) &#123; if (pred(array[i])) newArray[newArray.length] = array[i]; &#125; return newArray;&#125;; Lưu ý hàm dùng để xác định có lấy phần tử đó hay không được truyền thông qua biến pred, chỉ trả về giá trị Boolean thôi nhé. Hàm này sẽ trả về TRUE khi chúng ta muốn giữ lại phần tử, và FALSE nếu chúng ta muốn loại nó ra. Và đây là cách sử dụng hàm filter để lấy ra các phần tử là số lẻ trong một mảng : 1234var isOdd = x =&gt; x % 2 !== 0;var numbers = [1, 2, 3, 4, 5];var oddNumbers = filter(isOdd, numbers);console.log(oddNumbers); // [1, 3, 5] Sử dụng hàm filter vừa viết ở trên sẽ đơn giản và dễ dàng hơn rất nhiều với việc phải đóng mở vòng for, set các biến lưu giá trị,… những công việc nhàm chán lại hay sai. Hàm thường xuyên được sử dụng trong FP tôi muốn giới thiệu cuối cùng có tên là reduce. Về cơ bản, nó được dùng với giá trị đầu vào là một danh sách, và kết quả trả ra là một giá trị đơn lẻ (nên mới được gọi là reduce - rút gọn), nhưng thực tế thì có rất nhiều cách để áp dụng. Hàm reduce thường được biết đến với cái tên là fold trong FP: 123456var reduce = (f, start, array) =&gt; &#123; var acc = start; for (var i = 0; i &lt; array.length; ++i) acc = f(array[i], acc); // f() takes 2 parameters return acc;&#125;); Hàm reduce sẽ gồm 3 tham số, bao gồm một hàm f dùng để thực hiện rút gọn (reduce), một giá trị khởi đầu start và một mảng để thao tác array. Để ý rằng hàm dùng cho việc rút gọn là f sẽ nhận 2 tham số, một là giá trị hiện tại của mảng array, một là giá trị tích lũy acc đang được tính toán và thay đổi khi duyệt qua từng phần tử trong mảng. Giá trị acc ở bước cuối cùng sẽ được trả về và cũng là kết quả của hàm reduce. Ví dụ dưới đây sẽ giúp chúng ta hiểu rõ hơn cách hoạt động của hàm này : 1234var add = (x, y) =&gt; x + y;var values = [1, 2, 3, 4, 5];var sumOfValues = reduce(add, 0, values);console.log(sumOfValues); // 15 Hàm add sẽ nhận vào 2 tham số và trả về tổng của chúng. Hàm reduce của chúng ta chấp nhận các hàm cho việc rút gọn với 2 tham số, nên trong trường hợp này hàm add là hoàn toàn hợp lý. Chúng ta bắt đầu với giá trị start là 0 và truyền vào một mảng values, do đó kết quả nhận lại của hàm reduce sẽ là tổng các phần tử trong mảng values. Trong hàm reduce, giá trị tổng các phần tử sẽ được tích lũy, cộng dồn sau mỗi lần duyệt từng phần tử của mảng. Bắt đầu acc = start = 0, giá trị đầu tiên của mảng là 1, lần thực hiện đầu tiên của hàm add sẽ là add(1,0) và acc mang giá trị 1 giá trị thứ 2 của mảng là 2, acc = 1, hàm add lúc này sẽ được gọi với giá trị add(2, 1),và acc = 3 Tiếp tục như vậy đến cuối cùng, giá trị acc = 15 sau lần duyệt phần tử cuối cùng (5) của mảng value và được trả về bởi hàm reduce. Có thể thấy rằng, mỗi hàm map, filter, reduce sẽ cho phép chúng ta thực hiện các biến đổi thông thường với một mảng mà không phải viết những đoạn code sử dụng vòng lặp dài dòng và khó hiểu nữa. Nhưng trong FP, khi mà chúng ta chỉ có đệ quy, còn vòng lặp thì không tồn tại, thì các hàm duyệt và biến đổi mảng ở trên sẽ trở nên cực kì hữu ích và cần thiết. Đầu của tôi!!!! Hôm nay đến đây thôi là đủ. Trong các phần sau của bài viết này, tôi sẽ nói về các vấn đề như là Referential Integrity, Execution Order, Types và một vài thứ nữa Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: Learn Elm Programming Và đây là Twitter của tác giả : @cscalfani","categories":[],"tags":[]},{"title":"Trở thành Functional Programmer - Phần 3","slug":"Tro-thanh-Functional-Programmer-Phan-3","date":"2017-08-23T16:25:03.000Z","updated":"2017-08-24T00:52:55.335Z","comments":true,"path":"2017/08/Tro-thanh-Functional-Programmer-Phan-3.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Tro-thanh-Functional-Programmer-Phan-3.html","excerpt":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP.","text":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP. Concept 5: Function Composition - Hàm hợp Lười là một trong những đặc trưng của lập trình viên chúng ta. Điển hình cho cái tính lười này là sự ngán ngẩm khi phải thực hiện đi thực hiện lại công việc chỉnh sửa, test, deploy code mà mình đã từng viết trước đó. Vì thế, chúng ta luôn luôn tìm ra những cách để chỉ làm một lần và đem ra tái sử dụng một lúc nào đó. Tái sử dụng code (code reuse) là một thứ thật tuyệt vời nhưng rất khó để đạt được. Nếu các đoạn code quá cụ thể thì ta không thể nào tái sử dụng được. Nhưng nếu các đoạn code đó lại quá chung chung thì lại rất khó khi áp dụng vào từng trường hợp cụ thể. Do đó chúng ta cần một sự cân bằng giữa hai tính chất trên, cần một cách để tạo ra các khối code nhỏ, có thể dễ dàng tái sử dụng - giống như các viên gạch vậy - để tạo nên các chức năng phức tạp. Trong FP, hàm được coi như các khối vật liệu xây dựng nên chương trình. Chúng ta sẽ viết các hàm cho những công việc cụ thể, nhưng sau đó chúng ta có thể ghép chúng lại như ghép Lego vậy. Và concept mô tả cho việc này có tên là Function Composition - Hàm hợp Vậy nó hoạt động như thế nào? Để hiểu rõ hơn, hãy cùng bắt đầu với 2 hàm Javascript sau : 123456var add10 = function(value) &#123; return value + 10;&#125;;var mult5 = function(value) &#123; return value * 5;&#125;; Nhìn 2 hàm này khá là rối rắm, nên chúng ta có thể viết lại bằng cách sử dụng Arrow function như sau: 12var add10 = value =&gt; value + 10;var mult5 = value =&gt; value * 5; Gọn hơn rồi nhỉ. Lúc này hãy thử tưởng tượng rằng chúng ta có một hàm nhận một giá trị số rồi cộng với 10, sau đó nhân kết quả nhận được với 5. Chúng ta có thể viết như sau : 1var mult5AfterAdd10 = value =&gt; 5 * (value + 10) Mặc dù đây chỉ là một ví dụ đơn giản, nhưng chúng ta sẽ có cảm giác rằng mình không hề muốn viết hàm này từ con số 0 một chút nào. Lý do đầu tiên, vì chúng ta có thể phạm phải một số sai lầm như là quên mất dấu đóng/mở ngoặc. Lý do thứ hai, chúng ta đã có 2 hàm trước đó, add10 dùng để cộng thêm 10 vào 1 giá trị, mult5 dùng để nhân 5 lần giá trị nhận được, nên việc viết lại hàm mul5AfterAdd10 thực chất chỉ là viết lại những gì đã viết. Và vì thế, chúng ta sẽ dùng 2 hàm add10 và mult5 làm thành phần cho việc xây dựng nên hàm mới: 1var mult5AfterAdd10 = value =&gt; mult5(add10(value)); Ta đã vừa sử dụng các hàm đã có để tạo nên hàm mult5AfterAdd10, nhưng vẫn còn cách cải thiện đoạn code trên. Chúng ta sẽ nhắc lại một chút về toán học. f ∘ g là phép hợp hàm và được diễn giải là hàm f kết hợp với hàm g, hoặc theo ngôn ngữ phổ thong, hàm f sau hàm g. Vì thế (f ∘ g)(x) tương đương với việc gọi hàm f sau khi gọi hàm g với tham số là x, hay viết gọn lại là f(g(x)). Ví dụ ở trên sẽ tương đương với mult5 ∘ add10 hoặc là hàm mult5 theo sau hàm add10, và vì thế tên hàm sẽ là mult5AfterAdd10. Và đó chính xác là những gì mà chúng ta đã làm. Ta gọi hàm mult5 sau khi gọi hàm add10 với tham số là value, hay viết gọn là mult5(add10(value)). Vì Javascript không hỗ trợ FP một cách hoàn toàn nên code có vẻ khá phức tạp, chúng ta hãy nhìn sang phiên bản của Elm: 123456add10 value = value + 10mult5 value = value * 5mult5AfterAdd10 value = (mult5 &lt;&lt; add10) value Toán tử &lt;&lt; được dùng để kết hợp hàm ở trong Elm. Và việc sử dụng toán tử này sẽ cho chúng ta một hình dung khá rõ ràng về luồng xử lý dữ liệu. Đầu tiên, biến value được truyền cho hàm add10, sau đó sẽ được truyền sang hàm mult5. Đồng thời hãy lưu ý dấu mở và đóng ngoặc ở hàm mult5AfterAdd10, cụ thể là ở đoạn (mult5 &lt;&lt; add10). Việc sử dụng đóng mở ngoặc ở đây nhằm đảm bảo rằng 2 hàm sẽ được kết hợp trước khi xử lý tham số value. Ta cũng có thể kết hợp nhiều hàm nếu thích : 12f x = (g &lt;&lt; h &lt;&lt; s &lt;&lt; r &lt;&lt; t) x Ở đây biến x sẽ được truyền vào hàm t, kết quả được truyền sang hàm r, sau đó kết quả ở hàm rlại sang hàng s và tiếp tục cho đến hết hàm g. Phiên bản hàm hợp tương đương ở Javascript sẽ là g(h(s(r(t(x))))) - trông như một đống ngổn ngang toàn dấu đóng mở ngoặc. Concept 6 : Point-Free Notation(Lời người dịch : Từ này mình không tìm thấy từ tiếng Việt tương ứng, theo ý hiểu của mình có nghĩa là ký hiệu hàm mà không phải chỉ định rõ tham số nên được gọi là Point - Free) Có một phong cách viết code mà không phải chỉ định rõ tham số với tên gọi là Point-Free Notation. Ban đầu phong cách này nhìn có thể kỳ cục nhưng theo thời gian, chúng ta sẽ cảm nhận được tác dụng của sự vắn tắt này. Quay trở lại ví dụ về hàm mult5AfterAdd10, ta nhận thấy rằng biến value được ghi ra hai lần. Một lần trong danh sách tham số và một lần được sử dụng trong thân hàm 123-- This is a function that expects 1 parametermult5AfterAdd10 value = (mult5 &lt;&lt; add10) value Nhưng thực tế thì tham số này là không cần thiết vì hàm add10 - hàm ở ngoài cùng bên phải của hàm hợp, cũng dùng chính xác tham số đó. Dưới đây sẽ là phiên bản point-free tương đương với hàm trên: 123-- This is also a function that expects 1 parametermult5AfterAdd10 = (mult5 &lt;&lt; add10) Khi viết theo cách này, thực tế sẽ đem lại cho ta rất nhiều lợi ích. Đầu tiên, chúng ta không phải chỉ rõ các tham số được rút gọn, do đó chúng ta không phải mất thời gian để nghĩ tên cho tất cả các tham số đó. Thứ hai, viết theo kiểu này sẽ dễ đọc và suy luận hơn vì nó sẽ bớt rối rắm. Ví dụ phía trên rất đơn giản, nhưng hãy tưởng tượng nếu một hàm nhận nhiều hơn một tham số. Rắc rối chốn thiên đường Từ đầu bài viết đến giờ, chúng ta đã tìm hiểu cách Hàm hợp hoạt động và lý do cũng như cách chúng ta nên viết hàm dưới dạng Point-Free Notation cho sự mạch lạc, rõ ràng và linh động. Giờ, hãy thử áp dụng các ý tưởng trên vào một bối cảnh khác và xem chúng hoạt động ra sao nhé. Tưởng tượng chúng ta thay hàm add10 bằng hàm add như sau : 1234add x y = x + ymult5 value = value * 5 Câu hỏi giờ là : Làm thế nào để tạo ra hàm mult5After10 chỉ với 2 hàm trên. Trước khi đi tiếp, tôi khuyên bạn hãy dừng lại và nghĩ một chút. Không có gì nghiêm trọng cả, chỉ đơn giản là dừng lại và thử ngẫm nghĩ một chút thôi. Ok, nếu bạn đã bỏ thời gian suy nghĩ, thì có thể bạn đã nghĩ đến giải pháp như dưới đây: 123-- This is wrong !!!!mult5AfterAdd10 = (mult5 &lt;&lt; add) 10 Nhưng thực tế nó sẽ không hoạt động. Vì sao? Vì hàm add cần hai - hai chứ không phải một tham số. Nếu trong Elm nhìn có vẻ không hiển nhiên, chúng ta sẽ quay lại với phiên bản Javascript: 1var mult5AfterAdd10 = mult5(add(10)); // cái này không hoạt động Đoạn code này không đúng, nhưng lý do là vì sao? Nguyên nhân là vì hàm add chỉ lấy 1 trong 2 tham số để tính toán, tạo ra kết quả sai, mà kết quả sai đó sẽ được truyền sang hàm mult5, dẫn đến kết quả cuối cùng không đúng. Trong thực tế, với Elm, bộ biên dịch - compiler sẽ không bao giờ bỏ qua những dòng code sai định dạng như trên (và đó là một trong những điểm tuyệt vời của Elm). Chúng ta có thể viết lại như sau : 1var mult5AfterAdd10 = y =&gt; mult5(add(10, y)); // not point-free Đây không phải là cách viết hàm theo phong cách point-free, nhưng ít ra thì nó sẽ đảm bảo được kết quả đúng. Nhưng giờ thì ta không thể dùng toán tử kết hợp các hàm lại thành hàm hợp nữa (là phần &lt;&lt;). Thay vì thế ta đang tạo ra một hàm mới. Sau này nếu kịch bản trở nên phức tạp hơn, ví dụ như muốn kết hợp hàm mult5AfterAdd10 với một cái gì đó khác, lúc này mọi thứ sẽ trở nên thực sự rắc rối. Vì thế khi chúng ta không thể kết hợp hai hàm ở trên, có một điều ta nhận thấy rõ ràng là Hàm hợp có sự hạn chế nhất định. Điều đó thật tệ vì Hàm hợp là một concept khá mạnh mẽ. Vậy làm thế nào để chúng ta giải quyết vấn đề trên? Chúng ta cần thứ gì để có thể thổi bay sự rắc rối này? Giả sử chúng ta có thể làm cách nào đó để chỉ truyền cho hàm add một giá trị tham số trước tiên (khi tạo hàm hợp) , và tham số thứ 2 sẽ được truyền vào sau đó khi thực hiện hàm hợp - ở đây là lúc hàm mult5AfterAdd10 được gọi, chẳng phải vấn đề ở trên sẽ dễ dàng được giải quyết sao. Và thực tế là cách đó có tồn tại, với tên gọi là Currying. Đầu của tôi!!!! Hôm nay đến đây thôi là đủ. Trong các phần sau của bài viết này, tôi sẽ nói về các vấn đề như là Currying, các functional functions cơ bản (như là map, filter, fold,… ), Referential Transparency và một vài thứ nữa Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: Learn Elm Programming Và đây là Twitter của tác giả : @cscalfani","categories":[],"tags":[]},{"title":"Trở thành Functional Programmer - Phần 2","slug":"Tro-thanh-Functional-Programmer-Phan-2","date":"2017-08-23T16:22:32.000Z","updated":"2017-08-24T00:52:47.992Z","comments":true,"path":"2017/08/Tro-thanh-Functional-Programmer-Phan-2.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Tro-thanh-Functional-Programmer-Phan-2.html","excerpt":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP.","text":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP. Một chút lưu ý Tôi mong các bạn sẽ đọc các dòng code một cách từ tốn. Và hãy đảm bảo rằng bạn đã hoàn toàn hiểu rõ, nắm vững các nội dung vừa đọc được trước khi tiếp tục. Các phần tiếp theo được phát triển từ các phần trước đó, nên nếu bạn vội vã, bạn có thể bỏ qua một vài kiến thức quan trọng, cần thiết cho các phần sau này. Tái cấu trúc - Refactoring Phần này sẽ nói về Tái cấu trúc - một kỹ thuật khá quen thuộc đối với các lập trình viên. Sau đây mời các bạn xem một đoạn code Javascript: function validateSsn(ssn) {if (/^\\d{3}-\\d{2}-\\d{4}/.exec(ssn)) console.log(‘Valid SSN‘); else console.log(‘Invalid SSN‘); } function validatePhone(phone) { if (/^(\\d{3})\\d{3}-\\d{4}/.exec(phone)) console.log(‘Valid Phone Number‘); else console.log(‘Invalid Phone Number‘);} Hẳn là bạn đã từng viết những dòng code kiểu như thế này, và theo thời gian, bạn sẽ dần nhận ra rằng 2 hàm phía trên khá là giống nhau, chỉ có đôi chút khác biệt (phần được bôi đậm). Vì thế, thay vì copy lại hàm validateSSn và thay đổi để tạo ra hàm validatePhone mới, chúng ta có thể chỉ tạo một hàm và biến các phần khác nhau thành tham số. Trong ví dụ này, chúng ta nên tham số hóa phần value, phần regulare expression và phần message được in ra (là những phần bôi đậm ở trên). Đây là code sau khi refactor: 123456function validateValue(value, regex, type) &#123; if (regex.exec(value)) console.log(&apos;Invalid &apos; + type); else console.log(&apos;Valid &apos; + type);&#125; Các tham số ssn và phone ở trong phần code cũ đã được thay thế bằng biến value. 2 biểu thức chính quy (regulare expression) /^\\d{3}-\\d{2}-\\d{4}$/ và /^\\(\\d{3}\\)\\d{3}-\\d{4}$/ được thay thế bằng biến regex. Và phần sau của message gồm SNS và Phone Number sẽ được thay thế bằng biến type. Việc chỉ có một hàm như thế này sẽ tốt hơn rất nhiều so với việc có 2, hoặc xấu hơn là 3, 4 hay 10 hàm. Việc này sẽ giúp code của bạn sạch sẽ và dễ bảo trì hơn. Ví dụ, nếu có lỗi xảy ra, bạn sẽ chỉ phải fix ở một chỗ thay vì tìm kiếm trong tất cả source code để tìm các chỗ mà hàm này CÓ THỂ đã được copy/paste và thay đổi. Tiếp theo chúng ta cùng xem xét trường hợp phức tạp hơn một chút : 123456789101112function validateAddress(address) &#123; if (parseAddress(address)) console.log(&apos;Valid Address&apos;); else console.log(&apos;Invalid Address&apos;);&#125;function validateName(name) &#123; if (parseFullName(name)) console.log(&apos;Valid Name&apos;); else console.log(&apos;Invalid Name&apos;);&#125; Ở đây parseAddress và parseFullName là 2 hàm đều nhận vào một chuỗi và trả về true nếu parse thành công. Bạn sẽ refactor code trong trường hợp này như thế nào đây? Giống như trường hợp trước đó, ta có thể sử dụng biến value cho address và name, type cho Address và Name giống như đã làm trước đó, nhưng ở vị trí của biểu thức chính quy lúc trước giờ lại là 2 hàm khác nhau. Nếu như chúng ta có thể đưa hàm vào tham số thì … Concept 3: Higher-Order Functions(Chú thích của người dịch: High-order Function mình đã tìm hiểu nhưng khó có từ tiếng Việt tương đương, bạn có thể hiểu Higher-Order Functions có nghĩa là Hàm có cấp bậc cao hơn - với ý nghĩa là hàm có nhiều khả năng và linh hoạt hơn so với các ngôn ngữ Imperative Programming thông thường như Java, C, C++) Rất nhiều ngôn ngữ lập trình không hỗ trợ việc đưa hàm vào thành tham số. Một số ngôn ngữ thì có thể nhưng cách thực hiện thì không hề dễ dàng chút nào. Trong Functional Programming, một hàm sẽ được coi như là một công dân hạng nhất trong ngôn ngữ đó. Hay nói cách khác, hàm sẽ giống như các loại giá trị (số, text, object,…) khác. Bởi vì hàm sẽ được coi như các loại giá trị khác, nên hàm có thể được truyền dưới dạng tham số. Mặc dù không phải là ngôn ngữ hỗ trợ FP chính thống, nhưng một vài concept trong FP có thể được thực hiện bởi Javascript. Và đây là cách thu gọn hai hàm ở trên thành một bằng việc đưa hàm thực hiện việc parse dữ liệu thành tham số của hàm mới có tên là parseFunc: 123456function validateValueWithFunc(value, parseFunc, type) &#123; if (parseFunc(value)) console.log(&apos;Invalid &apos; + type); else console.log(&apos;Valid &apos; + type);&#125; Và hàm mới của chúng ta được gọi là Higher-order Function. Higher-order Functions là các hàm hoặc nhận hàm làm tham số, hoặc trả về hàm, hoặc vừa nhận hàm làm tham số vừa trả về hàm. Và giờ chúng ta có thể viết lại cả 4 hàm trên bằng cách sử dụng hàm validateValueWithFunc như sau ( lưu ý rằng hàm Regex.exec sẽ trả về true nếu chuỗi ký tự match với biểu thức chính quy ): 1234validateValueWithFunc(&apos;123-45-6789&apos;, /^\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;$/.exec, &apos;SSN&apos;);validateValueWithFunc(&apos;(123)456-7890&apos;, /^\\(\\d&#123;3&#125;\\)\\d&#123;3&#125;-\\d&#123;4&#125;$/.exec, &apos;Phone&apos;);validateValueWithFunc(&apos;123 Main St.&apos;, parseAddress, &apos;Address&apos;);validateValueWithFunc(&apos;Joe Mama&apos;, parseName, &apos;Name&apos;); Code được viết lại như trên nhìn ngon hơn hẳn so với việc có 4 hàm từa tựa nhau nhỉ? :D Để ý kĩ hơn một chút, 2 hàm sử dụng biểu thức chính quy nhìn có vẻ khá là rườm rà, nhất là khi sau này biểu thức chính quy có thể trở nên dài và phức tạp hơn. Chúng ta có thể làm cho nó gọn hơn bằng cách đưa phần gọi biểu thức chính quy ra ngoài như sau : 1234567var parseSsn = /^\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;$/.exec;var parsePhone = /^\\(\\d&#123;3&#125;\\)\\d&#123;3&#125;-\\d&#123;4&#125;$/.exec;validateValueWithFunc(&apos;123-45-6789&apos;, parseSsn, &apos;SSN&apos;);validateValueWithFunc(&apos;(123)456-7890&apos;, parsePhone, &apos;Phone&apos;);validateValueWithFunc(&apos;123 Main St.&apos;, parseAddress, &apos;Address&apos;);validateValueWithFunc(&apos;Joe Mama&apos;, parseName, &apos;Name&apos;); Mọi thứ tốt hơn rồi nhỉ. Sau này nếu muốn kiểm tra một số điện thoại khác, thay vì phải copy lại biểu thức chính quy, ta có thể sử dụng hàm parsePhone và validateValueWithFunc. Tuy nhiên, hãy thử tưởng tượng nếu chúng ta có nhiều biểu thức chính quy cần thực hiện, ngoài 2 hàm parseSsn và parsePhone thì sẽ ra sao nhỉ? Để ý rằng mỗi khi gọi hàm xử lý biểu thức chính quy, ta đều phải gọi thêm .exec vào cuối, và nếu số lượng biểu thức chính quy tăng lên thì sẽ khá là phiền phức, và tin tôi đi, sẽ có lúc bạn sẽ quên mất không thêm .exec vào đó. Để tránh mắc phải lỗi này, chúng ta có thể tạo ra một hàm dạng high-order function được dùng để trả về hàm exec từ biểu thức chính quy truyền vào như sau : 123456789function makeRegexParser(regex) &#123; return regex.exec;&#125;var parseSsn = makeRegexParser(/^\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;$/);var parsePhone = makeRegexParser(/^\\(\\d&#123;3&#125;\\)\\d&#123;3&#125;-\\d&#123;4&#125;$/);validateValueWithFunc(&apos;123-45-6789&apos;, parseSsn, &apos;SSN&apos;);validateValueWithFunc(&apos;(123)456-7890&apos;, parsePhone, &apos;Phone&apos;);validateValueWithFunc(&apos;123 Main St.&apos;, parseAddress, &apos;Address&apos;);validateValueWithFunc(&apos;Joe Mama&apos;, parseName, &apos;Name&apos;); Ở đây, hàm makeRegexParser nhận tham số là một biểu thức chính quy, và trả về hàm exec của biểu thức chính quy đó, với tham số là một chuỗi string. Lúc này, hàm validateValueWithFunc sẽ nhận chuỗi string từ biến value, sau đó truyền sang hàm parseSsn hoặc parsePhone, đối ví dụ trên thực chất sẽ là hàm exec được trả về từ hàm parseSsn hoặc parsePhone. Như các bạn đã thấy, đây tuy chỉ là một quá trình tái cấu trúc code nho nhỏ, nhưng nó đã thể hiện khả năng và sự tiện lợi của High-order function khi hỗ trợ việc trả về hàm. Lợi ích của việc thay đổi này sẽ thể hiện một cách rõ ràng hơn khi hàm makeRegexParser trở nên phức tạp hơn. Dưới đây là một ví dụ khác về một High-order function có kết quả trả về là một hàm : 12345function makeAdder(constantValue) &#123; return function adder(value) &#123; return constantValue + value; &#125;;&#125; Chúng ta có một hàm makeAdder nhận vào tham số là constantValue (giá trị cố định), và trả về một hàm tên là adder, với khả năng cộng thêm giá trị constantValue vào tham số truyền vào. Đây là cách hàm adder có thể sử dụng : 1234var add10 = makeAdder(10);console.log(add10(20)); // prints 30console.log(add10(30)); // prints 40console.log(add10(40)); // prints 50 Chúng ta đã tạo ra một hàm có tên là add10 bằng việc truyền giá trị 10 vào hàm makeAdder, mà hàm add10 sẽ hoạt động đúng như tên của nó, cộng thêm 10 vào bất kỳ biến nào truyueenf vào. Để ý rằng hàm adder có thể truy cập đến biến constantValue ngay cả khi hàm makeAddr đã hoàn thành. Lý do là bởi vì biến constantValue đã ở trong cùng một scope (phạm vi) khi hàm adder được tạo. Khả năng này rất quan trọng bởi vì nếu thiếu nó, việc hàm trả về hàm sẽ không còn nhiều lợi ích nữa. Vì thế việc hiểu cách hoạt động và tên gọi của khả năng này cũng là điều mà chúng ta cần tìm hiểu, và nó có tên là Closure. Concept 4: Closures - Bao đóng Dưới đây là một ví dụ giả tưởng nhằm minh họa việc hàm sử dụng closures: 12345678910function grandParent(g1, g2) &#123; var g3 = 3; return function parent(p1, p2) &#123; var p3 = 33; return function child(c1, c2) &#123; var c3 = 333; return g1 + g2 + g3 + p1 + p2 + p3 + c1 + c2 + c3; &#125;; &#125;;&#125; Trong ví dụ này, hàm child có thể truy cập các biến của chính nó, các biến của hàm parent và cả các biến của hàm grandParent nữa.(đủ g1, g2, g3, p1, p2, p3, c1, c2, c3) Hàm parent có thể truy cập các biến của chính nó và của hàm grandParent. (bao gồm g1, g2, g3, p1, p2, p3) Hàm grandParent chỉ có thể truy cập các biến của chính nó. (bao gồm g1, g2, g3). (Mọi người có thể tham khảo hình vẽ kim tự tháp phía bên trên để hiểu rõ hơn). Sau đây là 1 ví dụ sử dụng hàm 3 đời ở trên : 1234var parentFunc = grandParent(1, 2); // returns parent() - trả về hàm parent() với g1 = 1, g2 = 2, g3 = 3var childFunc = parentFunc(11, 22); // returns child() - trả về hàm child() với g1 = 1, g2 = 2, g3 = 3, p1 = 11, p2 = 22, p3 = 33console.log(childFunc(111, 222)); // prints 738 - in ra 738 vì :// 1 + 2 + 3 + 11 + 22 + 33 + 111 + 222 + 333 == 738 Ở đây, biến parentFunc sẽ giữ cho scope của hàm parent tồn tại sau khi thực hiện hàm grandParent, lúc này hàm parent sẽ trả về và tham chiếu thông qua biến parentFunc (scope của parent ở đây sẽ bao gồm các giá trị được hàm parent tham chiếu đến, tức là sẽ lưu giữ các giá trị g1, g2, g3, p1, p2, p3). Tương tự như vậy, biến childFunc sẽ giữ scope của hàm child tồn tại sau khi thực hiện gọi hàm parent thông qua biến parentFunc, lúc này hàm child được trả về và tồn tại vì có biến childFunc tham chiếu đến. Mỗi khi một hàm được tạo ra, tất cả các giá trị nằm trong scope của nó ở thời điểm hàm được tạo sẽ được lưu trữ và có thể truy cập trong suốt vòng đời của hàm đó. Và hàm sẽ còn tồn tại chừng nào còn có tham chiếu (reference) đến nó. Ví dụ, scope của hàm child sẽ còn tồn tại cho đến khi nào biến childFunc vẫn tham chiếu đến nó. Một closure (bao đóng) là một scope của một hàm mà sẽ tồn tại chừng nào còn có tham chiếu đến hàm đó. Lưu ý rằng, trong Javascript, closures sẽ gây ra nhiều rắc rối bởi vì các biến có thể thay đổi (mutable), và vì thế các biến đó có thể bị/được thay đổi giá trị từ lúc chúng được đóng lại cho đến lúc hàm trả về được gọi. (Ở đây đóng lại ý nói lúc dùng High-order function để trả về một hàm, lúc này các biến trong scope của hàm đó vẫn có thể truy cập và thay đổi giá trị, do đó đến lúc thực thi hàm này, các biến này giá trị có thể khác so với lúc được trả về, gây ra các kết quả không mong muốn) Thật may mắn là các biến trong FP sẽ là bất biến (immutable - đã nói đến ở phần 1), nên các lỗi có thể xảy ra do Closure như trong JS sẽ không gặp phải nữa. Đầu của tôi!!!! Hôm nay đến đây thôi là đủ. Trong các phần sau của bài viết này, tôi sẽ nói về các vấn đề như là Functional Composition, Currying, các functional functions cơ bản (như là map, filter, fold,… ), và một vài thứ nữa Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: Learn Elm Programming Và đây là Twitter của tác giả : @cscalfani","categories":[],"tags":[]},{"title":"Trở thành Functional Programmer - Phần 1","slug":"Tro-thanh-Functional-Programmer-Phan-1","date":"2017-08-23T16:19:26.000Z","updated":"2017-08-24T00:52:40.637Z","comments":true,"path":"2017/08/Tro-thanh-Functional-Programmer-Phan-1.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Tro-thanh-Functional-Programmer-Phan-1.html","excerpt":"Việc sáng tỏ, ngộ ra concept của Functional Programming thường là một trong những bước phát triển quan trọng nhất trong sự nghiệp lập trình của bạn, và đôi khi cũng là bước khó khăn nhất. Tuy nhiên chúng ta có thể vượt qua nó một cách dễ dàng với cách tiếp cận đúng đắn. Bài viết sau đây sẽ hướng dẫn mọi người đến được với vùng chân lý đó.","text":"Việc sáng tỏ, ngộ ra concept của Functional Programming thường là một trong những bước phát triển quan trọng nhất trong sự nghiệp lập trình của bạn, và đôi khi cũng là bước khó khăn nhất. Tuy nhiên chúng ta có thể vượt qua nó một cách dễ dàng với cách tiếp cận đúng đắn. Bài viết sau đây sẽ hướng dẫn mọi người đến được với vùng chân lý đó. Bắt đầu từ việc học lái xe Lần đầu lái xe thường là những kỉ niệm đau thương và khốn khổ nhất của chúng ta. Sẽ thật dễ dàng khi nhìn người khác lái, nhưng khi thực sự đặt tay vào vô-lăng, mọi thứ bỗng trở nên khó khăn hơn chúng ta tưởng. Và chúng ta sẽ phải tập luyện bằng xe của gia đình cho đến khi có thể làm chủ những đoạn đường xung quanh nhà trước khi thoát xác lên cung đường cao tốc. Nhưng cuối cùng thì thông qua quá trình luyện tập lặp đi lặp lại và một số khoảng thời gian khiến gia đình thót tim, cuối cùng bạn cũng sẽ học được cách lái xe và có bằng lái cho riêng mình. Với tấm bằng lái trong tay, chúng ta có thể lái bất cứ cái xe nào nếu có thể nổ máy. Và với mỗi chuyến đi, sự tự tin, làm chủ tay lái sẽ ngày càng được củng cố. Và cũng sẽ đến cái ngày chúng ta phải lái xe cuả người khác, hay là phải thay chiếc xe cà tàng bằng một chiếc mới hiện đại hơn. Cảm xúc khi lái một chiếc xe khác sẽ như thế nào nhỉ? Liệu có giống với cảm xúc khi lần đầu chạm tay vào vô lăng? Không hẳn. Lần đầu tiên lái xe, chúng ta hoàn toàn bỡ ngỡ. Mặc dù trước đó đã ngồi trên xe nhưng chúng ta chỉ có vai trò là hành khách. Còn lầu đầu tiên lái xe là khi có qtoàn quyền điều khiển chiếc xe đó. Còn với lần lái chiếc xe thứ hai trở đi, chúng ta chỉ tìm kiếm câu trả lời cho những câu hỏi đơn giản : Chìa khóa ở đâu nhỉ? Đèn ở đâu nhỉ? Chỉnh gương với đèn chiếu ở đâu ta? Sau những thắc mắc đó, mọi thứ diễn ra thật tự nhiên như nước chảy mây trôi, việc lái xe thật dễ dàng hơn không biết bao nhiêu lần so với lần đầu cầm lái. Nguyên do cho sự việc trên là chiếc xe mới sẽ vận hành giống gần hết chiếc xe cũ. Cả 2 chiếc xe đều có những thứ cơ bản cho việc lái xe, và các thứ đó hầu hết đều ở cùng một vị trí Một vài thứ nho nhỏ sẽ được thay đổi, hoặc thêm chí có thêm vài tính năng mới, nhưng chúng ta hầu hết sẽ không dùng chúng vào lần đầu tiên, thậm chí lần thứ 2. Dần dần sau cùng chúng ta mới học sử dụng các tính năng mới, mà chỉ là các tính năng mà chúng ta quan tâm thôi. Việc học lập trình cũng tương tự như học lái xe vậy. Lần đầu tiên bao giờ cũng là lần khó khăn nhất. Nhưng khi bạn đã quen rồi, thì những lần sau sẽ trở nên dễ dàng hơn rất nhiều. Mỗi khi bạn bắt đầu việc học một ngôn ngữ mới, sẽ có một số câu hỏi bạn sẽ thường tự hỏi mình như là : Làm thế nào để tạo một module? Làm thế nào để tìm kiếm trong 1 mảng? Tham số cho hàm thay thế chuỗi là gì? Bạn hoàn toàn tự tin rằng mình sẽ sử đụng được ngôn ngữ mới này, bởi vì nó gợi nhớ lại cho bạn những kỉ niệm, hiểu biết với ngôn ngữ cũ, cùng với một vài điều mới mẻ với hy vọng rằng làm cho cuộc đời của bạn trở nên đẹp đẽ hơn. Đến con tàu vũ trụ đầu tiên Giờ hãy thử tưởng tượng rằng bạn đã lái hàng tá xe ô tô trong cuộc đời, rồi đến một ngày bạn được đặt vào khoang điều khiển của một chiếc Tàu không gian. Lúc này bạn bỗng trở nên hoang mang, không biết rằng liệu những kinh nghiệm lái xe có giúp ích được gì cho mình không. Bạn cảm giác như mình đang bắt đầu lại từ con số 0 tròn trĩnh. (Chúng ta là lập trình viên, chúng ta đếm từ số 0) Bạn có thể bắt đầu việc luyện tập với cảm giác rằng mọi thứ sẽ trở nên rất khác ở trong không gian, và cách vận hành con tàu khác hoàn toàn này sẽ rất khác so với việc lái xe trên mặt đất. Tuy nhiên thì các định luật vật lý đều không thay đổi. Chỉ khác ở chỗ cách bạn di chuyển trong cùng một vũ trụ mà thôi. Và với việc học Functional Programming (lập trình hàm) cũng tương tự như vậy. Bạn dự đoán, cảm giác rằng mọi thứ sẽ rất khác. Khác đến nỗi mà khiến cho những kinh nghiệm, kiến thức đã từng có được sẽ bị xóa sổ, không quay lại được như xưa nữa. Và mọi thứ sẽ được mở đầu bằng câu nói kinh điển dưới đây. Quên tất cả những thứ đã biếtMọi người rất thích câu nói sau đây, và nó cũng khá đúng trong hầu hết các trường hợp: Học lập trình hàm (FP) cũng giống như bắt đầu lại mọi thứ vậy. Không hoàn toàn là như vậy, nhưng đó là một suy nghĩ khá hiệu quả khi tiếp xúc với FP. Có rất nhiều concepts giống nhau giữa lập trình mà bạn đã biết và FP, nhưng việc tiếp cận FP với tư tưởng rằng mình sẽ phải học lại tất cả mọi thứ thường tỏ ra hiệu quả nhất. Với cách tiếp cận chính xác, bạn sẽ có những tư tưởng, suy nghĩ đúng đắn, là những thứ sẽ giúp bạn không bỏ cuộc khi việc học hành trở nên khó khăn. Bạn sẽ phải xác định rằng có rất nhiều thứ mà bạn đã từng học và làm quen trên con đường làm lâp trình viên từ trước đến giờ, khi đến với FP, sẽ biến mất hoặc không thể sử dụng được nữa. Liên hệ với việc lái xe, bạn có thể quen với việc dùng số lùi để đậu xe. Tuy nhiên một con tùa không gian sẽ không có số lùi. Có thể bạn sẽ nghĩ rằng : CÁI GÌ CƠ? KHÔNG CÓ SỐ LÙi!?! TÔI LÁI TÀU THẾ QUÁI NÀO KHI KHÔNG CÓ SỐ LÙI BÂY GIỜ?! Thực tế là tàu không gian có thể di chuyển trong không gian 3 chiều (ô tô là 2 chiều), nên sẽ không cần số lùi. Khi bạn nắm rõ cách hoạt động của tàu không gian, bạn sẽ không cần phải sử dụng số lùi thêm một lần nào nữa. Và rồi bạn sẽ thấy rằng mấy cái xe thật là cùi =)) Với FP cũng vậy, tuy nhiên: Học FP sẽ mất thời gian. Vì thế hãy kiên nhẫn Và giờ chúng ta cùng đến với miền đất hứa của Functional Programming, bỏ qua vùng đất lạnh lẽo, nhàm chán của Imperative Programming đã quá quen thuộc. Những gì dược viêt tiếp theo đây là một series bài viết giới thiệu các Concepts của FP với mục đích giúp người đọc làm quen trước khi đi vào bất kì ngôn ngữ lập trình FP nào. Hoặc nếu bạn đã sử dụng FP rồi, thì đây sẽ là bài viết giúp bạn hiểu rõ hơn những việc mình đang làm . Và mong các bạn không vội vàng. Hãy dành thời gian đọc những gì tôi sắp viết sau đây, cũng như dành thời gian để hiểu những đoạn code ví dụ. Bạn có thể tạm dừng sau mỗi đoạn để kiến thức ngấm hoàn toàn vào người, sau đó hãy quay lại và tiếp tục. Điều quan trọng nhất là kiến thức của bạn. Concept 1: Purity - Sự thuần khiết Khi những lập trình viên FP nói về Purity, đó là khi họ muốn đề cập đến Pure Function . Pure Function là những hàm hết sức đơn giản, chỉ thao tác dựa trên tham số đầu vào. Đây là một ví dụ về một hàm được gọi là Pure trong Javascript : 1234var z = 10;function add(x, y) &#123; return x + y;&#125; Bạn có thể nhận thấy rằng hàm add không hề đụng vào biến z. Hàm đó không đọc giá trị của biến z, cũng như không thay đổi giá trị biến z. Nó chỉ đơn giản là đọc 2 tham số x và y, là 2 tham số đầu vào, rồi trả về giá trị là tổng của 2 tham số đó. Hàm add, vì lý do đó, được gọi là Pure Function. Nếu hàm add có bất kỳ xử lý nào liên quan đến biến z, hàm đó sẽ không còn là pure nữa. Chúng ta cùng tham khảo một hàm khác: 123function justTen() &#123; return 10;&#125; Nếu hàm justTen là pure, thì nó chỉ có thể trả về một giá trị duy nhất, cố định. Nguyên nhân là vì hàm này không có bất kì một tham số nào. Và để đảm bảo nó là pure function, hàm này sẽ không thể truy cập bất kì giá trị nào ngoài các tham số của nó. Ở đây không có tham số nào, nên giá trị trả về của hàm này lúc nào cũng là một giá trị cố định. Và pure function mà không có tham số nào để thực hiện thì có vẻ hơi vô nghĩa, và chúng ta nên thay thế hàm justTen bằng một hằng số (constant) thì tốt hơn. Hầu hết các Pure Function đều có ít nhất một tham số. Tiếp theo chúng ta đến với một hàm khác: 123function addNoReturn(x, y) &#123; var z = x + y&#125; Dễ dàng nhận thấy rằng hàm addNoReturn không có giá trị trả về. Hàm này chỉ đơn giản là xử lý việc cộng 2 tham số x và y rồi lưu vào biến z, nhưng không trả về giá trị tông.Đây mặc dù vẫn là một pure function khi nó chỉ xử lý các tham số của chính mình. Nó thực hiện việc cộng 2 input, nhưng vì không trả về bất cứ giá trị gì, nên nó vô dụng (vì chúng ta không có cách nào lấy được giá trị đã được xử lý). Một Pure Function chỉ có giá trị sử dụng khi có giá trị trả về. Và giờ chúng ta quay lại hàm add lúc đầu một lần nữa : 123456function add(x, y) &#123; return x + y;&#125;console.log(add(1, 2)); // prints 3console.log(add(1, 2)); // still prints 3console.log(add(1, 2)); // WILL ALWAYS print 3 Có thể thấy rằng việc thực hiện add(1,2) luôn trả về giá trị 3. Không phải là một điều gì quá ngạc nhiên, nhưng điều này chỉ có thể thực hiện nếu hàm đó là pure function. Nếu hàm add sử dụng bất kì một biến nào ở bên ngoài, thì bạn sẽ không bao giờ dự đoán được kết quả trả về Pure Function sẽ luôn trả về cùng output với cùng input, bất kể có thực hiện bao nhiêu lần. Vì pure function sẽ không tác động đến các biến nằm ngoài chúng, nên các hàm sau sẽ được coi là impure (không thuần khiết =)) ): 1234writeFile(fileName);updateDatabaseTable(sqlCmd);sendAjaxRequest(ajaxRequest);openSocket(ipAddress); Tất cả các hàm này đều có một đặc tính chung được gọi là Side Effects (tác dụng phụ). Khi bạn gọi và thực thi chúng, các hàm này sẽ thay đổi file, cập nhật cơ sử dữ liệu, gửi data về phía server hoặc gọi hệ điều hành để lấy socket. Chúng làm nhiều thứ hơn là chỉ thao tác với tham số đầu vào và trả về output. Vì thế, bạn có thể không bao giờ dự đoán được giá trị mà những hàm này sẽ trả về. Pure Function đảm bảo việc hàm sẽ không có Side Effects. Trong các ngôn ngữ Imperative Language như là Javascript, Java, hay C#, Side Effects xuất hiện ở khắp mọi nơi. Điều này khiến cho việc debug rất khó vì biến có thể được thay đổi ở bất kỳ đâu trong chương trình. Vì thế khi có một lỗi xảy ra do một biến thay đổi thành giá trị không muốn muốn, bạn sẽ phải tìm ở đâu? Khắp mọi ngóc ngách? Điều đó thật không tốt chút nào. Đến đây, có thể bạn sẽ thắc mắc rằng: VẬY LÀM THẾ QUÁI NÀO MÀ TÔI CÓ THỂ LÀM VIỆC CHỈ VỚI PURE FUNCTION CHỨ?! Trong FP, Pure Function không phải là thứ duy nhất mà bạn sẽ vieests. FP không thể loại trừ hoàn toàn Side Effects, mà chỉ có thể cô lập chúng. Vì các phần mềm phải giao tiếp, thao tác với thế giới thực, nên một số thành phần bắt buộc phải impure. Mục tiêu của FP là tối thiểu hóa hết mức có thể số lượng impure code và tách biệt chúng hoàn toàn khỏi các phần khác của chương trình. Concept 2 - Immutability : Sự bất biến Bạn còn nhớ lần đầu nhìn thấy dòng code kiểu như này chứ : 12var x = 1;x = x + 1; Khi đó, hẳn là người nào đó dạy bạn lâp trình đã nói rằng : Hãy quên những gì đã học ở môn Toán đi? Vì trong toán học, x không bao giờ bằng x+1 được cả Nhưng trong các ngỗn ngữ Imperative Programming, các câu lệnh trên có nghĩa là, lấy giá trị hiện tại của biến x, cộng nó thêm 1 và gán kết quả trả về vào lại biến x. Tuy nhiên sang đến FP, x = x + 1 lại trở thành không đúng, không được phép. Và bạn sẽ phải nhớ lại những gì mà bạn đã bị bắt phải quên trước đó về toán học. Hmm… Trong Functional Programming không có khái niệm về biến (variable) Để lưu trữ các giá trị, khái niệm biến (variable) vẫn được sử dụng, nhưng các biến này đều là hằng số (constant), tức là nếu biến x đã lưu một giá trị nào đó (là 1 chẳng hạn), thì giá trị của biến x sẽ không thay đổi, vẫn giữ nguyên là 1 như ban đầu được set (và chúng ta gọi là biến hằng số - constant variable) Nếu bạn đang lo lắng về bộ nhớ, thì bạn có thể an tâm khi trong FP, x thường chỉ là biến cục nên thời gian tồn tại thường rất ngắn. Tuy nhiên trong suốt thời gian tồn tại, giá chị của x là bất biến. Đây là một ví dụ về biến hằng số trong Elm, một ngôn ngữ thuần FP cho lập trình Web: 12345addOneToSum y z = let x = 1 in x + y + z Nếu bạn không quen với syntax dạng ML-Style , hãy để tôi giải thích. Hàm addOneToSum nhận 2 tham số là y và z. Trong block của let, biến x được gán với giá trị 1, tức là x sẽ giữ giá trị đó trong suốt phần đời của nó. Vòng đời của x sẽ kết thúc khi hàm kết thúc chạy, cụ thể hơn là sau khi block let được thực hiện. Bên trong block in, các dòng lệnh có thể chứa và tham chiếu đến các giá trị được định nghĩa trông phần block let, ở đây là x. Kết quả của việc tính toán x + y + z được xử lý và trả về, cụ thể hơn ở đây là 1 + y + z sẽ được tính toán trả về, vì x = 1. Và bạn có thể thấy bối rối mà thắc mắc rằng : TÔI LÀM TRÌNH KIỂU MÉO GÌ KHI MÀ KHÔNG CÓ BIẾN SỐ ĐÂY?! Hãy bình tĩnh và nghĩ đến thời điểm mà bạn muốn thay đổi giá trị của biến số. Sẽ có 2 trường hợp cơ bản nhảy ra trong đầu bạn : Thay đổi biến số chứa nhiều giá trị (vd như thay đổi một/nhiều thuộc tính của một đối tượng hoặc bản ghi) và thay đổi biến số chứa một giá trị (vd như bộ đếm trong vòng lặp). FP xử lý việc thay đổi các giá trị trong một bản ghi bằng cách tạo ra một bản sao của bản ghi với dữ liệu được cập nhật. FP xử lý trường hợp thay đổi giá trị này bằng cách: không copy lại tất cả các thành phần của bản ghi, mà sử dụng các cấu trúc dữ liệu để thực hiện việc này một cách hiệu quả nhất. Về việc xử lý trường hợp thay đổi biến số chứa một giá trị, FP cũng làm tương tự như trên, cũng bằng cách tạo ra một bản sao của biến số đó. Và sẽ KHÔNG có vòng lặp trong FP đâu. ĐẦU TIÊN THÌ KHÔNG CÓ BIẾN, VÀ GIỜ THÌ KHÔNG CÓ VÒNG LẶP?! GHÉT RỒI ĐẤY Bình tình nào. Không phải là chúng ta không thể tạo ra các vòng lặp trong FP (tôi không chơi chữ đâu nhé), mà chỉ đơn giản là chúng ta sẽ không có các cấu trúc lặp như là for, while, do, repeat, … thôi. Functional Programming sử dụng đệ quy cho việc lặp. Dưới đây là 2 cách thực hiện vòng lặp trong Javascript: 123456789101112// simple loop constructvar acc = 0;for (var i = 1; i &lt;= 10; ++i) acc += i;console.log(acc); // prints 55// without loop construct or variables (recursion)function sumRange(start, end, acc) &#123; if (start &gt; end) return acc; return sumRange(start + 1, end, acc + start)&#125;console.log(sumRange(1, 10, 0)); // prints 55 Bạn có thể thấy rằng, bằng việc sử dụng đệ quy, chúng ta có thể thực hiện được đúng như những gì mà vòng lặp for phía trên đã thực hiện. Với việc sử dụng hàm sumRange gọi lại chính nó sau mỗi lần chạy với tham số start mới (start + 1) và tham số acc mới (acc + start). Hàm này không hề thay đổi các giá trị mới. Thay vào đó nó sử dụng các giá trị mới được tính toán từ các giá trị cũ. Thật không may, việc này khá là khó để có thể nhìn thấy rõ ràng trong Javascript, kể cả bạn đã bỏ ra chút thời gian để nghiên cứu về nó, bởi 2 lý do sau đây. Thứ nhất là do syntax trong Javascript khá là khó nhìn và thứ hai, là bạn có thể không quen với tư duy suy nghĩ theo đệ quy. Nếu sử dụng Elm, việc đọc sẽ trở nên dễ dàng hơn, và do đó, dễ hiểu hơn đối với bạn: 12345sumRange start end acc = if start &gt; end then acc else sumRange (start + 1) end (acc + start) Đây là kết quả đoạn code trên thực hiện: 123456789101112sumRange 1 10 0 = -- sumRange (1 + 1) 10 (0 + 1)sumRange 2 10 1 = -- sumRange (2 + 1) 10 (1 + 2)sumRange 3 10 3 = -- sumRange (3 + 1) 10 (3 + 3)sumRange 4 10 6 = -- sumRange (4 + 1) 10 (6 + 4)sumRange 5 10 10 = -- sumRange (5 + 1) 10 (10 + 5)sumRange 6 10 15 = -- sumRange (6 + 1) 10 (15 + 6)sumRange 7 10 21 = -- sumRange (7 + 1) 10 (21 + 7)sumRange 8 10 28 = -- sumRange (8 + 1) 10 (28 + 8)sumRange 9 10 36 = -- sumRange (9 + 1) 10 (36 + 9)sumRange 10 10 45 = -- sumRange (10 + 1) 10 (45 + 10)sumRange 11 10 55 = -- 11 &gt; 10 =&gt; 5555 Bạn có thể cho rằng vòng lặp for sẽ dễ hiểu hơn. Trong khi vấn đề này vẫn đang được tranh cãi khá là nhiều, mà có thể nguyên nhân chủ yếu là do sự quen thuộc, thì có một sự thật là các vòng lặp for cần đến khả năng biến đổi của hàm số, mà điều này được cho là không tốt trong FP. Tôi sẽ không giải thích chi tiết những lợi ít của tính bất biến trong bài viết này, nhưng bạn có thể xem phần Global Mutate State trong bài viết Vì sao Lập trình viên cần có giới hạn để biết thêm chi tiết. Một lợi ích rõ ràng của tính bất biến, đó là nếu bạn phải truy cập đến một giá trị bất kỳ trong chương trình của bạn, bạn chỉ có thể có quyền đọc nó, và điều đó tương đương với việc không ai có thể thay đổi giá trị của nó. Kể cả chính bạn. Và do đó sẽ tránh được những thay đổi không mong muốn. Và nếu chương trình của bạn hỗ trợ đa luồng (multi-threaded), thì sẽ không có bất kỳ một thread nào có thể khiến bạn đau đầu. Giá trị được set sẽ là hằng số, và nếu bất kì một thread nào muốn thay đổi nó, thread đó sẽ phải tạo một giá trị mới từ cái cũ. Quay trở lại những năm 90, tôi đã từng viết một Game Engine cho trò chơi Creature Crunch , và nguyên nhân gây ra nhiều bug nhất chính là các vấn đề liên quan đến xử lý đa luồng. Tôi ước gì mình đã biết về Tính bất biến lúc đó. Mà thực ra điều tôi quan tâm nhất khi ấy là sự khác nhau giữa tốc độ đọc 2x và 4x của ổ đĩa CD-ROM sẽ ảnh hưởng thế nào đến hiệu năng chạy game. Tính bất biến tạo ra các dòng code đơn giản hơn và an toàn hơn Đầu của tôi!!!!Tạm thời đến đây thôi là đủ. Trong các phần sau của bài viết này, tôi sẽ nói về các vấn đề như là High-order Function, Functional Composition, Curring, v..v… Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: Learn Elm Programming Và đây là Twitter của tác giả : @cscalfani","categories":[],"tags":[]},{"title":"Giải thích về Value và Reference trong Javascript","slug":"Explaining-Value-vs-Reference-in-Javascript","date":"2017-08-21T12:32:28.000Z","updated":"2017-08-31T00:53:23.895Z","comments":true,"path":"2017/08/Explaining-Value-vs-Reference-in-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Explaining-Value-vs-Reference-in-Javascript.html","excerpt":"Dùng một cái nhìn đơn giản của bộ nhớ máy tính giải thích điều này Javascript có 5 kiểu dữ liệu được thông qua value: Boolean, null, undefined, String, và Number. Chúng ta sẽ gọi chung là primitive types. Javascript có 5 kiểu dữ liệu được thông qua reference: Array, Function, và Object. Về mặt kỹ thuật đó là Objects, vì vậy chúng ta sẽ đề cập đến chúng chung chung như Objects.","text":"Dùng một cái nhìn đơn giản của bộ nhớ máy tính giải thích điều này Javascript có 5 kiểu dữ liệu được thông qua value: Boolean, null, undefined, String, và Number. Chúng ta sẽ gọi chung là primitive types. Javascript có 5 kiểu dữ liệu được thông qua reference: Array, Function, và Object. Về mặt kỹ thuật đó là Objects, vì vậy chúng ta sẽ đề cập đến chúng chung chung như Objects. Primitives (Nguyên thủy)Nếu một kiểu nguyên thủy được gán cho một biến, chúng ta có thể nghĩ rằng biến đó chứa đựng giá trị nguyên thủy. 123var x = 10;var y = 'abc';var z = null; x chứa đựng 10. y chứa đựng &#39;abc&#39;. Để củng cố ý tưởng này, chúng tôi sẽ cung cấp một hình ảnh về những gì các biến này và các giá trị tương ứng giống như trong bộ nhớ. Khi chúng ta gán các biến này cho các biến khác sử dụng dấu =, Chúng ta copy giá trị cho biến mới. Chúng được sao chép theo giá trị. 12345var x = 10;var y = 'abc';var a = x;var b = y;console.log(x, y, a, b); // -&gt; 10, 'abc', 10, 'abc' Cả a và x bây giờ chứa 10. Cả b và y bây giờ chứa &#39;abc&#39;. Chúng là tách biệt, vì các giá trị được sao chép. Khi thay đổi một biến nó không thay đổi cái khác. Hãy suy nghĩ là các biến như không có mối quan hệ với nhau. 12345678var x = 10;var y = 'abc';var a = x;var b = y;a = 5;b = 'def';console.log(x, y, a, b); // -&gt; 10, 'abc', 5, 'def' ObjectsThis will feel confusing, but bear with me and read through it. Once you get through it, it’ll seem easy. Variables that are assigned a non-primitive value are given a reference to that value. That reference points to the object’s location in memory. The variables don’t actually contain the value. Objects are created at some location in your computer’s memory. When we write arr = [], we’ve created an array in memory. What the variable arr receives is the address, the location, of that array. Let’s pretend that address is a new data type that is passed by value, just like number or string. An address points to the location, in memory, of a value that is passed by reference. Just like a string is denoted by quotation marks (&#39;&#39; or &quot;&quot;), an address will be denoted by arrow brackets, &lt;&gt;. When we assign and use a reference-type variable, what we write and see is: 121) var arr = [];2) arr.push(1); A representation of lines 1 and 2 above in memory is: 1. 2. Notice that the value, the address, contained by the variable arr is static. The array in memory is what changes. When we use arr to do something, such as pushing a value, the Javascript engine goes to the location of arr in memory and works with the information stored there. Assigning by ReferenceWhen a reference type value, an object, is copied to another variable using =, the address of that value is what’s actually copied over as if it were a primitive. Objects are copied by reference instead of by value. 12var reference = [1];var refCopy = reference; The code above looks like this in memory. Each variable now contains a reference to the same array. That means that if we alter reference, refCopy will see those changes: 12reference.push(2);console.log(reference, refCopy); // -&gt; [1, 2], [1, 2] We’ve pushed 2 into the array in memory. When we use reference and refCopy, we’re pointing to that same array. Reassigning a ReferenceReassigning a reference variable replaces the old reference. 1var obj = &#123; first: 'reference' &#125;; In memory: When we have a second line: 12var obj = &#123; first: 'reference' &#125;;obj = &#123; second: 'ref2' &#125; The address stored in obj changes. The first object is still present in memory, and so is the next object: When there are no references to an object remaining, as we see for the address #234 above, the Javascript engine can perform garbage collection. This just means that the programmer has lost all references to the object and can’t use the object any more, so the engine can go ahead and safely delete it from memory. In this case, the object { first: &#39;reference&#39; } is no longer accessible and is available to the engine for garbage collection. == and ===When the equality operators, == and ===, are used on reference-type variables, they check the reference. If the variables contain a reference to the same item, the comparison will result in true. 12var arrRef = [’Hi!’];var arrRef2 = arrRef;console.log(arrRef === arrRef2); // -&gt; true If they’re distinct objects, even if they contain identical properties, the comparison will result in false. 12var arr1 = ['Hi!'];var arr2 = ['Hi!'];console.log(arr1 === arr2); // -&gt; false If we have two distinct objects and want to see if their properties are the same, the easiest way to do so is to turn them both into strings and then compare the strings. When the equality operators are comparing primitives, they simply check if the values are the same. 12var arr1str = JSON.stringify(arr1);var arr2str = JSON.stringify(arr2);console.log(arr1str === arr2str); // true Another option would be to recursively loop through the objects and make sure each of the properties are the same. Passing Parameters through FunctionsWhen we pass primitive values into a function, the function copies the values into its parameters. It’s effectively the same as using =. 1234567var hundred = 100;var two = 2;function multiply(x, y) &#123; // PAUSE return x * y;&#125;var twoHundred = multiply(hundred, two); In the example above, we give hundred the value 100. When we pass it into multiply, the variable x gets that value, 100. The value is copied over as if we used an = assignment. Again, the value of hundred is not affected. Here is a snapshot of what the memory looks like right at the PAUSE comment line in multiply. Pure FunctionsWe refer to functions that don’t affect anything in the outside scope as pure functions. As long as a function only takes primitive values as parameters and doesn’t use any variables in its surrounding scope, it is automatically pure, as it can’t affect anything in the outside scope. All variables created inside are garbage-collected as soon as the function returns. A function that takes in an Object, however, can mutate the state of its surrounding scope. If a function takes in an array reference and alters the array that it points to, perhaps by pushing to it, variables in the surrounding scope that reference that array see that change. After the function returns, the changes it makes persist in the outer scope. This can cause undesired side effects that can be difficult to track down. Many native array functions, including Array.map and Array.filter, are therefore written as pure functions. They take in an array reference and internally, they copy the array and work with the copy instead of the original. This makes it so the original is untouched, the outer scope is unaffected, and we’re returned a reference to a brand new array. Let’s go into an example of a pure vs. impure function. 123456789101112function changeAgeImpure(person) &#123; person.age = 25; return person;&#125;var alex = &#123; name: 'Alex', age: 30&#125;;var changedAlex = changeAgeImpure(alex);console.log(alex); // -&gt; &#123; name: 'Alex', age: 25 &#125;console.log(changedAlex); // -&gt; &#123; name: 'Alex', age: 25 &#125; This impure function takes in an object and changes the property age on that object to be 25. Because it acts on the reference it was given, it directly changes the object alex. Note that when it returns the person object, it is returning the exact same object that was passed in. alex and alexChanged contain the same reference. It’s redundant to return the person variable and to store the reference in a new variable. Let’s look at a pure function. 12345678910111213function changeAgePure(person) &#123; var newPersonObj = JSON.parse(JSON.stringify(person)); newPersonObj.age = 25; return newPersonObj;&#125;var alex = &#123; name: 'Alex', age: 30&#125;;var alexChanged = changeAgePure(alex);console.log(alex); // -&gt; &#123; name: 'Alex', age: 30 &#125;console.log(alexChanged); // -&gt; &#123; name: 'Alex', age: 25 &#125; In this function, we use JSON.stringify to transform the object we’re passed into a string, and then parse it back into an object with JSON.parse. By performing this transformation and storing the result in a new variable, we’ve created a new object. There are other ways to do the same thing such as looping through the original object and assigning each of its properties to a new object, but this way is simplest. The new object has the same properties as the original but it is a distinctly separate object in memory. When we change the age property on this new object, the original is unaffected. This function is now pure. It can’t affect any object outside its own scope, not even the object that was passed in. The new object needs to be returned and stored in a new variable or else it gets garbage collected once the function completes, as the object is no longer in scope. Test YourselfValue vs. reference is a concept often tested in coding interviews. Try to figure out for yourself what’s logged here. 1234567891011121314151617function changeAgeAndReference(person) &#123; person.age = 25; person = &#123; name: 'John', age: 50 &#125;; return person;&#125;var personObj1 = &#123; name: 'Alex', age: 30&#125;;var personObj2 = changeAgeAndReference(personObj1);console.log(personObj1); // -&gt; ?console.log(personObj2); // -&gt; ? The function first changes the property age on the original object it was passed in. It then reassigns the variable to a brand new object and returns that object. Here’s what the two objects are logged out. 12console.log(personObj1); // -&gt; &#123; name: 'Alex', age: 25 &#125;console.log(personObj2); // -&gt; &#123; name: 'John', age: 50 &#125; Remember that assignment through function parameters is essentially the same as assignment with =. The variable person in the function contains a reference to the personObj1 object, so initially it acts directly on that object. Once we reassign person to a new object, it stops affecting the original. This reassignment does not change the object that personObj1 points to in the outer scope. person has a new reference because it was reassigned but this reassignment doesn’t change personObj1. An equivalent piece of code to the above block would be: 123456789101112131415var personObj1 = &#123; name: 'Alex', age: 30&#125;;var person = personObj1;person.age = 25;person = &#123; name: 'john', age: 50&#125;;var personObj2 = person;console.log(personObj1); // -&gt; &#123; name: 'Alex', age: 25 &#125;console.log(personObj2); // -&gt; &#123; name: 'John', age: '50' &#125; The only difference is that when we use the function, person is no longer in scope once the function ends. Kết thúc. Bắt đầu viết code nào.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Thực hành tối ưu những ứng dụng React","slug":"Optimizing-React-Apps-in-Practice","date":"2017-08-21T12:21:55.000Z","updated":"2017-08-31T01:00:24.154Z","comments":true,"path":"2017/08/Optimizing-React-Apps-in-Practice.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Optimizing-React-Apps-in-Practice.html","excerpt":"React có thể chậm. Ý tôi là, bất kỳ ứng dụng React với kích thước trung bình có thể có vẻ chậm. Nhưng trước khi bạn bắt đầu tìm kiếm các phương án thay thế, bạn nên biết rằng bất kỳ ứng dụng Angular hay Ember cỡ trung bình nào cũng chậm. Tin vui là: Nếu bạn quan tâm đến hiệu suất, nó khá dễ dàng để làm bất kỳ ứng dụng React trở nên siêu nhanh ⚡.️ Đây là cách.","text":"React có thể chậm. Ý tôi là, bất kỳ ứng dụng React với kích thước trung bình có thể có vẻ chậm. Nhưng trước khi bạn bắt đầu tìm kiếm các phương án thay thế, bạn nên biết rằng bất kỳ ứng dụng Angular hay Ember cỡ trung bình nào cũng chậm. Tin vui là: Nếu bạn quan tâm đến hiệu suất, nó khá dễ dàng để làm bất kỳ ứng dụng React trở nên siêu nhanh ⚡.️ Đây là cách. Measuring React PerformanceWhat do I mean by “slow”? Let’s take an example: I’m working on an open-source project called admin-on-rest, which leverages material-ui and Redux to provide an admin GUI for any REST API. This application has a datagrid page, displaying a list of records in a table. When the user changes the sort order, or goes to the next page, or filters the result, the interface isn’t as responsive as I would expect. The following screencast shows the refresh slowed down five times: To see what’s happening, I append a ?react_perf to the URL. This enables Component Profiling since React 15.4. I wait for the initial datagrid to load. Then I open the Chrome Developer Tools on the Timeline tab, hit the “Record” button, and click on a table header to update the sort order. Once the data refreshes, I hit the “Record” button again to stop recording, and Chrome displays a yellow flamegraph with a “User Timing” label. If you’ve never seen a flamegraph, it can look intimidating, but it’s actually very easy to use. This “User Timing” graph shows the time passed in each of your components. It hides the time spend inside React internals (you can’t optimize this time anyway), so it lets you focus on optimizing your app. The Timeline displays screenshots of the window at various stages, this lets me zoom in to the moment I clicked on the table header: It seems that my app rerenders the &lt;List&gt; component just after clicking on the sort button, before even fetching the REST data. And this takes more than 500ms. The app just updates the sort icon in the table header, and displays a grey overlay on the datagrid to show that the data is being fetched. To put it otherwise, the app takes half a second to provide visual feedback to a click. Half a second is definitely perceivable — UI experts say that users perceive an interface change as instantaneous when it’s below 100ms. A change slower than that is what I mean by “slow”. Why Did You Update?In the flamegraph above, you can see many tiny pits. That’s not a good sign. It means that many components are rerendered. The flamegraph shows that the &lt;Datagrid&gt; update takes the most time. Why did the app rerender the entire datagrid before fetching new data? Let’s dig down. Understanding the causes of a rerender often implies adding console.log() statements in render() functions. For functional components, you can use the following one-liner Higher-Order Component (HOC): 12345678// in src/log.jsconst log = BaseComponent =&gt; props =&gt; &#123; console.log(`Rendering $&#123;BaseComponent.name&#125;`); return &lt;BaseComponent &#123;…props&#125; /&gt;;&#125;export default log;// in src/MyComponent.jsimport log from ‘./log’;export default log(MyComponent); Tip: Another React performance tool worth mentioning is why-did-you-update. This npm package patches React to emit console warnings whenever a component rerenders with identical props. Caveats: The output is verbose, and it doesn’t work on functional components. In the example, when the user clicks on a header column, the app emits an action, which changes the state: the list sort order (currentSort) is updated. This state change triggers the rerendering of the &lt;List&gt; page, which in turn rerenders the entire &lt;Datagrid&gt; component. We want the datagrid header to be immediately rendered to show the sort icon change as a feedback to user action. What makes a React app slow is usually not a single slow component (that would translate in the flamegraph as one large pit). What makes a React app slow is, most of the time, useless rerenders of many components. You may have read that the React VirtualDom is super fast. That’s true, but in a medium size app, a full redraw can easily render hundreds of components. Even the fastest VirtualDom templating engine can’t make that in less than 16ms. Cutting Components To Optimize ThemHere is the &lt;Datagrid&gt; component render() method: 12345678910111213141516171819202122232425262728293031323334353637383940// in Datagrid.jsrender() &#123; const &#123; resource, children, ids, data, currentSort &#125; = this.props; return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &#123;Children.map(children, (field, index) =&gt; &lt;DatagridHeaderCell key=&#123;index&#125; field=&#123;field&#125; currentSort=&#123;currentSort&#125; updateSort=&#123;this.updateSort&#125; /&gt; )&#125; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;ids.map(id =&gt; ( &lt;tr key=&#123;id&#125;&gt; &#123;Children.map(children, (field, index) =&gt; &lt;DatagridCell record=&#123;data[id]&#125; key=&#123;`$&#123;id&#125;-$&#123;index&#125;`&#125; field=&#123;field&#125; resource=&#123;resource&#125; /&gt; )&#125; &lt;/tr&gt; ))&#125; &lt;/tbody&gt; &lt;/table&gt; );&#125; This seems like a very simple implementation of a datagrid, yet it is very inefficient. Each &lt;DatagridCell&gt; call renders at least two or three components. As you can see in the initial interface screencast, the list has 7 columns, 11 rows, that means 7113 = 231 components rerended. When only the currentSort changes, it’s a waste of time. Even though React doesn’t update the real DOM if the rerendered VirtualDom is unchanged, it takes about 500ms to process all the components. In order to avoid a useless rendering of the table body, I must first extract it: 123456789101112131415161718192021222324252627282930// in Datagrid.jsrender() &#123; const &#123; resource, children, ids, data, currentSort &#125; = this.props; return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &#123;React.Children.map(children, (field, index) =&gt; &lt;DatagridHeaderCell key=&#123;index&#125; field=&#123;field&#125; currentSort=&#123;currentSort&#125; updateSort=&#123;this.updateSort&#125; /&gt; )&#125; &lt;/tr&gt; &lt;/thead&gt; &lt;DatagridBody resource=&#123;resource&#125; ids=&#123;ids&#125; data=&#123;data&#125;&gt; &#123;children&#125; &lt;/DatagridBody&gt; &lt;/table&gt; ); );&#125; I created a new &lt;DatagridBody&gt; component by extracting the table body logic: 12345678910111213141516171819// in DatagridBody.jsimport React, &#123; Children &#125; from 'react';const DatagridBody = (&#123; resource, ids, data, children &#125;) =&gt; ( &lt;tbody&gt; &#123;ids.map(id =&gt; ( &lt;tr key=&#123;id&#125;&gt; &#123;Children.map(children, (field, index) =&gt; &lt;DatagridCell record=&#123;data[id]&#125; key=&#123;`$&#123;id&#125;-$&#123;index&#125;`&#125; field=&#123;field&#125; resource=&#123;resource&#125; /&gt; )&#125; &lt;/tr&gt; ))&#125; &lt;/tbody&gt;);export default DatagridBody; Extracting the table body has no effect on performance, but it reveals the path to optimization. Large, general purpose components are hard to optimize. Small, single-responsibility components are much easier to deal with. shouldComponentUpdateThe React documentation is very clear about the way to avoid useless rerenders: shouldComponentUpdate(). By default, React always renders a component to the virtual DOM. In other terms, it’s your job as a developer to check that the props of a component didn’t change and skip rendering altogether in that case. In the case of the &lt;DatagridBody&gt; component above, there should be no rerender of the body unless the props have changed. So the component should be completed as follows: 123456789101112131415161718192021222324252627import React, &#123; Children, Component &#125; from 'react';class DatagridBody extends Component &#123; shouldComponentUpdate(nextProps) &#123; return (nextProps.ids !== this.props.ids || nextProps.data !== this.props.data); &#125; render() &#123; const &#123; resource, ids, data, children &#125; = this.props; return ( &lt;tbody&gt; &#123;ids.map(id =&gt; ( &lt;tr key=&#123;id&#125;&gt; &#123;Children.map(children, (field, index) =&gt; &lt;DatagridCell record=&#123;data[id]&#125; key=&#123;`$&#123;id&#125;-$&#123;index&#125;`&#125; field=&#123;field&#125; resource=&#123;resource&#125; /&gt; )&#125; &lt;/tr&gt; ))&#125; &lt;/tbody&gt; ); &#125;&#125;export default DatagridBody; Tip: As an alternative to implementing shouldComponentUpdate() manually, I could inherit from React’s PureComponent instead of Component. This would compare all props using strict equality (===) and rerender only if any of the props change. But I know that resource and children cannot change in that context, so I don’t need to check for their equality. With this optimization, the rerendering of the &lt;Datagrid&gt; component after clicking on a table header skips the table body and its 231 components entirely. This reduces the update time from 500ms to 60ms. That’s a net performance improvement of more than 400ms! Tip: Don’t get fooled by the flamegraph width, it’s zoomed even more than the previous flamegraph. This one is definitely better! The shouldComponentUpdate optimization has removed a lot of pits in the graph, and reduced the overall rendering time. I can use the same trick to avoid even more rerenders (e.g. to avoid rendering the sidebar, the action buttons, the table headers that didn’t change, the pagination). After about an hour of work, the entire page renders just 100ms after clicking on a header column. That’s fast enough — even if there is still room for optimization. Adding a shouldComponentUpdate method may seem cumbersome, but if you care about performance, most of the components you write should end up with one. Don’t do it everywhere — executing shouldComponentUpdate on simple components is sometimes slower than just rendering the component. Don’t do that too early in the life of an application either — this would be premature optimization. But as your apps grow, and you can detect performance bottlenecks in your components, add shouldComponentUpdate logic to remain fast. RecomposeI’m not very happy with the previous change on &lt;DatagridBody&gt;: because of shouldComponentUpdate, I had to transform a simple, functional component to a class-based component. This adds more lines of code, and every line of code has a cost — to write, to debug, and to maintain. Fortunately, you can implement the shouldComponentUpdate logic in a higher-order component (HOC) thanks to recompose. It’s a functional utility belt for React, providing for instance the pure() HOC: 1234567891011121314151617181920// in DatagridBody.jsimport React, &#123; Children &#125; from 'react';import pure from 'recompose/pure';const DatagridBody = (&#123; resource, ids, data, children &#125;) =&gt; ( &lt;tbody&gt; &#123;ids.map(id =&gt; ( &lt;tr key=&#123;id&#125;&gt; &#123;Children.map(children, (field, index) =&gt; &lt;DatagridCell record=&#123;data[id]&#125; key=&#123;`$&#123;id&#125;-$&#123;index&#125;`&#125; field=&#123;field&#125; resource=&#123;resource&#125; /&gt; )&#125; &lt;/tr&gt; ))&#125; &lt;/tbody&gt;);export default pure(DatagridBody); The only difference between this code and the initial implementation is the last line: I export pure(DatagridBody) instead of DatagridBody. pure is like PureComponent, but without the extra class boilerplate. I can even be more specific and target only the props that I know may change, using recompose’s shouldUpdate() instead of pure(): 12345678910// in DatagridBody.jsimport React, &#123; Children &#125; from 'react';import shouldUpdate from ‘recompose/shouldUpdate’;const DatagridBody = (&#123; resource, ids, data, children &#125;) =&gt; ( ...);const checkPropsChange = (props, nextProps) =&gt; (nextProps.ids !== props.ids || nextProps.data !== props.data);export default shouldUpdate(checkPropsChange)(DatagridBody); The checkPropsChange function is pure, and I can even export it for unit tests. The recompose library offers more performance HOCs, like onlyUpdateForKeys(), which does exactly the type of check I did in my own checkPropsChange: 1234567// in DatagridBody.jsimport React, &#123; Children &#125; from 'react';import onlyUpdateForKeys from ‘recompose/onlyUpdateForKeys’;const DatagridBody = (&#123; resource, ids, data, children &#125;) =&gt; ( ...);export default onlyUpdateForKeys([‘ids’, ‘data’])(DatagridBody); I warmly recommend recompose. Beyond performance optimization, it helps you extract data fetching logic, HOC composition, and props manipulation in a functional and testable way. ReduxIf you’re using Redux to manage application state (which I also recommend), then connected components are already pure. No need to add another HOC. Just remember that if only one of the props change, then the connected component rerenders — this includes all its children, too. So even if you use Redux for page components, you should use pure() or shouldUpdate() for components further down in the render tree. Also, beware that Redux does the props comparison using strict equality. Since Redux connects the state to a component’s props, if you mutate an object in the state, Redux props comparison will miss it. That’s why you must use immutability in your reducers. For instance, in admin-on-rest, clicking on a table header dispatches a SET_SORT action. The reducer listening to that action must pay attention to replace objects in the state, not update them: 12345678910111213141516171819202122232425262728293031323334// in listReducer.jsexport const SORT_ASC = 'ASC';export const SORT_DESC = 'DESC';const initialState = &#123; sort: 'id', order: SORT_DESC, page: 1, perPage: 25, filter: &#123;&#125;,&#125;;export default (previousState = initialState, &#123; type, payload &#125;) =&gt; &#123; switch (type) &#123; case SET_SORT: if (payload === previousState.sort) &#123; // inverse sort order return &#123; ...previousState, order: oppositeOrder(previousState.order), page: 1, &#125;; &#125; // replace sort field_ return &#123; ...previousState, sort: payload, order: SORT_ASC, page: 1, &#125;; // ... default: return previousState; &#125;&#125;; With this reducer, when Redux checks for changes using triple equal, it finds that the state object is different, and rerenders the datagrid. But had we mutated the state, Redux would have missed the state change, and skipped rerendering by mistake: 12345678910111213141516171819// don't do this at homeexport default (previousState = initialState, &#123; type, payload &#125;) =&gt; &#123; switch (type) &#123; case SET_SORT: if (payload === previousState.sort) &#123; // never do this previousState.order = oppositeOrder(previousState.order); return previousState; &#125; // never do that either previousState.sort = payload; previousState.order = SORT_ASC; previousState.page = 1; return previousState; // ... default: return previousState; &#125;&#125;; To write immutable reducers, other developers like to use immutable.js, also from Facebook. I find it unnecessary, since ES6 destructuring makes it easy to selectively replace a component properties. Besides, Immutable is heavy (60kB), so think twice before you add it to your project dependencies. ReselectTo prevent useless renders in (Redux) connected components, you must also make sure that the mapStateToProps function doesn’t return new objects each time it is called. Take for instance the &lt;List&gt; component in admin-on-rest. It grabs the list of records for the current resource (e.g. posts, comments, etc) from the state using the following code: 123456789101112131415161718// in List.jsimport React from 'react';import &#123; connect &#125; from 'react-redux';const List = (props) =&gt; ...const mapStateToProps = (state, props) =&gt; &#123; const resourceState = state.admin[props.resource]; return &#123; ids: resourceState.list.ids, data: Object.keys(resourceState.data) .filter(id =&gt; resourceState.list.ids.includes(id)) .map(id =&gt; resourceState.data[id]) .reduce((data, record) =&gt; &#123; data[record.id] = record; return data; &#125;, &#123;&#125;), &#125;;&#125;;export default connect(mapStateToProps)(List); The state contains an array of all the previously fetched records, indexed by resource. For instance, state.admin.posts.data contains the list of posts: 12345&#123; 23: &#123; id: 23, title: “Hello, World”, /* … */ &#125;, 45: &#123; id: 45, title: “Lorem Ipsum”, /* … */ &#125;, 67: &#123; id: 67, title: “Sic dolor amet”, /* … */ &#125;,&#125; The mapStateToProps function filters this state object to return only the records actually displayed in the list. Something like: 1234&#123; 23: &#123; id: 23, title: “Hello, World”, /* … */ &#125;, 67: &#123; id: 67, title: “Sic dolor amet”, /* … */ &#125;,&#125; The problem is that each time mapStateToProps runs, it returns a new object, even if the underlying objects didn’t change. As a consequence, the &lt;List&gt; component rerenders every time something in the state changes — while id should only change if the date or ids change. Reselect solves this problem by using memoization. Instead of computing the props directly in mapStateToProps, you use a selector from reselect, which returns the same output if the input didn’t change. 123456789101112131415161718192021222324252627import React from 'react';import &#123; connect &#125; from 'react-redux';import &#123; createSelector &#125; from 'reselect'const List = (props) =&gt; ...const idsSelector = (state, props) =&gt; state.admin[props.resource].idsconst dataSelector = (state, props) =&gt; state.admin[props.resource].dataconst filteredDataSelector = createSelector( idsSelector, dataSelector (ids, data) =&gt; Object.keys(data) .filter(id =&gt; ids.includes(id)) .map(id =&gt; data[id]) .reduce((data, record) =&gt; &#123; data[record.id] = record; return data; &#125;, &#123;&#125;))const mapStateToProps = (state, props) =&gt; &#123; const resourceState = state.admin[props.resource]; return &#123; ids: idsSelector(state, props), data: filteredDataSelector(state, props), &#125;;&#125;;export default connect(mapStateToProps)(List); Now the &lt;List&gt; component will only rerender if a subset of the state changes. As for recompose, reselect selectors are pure functions, easy to test and compose. It’s a great way to code your selectors for Redux connected components. Beware of Object Literals in JSXOnce your components become more “pure”, you start detecting bad patterns that lead to useless rerenders. The most common is the usage of object literals in JSX, which I like to call “The infamous \\{\\{”. Let me give you an example: 1234567import React from 'react';import MyTableComponent from './MyTableComponent';const Datagrid = (props) =&gt; ( &lt;MyTableComponent style=&#123;&#123; marginTop: 10 &#125;&#125;&gt; ... &lt;/MyTableComponent&gt;) The style prop of the &lt;MyTableComponent&gt; component gets a new value every time the &lt;Datagrid&gt; component is rendered. So even if &lt;MyTableComponent&gt; is pure, it will be rendered every time &lt;Datagrid&gt; is rendered. In fact, each time you pass an object literal as prop to a child component, you break purity. The solution is simple: 12345678import React from 'react';import MyTableComponent from './MyTableComponent';const tableStyle = &#123; marginTop: 10 &#125;;const Datagrid = (props) =&gt; ( &lt;MyTableComponent style=&#123;tableStyle&#125;&gt; ... &lt;/MyTableComponent&gt;) This looks very basic, but I’ve seen this mistake so many times that I’ve developed a sense for detecting the infamous \\{\\{ in JSX. I routinely replace it with constants. Another usual suspect for hijacking pure components is React.cloneElement(). If you pass a prop by value as second parameter, the cloned element will receive new props at every render. 12345678// badconst MyComponent = (props) =&gt; &lt;div&gt;&#123;React.cloneElement(Foo, &#123; bar: 1 &#125;)&#125;&lt;/div&gt;;// goodconst additionalProps = &#123; bar: 1 &#125;;const MyComponent = (props) =&gt; &lt;div&gt;&#123;React.cloneElement(Foo, additionalProps)&#125;&lt;/div&gt;; This has bitten me a couple times with material-ui, for instance with the following code: 123456789import &#123; CardActions &#125; from 'material-ui/Card';import &#123; CreateButton, RefreshButton &#125; from 'admin-on-rest';const Toolbar = (&#123; basePath, refresh &#125;) =&gt; ( &lt;CardActions&gt; &lt;CreateButton basePath=&#123;basePath&#125; /&gt; &lt;RefreshButton refresh=&#123;refresh&#125; /&gt; &lt;/CardActions&gt;);export default Toolbar; Although &lt;CreateButton&gt; is pure, it was rendered every time &lt;Toolbar&gt; was rendered. That’s because material-ui’s &lt;CardActions&gt; adds a special style to its first child to accommodate for margins — and it does so with an object literal. So &lt;CreateButton&gt; received a different style prop every time. I solved it using recompose’s onlyUpdateForKeys() HOC. 123456// in Toolbar.jsimport onlyUpdateForKeys from 'recompose/onlyUpdateForKeys';const Toolbar = (&#123; basePath, refresh &#125;) =&gt; ( ...);export default onlyUpdateForKeys(['basePath', 'refresh'])(Toolbar); ConclusionThere are many other things you should do to keep your React app fast (using keys, lazy loading heavy routes, the react-addons-perf package, using ServiceWorkers to cache app state, going isomorphic, etc), but implementing shouldComponentUpdate correctly is the first step — and the most rewarding. React isn’t fast by default, but it offers all the tools to be fast whatever the size of the application. This may seem counterintuitive, especially since many frameworks offering an alternative to React claim themselves as n times faster. But React puts developer experience before performance. That’s the reason why developing large apps with React is such a pleasant experience, without bad surprises, and a constant implementation rate. Just remember to profile your app every once in a while, and dedicate some time to add a few pure() calls where it’s needed. Don’t do it first, or spend too much time to over optimize each and every component — except if you’re on mobile. And remember to test on various devices to get a good impression of your app’s responsiveness from a user’s point of view. If you want to read more about React performance optimization, here is a list of great articles on the subject: React Rally: Animated — React Performance Toolbox: A fabulous slide deck by Christopher Chedeau (Vjeux), one of the React Native developers. He’s French, by the way. Progressive Web Apps with React.js: Part 2 — Page Load Performance by Addy Osmany, who works at Google and writes a lot of blog posts about web performance Optimizing the Performance of Your React Application focuses on the react-addons-perf package to profile React apps precisely React Higher Order Components in depth, interesting for the introduction of Render Hijacking A Deep Dive into React Perf Debugging describes a step-by-step debugging session with Chrome dev Tools Making React reactive: the pursuit of high performing, easily maintainable React apps on using Observables to avoid rerenders","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Use const Until You Have to Use let","slug":"Use-const-Until-You-Have-to-Use-let","date":"2017-08-21T11:44:18.000Z","updated":"2017-08-21T15:42:19.465Z","comments":true,"path":"2017/08/Use-const-Until-You-Have-to-Use-let.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Use-const-Until-You-Have-to-Use-let.html","excerpt":"Aloha, web surfer. So perhaps you’re a let fan who came here to see what was up. Or maybe you’re a beginner, just moving out of var town and into the wild west that is ES6 variable declaration. Whatever your experience level may be, I hope this article provides valuable insights and leaves you with a solid rule of thumb for instantiating variables in Javascript. My other hope is that, upon finishing this article, you can confidently part ways with var – it is time.","text":"Aloha, web surfer. So perhaps you’re a let fan who came here to see what was up. Or maybe you’re a beginner, just moving out of var town and into the wild west that is ES6 variable declaration. Whatever your experience level may be, I hope this article provides valuable insights and leaves you with a solid rule of thumb for instantiating variables in Javascript. My other hope is that, upon finishing this article, you can confidently part ways with var – it is time. Once Upon A Time……in a specification authored somewhere in California… …a keyword for variable instantiation was created and called var. If you remember your first day learning Javascript, it probably involved var. This little keyword was our only option for declaring variables in Javascript for a long time. In fact, every web site and application that used Javascript between it’s inception in 1995 and the release of ECMAScript 2015 (ES6) used var and only var to create variables. (Someone fact check me on this statement, but I think it’s accurate.) The var keyword is no longer relevant, but in order to truly understand our present, we must understand our past. Some important things to know about variables created with the var keyword: 1231) They are function scoped2) Their declarations get hoisted3) They can be declared without a value 1 “They are function scoped”This means that var creates a variable that only exists inside of the function where it was declared. (Unless it was not declared inside a function. In that case, it exists ~everywhere~ 😲. More on this in fact #3.) Here’s a code snippet that illustrates the behavior of a function scoped variable: 123456function logA() &#123; var a = 2; console.log(a); // inside of `logA()`, `a` exists with value 2&#125;console.log(a); // ReferenceError! Outside of logA(), `a` is not defined. I think it’s worth clarifying that when I say “inside of” logA(), I mean “between logA()’s curly brackets”. 2 “Their declarations get hoisted” 🏋Variable hoisting basically boils down to the fact that a variable declared with var can be instantiated after it gets used. This code… 123456function logB() &#123; b = 2; // using b to hold the number 2 console.log(b); // using b to print 2 in the console var b; // instantiating b 🤔&#125; …will get transformed into something like this code… 123456function logB() &#123; var b; // instantiation is hoisted to the top of logB()'s scope b = 2; console.log(b);&#125; …at compile time (yes, Javascript gets compiled). That’s why it doesn’t matter (to the browser) where we instantiate our variables – the declarations get to skip the line every time. There’s a dark side to the way var gets hoisted, though. Javascript’s compiler can be a bit too helpful in some situations. If we use a variable within a function but don’t instantiate the variable in that function, the compiler will look for a var in the parent function scope. If it doesn’t find it there, it will keep looking all the way up the scope chain until it gets to the global scope. If it still doesn’t see a var declaration up there, it will just go ahead and make one for you, as demonstrated in this snippet: 12345function logC() &#123; c = 2; console.log(c); // 2&#125;// c is not instantiated in this program, yet it just works... Yikes. I guess this could be convenient sometimes when messing around in a REPL or something… But for the most part, this is bananas. &quot;use strict&quot;; prevents this and should be included at the top of any ES5 script. 3 “They can be declared without a value”You may have seen someone do something along these lines before: 1234567// declare all my variables at the top of the scriptvar a, b, c;// use them down herea = 1;b = 2;c = a + b; Put a pin in this because it becomes important later. Times Have ChangedThe three facets of var that I just covered come together to create an extremely flexible variable declaration mechanism. While flexibility itself is not a bad thing and having only one variable instantiation keyword means a little more flexibility is necessary, var is simply doing too much. Function scope isn’t a problem, but reassigning variables is so-so and should only be used for for loops and times when it’s completely unavoidable (and when it’s unavoidable, it probably means we have bigger fish to fry). The same goes for declaring variables without values. Lastly, being allowed to use a variable whether we declared it or not is silly. So, in order to address these drawbacks of var and save us developers from the pitfalls these “helpful” features can cause, the ES6 specification introduced two new variable keywords: const and let. Remember, the primary goal of this post is to show that it’s time to ditch var. Times have changed and var doesn’t make the cut. Let me explain…In 2015, Javascript’s variable declaration family grew to include let, which deviates significantly from var in that it is block scoped. This basically means that we now have two units of scope available: 1 Functions12345function() &#123; let i = 'aye'; // `i` is scoped to this function console.log(i); // \"aye\"&#125;console.log(i); // ReferenceError 2 Blocks12345&#123; let i = 'oi'; // `i` is scoped to this block console.log(i); // \"oi\"&#125;console.log(i); // ReferenceError The let keyword has another helpful constraint: the variable cannot be accessed before its declaration (let does get hoisted though). One thing let shares with var is that it can be used to declare a variable without an initial value. Like in the example above, we could have done 1234&#123; let i; i = 'oi';&#125; and it would’ve worked. Bookmarks for let 👓 Are Let / Const Hoisted? YDKJS Blocks As Scopes YDKJS Let YDKJS Garbage Collection YDKJS Let loops Const stop, won’t stopOkay, const is my favorite variable declaration keyword in Javascript. I default to const over let and never use var. As a rule, I always use const unless I have to use let. Remember how variables declared with var can be instantiated with empty values? This type of instantiation is allowed with let, too. It is not so with const. Oh no, const requires that you provide a value up front. Otherwise, it will turn its nose up at you and refuse to create a variable, “If you don’t know what’s going in the variable, monsieur/madame, then why do you need it at all?” – this is good. But there’s more! const goes one step further and ensures that the variable cannot be reassigned [note: this does not mean the variable is immutable]. For example, 12const a = 'ay';a = 2; // TypeError: Assignment to constant variable. Comparing const to var: 1 const is block scoped, var is function scoped. 2 const has to be instantiated with a value, var does not 3 const cannot be reassigned, var can 4 const cannot be accessed prior to instantiation, var can So basically const is the strictest variable instantiation tool we have at our disposal. The constraints it provides protect us from several possible errors, making the development process smoother. Exceptions: When to use letWhile I recommend defaulting to const, some situations demand the use of let. Here is a quote by Eric Elliot from a great article he wrote about the three keywords: 1`let`, is a signal that the variable may be reassigned, such as a counter in a loop, or a value swap in an algorithm. It also signals that the variable will be used only in the block it’s defined in, which is not always the entire containing function. In other words, for loops and mathematical algorithms are the only times we would need to reach for let. Other than that, const is the strongest, safest bet. Use const until you have to use letI hope this article helped you on your quest to understand let and const and how they differ from var. I also hope you can comfortably ditch var and use const until you have to use let. I’m still learning myself and there are certainly gaps in this article. Feel free to correct me when I’m wrong or bring missing information to light.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://nthung2112.github.io/tags/es6/"}]},{"title":"How to use Memoize to cache JavaScript function results and speed up your code","slug":"How-to-use-Memoize-to-cache-JavaScript-function-results","date":"2017-08-21T07:58:54.000Z","updated":"2017-08-21T15:42:19.418Z","comments":true,"path":"2017/08/How-to-use-Memoize-to-cache-JavaScript-function-results.html","link":"","permalink":"http://nthung2112.github.io/2017/08/How-to-use-Memoize-to-cache-JavaScript-function-results.html","excerpt":"","text":"Functions are an integral part of programming. They help add modularity and reusability to our code. It’s quite common to divide our program into chunks using functions which we can call later to perform some useful action. Sometimes, a function can become expensive to call multiple times (say, a function to calculate the factorial of a number). But there’s a way we can optimize such functions and make them execute much faster: caching. For example, let’s say we have a function to return the factorial of a number: 1234function factorial(n) &#123; // Calculations: n * (n-1) * (n-2) * ... (2) * (1) return factorial&#125; Great, now let’s find factorial(50). The computer will perform calculations and return us the final answer, sweet! When that’s done, let’s find factorial(51). The computer again performs a number of calculations and gets us the result, but you might have noticed that we’re already repeating a number of steps that could have been avoided. An optimized way would be: 1factorial(51) = factorial(50) * 51 But our function performs the calculations from scratch every time it’s called: 1factorial(51) = 51 * 50 * 49 * ... * 2 * 1 Wouldn’t it be cool if somehow our factorial function could remember the values from its previous calculations and use them to speed up the execution? In comes memoization, a way for our function to remember (cache) the results. Now that you’ve a basic understanding of what we’re trying to achieve, here’s a formal definition: Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again Memoizing in simple terms means memorizing or storing in memory. A memoized function is usually faster because if the function is called subsequently with the previous value(s), then instead of executing the function, we would be fetching the result from the cache. Here’s what a simple memoized function might look like (and here’s a CodePen in case you want to interact with it): 12345678910111213141516171819202122232425// a simple function to add somethingconst add = (n) =&gt; (n + 10);add(9);// a simple memoized function to add somethingconst memoizedAdd = () =&gt; &#123; let cache = &#123;&#125;; return (n) =&gt; &#123; if (n in cache) &#123; console.log('Fetching from cache'); return cache[n]; &#125; else &#123; console.log('Calculating result'); let result = n + 10; cache[n] = result; return result; &#125; &#125;&#125;// returned function from memoizedAddconst newAdd = memoizedAdd();console.log(newAdd(9)); // calculatedconsole.log(newAdd(9)); // cached Memoization takeawaysSome takeaways from the above code are: memoizedAdd returns a function which is invoked later. This is possible because in JavaScript, functions are first class objects which lets us use them as higher order functions and return another function. cache can remember its values since the returned function has a closure over it. It’s essential that the memoized function is pure. A pure function will return the same output for a particular input no mater how many times it’s called, which makes the cache work as expected. Writing your own memoize functionThe previous code works fine but what if we wanted to turn any function into a memoized function? Here’s how to write your own memoize function (codepen): 1234567891011121314151617181920212223242526272829// a simple pure function to get a value adding 10const add = (n) =&gt; (n + 10);console.log('Simple call', add(3));// a simple memoize function that takes in a function// and returns a memoized functionconst memoize = (fn) =&gt; &#123; let cache = &#123;&#125;; return (...args) =&gt; &#123; let n = args[0]; // just taking one argument here if (n in cache) &#123; console.log('Fetching from cache'); return cache[n]; &#125; else &#123; console.log('Calculating result'); let result = fn(n); cache[n] = result; return result; &#125; &#125;&#125;// creating a memoized function for the 'add' pure functionconst memoizedAdd = memoize(add);console.log(memoizedAdd(3)); // calculatedconsole.log(memoizedAdd(3)); // cachedconsole.log(memoizedAdd(4)); // calculatedconsole.log(memoizedAdd(4)); // cached Now that’s great! This simple memoize function will wrap any simple function into a memoized equivalent. The code works fine for simple functions and it can be easily tweaked to handle any number of arguments as per your needs. Another alternative is to make use of some de-facto libraries such as: Lodash’s _.memoize(func, [resolver]) ES7 @memoize decorators from decko Memoizing recursive functionsIf you try passing in a recursive function to the memoize function above or _.memoize from Lodash, the results won’t be as expected since the recursive function on its subsequent calls will end up calling itself instead of the memoized function thereby making no use of the cache. Just make sure that your recursive function is calling the memoized function. Here’s how you can tweak a textbook factorial example (codepen): 12345678910111213141516171819202122232425262728293031// same memoize function from beforeconst memoize = (fn) =&gt; &#123; let cache = &#123;&#125;; return (...args) =&gt; &#123; let n = args[0]; if (n in cache) &#123; console.log('Fetching from cache', n); return cache[n]; &#125; else &#123; console.log('Calculating result', n); let result = fn(n); cache[n] = result; return result; &#125; &#125;&#125;const factorial = memoize( (x) =&gt; &#123; if (x === 0) &#123; return 1; &#125; else &#123; return x * factorial(x - 1); &#125; &#125;);console.log(factorial(5)); // calculatedconsole.log(factorial(6)); // calculated for 6 and cached for 5 A few points to note from this code: The factorial function is recursively calling a memoized version of itself. The memoized function is caching the values of previous factorials which significantly improves calculations since they can be reused factorial(6) = 6 * factorial(5) Is memoization same as caching?Yes, kind of. Memoization is actually a specific type of caching. While caching can refer in general to any storing technique (like HTTP caching) for future use, memoizing specifically involves caching the return values of a function. When to memoize your functionsAlthough it might look like memoization can be used with all functions, it actually has limited use cases: In order to memoize a function, it should be pure so that return values are the same for same inputs every time Memoizing is a trade-off between added space and added speed and thus only significant for functions having a limited input range so that cached values can be made use of more frequently It might look like you should memoize your API calls however it isn’t necessary because the browser automatically caches them for you. See HTTP caching for more detail The best use case I found for memoized functions is for heavy computational functions which can significantly improve performance (factorial and fibonacci are not really good real world examples) If you’re into React/Redux you can check out reselect which uses a memoized selector to ensure that calculations only happen when a change happens in a related part of the state tree. Further readingThe following links can be useful if you would like to know more about some of the topics from this article in more detail: Higher order functions in JavaScript Closures in JavaScript Pure functions Lodash’s _.memoize docs and source code More memoization examples here and here reactjs/reselect I hope this article was useful for you, and you’ve gained a better understanding of memoization in JavaScript.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"advanced","slug":"advanced","permalink":"http://nthung2112.github.io/tags/advanced/"}]},{"title":"3 Reasons why I stopped using React.setState","slug":"3-Reasons-why-I-stopped-using-React-setState","date":"2017-08-21T07:43:25.000Z","updated":"2017-08-21T15:44:01.374Z","comments":true,"path":"2017/08/3-Reasons-why-I-stopped-using-React-setState.html","link":"","permalink":"http://nthung2112.github.io/2017/08/3-Reasons-why-I-stopped-using-React-setState.html","excerpt":"Since a few months I’ve stopped using React’s setState on all my new React components. Don’t get me wrong, I didn’t stop having local component state, I just stopped using React to manage it. And it’s been delightful! Using setState is tricky for beginners. Even experienced React programmers easily introduce subtle bugs when using React’s own state mechanism, like this: Bug introduced by forgetting that React state is asynchronous; the log is always one item behind","text":"Since a few months I’ve stopped using React’s setState on all my new React components. Don’t get me wrong, I didn’t stop having local component state, I just stopped using React to manage it. And it’s been delightful! Using setState is tricky for beginners. Even experienced React programmers easily introduce subtle bugs when using React’s own state mechanism, like this: Bug introduced by forgetting that React state is asynchronous; the log is always one item behind The excellent Reacts docs sum up everything that could go wrong when using setState: To summarize, there are 3 issues when using setState: 1. setState is asynchronousMany devs don’t realize this initially, but setState is asynchronous. If you set some state, than take a look at it, you will still see the old state.This is the most tricky part of setState. setState calls don’t look asynchronous, and naively calling setState introduces very subtle bugs. The next gist demonstrates that nicely: At first glance this might look fine. Two event handlers and a utility function that fire the onSelect event if provided. However, this Select component has a bug that is nicely demonstrated in the GIF above. onSelect is always fired with the previous value of state.selection, because setState hasn’t done it’s job yet when the fireOnSelect helperis invoked. I think the least React could do here is rename the method to scheduleState or make the callback required. This bug is easily fixed, the tricky part is realizing it’s there. 2. setState causes unnecessary rendersThe second issue with setState is that it always triggers a re-render. Often those re-renders are unnecessary. You can use the printWasted method from the React performance tools to find out when this happens. But roughly speaking there are several reasons why a re-render may be unnecessary: The new state is actually the same as the previous one. This can often be addressed by implementing shouldComponentUpdate. You may already be using a (pure render) library to solve this for you. Sometimes the changed state is relevant for the rendering, but not under all circumstances. For example when some data is only conditionally visible. Thirdly, as pointed out in Aria Buckles’ talk at React Europe 2015, sometimes instance state is not relevant for the rendering at all! This is often householding state related to managing event listeners, timer ID’s etc. 3. setState is not sufficient to capture all component stateFollowing the last point above, not all component state should be stored and updated using setState. More complex components often have administration that is needed by lifecycle hooks to manage timers, network requests, events etc. Managing those with setState not only causes unnecessary renders, but also causes related lifecycle hooks to be triggered again, leading to weird situations. Managing local component state with MobX(Surprise, surprise) At Mendix we already rely on MobX to manage all our stores. However, we were still using React’s own state mechanism for local component state. Recently, we switched to managing local component state with MobX as well. That looks like this: For completeness sake: No unexpected bugs when using a state mechanism that is synchronous The above code snippet is not only more concise, MobX also addresses all of the setState related issues: Changes to the state are immediately reflected in the local component state. This makes our logic simpler and code reuse easier. You don’t have to compensate for the fact that the state might not have been updated yet. MobX determines at runtime which observables are relevant for rendering. So observables that are temporarily irrelevant for the rendering, won’t cause a re-rendering. Until they are relevant again. For this reason, there are also no rendering penalties (or lifecycle issues) when marking fields as @observable that are not relevant for rendering at all. So renderable and non-renderable state is treated uniformly. In addition, state stored in our components now works the same as state stored in any of our stores. This makes it trivial to refactor components, and move local component state into a separate store or vice versa. Which is demonstrated in this egghead tutorial. MobX effectively turns your components into small stores Furthermore, rookie mistakes like assigning values directly to the state object cannot be made anymore when using observables for state. Oh, and don’t worry about implementing shouldComponentUpdate or PureRenderMixin, MobX already takes care of that as well. Finally, you might be wondering, what if I want to wait until setState has finished? Well, you can still use the _compentDidUpdate l_ifecycle hook for that. Sounds cool! How do I get started with MobX?Pretty simple, follow the 10 minute interactive introduction or watch the aforementioned video. You can simply take a single component from your code base, slap @observer on it and introduce some @observable properties. You don’t even have to replace your existing setState calls, they continue to work while using MobX. Although, within a few minutes you might find them so convoluted that you will replace them anyway :). (Oh, and if you don’t like decorators, no worries, it works with good ol’ ES5 as well). TL;DR:I’ve stopped using React to manage local component state. I use MobX instead. Now React is truly “just the view” :). MobX now manages both local component state and state in stores. It is concise, synchronous, efficient and uniform. From experience, I’ve learned that MobX is even easier to explain to React beginners than React’s own setState. It keeps our components clean and simple. JSBin using setState for state management JSBin using MobX observables for state management","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"mobx","slug":"mobx","permalink":"http://nthung2112.github.io/tags/mobx/"}]},{"title":"What I’ve Learned Over 5 Years as a Software Developer","slug":"What-I’ve-Learned-Over-5-Years-as-a-Software-Developer","date":"2017-08-20T17:22:53.000Z","updated":"2017-08-20T17:47:33.433Z","comments":true,"path":"2017/08/What-I’ve-Learned-Over-5-Years-as-a-Software-Developer.html","link":"","permalink":"http://nthung2112.github.io/2017/08/What-I’ve-Learned-Over-5-Years-as-a-Software-Developer.html","excerpt":"It’s July 3rd 2017 at the time of publishing this article. Why am I mentioning such a seemingly arbitrary fact? Because today marks the five-year anniversary of beginning my software engineering career. Before this, I did undertake some work experience and completed some freelance projects, but I had no commercial exposure until I started my graduate scheme at Sky on this very day in 2012. Rather than dive into some self-indulgent drivel, I’d love to share five of the most important things I’ve learned thus far; I believe that all developers should embrace them.","text":"It’s July 3rd 2017 at the time of publishing this article. Why am I mentioning such a seemingly arbitrary fact? Because today marks the five-year anniversary of beginning my software engineering career. Before this, I did undertake some work experience and completed some freelance projects, but I had no commercial exposure until I started my graduate scheme at Sky on this very day in 2012. Rather than dive into some self-indulgent drivel, I’d love to share five of the most important things I’ve learned thus far; I believe that all developers should embrace them. 1. Throw yourself in the deep endI remember my first day in the NOW TV Xbox 360 team. I’d just finished a 7-month stint on a graduate scheme, working on a number of small internal projects using Ruby and JavaScript. My new team, in contrast, used C#, .NET, and Silverlight. Needless to say, I had no idea where to begin; I covered C#, .NET, and a touch of XAML in the final year of my degree, but not to a commercially-acceptable level. Although my colleagues were incredibly accommodating and helpful, I nonetheless realised that I had to get up to speed if I was to meaningfully contribute to the codebase. As well as working on tickets, I: studied the various aspects of the codebase and searched online for information on concepts that I didn’t understand paired with senior developers to gain insights into effectively implementing new features and refactoring others read books, documentation, and other literature covering: C#; .NET; Silverlight; design patterns; unit testing; and the software development lifecycle (SDLC) Of course, one can only learn at a set pace, and as I’ll cover later, too much work will ultimately come to a head. However, by placing oneself on an alien project, one will naturally push oneself to work as hard as possible; humans are naturally curious creatures, and we thrive in new settings, regardless of how difficult the challenges ahead may be. If somebody offers you an amazing opportunity but you are not sure you can do it, say yes — then learn how to do it later! Richard Branson 2. Be humbleOnce one has gained enough experience as a developer, or in any other capacity for that matter, one consequently gains confidence, and is now in a position to contribute to more complex parts of a codebase, to open source projects, and to the community in general in a variety of ways, such as articles. It can be easy to patronise others who may not have the same skill set, or general level of aptitude, as you. “That’s easy! How can you not know that?!” or “You obviously forgot to run the build script” may be tempting responses to simple questions, but remember that you were once naïve and lacking knowledge. Be kind and humble towards others as if you were at their level. Empathise! Another important facet of humility is to admit when one is wrong. I’ve encountered my share of developers who, rather than admit that they’ve misunderstood a concept or take ownership of a problem they’ve created, attempt to bullshit their way out of a situation. “You’re incapable of understanding my work! I can’t be wrong.” Well yes, you can. 3. Listen and be open-minded, but don’t be afraid of demonstrating assertionOn the subject of humility, it is important to be open-minded towards both alternative points of view and new information regarding concepts and ideas to which one is completely new. While the latter case may seem natural, few people are willing to challenge their own views and ultimately alter their own positions; being malleable will allow one to refine one’s opinions and knowledge which can then be applied to a similar situation further down the road. That said, there is nothing wrong with pushing back if one has experience within the domain of a specific problem and is therefore aware of common pitfalls and best practices. By demonstrating confidence and effective persuasion techniques, one might bring new information to the attention of one’s colleagues. Being assertive does not make you an arsehole. Me 4. Embrace change, but don’t jump on the bandwagonTo a new developer, the rate of change that one witnesses might seem unmanageable; I would like to counter this by arguing that this is not necessarily the case. In the JavaScript world, it’s clear that new libraries and frameworks are released regularly, and certain programmers (read: hipsters) will adopt them quickly without giving much thought to their applicability to a particular use case. One might therefore feel obliged to follow the emergence of technologies in order to continue to provide value as a developer. I initially felt this pressure, but it’s completely avoidable when one views this in reverse. Whenever I’m starting a new project, I seek technologies from which it may benefit, and investigate them with the outcome of answering these questions: Does is naturally lend itself to my problem? Is it mature? Does it have a strong community? Is it well-tested? This is by no means an exclusive list, but I’ve found that this mindset points me in the right direction. I was admittedly very cynical of React when it first emerged. “XML in JS?! Surely this is just a pointless abstraction of the DOM.” Then I tried it in a new role for an app that rendered large lists of items, which would re-render as a consequence of various interactions; it clicked that it was a great library for this particular application, and I thus realised how wrong I was. One should definitely endeavour to be aware of new approaches, and to use them if appropriate, but there’s no obligation to use the new hotness for the sake of it; the main goal of software engineering is to, well, deliver software, and choosing the wrong tech could hinder this achievement. 5. Balance work and playAs soon as I wrote my first Hello World program at university, I almost became addicted to programming. Initially, my ability was limited, thus most of my code was ugly (but that’s OK; it’s part of the learning process.) Once I had worked in the industry for a while and became competent, however, I would spend my evenings and weekends working on all sorts of side projects, and I loved it. I felt that I had truly found my calling, and I just couldn’t stop. Some of these manifested into relatively successful open source projects, as well as contributions to existing codebases. This really gave me a sense of self-esteem, so I kept going. I would enter JavaScript competitions, such as the brilliant js13kGames and JS1k, write articles, and go on to publish a screencast series for SitePoint. I even interviewed with some big tech companies, which resulted in lots of practice and reading. By the end of this, I was completely burned out. I had lost all motivation and could no longer bring myself to program in my spare time. Furthermore, my other hobbies, which allowed me to escape technology when needed, were put on the back burner; I was essentially a code production unit. It’s important to challenge oneself while one has the opportunity; these means not only enabled me to improve as a developer, but have really advanced my career. However, rest is critical. You’re a human being; your capacity to learn abstract concepts and work without sufficient breaks will naturally diminish, given our evolutionary origins. If you feel burnout approaching, take a step back for a while. Not just for a week or so; I’m talking a month or two. Trust me, you’ll know when you’re ready to resume, plus your projects won’t be going anywhere.","categories":[],"tags":[]},{"title":"Our Best Practices for Writing React Components","slug":"Our-Best-Practices-for-Writing-React-Components","date":"2017-08-20T16:06:29.000Z","updated":"2017-08-21T15:42:19.451Z","comments":true,"path":"2017/08/Our-Best-Practices-for-Writing-React-Components.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Our-Best-Practices-for-Writing-React-Components.html","excerpt":"When I first started writing React, I remember seeing many different approaches to writing components, varying greatly from tutorial to tutorial. Though the framework has matured considerably since then, there doesn’t seem to yet be a firm ‘right’ way of doing things. Over the past year at MuseFind, our team has written a lot of React components. We’ve gradually refined our approach until we’re happy with it. This guide represents our suggested best practices. We hope it will be useful, whether you’re a beginner or experienced.","text":"When I first started writing React, I remember seeing many different approaches to writing components, varying greatly from tutorial to tutorial. Though the framework has matured considerably since then, there doesn’t seem to yet be a firm ‘right’ way of doing things. Over the past year at MuseFind, our team has written a lot of React components. We’ve gradually refined our approach until we’re happy with it. This guide represents our suggested best practices. We hope it will be useful, whether you’re a beginner or experienced.Before we get started, a couple of notes: We use ES6 and ES7 syntax. If you’re not sure of the distinction between presentational and container components, we recommend you read this first. Please let us know in the comments if you have any suggestions, questions, or feedback. Class Based ComponentsClass based components are stateful and/or contain methods. We try to use them as sparingly as possible, but they have their place. Let’s incrementally build our component, line by line. Importing CSS12345import React, &#123; Component &#125; from 'react'import &#123; observer &#125; from 'mobx-react'import ExpandableForm from './ExpandableForm'import './styles/ProfileContainer.css' I like CSS in JavaScript, I do — in theory. But it’s still a new idea, and a mature solution hasn’t emerged. Until then, we import a CSS file to each component. We also separate our dependency imports from local imports by a newline. Initializing State12345678import React, &#123; Component &#125; from 'react'import &#123; observer &#125; from 'mobx-react'import ExpandableForm from './ExpandableForm'import './styles/ProfileContainer.css'export default class ProfileContainer extends Component &#123; state = &#123; expanded: false &#125; You can also use the older approach of initializing state in the constructor. More on that here. We prefer the cleaner way. We also make sure to export our class as the default. propTypes and defaultProps12345678910111213141516171819import React, &#123; Component &#125; from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; string, object &#125; from 'prop-types'import ExpandableForm from './ExpandableForm'import './styles/ProfileContainer.css'export default class ProfileContainer extends Component &#123; state = &#123; expanded: false &#125; static propTypes = &#123; model: object.isRequired, title: string &#125; static defaultProps = &#123; model: &#123; id: 0 &#125;, title: 'Your Name' &#125; propTypes and defaultProps are static properties, declared as high as possible within the component code. They should be immediately visible to other devs reading the file, since they serve as documentation. If using React 15.3.0 or higher, use the prop-types package instead of React.PropTypes — nicely destructured, of course. All your components should have propTypes. Methods1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; string, object &#125; from 'prop-types'import ExpandableForm from './ExpandableForm'import './styles/ProfileContainer.css'export default class ProfileContainer extends Component &#123; state = &#123; expanded: false &#125; static propTypes = &#123; model: object.isRequired, title: string &#125; static defaultProps = &#123; model: &#123; id: 0 &#125;, title: 'Your Name' &#125; handleSubmit = (e) =&gt; &#123; e.preventDefault() this.props.model.save() &#125; handleNameChange = (e) =&gt; &#123; this.props.model.changeName(e.target.value) &#125; handleExpand = (e) =&gt; &#123; e.preventDefault() this.setState(&#123; expanded: !this.state.expanded &#125;) &#125; With class components, when you pass methods to subcomponents, you have to ensure that they have the right this when they’re called. This is usually achieved by passing this.handleSubmit.bind(this) to the subcomponent. We think this approach is cleaner and easier, maintaining the correct context automatically via the ES6 arrow function. Passing setState a FunctionIn the above example, we do this: 1this.setState(&#123; expanded: !this.state.expanded &#125;) Here’s the dirty secret about setState — it’s actually asynchronous. React batches state changes for performance reasons, so the state may not change immediately after setState is called. That means you should not rely on the current state when calling setState — since you can’t be sure what that state will be! Here’s the solution — pass a function to setState, with the previous state as an argument. 1this.setState(prevState =&gt; (&#123; expanded: !prevState.expanded &#125;)) (Thanks to Austin Wood for his help with this section). Destructuring Props123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import React, &#123; Component &#125; from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; string, object &#125; from 'prop-types'import ExpandableForm from './ExpandableForm'import './styles/ProfileContainer.css'export default class ProfileContainer extends Component &#123; state = &#123; expanded: false &#125; static propTypes = &#123; model: object.isRequired, title: string &#125; static defaultProps = &#123; model: &#123; id: 0 &#125;, title: 'Your Name' &#125; handleSubmit = (e) =&gt; &#123; e.preventDefault() this.props.model.save() &#125; handleNameChange = (e) =&gt; &#123; this.props.model.changeName(e.target.value) &#125; handleExpand = (e) =&gt; &#123; e.preventDefault() this.setState(prevState =&gt; (&#123; expanded: !prevState.expanded &#125;)) &#125; render() &#123; const &#123; model, title &#125; = this.props return ( &lt;ExpandableForm onSubmit=&#123;this.handleSubmit&#125; expanded=&#123;this.state.expanded&#125; onExpand=&#123;this.handleExpand&#125;&gt; &lt;div&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;input type=\"text\" value=&#123;model.name&#125; onChange=&#123;this.handleNameChange&#125; placeholder=\"Your Name\"/&gt; &lt;/div&gt; &lt;/ExpandableForm&gt; ) &#125;&#125; Components with many props should have each prop on a newline, like above. Decorators12@observerexport default class ProfileContainer extends Component &#123; If you’re using something like mobx, you can decorate your class components like so — which is the same as passing the component into a function. Decorators are flexible and readable way of modifying component functionality. We use them extensively, with mobx and our own mobx-models library. If you don’t want to use decorators, do the following: 12345class ProfileContainer extends Component &#123; // Component code&#125;export default observer(ProfileContainer) ClosuresAvoid passing new closures to subcomponents, like so: 1234567&lt;input type=\"text\" value=&#123;model.name&#125; // onChange=&#123;(e) =&gt; &#123; model.name = e.target.value &#125;&#125; // ^Not this. Use the below: onChange=&#123;this.handleChange&#125; placeholder=\"Your Name\"/&gt; Here’s why: every time the parent component renders, a new function is created and passed to the input. If the input were a React component, this would automatically trigger it to re-render, regardless of whether its other props have actually changed. Reconciliation is the most expensive part of React. Don’t make it harder than it needs to be! Plus, passing a class method is easier to read, debug, and change. Here’s our full component: Functional ComponentsThese components have no state and no methods. They’re pure, and easy to reason about. Use them as often as possible. propTypes123456789101112import React from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; func, bool &#125; from 'prop-types'import './styles/Form.css'ExpandableForm.propTypes = &#123; onSubmit: func.isRequired, expanded: bool&#125;// Component declaration Here, we assign the propTypes before the component declaration, so they are immediately visible. We’re able to do this because of JavaScript function hoisting. Destructuring Props and defaultProps123456789101112131415161718192021import React from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; func, bool &#125; from 'prop-types'import './styles/Form.css'ExpandableForm.propTypes = &#123; onSubmit: func.isRequired, expanded: bool, onExpand: func.isRequired&#125;function ExpandableForm(props) &#123; const formStyle = props.expanded ? &#123;height: 'auto'&#125; : &#123;height: 0&#125; return ( &lt;form style=&#123;formStyle&#125; onSubmit=&#123;props.onSubmit&#125;&gt; &#123;props.children&#125; &lt;button onClick=&#123;props.onExpand&#125;&gt;Expand&lt;/button&gt; &lt;/form&gt; )&#125; Our component is a function, which takes its props as its argument. We can expand them like so: 123456789101112131415161718192021import React from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; func, bool &#125; from 'prop-types'import './styles/Form.css'ExpandableForm.propTypes = &#123; onSubmit: func.isRequired, expanded: bool, onExpand: func.isRequired&#125;function ExpandableForm(&#123; onExpand, expanded = false, children, onSubmit &#125;) &#123; const formStyle = expanded ? &#123;height: 'auto'&#125; : &#123;height: 0&#125; return ( &lt;form style=&#123;formStyle&#125; onSubmit=&#123;onSubmit&#125;&gt; &#123;children&#125; &lt;button onClick=&#123;onExpand&#125;&gt;Expand&lt;/button&gt; &lt;/form&gt; )&#125; Note we can also use default arguments to act as defaultProps in a highly readable manner. If expanded is undefined, we set it to false. (A bit of a forced example, since it’s a boolean, but very useful for avoiding ‘Cannot read of undefined’ errors with objects). Avoid the following ES6 syntax: 1const ExpandableForm = (&#123; onExpand, expanded, children &#125;) =&gt; &#123; Looks very modern, but the function here is actually unnamed. This lack of name will not be a problem if your Babel is set up correctly — but if it’s not, any errors will show up as occurring in &lt;&gt; which is terrible for debugging. Unnamed functions can also cause problems with Jest, a React testing library. Due to the potential for difficult-to-understand bugs (and the lack of real benefit) we recommend using function instead of const. WrappingSince you can’t use decorators with functional components, you simply pass it the function in as an argument: 12345678910111213141516171819202122import React from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; func, bool &#125; from 'prop-types'import './styles/Form.css'ExpandableForm.propTypes = &#123; onSubmit: func.isRequired, expanded: bool, onExpand: func.isRequired&#125;function ExpandableForm(&#123; onExpand, expanded = false, children, onSubmit &#125;) &#123; const formStyle = expanded ? &#123;height: 'auto'&#125; : &#123;height: 0&#125; return ( &lt;form style=&#123;formStyle&#125; onSubmit=&#123;onSubmit&#125;&gt; &#123;children&#125; &lt;button onClick=&#123;onExpand&#125;&gt;Expand&lt;/button&gt; &lt;/form&gt; )&#125;export default observer(ExpandableForm) Here’s our full component: Conditionals in JSXChances are you’re going to do a lot of conditional rendering. Here’s what you want to avoid: Actual code I wrote in my early days at MuseFind… forgive me No, nested ternaries are not a good idea. There are some libraries that solve this problem (JSX-Control Statements), but rather than introduce another dependency, we settled on this approach for complex conditions: A refactored version of the above. Use curly braces wrapping an IIFE, and then put your if statements inside, returning whatever you want to render. Note that IIFE’s like this can cause a performance hit, but in most cases it will not be significant enough to warrant losing the readability factor. Update: Many commenters have recommended extracting this logic to a subcomponent that conditionally returns different buttons based on props. They’re right — splitting up your components as much as possible is always a good call. But keep the IIFE approach in mind as a fallback for quick conditionals. Also, when you only want to render an element on one condition, instead of doing this… 12345&#123; isTrue ? &lt;p&gt;True!&lt;/p&gt; : &lt;none/&gt;&#125; … use short-circuit evaluation: 1234&#123; isTrue &amp;&amp; &lt;p&gt;True!&lt;/p&gt;&#125; ConclusionWas this article useful? Please click the green heart below, or follow me and our publication for more. Have any feedback? Leave a comment below. Thanks for reading!","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Nodejs là gì","slug":"Nodejs-la-gi","date":"2017-08-20T15:56:00.000Z","updated":"2017-08-21T15:44:24.511Z","comments":true,"path":"2017/08/Nodejs-la-gi.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Nodejs-la-gi.html","excerpt":"Trong bài viết giới thiệu về asynchronous, event-driven và non-blocking I/O, mình có treo tên Nodejs lên trên tiêu đề nhưng thật ra bài viết ấy lại không đả động đến Nodejs được bao nhiêu. Nó chỉ giới thiệu ý nghĩa của các khái niệm trên trong ngữ cảnh mà Nodejs sử dụng. Lần này là một bài viết chân thật về Nodejs. Hãy cùng nhau trả lời một câu hỏi mang tính bản thể luận về Nodejs: Bản chất của Nodejs là gì? Trong bài viết giới thiệu về asynchronous, event-driven và non-blocking I/O, mình có treo tên Nodejs lên trên tiêu đề nhưng thật ra bài viết ấy lại không đả động đến Nodejs được bao nhiêu. Nó chỉ giới thiệu ý nghĩa của các khái niệm trên trong ngữ cảnh mà Nodejs sử dụng. Lần này là một bài viết chân thật về Nodejs. Hãy cùng nhau trả lời một câu hỏi mang tính bản thể luận về Nodejs: Bản chất của Nodejs là gì?","text":"Trong bài viết giới thiệu về asynchronous, event-driven và non-blocking I/O, mình có treo tên Nodejs lên trên tiêu đề nhưng thật ra bài viết ấy lại không đả động đến Nodejs được bao nhiêu. Nó chỉ giới thiệu ý nghĩa của các khái niệm trên trong ngữ cảnh mà Nodejs sử dụng. Lần này là một bài viết chân thật về Nodejs. Hãy cùng nhau trả lời một câu hỏi mang tính bản thể luận về Nodejs: Bản chất của Nodejs là gì? Trong bài viết giới thiệu về asynchronous, event-driven và non-blocking I/O, mình có treo tên Nodejs lên trên tiêu đề nhưng thật ra bài viết ấy lại không đả động đến Nodejs được bao nhiêu. Nó chỉ giới thiệu ý nghĩa của các khái niệm trên trong ngữ cảnh mà Nodejs sử dụng. Lần này là một bài viết chân thật về Nodejs. Hãy cùng nhau trả lời một câu hỏi mang tính bản thể luận về Nodejs: Bản chất của Nodejs là gì? Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript Engine. JavaScript thì dễ hiểu rồi (Thật ra Chrome cũng dễ hiểu), nhưng còn Runtime với Engine là gì? Mối quan hệ giữa chúng như thế nào? JavaScript Engine có thể được định nghĩa một cách đơn giản như sau: Một chương trình hoặc thư viện thực thi mã JavaScript, cung cấp các cơ chế khởi tạo object, gọi function,… Có thể đơn giản là một interpreter hoặc một JIT compiler to bytecode. Tất nhiên, vì cả bài viết này chỉ nhằm nhiệm vụ trả lời Nodejs là gì, mà biết được JavaScript Engine là gì tức là đã xong 50% vấn đề, nên ta sẽ giải thích lại, một cách phức tạp và dài dòng hơn, bắt đầu từ những khái niệm cơ bản hơn như Interpreter và Compiler. Interpreter và Compiler Interpreter (của ngôn ngữ A): Một thành phần có chức năng trực tiếp thực thi một đoạn code (được viết bằng ngôn ngữ A). Có thể coi CPU như một interpreter của tập chỉ lệnh tương ứng. Ngày nay, interpreter thường hiểu theo ý nghĩa trực tiếp một chương trình từ source code mà không qua chuyển đổi thành machine code. Compiler: Dịch từ ngôn ngữ A sang ngôn ngữ B sao cho khi thực thi thu được kết quả tương đương. Thường được sử dụng để dịch source code từ ngôn ngữ bậc cao A sang ngôn ngữ B có bậc thấp hơn dễ dàng interprete hơn, và tất nhiên ngôn ngữ dễ interprete nhất là machine code. Thời gian cần để compile thường không phải là nhỏ, nhất là khi cần tối ưu hoá kết quả. Để giảm thiểu thời gian compile, có một cách (đánh đổi bởi tốc độ thực thi sau khi compile) là không dịch trực tiếp source code ra machine code mà dịch sang một ngôn ngữ trung gian và sử dụng interpreter cho ngôn ngữ trung gian này, thường gọi là bytecode, với đặc điểm là thời gian compile từ ngôn ngữ nguồn sang bytecode nhanh hơn sang machine code, tốc độ thực thi nhanh hơn việc trực tiếp interprete source code, mặc dù chậm hơn machine code. Từ interpreter và bytecode trong định nghĩa về JavaScript Engine đã rõ ràng, vậy còn JIT compiler? Để có một cái nhìn về JIT compiler, chúng ta cần xem xét nó trong một mối quan hệ biện chứng giữa nó và một khái niệm khác: AOT compiler. Ahead-of-Time (AOT) và Just-in-Time (JIT) compilation: Từ time được nhắc đến ở đây là runtime. AOT dịch toàn bộ source code trước khi bắt đầu chạy chương trình, JIT thì trái lại compile source code trong thời gian chạy. Triết lý của JIT compilation là thay vì phải chờ compiler dịch toàn bộ source, việc có thể mất nhiều thời gian, ta dịch từng phần mà ta cần dùng trước rồi bắt đầu chạy với chúng ngay lập tức. Interpreter và compiler có thể kết hợp trở thành engine của một ngôn ngữ theo 1 trong 2 cách: AOT kết hợp interpreter: Source code được compile toàn bộ thành machine code hoặc bytecode trước khi khởi chạy chương trình, sau đó sử dụng một interpreter để thực thi. Ví dụ Python được AOT compiler dịch thành cpython bytecode trong chớp nhoáng và cpython được chạy trên interpreter. JIT kết hợp interpreter: Thực tế là full compiled code chạy nhanh hơn nhưng tốn nhiều thời gian trước khi bắt đầu chạy, trực tiếp interprete source code thì có thể bắt đầu chạy ngay nhưng tốc độ thực thi chậm. Giải pháp trung hoà là sử dụng interpreter để khởi chạy nhanh chóng source code, rồi dùng JIT compiler để dịch và thay thế source code bằng compiled code sau khi đã dịch xong. V8 EngineV8 là một open source JavaScript engine viết bằng C++, phát triển bởi Google như là một phần trong dự án Chromium, phát hành lần đầu cùng với phiên bản đầu tiên của trình duyêt Chrome. V8 compile trực tiếp JavaScript thành native machine code thay vì sử dụng interpreting bytecode theo cách truyền thống. Nodejs được xây dựng lần đầu trên V8 do tốc độ thực thi đáng kinh ngạc so với các JavaScript Engine trước đó, đủ sức đảm đương một hệ thống yêu cầu hiệu năng cao trên server-side. Ngày nay thì các Engine của các hãng khác cũng đã bắt kịp V8 rồi, vừa rồi Nodejs cũng đã phát hành một phiên bản sử dụng Chakra Enginecủa Microsoft tại https://github.com/nodejs/node-chakracore, nhưng có lẽ khi nhắc đến Nodejs thì ta chỉ cần giới thiệu về V8 là đủ. V8 Engine được Google lựa chọn quả thật là một cái tên mang nhiều cảm xúc, gợi lên hình ảnh về những động cơ ô tô mạnh mẽ, sản sinh công suất lớn từ thiết kế 8 xy-lanh sắp xếp hình chữ V mà hiếm khi nào có tổng dung tích dưới 3.0 L, thậm chí lên đến hơn 8.0 L, ví như động cơ của chiếc Audi R8 trong hình dưới. Khá chắc là các kỹ sư của Google cũng rất mê xe, bởi họ tiếp tục đặt tên cho các thành phần trong động cơ V8 của mình là Crankshaft, TuborFan và Ignition, các thành phần kỹ thuật của động cơ đốt trong hiện đại mà chúng ta sẽ bắt gặp trong phần sau của bài viết. Lan man vậy thôi, bây giờ, ba yếu tố then chốt tạo nên hiệu năng cao của V8 là: Fast Property Access Dynamic Machine Code Generation Efficient Garbage Collection Fast Property AccessJavaScript là một dynamic programming language, có nghĩa, các property có thể được thêm, bớt, thay đổi trong thời gian chạy. Hầu hết các JavaScript Engine sử dụng một cấu trúc dữ liệu dạng dictionary để lưu giữ các property trong object, mỗi truy cập đến property yêu cầu một dictionary dynamic lookup để tìm ra vị trí của property trong memory, chậm hơn cách truy cập trực tiếp đến property trong các class-based language truyền thống. Để tránh dynamic lookup, V8 tự động ngầm tạo một hidden class cho mỗi object, biến object trong JavaScript thành class-based. Mỗi khi object được thêm property, V8 tạo mới một hidden class và object chuyển hidden class của nó sang class mới này. Nguồn ảnh: v8project.blogspot.com Kể từ khi object trong JavaScript trở thành class-based, một kỹ thuật compiler optimization kinh điển trở nên khả thi và được đưa vào V8, Inline Caching, giúp tăng lực cho JavaScript lên thậm chí vài chục lần với long runtime. Dynamic Machine Code GenerationV8 dịch trực tiếp JavaScript source code sang native machine code, cho tốc độ interprete cao, đồng thời có khả năng linh động tối ưu hoá (và tái tối ưu) compiled code trong thời gian chạy dựa trên các dữ liệu thu thập được từ profiler. V8 có 2 compiler, ban đầu, tất cả source code của bạn sẽ được phân tích cú pháp, chuyển thành AST rồi đẩy vào Full-Codegen Compiler, nơi sẽ cho ra phiên bản machine code đầu tiên của chương trình. Full-Codegen Compiler: Nhiệm vụ là chuyển source code của bạn thành machine code nhanh nhất có thể, khỏi optimize gì luôn. Nó cũng thêm vào một ít type-feedback code thu thập thông tin để phục vụ công việc optimize code sau này. Compiler không tiến hành bất cứ phân tích và không biết gì về kiểu dữ liệu trong source code tại thời điểm này. Để gia tăng hiệu năng, V8 tiếp tục theo dõi chương trình trong runtime bằng một profiler, một thành phần trong kiến trúc của V8, sẽ thu thập thông tin và tìm xem function nào là hot function, tức được dùng đi dùng lại rất nhiều lần, đó là thời điểm cần tiến hành optimize cho một compiled code tốt hơn. Và đó là thời điểm Crankshaft vào cuộc. Optimizing compiler: Crankshaft (và mới đây là TuborFan được thêm vào) đưa ra những dự đoán về function dựa vào những thông tin thu được từ profiler, re-compile và thay thế phần code chưa được optimize bằng cách sử dụng on-stack replacement (OSR). Nếu những giả định là sai lầm, ví dụ nó cho rằng a, b sẽ luôn là number trong phép tính a + b ở đâu đó, và sử dụng thẳng phép cộng 2 số ở đây thay vì lần nào cũng phải kiểm tra kiểu và sử dụng + operator thích hợp, mà bất chợt b lại nhận kiểu là string, thì nó chỉ đơn giản là de-optimizing và tái sử dụng phần code chưa optimize. Đây là cách V8 đối xử với source code của chúng ta: Nguồn ảnh: v8project.blogspot.com Trong năm 2016, một interpreter mang tên Ingition được thêm vào V8 với mục đích giảm thiểu chiếm dụng bộ nhớ trên những hệ thống có memory nhỏ như Android. Efficient Garbage CollectionGarbage collector của V8, được quảng cáo là một stop-the-world, generational, accurate, garbage collector làm nhiệm vụ thu hồi memory đối với những object không còn được process sử dụng một cách rất hiệu quả. Còn nó hiệu quả như thế nào, tại sao hay thậm chí nó có thật sự hiệu quả hơn các engine khác hay không thì mình cũng không rõ. Ban đầu, JavaScript được thiết kế để thực hiện một số nhiệm vụ nhỏ nhoi và ngắn ngủi, ví dụ như đặt một event listener cho một element trên browser, engine lúc ấy chỉ đơn giản là một interpreter đọc và thực thi JavaScript source code. Dần dần, theo thời gian, chúng ta yêu cầu nhiều hơn từ nó. Ứng dụng đầu tiên giao phó những nhiệm vụ nặng nề cho JavaScript là Google Map. Từ đây người ta nhận ra sự cần thiết của một JavaScript nhanh hơn, trong một runtime dài hơi hơn. JIT compilation cần nhiều thời gian để khởi tạo hơn interpretation, nhưng nhanh hơn rất nhiều trong runtime dài. Với những web application dùng nhiều JavaScript của mình, Google đã dành nhiều công sức để thúc đẩy các trình duyệt cải thiện hiệu suất của JavaScript, và V8 ra đời như một kết quả. Giờ đây, một process JavaScript chạy càng lâu, càng được optimize và càng sở hữu hiệu năng cao hơn, mọi người cảm thấy nó đã khả thi để xuất hiện trong một môi trường khắc nghiệt hơn là trên web browser, server-side. JavaScript RuntimeĐược giới thiệu là một JavaScript Runtime, Nodejs có gì khác biệt với một JavaScript Engine? Lấy cảm hứng từ một câu trả lời trên Stackoverflow, chúng ta có thể tạm hiểu như sau: JavaScript chạy trên một container – một chương trình sẽ nhận source code của bạn và thực thi nó. Chương trình này làm hai điều: Phân thích source code và thực thi từng đơn vị có thể. Cung cấp một vài object để JavaScript có thể tương tác với thế giới bên ngoài. Phần đầu, gọi là Engine. Phần còn lại, gọi là Runtime. Trên thực tế, V8 implement một ECMAScript theo đúng chuẩn, tức là những gì ngoài chuẩn thì không có mặt trong V8. Để tương tác với môi trường, V8 cung cấp các lớp template bọc ngoài các object và function viết bởi C++. Các C++ function này có thể làm nhiệm vụ đọc/ghi file system, thao tác networking hoặc giao tiếp với các process khác trong hệ thống. Bằng cách thiết lập một JavaScript context với global scope chứa các JavaScript instance tạo ra từ các template và chạy source code của chúng ta trong context này, mã của chúng ta đã sẵn sàng để giao tiếp với thế giới. Và đó là nhiệm vụ của một Runtime Library: Tạo ra một runtime environment cung cấp các thư viện built-in dưới dạng các biến global để mã của bạn có thể sử dụng trong thời gian chạy, đón nhận source code như là một argument và thực thi nó trong context đã tạo. Với browser runtime environment như Chrome, context mà Chrome cung cấp cho V8 bao gồm các biến global như window, console, DOM object, XMLHttpRequest và timer setTimeout(). Tất cả những thứ ấy đến từ Chrome, không phải từ bản thân V8. Thay vào đó, V8 cung cấp các built-in object chuẩn, có mặt trong mọi environment của JavaScript, được miêu tả trong ECMAScript Standard, bao gồm các kiểu dữ liệu, operator, một số object và function đặc biệt như các value property (Infinity, NaN, null, undefined), Object, Function, Boolean, String, Number, Map, Set, Array, parseInt(), eval(),… Rời xa thế giới browser, rời xa DOM, Nodejs mang đến cho chúng ta nhiều built-in library hơn như fs để giao tiếp với file system, http và https cho networking, tls, tty, cluster, os,… Vấn đề là không phải lúc nào ta cũng cần tất cả những thứ này, việc tạo một context mang quá nhiều global variable không cần thiết như vậy rõ ràng không phải là một cách làm hay. Nodejs bởi vậy nhóm nhiều chức năng vào các module khác nhau và thực hiện một cơ chế module loading thông qua từ khoá require và exports, cho phép tạo ra những context linh động hơn. Tất nhiên, cơ chế này được implement bằng C/C++. Đó là diễn giải đằng sau lời giới thiệu runtime built on Chrome’s V8 JavaScript Engine của Nodejs, và đó là cách mã JavaScript của bạn thao tác với các low-level API, theo một cách đồng bộ (synchronous). V8 chạy mã của bạn trong một single thread, tuần tự từng lệnh một, sử dụng một cấu trúc để quản lý các active subroutine gọi là call stack. Call Stack và Event LoopCall stack không phải là một điều gì đó mới mẻ, thực tế chúng ta luôn luôn phải sử dụng nó để đảm bảm chương trình thực thi một cách đúng đắn, chẳng qua trong các ngôn ngữ bậc cao, việc cung cấp một call stack được ẩn đi và tự động hoá. Nếu push quá nhiều stack frame vào và tiêu tốn hết không gian được cấp cho call stack, chúng ta sẽ đối diện với Stackoverflow huyền thoại. Câu chuyện về call stack của JavaScript có lẽ chúng ta đều đã được nghe kể rất nhiều lần. Ta đều biết rằng stack frame được push mỗi khi một hàm được gọi, và được pop với lệnh return. Sau khi lần lượt xử lý hết các lệnh trong chương trình, call stack trở nên rỗng ruột, một phép màu mang tên event loop sẽ nhặt các hàm callback trong một tạo vật gọi là event queue (hay task queue), đẩy vào trong call stack, và V8 engine tiếp tục thực thi hàm đang nằm trong call stack này. Đây là cách JavaScript thực hiện asynchronous call. Đây cũng là lý do tại sao gọi timer setTimeout() với đối số là 0, hàm callback của chúng ta vẫn phải chờ cho đến khi tất cả code trong chương trình thực thi xong (call stack trở thành empty) thì mới được invoke. Nguồn ảnh: appsdev.is.ed.ac.uk V8 nhận event loop như là một đối số đầu vào khi khởi tạo environment, các môi trường khác nhau sẽ có event loop và API để tạo asynchronous request, thứ mà sẽ đẩy callback function của ta vào trong event queue rồi vật vờ ngồi đợi, của riêng mình. Với Nodejs, event loop implementation của nó là libuv. Thiếu đi libuv, bức tranh về một Nodejs event-driven asynchronous non-blocking I/O sẽ không thể hoàn thiện. V8 thì thậm chí còn chẳng biết I/O là cái gì chứ đừng nói đến blocking hay không blocking. Về libuv và cách nó hoạt động lại là một câu chuyện dài mà thời lượng ở đây không cho phép mình giới thiệu. Xin hẹn được chia sẻ về nó trong một bài viết khác, mà chính xác ra thì là bài viết này: http://sotatek.com/nodejs-hieu-asynchronous-event-drivent-nonblocking-io/ Tổng kếtĐến đây, có lẽ ta đã có thể tự vẽ một bức tranh khá đầy đủ về Nodejs system cho riêng mình. Còn nếu bạn lười vẽ, không sao cả, Richard Key đã vẽ cho bạn rồi đây: Nguồn ảnh: twitter.com/BusyRich","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://nthung2112.github.io/tags/nodejs/"}]},{"title":"Master the JavaScript Interview","slug":"Master-the-JavaScript-Interview","date":"2017-08-20T15:36:07.000Z","updated":"2017-08-20T17:47:13.879Z","comments":true,"path":"2017/08/Master-the-JavaScript-Interview.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Master-the-JavaScript-Interview.html","excerpt":"“Master the JavaScript Interview” is a series of posts designed to prepare candidates for common questions they are likely to encounter when applying for a mid to senior-level JavaScript position. These are questions I frequently use in real interviews. Want to start from the beginning? See “What is a Closure?”","text":"“Master the JavaScript Interview” is a series of posts designed to prepare candidates for common questions they are likely to encounter when applying for a mid to senior-level JavaScript position. These are questions I frequently use in real interviews. Want to start from the beginning? See “What is a Closure?”Note: This article uses ES6 examples. If you haven’t learned ES6 yet, see “How to Learn ES6”. Objects are frequently used in JavaScript, and understanding how to work with them effectively will be a huge win for your productivity. In fact, poor OO design can potentially lead to project failure, and in the worst cases, company failures. Unlike most other languages, JavaScript’s object system is based on prototypes, not classes. Unfortunately, most JavaScript developers don’t understand JavaScript’s object system, or how to put it to best use. Others do understand it, but want it to behave more like class based systems. The result is that JavaScript’s object system has a confusing split personality, which means that JavaScript developers need to know a bit about both prototypes and classes. What’s the Difference Between Class &amp; Prototypal Inheritance?This can be a tricky question, and you’ll probably need to defend your answer with follow-up Q&amp;A, so pay special attention to learning the differences, and how to apply the knowledge to write better code. Class Inheritance: A class is like a blueprint — a description of the object to be created. Classes inherit from classes and create subclass relationships: hierarchical class taxonomies. Instances are typically instantiated via constructor functions with the new keyword. Class inheritance may or may not use the class keyword from ES6. Classes as you may know them from languages like Java don’t technically exist in JavaScript. Constructor functions are used, instead. The ES6 class keyword desugars to a constructor function: 12class Foo &#123;&#125;typeof Foo // 'function' In JavaScript, class inheritance is implemented on top of prototypal inheritance, but that does not mean that it does the same thing: JavaScript’s class inheritance uses the prototype chain to wire the child Constructor.prototype to the parent Constructor.prototype for delegation. Usually, the super() constructor is also called. Those steps form single-ancestor parent/child hierarchies and create the tightest coupling available in OO design. “Classes inherit from classes and create subclass relationships: hierarchical class taxonomies.” Prototypal Inheritance: A prototype is a working object instance. Objects inherit directly from other objects. Instances may be composed from many different source objects, allowing for easy selective inheritance and a flat [[Prototype]] delegation hierarchy. In other words, class taxonomies are not an automatic side-effect of prototypal OO: a critical distinction. Instances are typically instantiated via factory functions, object literals, or Object.create(). “A prototype is a working object instance. Objects inherit directly from other objects.” Why Does this Matter?Inheritance is fundamentally a code reuse mechanism: A way for different kinds of objects to share code. The way that you share code matters because if you get it wrong, it can create a lot of problems, specifically: Class inheritance creates parent/child object taxonomies as a side-effect. Those taxonomies are virtually impossible to get right for all new use cases, and widespread use of a base class leads to the fragile base class problem, which makes them difficult to fix when you get them wrong.In fact, class inheritance causes many well known problems in OO design: The tight coupling problem (class inheritance is the tightest coupling available in oo design), which leads to the next one… The fragile base class problem Inflexible hierarchy problem (eventually, all evolving hierarchies are wrong for new uses) The duplication by necessity problem (due to inflexible hierarchies, new use cases are often shoe-horned in by duplicating, rather than adapting existing code) The Gorilla/banana problem (What you wanted was a banana, but what you got was a gorilla holding the banana, and the entire jungle) I discuss some of the issues in more depth in my talk, “Classical Inheritance is Obsolete: How to Think in Prototypal OO”: The solution to all of these problems is to favor object composition over class inheritance. “Favor object composition over class inheritance.”~ The Gang of Four, “Design Patterns: Elements of Reusable Object Oriented Software” Summed up nicely here: Is All Inheritance Bad?When people say “favor composition over inheritance” that is short for “favor composition over class inheritance” (the original quote from “Design Patterns” by the Gang of Four). This is common knowledge in OO design because class inheritance has many flaws and causes many problems. Often people leave off the word class when they talk about class inheritance, which makes it sound like all inheritance is bad — but it’s not. There are actually several different kinds of inheritance, and most of them are great. Three Different Kinds of Prototypal InheritanceBefore we dive into the other kinds of inheritance, let’s take a closer look at what I mean by class inheritance: You can experiment with this example on Codepen. BassAmp inherits from GuitarAmp, and ChannelStrip inherits from BassAmp &amp; GuitarAmp. This is an example of how OO design goes wrong. A channel strip isn’t actually a type of guitar amp, and doesn’t actually need a cabinet at all. A better option would be to create a new base class that both the amps and the channel strip inherits from, but even that has limitations. Eventually, the new shared base class strategy breaks down, too. There’s a better way. You can inherit just the stuff you really need using object composition: Experiment with this on CodePen. If you look carefully, you might see that we’re being much more specific about which objects get which properties because with composition, we can. It wasn’t really an option with class inheritance. When you inherit from a class, you get everything, even if you don’t want it. At this point, you may be thinking to yourself, “that’s nice, but where are the prototypes?” To understand that, you have to understand that there are three different kinds of prototypal OO. Concatenative inheritance: The process of inheriting features directly from one object to another by copying the source objects properties. In JavaScript, source prototypes are commonly referred to as mixins. Since ES6, this feature has a convenience utility in JavaScript called Object.assign(). Prior to ES6, this was commonly done with Underscore/Lodash’s .extend() jQuery’s $.extend(), and so on… The composition example above uses concatenative inheritance. Prototype delegation: In JavaScript, an object may have a link to a prototype for delegation. If a property is not found on the object, the lookup is delegated to the delegate prototype, which may have a link to its own delegate prototype, and so on up the chain until you arrive at Object.prototype, which is the root delegate. This is the prototype that gets hooked up when you attach to a Constructor.prototype and instantiate with new. You can also use Object.create() for this purpose, and even mix this technique with concatenation in order to flatten multiple prototypes to a single delegate, or extend the object instance after creation. Functional inheritance: In JavaScript, any function can create an object. When that function is not a constructor (or class), it’s called a factory function. Functional inheritance works by producing an object from a factory, and extending the produced object by assigning properties to it directly (using concatenative inheritance). Douglas Crockford coined the term, but functional inheritance has been in common use in JavaScript for a long time. As you’re probably starting to realize, concatenative inheritance is the secret sauce that enables object composition in JavaScript, which makes both prototype delegation and functional inheritance a lot more interesting. When most people think of prototypal OO in JavaScript, they think of prototype delegation. By now you should see that they’re missing out on a lot. Delegate prototypes aren’t the great alternative to class inheritance — object composition is. Why Composition is Immune to the Fragile Base Class ProblemTo understand the fragile base class problem and why it doesn’t apply to composition, first you have to understand how it happens: A is the base class B inherits from A C inherits from B D inherits from B C calls super, which runs code in B. B calls super which runs code in A. A and B contain unrelated features needed by both C &amp; D. D is a new use case, and needs slightly different behavior in A’s init code than C needs. So the newbie dev goes and tweaks A’s init code. __**_C_ breaks because it depends on the existing behavior**, and D starts working. What we have here are features spread out between A and B that C and D need to use in various ways. C and D don’t use every feature of A and B… they just want to inherit some stuff that’s already defined in A and B. But by inheriting and calling super, you don’t get to be selective about what you inherit. You inherit everything: “…the problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.” ~ Joe Armstrong — “Coders at Work” With CompositionImagine you have features instead of classes: 1feat1, feat2, feat3, feat4 C needs feat1 and feat3, D needs feat1, feat2, feat4: 12const C = compose(feat1, feat3);const D = compose(feat1, feat2, feat4); Now, imagine you discover that D needs slightly different behavior from feat1. It doesn’t actually need to change feat1, instead, you can make a customized version of feat1 and use that, instead. You can still inherit the existing behaviors from feat2 and feat4 with no changes: 1const D = compose(custom1, feat2, feat4); And __**_C_ remains unaffected**. The reason this is not possible with class inheritance is because when you use class inheritance, you buy into the whole existing class taxonomy. If you want to adapt a little for a new use-case, you either end up duplicating parts of the existing taxonomy (the duplication by necessity problem), or you refactor everything that depends on the existing taxonomy to adapt the taxonomy to the new use case due to the fragile base class problem. Composition is immune to both. You Think You Know Prototypes, but…If you were taught to build classes or constructor functions and inherit from those, what you were taught was not prototypal inheritance. You were taught how to mimic class inheritance using prototypes. See “Common Misconceptions About Inheritance in JavaScript”. In JavaScript, class inheritance piggybacks on top of the very rich, flexible prototypal inheritance features built into the language a long time ago, but when you use class inheritance — even the ES6+ class inheritance built on top of prototypes, you’re not using the full power &amp; flexibility of prototypal OO. In fact, you’re painting yourself into corners and opting into all of the class inheritance problems. Using class inheritance in JavaScript is like driving your new Tesla Model S to the dealer and trading it in for a rusted out 1983 Ford Pinto. Stamps: Composable Factory FunctionsMost of the time, composition is achieved using factory functions: functions which exist to create object instances. What if there was a standard that makes factory functions composable? There is. It’s called The Stamp Specification. Explore the Series What is a Closure? What is the Difference Between Class and Prototypal Inheritance? What is a Pure Function? What is Function Composition? What is Functional Programming? What is a Promise? Soft Skills Level Up Your Skills with Live 1:1 MentorshipDevAnywhere is the fastest way to level up to advanced JavaScript skills: Live lessons Flexible hours 1:1 mentorship Build real production apps https://devanywhere.io/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"interview","slug":"interview","permalink":"http://nthung2112.github.io/tags/interview/"}]},{"title":"Giải thích keyword 'new' trong Javascript","slug":"Giai-thich-keyword-new-trong-Javascript","date":"2017-08-20T15:21:52.000Z","updated":"2017-08-20T17:47:47.594Z","comments":true,"path":"2017/08/Giai-thich-keyword-new-trong-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Giai-thich-keyword-new-trong-Javascript.html","excerpt":"Normal Function CallTo explain what new does, let’s start with just a normal function, called without new. We want to write a function that will create “person” objects. It’ll give these objects name and age properties based on parameters that it takes in.","text":"Normal Function CallTo explain what new does, let’s start with just a normal function, called without new. We want to write a function that will create “person” objects. It’ll give these objects name and age properties based on parameters that it takes in. 123456789function personFn(name, age) &#123; var personObj = &#123;&#125;; personObj.name = name; personObj.age = age; return personObj;&#125;var alex = personFn('Alex', 30);// -&gt; &#123; name: 'Alex', age: 30 &#125; Simple enough. We create an object, add the properties to it, and return it at the end. newObject-oriented programming Let’s create a function that does the same thing, but we want it to be invoked using new. This function will create the same object as the one above. Common practice is to make functions that are meant to be invoked with new start with a capital letter. These functions are also referred to as constructors. 123456function PersonConstructor(name, age) &#123; this.name = name; this.age = age;&#125;var alex = new PersonConstructor('Alex', 30);// -&gt; &#123; name: 'Alex', age: 30 &#125; Invoking personFn normally and invoking PersonConstructor with new both result in the same object being created. What’s going on? The new keyword invokes a function in a special way. It adds some implicit code that we don’t see. Let’s expand the above function to show everything that’s happening. The commented lines are pseudocode representing functionality that is implicitly added by the JS engine when using new. 12345678910111213141516function PersonConstructor(name, age) &#123; // this = &#123;&#125;; // this.__proto__ = PersonConstructor.prototype; // Set up logic such that: if // there is a return statement // in the function body that // returns anything EXCEPT an // object, array, or function: // return 'this' (the newly // constructed object) // instead of that item at // the return statement; this.name = name; this.age = age; // return this;&#125; Let’s break it down. new: Creates a new object and binds it to the this keyword. Sets the object’s internal [[Prototype]], property, &#95;&#95;proto&#95;&#95;, to be the prototype of the constructing function. This also makes it so the constructor of the new object is prototypically inherited. Sets up logic such that if a variable of any type other than object, array, or function is returned in the function body, return this, the newly constructed object, instead of what the function says to return. At the end of the function, returns this if there is no return statement in the function body. Let’s show that these statements are valid, one by one. 12345678910111213function Demo() &#123; console.log(this); this.value = 5; return 10;&#125;/*1*/ var demo = new Demo(); // -&gt; &#123;&#125;/*2*/ console.log(demo.__proto__ === Demo.prototype); // -&gt; true console.log(demo.constructor === Demo); // -&gt; true/*3*/ console.log(demo); // -&gt; &#123; value: 5 &#125;function SecondDemo() &#123; this.val = '2nd demo';&#125;/*4*/ console.log(new SecondDemo()); // -&gt; &#123; val: '2nd demo' &#125; If you aren’t familiar with constructors or prototypes, don’t worry about it too much. You’ll run into them as you continue to learn Javascript. For now, just understand that the new object implicitly returned by the constructor function will be able to inherit properties and methods. Calling a non-constructor with newWhat happens if we invoke a normal function like personFn using new? Nothing special. The same rules apply. in the case of personFn, we see nothing explicitly happening. 12var alex = new personFn('Alex', 30);// -&gt; &#123; name: 'Alex', age: 30 &#125; Why? Let’s add our implicit code in to personFn. 123456789101112131415161718192021function personFn(name, age) &#123; // this = &#123;&#125;; // this.constructor = PersonConstructor; // this.__proto__ = PersonConstructor.prototype; // Set up logic such that: if // there is a return statement // in the function body that // returns anything EXCEPT an // object, array, or function: // return this (the newly // constructed object) // instead of that item at // the return statement; var personObj = &#123;&#125;; personObj.name = name; personObj.age = age; return personObj; // return this;&#125; The implicit code is still added in: It binds this to a new object and sets its constructor and prototype. It adds logic that will return this instead of a non-object. It adds an implicit return this statement at the end. This doesn’t affect our code, since we don’t use the this keyword in our code. We also explicitly return an object, personObj, so the returning logic and the return this line have no use. Effectively, using new to invoke our function here has no effect on the output. If we were using this or if we weren’t returning an object, the function would have different effects when invoked with and without new. That’s it. Go write some code.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"A Jade Tutorial for Beginners","slug":"A-Jade-Tutorial-for-Beginners","date":"2017-08-20T14:57:13.000Z","updated":"2017-08-20T15:07:42.818Z","comments":true,"path":"2017/08/A-Jade-Tutorial-for-Beginners.html","link":"","permalink":"http://nthung2112.github.io/2017/08/A-Jade-Tutorial-for-Beginners.html","excerpt":"Jade is an elegant templating engine, primarily used for server-side templating in NodeJS. In plain words, Jade gives you a powerful new way to write markup, with a number of advantages over plain HTML. For example, take a look at this movie card in HTML: 123456789&lt;div&gt; &lt;h1&gt;Ocean's Eleven&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Comedy&lt;/li&gt; &lt;li&gt;Thriller&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Danny Ocean and his eleven accomplices plan to rob three Las Vegas casinos simultaneously.&lt;/p&gt;&lt;/div&gt;","text":"Jade is an elegant templating engine, primarily used for server-side templating in NodeJS. In plain words, Jade gives you a powerful new way to write markup, with a number of advantages over plain HTML. For example, take a look at this movie card in HTML: 123456789&lt;div&gt; &lt;h1&gt;Ocean's Eleven&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Comedy&lt;/li&gt; &lt;li&gt;Thriller&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Danny Ocean and his eleven accomplices plan to rob three Las Vegas casinos simultaneously.&lt;/p&gt;&lt;/div&gt; This is what the same markup looks like in Jade: 12345678div h1 Ocean&apos;s Eleven ul li Comedy li Thriller p. Danny Ocean and his eleven accomplices plan to rob three Las Vegas casinos simultaneously. The Jade version is elegant and concise. But it’s not just about the beautiful syntax. Jade has some really neat features, allowing you to write modular and reusable markup. Before we get into these powerful features, let’s do a quick overview of the basics. The BasicsI’m going to highlight three basic features in Jade Simple tags Adding attributes to the tags Blocks of text If you want to try this out as we go along, you can use CodePen and choose Jade as your HTML preprocessor or use the online compiler on the official Jade page to compile your Jade to HTML. Simple TagsAs you might have noticed earlier, there are no “closing” tags in Jade. Instead, Jade uses indentation (i.e. white space) to determine how tags are nested. 123div p Hello! p World! In the example above, since the paragraph tags are indented, they will end up inside the div tag. Simple! 1234&lt;div&gt; &lt;p&gt;Hello!&lt;/p&gt; &lt;p&gt;World!&lt;/p&gt;&lt;/div&gt; Jade compiles this accurately by treating the first word on each line as a tag, while subsequent words on that line are treated as text inside the tag. View this example on CodePen AttributesAll this is great, but how do we add attributes to our tags? Quite simple really. Let’s go back to our first example and toss in some classes and a poster image. 123456div(class=&quot;movie-card&quot;, id=&quot;oceans-11&quot;) h1(class=&quot;movie-title&quot;) Ocean&apos;s 11 img(src=&quot;/img/oceans-11.png&quot;, class=&quot;movie-poster&quot;) ul(class=&quot;genre-list&quot;) li Comedy li Thriller Pretty neat right? 12345678&lt;div class=\"movie-card\" id=\"oceans-11\"&gt; &lt;h1 class=\"movie-title\"&gt;Ocean's 11&lt;/h1&gt; &lt;img src=\"/img/oceans-11.png\" class=\"movie-poster\"&gt; &lt;ul class=\"genre-list\"&gt; &lt;li&gt;Comedy&lt;/li&gt; &lt;li&gt;Thriller&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; View this example on CodePen But it doesn’t stop here. Jade provides special shorthand for IDs and classes, further simplifying our markup using a familiar notation: 123456div.movie-card#oceans-11 h1.movie-title Ocean&apos;s 11 img.movie-poster(src=&quot;/img/oceans-11.png&quot;) ul.genre-list li Comedy li Thriller View this example on CodePen As you can see, Jade uses the same syntax as that which we’re already familiar with when writing CSS selectors, making it even easier to spot classes. Blocks of TextLet’s say you have a paragraph tag and you want to place a large block of text in it. Jade treats the first word of every line as an HTML tag – so what do you do? You might have noticed an innocent period in the first code example in this article. Adding a period (full stop) after your tag indicates that everything inside that tag is text and Jade stops treating the first word on each line as an HTML tag. 123456div p How are you? p. I&apos;m fine thank you. And you? I heard you fell into a lake? That&apos;s rather unfortunate. I hate it when my shoes get wet. View this example on CodePen And just to drive home the point, if I were to remove the period after the p tag in this example, the compiled HTML would treat the “I” in the word “I’m” as an opening tag (in this case, it would be the &lt;i&gt; tag). Powerful FeaturesNow that we’ve covered the basics, let’s take a peek at some powerful features that will make your markup smarter. We’ll look at the following features in remainder of this tutorial: Loops JavaScript Interpolation Mixins Using JavaScript in JadeJade is implemented with JavaScript, so it’s super-easy to use JavaScript in Jade. Here’s an example. 123456- var x = 5;div ul - for (var i=1; i&lt;=x; i++) &#123; li Hello - &#125; What did we just do here?! By starting a line with a hyphen, we indicate to the Jade compiler that we want to start using JavaScript and it just works as we would expect. Here’s what you get when you compile the Jade code above to HTML: 123456789&lt;div&gt; &lt;ul&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; View this example on CodePen We use a hyphen when the code doesn’t directly add output. If we want to use JavaScript to output something in Jade, we use =. Let’s tweak the code above to show a serial number. 123456- var x = 5;div ul - for (var i=1; i&lt;=x; i++) &#123; li= i + &quot;. Hello&quot; - &#125; And voilà, we now have serial numbers: 123456789&lt;div&gt; &lt;ul&gt; &lt;li&gt;1\\. Hello&lt;/li&gt; &lt;li&gt;2\\. Hello&lt;/li&gt; &lt;li&gt;3\\. Hello&lt;/li&gt; &lt;li&gt;4\\. Hello&lt;/li&gt; &lt;li&gt;5\\. Hello&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; View this example on CodePen Of course, in this case, an ordered list would be much more appropriate, but you get the point. Now, if you’re worried about XSS and HTML escaping, read the docs for more info. LoopsJade provides an excellent looping syntax so that you don’t need to resort to JavaScript. Let’s loop over an array: 123456- var droids = [&quot;R2D2&quot;, &quot;C3PO&quot;, &quot;BB8&quot;];div h1 Famous Droids from Star Wars for name in droids div.card h2= name And this will compile as follows: 123456789101112&lt;div&gt; &lt;h1&gt;Famous Droids from Star Wars&lt;/h1&gt; &lt;div class=\"card\"&gt; &lt;h2&gt;R2D2&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"card\"&gt; &lt;h2&gt;C3PO&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"card\"&gt; &lt;h2&gt;BB8&lt;/h2&gt; &lt;/div&gt;&lt;/div&gt; View this example on CodePen You can iterate over objects and use while loops too. Check out the docs for more. InterpolationIt can get annoying to mix JavaScript into text like this p= &quot;Hi there, &quot; + profileName + &quot;. How are you doing?&quot;. Does Jade have an elegant solution for this? You bet. 123- var profileName = &quot;Danny Ocean&quot;;div p Hi there, #&#123;profileName&#125;. How are you doing? View this example on CodePen Isn’t that neat? MixinsMixins are like functions. They take parameters as input and give markup as output. Mixins are defined using the mixin keyword. 1234mixin thumbnail(imageName, caption) div.thumbnail img(src=&quot;/img/#&#123;imageName&#125;.jpg&quot;) h4.image-caption= caption Once the mixin is defined, you can call the mixin with the + syntax. 12+thumbnail(&quot;oceans-eleven&quot;, &quot;Danny Ocean makes an elevator pitch.&quot;)+thumbnail(&quot;pirates&quot;, &quot;Introducing Captain Jack Sparrow!&quot;) Which will output HTML like this: 123456789101112&lt;div class=\"thumbnail\"&gt; &lt;img src=\"/img/oceans-eleven.jpg\"&gt; &lt;h4 class=\"image-caption\"&gt; Danny Ocean makes an elevator pitch. &lt;/h4&gt;&lt;/div&gt;&lt;div class=\"thumbnail\"&gt; &lt;img src=\"/img/pirates.jpg\"&gt; &lt;h4 class=\"image-caption\"&gt; Introducing Captain Jack Sparrow! &lt;/h4&gt;&lt;/div&gt; Putting It All TogetherLet’s put together everything we’ve learned so far. Say we have a nice array of movies, with each item containing the movie’s title, the cast (a sub-array), the rating, the genre, a link to the IMDB page and the image path for the movie’s poster. The array will look something like this (white space added for readability): 1234567891011- var movieList = [ &#123; title: \"Ocean's Eleven\", cast: [\"Julia Roberts\", \"George Clooney\", \"Brad Pitt\", \"Andy Garcia\"], genres: [\"Comedy\", \"Thriller\"], posterImage: \"/img/oceans-eleven\", imdbURL: \"http://www.imdb.com/title/tt0240772/\", rating: 7 &#125; // etc...]; We have 10 movies and we want to build nice movie cards for each of them. Initially, we don’t plan to use the IMDB link. If a movie is rated above 5, we give it a thumbs up, otherwise, we give it a thumbs down. We’ll use all the nice features of Jade to write some modular code to do the following: Create a mixin for a movie card Iterate through the cast list and display the actors. We’ll do the same with genres. Check the rating and decide whether to display a thumbs up or a thumbs down. Iterate through the movie list and use the mixin to create one card per movie. So let’s create the mixin first. 12345678910111213141516mixin movie-card(movie) div.movie-card h2.movie-title= movie.title img.movie-poster(src=movie.posterImage) h3 Cast ul.cast each actor in movie.cast li= actor div.rating if movie.rating &gt; 5 img(src=&quot;img/thumbs-up&quot;) else img(src=&quot;img/thumbs-down&quot;) ul.genre each genre in movie.genres li= genre There’s a lot going on up there, but I’m sure it looks familiar – we’ve covered all this in this tutorial. Now, we just need to use our mixin in a loop: 12for movie in movieList +movie-card(movie) That’s it. Is that elegant or what? Here’s the final code. 1234567891011121314151617181920212223242526272829303132333435363738- var movieList = [ &#123; title: &quot;Ocean&apos;s Eleven&quot;, cast: [&quot;Julia Roberts&quot;, &quot;George Clooney&quot;, &quot;Brad Pitt&quot;, &quot;Andy Garcia&quot;], genres: [&quot;Comedy&quot;, &quot;Thriller&quot;], posterImage: &quot;/img/oceans-eleven&quot;, imdbURL: &quot;http://www.imdb.com/title/tt0240772/&quot;, rating: 9.2 &#125;, &#123; title: &quot;Pirates of the Caribbean&quot;, cast: [&quot;Johnny Depp&quot;, &quot;Keira Knightley&quot;, &quot;Orlando Bloom&quot;], genres: [&quot;Adventure&quot;, &quot;Comedy&quot;], posterImage: &quot;/img/pirates-caribbean&quot;, imdbURL: &quot;http://www.imdb.com/title/tt0325980/&quot;, rating: 9.7 &#125;];mixin movie-card(movie) div.movie-card h2.movie-title= movie.title img.movie-poster(src=movie.posterImage) h3 Cast ul.cast each actor in movie.cast li= actor div.rating if movie.rating &gt; 5 img(src=&quot;img/thumbs-up&quot;) else img(src=&quot;img/thumbs-down&quot;) ul.genre each genre in movie.genres li= genrefor movie in movieList +movie-card(movie) And here’s the compiled HTML: 1234567891011121314151617181920212223242526272829303132333435&lt;div class=\"movie-card\"&gt; &lt;h2 class=\"movie-title\"&gt;Ocean's Eleven&lt;/h2&gt; &lt;img src=\"/img/oceans-eleven\" class=\"movie-poster\"/&gt; &lt;h3&gt;Cast&lt;/h3&gt; &lt;ul class=\"cast\"&gt; &lt;li&gt;Julia Roberts&lt;/li&gt; &lt;li&gt;George Clooney&lt;/li&gt; &lt;li&gt;Brad Pitt&lt;/li&gt; &lt;li&gt;Andy Garcia&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"rating\"&gt; &lt;img src=\"img/thumbs-up\"/&gt; &lt;/div&gt; &lt;ul class=\"genre\"&gt; &lt;li&gt;Comedy&lt;/li&gt; &lt;li&gt;Thriller&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class=\"movie-card\"&gt; &lt;h2 class=\"movie-title\"&gt;Pirates of the Carribean&lt;/h2&gt; &lt;img src=\"/img/pirates-caribbean\" class=\"movie-poster\"/&gt; &lt;h3&gt;Cast&lt;/h3&gt; &lt;ul class=\"cast\"&gt; &lt;li&gt;Johnny Depp&lt;/li&gt; &lt;li&gt;Keira Knightley&lt;/li&gt; &lt;li&gt;Orlando Bloom&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"rating\"&gt; &lt;img src=\"img/thumbs-up\"/&gt; &lt;/div&gt; &lt;ul class=\"genre\"&gt; &lt;li&gt;Adventure&lt;/li&gt; &lt;li&gt;Comedy&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; But wait a minute. What if we now want to go to the movie’s IMDB page when we click on a movie’s title? We can add one line: a(href=movie.imdbURL) to the mixin. 1234567891011121314151617mixin movie-card(movie) div.movie-card a(href=movie.imdbURL) h2.movie-title= movie.title img.movie-poster(src=movie.posterImage) h3 Cast ul.cast each actor in movie.cast li= actor div.rating if movie.rating &gt; 5 img(src=&quot;img/thumbs-up&quot;) else img(src=&quot;img/thumbs-down&quot;) ul.genre each genre in movie.genres li= genre View this example on CodePen ConclusionWe went from knowing nothing about Jade to building some beautiful modular movie cards. There’s a lot more to Jade, but I’ve glossed over some concepts to keep things simple. So I hope this tutorial piqued your curiosity to learn more. Important note: As some of you might already know, Jade has been renamed to Pug due to a software trademark claim. In the future, articles on Jade will use the new name “Pug” or “PugJS”.","categories":[],"tags":[{"name":"jade","slug":"jade","permalink":"http://nthung2112.github.io/tags/jade/"},{"name":"html","slug":"html","permalink":"http://nthung2112.github.io/tags/html/"}]},{"title":"Reducing CSS bundle size with webpack","slug":"reducing-css-bundle-size-with-webpack","date":"2017-08-20T08:41:31.000Z","updated":"2017-08-20T14:50:45.892Z","comments":true,"path":"2017/08/reducing-css-bundle-size-with-webpack.html","link":"","permalink":"http://nthung2112.github.io/2017/08/reducing-css-bundle-size-with-webpack.html","excerpt":"Đầu năm nay tôi đã build 1 ứng dụng tên là GO2CINEMA, 1 ứng dụng nhỏ gọn, nhanh nhẹ, bảo mật, giúp người dùng book vé xem phim ở Anh. Trong thời gian build ứng dụng này, tôi đã bị ám ảnh với việc tối ưu hóa tốc độ render. Tôi đã giải quyết việc pre-render HTML bằng usus. usus sẽ render HTML SPA (Single Page Application) và sử dụng inline CSS. Tuy nhiên tôi không thích việc nhét đến 70kB dung lượng vào mỗi tài liệu HTML, nhất là khi phần lớn dung lượng đó là để chứa tên class CSS.","text":"Đầu năm nay tôi đã build 1 ứng dụng tên là GO2CINEMA, 1 ứng dụng nhỏ gọn, nhanh nhẹ, bảo mật, giúp người dùng book vé xem phim ở Anh. Trong thời gian build ứng dụng này, tôi đã bị ám ảnh với việc tối ưu hóa tốc độ render. Tôi đã giải quyết việc pre-render HTML bằng usus. usus sẽ render HTML SPA (Single Page Application) và sử dụng inline CSS. Tuy nhiên tôi không thích việc nhét đến 70kB dung lượng vào mỗi tài liệu HTML, nhất là khi phần lớn dung lượng đó là để chứa tên class CSS. Google xử lý như thế nào?Đã bao giờ bạn tò mò về source code của Google chưa? Nếu rồi, hẳn bạn sẽ nhận ra tên class CSS chỉ đơn giản là vài ký tự. Bạn có thắc mắc tại sao lại thế không? Sự thiếu sót của CSS minifierCó 1 thứ duy nhất minifier không thể làm được: đó là thay đổi tên của selector. Lý do là vì minifier CSS không điều khiển được các HTML output. Trong lúc đó, các CSS name có thể rất dài. Nếu bạn sử dụng CSS module, CSS module sẽ có xu hướng thêm các tên cho stylesheet, local identifier và các hash ngẫu nhiên. Dạng của tên class sẽ được định nghĩa bởi css-loader localIdentName, config như sau: [name]___[local]___[hash:base64:5. Do đó, tên class sẽ được sinh ra có dạng giống thế: .MovieView___movie-title___yvKVV; trong trường hợp bạn muốn mô tả kĩ hơn, tên class có thể còn dài nữa: .MovieView___movie-description-with-summary-paragraph___yvKVV Thay đổi tên class CSS ngay thời điểm biên dịchNếu bạn sử dụng webpack và babel-plugin-react-css-module thì bạn không cần lo lắng thêm về vấn đề này nữa. Bạn có thể thay đổi tên class ngay thời điểm biên dịch bằng cách sử dụng css-loader getLocalIdent và babel-plugin-react-css-modules generateScopedName. 1234567const generateScopedName = ( localName: string, resourcePath: string) =&gt; &#123; const componentName = resourcePath.split('/').slice(-2, -1);return componentName + '_' + localName;&#125;; Có 1 điều khá tuyệt về generateScopedName đó là instance của function này có thể được sử dụng trong quá trình build của babel và webpack. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @file Webpack configuration. */const path = require('path');const generateScopedName = (localName, resourcePath) =&gt; &#123; const componentName = resourcePath.split('/').slice(-2, -1); return componentName + '_' + localName;&#125;;module.exports = &#123; module: &#123; rules: [ &#123; include: path.resolve(__dirname, '../app'), loader: 'babel-loader', options: &#123; babelrc: false, extends: path.resolve(__dirname, '../app/webpack.production.babelrc'), plugins: [ [ 'react-css-modules', &#123; context: common.context, filetypes: &#123; '.scss': &#123; syntax: 'postcss-scss' &#125; &#125;, generateScopedName, webpackHotModuleReloading: false &#125; ] ] &#125;, test: /\\.js$/ &#125;, &#123; test: /\\.scss$/, use: [ &#123; loader: 'css-loader', options: &#123; camelCase: true, getLocalIdent: (context, localIdentName, localName) =&gt; &#123; return generateScopedName(localName, context.resourcePath); &#125;, importLoaders: 1, minimize: true, modules: true &#125; &#125;, 'resolve-url-loader' ] &#125; ] &#125;, output: &#123; filename: '[name].[chunkhash].js', path: path.join(__dirname, './.dist'), publicPath: '/static/' &#125;, stats: 'minimal'&#125;; Đặt tên ngắnMay mắn rằng babel-plugin-react-css-modules và css-loader sử dụng cùng 1 logic để sinh ra tên class CSS. Nhờ đó ta có thể thay đổi tên class bất cứ khi nào cần thiết, thậm chí các hash ngẫu nhiên. Cá nhân tôi thì lại muốn tên class ngắn nhất có thể. Để làm được điều này, tôi sẽ tạo 1 class name index và sử dụng module incstr để sinh ra các ID tăng dần cho mỗi bản ghi. 123456789101112131415161718192021222324252627282930313233343536const incstr = require('incstr');const createUniqueIdGenerator = () =&gt; &#123; const index = &#123;&#125;; const generateNextId = incstr.idGenerator(&#123; // Removed \"d\" letter to avoid accidental \"ad\" construct. // @see https://medium.com/@mbrevda/just-make-sure-ad-isnt-being-used-as-a-class-name-prefix-or-you-might-suffer-the-wrath-of-the-558d65502793 alphabet: 'abcefghijklmnopqrstuvwxyz0123456789' &#125;); return (name) =&gt; &#123; if (index[name]) &#123; return index[name]; &#125; let nextId; do &#123; // Class name cannot start with a number. nextId = generateNextId(); &#125; while (/^[0-9]/.test(nextId)); index[name] = generateNextId(); return index[name]; &#125;;&#125;;const uniqueIdGenerator = createUniqueIdGenerator();const generateScopedName = (localName, resourcePath) =&gt; &#123; const componentName = resourcePath.split('/').slice(-2, -1); return uniqueIdGenerator(componentName) + '_' + uniqueIdGenerator(localName);&#125;; Việc này sẽ đảm bảo được tên class sẽ đủ ngắn và duy nhất trong cả ứng dụng. Bây giờ thay vì là những cái tên dài ngoằng như .MovieView___movie-title___yvKVV và .MovieView___movie-description-with-summary-paragraph___yvKVV, tên class đã trở thành .a_a, .b_a. Nhờ đó mà kích thước file bundle css của GO2CINEMA đã giảm từ 140kB xuống còn 53kB. Sử dụng Scope Isolation để giảm kích thước file bundleCó 1 lý do cho việc tôi sử dụng _ trong tên class, chia tách tên các component với tên các local identifier, điều này rất hữu ích cho quá trình minify. csso (CSS minifier) có những thiết lập về scope. Scope sẽ định nghĩa các danh sách tên class CSS để sử dụng với 1 số markup, ví dụ các selector từ các scope khác nhau sẽ không nối với các element giống nhau. Việc này sẽ giúp cho việc optimize chủ động hơn. Dưới đây là code sử dụng csso-webpack-plugin để tiền xử lý file bundle CSS: 12345678910111213141516171819202122232425262728293031const getScopes = (ast) =&gt; &#123; const scopes = &#123;&#125;; const getModuleID = (className) =&gt; &#123; const tokens = className.split('_')[0]; if (tokens.length !== 2) &#123; return 'default'; &#125; return tokens[0]; &#125;; csso.syntax.walk(ast, node =&gt; &#123; if (node.type === 'ClassSelector') &#123; const moduleId = getModuleID(node.name); if (moduleId) &#123; if (!scopes[moduleId]) &#123; scopes[moduleId] = []; &#125; if (!scopes[moduleId].includes(node.name)) &#123; scopes[moduleId].push(node.name); &#125; &#125; &#125; &#125;); return Object.values(scopes);&#125;; Quá trình này tiếp tục giảm kích thước file bundle CSS của GO2CINEMA từ 53kB còn 47kB. Kết luậnHẳn sẽ có những ý kiến trái chiều nói rằng việc minify này hoàn toàn có thể dùng thuật toán nén. Với GO2CINEMA, fle bundle CSS sau khi được nén bằng thuật toán Brotli thì kích thước của nó chỉ ít hơn 1kB so với cách minify file bundle bỏ-tên-class tôi đã trình bày trên. Mặt khác, cài đặt quá trình minify có thể xem như là 1 khoản đầu tư dài hạn. Ngoài việc giảm kích thước file cần parse, nó còn có những lợi ích khác nữa, ví dụ như ngăn chặn việc tên class CSS không bị nối với các selector của blocklist ad-blocker chẳng hạn. Bạn có thể xem demo của minification này được sử dụng với các phim trên GO2CINEMA: https://go2cinema.com/movies/wonder-woman-2017-1305237 https://go2cinema.com/venues/odeon-oxford-magdalen-st-1001053","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"webpack","slug":"webpack","permalink":"http://nthung2112.github.io/tags/webpack/"}]},{"title":"How to Create a Reddit Clone Using React and Firebase","slug":"How-to-Create-a-Reddit-Clone-Using-React-and-Firebase","date":"2017-07-23T09:48:27.000Z","updated":"2017-08-20T14:50:38.595Z","comments":true,"path":"2017/07/How-to-Create-a-Reddit-Clone-Using-React-and-Firebase.html","link":"","permalink":"http://nthung2112.github.io/2017/07/How-to-Create-a-Reddit-Clone-Using-React-and-Firebase.html","excerpt":"React is an awesome JavaScript library for building user interfaces. Since the publishing of Create React App, it has become very easy to scaffold a barebones React application. In this article, we will be using Firebase along with Create React App to build an app which will function similar to Reddit. It will allow the user to submit a new link which can then be voted on. Here’s a live demo of what we’ll be building.","text":"React is an awesome JavaScript library for building user interfaces. Since the publishing of Create React App, it has become very easy to scaffold a barebones React application. In this article, we will be using Firebase along with Create React App to build an app which will function similar to Reddit. It will allow the user to submit a new link which can then be voted on. Here’s a live demo of what we’ll be building. Why Firebase?Using Firebase will make it very easy for us to show real-time data to the user. Once a user votes on a link, the feedback will be instantaneous. Firebase’s Realtime Database will help us in developing this feature. Also, it will help us to understand how to bootstrap a React application with Firebase. Why React?React is particularly known for creating user interfaces using a component architecture. Each component can contain internal state or be passed data as props. State and props are the two most important concepts in React. These two things help us determine the state of our application at any point in time. If you are not familiar with these terms, please head over to the React docs first. Note: You can also use a state container like Redux or MobX, but for the sake of simplicity, we won’t be using one for this tutorial. The whole project is available on Github. By the way, for a high-quality, in-depth introduction to React, you can’t go past Canadian full-stack developer Wes Bos. Try his course, and use the coupon code ‘SITEPOINT’ to get 25% off and to help support SitePoint. Setting up the projectLet’s walk through the steps to set up our project structure and any necessary dependencies. Installing create-react-appIf you haven’t already, you need to install create-react-app. To do so, you can type the following in your terminal: 1npm install -g create-react-app Once you’ve installed it globally, you can use it to scaffold a React project inside any folder. Now, let’s create a new app and call it reddit-clone. 1create-react-app reddit-clone This will scaffold a new create-react-app project inside the reddit-clone folder. Once the bootstrapping is done, we can go inside reddit-clone directory and fire up the development server: 1npm start At this point, you can go to http://localhost:3000/ and see your app skeleton up and running. Structuring the appFor maintenance, I always like to separate my containers and components. Containers are the smart components which are contains the business logic of our application and manage Ajax requests. Components are simply dumb presentational components. They can have their own internal state which can be used to control the logic of that component (e.g. showing the current state of a controlled input component). After removing the unnecessary logo and css files, this is how your app should look like now. We created a components folder and a containers folder. Let’s move App.js inside the containers/App folder and create registerServiceWorker.js inside the utils folder. Your src/containers/App/index.js file should look like this: 123456789101112131415// src/containers/App/index.jsimport React, &#123; Component &#125; from 'react';class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; Hello World &lt;/div&gt; ); &#125;&#125;export default App; Your src/index.js file should look like this: 123456789// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import App from './containers/App';import registerServiceWorker from './utils/registerServiceWorker';ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));registerServiceWorker(); Go to your browser and if every thing works fine you will see Hello World on your screen. You can check my commit on Github. Adding react-routerReact-router will help us define the routes for our app. It’s very customizable and very popular in the react ecosystem. We will be using version 3.0.0 of react-router. 1npm install --save react-router@3.0.0 Now, add a new file routes.js inside the src folder with the following code: 123456789101112131415// routes.jsimport React from 'react';import &#123; Router, Route &#125; from 'react-router';import App from './containers/App';const Routes = (props) =&gt; ( &lt;Router &#123;...props&#125;&gt; &lt;Route path=\"/\" component=&#123; App &#125;&gt; &lt;/Route&gt; &lt;/Router&gt;);export default Routes; The Router component wraps all the Route components. Based on the path prop of the Route component, the component passed to the component prop, will be rendered on the page. Here, we are setting up the root URL (/) to load our App component using the Router component. 1234&lt;Router &#123;...props&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123; &lt;div&gt;Hello World!&lt;/div&gt; &#125;&gt; &lt;/Route&gt;&lt;/Router&gt; The above code is also valid. For the path /, the &lt;div&gt;Hello World!&lt;/div&gt; will be mounted. Now, we need to call our routes.js file from our src/index.js file. The file should have the following content: 12345678910111213141516// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import &#123; browserHistory &#125; from 'react-router';import App from './containers/App';import Routes from './routes';import registerServiceWorker from './utils/registerServiceWorker';ReactDOM.render( &lt;Routes history=&#123;browserHistory&#125; /&gt;, document.getElementById('root'));registerServiceWorker(); Basically, we are mounting our Router component from our routes.js file. We pass in the history prop to it so that the routes know how to handle history tracking. You can check my commit on Github. Adding FirebaseIf you don’t have a Firebase account, create one now (it’s free!) by going to their website. After you’re done creating a new account, log into your account and go to the console page and click on Add project. Enter the name of your project (I’ll call mine reddit-clone), choose your country, and click on the Create project button. Now, before we proceed we need to change the rules for the database since, by default, Firebase expects the user to be authenticated to be able to read and write data. If you select your project and click on the Database tab on the left, you will be able to see your database. You need to click on the Rules tab on the top that will redirect us to a screen which will have the following data: 123456&#123; \"rules\": &#123; \".read\": \"auth != null\", \".write\": \"auth != null\" &#125;&#125; We need to change this to the following: 123456&#123; \"rules\": &#123; \".read\": \"auth === null\", \".write\": \"auth === null\" &#125;&#125; This will let users update the database without logging in. If we implemented a flow in which we had authentication before making updates to the database, then we would need the default rules provided by Firebase. To keep this application simple, we won’t be doing authentication. Important: If you don’t make this modification, Firebase won’t let you update the database from your app. Now, let’s add the firebase npm module to our app by running the following code: 1npm install --save firebase Next, import that module in your App/index.js file as: 123// App/index.jsimport * as firebase from \"firebase\"; When we select our project after logging into Firebase, we will get an option Add Firebase to your web app. If we click on that option, a modal will appear which will show us the config variable which we will use in our componentWillMount method. Let’s create the Firebase config file. We shall call this file firebase-config.js and this file will contain all the configs necessary to connect our app with Firebase. 12345678910// App/firebase-config.jsexport default &#123; apiKey: \"AIzaSyBRExKF0cHylh_wFLcd8Vxugj0UQRpq8oc\", authDomain: \"reddit-clone-53da5.firebaseapp.com\", databaseURL: \"https://reddit-clone-53da5.firebaseio.com\", projectId: \"reddit-clone-53da5\", storageBucket: \"reddit-clone-53da5.appspot.com\", messagingSenderId: \"490290211297\"&#125;; We’ll import our Firebase config into App/index.js. 123// App/index.jsimport config from './firebase-config'; We will initialize our Firebase database connection in the constructor. 12345678// App/index.jsconstructor() &#123; super(); // Initialize Firebase firebase.initializeApp(config);&#125; In the componentWillMount() lifecycle hook, we use the package firebase we just installed and call its initializeApp method and passed the config variable to it. This object contains all the data about our app. The initializeApp method will connect our application to our Firebase database so that we can read and write data. Let’s add some data to Firebase to check if our configuration is correct. Go to the Database tab and add the following structure to your database: Clicking on Add will save the data to our database. Now, let’s add some code to our componentWillMount method to make the data appear on our screen. 123456789101112131415161718// App/index.jscomponentWillMount() &#123; ... let postsRef = firebase.database().ref('posts'); let _this = this; postsRef.on('value', function(snapshot) &#123; console.log(snapshot.val()); _this.setState(&#123; posts: snapshot.val(), loading: false &#125;); &#125;); &#125; firebase.database() gives us a reference to the database service. Using ref(), we can get a specific reference from the database. For example, if we call ref(&#39;posts&#39;), we will be getting the posts reference from our database and storing that reference in postsRef. postsRef.on(&#39;value&#39;, ...) gives us the updated value whenever there is any change in the database. This is very useful when we need a real-time update to our user interface based on any database events. Using postsRef.once(&#39;value&#39;, ...) will only give us the data once. This is useful for data that only needs to be loaded once and isn’t expected to change frequently or require active listening. After we get the updated value in our on() callback, we store the values in our posts state. Now, we will see the data appearing on our console. Also, we will be passing this data down to our children. So, we need to modify the render function of our App/index.js file: 12345678910111213// App/index.jsrender() &#123; return ( &lt;div className=\"App\"&gt; &#123;this.props.children &amp;&amp; React.cloneElement(this.props.children, &#123; firebaseRef: firebase.database().ref('posts'), posts: this.state.posts, loading: this.state.loading &#125;)&#125; &lt;/div&gt; );&#125; This main objective here is to make the posts data available in all our children components which will be passed through react-router. We are checking if this.props.children exists or not and if it exists we clone that element and pass all our props to all our children. This is a very efficient way of passing props to dynamic children. Calling cloneElement will shallowly merge the already existing props in this.props.children and the props, we passed here (firebaseRef, posts and loading). Using this technique, the firebaseRef, posts and loading props will be available to all routes. You can check my commit on Github. Connecting The App With FirebaseFirebase can only store data as objects; it doesn’t have any native support for arrays. We will store the data in the following format: Add the data in the screenshot above manually so that you can test your views. Add views for all the postsNow, we will add views to show all the posts. Create a file src/containers/Posts/index.js with the following content: 1234567891011121314151617181920212223242526272829// src/containers/Posts/index.jsimport React, &#123; Component &#125; from 'react';class Posts extends Component &#123; render() &#123; if (this.props.loading) &#123; return ( &lt;div&gt; Loading... &lt;/div&gt; ); &#125; return ( &lt;div className=\"Posts\"&gt; &#123; this.props.posts.map((post) =&gt; &#123; return ( &lt;div&gt; &#123; post.title &#125; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; ); &#125;&#125;export default Posts; Here, we are just mapping over the data and rendering it to the user interface. Next, we need to add this to our routes.js file. 123456789// routes.js...&lt;Router &#123;...props&#125;&gt; &lt;Route path=\"/\" component=&#123; App &#125;&gt; &lt;Route path=\"/posts\" component=&#123; Posts &#125; /&gt; &lt;/Route&gt;&lt;/Router&gt;... This is because we want the posts to show up only on the /posts route. So, we just pass the Posts component to the component prop and /posts to the path prop of the Route component of react-router. If we go to the URL localhost:3000/posts, we will see the posts from our Firebase database. You can check my commit on Github. Add views to write a new postNow, let’s create a view from where we can add a new post. Create a file src/containers/AddPost/index.js with the following content: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// src/containers/AddPost/index.jsimport React, &#123; Component &#125; from 'react';class AddPost extends Component &#123; constructor() &#123; super(); this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; state = &#123; title: '' &#125;; handleChange = (e) =&gt; &#123; this.setState(&#123; title: e.target.value &#125;); &#125; handleSubmit = (e) =&gt; &#123; e.preventDefault(); this.props.firebaseRef.push(&#123; title: this.state.title &#125;); this.setState(&#123; title: '' &#125;); &#125; render() &#123; return ( &lt;div className=\"AddPost\"&gt; &lt;input type=\"text\" placeholder=\"Write the title of your post\" onChange=&#123; this.handleChange &#125; value=&#123; this.state.title &#125; /&gt; &lt;button type=\"submit\" onClick=&#123; this.handleSubmit &#125; &gt; Submit &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default AddPost; Here, the handleChange method updates our state with the value present in the input box. Now, when we click on the button, the handleSubmit method is triggered. The handleSubmit method is responsible for making the API request to write to our database. We do it using the firebaseRef prop which we passed to all the children. 123this.props.firebaseRef.push(&#123; title: this.state.title&#125;); The above block of code sets the current value of the title to our database. After the new post has been stored in the database, we make the input box empty again ready to add a new post. Now, we need to add this page to our routes. 12345678910111213141516171819// routes.jsimport React from 'react';import &#123; Router, Route &#125; from 'react-router';import App from './containers/App';import Posts from './containers/Posts';import AddPost from './containers/AddPost';const Routes = (props) =&gt; ( &lt;Router &#123;...props&#125;&gt; &lt;Route path=\"/\" component=&#123; App &#125;&gt; &lt;Route path=\"/posts\" component=&#123; Posts &#125; /&gt; &lt;Route path=\"/add-post\" component=&#123; AddPost &#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;);export default Routes; Here, we just added the /add-post route so that we can add a new post from that route. Hence, we passed the AddPost component to its component prop. Also, let’s modify the render method of our src/containers/Posts/index.js file so that it can iterate over objects instead of arrays (since Firebase doesn’t store arrays). 12345678910111213141516171819202122232425// src/containers/Posts/index.jsrender() &#123; let posts = this.props.posts; if (this.props.loading) &#123; return ( &lt;div&gt; Loading... &lt;/div&gt; ); &#125; return ( &lt;div className=\"Posts\"&gt; &#123; Object.keys(posts).map(function(key) &#123; return ( &lt;div key=&#123;key&#125;&gt; &#123; posts[key].title &#125; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; ); &#125; Now, if we go to localhost:3000/add-post, we can add a new post. After clicking on the submit button, the new post will appear immediately on the posts page. You can check my commit on Github. Implement votingNow, we need to allow users to vote on a post. For that, let’s modify the render method of our src/containers/App/index.js. 1234567891011121314// src/containers/App/index.jsrender() &#123; return ( &lt;div className=\"App\"&gt; &#123;this.props.children &amp;&amp; React.cloneElement(this.props.children, &#123; // https://github.com/ReactTraining/react-router/blob/v3/examples/passing-props-to-children/app.js#L56-L58 firebase: firebase.database(), posts: this.state.posts, loading: this.state.loading &#125;)&#125; &lt;/div&gt; );&#125; We changed the firebase prop from firebaseRef: firebase.database().ref(&#39;posts&#39;) to firebase: firebase.database() because we will be using Firebase’s set method to update our voting count. In this way, if we had more Firebase refs, it would be very easy for us to handle them by using only the firebase prop. Before proceeding with the voting, let’s modify the handleSubmit method in our src/containers/AddPost/index.js file a little bit: 1234567891011// src/containers/AddPost/index.jshandleSubmit = (e) =&gt; &#123; ... this.props.firebase.ref('posts').push(&#123; title: this.state.title, upvote: 0, downvote: 0 &#125;); ...&#125; We renamed our firebaseRef prop to firebase prop. So, we change the this.props.firebaseRef.push to this.props.firebase.ref(&#39;posts&#39;).push. Now, we need to modify our src/containers/Posts/index.js file to accomodate the voting. The render method should be modified to: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// src/containers/Posts/index.jsrender() &#123; let posts = this.props.posts; let _this = this; if (!posts) &#123; return false; &#125; if (this.props.loading) &#123; return ( &lt;div&gt; Loading... &lt;/div&gt; ); &#125; return ( &lt;div className=\"Posts\"&gt; &#123; Object.keys(posts).map(function(key) &#123; return ( &lt;div key=&#123;key&#125;&gt; &lt;div&gt;Title: &#123; posts[key].title &#125;&lt;/div&gt; &lt;div&gt;Upvotes: &#123; posts[key].upvote &#125;&lt;/div&gt; &lt;div&gt;Downvotes: &#123; posts[key].downvote &#125;&lt;/div&gt; &lt;div&gt; &lt;button onClick=&#123; _this.handleUpvote.bind(this, posts[key], key) &#125; type=\"button\" &gt; Upvote &lt;/button&gt; &lt;button onClick=&#123; _this.handleDownvote.bind(this, posts[key], key) &#125; type=\"button\" &gt; Downvote &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; );&#125; When the buttons are clicked, the upvote or downvote count will be incremented in our Firebase DB. To handle that logic, we create two more methods: handleUpvote() and handleDownvote(): 1234567891011121314151617// src/containers/Posts/index.jshandleUpvote = (post, key) =&gt; &#123; this.props.firebase.ref('posts/' + key).set(&#123; title: post.title, upvote: post.upvote + 1, downvote: post.downvote &#125;);&#125;handleDownvote = (post, key) =&gt; &#123; this.props.firebase.ref('posts/' + key).set(&#123; title: post.title, upvote: post.upvote, downvote: post.downvote + 1 &#125;);&#125; In these two methods, whenever a user clicks on either of the buttons, the respective count is incremented in the database and is instantly updated in the browser. If we open two tabs with localhost:3000/posts and click on the voting buttons of the posts, we will see each of the tabs get updated almost instantly. This is the magic of using a real-time database like Firebase. You can check my commit on Github. In the repository, I’ve added the /posts route to the IndexRoute of the application just to show the posts on localhost:3000 by default. You can check that commit on Github. ConclusionThe end result is admittedly a bit barebones, as we didn’t try to implement any design (although the demo has some basic styles added). We also didn’t add any authentication in order to reduce the complexity and the length of the tutorial, but obviously any real-world application would require it. Firebase is really useful for places where you don’t want to create and maintain a separate backend application or where you want real-time data without investing too much time developing your APIs. It plays really well with React, as you can hopefully see from the article.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"firebase","slug":"firebase","permalink":"http://nthung2112.github.io/tags/firebase/"}]},{"title":"Using MySQL with Node.js & the mysql JavaScript Client","slug":"Using-MySQL-with-Node-js-the-mysql-JavaScript-Client","date":"2017-07-23T09:47:48.000Z","updated":"2018-05-18T01:03:22.966Z","comments":true,"path":"2017/07/Using-MySQL-with-Node-js-the-mysql-JavaScript-Client.html","link":"","permalink":"http://nthung2112.github.io/2017/07/Using-MySQL-with-Node-js-the-mysql-JavaScript-Client.html","excerpt":"NoSQL databases are all the rage these days and probably the preferred back-end for Node.js applications. But you shouldn’t architect your next project based on what’s hip and trendy, rather the type of database to be used should depend on the project’s requirements. If your project involves dynamic table creation, real time inserts etc. then NoSQL is the way to go, but on the other hand, if your project deals with complex queries and transactions, then a SQL database makes much more sense. In this tutorial, we’ll have a look at getting started with the mysql module — a Node.js driver for MySQL, written in JavaScript. I’ll explain how to use the module to connect to a MySQL database, perform the usual CRUD operations, before examining stored procedures and escaping user input. This popular tutorial was updated on 11.07.2017. Changes include updating to ES6 syntax, addressing the fact that the node-mysql module was renamed, adding more beginner friendly instructions and adding a section on ORMs.","text":"NoSQL databases are all the rage these days and probably the preferred back-end for Node.js applications. But you shouldn’t architect your next project based on what’s hip and trendy, rather the type of database to be used should depend on the project’s requirements. If your project involves dynamic table creation, real time inserts etc. then NoSQL is the way to go, but on the other hand, if your project deals with complex queries and transactions, then a SQL database makes much more sense. In this tutorial, we’ll have a look at getting started with the mysql module — a Node.js driver for MySQL, written in JavaScript. I’ll explain how to use the module to connect to a MySQL database, perform the usual CRUD operations, before examining stored procedures and escaping user input. This popular tutorial was updated on 11.07.2017. Changes include updating to ES6 syntax, addressing the fact that the node-mysql module was renamed, adding more beginner friendly instructions and adding a section on ORMs. Quick Start: How to Use MySQL in NodeMaybe you’ve arrived here looking for a quick leg up. If you’re just after a way to get up and running with MySQL in Node in as little time as possible, we got you covered! Here’s how to use MySQL in Node in 5 easy steps: Create a new project: mkdir mysql-test &amp;&amp; cd mysql-test Create a package.json file: npm init –y Install the mysql module: npm install mysql –save Create an app.js file and copy in the snippet below. Run the file: node app.js. Observe a “Connected!” message. 12345678910111213//app.jsconst mysql = require(&apos;mysql&apos;);const connection = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;user&apos;, password: &apos;password&apos;, database: &apos;database name&apos;&#125;);connection.connect((err) =&gt; &#123; if (err) throw err; console.log(&apos;Connected!&apos;);&#125;); Installing the mysql ModuleNow let’s take a closer look at each of those steps. First of all we’re using the command line to create a new directory and navigate to it. Then we’re creating a package.json file using the command npm init –y. The -y flag means that npm will use only defaults and not prompt you for any options. This step also assumes that you have Node and npm installed on your system. If this is not the case, then check out this SitePoint article to find out how to do that: Install Multiple Versions of Node.js using nvm. After that, we’re installing the mysql module from npm and saving it as a project dependency. Project dependencies (as opposed to dev-dependencies) are those packages required for the application to run. You can read more about the differences between the two here. 123mkdir mysql-testcd mysql-testnpm install mysql -y If you need further help using npm, then be sure to check out this guide, or ask in our forums. Getting StartedBefore we get on to connecting to a database, it’s important that you have MySQL installed and configured on your machine. If this is not the case, please consult the installation instructions on their home page. The next thing we need to do is to create a database and a database table to work with. You can do this using agraphical interface, such as phpMyAdmin, or using the command line. For this article I’ll be using a database called sitepoint and a table called employees. Here’s a dump of the database, so that you can get up and running quickly, if you wish to follow along: 123456789101112CREATE TABLE employees ( id int(11) NOT NULL AUTO_INCREMENT, name varchar(50), location varchar(50), PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=5 ;INSERT INTO employees (id, name, location) VALUES(1, &apos;Jasmine&apos;, &apos;Australia&apos;),(2, &apos;Jay&apos;, &apos;India&apos;),(3, &apos;Jim&apos;, &apos;Germany&apos;),(4, &apos;Lesley&apos;, &apos;Scotland&apos;); Connecting to the DatabaseNow, let’s create a file called app.js in our mysql-test directory and see how to connect to MySQL from Node.js. 1234567891011121314151617181920212223// app.jsconst mysql = require(&apos;mysql&apos;);// First you need to create a connection to the dbconst con = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;user&apos;, password: &apos;password&apos;,&#125;);con.connect((err) =&gt; &#123; if(err)&#123; console.log(&apos;Error connecting to Db&apos;); return; &#125; console.log(&apos;Connection established&apos;);&#125;);con.end((err) =&gt; &#123; // The connection is terminated gracefully // Ensures all previously enqueued queries are still // before sending a COM_QUIT packet to the MySQL server.&#125;); Now open up a terminal and enter node app.js. Once the connection is successfully established you should be able to see the ‘Connection established’ message in the console. If something goes wrong (for example you enter the wrong password), a callback is fired, which is passed an instance of the JavaScript Error object (err). Try logging this to the console to see what additional useful information it contains. Using Grunt to Watch the Files for ChangesRunning node app.js by hand every time we make a change to our code is going to get a bit tedious, so let’s automate that. This part isn’t necessary to follow along with the rest of the tutorial, but will certainly save you some keystrokes. Let’s start off by installing a couple of packages: 1npm install --save-dev grunt grunt-contrib-watch grunt-execute Grunt is the well-know JavaScript task runner, grunt-contrib-watch runs a pre-defined task whenever a watched file changes, and grunt-execute can be used to run the node app.js command. Once these are installed, create a file called Gruntfile.js in the project root and add the following code. 1234567891011121314151617181920// Gruntfile.jsmodule.exports = (grunt) =&gt; &#123; grunt.initConfig(&#123; execute: &#123; target: &#123; src: [&apos;app.js&apos;] &#125; &#125;, watch: &#123; scripts: &#123; files: [&apos;app.js&apos;], tasks: [&apos;execute&apos;], &#125;, &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-watch&apos;); grunt.loadNpmTasks(&apos;grunt-execute&apos;);&#125;; Now run grunt watch and make a change to app.js. Grunt should detect the change and re-run the node app.js command. Executing QueriesReadingNow that you know how to establish a connection to MySQL from Node.js, let’s see how to execute SQL queries. We’ll start by specifying the database name (sitepoint) in the createConnection command. 123456const con = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;user&apos;, password: &apos;password&apos;, database: &apos;sitepoint&apos;&#125;); Once the connection is established we’ll use the connection variable to execute a query against the database table employees. 123456con.query(&apos;SELECT * FROM employees&apos;, (err,rows) =&gt; &#123; if(err) throw err; console.log(&apos;Data received from Db:\\n&apos;); console.log(rows);&#125;); When you run app.js (either using grunt-watch or by typing node app.js into your terminal), you should be able to see the data returned from database logged to the terminal. 1234[ &#123; id: 1, name: &apos;Jasmine&apos;, location: &apos;Australia&apos; &#125;, &#123; id: 2, name: &apos;Jay&apos;, location: &apos;India&apos; &#125;, &#123; id: 3, name: &apos;Jim&apos;, location: &apos;Germany&apos; &#125;, &#123; id: 4, name: &apos;Lesley&apos;, location: &apos;Scotland&apos; &#125; ] Data returned from the MySQL database can be parsed by simply lopping over the rows object. 123rows.forEach( (row) =&gt; &#123; console.log(`$&#123;row.name&#125; is in $&#123;row.location&#125;`); &#125;); CreatingYou can execute an insert query against a database, like so: 123456const employee = &#123; name: &apos;Winnie&apos;, location: &apos;Australia&apos; &#125;;con.query(&apos;INSERT INTO employees SET ?&apos;, employee, (err, res) =&gt; &#123; if(err) throw err; console.log(&apos;Last insert ID:&apos;, res.insertId);&#125;); Note how we can get the ID of the inserted record using the callback parameter. UpdatingSimilarly, when executing an update query, the number of rows affected can be retrieved using result.affectedRows: 123456789con.query( &apos;UPDATE employees SET location = ? Where ID = ?&apos;, [&apos;South Africa&apos;, 5], (err, result) =&gt; &#123; if (err) throw err; console.log(`Changed $&#123;result.changedRows&#125; row(s)`); &#125;); DestroyingSame thing goes for a delete query: 1234567con.query( &apos;DELETE FROM employees WHERE id = ?&apos;, [5], (err, result) =&gt; &#123; if (err) throw err; console.log(`Deleted $&#123;result.affectedRows&#125; row(s)`); &#125;); Advanced UseI’d like to finish off by looking at how the mysql module handles stored procedures and the escaping of user input. Stored ProceduresPut simply, a stored procedure is a procedure (written in, for example, SQL) stored in a database which can be called by the database engine and connected programming languages. If you are in need of a refresher, then please check out this excellent article. Let’s create a stored procedure for our sitepoint database which fetches all the employee details. We’ll call it sp_getall . To do this, you’ll need some kind of interface to the database. I’m using phpMyAdmin. Run the following query on the sitepoint database: 123456DELIMITER $$CREATE DEFINER=`root`@`localhost` PROCEDURE `sp_getall`()BEGIN SELECT id, name, location FROM employees;END This will create and store the procedure in the information_schema database in the ROUTINES table. Next, establish a connection and use the connection object to call the stored procedure as shown: 123456con.query(&apos;CALL sp_getall()&apos;,function(err, rows)&#123; if (err) throw err; console.log(&apos;Data received from Db:\\n&apos;); console.log(rows);&#125;); Save the changes and run the file. Once executed you should be able to view the data returned from the database. 123456789101112[ [ &#123; id: 1, name: &apos;Jasmine&apos;, location: &apos;Australia&apos; &#125;, &#123; id: 2, name: &apos;Jay&apos;, location: &apos;India&apos; &#125;, &#123; id: 3, name: &apos;Jim&apos;, location: &apos;Germany&apos; &#125;, &#123; id: 4, name: &apos;Lesley&apos;, location: &apos;Scotland&apos; &#125; ], &#123; fieldCount: 0, affectedRows: 0, insertId: 0, serverStatus: 34, warningCount: 0, message: &apos;&apos;, protocol41: true, changedRows: 0 &#125; ] Along with the data, it returns some additional information, such as the affected number of rows, insertId etc. You need to iterate over the 0th index of the returned data to get employee details separated from the rest of the information. 123rows[0].forEach( (row) =&gt; &#123; console.log(`$&#123;row.name&#125; is in $&#123;row.location&#125;`);&#125;); Now lets consider a stored procedure which requires an input parameter. 12345678DELIMITER $$CREATE DEFINER=`root`@`localhost` PROCEDURE `sp_get_employee_detail`( in employee_id int)BEGIN SELECT name, location FROM employees where id = employee_id;END Now we can pass the input parameter while making a call to the stored procedure: 123456con.query(&apos;CALL sp_get_employee_detail(1)&apos;, (err, rows) =&gt; &#123; if(err) throw err; console.log(&apos;Data received from Db:\\n&apos;); console.log(rows[0]);&#125;); Most of the time when we try to insert a record into the database, we need the last inserted ID to be returned as an out parameter. Consider the following insert stored procedure with an out parameter: 123456789101112DELIMITER $$CREATE DEFINER=`root`@`localhost` PROCEDURE `sp_insert_employee`( out employee_id int, in employee_name varchar(25), in employee_location varchar(25))BEGIN insert into employees(name, location) values(employee_name, employee_location); set employee_id = LAST_INSERT_ID();END To make a procedure call with an out parameter, we first need to enable multiple calls while creating the connection. So, modify the connection by setting the multiple statement execution to true. 1234567const con = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;user&apos;, password: &apos;password&apos;, database: &apos;sitepoint&apos;, multipleStatements: true&#125;); Next when making a call to the procedure, set an out parameter and pass it in. 123456789con.query( &quot;SET @employee_id = 0; CALL sp_insert_employee(@employee_id, &apos;Ron&apos;, &apos;USA&apos;); SELECT @employee_id&quot;, (err, rows) =&gt; &#123; if (err) throw err; console.log(&apos;Data received from Db:\\n&apos;); console.log(rows); &#125;); As seen in the above code, we have set an out parameter @employee_id and passed it while making a call to the stored procedure. Once the call has been made we need to select the out parameter to access the returned ID. Run app.js. On successful execution you should be able to see the selected out parameter along with various other information. rows[2] should give you access to the selected out parameter. 1[ &#123; &apos;@employee_id&apos;: 6 &#125; ] Escaping User InputIn order to avoid SQL Injection attacks, you should always escape any data from user land before using it inside a SQL query. Let’s demonstrate why: 123456789const userLandVariable = &apos;4 &apos;;con.query( `SELECT * FROM employees WHERE id = $&#123;userLandVariable&#125;`, (err, rows) =&gt; &#123; if(err) throw err; console.log(rows); &#125;); This seems harmless enough and even returns the correct result: 1&#123; id: 4, name: &apos;Lesley&apos;, location: &apos;Scotland&apos; &#125; However, if we change the userLandVariable to this: 1const userLandVariable = &apos;4 OR 1=1&apos;; we suddenly have access to the entire data set. If we then change it to this: 1const userLandVariable = &apos;4; DROP TABLE employees&apos;; then we’re in proper trouble! The good news is that help is at hand. You just have to use the mysql.escape method: 1234con.query( `SELECT * FROM employees WHERE id = $&#123;mysql.escape(userLandVariable)&#125;`, function(err, rows)&#123; ... &#125;); Or by using a question mark placeholder, as we did in the examples at the beginning of the article: 12345 con.query( &apos;SELECT * FROM employees WHERE id = ?&apos;, [userLandVariable], (err, rows) =&gt; &#123; ... &#125;); Why Not Just USE an ORM?As you may have noticed, a couple of people in the comments are suggesting using an ORM. Before we get into the pros and cons of this approach, let’s take a second to look at what ORMs are. The following is taken from an answer on Stack Overflow: Object-Relational Mapping (ORM) is a technique that lets you query and manipulate data from a database using an object-oriented paradigm. When talking about ORM, most people are referring to a library that implements the Object-Relational Mapping technique, hence the phrase “an ORM”. So basically, this approach means you write your database logic in the domain-specific language of the ORM, as opposed to the vanilla approach we have been taking so far. Here’s a contrived example using Sequelize: 123Employee.findAll().then(employees =&gt; &#123; console.log(employees);&#125;); Contrasted with: 123456con.query(&apos;SELECT * FROM employees&apos;, (err,rows) =&gt; &#123; if(err) throw err; console.log(&apos;Data received from Db:\\n&apos;); console.log(rows);&#125;); Whether or not using an ORM makes sense for you, will depend very much on what you are working on and with whom. On the one hand, ORMS tend to make developers more productive, in part by abstracting away a large part of the SQL so that not everyone on the team needs to know how to write super efficient database specific queries. It is also easy to move to different database software, because you are developing to an abstraction. On the other hand however, it is possible to write some really messy and inefficient SQL as a result of not understanding how the ORM does what it does. Performance is also an issue in that it’s much easier to optimize queries that don’t have to go through the ORM. Whichever path you take is up to you, but if this is a decision you’re in the process of making, check out this Stack Overflow thread: Why should you use an ORM? as well as this post on SitePoint: 3 JavaScript ORMs You Might Not Know. ConclusionIn this tutorial, we’ve only scratched the surface of what the mysql client offers. For more detailed information, I would recommend reading the official documentation. There are other options too, such as node-mysql2 and node-mysql-libmysqlclient.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"http://nthung2112.github.io/tags/nodejs/"},{"name":"mysql","slug":"mysql","permalink":"http://nthung2112.github.io/tags/mysql/"}]},{"title":"10 React mini-patterns","slug":"10-react-mini-patterns","date":"2017-07-16T14:50:48.000Z","updated":"2017-08-20T16:43:56.760Z","comments":true,"path":"2017/07/10-react-mini-patterns.html","link":"","permalink":"http://nthung2112.github.io/2017/07/10-react-mini-patterns.html","excerpt":"Over the last few years, I’ve worked on a handful of decent-sized React projects, and many, many pint-sized ones. Throughout this magical journey, a number of patterns have come up that I find myself repeating again and again. Because that’s what patterns are. These are the sorts of things I would like to have heard about on day one. So if today is your day one with React, you’re in luck. Or maybe you’re not. There’s only one way to find out… It’s a long one, but it’s a listicle so you can skip the boring ones (3, 6, 8, 10).","text":"Over the last few years, I’ve worked on a handful of decent-sized React projects, and many, many pint-sized ones. Throughout this magical journey, a number of patterns have come up that I find myself repeating again and again. Because that’s what patterns are. These are the sorts of things I would like to have heard about on day one. So if today is your day one with React, you’re in luck. Or maybe you’re not. There’s only one way to find out… It’s a long one, but it’s a listicle so you can skip the boring ones (3, 6, 8, 10). #1 Sending data down and upThe one thing I’d recommend to everyone new to React is to get your head around the pattern of passing information down (as objects, strings, etc.) and passing methods down to allow child components to pass information back up. Like sending down a packet of chips and a walkie talkie to miners trapped underground. How about a picture? The below thing is the simplest form of this pattern. Worth a thousand words? Parent on the left, child on the right. You can think of the two props that connect these components as allowing information to flow in either direction between the two. The prop called items is passing data down into the child component. The prop called deleteItem is giving the child component a way to send some information back up into the parent (“hey, delete this item”). That’s not really a pattern. The rest are patterns. I promise. #2 Fixing HTML’s inputsOne of the great things about React, and web components in general, is that you get to iron out the kinks if something in html doesn’t work the way you want. If you think about the different elements that allow for user input (do it), you will soon see that the naming of these elements is nonsensical, bordering on reckless. If I’m building a site that will have a lot of user inputs, one of the first things I do is fix this. It’s not purely cosmetic though; there are more improvements to be had: Inputs should return a value via an onChange method, not a JavaScript Event instance, shouldn’t they? You can go a step further and ensure that the data type returned in onChange matches the type passed in. If the typeof props.value is number, then convert e.target.value back to a number before sending the data out again. A set of radio buttons is functionally the same thing as a &lt;select&gt;, right? It’s messed up to treat them in a completely different manner when the only difference is the UI. Maybe for your app it makes sense to have a single &lt;PickOneFromMany /&gt; component and pass either ui=&quot;radio&quot; or ui=&quot;dropDown&quot;. The point is not to do it like I do it. The point is to make them your own — you don’t need to keep working with the somewhat ass-about nature of HTML’s user input elements. #3 Binding labels to inputs with unique IDsOn the topic of inputs… if you care about your users, you’ll bind your &lt;label&gt; elements to your &lt;input&gt;s via an id/for combo. But you don’t want to think of some clever and unique id for every input you define, who’s got time for that? I don’t know about you but I’ve got goat videos to watch. (Frequent-flyer tip: if you have a screaming child on your flight, close your eyes and pretend you’re watching a video on YouTube of goats that sound like humans. Annoying becomes hilarious.) Back to it. You could generate a random ID for each input/label pair, but then your client-rendered HTML won’t match your server-rendered HTML. Checksum error! That’s no good. So, instead you can create a little module that gives an incrementing ID, and use that in an Input component like so: Obviously it makes more sense when the input isn’t inside the label. If getNextId() simply increments a number every time it’s called, then when rendering on the server, the number would keep going up and up, eventually reaching infinity. So you’ll want to reset the number each time you render the app (for each network request). You can do this at the entry point to your app, with a simple resetId() or whatever name you think is best. With all that taken into account, your super-fancy module might look something like this: #4 Controlling CSS with propsWhen you want to apply different CSS in different instances (e.g. ‘primary’ and ‘secondary’ buttons) you can pass in props to control which CSS to apply. This seems super simple on the surface, but let me assure you there are a lot of wrong ways to do this (I’ve tried them all!). There are — I reckon — three distinct ways in which you can control the CSS applied to a component. Using themesFor grouping a number of CSS declarations together, you can use the idea of ‘themes’, for example primary or secondary button: &lt;Button theme=&quot;secondary&quot;&gt;Hello&lt;/Button&gt; Do your best to only require one theme per component. Using flagsMaybe some of your buttons have rounded corners, but this doesn’t correspond directly with the themes you have defined. In this case you can either sit your designer down and have the consistency talk, or create a boolean prop which might look a little something like this: &lt;Button theme=&quot;secondary&quot; rounded&gt;Hello&lt;/Button&gt; Just like HTML’s binary attributes, you don’t need to do rounded={true}. Setting valuesIn some cases you might want to pass in the value of a CSS property directly (in the component you would set it as an inline style). &lt;Icon width=&quot;25&quot; height=&quot;25&quot; type=&quot;search&quot; /&gt; An exampleImagine you’re creating a link component. You go through your site’s designs and work out that there are three distinct themes, and that sometimes they have an underline, sometimes they don’t. Here’s how I would design that component: And the CSS… You may have noticed the awkward double negative for link--no-underline. Story time: I used to think writing fewer lines of CSS was the goal, but it’s not. I’d rather have some double-negatives and multi-selector rulesets if it means the styles are applied in a nice layered way. I’m sure I’ve said it before but the hardest thing about scaling a website is the CSS. JavaScript is easy, but with CSS you pay for your sins — once you’ve started a mess, it’s not easy to back out of. True fact: fighting CSS specificity is the number one cause of death among web developers. If you’re on a big computer, check out the CSS for the little notification icon in medium’s top nav. If you’re not, or you’re lazy, just guess how many CSS rules are combined to make this round circle with a number in it? Twenty three rules. That’s not including the styles inherited from eleven other rules. The line-height alone is overridden nine times. If line-height was a cat it would be dead by now. This cannot be pleasant to maintain. With React we can do better. We can thoughtfully design which classes are applied to our components. We can remove global resets and move it all inside our Button.scss. We can remove all reliance on specificity and ordering of files. Side note: I dream of a day when we will be able to tell browsers that we don’t want their opinion about style at all. ::user-agent-styles: none-whatsoever; — make it happen, vendors. [Edit: a clever chap in the comments has pointed out that all: unset may cure what ails me.] #5 The switching componentA switching component is a component that renders one of many components. This may be a &lt;Page&gt; component that displays one of many pages. Or tabs in a tab set, or different modals in a modal component. I used to do this with switch statements, then progressed to actually passing in the component I wanted rendered. Then moved on to exporting references to the components from the component itself (as named exports, then as properties on the component). All terrible ideas. The potentially-terrible approach that I have settled on is to use an object to map prop values to components. The keys of the PAGES object can be used in the prop types to catch dev-time errors. Then of course we would use this like &lt;Page page=&quot;home&quot; /&gt;. If you replace the keys home, about and user with /, /about, and /user, you’ve got yourself half a router. (Future post idea: removing react-router.) #6 Reaching into a componentIf you’re looking for an easy way to please your users, add autofocus to the input that they are most likely to type into when coming to a page. It really is that easy. Perhaps you have a sign-in form and — being the UX champ that you are — you want to put that little blinking cursor in the ‘user name’ field. But oh no, the form shows in a modal when the user clicks ‘sign in’, and the autofocus attribute only applies to page load. Whatever will you do! You’ll programmatically focus the element, that’s what. Here you may be tempted to give the input an id and type document.getElementById(&#39;user-name-input&#39;).focus(). This works, but is not The Correct Way. The fewer things you have in your app that rely on two strings matching, the better. Luckily, there is a very easy way to do this ‘properly’: Boom, an input component with a focus() method that focuses the HTML element. In the parent component, we can get a reference to the Input component and call its focus() method. Note that when you use ref on a component, it’s a reference to the component (not the underlying element), so you have access to its methods. #7 Almost-componentsLet’s say you’re building a component that lets you search for people. As you type, you see a list of names and photos of potential matches. Something like this. (I’m searching for political satirists because I, like everyone, am super interested in what other people think about politics.) When designing this component, you may think to yourself: is each item in that list it’s own SearchSuggestion component? It’s really only a few lines of HTML and CSS, so maybe not? But I was once told ‘if in doubt, create another component’. Oh my, this is quite the dilly of a pickle, isn’t it? If I was making this, I would not have a separate component. Instead, just a renderSearchSuggestion method that returned the appropriate DOM for each entry. I can then generate the results like: If things get more complex or you want to use this component elsewhere, you should be able to copy/paste the code out into a new component. Don’t prematurely componentize. Components aren’t like teaspoons; you can have too many. What I am not saying: “take something that you think should be a component, and make it part of the parent component.” What I am saying: “take something that you don’t think should be a component, and make it a bit more like its own component (if it can be).” #8 Components for formatting textWhen I first started with React I thought of components as big things, a way of grouping structural chunks of DOM. But components work just as well as a way to apply formatting. Here’s a &lt;Price&gt; component that takes a number and returns a pretty string, with or without decimals and a ‘$’ sign. As you can see I’m using the powerful Intl string formatting library, here’s a link to their website. I should point out (before some punk does) that this is not a saving in lines of code. You could just as easily use a function to do this. (Of course components are just functions with different shaped brackets.) It’s less code, but to my eye, not quite as nice: Note that I’m not checking that I got a valid number in any of the above. That’s because … #9 The store is the component’s servantI have probably written this thousands of times: if (props.user.signInStatus === SIGN_IN_STATUSES.SIGNED_IN)... (I’ve been told that I exaggerate, like, a gazillion times.) Quite recently I have decided that if I’m doing a check like this, I’m doing it wrong. I want to just ask “is the user signed in?”, not “is the sign in status of the user equal to signed in?” My components have enough going on in their lives, they shouldn’t have to worry their pretty little heads over such matters. Nor should they have to worry that a price isn’t being sent as a number, or a boolean as the word ‘true’. For you see, if the data in your store is designed to match your components, your components will be much simpler. And I’ve said it before, complexity is where the bugs hide. The less complexity you have in your components, the lower the chance of bugs. But the complexity has to go somewhere, doesn’t it? My suggestion is this: Work out the general structure of your components and the data they will require Design your store to support those requirements Do whatever you need to do to your incoming data to make it fit into the store. For this last point, I recommend a single module that does all the massaging of incoming data (oh la la). Renaming props, casting strings to numbers, objects into arrays, date strings to date objects, whatever. Do it all in the one place, and unit test the crap out of it. If you’re rockin’ a react/redux setup, you might then do something like this in an action creator that fetches search results: Your components will thank you for it. #10 Importing components without relative pathsWouldn’t it be sweet if instead of doing this: **import** Button **from** '../../../../Button/Button.jsx'; **import** Icon **from** '../../../../Icon/Icon.jsx'; **import** Footer **from** '../../Footer/Footer.jsx'; You could just do this: 1import &#123;Button, Icon, Footer&#125; from &apos;Components&apos;; Well in theory you can: Create a single index.js somewhere that exports references each of your components Use Webpack’s resolve.alias to redirect Components to that index file I hadn’t done this before, and planned to convert one of my existing apps for this post (then lie and tell you I totes do it all the time). But as I wrote the code I came to realise that this is a bad idea, for three reasons: It seems to be broken in Webpack 2. It’s an eslint error because Components won’t be in node_modules. If you use a good IDE, it will know things about your components. You will get clever warnings about not supplying required props, the ability to cmd/ctrl+click to open that component’s file. Things of that nature.If you do the above, your IDE will no longer know where to find that component and you’ll lose those smarts. Thanks, WebStorm. Edit: matthew hsiung has a solution for the eslint and WebStorm issues in this comment. Wrap upThat’s the lot of them. I’m quite sure I’ll look at this in a year and wince. Perhaps you’ll do it today. Perhaps you’ll share something that has served you well. Oh and I’ve decided I don’t care if you click the little green heart or not. I WILL NOT BE DEFINED BY AN INTERNET METRIC.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Tìm hiểu về async và await đơn giản","slug":"Javascript-Tim-hieu-ve-async-va-await-don-gian","date":"2017-01-10T13:03:38.000Z","updated":"2017-08-20T14:51:30.727Z","comments":true,"path":"2017/01/Javascript-Tim-hieu-ve-async-va-await-don-gian.html","link":"","permalink":"http://nthung2112.github.io/2017/01/Javascript-Tim-hieu-ve-async-va-await-don-gian.html","excerpt":"1. Giới thiệuVới các đặc tả JavaScript cũ, ta phải sử dụng các hàm phản hồi để xử lý các thao tác bất đồng bộ. Tuy nhiên việc này dẫn tới tình trạng callback hell khi ta có nhiều thao tác bất đồng bộ phải chờ nhau thực hiện. Call hell làm cho mã nguồn của ta rất rối và khó bảo trì. 12345678910111213141516function wait(ms, cb) &#123; setTimeout(cb, ms)&#125;function main() &#123; console.log('sắp rồi...') wait(2007, () =&gt; &#123; console.log('chờ tí...') wait(2012, () =&gt; &#123; console.log('thêm chút nữa thôi...') wait(2016, () =&gt; &#123; console.log('xong rồi đấy!') &#125;) &#125;) &#125;)&#125; Vì vậy, với phiên bản ES6 (ES 2016), Promise đã được đưa vào mặc định nhằm giải quyết tình trạng callback hell. Với Promise, mã nguồn của ta sẽ trông gần giống với phong cách đồng bộ, kết quả là trông dễ theo dõi và bảo trì hơn. Tuy nhiên sử dụng Promise lại làm phát sinh vấn đề “khá” tương tự là Promise hell ( lol! JavaScript Heo! ).","text":"1. Giới thiệuVới các đặc tả JavaScript cũ, ta phải sử dụng các hàm phản hồi để xử lý các thao tác bất đồng bộ. Tuy nhiên việc này dẫn tới tình trạng callback hell khi ta có nhiều thao tác bất đồng bộ phải chờ nhau thực hiện. Call hell làm cho mã nguồn của ta rất rối và khó bảo trì. 12345678910111213141516function wait(ms, cb) &#123; setTimeout(cb, ms)&#125;function main() &#123; console.log('sắp rồi...') wait(2007, () =&gt; &#123; console.log('chờ tí...') wait(2012, () =&gt; &#123; console.log('thêm chút nữa thôi...') wait(2016, () =&gt; &#123; console.log('xong rồi đấy!') &#125;) &#125;) &#125;)&#125; Vì vậy, với phiên bản ES6 (ES 2016), Promise đã được đưa vào mặc định nhằm giải quyết tình trạng callback hell. Với Promise, mã nguồn của ta sẽ trông gần giống với phong cách đồng bộ, kết quả là trông dễ theo dõi và bảo trì hơn. Tuy nhiên sử dụng Promise lại làm phát sinh vấn đề “khá” tương tự là Promise hell ( lol! JavaScript Heo! ). 12345678910111213141516171819function wait(ms) &#123; return new Promise(r =&gt; setTimeout(r, ms)) &#125;function main() &#123; console.log('sắp rồi...') wait(2007).then(() =&gt; &#123; console.log('chờ tí...') return wait(2007) &#125;).then(() =&gt; &#123; console.log('thêm chút nữa thôi...') return wait(2012) &#125;).then(() =&gt; &#123; console.log('thêm chút nữa thôi...') return wait(2016) &#125;).then(() =&gt; &#123; console.log('xong rồi đấy!') &#125;)&#125; Để giải quyết vấn đề đó, ở phiên bản ES7 (ES 2017), 1 khái niệm với 2 từ khóa mới được đưa vào là hàm async (async / await). Hàm async cho phép ta viết các thao tác bất đồng bộ với phong cách của các mã đồng bộ. Bằng cách viết như vậy, mã nguồn của ta trông sẽ sáng sủa, dễ đọc hơn và “dễ hiểu hơn”. 12345678910111213function wait(ms) &#123; return new Promise(r =&gt; setTimeout(r, ms)) &#125;async function main() &#123; console.log('sắp rồi...') await wait(2007) console.log('chờ tí...') await wait(2012) console.log('thêm chút nữa thôi...') await wait(2016) console.log('xong rồi đấy!')&#125; 2. Cách sử dụngĐể sử dụng hàm async, ta cần khai báo từ khóa async ngay trước từ khóa định nghĩa hàm. Tức là, với hàm định nghĩa với từ khóa function ta phải khai báo ngay trước function, với hàm mũi tên (arrow function) ta phải khai báo trước tập tham số đầu vào, với phương thức của lớp Class thì ta phải khai báo ngay trước tên hàm. 1234567891011121314151617181920// regular functionasync function functionName() &#123; let ret = await new Google().search('JavaScript')&#125;// arrow functionlet arr = ['JS', 'node.js'].map(async val =&gt; &#123; return await new Google().search(val)&#125;)// Classclass Google &#123; constructor() &#123; this.apiKey = '...' &#125; async search(keyword) &#123; return await this.searchApi(keyword) &#125;&#125; Với từ khóa async này, ta có thể đợi các Promise (thao tác bất đồng bộ) xử lý trong hàm đó mà không tạm dùng luồng chính bằng từ khóa await như ví dụ trên. Kết quả trả ra của hàm async luôn là một Promise dù bạn có gọi await - có xử lý bất đồng bộ hay không. Promise này sẽ ở trạng thái thành công với kết quả được trả ra với từ khóa return của hàm async, hoặc trạng thái thất bại với kết quả được đẩy qua từ khóa throw trong hàm async. Như vậy, bản chất của hàm async chính là Promise. Nếu bạn chưa tìm hiểu về Promise thì nên đọc trước ở bài viết này. Với Promise, ta có thể xử lý ngoại lệ với catch khá đơn giản. Tuy nhiên cũng không dễ dàng theo dõi và dễ đọc. Nhưng với hàm async, việc này cực kì đơn giản bằng từ khóa try catch hệt như các thao tác đồng bộ. 1234567891011121314151617181920212223242526272829//// test.js//function wait(ms) &#123; return new Promise(r =&gt; setTimeout(r, ms)) &#125;async function runner() &#123; console.log('sắp rồi...') await wait(2007) console.log('chờ tí...') await wait(2012) console.log('thêm chút nữa thôi...') await wait(2016) throw new Error(2016)&#125;async function main() &#123; try &#123; await runner() console.log('xong rồi đấy!') &#125; catch (e) &#123; console.log(`có vấn đề tại $&#123; e &#125;`) &#125;&#125;// Node v7// `$ node --harmony-async-await test.js`// Console: ... có vấn đề tại 2016 Ngon! Rõ ràng là mã nguồn sử dụng async/await trông đơn giản, dễ theo dõi, “dễ hiểu” hơn và giải quyết được tình trạng callback - promise hell. Tuy nhiên, việc sử dụng nó cũng không phải lúc nào cũng đơn giản. Ta cùng nhau xem một số trường hợp dưới đây. 3. Lưu ý3.1. Quên khai báo từ khóa asyncĐương nhiên rồi, không khai báo từ khóa này thì ta không có hàm async được, không sử dụng await được rồi. Thường bạn sẽ nghĩ đơn giản là không thể nào quên được từ khóa này, nhưng tôi nghĩ đôi lúc có thể đấy. Ví dụ như với trường hợp khai báo một hàm trong một hàm async. Hàm khai báo trong hàm async cũng bắt buộc phải được khai báo với từ khóa async nếu như bạn muốn sử dụng như một hàm async. 123456async function main() &#123; await wait(1000) let arr = [100, 300, 500].map(val =&gt; wait(val)) arr.forEach(func =&gt; await func) // ??? error&#125; 3.2. Nhập nhằng từ khóa awaitCó 2 tình huống điển hình cho trường hợp này là: Quên khai báo khi cần đợi một xử lý bất đồng bộ Có gì đáng sợ không? Câu trả lời là có đấy! Nếu bạn không khai báo từ khóa này thì kết quả bạn nhận được sẽ là một Promise chứ không phải là kết quả thực thi của xử lý bất đồng bộ nhé. 123456789async function now() &#123; return Date.now()&#125;async function main() &#123; let t = now() console.log(t) // ??? `t` is a `Promise` instance&#125; Khai báo “thừa” trước một xử lý đồng bộ Nếu mà sợ quên thì cứ khai báo bừa đi, đâu có sao? Ừ không sao đâu ngoại trừ 2 vấn đề là không biết cái nào là đồng bộ, cái nào là bất đồng bộ nữa, và hiệu quả đi xuống đấy. Mỗi khi bạn khai báo await thì mặc nhiên sau từ khóa đó là một Promise, nếu không phải là một Promise thì nó sẽ được gói lại vào Promise và được trả ra ngay với phương thức Promise.resolve(value). Rảnh quá ha, muốn lấy 1 + 0 = 1 mà phải đi đường vòng là tính tổng, rồi nhét vào Promise, rồi lại moi ra để sử dụng. 12345678910111213141516171819async function main() &#123; // run with await console.log('run with await') let i = 1000000 console.time('await') while(i-- &gt; 0) &#123; let t = await (1 + 0) &#125; console.timeEnd('await') // run without await console.log('run without await') i = 1000000 console.time('normal') while(i-- &gt; 0) &#123; let t = 1 + 0 &#125; console.timeEnd('normal')&#125; 3.3. Quên xử lý lỗiCũng như với việc quên catch lỗi khi sử dụng Promise, việc quên try catch để bắt lỗi với hàm async cũng có thể xảy ra. Nếu bạn quên không bắt lỗi, thì khi đoạn mã bất đồng của bạn xảy ra lỗi có thể làm chương trình của bạn bị dừng lại. 1234567891011121314function wait(ms) &#123; if (ms &gt; 2015) throw new Error(ms) return new Promise(r =&gt; setTimeout(r, ms))&#125;async function main() &#123; console.log('sắp rồi...') await wait(2007) console.log('chờ tí...') await wait(2012) console.log('thêm chút nữa thôi...') await wait(2016) console.log('xong rồi đấy!')&#125; 3.4. Mất tính song songCái này có vẻ là căng nhất, bạn cứ khai báo await tuần tự đi rồi chương trình của bạn sẽ chậm như con rùa. hahaaa. Vì mỗi lần khai báo await như vậy là bạn cần phải chờ cho xử lý của await kết thúc. Kết quả là bạn có 1 con rùa chạy tuần tự qua từng nấc thang. 12345678910function wait(ms) &#123; return new Promise(r =&gt; setTimeout(r, ms))&#125;async function main() &#123; console.time('wait3s') await wait(1000) await wait(2000) console.timeEnd('wait3s')&#125; Với đoạn mã trên bạn sẽ mất tổng cộng là 1 + 2 = 3s để thực thi. Vì bạn phải chờ từng hàm wait một. Vậy làm sao để tránh được tình trạng trên? Câu trả lời là cứ cho xử lý bất đồng bộ chạy trước đi rồi lấy kết quả sau. Vì Promise có thể cho phép ta lấy kết quả bất cứ khi nào mà nó ở trạng thái cuối cùng, nên ta có thể chạy nó trước rồi lấy sau cũng không sao cả. 123456789101112function wait(ms) &#123; return new Promise(r =&gt; setTimeout(r, ms))&#125;async function main() &#123; console.time('wait2s') let w1 = wait(1000) let w2 = wait(2000) await w1 await w2 console.timeEnd('wait2s')&#125; Như đoạn mã này, ta chỉ mất 2s để thực hiện vì đoạn wait của ta được thực thi song song. Ngoài cách await từng Promise như trên ta có thể sử dụng Promise.all để song song hóa các Promise. 123456789function wait(ms) &#123; return new Promise(r =&gt; setTimeout(r, ms))&#125;async function main() &#123; console.time('wait2s') await Promise.all([wait(1000), wait(2000)]) console.timeEnd('wait2s')&#125; Lúc này, có thể bạn đang nghĩ Promise.all và await từng Promise là như nhau, nhưng nó khác nhau chút đấy. Promise.all chỉ ở trạng thái thành công khi mà tất cả các Promise được truyền vào xử lý thành công, còn nó sẽ ở trạng thái lỗi khi một trong các Promise truyền vào bị lỗi. Như vậy, nếu bạn muốn bỏ qua các Promise lỗi thì bạn không thể sử dụng Promise.all được đâu. Lúc đó bắt buộc bạn phải sử dụng await kèm với try catch cho từng Promise của bạn. 12345678910111213141516171819202122232425function wait(ms) &#123; if (ms &gt; 2000) throw new Error(ms) return new Promise(r =&gt; setTimeout(r, ms))&#125;async function main() &#123; const dur = [1000, 2000, 3000, 4000] let all = dur.map(ms =&gt; wait(ms)) try &#123; await Promise.all(all) console.log('Promise.all - done') &#125; catch (e) &#123; console.error('Promise.all:', e) &#125; let each = dur.map(ms =&gt; wait(ms)) each.forEach(async (func, index) =&gt; &#123; try &#123; await func console.log('each - done:', dur[index]) &#125; catch (e) &#123; console.error('each:', e) &#125; &#125;)&#125; 4. Nền tảng/ trình duyệt hỗ trợ Thời điểm này (2016/10), các nền tảng và trình duyệt sau đã hỗ trợ hàm async. Node.js v7.0 với cờ --harmony-async-await Chrome v5.55 Microsoft Edge v21.10547 Nếu bạn muốn chạy ở các nền tảng/ trình duyệt chưa hỗ trợ thì có thể dùng babel để chuyển đổi: Babel async-2-generator plugin 5. Kết luận Bản chất của hàm async chính là Promise, vì vậy để sử dụng được nó ta cần phải sử dụng Promise cho việc xử lý các thao tác bất đồng bộ. Bạn không thể nào sài await để đợi các hàm có sử dụng hàm phản hồi (callback) được, mà bắt buộc phải gắn nó với một Promise trước khi sử dụng await. Mặc dù hàm async có cú pháp rất rõ ràng, ta cũng cần phải lưu ý tránh khai báo thừa thiếu các từ khóa gây lỗi, gây hiểu lầm về lô-gíc chương trình. Và đặc biệt lưu ý tới khả năng làm mất đi tính song song của chương trình. Với sự tiện dụng của hàm async, ta nên cố gắng sử dụng nó ngay từ bây giờ để giảm thiểu việc bảo trì sau này. Với các nền tảng/ trình duyệt chưa hỗ trợ thì ta có thể chuyển đổi bằng babel. Hiện tại Node v7 vẫn đang sử dụng Chrome v5.54 nên muốn sử dụng được async/await, ta buộc phải chạy với cờ --harmony-async-await và hiệu năng, bộ nhớ được sử dụng vẫn chưa hiệu quả, không khuyến khích cho các sản phẩm thực tế. Tuy nhiên, rất có thể Node v8 sẽ sử dụng phiên bản Chrome v5.55 và cho phép ta thực hiện mặc định các hàm async. async chúc các bạn await vui vẻ!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://nthung2112.github.io/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"async","slug":"async","permalink":"http://nthung2112.github.io/tags/async/"},{"name":"await","slug":"await","permalink":"http://nthung2112.github.io/tags/await/"}]},{"title":"Bất ngờ về mảng trong javascript","slug":"Javascript-Bat-ngo-ve-mang-trong-javascript","date":"2017-01-10T13:02:14.000Z","updated":"2017-08-20T14:51:37.207Z","comments":true,"path":"2017/01/Javascript-Bat-ngo-ve-mang-trong-javascript.html","link":"","permalink":"http://nthung2112.github.io/2017/01/Javascript-Bat-ngo-ve-mang-trong-javascript.html","excerpt":"Từng làm việc với một vài ngôn ngữ lập trình (Java, C, C++, C#, Objective-C, PHP), mỗi ngôn ngữ đều có cái hay riêng. Nhưng khi tiếp xúc với JavaScript (JS) lại tự dưng thấy yêu nó, yêu cái vẻ sexy và bất ngờ của nó. Ví như mảng trong JS rất đặc biệt và bất ngờ. Trong bài này sẽ viết lại một số điểm có thể là bất ngờ với một số người như mình. 1. Bạn lấy độ dài của mảng thế nào?Hôm qua ngồi code lúc lấy độ dài mảng bằng thuộc tính length mới thấy khác biệt với phần tử lấy được, làm mình hơi ngạc nhiên một chút. Ngồi đọc lại tài liệu JS, mới thấy dường như nó không có thuộc tính lưu trữ số lượng phần tử hiện hữu (khác undefined) trong nó thì phải? Hoặc ít nhất là mình chưa rõ. Có cao thủ nào chỉ giáo cho thì tốt. Các bạn có thể thử đoạn mã sau thì sẽ thấy rằng thuộc tính length của mảng sẽ bằng tổng của index lớn nhất của mảng với 1. 12345var arr = []arr[10] = 0arr[20] = 'index 20'arr['js'] = 'JavaScript'console.log(arr.length)","text":"Từng làm việc với một vài ngôn ngữ lập trình (Java, C, C++, C#, Objective-C, PHP), mỗi ngôn ngữ đều có cái hay riêng. Nhưng khi tiếp xúc với JavaScript (JS) lại tự dưng thấy yêu nó, yêu cái vẻ sexy và bất ngờ của nó. Ví như mảng trong JS rất đặc biệt và bất ngờ. Trong bài này sẽ viết lại một số điểm có thể là bất ngờ với một số người như mình. 1. Bạn lấy độ dài của mảng thế nào?Hôm qua ngồi code lúc lấy độ dài mảng bằng thuộc tính length mới thấy khác biệt với phần tử lấy được, làm mình hơi ngạc nhiên một chút. Ngồi đọc lại tài liệu JS, mới thấy dường như nó không có thuộc tính lưu trữ số lượng phần tử hiện hữu (khác undefined) trong nó thì phải? Hoặc ít nhất là mình chưa rõ. Có cao thủ nào chỉ giáo cho thì tốt. Các bạn có thể thử đoạn mã sau thì sẽ thấy rằng thuộc tính length của mảng sẽ bằng tổng của index lớn nhất của mảng với 1. 12345var arr = []arr[10] = 0arr[20] = 'index 20'arr['js'] = 'JavaScript'console.log(arr.length) Đoạn mã trên sẽ in ra độ dài của mảng arr là 21, tức là bằng index lớn nhất (20) cộng với 1. Hơi bất ngờ chút vì lúc đầu mình nghĩ nó trả ra là 3 (số phần tử khác undefined) . Còn index không phải là dạng số tự nhiên thì có ý nghĩa gì không? Câu trả lời là không có ý nghĩa gì với thuộc tính length cả. Các bạn có thể xem trong ví dụ sau thì sẽ thấy độ dài length sẽ không phụ thuộc vào các index không thuộc dạng số tự nhiên. 12345var arr = []arr[-1] = 100arr['js'] = 'JavaScript'arr['me'] = 'Java Lover'console.log(arr.length) Đoạn mã này sẽ luôn in ra 0, chứng tỏ các index không số tự nhiên không ảnh hưởng gì tới thuộc tính length. Vậy câu hỏi đặt ra là làm thế nào để lấy được số phần tử chính xác của một mảng? Một cách làm đơn giản là duyệt mảng để đếm số lượng các phần tử hiện hữu của mảng đúng không? Thế nhưng mọi chuyện lại không đơn giản như ta nghĩ. 2. Bạn duyệt mảng thế nào?Duyệt mảng trong JS cũng rất thú vị. Cách duyệt mảng thông thường với một mảng là lấy length của nó rồi duyệt từ đầu tới cuối như sau. 1234567891011121314151617var arr = []arr[10] = 0arr[20] = 'index 20'arr['me'] = 'Java Lover'var counter = 0for (var i = 0, len = arr.length; i &lt; len; i ++) &#123; console.log(i + \": \" + arr[i]) if (typeof(arr[i]) != 'undefined') counter ++&#125;// hoặc như saufor (var i = arr.length; i &gt; 0; -- i) &#123; console.log(i + \": \" + arr[i]) if (typeof(arr[i]) != 'undefined') counter ++&#125;console.log('The size of array: %d', counter) Kết quả đoạn mã trên sẽ trả ra các phần từ có index từ 0 ~ 9 và 11 ~ 19 là undefined, và counter sẽ là 2.Như vậy là counter không cho ra kết quả chính xác và với một mảng lớn (1000 phần tử chẳng hạn) ta không thể duyệt theo cách này được. Vậy phải có cách khác, ta thử dùng hàm forEach của Array xem sao. 12345678910var arr = []arr[10] = 0arr[20] = 'index 20'arr['me'] = 'XXX Lover'var counter = 0arr.forEach(function(ele, i, array) &#123; console.log(i + \": \" + ele) counter ++&#125;)console.log('The size of array: %d', counter) Cách này vẫn không ăn thua, kết quả lại như duyệt theo biến length. Thêm một cách duyệt khác là với lệnh for in như sau. 12345678910var arr = []arr[10] = 0arr[20] = 'index 20'arr['me'] = 'Java Lover'var counter = 0for (var i in arr) &#123; console.log(i + \": \" + arr[i]) counter ++&#125;console.log('The size of array: %d', counter) Đoạn này lại cho ra kết quả chính xác với từng phần tử được in ra và kích cỡ mảng trả về là 3. Từ đây ta có thể thấy một điều là nên cẩn thận với biến length của mảng và nên chú ý cách duyệt mảng sao cho hợp lý. Với các dữ liệu liên tục ta hoàn toàn có thể duyệt theo biến length hay Array.forEach, nhưng dữ liệu cách đoạn và index không là số tự nhiên thì cần theo cách duyệt for in. 3. Làm sao để biết một biến là mảng?Các bạn thử chạy đoạn mã sau xem thế nào. 12345678var arr = []arr[10] = 0arr[20] = 'index 20'arr['me'] = 'JavaScript Lover'console.log(\"Trust me, men, I'm an Array @@\")console.log(\"Really, I have to check your DNA.\")console.log(\"JavaScript checker: arr is \" + typeof(arr)) ??? Mày là Object mà sao lại bảo là Array?Không cháu là mảng mà, bác thử kiểm tra với cái máy này xem. 1234567var arr = []arr[10] = 0arr[20] = 'index 20'arr['me'] = 'JavaScript Lover'console.log(\"JavaScript checker: Is arr an array ... \" + (Object.prototype.toString.apply(arr) === \"[object Array]\")) Ồ, ồ khỉ thật sao lại thế nhỉ? Đấy cháu dòng giống hoàng tộc nên phải ẩn mình thế đấy. Đúng là nhìn gái xinh thì dễ chứ nhìn gái tốt hay xấu phải có mẹo thật. Để kết thúc bài, dành tặng cho các bạn beginner về NodeJS một đoạn mã nhỏ. Bài toán đặt ra là lấy nội dung 3 trang web (giao thức http) với địa chỉ nhập từ bàn phím theo dạng bất đồng bộ và in ra nội dung các trang đó theo đúng thứ tự đầu vào nhập từ bàn phím.Chắc code này không phải giải thích nhiều các bạn cũng sẽ thấy có mối tương quan với nội dung mình vừa viết phía trên.1234567891011121314151617181920212223242526var http = require('http')var bl = require('bl')var data = []var counter = 0function printData() &#123; for (var i = 0; i&lt; 3; i++) console.log(data[i])&#125;function loadData(index) &#123; http.get(process.argv[2 + index], function(resp) &#123; resp.pipe(bl(function(err, buf) &#123; if (err) data[index] = err.toString() else data[index] = buf.toString() counter ++ if (counter === 3) printData() &#125;)) &#125;)&#125;for (var i = 0; i &lt; 3; i++) loadData(i) Bài này tạm thời thế, khi nào gặp vấn đề lại update tiếp. Mong các cao thủ biết được gì thêm về mảng trong JavaScript thì chỉ giáo cho các hạ.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://nthung2112.github.io/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"array","slug":"array","permalink":"http://nthung2112.github.io/tags/array/"}]},{"title":"Tìm hiểu về call, apply và bind","slug":"Javascript-Tim-hieu-ve-call-apply-va-bind","date":"2017-01-10T12:57:42.000Z","updated":"2017-08-20T14:51:23.254Z","comments":true,"path":"2017/01/Javascript-Tim-hieu-ve-call-apply-va-bind.html","link":"","permalink":"http://nthung2112.github.io/2017/01/Javascript-Tim-hieu-ve-call-apply-va-bind.html","excerpt":"Như trong bài về từ khóa this đã đề cập tới ngữ cảnh thực thi với mối tương quan tới từ khóa this và việc thay đổi được ngữ cảnh thực thi một cách trực tiếp bằng cách sử dụng call, apply và bind, thì bài viết này sẽ làm rõ ràng hơn 3 phương thức này và sự khác nhau cũng như tính hữu dụng của nó. Về cơ bản call và apply gần giống nhau và được giới thiệu từ phiên bản 3 theo chuẩn ECMAScript, còn bind được giới thiệu từ phiên bản 5 thì lại khác hẳn về bản chất nhưng cũng có mối quan hệ mật thiết với 2 phương thức kia. Vậy nên trong bài này ta sẽ đi dần từ call với apply tới bind.","text":"Như trong bài về từ khóa this đã đề cập tới ngữ cảnh thực thi với mối tương quan tới từ khóa this và việc thay đổi được ngữ cảnh thực thi một cách trực tiếp bằng cách sử dụng call, apply và bind, thì bài viết này sẽ làm rõ ràng hơn 3 phương thức này và sự khác nhau cũng như tính hữu dụng của nó. Về cơ bản call và apply gần giống nhau và được giới thiệu từ phiên bản 3 theo chuẩn ECMAScript, còn bind được giới thiệu từ phiên bản 5 thì lại khác hẳn về bản chất nhưng cũng có mối quan hệ mật thiết với 2 phương thức kia. Vậy nên trong bài này ta sẽ đi dần từ call với apply tới bind. 1. Call và ApplyCú pháp: call() Function.prototype.call(thisArg[, arg1[ , arg2, …]]) apply() Function.prototype.apply(thisArg, argArray) Phương thức call() và apply() để gọi thực thi một hàm với một ngữ cảnh chỉ định thông qua tham số thisArg và các tham số đầu vào của hàm tương ứng. Tức là nó sẽ cho phép hàm thực thi được với một ngữ cảnh chỉ định nào đó tuỳ ý. Sự khác nhau giữa chúng là call() sẽ nhận tham số hàm qua từng biến đầu vào riêng biệt còn apply() thì lại nhận các tham số hàm qua một mảng chứa các biến đầu vào. Ta cùng xét ví dụ bên dưới: 12345678910111213141516171819202122232425var obj = &#123; firstName: \"Vô\", lastName : \"Danh\", mMethod: function(firstName, lastName) &#123; var firstName = firstName || this.firstName var lastName = lastName || this.lastName console.log(\"Hello \" + firstName + \" \" + lastName) &#125;&#125; var obj1 = &#123; firstName: \"Ông\", lastName : \"Ké\"&#125;;obj.mMethod() // Hello Vô Danhobj.mMethod.call(obj1) // Hello Ông Kéobj.mMethod.apply(obj1) // Hello Ông Ké obj.mMethod.call(obj1, \"Thị\", \"Nở\") // Hello Thị Nởobj.mMethod.apply(obj1, [\"Chí\", \"Phèo\"]) // Hello Chí Phèo Với đoạn mã trên ta có thể thấy rằng, sau khi gọi call() hoặc apply() ngữ cảnh thực thi của mMethod đã được đổi sang obj1 và call() cho phép ta truyền tham số đầu vào riêng biệt còn apply() lại cho phép truyền vào như một mảng. Từ phiên bản 5, apply() còn có thể được truyền vào một đối tượng tựa mảng (chú thích [1]) thay vì mảng: 12345678910111213141516171819var obj = &#123; firstName: \"Vô\", lastName : \"Danh\", mMethod: function(firstName, lastName) &#123; var firstName = firstName || this.firstName var lastName = lastName || this.lastName console.log(\"Hello \" + firstName + \" \" + lastName) &#125;&#125; var obj1 = &#123; firstName: \"Ông\", lastName : \"Ké\"&#125;;obj.mMethod.apply(obj1, [\"Chí\", \"Phèo\"]) // Hello Chí Phèoobj.mMethod.apply(obj1, &#123;'length': 2, '0': \"Chí\", '1': \"Phèo\"&#125;) // Hello Chí Phèo Với việc sử dụng call() hoặc apply() ta có thể làm được rất nhiều việc hay ho như sử dụng phương thức của một ngữ cảnh khác như ở ví dụ trên, hay đẩy ngữ cảnh thực thi cho hàm phản hồi hoặc thay đổi cách truyền tham số hàm rất hiểu quả. Các bạn có thể xem ở ví dụ sau: Truyền ngữ cảnh thực thi cho hàm phản hồi 1234567891011121314function print() &#123; console.log(this.mVal)&#125;var obj = &#123; mVal: \"Tôi yêu thành phố Hồ Chí Minh\", mMethod: function(callback) &#123; // truyền đối tượng hiện tại cho hàm phản hồi callback callback.call(this) &#125;&#125;obj.mMethod(print) Thay đổi cách truyền tham số hàm123// Math.min([value1[,value2[, ...]]])// Ta sử dụng mảng cho tham số đầu vào thay vì các giá trị rời rạcconsole.log (Math.min.apply(null, [100, -1, 8, 219])) // -1 Cũng không tồi đấy chứ, bằng call, apply ta có thể linh hoạt hơn khi lập trình, đỡ được nhiều công sức biến đổi rắc rối và tận dụng được mã nguồn rất hiệu quả. 2. BindCú pháp: Function.prototype.bind( thisArg[, arg1[ , arg2, …]]) Phương thức bind() sẽ tạo ra một hàm mới có nội dung thực thi như hàm được gọi nhưng được gắn với một ngữ cảnh thực thi chỉ định qua tham số thisArg. Như vậy khác với call() và apply(), bind() sẽ không gọi để thực thi hàm mà sẽ lưu lại ngữ cảnh thực thi cho một hàm nào đó như ví dụ sau: 123456789101112131415var obj = &#123; mVal: \"Việt Nam\", mMethod: function() &#123; console.log(\"Hello \" + this.mVal) &#125;&#125; var oMethod = obj.mMethod.bind(obj) // this trong oMethod sẽ bị ép thành giá trị objoMethod() // Hello Việt Namobj.mVal = \"Hà Nội\" oMethod() // Hello Hà Nội Như vậy khác với call() và apply(), khi gọi bind() hàm sẽ không thực thi ngay mà chỉ gắn ngữ cảnh thực thi cho phương thức mMethod. Vì mMethod được gắn với ngữ cảnh đối tượng obj, nên mỗi lần thực thi nó sẽ sử dụng this như là đối tượng obj. Như trong ví dụ phía trên, sau khi ta thay đổi giá trị của biến mVal trong đối tượng obj thì mMethod cũng sẽ in ra giá trị đã bị thay đổi. Về bản chất thì bind() có thể được thực hiện như sau:123456Function.prototype.bind = function(context) &#123; var _this = this; return function() &#123; _this.apply(context, arguments); &#125;;&#125;; Bằng việc sử dụng apply(), ta có thể thay đổi ngữ cảnh thực thi cho một hàm, còn để lưu lại ngữ cảnh dành cho việc thực thi sau này ta tạo ra một hàm mới như trong đoạn mã trên. Vì tính chất lưu lại được ngữ cảnh nên bind() rất hay được sử dụng với hàm phản hồi như xử lý sự kiện click vào một nút nào đó chẳng hạn. Ví dụ như khi sử dụng jQuery, ta có thể lấy được giá trị cho this bằng button trong các hàm phản hồi của sự kiện click vào một button vì jQuery đều đã buộc (bind) sẵn button cho hàm phản hồi được truyền vào. 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; $(\"#btn\").click(function()&#123; console.log(this) $(this).text(Number($(this).text()) + 1) &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;0&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; Ngoài ra, ta có thể làm được rất nhiều việc khá hay ho như tạo shortcut cho hàm nào đó, hay nhóm lại các tham số theo từng cụm như ví dụ bên dưới: 12345678910111213141516171819202122232425262728var obj = &#123; firstName: \"Thánh\", lastName: \"Gióng\", mMethod: function(hello, firstName, lastName) &#123; var hello = hello || \"Hello\" ,firstName = firstName || this.firstName ,lastName = lastName || this.lastName console.log(hello + \" \" + firstName + \" \" + lastName); &#125;&#125;// tạo shortcutvar print = obj.mMethod.bind(obj)print()var print = obj.mMethod.bind(obj, \"Hello\", \"Mr\", \"Bean\")print()// Nhóm theo helloprint = obj.mMethod.bind(obj, \"Xin chào bạn\")print()// Nhóm theo firstNameprint = obj.mMethod.bind(obj, \"Kính chào ngài\", \"Nguyễn\")print(\"Trãi\")print(\"Xiển\") 3. Vui vẻ týNhư bên trên đã phân tích, khi ta cần thực thi một function cho một ngữ cảnh khác, ta cần sử dụng call, apply hoặc bind, nhưng có một cách vượt mặt để không cần sử dụng nó. Bạn có thể xem ví dụ sau: 123456789101112131415161718192021222324252627var obj = &#123; firstName: \"Vô\", lastName : \"Danh\", mMethod: function(firstName, lastName) &#123; var firstName = firstName || this.firstName var lastName = lastName || this.lastName console.log(\"Hello \" + firstName + \" \" + lastName) &#125;&#125; var obj1 = &#123; firstName: \"Ông\", lastName : \"Ké\"&#125;;obj.mMethod.apply(obj1) // Hello Ông Ké// vượt mặt ở đâyvar method = Function.call.bind(obj.mMethod)method(obj1) // Hello Ông Ké// vượt mặt trong prototype của objectmethod = Function.call.bind(Array.prototype.slice)console.log(method([100, 20, 40], 1)) // [20, 40] Với đoạn mã trên, ta có thế thấy rằng khi gọi method ta không cần phải gọi call, apply hay bind ra nữa mà chỉ cần đẩy trực tiếp đối tượng cần gọi và tham số vào là đủ. Khá hay ho đấy chứ? gọi call, apply, bind mãi cũng chán, overcome một tý thấy nó tiện hơn hẳn. Ta có thể làm được như vậy là vì tất cả các function trong JavaScript đều kế thừa từ đối tượng Function.prototype, nên hiển nhiên nó có tất cả các function được định nghĩa từ Function.prototype như call, apply hay bind. Như vậy, ta hoàn toàn có thể gọi được các phương thức kế thừa này từ một function bất kì. Với ví dụ trên, ta coi obj.mMethod là một đối tượng cần gọi tới phương thức call thì ta hoàn toàn có thể tạo một phương thức method trực tiếp từ phương thức call mà đã được gắn thisVal bằng obj.mMethod: Function.call.bind(obj.mMethod) hoặc Function.prototype.call.bind(obj.mMethod). Hay nói cách khác, phương thức method mới được tạo ra có nội dung giống như phương thức call và đối tượng chứa nó (gọi nó - this) là đối tượng obj.mMethod nên method() ~ obj.mMethod.call(). 4. Kết luậnBằng việc sử dụng call, apply và bind ta có thể thay đổi được ngữ cảnh thực thi (phạm vi chứa hàm) để sử dụng một hàm với công dụng đa năng hơn như thực thi cho một đối tượng, phạm vi khác khác giúp ta có thể tận dụng tối đa mã nguồn được đã tạo ra, hay tạo shortcut cho hàm, linh hoạt hơn tham số đầu vào. Với call và apply chúng ta sử dụng để thực thi hàm đó luôn khi gọi, còn với bind ta có thể thực thi hàm đó nhiều lần sau khi đã được buộc (bind) với một ngữ cảnh nhất định. Chú thích[1] đối tượng tựa mảng: Một đối tượng tựa mảng (array-like object) là một đối tượng có các thuộc tính là số tự nhiên và có một thuộc tính bắt buộc là length có giá trị bằng số các thuộc tính là số tự nhiên. Ví dụ: {length: 3, 0: &quot;Tôi&quot;, 1: &quot;là&quot;, 2: &quot;người Việt&quot;} hoặc {&#39;length&#39;: 3, &#39;0&#39;: &quot;Tôi&quot;, &#39;1&#39;: &quot;là&quot;, &#39;2&#39;: &quot;người Việt&quot;}.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://nthung2112.github.io/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"call","slug":"call","permalink":"http://nthung2112.github.io/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://nthung2112.github.io/tags/apply/"},{"name":"bind","slug":"bind","permalink":"http://nthung2112.github.io/tags/bind/"}]},{"title":"Tìm hiểu về từ khóa this","slug":"Javascript-Tim-hieu-ve-tu-khoa-this","date":"2017-01-10T12:55:00.000Z","updated":"2017-08-20T14:51:16.099Z","comments":true,"path":"2017/01/Javascript-Tim-hieu-ve-tu-khoa-this.html","link":"","permalink":"http://nthung2112.github.io/2017/01/Javascript-Tim-hieu-ve-tu-khoa-this.html","excerpt":"123456789101112// app.js// câu hỏi: Đoán kết quả lệnh (1) và lệnh (2)var obj = &#123; mMethod: function() &#123; console.log(this) &#125;&#125;obj.mMethod(); // (1)var _mMethod = obj.mMethod;_mMethod(); // (2) JavaScript (JS) là một ngôn ngữ lập trình khá linh hoạt và thú vị. Nhưng để có được điều đó nó cũng mang tới không ít phiền phức, dễ nhầm lẫn với những người không chuyên. Với những người mới sờ vào JS, họ thường nghĩ ngay chắc JS cũng lơ lớ như các ngôn ngữ lập trình khác như Java hay C#. Nhưng nhiều điểm ở JS lại khá khác với suy nghĩ ở các ngôn ngữ khác gây nên những hiểu lầm cho người mới vào nghề. Một trong những điểm dễ nhầm lẫn đó là biến this vì trong JS nó không chỉ đơn giản là đại diện cho đối tượng hiện thời như các ngôn ngữ lập trình hướng đối tượng khác. Cụ thể ra sao ta cùng nhau xem xét ở bài viết này. Đọc tới đây chắc một số bạn biết về this rồi sẽ bật cười là sao lại viết là biến this. Nếu bạn nghĩ tới mức đó thì xin chúc mừng bạn, bạn đã đúng. this trong JS là một từ khoá chứ không phải là một biến nào cả. Bạn không thể gắn giá trị trực tiếp cho this được cũng như chẳng thể nào delete nó đi. Vậy từ khoá này có gì lại rắc rối vậy?","text":"123456789101112// app.js// câu hỏi: Đoán kết quả lệnh (1) và lệnh (2)var obj = &#123; mMethod: function() &#123; console.log(this) &#125;&#125;obj.mMethod(); // (1)var _mMethod = obj.mMethod;_mMethod(); // (2) JavaScript (JS) là một ngôn ngữ lập trình khá linh hoạt và thú vị. Nhưng để có được điều đó nó cũng mang tới không ít phiền phức, dễ nhầm lẫn với những người không chuyên. Với những người mới sờ vào JS, họ thường nghĩ ngay chắc JS cũng lơ lớ như các ngôn ngữ lập trình khác như Java hay C#. Nhưng nhiều điểm ở JS lại khá khác với suy nghĩ ở các ngôn ngữ khác gây nên những hiểu lầm cho người mới vào nghề. Một trong những điểm dễ nhầm lẫn đó là biến this vì trong JS nó không chỉ đơn giản là đại diện cho đối tượng hiện thời như các ngôn ngữ lập trình hướng đối tượng khác. Cụ thể ra sao ta cùng nhau xem xét ở bài viết này. Đọc tới đây chắc một số bạn biết về this rồi sẽ bật cười là sao lại viết là biến this. Nếu bạn nghĩ tới mức đó thì xin chúc mừng bạn, bạn đã đúng. this trong JS là một từ khoá chứ không phải là một biến nào cả. Bạn không thể gắn giá trị trực tiếp cho this được cũng như chẳng thể nào delete nó đi. Vậy từ khoá này có gì lại rắc rối vậy? 1. Bản chất của từ khoá thisCác đoạn mã của JavaScript được thực thi trong một ngữ cảnh nhất định (Execution Context). Các ngữ cảnh này lại được sắp xếp để thực hiện chương trình một cách tuần tự. Bạn có thể tưởng tượng thế này, mỗi ngữ cảnh chứa một số đoạn mã nhất định, và toàn chương trình của ta sắp xếp các ngữ cảnh này vào một ngăn xếp (stack). Sau đó các ngữ cảnh sẽ được gọi ra thực thi dần cho tới hết, tức là ngữ cảnh trên đỉnh của ngăn xếp sẽ chứa các đoạn mã sẵn sàng chạy. Mỗi ngữ cảnh thực thi này có tương ứng một ThisBinding có giá trị không đổi đại diện cho ngữ cảnh thực thi đó. Và từ khoá this sẽ bằng giá trị ThisBinding trong ngữ cảnh đang thực thi hiện thời. Như vậy this sẽ đại diện cho ngữ cảnh đang thực thi và nó cần được đánh giá lại tham chiếu khi ngữ cảnh thực thi thay đổi. Có 3 kiểu ngữ cảnh thực thi là toàn cục (global), eval và hàm (function). Global là ngữ cảnh ở mức trên cùng của toàn bộ chương trình, tức là nó chứa các đoạn mã không nằm trong function hay được gọi bởi eval và global sẽ là ngữ cảnh thực thi chương trình mặc định. Eval là ngữ cảnh chứa các mã được gọi bởi hàm eval. Còn function là các đoạn mã nằm trong một function nào đó. Ta sẽ xem chi tiết từng ngữ cảnh thực thi qua phần dưới đây. 2. Các ngữ cảnh thực thi2.1. Toàn cục - GlobalLà ngữ cảnh thực thi nằm ở trên cùng của ngăn xếp ngữ cảnh, tức là ngữ cảnh đầu tiên thực thi chương trình. Ví dụ trong các mã thực thi phía máy khách trong trang web thì ngữ cảnh toàn cục này nằm ngay sau thẻ . Trong ngữ cảnh toàn cục này thì ThisBinding sẽ được thiết lập giá trị là đối tượng toàn cục (Global Object). Trong Nodejs thì đối tượng toàn cục là đối tượng toàn cục của Nodejs - khởi đầu là một đối tượng trống, trong trình duyệt thì nó là đối tượng window, nhưng cần chú ý là nếu ở trong chế độ strict mode thì đối tượng toàn cục là undefined. Ta có thể cùng nhau xem xét ví dụ dưới đây. 12345678910111213console.log(this) // đối tượng toàn cục trong ngữ cảnh toàn cụcthis.mX = \"I love JavaScript\" // sử dụng đối tượng toàn cụcconsole.log(this.mX) // in ra giá trị của thuộc tính mXvar obj = &#123; mMethod: function() &#123; console.log(this) // in ra giá trị this hiện thời &#125;&#125;obj.mMethod() // không còn là đối tượng toàn cục nữa 2.2. Gọi mã - EvalVới trường hợp sử dụng hàm eval ta phân làm 2 trường hợp. 2.2.1. Gọi eval trực tiếpGọi eval trực tiếp là ta gọi trực tiếp hàm eval như ví dụ bên dưới. Với trường hợp này thì ThisBinding sẽ được gắn giá trị là ngữ cảnh gốc của đoạn mã đó. 12345678910111213function callMe() &#123; console.log(this)&#125;var obj = &#123; callMe: function() &#123; console.log(this) &#125;&#125;eval(\"callMe()\") // đối tượng toàn cụceval(\"obj.callMe()\") // đối tượng obj 2.2.2. Gọi eval gián tiếpGọi eval gián tiếp là ta gọi hàm eval thông qua một biến được gắn giá trị tương ứng như truyền hàm eval qua tham số hàm khác hoặc gắn nó với một biến nào đó. Với trường hợp này thì ThisBinding sẽ được gắn giá trị là ngữ toàn cục. 1234567891011121314151617181920// this trong mã thực thi của eval sẽ là đối tượng toàn cụcthis.callMe = function () &#123; console.log(\"callMe in Global Object\")&#125;var obj = &#123; callMe: function() &#123; console.log(this) &#125;, _callMe: function(_eval) &#123; _eval(\"console.log(this)\") _eval(\"callMe()\") &#125;&#125;obj._callMe(eval) // gọi gián tiếp eval qua tham số hàmvar mEval = eval // gắn eval với một biếnmEval(\"console.log(this)\") // gọi gián tiếp eval qua biến mEval 2.3. Hàm - FunctionKhi hàm được gọi thì ngữ cảnh thực thi của nó sẽ phụ thuộc vào tham số đầu vào và ngữ cảnh gọi nó. Giả sử hàm của ta là F, với tham số là argumentsLits, và ngữ cảnh gọi F tương ứng với thisValue. Việc xác định thisBinding được xác định như sau: If hàm trong chế độ strict, ThisBinding được gắn là thisValue. Else if thisValue là null hoặc undefined, ThisBinding được gắn là đối tượng toàn cục. Else if Type(thisValue) không là Object, ThisBinding được gắn là ToObject(thisValue). Else ThisBinding được gắn là thisValue Xem thêm về cách gắn thisBinding ở đây. Để rõ ràng hơn ta xét một số tình huống cụ với việc gọi hàm. 2.3.1. Gọi thông qua ngữ cảnh toàn cụcTrường hợp này this sẽ tham chiếu tới đối tượng toàn cục.123456789101112131415function mMethod() &#123; console.log(this) // đối tượng toàn cục - global object&#125;mMethod();var obj = &#123; myMethod: function() &#123; return (function()&#123; console.log(this) // đối tượng toàn cục &#125;)(); &#125;&#125;obj.myMethod() 2.3.2. Gọi thông qua đối tượngTrường hợp này this sẽ tham chiếu tới đối tượng thisValue - đối tượng tương ứng chứa hàm. 12345678910111213141516171819202122232425262728293031323334353637// Tạo đối tượng objvar obj = &#123; mMethod: function() &#123; console.log(this) &#125;, oMethod: function() &#123; console.log('▼ oMethod') console.log(this) console.log('▲ oMethod') &#125;&#125;obj.mMethod() // this sẽ tương ứng với đối tượng objobj['oMethod']() // this sẽ tương ứng với đối tượng obj// Gắn mMethod cho đối tượng khácvar obj1 = &#123; mVal: \"I'm obj1\"&#125;obj1.mMethod = obj.mMethod;obj1.mMethod() // this sẽ tương ứng với đối tượng obj1// Gọi qua khởi tạo đối tượng với từ khoá newfunction MyObject(val) &#123; this.mVal = val || \"I xxx JS\"; this.mMethod = function() &#123; console.log(this) &#125;;&#125;var mObj1 = new MyObject()var mObj2 = new MyObject(\"I'm object 2\")mObj1.mMethod() // this sẽ tương ứng với đối tượng mObj1mObj2.mMethod() // this sẽ tương ứng với đối tượng mObj2 2.3.3. Gọi thông qua một số hàm đặc biệtTrong JavaScript có xây dựng sẵn một số hàm đặc biệt cho phép ta sử dụng this qua đối tượng đầu vào như: Function.prototype.apply(thisArg, argArray) Function.prototype.call(thisArg[, arg1[ , arg2, …]]) Function.prototype.bind( thisArg[, arg1[ , arg2, …]]) Array.prototype.every(callback[, thisArg]) Array.prototype.some(callback[, thisArg]) Array.prototype.forEach(callback[, thisArg]) Array.prototype.map(callback[, thisArg]) Array.prototype.filter(callback[, thisArg]) Bằng việc sử dụng các hàm trên ta có thể thể sử dụng this như là giá trị của đối tượng thisArg. Việc này rất tiện cho ta thay đổi thisBinding một cách chủ động. Ta có thể xem ví dụ sau: 123456789101112131415161718var obj = &#123; mMethod: function(firstName, lastName) &#123; var firstName = firstName || \"Vô\" var lastName = lastName || \"Danh\" console.log(\"Hello \" + firstName + \" \" + lastName) console.log(this) &#125;&#125;var obj1 = &#123; mVal: \"I'm obj1\"&#125;;obj.mMethod.apply(obj1) // đối tượng obj1obj.mMethod.apply(obj1, [\"Chí\", \"Phèo\"]) // đối tượng obj1obj.mMethod.call(obj1, \"Thị\", \"Nở\") // đối tượng obj1 Đoạn mã trên sẽ in ra this là đối tượng obj1 chứ không còn là obj, do call và apply đã đẩy trực tiếp this qua tham số đầu vào. 3. Một số trường hợp dễ nhầm lẫn3.1. Gọi thông qua ngữ cảnh khácTa xét trường hợp sau: 1234567891011var obj = &#123; mVal: \"Việt Nam\", mMethod: function() &#123; console.log(\"Hello \" + this.mVal) &#125;&#125;var oMethod = obj.mMethod // oMethod nằm trong ngữ cảnh toàn cụcoMethod() Khi thực hiện đoạn mã trên kết quả in ra sẽ là Hello undefined, vì ta đã đẩy this ra đối tượng toàn cục mất rồi. Vậy làm sao để có được đúng kết quả là Hello Việt Nam? Để giải quyết được cái này ta sẽ sử dụng hàm bind để đẩy giá trị đối tượng obj cho biến this ở đây như sau: 1234567891011var obj = &#123; mVal: \"Việt Nam\", mMethod: function() &#123; console.log(\"Hello \" + this.mVal) &#125;&#125;var oMethod = obj.mMethod.bind(obj) // this trong oMethod sẽ bị ép thành giá trị objoMethod() Vì sao lại là bind mà không phải là call hay apply? Vì bind sẽ giữ giá trị của obj để gọi nhiều lần chứ không chỉ gọi một lần như với call hay apply. Các bạn có thể đọc thêm ở đây.Với trường hợp gọi một lần với call hoặc apply ta có thể cùng nhau xem ví dụ sau: 12345678910111213var obj = &#123; mVal: \"Việt Nam\", mMethod: function() &#123; console.log(\"Hello \" + this.mVal) &#125;&#125;var obj1 = &#123; mVal: \"Nhật Bản\" &#125;obj.mMethod.call(obj1) // in ra là: Hello Nhật Bản Đoạn mã trên sẽ gọi hàm mMethod của đối tượng obj nhưng this trong hàm mMethod đã được ép thành đối tượng obj1. Với việc gọi 1 lần này ta có thể mượn phương thức mMethod của đối tượng obj để thực thi cho đối tượng obj1 mà không cần tạo phương thức này cho đối tượng obj1. Cái này khá kool đúng hem ^.^ 3.2. Hàm phản hồi - CallbackGọi thông qua hàm phản hồi cũng chính là một trường hợp của gọi thông qua ngữ cảnh khác vì hàm phản hồi được thực thi trong một ngữ cảnh khác. Ta xét ví dụ sau: 123456789101112131415var obj = &#123; mVal: \"Việt Nam\", mMethod: function() &#123; console.log(\"Hello \" + this.mVal) &#125;&#125;var obj1 = &#123; oMethod: function(callback) &#123; return callback(); &#125;&#125;obj1.oMethod(obj.mMethod) Vì gọi trong ngữ cảnh của đối tượng obj1 nên mMethod lúc này sẽ lấy giá trị cho this là obj1 chứ không còn là obj nữa. Vẫn làm tương tự như phần 3.1, ta sử dụng bind để đẩy giá trị ngữ cảnh obj vào cho mMethod như sau: 123456789101112131415var obj = &#123; mVal: \"Việt Nam\", mMethod: function() &#123; console.log(\"Hello \" + this.mVal) &#125;&#125;var obj1 = &#123; oMethod: function(callback) &#123; return callback(); &#125;&#125;obj1.oMethod(obj.mMethod.bind(obj)) Hoàn hảo, đoạn mã trên đã cho ta kết quả như mong muốn. Đọc tới đây, nhiều bạn thắc mắc sao cần gì phải tách ra 3.1 với 3.2 làm gì cho rắc rối? Tách ra thế này có lợi thế là không bị vướng quá nhiều vấn đề vào cả một cụm, ví hàm phản hồi là một trường hợp rất hay được sử dụng khi lập trình với JavaScript. Ví dụ như trong Nodejs, hàm phản hồi là một thành phần quan trọng, một khái niệm cơ bản nhất cần nắm được để có thể lập trình với Nodejs. Hay nhiều bạn có sử dụng JQuery để làm phía trình duyệt, các sự kiện click vào một nút nào đó chẳng hạn, các bạn đều sử dụng luôn được từ khoá this ngay trong hàm phản hồi của các nút đó mà không cần quan tâm tới ngữ cảnh thực thi hiện tại là gì cả. Để làm được việc đó, jQuery đều đã bind các nút tương ứng đó cho các hàm phản hồi cho các bạn rồi đó. 3.3. Hàm lồng nhauTa cùng xét sự nhập nhằng qua ví dụ sau. 1234567891011121314151617var obj = &#123; mVal: \"Việt Nam\", oVal: &#123; oMethod: function(callMe) &#123; callMe() &#125; &#125;, mMethod: function() &#123; this.oVal.oMethod(function() &#123; console.log(\"Hello \" + this.mVal) &#125;) &#125;&#125;obj.mMethod() // in ra là: Hello undefined Với đoạn mã trên ta mong muốn nó in ra được giá chỉ của biến mVal trong đối tượng obj nhưng thực tế nó sẽ in ra Hello undefined? Nguyên nhân là ngữ cảnh của thực thi ở console.log lúc này là đối tượng oVal mất rồi. Vậy làm sao ta có thể sử dụng được biến mVal của đối tượng obj? Muốn làm được như vậy ta cần lấy được ngữ cảnh thực thi của đối tượng obj bằng cách nhớ lại ngữ cảnh thực thi thông qua một biến trung gian và sử dụng biến này với ngữ cảnh của đối tượng oVal. Ví dụ dưới đây sẽ thực hiện theo ý tưởng này: 12345678910111213141516171819var obj = &#123; mVal: \"Việt Nam\", oVal: &#123; oMethod: function(callMe) &#123; callMe() &#125; &#125;, mMethod: function() &#123; var _this = this; // nhớ ngữ cảnh thực thi của obj trong biến _this this.oVal.oMethod(function() &#123; console.log(\"Hello \" + _this.mVal) // gọi tới ngữ cảnh thực thi của obj &#125;) &#125;&#125;obj.mMethod() 4. Kết luậnTừ khoá this hơi rắc rối một chút nên khi lập trình ta cần chú ý tới ngữ cảnh thực thi để sử dụng từ khoá này cho hiệu quả và đúng đắn dựa vào ngữ cảnh gọi nó và kiểu của ngữ cảnh thực thi. Ta cũng cần chú ý hơn ở những đoạn sử dụng tới hàm phản hồi hay hàm lồng nhau. Ngoài ra ta có thể thay đổi được ngữ cảnh thực thi của một đối tượng bằng cách sử dụng call, apply hoặc bind như đã mô tả phía trên. Về việc sử dụng Call, Apply và Bind cụ thể ra sao thì các bạn đọc thêm ở bài viết này. Ngoài ra, bạn có thể tham khảo về chuẩn ECMAScript 5.1 ở đây.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://nthung2112.github.io/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"this","slug":"this","permalink":"http://nthung2112.github.io/tags/this/"}]}]}