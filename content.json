{"meta":{"title":"Learn and Share","subtitle":null,"description":"Learn any share","author":"Hung Tan Nguyen","url":"http://nthung2112.github.io"},"pages":[{"title":"About me","date":"2017-03-09T01:12:38.000Z","updated":"2017-08-20T15:08:41.686Z","comments":true,"path":"about/index.html","permalink":"http://nthung2112.github.io/about/index.html","excerpt":"","text":"Hi all, Tôi là Hung Tan Nguyen. Tôi viết blog này mục đích để note lại những kiến thức mình đã tham khảo và học hỏi được, bên cạnh đó mình cũng muốn chia sẻ những kinh nghiệm của mình để nâng cao thêm kiến thức của mình. Thanks all."},{"title":"Categories","date":"2017-03-09T14:16:54.197Z","updated":"2017-03-09T14:16:54.197Z","comments":true,"path":"categories/index.html","permalink":"http://nthung2112.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-03-09T14:16:54.197Z","updated":"2017-03-09T14:16:54.197Z","comments":true,"path":"tags/index.html","permalink":"http://nthung2112.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Làm thế nào để thành thạo CSS Grid trong nháy mắt","slug":"Lam-the-nao-de-thanh-thao-CSS-Grid-trong-nhay-mat","date":"2018-07-10T01:10:00.000Z","updated":"2018-07-10T02:08:58.475Z","comments":true,"path":"2018/07/Lam-the-nao-de-thanh-thao-CSS-Grid-trong-nhay-mat.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Lam-the-nao-de-thanh-thao-CSS-Grid-trong-nhay-mat.html","excerpt":"Giới thiệuĐây KHÔNG phải là một bài viết để học “mọi thứ” về css grid.Bài viết này hướng đến những người muốn có kết quả nhanh chóng và hiệu quả.Trong bốn phần của bài viết này, tôi sẽ chỉ cho bạn 20% cần thiết để làm được 80% những gì bạn có thể làm với CSS Grid layout. Hãy cùng tìm hiểu!","text":"Giới thiệuĐây KHÔNG phải là một bài viết để học “mọi thứ” về css grid.Bài viết này hướng đến những người muốn có kết quả nhanh chóng và hiệu quả.Trong bốn phần của bài viết này, tôi sẽ chỉ cho bạn 20% cần thiết để làm được 80% những gì bạn có thể làm với CSS Grid layout. Hãy cùng tìm hiểu! Tại sao chỉ 20%? Bất cứ khi nào, một lập trình viên tìm kiếm sự hiệu quả - sự lười biếng sẽ giúp anh ta. CSS Grid layout rất phức tạp. Theo ý kiến của tôi, nó phức tạp hơn Flexbox. (tôi đã mất vài tuần để tìm hiểu flexbox) Không hẳn bởi vì nó “khó” mà do CSS Grid có tới 18 thuộc tính mới cộng với những khái niệm mà bạn chưa bao giờ nghe tới trước đó. Vậy, bạn cần biết tất cả những thuộc tính mới này ngay bây giờ? Ngay lập tức? Không, bạn không cần! Bạn chỉ cần học một vài thuộc tính cần thiết ngay lúc này để tạo ra kết quả mong muốn. Những thuộc tính khác có thể học sau. Đó là định nghĩa về “hiệu quả” của tôi. 1. CSS Grid layout là gì ?Nếu bạn mới học bố cục trong CSS, CSS Grid có thể khá xa lạ với bạn. Bạn đã nghe nói tới Flexbox chưa? Tôi thích coi CSS Grid như là một người anh (hoặc cha) của Flexbox. Xử lý các bố cục trong CSS được coi là một công việc khó khăn và không hấp dẫn. Flexbox đã làm cho mọi thứ dễ dàng hơn - nhưng CSS Grid thậm chí còn tốt hơn. Cái chúng ta sẽ xây dựng.Chúng ta sẽ học cách áp dụng 20% kiến thức học được để xây dựng bố cục responsive của một ứng dụng âm nhạc Phần 1: 10% bạn cần biết - Các thuật ngữ cơ bảnChúng ta hãy nhìn vào những điều đầu tiên bạn bắt buộc phải biết. Grid Container là gì?Mỗi bố cục các trang web hoặc ứng dụng bạn tạo ra (hoặc thấy) về bản chất là những chiếc hộp được đặt trong những đường ranh giới xác định. Hiểu đơn giản, grid chỉ là “những đường kẻ”. Những đường kẻ ngang và dọc xác định vị trí của các phần tử được thiết kế khác nhau. Bạn sẽ quen với grid nếu bạn đã sử dụng các phần mềm thiết kế như photoshop hoặc sketch. Trong bối cảnh của CSS Grid layout, một Grid container là phần tử cha chứa tất cả các phần tử nằm trong grid. Grid container xác định vị trí ban đầu của các đường kẻ trong grid, cả dọc và ngang. Grid Line là gì?Giả sử bạn có một bố cục như thế này: Bố cục bao gồm một grid container với các phần tử ở bên trong Grid lines chính là những đường kẻ ngang và dọc phân chia grid thành các ô. Grid Cell là gì?Grid cell là đơn vị nhỏ nhất trong grid layout. Bất kỳ khoảng trống nào được xác định bởi 4 đường grid line. Grid AreaMột grid area có thể giống như một grid cell (giống như ở phần trước). Hoặc cũng có thể trải rộng trên nhiểu hoặc tất cả grid cell trong grid. Trong hình vẽ dưới đây, grid area trải rộng trên 4 ô. Grid Track là gì?Một grid track có thể xem như một tên gọi khác cho các cột và các dòng. Nó là khoảng trống giữa 2 grid line bất kỳ. Hình dưới đây là ví dụ về grid tracks Vì vậy, chúng tôi đã phân loại được tất cả trong phần đầu tiên. Phần 2: 10% còn lại mà bạn cần biết về CSS grid.Bây giờ bạn đã hiểu các thuật ngữ cơ bản, giống như một đứa trẻ mạo hiểm, hãy bắt đầu! Làm thế nào để định nghĩa một Grid?Giống như Flexbox, mọi thứ bắt đầu với display: grid hoặc display: inline-grid cho phiên bản inline. Ví dụ, để biến một div thành một grid container: 123div &#123; display: grid;&#125; Làm thế nào để tạo các cột và dòng?Để tạo các cột và các dòng trong một grid container, chúng ta sẽ sử dụng 2 thuộc tính mới: grid-template-columns và grid-template-rows. Vậy sử dụng chúng như thế nào? Khá đơn giản. grid-template-columns định nghĩa vị trí của các cột. grid-template-rows định nghĩa vị trí của các dòng. Bạn truyền giá trị vào các thuộc tính này, và chúng tạo ra các dòng và các cột. Xem ví dụ: 1grid-template-columns: 100px 200px 300px Đoạn code này sẽ tạo thành 3 cột mới trong grid container. Cột đầu tiên có độ rộng 100px, cột tiếp theo 200px và cột cuối 300px. 1grid-template-rows: 100px 200px 300px Đoạn code này sẽ tạo 3 dòng mới trong grid container như hình dưới đây: Bây giờ đặt chúng cùng nhau, bạn sẽ có một grid hoàn chỉnh với các dòng và cột đã được định nghĩa. 12grid-template-columns: 100px 200px 300pxgrid-template-rows: 100px 200px 300px Phần 3: Bắt tay vào Code - CSS GridBây giờ chúng ta hãy thực hiện các bước để xây dựng bản sao của ứng dụng âm nhạc nổi tiếng, nhạc catty Để phát triển nhanh chóng, tôi sẽ sử dụng Codepen. Tạo một dự án mới và hãy bắt đầu. Làm thế nào để tạo ra bộ khung cho ứng dụng Catty MusicSau khi đã tạo một project trên codepen. Chúng ta sẽ tạo một tài liệu html cơ bản: 12345&lt;body&gt; &lt;aside&gt;&lt;/aside&gt; &lt;main&gt;&lt;/main&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt; Có mục đích khi chọn cấu trúc này. Bạn sẽ sớm nhận ra điều đó. Bây giờ style tài liệu. 1234body &#123; display: grid; min-height: 100%&#125; Đoạn code này sẽ biến body thành một grid-container. Bây giờ chúng ta cần tạo cấu trúc các dòng và cột trong grid. Làm thế nào để tạo ra các dòng và các cột cho ứng dụng Catty MusicTạo các dòng và cột là khá dễ dàng. Kết quả cuối cùng chúng cần đạt được là: Tuy nhiên, ban đầu khi thiết lập grid chúng ta cần 2 dòng và 2 cột. Đây là một vài thứ cần chú ý về thiết lập GridColumns: Cột đầu tiên phải có độ rộng cố định là 50px. Cột thứ 2 phải chiếm toàn bộ độ rộng còn lại của dòng. Rows: Dòng thứ 2 phải có chiều cao cố định là 100px. Dòng đầu tiên phải chiếm toàn bộ chiều còn lại của grid. Giải pháp của một người ít kinh nghiệm.Nếu bạn KHÔNG có kinh nghiệm với CSS, bạn có thể viết như thế này: 12345body &#123; ... grid-template-rows: 100% 100px; grid-template-columns: 50px 100%;&#125; Vấn đề với giải pháp này là bạn đã vô tình tạo ra một grid với chiều rộng là 100% + 50px và chiều cao là 100% + 100px. Cái chúng ta muốn là chiều rộng và chiều cao là 100%. Vì thế hướng tiếp cần này là sai. Giải pháp của người đã có kinh nghiệmNếu đã có một vài kinh nghiệm với CSS, bạn có thể làm một vài thứ thông minh hơn như thế này: 12345body &#123; ... grid-template-rows: calc(100% - 100px) 100px; grid-template-columns: 50px calc(100%-50px)&#125; Cách này khá thông minh. Nhưng có một vấn đề - nó rất khó để bảo dưỡng. Ví dụ, nếu vì một lý do nào đó bạn phải thay đổi độ rộng cố định, bạn cũng phải thay đổi định nghĩa calc. Giải pháp hiệu quả nhấtMay mắn là CSS Grid có một đơn vị mới giúp chúng ta giải quyết vấn đề ở trên một cách dễ dàng đó là đơn vị. factional(fr) Đơn vị fractional giải quyết vấn đề tự động phân bố khoảng trống. Nếu bạn có grid với 3 cột như ở dưới, đơn vị fractional sẽ tự động phân bổ các khoảng trống bằng nhau. INếu vì một vài lý do bạn thêm nhiều phần tử hơn - đừng lo lắng. Đơn vị fr sẽ phân bổ lại các khoảng trống bằng nhau. Cuối cùng, nếu bạn đã có một phần tử với độ rộng cố định, bạn có thể lấy toàn bộ khoảng trống còn lại với đơn vị fr. Như thế này: 12345body &#123; ... grid-template-rows: 1fr 100px; grid-template-columns: 50px 1fr;&#125; And that is it — done! Đặt tên và xác định vị trí bởi Grid AreasChúng ta đã tạo ra hệ thống grid. Bây giờ là lúc để sử dụng nó. Mục đích của phần này học cách xác định vị trí các phần tử trong grid sử dụng grid areas. Nhắc lại một chút, một grid area là bất kỳ khoảng trống được bao bởi 4 grid line. Làm thế nào để sử dụng grid areas?Nơi hợp lý để bắt đầu là đặt tên grid areasHãy để tôi giải thích.Xem xét khối lệnh dưới đây: 123&lt;div class=\"aside\"&gt;&lt;/div&gt;&lt;div class=\"main\"&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; 3 divs - đơn giản. Bằng cách này, Nó là ngữ nghĩa tốt hơn để sử dụng tags aside main và footer. Tôi sẽ giữ mọi thứ đơn giản. Bây giờ hãy xem đoạn code này: 123456789.main &#123; grid-area: content;&#125;.footer &#123; grid-area: footer;&#125;.aside &#123; grid-area: sidebar;&#125; Chuyện gì đang xảy ra ở đâyNếu biết một chút về Javascript, hay bất kỳ ngôn ngữ lập trình nào khác, thì khái niệm về biến sẽ không phải là mới với bạn. Trong Javascript, chúng ta có thể nói: 1var gridArea = \"content\" Cái chúng ta làm ở phía trên là, lưu chuỗi content vào biến gridArea Khai báo CSS ở phần trước tương tự như vậy. Mọi phần tử trong grid có thể được gán tới một vùng trong grid container. Tuy nhiên, trước khi làm điều đó, chúng ta bắt buộc phải gán mỗi phần tử trong grid với một tên gọi. Giống như các biến trong Javascript. 123456789.main &#123; grid-area: content;&#125;.footer &#123; grid-area: footer;&#125;.aside &#123; grid-area: sidebar;&#125; Đoạn code ở trên nói rằng, class .main có tên là content. Class .footer có tên là footer. Cuối cùng, class .aside có tên là sidebar Bây giờ các grid items được gán tên cho mỗi vùng. Trong lập trình, các biến được thiết lập để được sử dụng ở nơi khác. Bây giờ, hãy sử dụng tên grid area. Vị trí Grid areaMột người đàn ông trẻ có một cái bánh nướng. Anh ta có 3 đứa con và phải chia cho mỗi đứa một phần. Ai là người chia bánh thì hợp lý nhất? Chính người đàn ông đó! Người đàn ông trẻ cắt bánh và chia cho mỗi đứa trẻ một phần. Đây là lý do tôi kể câu chuyện này. Giống như chiếc bánh, toàn bộ khoảng trống trong grid là của ai? Chính là grid container! Giống như người đàn ông trẻ, grid container có 3 đứa con .aside .main và .footer. Bây giờ grid container phải chọn cách chia toàn bộ khoảng trống trong grid cho 3 đứa con này. Và một điều nữa. Vì tất cả những đứa trẻ đều có tên, người đàn ông trẻ có thể nói: “hey Brian đây là phần của con hoặc hey Emma của con là phần này.” Dễ dàng để xác định ai sở hữu phần nào của chiếc bánh, bằng cách gán mỗi phần với tên của mỗi người. Mỗi phần tử trong grid đều đã có tên bằng cách sử dụng thuộc tính grid-area. Bây giờ, hãy chia bánh! Thuộc tính grid-template-areasBây giờ grid container phải chia “bánh”. Gán mỗi vùng tới mỗi phần tử tương ứng. Có nhiều cách để làm điều đó, nhưng thuộc tính grid-template-areas là cách dễ dàng nhất để làm đó. nó chính là cái bạn cần biết để làm việc hiệu quả. Thuộc tính grid-template-areas làm việc như thế nào?Hãy xem đoạn code dưới đây: 1234body &#123; grid-template-areas: \"sidebar content\" \"footer footer\"; &#125; Cái quái gì vậy? Không cần phải bị choáng ngợp. Trong phần này, tôi sẽ giải thích nó hoạt động như thế nào - theo thuật ngữ rõ ràng. Thuộc tính grid-template-areas cung cấp một cấu trúc rất trực quan của grid. Hãy xem lại đoạn code trên một lần nữa: 1234body &#123; grid-template-areas: \"sidebar content\" \"footer footer\"; &#125; Bạn có thể thấy toàn bộ giá trị của thuộc tính là tên của các phần tử trong grid! sidebar content và footer là tên của các phần tử trong grid. Khai báo ở trên gán mỗi vùng trong grid với một phần tử tương ứng. Hình ảnh trên sẽ giúp bạn hiểu grid được chia như thế nào. footer sẽ chiếm toàn bộ dòng bên dưới. sidebar và content sẽ chiếm cột đầu tiên và thứ 2 của dòng bên bên. Đến đây chúng ta có: 1234567body &#123; display: grid; grid-template-columns: 40px 1fr; grid-template-rows: 1fr 90px; grid-template-areas: \"sidebar content\" \"footer footer\"; &#125; Kết quả sẽ như dưới đây: Tôi đã thêm màu sắc để hỗ trợ hình ảnh. Phần màu đỏ đại diện cho .footer, hai phần còn lại, phần .main và .sidebar. Làm cho bố cục responsive - Định nghĩa lại Grid areas với Media Queries Các Grid area mà bạn đã tạo trong grid container có thể thay đổi tùy theo kích thước màn hình của người sử dụng. Dưới đây là hình ảnh ứng dụng trên màn hình điện thoại. Chúng ta sẽ refactor lại code theo hướng tiếp cận mobile first. Mobile first đơn giản là làm cho style mặc định của bạn là dành cho các thiết di động. Sau đó bạn sẽ tạo ra các thay đổi cho các màn hình lớn hơn thông qua các media query. Đặt một phần code hiện nay trong một định nghĩa media query. Như dưới đây: 1234567@media only screen and (min-width: 600px) &#123; body &#123; grid-template-columns: 50px 1fr; grid-template-areas: \"sidebar content\" \"footer footer\"; &#125;&#125; Bạn sẽ để đoạn code mặc định bên ngoài media query 1234body &#123; display: grid; grid-template-rows: 1fr 100px;&#125; Tại sao chúng ta đặt grid-template-rows: 1fr 100px; bên ngoài media query? Bởi vì cả màn hình di động và desktop chúng ta đều có 2 dòng. Tuy nhiên, trên màn hình desktop. Sidebar là 50px trong định nghĩa grid-template-columns. Còn trên các thiết bị di động sidebar không tồn tại. Vì thế, chúng ta sẽ định nghĩa lại khai báo grid-template-columns cho di động. Bây giờ với các thiết bị di động chúng ta sẽ sử dụng style này là mặc định: 123body &#123; grid-template-areas: \"content\" \"footer\" Khá đơn giản phải không? Hãy để tôi giải thích. Dòng chảy (hướng) của GridĐoạn code cho di động như thế này: 123body &#123; grid-template-areas: \"content\" \"footer\" Bởi mặc định, một grid sẽ sắp xếp các phần tử trên các dòng. Vì thế khai báo ở phía trên sẽ sắp xếp content trên một dòng và footer trên một dòng khác. Dưới đây là kết quả - sidebar sẽ ẩn trên màn hình di động: Với rào cản ban đầu của sự hiểu biết cách hoạt động của grids và thiết lập responsive grid, chúng ta đã xong bố cục ứng dụng! Thêm nội dung vào trong GridKhi kết thúc phần này chúng ta sẽ có một bố cục ứng dụng âm nhạc hoàn chỉnh. Bây giờ hãy tập trung và việc sắp xếp nội dung trong grid. 1. The SidebarĐiều này có vẻ dễ nhất để bắt đầu. Hãy đi tìm nó. Sidebar bao gồm 8 icon cách đều nhau dọc theo toàn bộ chiều dài của sidebar. Hãy chèn các icon vào sidebar: 12345678910&lt;div class=\"aside\"&gt; &lt;i class=\"fa fa-bars\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-home\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-search\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-volume-up\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-spotify\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-cog\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-soundcloud\"&gt;&lt;/i&gt;&lt;/div&gt; Kết quả sẽ như thế này: Các icon cũng sẽ ẩn trên màn hình di động. Và chỉ hiển thị trên các màn hình lớn hơn. Đây là hướng tiếp cận mobile first. 1234567.aside i &#123; display: none;&#125;@media only screen and (min-width:600px) &#123; .aside i &#123; display: block; &#125; Các biểu tượng được hiển thị, nhưng được căn chỉnh chưa đều. Sắp xếp các iconCác thẻ i là các phần tử inline – điều đó giải thích tại sao 2 icon lại hiển thị cạnh nhau trên một dòng. Hãy sắp xếp chúng. Các phần tử con của grid container cũng có thể trở thành các grid container. Tại sao không? Bước 1: Biến Sidebar thành một Grid ContainerĐiều này sẽ cung các tính năng căn chỉnh của grid. Khi sidebar chỉ hiển thị trên các màn hình lớn hơn, đừng quên đặt nó trong media query. 123456789@media only screen and (min-width:600px) &#123; .aside &#123; display: grid; &#125; .aside i &#123; border: 1px solid red; &#125;&#125; Tôi thêm border cho mỗi icon - để chúng ta dễ phân biệt. Chuyện gì đang xảy ra ở đây? Chúng ta KHÔNG thiết lập bất kỳ dòng hay cột trong sidebar. Nhưng chúng ta thấy các icon được sắp xếp khá tốt. Grid tự động thiết lập điều đó. Đây là vị trí mặc định của các item trong một grid – trên cùng một dòng. Một grid cũng có thể sắp xếp các phần tử sử dụng justify-items hay align-items. justify-items sẽ sắp xếp các phần tử theo chiều ngang. align-items sẽ sắp xếp các phần tử theo chiều dọc. Áp dụng điều này cho sidebar, và chúng ta có một bổ cục các icon hoàn hảo: 12345.aside &#123; ... justify-items: center; align-items: center; &#125; Bạn vẫn cảm thấy khó hiểu, hãy xem video dưới đây: Bây giờ chúng ta đã một bố cục hoàn hảo dành cho các icon trong sidebar. justify-items hay align-items có thể có các giá trị: stretch start end center Nếu đã từng làm việc với Flexbox, bạn sẽ quen với chúng. Chúng ta sẽ thêm nhiều nội dung hơn vào thiết kế hiện tại. Thêm 2 thẻ div vào main section: 1234&lt;div class=\"main\"&gt; &lt;div class=\"main__header\"&gt;&lt;/div&gt; &lt;div class=\"main__body\"&gt;&lt;/div&gt;&lt;/div&gt; NB: main__header sẽ chứa music art và playbacks: main__bodysẽ chứa chi tiết: Trong phần này chúng ta sẽ tập trung vào main__header Đầu tiên, thêm đoạn code html này: 1234567891011121314151617&lt;div class=\"main__header\"&gt; &lt;div class=\"img\"&gt; &lt;img src=\"http://bit.ly/2sc2NJd\"/&gt; &lt;/div&gt; &lt;section class=\"details\"&gt; &lt;div&gt; &lt;p&gt;CattyBoard Top 100 Single Charts (11.06.36)&lt;/p&gt; &lt;p class=\"sm--hide\"&gt;Unknown Artist&lt;/p&gt; &lt;p class=\"sm--hide\"&gt;2016 . Charts . 100 songs&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;i class=\"fa fa-play\"&gt; &amp;nbsp;Play all&lt;/i&gt; &lt;i class=\"fa fa-plus\"&gt; &amp;nbsp;Add to&lt;/i&gt; &lt;i class=\"fa fa-ellipsis-h\"&gt;&amp;nbsp;&amp;nbsp;More&lt;/i&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt; Chú ý cấu trúc của tài liệu main__header có hai con trực tiếp. Một div chứa một hình ảnh và section chứa thông tin chi tiết của album. Kết quả của đoạn code trên khá xấu xí: Hãy làm cho nó đẹp hơn. Cái chúng ta cần là một grid với các phần tử được sắp xếp phù hợp. Hãy sử dụng những kiến thức về grid areas Đầu tiên, định nghĩa grid area: 123456.main__header &gt; .img &#123; grid-area: img;&#125;.main__header &gt; .details &#123; grid-area: dtls;&#125; div chứa hình ảnh được đặt tên là img. Phần chứa thông tin chi tiết của album được đặt tên là dtls. Bây giờ, định nghĩa grid: 12345.main__header &#123; display: grid; grid-template-areas: \"img\" \"dtls\"; &#125; .main__header trở thành một grid container, có 2 phần tử xếp chồng lên nhau đầu tiên là img tiếp theo là dtls. Bởi vì chúng ta đang theo hướng tiếp cận mobile first. Tại thời điểm này, không có nhiều thay đổi. Đây không phải là cái chúng ta muốn trên di động. Với màn hình di động, các phần tử nên được căn giữa. 12345@media screen and (max-width: 600px) &#123; .main__header &#123; justify-items: center; &#125; &#125; Kết quả sẽ như dưới đây: Tiếp theo hãy làm cho text trong .details căn giữa: 12345@media screen and (max-width: 600px) &#123; .main__header &gt; .details &#123; text-align: center; &#125; &#125; Đã khá gần với mục tiêu chỉ cần thêm một vài điều chỉnh. Đoạn text Unknown Artist và 2016 . Charts . 100 songs nên ẩn trên di động. Ảnh cũng nên nhỏ hơn. 12345678@media screen and (max-width: 600px) &#123; .sm--hide &#123; display: none; &#125; .img &gt; img &#123; width: 150px &#125;&#125; Class .sm--hide sẽ ẩn trên di động. Chỉ cần thêm class tới phần tử mong muốn. Như thế này: 12&lt;p class=\"sm--hide\"&gt;Unknown Artist&lt;/p&gt;&lt;p class=\"sm--hide\"&gt;2016 . Charts . 100 songs&lt;/p&gt; Và chúng ta có: Màn hình di động đã xong. Giờ hãy thêm style cho những màn hình lớn hơn. Với màn hình lớn hơn, chúng ta cần một grid 2 cột. Style sẽ như thế này: 123456@media only screen and (min-width:600px) &#123; .main__header &#123; grid-template-columns: 250px 1fr; grid-template-areas: \"img dtls\" &#125; &#125; Grid đã được định nghĩa lại với 2 cột. Một có độ rộng cố định là 250px và cột kia chiếm toàn bộ khoảng trống còn lại. Tiến trình hiện tại của chúng ta here. Phần 4: Kết hợp CSS Grid với FlexboxTrong phần này bạn sẽ học cách sử dụng Flexbox và Grid cùng nhau. Hai module này đã thay đổi cách xử lý bố cục trong CSS. Và cách hiệu quả nhất là sử dụng cả 2 module cùng nhau. Hãy đi vào chi tiết. Với phần hiển thị thông tin chi tiết của album chúng ta sẽ sử dụng flexbox. Làm sao để biết chỗ nào sẽ sử dụng Flexbox?Quy tắc chung là sử dụng Grid cho bố cục toàn bộ trang, còn Flexbox dành cho UI bên trong các phần tử con. Một phần tử con có thể là một flex container. Một phần tử con của flex container cũng có thể là một grid container. Tôi giả sử rằng bạn đã biết về flexbox. Như thường lệ, hãy bắt đầu bằng html Dưới đây là một div, với một danh sách các bài hát. Danh sách các bài hát có các đoạn có chứa tên bài hát, nghệ sĩ, thời lượng của bài hát và “catty cloud sync”. 1234567891011121314151617181920212223242526&lt;div class=\"main__body\"&gt; &lt;div&gt; &lt;p&gt;1. One Dance&lt;/p&gt; &lt;p&gt;Crake feat CatKid &amp;amp; Cyla&lt;/p&gt; &lt;p&gt;2:54&lt;/p&gt; &lt;p&gt;&lt;span&gt;CATTY CLOUD SYNC&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;2. Panda&lt;/p&gt; &lt;p&gt;Cattee&lt;/p&gt; &lt;p&gt;4:06&lt;/p&gt; &lt;p&gt;&lt;span&gt;CATTY CLOUD SYNC&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;3. Can't Stop the Feeling!&lt;/p&gt; &lt;p&gt;Catin Cimberlake&lt;/p&gt; &lt;p&gt;3:56&lt;/p&gt; &lt;p&gt;&lt;span&gt;CATTY CLOUD SYNC&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;4. Work From Home&lt;/p&gt; &lt;p&gt;Cat Harmony feat Colla&lt;/p&gt; &lt;p&gt;3:34&lt;/p&gt; &lt;p&gt;&lt;span&gt;CATTY CLOUD SYNC&lt;/span&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; Đây là cái chúng ta có: main__body là một phần tử của grid. Chúng ta có thể biến nó thành flex container nếu điều đó hữu ích. Trong trường hợp của chúng ta, mỗi thẻ div là con trực tiếp của main__body cần trở thành một flex container. Chúng chứa tên bài hát, nghệ sĩ, thời gian và “catty cloud sync”. 123.main__body &gt; div &#123; display:flex;&#125; Bây giờ chia chiều rộng cho các phần tử con: 123.main__body &gt; div p &#123; flex: 0 0 25%;&#125; Bạn sẽ đồng ý với tôi rằng tại thời điểm này, các yếu tố cần thiết cho bố cục đã hoàn thành. Tuy nhiên, tôi đã thực hiện một vài thay đổi. Bạn có thể xem kết quả cuối cùng here Bạn sẽ nhận thấy rằng tôi vẫn để trống footer. Đó là bài tập cho bạn. Lời khuyên của tôi là sử dụng flexbox. Nó sẽ giúp bạn hiểu cách cả hai module này làm việc cùng nhau. Với một vài thuộc tính của grid, bạn đã xây dựng một bố cục thực sự. Khá ấn tượng. Bạn cũng học được kỹ năng vô giá khi kết hợp CSS Grid với Flexbox.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"grid","slug":"grid","permalink":"http://nthung2112.github.io/tags/grid/"}]},{"title":"Tìm hiểu về Proxy trong ES6","slug":"Tim-hieu-ve-Proxy-trong-ES6","date":"2018-07-08T08:57:00.000Z","updated":"2018-07-08T08:59:57.977Z","comments":true,"path":"2018/07/Tim-hieu-ve-Proxy-trong-ES6.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Tim-hieu-ve-Proxy-trong-ES6.html","excerpt":"Nói về ES6 có lẽ chúng ta đã quá quen thuộc với các khái niệm như const và let, hàm mũi tên, class hay những tính năng hay ho hấp dẫn khác. Ngoài ra, ES6 cũng kèm theo những tính năng ít người biết hơn nhưng cũng rất thú vị, và một trong số đó là Proxy.","text":"Nói về ES6 có lẽ chúng ta đã quá quen thuộc với các khái niệm như const và let, hàm mũi tên, class hay những tính năng hay ho hấp dẫn khác. Ngoài ra, ES6 cũng kèm theo những tính năng ít người biết hơn nhưng cũng rất thú vị, và một trong số đó là Proxy. Proxy là gì?Proxy là một class được giới thiệu từ ES6, cho phép bạn can thiệp và thay đổi hành vi của một đối tượng (object). Các hành vi này bao gồm: truy xuất/thiết lập thuộc tính của một đối tượng, thay đổi prototype, gọi hàm, khởi tạo đối tượng bằng từ khóa new… Để hiểu rõ hơn về khái niệm, bạn có thể xem qua ví dụ sau: 123456789101112131415161718const u = &#123; name: 'Công Tằng Tôn Nữ Tạ Thị Tòn Ten' &#125;// Thiết lập proxy cho đối tượng `u`const p = new Proxy(u, &#123; // `get` là một trap, sẽ được gọi khi truy xuất đến thuộc tính // của đối tượng get(target, prop, receiver) &#123; // Thay đổi hành vi khi truy xuất đến một thuộc tính: Nếu là // chuỗi, chuyển sang chữ hoa if (typeof target[prop] === 'string') return target[prop].toUpperCase() return target[prop] &#125;&#125;)console.log(p.name) // CÔNG TẰNG TÔN NỮ TẠ THỊ TÒN TENp.email = 'ta.thi@ton.ten'console.log(p.email) // TA.THI@TON.TEN Chúng ta có thể áp dụng Proxy cho bất cứ object nào trong JavaScript, kể cả mảng, hàm hay một proxy khác. Có thể bạn thừa biếtMột hàm trong JavaScript là một thể hiện của lớp Function. Hiện tại Proxy đã được hỗ trợ bởi các trình duyệt xịn (nghĩa là không có IE đó) và node.js v6 trở đi. Tin vắnPhiên bản 5.0 của MobX đã hoàn toàn sử dụng ES6 Proxy. Sử dụng như thế nào?Trước hết, hãy xem qua những thuật ngữ thông dụng khi làm việc với Proxy: target: là đối tượng sẽ được áp dụng proxy vào traps: là những phương thức giúp bạn thay đổi hành vi của đối tượng handler: là một object chứa các traps, được đưa vào hàm dựng của lớp Proxy Để khởi tạo proxy, bạn dùng new Proxy(target, handler) như bên dưới: 1const p = new Proxy(target, handler) Chúng ta sẽ cùng đi qua những traps thông dụng. handler.get() và handler.set()Như tên gọi, handler.get() và handler.set() cho phép bạn can thiệp khi truy xuất và thiết lập giá trị một thuộc tính của đối tượng. 12345678// property: tên của thuộc tính được truy xuất// receiver: đối tượng sau khi đã được gắn proxyhandler.get(target, property, receiver)// value: giá trị sẽ được thiết lập cho thuộc tính// handler.set() phải trả về một giá trị boolean. Nếu là true thì xem như thiết lập// thành công, ngược lại nếu là false thì xảy ra lỗi TypeError.handler.set(target, property, value, receiver) Chúng ta có thể dùng handler.set() để kiểm tra tính đúng đắn dữ liệu (data validation) trên thuộc tính của đối tượng. Chẳng hạn như: 123456789101112const u = &#123; age: null &#125;const p = new Proxy(u, &#123; set(target, prop, val) &#123; if (prop === 'age' &amp;&amp; typeof val !== 'number') throw new TypeError('Age must be a number') target[prop] = val return true &#125;&#125;)p.age = '10' // Error: Age must be a numberp.age = 10 // OK! handler.defineProperty() và handler.deleteProperty()handle.defineProperty(target, property, descriptor) là trap được kích hoạt khi sử dụng Object.defineProperty(). Phương thức này đòi hỏi phải trả về một giá trị boolean. Ví dụ: 123456789101112const p = new Proxy(&#123; foo: 1, bar: true &#125;, &#123; defineProperty(target, property, descriptor) &#123; if (property.startsWith('_')) throw new Error('Properties starting with _ are not allowed') return Object.defineProperty(...arguments) &#125;&#125;)p._hello = 1 // ErrorObject.defineProperty(p, '_hello', &#123; value: 1 &#125;) // Errorp.hello = 1Object.defineProperty(p, 'hello', &#123; value: 1 &#125;) descriptor là một object quy định hành vi của thuộc tính được khai báo. Chi tiết về descriptor bạn có thể xem ở trang MDN hoặc hóng bài viết tiếp theo của Ehkoo. handle.deleteProperty(target, property) sẽ được kích hoạt khi thực hiện delete một thuộc tính. Phương thức này phải trả về true nếu quá trình xóa được chấp nhận. Ví dụ: 12345678910const p = new Proxy(&#123; foo: 1, bar: true &#125;, &#123; deleteProperty(target, property) &#123; delete target[property] console.log(`$&#123;property&#125; was removed`) return true &#125;&#125;)delete p.foo // foo was removeddelete p.bar // bar was removed handler.has()handler.has() sẽ được kích hoạt khi sử dụng in. Phương thức này cũng đòi hỏi phải trả về một giá trị boolean. Ví dụ: 123456789const p = new Proxy(&#123; _foo: 1, bar: true &#125;, &#123; has(target, property) &#123; if (property.startsWith('_')) return false return property in target &#125;&#125;)console.log('bar' in p) // trueconsole.log('_foo' in p) // true handler.apply()handler.apply(target, thisArg, args) là trap dành cho các hàm, sẽ được khởi động khi hàm được gọi. Ví dụ: 123456789const sum = (a, b) =&gt; a + bconst f = new Proxy(sum, &#123; apply(target, thisArg, args) &#123; const [a, b] = args return target.call(thisArg, a * 2, b * 2) &#125;&#125;)f(1, 2) // 6 handler.construct()handler.construct(target, args) là trap sẽ được gọi khi khởi tạo đối tượng bằng new. Ví dụ: 123456789101112131415class User &#123; constructor(username) &#123; this.username = username &#125;&#125;const PUser = new Proxy(User, &#123; construct(target, args) &#123; const [username] = args return new target(username.toUpperCase()) &#125;&#125;)const u = new PUser('pikalong')console.log(u.username) // PIKALONG handler.getPrototypeOf() và handler.setPrototypeOf()Như tên gọi, hai traps này sẽ được kích hoạt khi sử dụng Object.getPrototypeOf() và Object.setPrototypeOf() trên đối tượng. Ghi chúBên cạnh những traps được giới thiệu ở đây, còn có một số traps khác mà bạn có thể tham khảo ở trang MDN. Viết thử nàoBạn có dùng thử chai chưa? Thư viện này hỗ trợ viết kiểm chứng (assertion) theo phong cách BDD/TDD, giống như thế này: 123456789// chai.expectexpect(foo).to.be.a('string')expect(foo).to.equal('bar')expect(foo).to.have.lengthOf(3)// hoặc chai.shouldfoo.should.be.a('string')foo.should.equal('bar')foo.should.have.lengthOf(3) Cách thiết kế này rõ ràng giúp cho chương trình trở nên mạch lạc và dễ theo dõi vì câu kiểm chứng được viết như một câu tiếng Anh vậy. Chúng ta có thể bắt chước chai và thử viết một lớp Thing có những khả năng sau: 123456789101112131415// Khởi tạo một đối tượng của lớp Thing với tên là \"Phương\"const t = new Thing('Phương')t.name // 'Phương'// Khai báo các thuộc tính booleant.is_a.singert.is_not_a.man// Kiểm tra thuộc tínht.is_a_singer // truet.is_a_man // false// Khai báo phương thứct.can.sing('Yêu hay không yêu không yêu hay yêu nói một lời')t.sing() // Phương sings: Yêu hay không yêu không yêu hay yêu nói một lời Đây là một phần trong bài The builder of things được lấy từ Codewars. Sau khi đọc hết bài viết này thì bạn hãy thử giải thử thách trên xem sao, bảo đảm kết quả không làm bạn thất vọng đâu.Ngoài ra nếu bạn có tham gia Codewars thì đừng quên gia nhập clan Ehkoo nhé ;) Đầu tiên, để truy xuất thuộc tính name, chúng ta có thể nghĩ đến giải pháp “vô cùng rõ ràng và ngây thơ” sau: 12345class Thing &#123; constructor(name) &#123; this.name = name &#125;&#125; Đoạn code trên hoàn toàn hợp lý, nhưng sẽ không giúp chúng ta giải quyết những yêu cầu tiếp theo của bài toán. Phân tích kỹ một chút ta có thể thấy việc dùng Proxy là không thể tránh khỏi. Do đó để cài đặt t.name bằng Proxy, ta có thể viết lại thành: 123456789101112131415161718192021222324class Thing &#123; constructor(name) &#123; this.state = &#123; name &#125; return proxify(this, this.state) &#125;&#125;// Hàm proxify() nhận vào một target và một object chứa state.// State này sẽ được sử dụng để giải quyết những yêu cầu tiếp theo.function proxify(target, state) &#123; return new Proxy(target, &#123; get(target, prop, receiver) &#123; // Nếu truy xuất đến thuộc tính `name`, lấy ra dữ liệu trong state if (prop === 'name') return state[prop] // Còn lại thì sử dụng hành vi mặc định return target[prop] &#125; &#125;)&#125;const t = new Thing('Phương')console.log(t.name) // Phươngconsole.log(t.age) // undefined Vậy là tạm ổn phần lấy name. Chúng ta xem tiếp đến hành vi tiếp theo của lớp Thing. 12345t.is_a.singert.is_not_a.mant.is_a_singer // truet.is_a_man // false Hành vi này cho phép khai báo thuộc tính boolean trên đối tượng bằng cách sử dụng is_a cho giá trị true và is_not_a cho giá trị false. Sau đó ta có thể kiểm tra thuộc tính bằng cách truy xuất đến is_a_${prop}. Để cài đặt hành vi này, chúng ta có thể làm như sau: Khai báo thêm một khóa booleans: {} cho state. Khóa này đóng vai trò như một bảng tham chiếu giữa tên thuộc tính boolean và giá trị của nó, chẳng hạn như { singer: true, man: false }. Ngoài ra chúng ta cũng cần thêm vào state một cờ inBooleanMode: false. Nếu prop là is_a hoặc is_not_a, bật cờ inBooleanMode: true Nếu cờ inBooleanMode đang bật, thuộc tính tiếp theo sẽ là thuộc tính boolean. Do đó ta cập nhật booleans của state thành { …booleans, [prop]: state.booleanValue } 12345678910111213141516171819202122232425262728function enterBooleanMode(receiver, state, booleanValue) &#123; // Bật cờ state.inBooleanMode = true // Lưu lại giá trị boolean tùy thuộc vào là `is_a` hay `is_not_a` state.booleanValue = booleanValue return receiver&#125;function setBoolean(receiver, state, prop) &#123; state.booleans = &#123;...state.booleans, [prop]: state.booleanValue &#125; // Reset lại các giá trị state.inBooleanMode = false state.booleanValue = null return receiver&#125;get(target, prop, receiver) &#123; // Đặt ở đây để tránh trường hợp gọi t.is_a.is_a if (state.inBooleanMode) return setBoolean(this, state, prop) if (prop === 'name') return state[prop] if (prop === 'is_a') return enterBooleanMode(receiver, state, true) if (prop === 'is_not_a') return enterBooleanMode(receiver, state, false) if (prop.startsWith('is_a_')) return state.booleans[prop.replace('is_a_', '')] return target[prop]&#125; Kiểm tra thử. 123456const t = new Thing('Phương')t.is_a.singert.is_not_a.manconsole.log(t.is_a_singer) // trueconsole.log(t.is_a_man) // false Để cài đặt hành vi tiếp theo, chúng ta cũng có thể làm tương tự như khai báo thuộc tính boolean bằng cách đặt thêm một cờ inDefineMethodMode và bật/tắt cờ này tương ứng. Bên cạnh đó chúng ta cũng đặt thêm một khóa methods trong state để chứa các phương thức được khai báo thông qua can. 123456789get(target, prop, receiver) &#123; // ... if (state.inDefineMethodMode) return setMethod(receiver, state, prop) if (prop === 'can') return enterDefineMethodMode(receiver, state) // Lấy ra phương thức được khai báo bởi `t.can` if (state.methods[prop]) return state.methods[prop] // ...&#125; Ở đây có một chút khó khăn. Có thể thấy trong t.can.sing(phrase), sing phải là một hàm. Do đó giá trị trả về của setMethod() có thể được viết như sau: 1234567891011121314function setMethod(receiver, state, prop) &#123; // Đừng quên tắt cờ sau khi cài đặt method state.inDefineMethodMode = false return phrase =&gt; &#123; // Tạo ra hàm mới const f = () =&gt; `$&#123;state.name&#125; $&#123;prop&#125;: $&#123;phrase&#125;` // Lưu vào danh sách các phương thức được khai báo bởi `t.can` state.methods = &#123; ...state.methods, [prop]: f &#125; &#125;&#125;t.can.sing('Yêu hay không yêu không yêu hay yêu nói một lời')console.log(t.sing()) // Phương sing: Yêu hay không yêu không yêu hay yêu nói một lời Vậy là được rồi. Chúng ta chỉ còn một bước nữa là chia “sing” sang ngôi thứ ba số ít “sings”, nhưng thôi cái này để bạn tự làm nhé. Bạn có thể xem đầy đủ mã nguồn ở đây. KếtProxy là một công cụ mạnh mẽ, giúp cho việc lập trình meta trong JavaScript trở nên dễ dàng hơn. Hi vọng bài viết này đã giúp bạn hiểu rõ hơn về Proxy và có thể ứng dụng nó trong công việc. Tham khảoProxy - MDN - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy ES6 Proxies in Depth - https://ponyfoo.com/articles/es6-proxies-in-depth","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Tìm hiểu Map và Set trong Javascript","slug":"Tim-Hieu-Map-Va-Set-Trong-Javascript","date":"2018-07-08T08:12:00.000Z","updated":"2018-07-08T08:57:25.234Z","comments":true,"path":"2018/07/Tim-Hieu-Map-Va-Set-Trong-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Tim-Hieu-Map-Va-Set-Trong-Javascript.html","excerpt":"Được giới thiệu từ ES6, Map, Set, WeakMap, và WeakSet là những cấu trúc dữ liệu giúp thao tác trên tập hợp. Bài viết này sẽ giới thiệu cách hoạt động cũng như các ứng dụng của chúng.","text":"Được giới thiệu từ ES6, Map, Set, WeakMap, và WeakSet là những cấu trúc dữ liệu giúp thao tác trên tập hợp. Bài viết này sẽ giới thiệu cách hoạt động cũng như các ứng dụng của chúng. MapMap, mảng kết hợp (associate arrays) hay từ điển (dictionary/dict) là những thuật ngữ dùng để chỉ một cấu trúc dữ liệu, cho phép bạn ánh xạ từ một khóa (key) tương ứng với một giá trị (value). Trong JavaScript, chúng ta có thể sử dụng object để thể hiện cấu trúc này. 123456const dict = &#123; hello: 'Xin chào', bye: 'Tạm biệt',&#125;console.log(dict['hello']) // Xin chào Tuy nhiên, nếu dùng object thì bạn chỉ có thể dùng chuỗi làm khóa. Ngoài ra, cách này cũng có một số hạn chế khác. Lớp Map do ES6 giới thiệu sẽ giúp giải quyết những vấn đề này. Với Map, bạn có thể sử dụng bất cứ dạng dữ liệu nào để làm khóa. 1234567891011const obj = &#123; bar: 2 &#125;const dict = new Map()dict .set('foo', 123) .set(obj, 'hello world')dict.get('foo') // 123dict.get(obj) // 'hello world'// Lấy giá trị của một khóa không tồn tạidict.get('wat') // undefined Bạn cũng có thể truyền vào hàm dựng của Map một mảng các cặp giá trị dạng [key, value], ví dụ như sau: 1234const dict = new Map([ ['foo', 123], [obj, 'hello world']]) Như đã nói ở trên, bạn có thể dùng bất cứ dạng dữ liệu gì để làm khóa cho Map, kể cả mảng, object, hàm, hay NaN. 123456const arr = [1]const f = () =&gt; &#123;&#125;dict .set(arr, 'an array') .set(f, 'a function') .set(NaN, 'not a number') Bản thân Map sử dụng phương thức so sánh SameValueZero để tìm khóa và giá trị tương ứng. SameValueZero hoạt động tương tự như ===, nhưng xem các giá trị NaN bằng nhau, cũng như +0 bằng -0. Đố-hẻm-vui: Đố bạn kết quả của các biểu thức sau là gì? NaN == NaNNaN === NaNObject.is(NaN, NaN) Do SameValueZero nên hai object khác nhau sẽ là hai khóa riêng biệt. 123456const o1 = &#123;&#125;const o2 = &#123;&#125;dict.set(o1, 'Ô Một').set(o2, 'Ô Hai')dict.get(o2) // Ô Haidict.get(&#123;&#125;) // undefined Nếu trong map đã có sẵn khóa, dữ liệu mới sẽ bị ghi đè lên. 12345const m = new Map()m.set('foo', 1)m.set('foo', 2)m.get('foo') // 2 Để duyệt qua các khóa và giá trị trong Map, bạn có thể dùng: 123456789101112131415const dict = new Map([ ['foo', 1], ['bar', 2]])dict.keys() // ['foo', 'bar']dict.values() // [1, 2]dict.entries() // [ ['foo', 1], ['bar', 2] ]dict.forEach(function(value, key, map) &#123; console.log(`$&#123;key&#125; has $&#123;value&#125;`)&#125;, /* thisArgs bạn có thể truyền vào tham chiếu cho `this` ở đây */)// Sử dụng for..of cùng với destructuringfor (let [key, value] of dict) &#123; console.log(`$&#123;key&#125; has $&#123;value&#125;`)&#125; Bạn cũng có thể dùng toán tử spread … với Map 12345678const dict = new Map([ ['foo', 1], ['bar', 2]])console.log([ ['wut', 3], ...dict])// [ [ 'wut', 3 ], [ 'foo', 1 ], [ 'bar', 2 ] ] Một số thao tác khác với Map. 1234567891011121314151617const dict = new Map([ ['foo', 1], ['bar', 2]])// Đếm số cặp giá trị trong mapdict.size // 2// Kiểm tra trong map có khóa \"foo\" hay khôngdict.has('foo') // truedict.has('wut') // false// Xóa một khóa, trả về boolean nếu thành công, false nếu thất bạidict.delete('wut') // falsedict.delete('foo') // true// Xóa hết các cặp giá trị của mapdict.clear() Tại sao lại là size mà không phải length?Một số độc giả tinh ý sẽ nhận ra chúng ta dùng size thay vì length để đếm số cặp giá trị trong map. Lý do là vì: length dùng cho những chuỗi có thể index (đánh số) được, ví dụ với mảng ta có thể arr[3]. Ngược lại, size dành cho những cấu trúc không có thứ tự như Map và Set. SetSet là tập hợp các giá trị không bị trùng lặp, nghĩa là trong một set không thể có hai giá trị bằng nhau. 12345678const s = new Set()set .add('red') .add('blue') .add('sweet') .add('you')s.size // 4 Bạn cũng có thể truyền một mảng vào hàm dựng của Set. 12const s = new Set(['red', 'blue', 'sweet', 'red', 'you'])console.log(s) // Set (4) &#123;'red', 'blue', 'sweet', 'you'&#125; Bạn cũng có thể thấy giá trị ‘red’ bị trùng lặp đã được loại bỏ. Chúng ta có thể áp dụng Set để tạo ra một mảng chứa những phần tử duy nhất. 123const a = ['red', 'blue', 'sweet', 'red', 'you']const b = [...new Set(a)]console.log(b) // [ 'red', 'blue', 'sweet', 'you' ] Cũng tương tự như Map, Set sử dụng SameZeroValue để so sánh các phần tử với nhau. 12345const obj = &#123;&#125;const s = new Set([NaN, &#123;&#125;, obj])s.has(NaN) // trues.has(obj) // trues.has(&#123;&#125;) // false Để duyệt qua các phần tử của Set, bạn có thể dùng các phương thức như với Map. 12345678910111213const s = new Set([1, 2, 3, 4, 5])// Vì Set không có khái niệm keys nên kết quả của `s.keys()` và `s.values()` là như nhau.s.keys()s.values()s.entries()s.forEach(function(value, key, setReference) &#123;&#125;, thisArg)for (let el of s) &#123; console.log(el)&#125; Một số thao tác khác trên Set. 1234567const s = new Set([1, 2, 3, 4, 5])// Xóa một phần tử trong sets.delete(3) // Set (4) &#123;1, 2, 4, 5&#125;// Xóa hết phần tử trong sets.clear() WeakMap và WeakSetES6 cũng giới thiệu hai lớp WeakMap và WeakSet. So với Map, các khóa của WeakMap bắt buộc phải là object, và chúng sẽ bị giải phóng khỏi bộ nhớ (garbage-collecting – “hốt rác”) đầu tiên nếu không có tham chiếu nào. WeakMap có các phương thức tương tự như Map, ngoại trừ việc bạn không thể duyệt qua WeakMap bằng .keys(), .values(), .entries() hay for..of. Bạn cũng không thể .clear(), vì lý do an toàn dữ liệu. Một ứng dụng của WeakMap là dùng để chứa dữ liệu private mà không gây ra rò rỉ bộ nhớ. 12345678910111213141516const privates = new WeakMap()class User &#123; constructor() &#123; const data = &#123; phoneNumber: 123 &#125; privates.set(this, data) &#125; getPhoneNumber() &#123; const data = privates.get(this) return data.phoneNumber &#125;&#125;const u = new User()console.log(u) // &#123;&#125;console.log(u.getPhoneNumber()) // 123 Tương tự như WeakMap, WeakSet cũng chỉ có thể chứa object, và nếu một phần tử trong WeakSet không có tham chiếu tới, nó sẽ bị giải phóng khỏi bộ nhớ. Kết luậnVới những cải tiến so với object thông thường, Map sẽ là công cụ hữu hiệu để lưu trữ dữ liệu dạng (khóa, giá trị). Trong khi đó, Set giúp bạn lưu trữ chuỗi dữ liệu mà không lo lắng về việc trùng lắp giá trị. Tham khảo[1] Axel Rauschmayer. ECMAScript 6: maps and sets. http://2ality.com/2015/01/es6-maps-sets.html [2] Keyed Collections - JavaScript | MDN. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections [3] Steve Brownlee. WeakMap for JavaScript Private Data. https://www.stevebrownlee.com/weakmap-javascript-private-data/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Tổng hợp những tính năng ES6 nổi bật","slug":"Tong-hop-nhung-tinh-nang-ES6-noi-bat","date":"2018-07-08T01:08:00.000Z","updated":"2018-07-08T09:09:59.591Z","comments":true,"path":"2018/07/Tong-hop-nhung-tinh-nang-ES6-noi-bat.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Tong-hop-nhung-tinh-nang-ES6-noi-bat.html","excerpt":"Việc hầu hết những tính năng hay ho hấp dẫn của ES6 đều đã được các trình duyệt hỗ trợ quả là tin vui cho giới lập trình web. Nhờ nó mà nhà phát triển có thể xây dựng ứng dụng trực tiếp bằng ES6, không cần phải thông qua các công cụ chuyển đổi như Babel hay Bublé nữa, giúp ứng dụng trở nên gọn nhẹ hơn, giảm thiểu kích thước tập tin khi chuyển đến người sử dụng.","text":"Việc hầu hết những tính năng hay ho hấp dẫn của ES6 đều đã được các trình duyệt hỗ trợ quả là tin vui cho giới lập trình web. Nhờ nó mà nhà phát triển có thể xây dựng ứng dụng trực tiếp bằng ES6, không cần phải thông qua các công cụ chuyển đổi như Babel hay Bublé nữa, giúp ứng dụng trở nên gọn nhẹ hơn, giảm thiểu kích thước tập tin khi chuyển đến người sử dụng. Nội dung let và const Hàm mũi tên (arrow functions) Chuỗi bản mẫu (template strings) Object chân phương (object literals) Phân rã biến (destructuring) Rest và Spread Giá trị mặc định cho tham số Lớp (class) Promise 1. let và constNgày xa xưa ấy, bạn khai báo biến trong JavaScript bằng var, giống như ví dụ dưới đây. 123456789var foo = 1function printFoo(shouldDo) &#123; if (shouldDo) &#123; var foo = 2 &#125; return foo&#125;console.log(printFoo(false)) // undefinedconsole.log(printFoo(true)) // 2 Biến được khai báo với var sẽ có tầm vực bên trong hàm gần nhất (function scope), và sẽ được đẩy lên đầu của tầm vực (hoisting). Đó là lý do tại sao foo lại có giá trị undefined trong dòng console.log đầu tiên. ES6 giới thiệu let và const như hai cách khai báo biến mới, hỗ trợ tầm vực theo khối (block scope) và không thực hiện hoisting. 1234567891011let foo = 1function printFoo(shouldDo) &#123; if (shouldDo) &#123; let foo = 2 console.log('Value of foo in scope', foo) // 2 &#125; console.log('foo is out of block scope', foo) // 1 return foo&#125;console.log(printFoo(false)) // 1console.log(printFoo(true)) // 1 Điểm khác biệt giữa let và const là với const, bạn không thể gán giá trị mới cho biến sau khi khai báo, trong khi điều này lại có thể với let. 123456let foo = 2foo = 3console.log(foo) // 3const baz = 2baz = 3 // Error: Assignment to constant variable. const mang ý nghĩa “constant” chứ không phải “immutability”. Nghĩa là với các biến là object hay array, bạn vẫn có thể thay đổi giá trị bên trong của chúng. 123456789101112const obj = &#123; foo: 2 &#125;obj.foo = 5obj.bar = 3console.log(obj) // &#123; foo: 5, bar: 3 &#125;const arr = [1]arr.push(2)console.log(arr) // [1, 2]// Tuy vậy bạn không thể gán một đối tượng khác cho obj/arrobj = &#123; baz: 4 &#125; // Error: Assignment to constant variable.arr = [] // Error: Assignment to constant variable. Tính tương thích: Được hỗ trợ trên tất cả trình duyệt, kể cả IE11.Lời khuyên: Dùng const cho tất cả khai báo biến vì nó sẽ giúp bạn hạn chế trường hợp “vô tình” thay đổi giá trị của biến. Chỉ dùng let trong trường hợp bất khả kháng, và tránh xa var. 2. Hàm mũi tênHàm mũi tên – (fat) arrow functions – là một kiểu cú pháp rút gọn cho khai báo hàm trong JavaScript. Trước ES6, bạn khai báo một hàm trong JavaScript với từ khóa function. 12345678function add(x, y) &#123; return x + y&#125;// Hàm add() ở trên là syntactic sugar cho...var add = function(x, y) &#123; return x + y&#125; “Syntactic sugar” là cú pháp làm cho ngôn ngữ trở nên dễ đọc và dễ hiểu hơn, theo kiểu nó làm cho ngôn ngữ “ngọt ngào hơn” (sweeter) với lập trình viên. Với hàm mũi tên trong ES6, bạn có thể viết lại thành: 1234567const add = (x, y) =&gt; &#123; return x + y&#125;// Bạn cũng có thể viết dưới dạng biểu thức (expression), hàm mũi// tên sẽ tự động trả giá trị về (auto-return).const add = (x, y) =&gt; x + y Hàm mũi tên cũng hữu dụng để giải quyết vấn đề muôn thuở trong JavaScript: “which this is this?” – khái niệm con trỏ this. Với ES5, bạn hay gặp trường hợp giống như thế này: 123456789'use strict'function App() &#123; this.count = 0 setInterval(function() &#123; console.log(this.count++) &#125;, 1000)&#125;var a = new App() Trước ES6, mỗi khai báo hàm đều có một giá trị this tách biệt. Điều này làm cho đoạn code ở trên không hoạt động, vì this.count bên trong hàm của setInterval mang giá trị undefined. Cách giải quyết thông thường là đặt một biến self, that hay _this để giữ reference, hoặc sử dụng Function.prototype.bind. 123456789101112131415161718function App() &#123; this.count = 0 var self = this setInterval(function() &#123; console.log(self.count++) &#125;, 1000)&#125;// hoặcfunction App() &#123; this.count = 0 function counter() &#123; console.log(this.count++) &#125; setInterval(counter.bind(this), 1000)&#125; Với hàm mũi tên trong ES6, giá trị của this chính là this trong tầm vực gần nhất với nó (lexical this). Do đó chúng ta không cần phải khai báo biến tạm hay dùng .bind nữa. 12345function App() &#123; this.count = 0 setInterval(() =&gt; console.log(this.count++), 1000)&#125; Hàm mũi tên cũng rất hữu ích khi thao tác trên mảng và tiến hành chuyển đổi dữ liệu, giúp mã nguồn dễ đọc và rõ ràng hơn. 1const subtotal = products.filter(product =&gt; product.price &gt; 500).reduce((acc, product) =&gt; acc + product.price, 0) Tính tương thích: Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ.Lời khuyên: Nếu có dùng đến this thì hàm mũi tên rất hữu dụng. Trường hợp không dùng thì…cũng hữu dụng luôn vì mã nguồn gọn gàng dễ đọc hơn. Với những trường hợp bạn muốn bao đóng giá trị của this chỉ gói gọn trong hàm của nó, dùng function. 3. Chuỗi bản mẫuChuỗi bản mẫu (template strings) là chuỗi chân phương (string literals) nhưng cho phép đính kèm biểu thức. Nó cũng cho phép khai báo chuỗi trên nhiều dòng. Để sử dụng, bạn dùng ký tự backtick ` (dấu huyền). Ví dụ như là: 1234const name = 'John'const greetings = `Hello $&#123;name&#125;,The result of 1 + 1 is $&#123;1 + 1&#125;, and the time is now $&#123;Date.now()&#125;.` Vì chuỗi bản mẫu cũng chỉ là chuỗi nên bạn có thể gọi đến những phương thức của String.prototype. 1;`Hello World`.substr(0, 5).toUpperCase() Tính tương thích: Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ.Lời khuyên: Dùng chuỗi bản mẫu khi bạn cần gắn biểu thức hay chuỗi có nội dung ở nhiều dòng. Còn lại thì vẫn dùng chuỗi bình thường với ‘ hay “. 4. Object chân phương (object literals)Object chân phương (object literals) chỉ đơn giản là khai báo một object trong JavaScript như bạn đã làm bao năm nay. 12345678var birthYear = 2000var obj = &#123; name: 'John', birthYear: birthYear, getAge: function(currentYear) &#123; return currentYear - obj.birthYear &#125;&#125; ES6 nâng cấp object chân phương, cho phép bạn khai báo tắt thuộc tính của object với biến cùng tên, và khai báo phương thức cho object. 123456789const birthYear = 2000const obj = &#123; name: 'John', birthYear, // khai báo tắt birthYear: birthYear getAge(currentYear) &#123; // `this` được gán trực tiếp vào bản thân object return currentYear - this.birthYear &#125;&#125; Một lưu ý với this là khi bạn dùng hàm mũi tên, this sẽ được lấy từ this trong tầm vực gần với nó nhất, chứ không trỏ đến đối tượng hiện tại. Do đó… 123&#123; getAge: currentYear =&gt; currentYear - this.birthYear&#125; …sẽ không chạy như mong muốn, vì có thể this.birthYear mang giá trị undefined. Để sử dụng hàm mũi tên bạn phải viết lại như trước ES6. 123&#123; getAge: currentYear =&gt; currentYear - obj.birthYear&#125; Ngoài ra từ ES6 bạn cũng có thể khai báo thuộc tính cho object một cách linh động bằng cách sử dụng cú pháp []. 1234const attr = 'foo'const year = 2017const obj = &#123; [attr]: 1, ['now' + year]: 'wow' &#125;console.log(obj) // &#123; foo: 1, now2017: 'wow' &#125; Tính tương thích: Được hỗ trợ bởi tất cả trình duyệtLời khuyên: Tính năng khai báo tắt thuộc tính của object cực ký hữu dụng =&gt; nên dùng. Nếu không bận tâm đến this thì bạn có thể dùng hàm mũi tên khi khai báo phương thức cho object để mã nguồn gọn gàng sạch đẹp hơn. 5. Phân rã biếnPhân rã biến – destructuring – theo mình là tính năng tiện dụng nhất của ES6. Tính năng này giúp bạn tách biến từ thuộc tính của đối tượng hay phần tử trong các đối tượng có thể duyệt với for, như mảng hoặc chuỗi. Chẳng hạn như: 1234567891011const user = &#123; name: 'John', age: 21 &#125;const &#123; name &#125; = userconsole.log(name) // 'John'const arr = [1, 2, 3]const [first, second] = arrconsole.log(first, second) // 1, 2const str = 'Hello'const [first, second] = strconsole.log(first, second) // 'H', 'e' Bạn cũng có thể phân rã các thuộc tính lồng nhau. 12345678910const userList = [ &#123; name: 'John', age: 21, products: [&#123; name: 'Creamy Crustacean Omelette', price: 1200 &#125;, &#123; name: 'Galdin Gratin', price: 2300 &#125;] &#125;]const [&#123; products: [&#123; price &#125;] &#125;] = userListconsole.log(price) // 1200 Với mảng hay chuỗi, bạn có thể bỏ qua phần tử không mong muốn khi phân rã. 1234567const arr = [1, 2, 3]const [first, , third] = arrconsole.log(first, third) // 1, 3const str = 'Hello'const [fst, , , , lst] = strconsole.log(fst, lst) // 'H', 'o' Phân rã biến cũng rất thường gặp khi bạn sử dụng ES6 module. 12import &#123; Component &#125; from 'react'import &#123; render &#125; from 'react-dom' Tính tương thích: Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ. 6. Rest và spreadRest – phần còn lại – là một bổ sung của phân rã biến mảng ở trên. Bạn dùng ba dấu chấm … để biểu thị rest. 123456const [first, second, ...others] = [1, 2, 3, 4, 5]console.log(first, second, others)// 1// 2// [3, 4, 5] Rest cũng được dùng khi khai báo hàm có thể nhận nhiều tham số 1234const foo = (...args) =&gt; console.log('You passed', args)console.log(foo(1, 2, 3)) // You passed[ 1, 2, 3 ]const bar = (x, y, ...rest) =&gt; console.log(rest, x, y) Bạn lưu ý biến args ở trên khác với biến đặc biệt arguments vốn có sẵn bên trong hàm. arguments là một đối tượng giống Array, với những thuộc tính đặc biệt như callee, trong khi args chỉ là một mảng bình thường. Spread – rải – là thao tác ngược lại với rest, giúp bạn kết hợp một mảng đã có sẵn thành mảng mới. 123const arr = [3, 4, 5]const newArr = [1, 2, ...arr, 6]console.log(newArr) // [1, 2, 3, 4, 5, 6] Spread rất hữu ích để thay thế các thao tác thên mảng, như .concat(). 123const head = [1, 2]const tail = [3, 4, 5]console.log([...head, ...tail]) // [1, 2, 3, 4, 5] Spread cũng rất ngon khi thay thế cho Function.prototype.apply. 123456const mul = (x, y, z) =&gt; x * y * zconst params = [1, 2, 3]// Thay thế cho// mul.prototype.apply(null, params)mul(...params) Rest/spread cũng có thể hoạt động trên object, tương tự như Object.assign(), nhưng bạn lưu ý tính năng vẫn đang được đề xuất (proposal). Về phía trình duyệt, có Firefox và Chrome là hỗ trợ, trong khi Edge và Safari hoàn toàn không hoạt động. 123456789101112const user = &#123; name: 'John' &#125;// ES5const userWithAgeEs5 = Object.assign(&#123;&#125;, user, &#123; age: 21 &#125;)// Thời đại mới với spreadconst userWithAge = &#123; ...user, age: 21 &#125;console.log(userWithAge) // &#123; name: 'John', age: 21 &#125;// Và restconst &#123; name, ...others &#125; = userWithAgeconsole.log(others) // &#123; age: 21 &#125; Tính tương thích: Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ rest và spread với mảng hay chuỗi. Với spread object, Edge và Safari chưa hỗ trợ. 7. Giá trị mặc định cho tham sốKhi khai báo hàm, tính năng này cho phép bạn thiết lập giá trị mặc định của tham số khi nó không được truyền giá trị hoặc có giá trị undefined. 123function getDiscountedPrice(price, discountRate = 0.1) &#123; return price * (1 + discountRate)&#125; Dĩ nhiên bạn có thể dùng bất cứ giá trị nào làm giá trị mặc định. 1234567function processItems(items = []) &#123; return items.map(transformItemData)&#125;// hoặc dùng biếnconst DISCOUNT_RATE = 0.1const getDiscountedPrice = (price, discountRate = DISCOUNT_RATE) =&gt; price * (1 + discountRate) 8. Lớp (class)Với ES5, chúng ta sử dụng function để tạo lớp và thêm các phương thức vào lớp bằng cách mở rộng prototype. 12345678910function Foo(x) &#123; this.x = x&#125;Foo.prototype.add = function(y) &#123; return this.x + y&#125;var f = new Foo(3)console.log(f.add(2)) // 5 ES6 mang đến cú pháp mới giúp tạo lớp trực tiếp và dễ dàng hơn. 123456789101112131415161718class Foo &#123; constructor(x) &#123; this.x = x &#125; add(y) &#123; return this.x + y &#125; // Khai báo phương thức tĩnh (static method) static whoAmI() &#123; return 'I am a Foo class' &#125;&#125;const f = new Foo(3)console.log(f.add(2)) // 5console.log(Foo.whoAmI()) // I am a Foo class Bạn cũng có thể kế thừa từ lớp khác bằng từ khóa extends. 1234567891011121314class Bar extends Foo &#123; constructor(x, y) &#123; // Gọi đến hàm dựng của lớp cha super(x) this.y = y &#125; calculate() &#123; return this.add(4) + this.y &#125;&#125;const f = new Bar(3, 4)console.log(f.calculate()) // 11 Ngoài ra với bạn cũng có thể dùng hàm mũi tên khi khai báo phương thức trong lớp. Điều này giúp đảm bảo this luôn trỏ đến đối tượng hiện tại. Cú pháp này đặc biệt thông dụng trong các ứng dụng React, tuy nhiên vẫn chưa được hỗ trợ mặc định bởi các trình duyệt, nên bạn phải dùng Babel để chuyển đổi mã nguồn. 12345678910111213class Button extends React.Component &#123; state = &#123; name: 'Fabulous button' &#125; doClick = e =&gt; &#123; e.preventDefault() // 'You clicked Fabulous button' console.log(`You clicked $&#123;this.state.name&#125;`) &#125; render = () =&gt; &#123; return &lt;button onClick=&#123;this.doClick&#125; /&gt; &#125;&#125; Tính tương thích: Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ lớp căn bản. 9. PromiseNếu bạn chưa biết Promise là gì thì click vào đây. Vì Promise đã được công nhận như một phần của đặc tả ECMAScript 6 nên các trình duyệt có nghĩa vụ phải hỗ trợ mặc định. So với những thư viện chuyên biệt như bluebird hay q thì phiên bản mặc định có ít tính năng hơn, nhưng cũng vừa đủ để dùng. Quan trọng là không cần thư viện thứ ba. 1234567891011121314const showUser = user =&gt; console.log(`Your name is $&#123;user.name&#125;`)const getUserData = userId =&gt; new Promise((resolve, reject) =&gt; &#123; return RemoteApi.get(`/users/$&#123;userId&#125;`, (err, response) =&gt; &#123; if (err) return reject(err) resolve(response) &#125;) &#125;)getUserData(123) .then(response =&gt; response.data) .then(showUser) .catch(err =&gt; console.error('Oh no', err)) Promise còn có các hàm tĩnh khác: Promise.all(iterator)Nhận vào một mảng các promises và chỉ resolve khi tất cả promises trong mảng được resolve. Promise.race(iterator)Nhận vào một mảng các promises và resolve/reject ngay khi một trong các promises trong mảng resolve/reject. Promise.resolve()Trả về một promise được tự động resolve. Promise.reject()Trả về một promise được tự động reject. Tính tương thích: Trừ IE11, tất cả các trình duyệt còn lại đều hỗ trợ. KếtES6 mang đến những tính năng tuyệt vời cho lập trình viên, giúp cho làm việc với JavaScript trở nên dễ thở hơn, đồng thời nâng cao hiệu suất, cải thiện mã nguồn và giảm dung lượng tập tin khi truyền tải trên mạng. Nếu ứng dụng của bạn hướng đến các trình duyệt hiện đại, đừng chần chờ gì, hãy dùng ES6 ngay hôm nay.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Chi phí của Javascript","slug":"Chi-phi-cua-Javascript","date":"2018-07-07T08:01:00.000Z","updated":"2018-07-08T09:31:29.960Z","comments":true,"path":"2018/07/Chi-phi-cua-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2018/07/Chi-phi-cua-Javascript.html","excerpt":"Khi các website chúng ta xây dựng ngày càng phụ thuộc vào JavaScript, thỉnh thoảng chúng ta cũng phải trả giá cho những gì được gửi về phía người dùng, theo những cách không dễ nhìn thấy . Trong bài viết này, tôi sẽ nói về lý do tại sao một chút kỷ luật có thể giúp nếu bạn muốn website của mình có thể tải và phản ứng một cách nhanh chóng trên các thiết bị di động.","text":"Khi các website chúng ta xây dựng ngày càng phụ thuộc vào JavaScript, thỉnh thoảng chúng ta cũng phải trả giá cho những gì được gửi về phía người dùng, theo những cách không dễ nhìn thấy . Trong bài viết này, tôi sẽ nói về lý do tại sao một chút kỷ luật có thể giúp nếu bạn muốn website của mình có thể tải và phản ứng một cách nhanh chóng trên các thiết bị di động. tl;dr: less code = less parse/compile + less transfer + less to decompress Dài quá ngại đọc: ít mã lệnh = ít thời gian phân tách/biên dịch + ít dung lượng trao đổi + ít phải giải nén 1. Kết nối mạngKhi nghĩ về chi phí cho JavaScript, hầu hết các lập trình viên nghĩ về mặt chi phí tải và thực thi mã lệnh. Kết nối Internet của người dùng càng chậm thì gửi nhiều bytes JavaScript về phía họ càng lâu. Điều này cũng có thể là một vấn đề với cả những nước đã phát triển, vì kết nối mạng đang sử dụng của một người dùng có thể không thật sự là 3G, 4G hay WiFi. Bạn có thể đang vào mạng WiFi của một quán cà phê, nhưng đang kết nối với một hotspot di động với tốc độ 2G. Bạn có thể giảm chi phí truyền tải JavaScript bằng cách: Chỉ chuyển đến người dùng phần mã lệnh cần thiết. Kỹ thuật chia mã (code-splitting) có thể hữu ích ở đây. Tối giản hóa mã lệnh (sử dụng Uglify cho ES5, babel-minify hay uglify-es cho ES2015) Nén mã lệnh tới mức tối đa, bằng cách dùng Brotli ~ q11, Zopfli hay gzip. Brotli hoàn toàn qua mặt gzip khi xét về tỉ lệ nén. Giải thuật này đã giúp cho CertSimple giảm 17% dung lượng nén tập tin JS, và LinkedIn tiết kiệm 4% thời gian tải. Xóa mã lệnh không dùng tới. Với DevTools code coverage, bạn có thể nhận dạng phần mã nào không được thực thi. Để loại bỏ mã nguồn không cần thiết, bạn có thể sử dụng kỹ thuật “rung cây” (tree-shaking) của Webpack, các kỹ thuật tối ưu hóa nâng cao của Closure Compiler, và các plugin hỗ trợ tỉa tót mã lệnh như lodash-babel-plugin hay ContextReplacementPlugin của Webpack dành cho các thư viện như moment.js. Sử dụng babel-preset-env và browserlist để tránh tình trạng chuyển đổi những tính năng ES2015 đã được hỗ trợ mặc định trong các trình duyệt. Những lập trình viên nhiều kinh nghiệm có thể phân tích các bản đóng gói (bundles) của Webpack và tìm cách bỏ đi những thư viện phụ thuộc không cần thiết. Lưu bộ đệm để giảm tải các yêu cầu mạng. Xác định thời gian sống tối ưu cho các tập tin JS (max-age) và cung cấp các token thẩm định (ETag) để tránh phải truyền tải những bytes không cần thiết. Lưu bộ đệm bằng Service Worker có thể giúp ứng dụng của bạn trở nên chủ động hơn trong trường hợp mất kết nối, đồng thời cho phép bạn truy xuất đến những tính năng đặc biệt, chẳng hạn như bộ đệm lưu trữ mã trong V8. Hãy tìm hiểu về lưu đệm dài hạn với kỹ thuật băm tên tập tin (filename hashing). 2. Phân tách/Biên dịchSau khi đã tải, một trong những chi phí JavaScript nặng nề nhất là thời gian để một trình xử lý JS tiến hành phân tách/biên dịch mã nguồn. Trong Chrome DevTools, phân tách và biên dịch là những phần trong thời gian “Scripting” màu vàng, có thể thấy trong bảng Performance. Phần Bottom-Up/Call Tree cho phép xem chính xác thời gian phân tách và biên dịch mã: Trong bản Performance của Chrome DevTools, tìm đến phần Bottom-Up. Khi Runtime Call Stats trong V8 được kích hoạt, chúng ta có thể thấy thời gian cần thiết của những tiến trình như Phân Tách và Biên Dịch Nhưng mà, tại sao điều này lại quan trọng? Mất nhiều thời gian để phân tách/biên dịch mã nguồn có thể làm chậm đi đáng kể thời gian người dùng có thể tương tác với website. Bạn càng gửi xuống nhiều tập tin JavaScript, trình duyệt càng tốn thời gian để phân tách và biên dịch trước khi website của bạn có thể tương tác được. Ăn byte nào trả byte đó, JavaScript ngày càng trở nên đắt đỏ cho trình duyệt để xử lý hơn là một bức hình hay web font có cùng dung lượng tương ứng – Tom Dale - tác giả của Ember.js So với JavaScript, cũng có nhiều chi phí tham gia vào quá trình xử lý một bức ảnh có dung lượng tương tự (chúng vẫn cần phải được giải mã!) nhưng đối với phần cứng của thiết bị di động trung bình, có vẻ như tác động của JS có phần tiêu cực hơn đến khả năng tương tác của website. Các byte của JavaScript và hình ảnh cần đến những chi phí rất khác nhau. Hình ảnh thường không chặn luồng chính (main thread) hay ngăn cản tương tác với các giao diện trong quá trình giải mã và hiển thị lên màn hình (rasterization). Ngược lại JS có thể làm chậm quá trình tương tác vì các chi phí phân tách, biên dịch và thực thi. Khi chúng ta nói về phân tách và biên dịch bị chậm, ngữ cảnh rất quan trọng – vì ở đây chúng ta đang nói về những chiếc điện thoại ở phân khúc trung bình. Người dùng bình dân có thể dùng những thiết bị với CPUs và GPUs chậm chạp, hoàn toàn không có bộ đệm L2/L3 và thậm chí còn bị giới hạn bộ nhớ. Năng lực mạng và năng lực của thiết bị thường không đi chung với nhau. Một người dùng sử dụng kết nối Fiber siêu tốc không nhất thiết phải có CPU tốt nhất để phân tách và thực thi JavaScript được gửi đến. Điều ngược lại cũng chính xác…kết nối cùi mía, nhưng CPU lại nhanh như điện. – Kristofer Baxter, LinkedIn. Trong bài JavaScript Start-up Performance, tôi có lưu ý về chi phí phân tách một tập tin JavaScript (đơn giản) đã được giải nén có dung lượng khoảng 1MB trên phần cứng bình dân và cao cấp. Thời gian phân tách/biên tịch mã lệnh giữa chiếc điện thoại nhanh nhất với chiếc điện thoại trung bình khác nhau từ 2 đến 5 lần. Thời gian phân tách một bản đóng gói JavaScript có dung lượng 1MB (~250KB gzipped) giữa các thiết bị máy tính cá nhân và di động thuộc nhiều dòng khác nhau. Khi nhìn vào chi phí cho việc phân tách, chúng ta phải xem xét khi tập tin đã được giải nén, chẳng hạn như ~250KB gzipped khi giải nén thì khoảng 1MB. Đối với những trang trong thực tế, như CNN.com thì sao? Trên một chiếc iPhone 8 cao cấp thì mất khoảng 4 giây để phân tách/biên dịch JS trên CNN.com, so với khoảng 13 giây cho một chiếc điện thoại bình dân (Moto G4). Điều này có thể tác động rõ ràng đến khả năng tương tác của người dùng với website. So sánh thời gian phân tách mã nguồn trên chip A11 Bionic của Apple với Snapdragon 617 trên các thiết bị Android bình dân Điều này nêu bật tầm quan trọng của việc kiểm thử ứng dụng trên các phần cứng trung bình (như chiếc Moto G4) thay vì chiếc điện thoại trong túi của bạn. Nói gì thì nói, ngữ cảnh cũng quan trọng: tối ưu hóa cho thiết bị và điều kiện kết nối mà người dùng của bạn có. Các ứng dụng phân tích thống kê (analytics) có thể đưa ra một cái nhìn về dòng thiết bị di động mà người dùng thực tế của bạn đang sử dụng. Thông tin này đem đến cơ hội để hiểu hơn về các điều kiện giới hạn của CPU/GPU trên các thiết bị đó. Mà có thật là chúng ta đang gửi xuống người dùng quá nhiều JavaScript không? Hên xui :) Bằng cách sử dụng HTTP Archive (với khoảng 500K websites) để phân tích hiện trạng JavaScript trên các thiết bị di động, chúng ta có thể thấy rằng 50% website cần đến hơn 14 giây để có thể tương tác. Những trang này bỏ ra đến hơn 4 giây chỉ để phân tách và biên dịch JS. Thời gian để tải và xử lý JS và các tài nguyên khác đóng một vai trò ở đây, và có lẽ không quá ngạc nhiên khi người dùng phải chờ một lúc trước khi cảm giác website đã có thể sử dụng. Rõ ràng chúng ta có thể làm tốt hơn. Loại bỏ những phần JavaScript không quan trọng trong trang có thể giảm thiểu thời gian truyền tải, quá trình phân tách và biên dịch vốn ngốn CPU, và cả việc ngốn bộ nhớ. Nó cũng làm cho website trở nên có thể tương tác được nhanh hơn. 3. Thời gian thực thiChi phí không chỉ nằm ở quá trình phân tách và biên dịch. Quá trình thực thi JavaScript (chạy mã lệnh sau khi đã phân tách/biên dịch) là một trong những thao tác phải xảy ra trong luồng chính. Thời gian thực thi quá lâu có thể làm trì hoãn thời gian người dùng có thể tương tác với website. If script executes for more than 50ms, time-to-interactive is delayed by the entire amount of time it takes to download, compile, and execute the JS — Alex Russell Nếu một đoạn mã phải thực thi trong hơn 50ms, thời gian để tương tác bị trì hoãn bằng nguyên cả thời gian cần thiết để tải, biên dịch và thực thi JS – Alex Russell Để giải quyết vấn đề này, JavaScript tận dụng khả năng chia nhỏ thành từng phần (small chunks) để tránh không khóa hoàn toàn luồng chính. Bạn hãy tìm hiểu để xem có thể giảm thiểu công việc trong quá trình thực thi hay không. 4. Một số khuôn mẫu để giảm thiểu chi phí truyền tải JavaScriptKhi bạn đang tìm cách để giảm thiểu thời gian truyền tải, phân tách và biên dịch JavaScript, có vài khuôn mẫu có thể hữu ích, như kỹ thuật chia nhỏ theo định tuyến (route-based chunking) hay còn gọi là PRPL. PRPL là một kỹ thuật để tối ưu hóa khả năng tương tác trên website bằng cách chia nhỏ mã nguồn và lưu bộ đệm một cách quyết liệt. Hãy xem những tác động nó có thể mang lại. Chúng ta phân tính thời gian tải của những trang web di động thông dụng và các ứng dụng web tăng tiến (Progressive Web Apps – PWAs) bằng cách sử dụng Runtime Call Stats trong V8. Như chúng ta có thể thấy, thời gian phân tách (phần màu cam) chiếm một phần lớn trong tổng thời gian của các website này. Wego, một trang sử dụng PRPL, xoay xở để giữ cho thời gian phân tách ở mức thấp, giúp cho website có thể tương tác nhanh hơn. Những trang còn lại cũng đã thực hiện kỹ thuật chia mã và dự toán hiệu suất (performance budgeting) để giảm chi phí JS. 5. Những chi phí khácJavaScript cũng có thể tác động đến hiệu suất của website theo những hướng khác: Bộ nhớ. Website có thể cảm thấy bị giựt (jank) hay tạm dừng thường xuyên do bộ gom rác (garbage collector - GC) hoạt động. Khi trình duyệt tiến hành thu hồi bộ nhớ, quá trình thực thi JS bị tạm dừng. Do đó khi trình duyệt thu hồi bộ nhớ quá thường xuyên, tiến trình JS cũng bị dừng liên tục hơn chúng ta mong muốn. Lập trình viên cần tránh bị rò rỉ bộ nhớ và tiến trình dừng của GC để website có thể hoạt động ổn định hơn. Trong quá trình chạy, mã JavaScript chạy quá lâu có thể khóa luồng chính, làm cho website trở nên không tương tác được. Bằng cách chia nhỏ công việc ra thành từng phần (sử dụng requestAnimationFrame() hay requestIdleCallback() để phân lịch) có thể giúp giảm thiểu các vấn đề về tương tác. 6. Kỹ thuật Khởi động Tăng tiến (progressive bootstrapping)Nhiều website xem tính ẩn hiện của nội dung trên trang là một chi phí đắt đỏ khi tối ưu hóa tính tương tác. Để có thể thực hiện tiến trình vẽ đầu tiên (first paint) một cách nhanh chóng, lập trình viên thường sử dụng kỹ thuật tạo nội dung trước ở phía server (server-side rendering - SSR), sau đó “nâng cấp” bằng cách gắn các hàm xử lý sự kiện sau khi JavaScript đã được tải về. Nhưng hãy cẩn thận – kỹ thuật này cũng có chi phí riêng của nó. Bạn 1) nhìn chung sẽ gửi xuống một tập tin HTML nặng ký hơn và có thể ảnh hưởng đến tính tương tác của site, hoặc 2) có thể đưa người dùng vào một vùng thung lũng huyền bí (uncanny valley) nơi một nửa trải nghiệm không thật sự có thể tương tác được, cho đến khi JavaScript hoàn tất quá trình xử lý. Kỹ thuật Khởi động Tăng tiến có thể là một hướng tiếp cận tốt hơn. Bạn chỉ cần gửi xuống một trang vừa đủ có thể hoạt động, bao gồm chỉ HTML/JS/CSS cần thiết cho định tuyến hiện tại. Khi các tài nguyên khác đã được tải xong, ứng dụng có thể lazy-load vào và mở ra các chức năng khác. Kỹ thuật tải mã lệnh tương ứng với những gì đang được hiển thị chính là cứu cánh. PRPL và Khởi động Tăng tiến là hai khuôn mẫu giúp đạt được mục tiêu này. Kết luậnKích thước tập tin khi truyền tải rất quan trọng đối với những kết nối mạng cấp thấp. Thời gian phân tách mã nguồn lại quan trọng đối với những thiết bị có giới hạn về CPU. Chúng ta cần phải giữ cho các chỉ số này ở mức thấp. Nhiều nhóm phát triển đã thành công trong việc làm theo các dự toán hiệu suất nghiêm ngặt, để giảm thiểu thời gian truyền tải và phân tách/biên dịch. Bạn có thể xem hướng dẫn “Can You Afford It?: Real-world Web Performance Budgets” của Alex Russell về dự toán hiệu suất cho các thiết bị di động. Nếu bạn đang phát triển một website hướng đến các thiết bị di động, hãy cố gắng hết sức để xây dựng nó trên phần cứng tiêu biểu, giữ cho thời gian phân tách/biên dịch JavaScript ở mức thấp, và thu nhận một dự toán hiệu suất để chắc chắn rằng nhóm của bạn luôn theo sát chi phí JavaScript. Tìm hiểu thêm Bài nói chuyện của tôi ở Chrome Dev Summit 2017 về chi phí cho JavaScript. Phần sau của bài nói có nhắc đến những ví dụ thực tế từ các trang như Pinterest hay Tinder. JavaScript Start-up Performance Solving the web performance crisis — Nolan Lawson Can you afford it? Real-world performance budgets — Alex Russell Evaluating web frameworks and libraries — Kristofer Baxter Kết quả thử nghiệm của Cloudflare cho giải thuật nén Brotli (lưu ý là nén Brotli động ở chất lượng cao có thể làm chậm quá trình hiển thị trang lần đầu tiên nên bạn cần đánh giá một cách thận trọng. Có khi bạn sẽ muốn nén theo phương pháp tĩnh hơn.) Performance Futures — Sam Saccone Chân thành cám ơn Nolan Lawson, Kristofer Baxter và Jeremy Wagner vì những phản hồi của mọi người.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"10 mẹo CSS hữu ích bạn nên biết","slug":"10-meo-CSS-huu-ich-ban-nen-biet","date":"2018-06-27T01:01:00.000Z","updated":"2018-06-27T01:11:20.866Z","comments":true,"path":"2018/06/10-meo-CSS-huu-ich-ban-nen-biet.html","link":"","permalink":"http://nthung2112.github.io/2018/06/10-meo-CSS-huu-ich-ban-nen-biet.html","excerpt":"Pagespeed Optimization (tối ưu hóa tốc độ trang) là một công việc mà hầu như mọi Web developer đều quan tâm và nên biết, mục đích của nó là đưa nội dung website đến với người xem nhanh nhất có thể. Front-end developer thường làm việc với HTML, CSS, Javascript và các hình ảnh. Do đó, đây cũng là các đối tượng chính để chúng ta tối ưu tốc độ tải trang cho website. Tốc độ tải trang của website ngoài các yếu tố liên quan do server thì còn phụ thuộc vào kích thước và số lượng file phải tải về, do đó càng giảm được kích thước file lẫn số lượng file cần phải tải về thì cũng đồng thời tăng tốc độ tải file và giảm số lượng request lên server.","text":"Pagespeed Optimization (tối ưu hóa tốc độ trang) là một công việc mà hầu như mọi Web developer đều quan tâm và nên biết, mục đích của nó là đưa nội dung website đến với người xem nhanh nhất có thể. Front-end developer thường làm việc với HTML, CSS, Javascript và các hình ảnh. Do đó, đây cũng là các đối tượng chính để chúng ta tối ưu tốc độ tải trang cho website. Tốc độ tải trang của website ngoài các yếu tố liên quan do server thì còn phụ thuộc vào kích thước và số lượng file phải tải về, do đó càng giảm được kích thước file lẫn số lượng file cần phải tải về thì cũng đồng thời tăng tốc độ tải file và giảm số lượng request lên server.Ở bài này mình sẽ giới thiệu với các bạn 10 mẹo CSS hữu ích giúp giảm kích thước, số lượng file CSS, tối ưu file CSS và phát triển CSS dễ dàng hơn, nội dung bài gồm những phần sau: Hạn chế sử dụng @import Sử dụng cách viết ngắn gọn (shorthand properties) Khai báo class bổ trợ (Helper classes) Hạn chế sử dụng CSS trong element của HTML (inline CSS attributes in HTML elements) Giảm số lượng file CSS (Combine external CSS) Giảm kích thước file CSS Áp dụng OOCSS (Object Oriented CSS) Đặt tên class và id một cách khoa học Ngôn ngữ tiền xử lý CSS (CSS Preprocessor) Sử dụng Koala-app khi làm việc với CSS 1. Hạn chế sử dụng @importHạn chế sử dụng @import hoặc tốt nhất là không nên sử dụng @import trong file CSS, vì nó sẽ làm chậm quá trình tải và không sử dụng được khả năng tải file đồng thời của browser. Để dễ hiểu bạn hãy xem ví dụ sau: Mình có 2 file CSS là a.css và b.css được nhúng vào trang web như sau: 12&lt;link rel='stylesheet' type='text/css' href='a.css'&gt;&lt;link rel='stylesheet' type='text/css' href='b.css'&gt; Trong file b.css, bạn import file c.css: 1@import url(c.css); Kết quả khi browser tải trang sẽ như thế này: HTML downloada.cssb.cssc.css Chú thích: Request 1: browser gửi request để lấy HTML về Request 2: browser gửi request để lấy a.css Request 3: browser gửi request để lấy b.css Request 4: browser gửi request để lấy c.css Như các bạn thấy ở hình trên, để tải được c.css thì browser phải chờ để tải xong a.css. Lý do: Vì browser khi đã tải xong b.css và bắt đầu đọc nội dung bên trong thì thấy @import yêu cầu phải tải thêm c.css, lúc này browser phải đứng chờ cho nhóm proccess trước đó chạy xong (trong trường hợp này là chờ a.css) thì mới bắt đầu tải tiếp c.css và tiếp tục render sau khi đã tải xong. Trong khi đó nếu bạn loại bỏ @import url(c.css) trong b.css đi và nhúng trực tiếp c.css vào trang HTML 123&lt;link rel='stylesheet' type='text/css' href='a.css'&gt;&lt;link rel='stylesheet' type='text/css' href='b.css'&gt;&lt;link rel='stylesheet' type='text/css' href='c.css'&gt; thì bạn sẽ có kết quả như sau: HTML downloada.cssb.cssc.css Lúc này browser sẽ bắt đầu tải file đồng thời không cần phải chờ cho a.css tải xong, sẽ rút ngắn được thời gian tải file xuống. Như tiêu đề mình nói rằng nên Hạn chế sử dụng @import, vậy một câu hỏi nhỏ đặt ra là khi nào thì nên dùng @import?. Theo mình thì khi những định nghĩa CSS cần lệ thuộc vào một định nghĩa ở file CSS khác trước – thì khi đó nên dùng @import, ví dụ bạn sử dụng các bộ thư viện reset CSS như Normalize.css, bạn cần reset tất cả các định nghĩa CSS về một chuẩn chung trước khi viết định nghĩa CSS tiếp theo – lúc này bạn sẽ dùng @import để import file Normalize.css vào trong file định nghĩa CSS của bạn, lý do sử dụng @import ở đây là để tránh cơ chế tải file đồng thời của browser và bắt buộc browser phải tải và áp định nghĩa CSS của Normalize.css trước rồi mới đến các định nghĩ CSS ở bên dưới @import. Một câu hỏi tiếp theo Nếu nhất thiết phải dùng @import như ví dụ trên, thì các nào khác để giải quyết thay vì dùng @import hay không?. Tất nhiên là có cách, đó là bạn copy toàn bộ nội dung của file Normalize.css vào trong file CSS của bạn, hay còn gọi là Combine external CSS mình sẽ giới thiệu phía bên dưới. 2. Sử dụng cách viết ngắn gọnSử dụng cách viết ngắn gọn (shorthand properties) để dễ dàng thiết lập một số thuộc tính chỉ trên một dòng, đây cũng là một cách để bạn dễ dàng kiểm soát – theo dõi code của mình, đồng thời cũng hỗ trợ giảm số lượng ký tự trong file css và giảm kích thước file. Lấy ví dụ đơn giản về cách thiết lập thuộc tính hình ảnh cho background 12345background-color:#000;background-image:url(bg-image.jpg);background-repeat:no-repeat;background-attachment:fixed;background-position:center center; Bạn có thể viết thành 1background:#000 url(bg-image.jpg) no-repeat fixed center center; Cấu trúc shorthand của thuộc tính background như sau 1background: &lt;color&gt; &lt;image&gt; &lt;repeat&gt; &lt;attachment&gt; &lt;position&gt;; Ngoài background thì còn có một số thuộc tính khác cũng có thể sử dụng shorthand như margin, padding, border, outline, … bạn có thể tham khảo thêm trên Mozilla Developer Network (MDN). Ở cuối trang này có danh sách các thuộc tính có thể áp dụng shorthand. Bên cạnh đó, nếu bạn thích khai báo mã màu HEX thì đối với một số mã màu thông dụng bạn cũng có thể viết ngắn gọn lại ví dụ như #FFF thay cho #FFFFFF hay #000 thay cho #000000. Bạn có thể tham khảo cách chuyển đổi tại CSS Color Converter. 3. Khai báo class bổ trợClass bổ trợ (Helper classes) là những class được định nghĩa sẵn một số thuộc tính đơn giản và thường hay sử dụng. Ví dụ như text-align, font-weight, color… Class bổ trợ trong quá trình viết HTML các bạn chỉ cần thêm class đó vào mà không cần phải định nghĩa lại thuộc tính. Cách làm này khá hữu dụng khi bạn sử dụng một CSS framework và cần custom “rất ít” thuộc tính, hoặc bạn không chọn được tên class phù hợp cho element đó, hay element đó không cần xác định class để làm gì đó với javascript. Điểm lợi của việc này ngoài việc bạn không cần định nghĩa lại một số thuộc tính không cần thiết, thì nếu CSS càng nhiều thì bạn sẽ tiết kiệm được khá nhiều thuộc tính cần khai báo lại và sẽ giảm được kích thước file CSS. Ví dụ: Mình có các element sau cần viết CSS và mình đang dùng framework bootstrap: 12345&lt;p class=\"text-center\"&gt; &lt;button type=\"button\" class=\"btn btn-success btn-md text-uppercase\"&gt; Show More &lt;/button&gt;&lt;/p&gt; Thay vì mình cần phải viết CSS như sau để custom lại theo ý mình 12p &#123; text-align: center; padding-top: 20px; &#125;p &gt; button &#123; background-color: #fff; padding-right: 30px; padding-left: 30px &#125; Thì mình sẽ khai báo class bổ trợ để có thể tái sử dụng cho nhiều trường hợp khác về sau ( Những class có sẵn của bootstrap mình sẽ không liệt kê vào, vì hiện giờ mình cần custom các element này ) 1234.padding-top-20 &#123; padding-top: 20px; &#125;.padding-right-30 &#123; padding-right: 30px; &#125;.padding-left-30 &#123; padding-left: 30px; &#125;.btn.btn-bg-white &#123; background-color: #fff; &#125; Như vậy trong HTML mình sẽ khai báo như sau 123&lt;p class=\"text-center padding-top-20\"&gt; &lt;button type=\"button\" class=\"btn btn-success btn-md btn-bg-white text-uppercase padding-right-30 padding-left-30\"&gt;Show More&lt;/button&gt;&lt;/p&gt; Như vậy thì về sau những class này mình có thể tái sử dụng rất nhiều lần ở rất nhiều element, và mình có thể bỏ đi khá nhiều công đoạn phải gõ lại code CSS khi có phát sinh thêm element mới. Điều này mình học hỏi từ bootstrap và cảm thấy nó khá là hay. Bạn có thể tham khảo thêm các helper class hoặc typography của bootstrap để hiểu rõ hơn. 4. Hạn chế sử dụng Inline CSS trong các elementsỞ đây, mình chỉ khuyên các bạn nên hạn chế sử dụng, vì điều này sẽ làm các bạn khó kiểm soát code CSS của mình. “Vạn bất đắc dĩ” cần giải quyết nhanh (hotfix) thì hãy dùng hoặc nếu chỉ dùng một lần hoặc là CSS động từ javascript thì có thể chấp nhận được. Theo như Google Pagespeed Insights thì việc này sẽ làm code bị lặp lại không cần thiết và vi phạm Chính sách Bảo mật Nội dung của W3, trong một số trường hợp thì các attribute này sẽ bị chặn. 5. Giảm số lượng file CSSGom các file CSS lại với nhau (Combine external CSS) là việc dễ làm nhất, thay vì phải viết thành nhiều file như header.css, navigation.css, footer.css… vào trong văn bản HTML thì bạn hãy gom các file này thành một file duy nhất. Nội dung file này sẽ chứa toàn bộ nội dung của các file trên, như vậy bạn sẽ giảm được nhiều request đến server và giảm tải cho server khá nhiều. Thay vì sử dụng như vầy 123&lt;link rel=\"stylesheet\" href=\"/css/header.css\"&gt;&lt;link rel=\"stylesheet\" href=\"/css/navigation.css\"&gt;&lt;link rel=\"stylesheet\" href=\"/css/footer.css\"&gt; Nên gom chúng lại thành 1&lt;link rel=\"stylesheet\" href=\"/css/style.css\"&gt; 6. Giảm kích thước file CSSGiảm kích thước file CSS được thực hiện bằng cách loại bỏ các khoảng trắng không cần thiết, dấu xuống hàng, dấu chấm phẩy cuối cùng trong class hoặc id… Công đoạn này còn được gọi là minify. Để tiện phân biệt giữa file chưa minify và file đã minify thì bạn nên thêm .min vào tên file đã minify. Ví dụ style.css sau khi minify sẽ thành style.min.css. Bạn có thể truy cập vào Clean CSS để thực hiện minify css hoặc sử dụng tool Koala-app mình sẽ giới thiệu bên dưới để tự động xuất file minify trong quá trình viết code. 7. Áp dụng kỹ thuật OOCSSOOCSS (Object Oriented CSS) – CSS hướng đối tượng, thật ra hướng đối tượng ở đây có nghĩa là bạn gom các thuộc tính giống nhau của 2 class cùng áp dụng cho một element thành một class để giảm thiểu sự lặp lại. Ví dụ: Thay vì khai báo 2 class cho button như sau 123456789101112131415161718192021222324252627282930313233.btn-primary &#123; display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; font-weight: 400; line-height: 1.42857143; text-align: center; white-space: nowrap; vertical-align: middle; border: 1px solid transparent; border-radius: 4px; color: #fff; background-color: #337ab7; border-color: #2e6da4;&#125; .btn-success &#123; display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; font-weight: 400; line-height: 1.42857143; text-align: center; white-space: nowrap; vertical-align: middle; border: 1px solid transparent; border-radius: 4px; color: #fff; background-color: #5cb85c; border-color: #5cb85c;&#125; Mình sẽ gom một số thuộc tính của 2 class này thành một class khác có tên là btn: 12345678910111213141516171819202122232425.btn &#123; display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; font-weight: 400; line-height: 1.42857143; text-align: center; white-space: nowrap; vertical-align: middle; border: 1px solid transparent; border-radius: 4px;&#125; .btn.btn-primary &#123; color: #fff; background-color: #337ab7; border-color: #2e6da4;&#125; .btn.btn-success &#123; color: #fff; background-color: #5cb85c; border-color: #5cb85c;&#125; Như vậy nếu sau này có thay đổi gì về một số thuộc tính chung của 2 class thì mình chỉ cần thay đổi class btn thì sẽ dễ dàng và nhanh hơn. 8. Tổ chức class và id một cách khoa họcViệc này để hỗ trợ bạn sau này khi xem lại code của mình dễ dàng hơn và không bị rối với cách đặt tên của mình, đồng thời cũng dễ dàng nếu có áp dụng một số CSS preprocessor hay BEM. Thay vì đặt tên 12345.titlepost &#123;&#125; .headerpost &#123;&#125; .contentpost &#123;&#125; thì nên đặt thành 1234567.post &#123;&#125; .post-title &#123;&#125; .post-header &#123;&#125; .post-content &#123;&#125; hoặc tổ chức thành 1234567.post &#123;&#125; .post &gt; .title &#123;&#125; .post &gt; .header &#123;&#125; .post &gt; .content &#123;&#125; 9. Ngôn ngữ tiền xử lý CSSTiền xử lý CSS (CSS Preprocessor) – là một cách mở rộng của CSS hoặc cũng có thể coi nó là một ngôn ngữ riêng. Mục đích của CSS preprocessor là để bạn dễ dàng cấu trúc các đoạn code CSS, giảm thời gian phải viết đi viết lại một đoạn code, dễ dàng áp dụng OOCSS… Nói cách khác bạn có thể hiểu CSS preprocessor gần như là một ngôn ngữ lập trình vì nó cũng có biến, kế thừa class, và dễ dàng tạo ra một thư viện riêng cho bạn quản lý, kế thừa và tái sử dụng ở những dự án khác. CSS preprocessor hiện nay có rất nhiều nhưng phổ biến nhất hiện nay là Less và Sass. Ở đây mình giới thiệu các bạn về Sass vì mình đang sử dụng nó thay cho Less, và CSS framework phổ biến – Bootstrap, kể từ phiên bản 4 đã chuyển từ Less qua Sass. Về Sass các bạn xem hướng dẫn cài đặt trên trang chủ. Khi bắt đầu với một dự án có áp dụng Sass, việc đầu tiên mình thường làm là cấu trúc CSS thành nhiều file nhỏ để tránh nhồi nhét CSS vào một file và dễ dàng cho việc quản lý, tìm kiếm khi cần thiết. Mình thường cấu trúc các file Sass như sau: 1234567891011scss|-- style.scss|-- _variable.scss|-- _helper.scss|-- _mixins.scss|-- components|-- -- _header.scss|-- -- _footer.scss|-- mixins|-- -- button.scss|-- -- label.scss Trong file style.scss nội dung như sau: 1234567@import \"variable\";@impprt \"helper\";@import \"mixins\"; // Components@import \"components/header\";@import \"components/footer\"; Chú thích: _variable.scss: variable chứa các thông tin về các biến dùng chung _helper.scss: helper sẽ chứa/import các class helper _mixins.scss: mixins sẽ chứa/import các class custom hoặc class được tái sử dụng nhiều lần Nội dung file _helper.scss như mình đã nói sẽ tạo ra các class helper, nhưng ở đây mình áp dụng tính chất của Scss để tạo ra các class với ít dòng code nhất: 12345678910111213141516171819202122232425$numbersPX: \"10\" 10px, \"15\" 15px, \"20\" 20px, \"25\" 25px, \"30\" 30px; // padding@each $i in $numbersPX&#123; .padding-#&#123;nth($i, 1)&#125; &#123; padding: nth($i, 2) !important; &#125; .padding-top-#&#123;nth($i, 1)&#125; &#123; padding-top: nth($i, 2) !important; &#125; .padding-bottom-#&#123;nth($i, 1)&#125; &#123; padding-bottom: nth($i, 2) !important; &#125; .padding-right-#&#123;nth($i, 1)&#125; &#123; padding-right: nth($i, 2) !important; &#125; .padding-left-#&#123;nth($i, 1)&#125; &#123; padding-left: nth($i, 2) !important; &#125;&#125; khi Sass complier ra file CSS thì mình sẽ thu được kết quả như sau 12345678910111213141516171819202122232425.padding-10 &#123; padding: 10px !important; &#125;.padding-top-10 &#123; padding-top: 10px !important; &#125;.padding-bottom-10 &#123; padding-bottom: 10px !important; &#125;.padding-right-10 &#123; padding-right: 10px !important; &#125;.padding-left-10 &#123; padding-left: 10px !important; &#125;.padding-15 &#123; padding: 15px !important; &#125;.padding-top-15 &#123; padding-top: 15px !important; &#125;.padding-bottom-15 &#123; padding-bottom: 15px !important; &#125;.padding-right-15 &#123; padding-right: 15px !important; &#125;.padding-left-15 &#123; padding-left: 15px !important; &#125;.padding-20 &#123; padding: 20px !important; &#125;.padding-top-20 &#123; padding-top: 20px !important; &#125;.padding-bottom-20 &#123; padding-bottom: 20px !important; &#125;.padding-right-20 &#123; padding-right: 20px !important; &#125;.padding-left-20 &#123; padding-left: 20px !important; &#125;.padding-25 &#123; padding: 25px !important; &#125;.padding-top-25 &#123; padding-top: 25px !important; &#125;.padding-bottom-25 &#123; padding-bottom: 25px !important; &#125;.padding-right-25 &#123; padding-right: 25px !important; &#125;.padding-left-25 &#123; padding-left: 25px !important; &#125;.padding-30 &#123; padding: 30px !important; &#125;.padding-top-30 &#123; padding-top: 30px !important; &#125;.padding-bottom-30 &#123; padding-bottom: 30px !important; &#125;.padding-right-30 &#123; padding-right: 30px !important; &#125;.padding-left-30 &#123; padding-left: 30px !important; &#125; 10. Giới thiệu sơ lược Koala AppKoala app là một ứng dụng GUI hỗ trợ biên dịch Less, Sass, Compass và CoffeeScript sang CSS và JS. Koala App chạy được trên cả 3 môi trường Mac OS, Linux và Windows nên rất tiện nếu bạn cần thay đổi qua lại giữa các hệ điều hành. Ngoài ra, Koala App còn hỗ trợ minify cho cả CSS và JS. Sử dụng Koala App rất đơn giản, bạn chỉ cần mở lên và ấn dấu + trên đầu chương trình để chọn thư mục chứa các file cần xử lý, và Koala App sẽ tự động scan toàn bộ các folder bên trong và theo dõi khi có thay đổi. Nếu bạn “siêng” thì có thể tham khảo cách để tự cấu hình project để Koala-app hoạt động theo ý mình tại đây. Trên đây là những mẹo CSS rút ra từ kinh nghiệm làm việc của mình. Nếu bạn còn những mẹo hay khác thì đừng ngại chia sẻ bên dưới nhé.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"}]},{"title":"Tối ưu hiệu suất render để website mượt hơn","slug":"Toi-uu-hieu-suat-render-de-website-muot-hon","date":"2018-06-26T00:50:00.000Z","updated":"2018-06-27T01:12:25.692Z","comments":true,"path":"2018/06/Toi-uu-hieu-suat-render-de-website-muot-hon.html","link":"","permalink":"http://nthung2112.github.io/2018/06/Toi-uu-hieu-suat-render-de-website-muot-hon.html","excerpt":"Optimizing Performance (tối ưu hóa hiệu suất) cho website là một công việc mà bất kỳ front-end developer nào cũng nên biết, mục đích là để trang web đáp ứng được 3 tiêu chí: NHẸ: Giảm kích thước trang web và các thành phần đi kèm như javascript, css, hình ảnh… nhằm đảm bảo thời gian tải xuống ngắn hơn. Chúng ta có thể dùng các bộ minify cho javascript, css…, nén các tập tin hình ảnh, font chữ, svg… ngoài ra còn có các kĩ thuật như code splitting, browser caching, HTTP caching… NHANH Hiển thị nội dung trang web càng sớm càng tốt bằng cách: chia cấu trúc DOM hợp lý, hạn chế blocking CSS/JS, hạn chế chỉnh sửa DOM tree, chia các file ra thành nhiều module, tải resource bất đồng bộ, tối ưu hóa các selector của CSS và JS… MƯỢT: Sau khi nội dung trang web đã được tải về và hiển thị thì việc tiếp theo là bảo đảm các hiệu ứng animation, transition, scrolling… phải mượt, không bị lag và giật (jank).","text":"Optimizing Performance (tối ưu hóa hiệu suất) cho website là một công việc mà bất kỳ front-end developer nào cũng nên biết, mục đích là để trang web đáp ứng được 3 tiêu chí: NHẸ: Giảm kích thước trang web và các thành phần đi kèm như javascript, css, hình ảnh… nhằm đảm bảo thời gian tải xuống ngắn hơn. Chúng ta có thể dùng các bộ minify cho javascript, css…, nén các tập tin hình ảnh, font chữ, svg… ngoài ra còn có các kĩ thuật như code splitting, browser caching, HTTP caching… NHANH Hiển thị nội dung trang web càng sớm càng tốt bằng cách: chia cấu trúc DOM hợp lý, hạn chế blocking CSS/JS, hạn chế chỉnh sửa DOM tree, chia các file ra thành nhiều module, tải resource bất đồng bộ, tối ưu hóa các selector của CSS và JS… MƯỢT: Sau khi nội dung trang web đã được tải về và hiển thị thì việc tiếp theo là bảo đảm các hiệu ứng animation, transition, scrolling… phải mượt, không bị lag và giật (jank). Trong 3 tiêu chí này, có 2 tiêu chí mà front-end developer chúng ta hằng ngày đều thực hiện là nhẹ và nhanh. Bằng cách sử dụng các framework (angularjs, reactjs…) và các bộ build tool (grunt, gulp, webpack…), các resource trong project ở môi trường production lúc nào cũng được minify và đóng gói đầy đủ, gọn gàng. Do đó, trong bài này tôi sẽ hướng dẫn cho bạn cách đáp ứng được tiêu chí thứ 3, đó là MƯỢT, thứ mà ít có framework hay công cụ nào có thể hỗ trợ bạn được. Trên thực tế, các web page yêu cầu độ mượt cao thường là các webpage có nhiều hiệu ứng, chuyển động, ví dụ như các trang landing page, giới thiệu sản phẩm, HTML5 game, hoặc các ứng dụng có animation chạy trên các thiết bị có cấu hình thấp. Bạn có thể xem qua một số trang sau: http://world.mathigon.org/ http://matthew.wagerfield.com/parallax/ Làm thế nào để web page “mượt”?Mượt ở đây chính là “Rendering Performance”, để tối ưu hiệu suất render chúng ta phải hiểu được quá trình render của browser. 60… là số khung hình trên một giây mà các thiết bị phổ biến hiện nay hỗ trợ (60fps). Để cho trang web mượt thì tốc độ render phải đáp ứng được con số này. Tức là trong 1 giây chúng ta phải cho ra 60 khung hình. Với mỗi khung hình, chúng ta có 1 / 60 = 16,66 mili giây. Trên thực tế, browser còn có một số tác vụ khác phải làm bên cạnh việc render, vì thế chúng ta trừ hao còn lại khoảng 16ms. Bất cứ animation hay transition nào, muốn đảm bảo được tốc độ 60fps thì phải cũng phải đảm bảo trong vòng 16ms phải render được một khung hình, nếu không thì sẽ bị hiện tượng “frame skip”, hiệu ứng sẽ bị giật, lag. Cần phải làm những gì trong 16ms đó?Để cho ra được 1 khung hình, đây là các việc mà browser phải thực hiện (the pixel pipeline): Giải thích ngắn gọn: 1. JavaScript: là hoạt động execute code của javascript. 1document.getElementById('my-element').style.width = '300px'; 2. Style calculation: tính toán các thuộc tính theo các quy tắc từ file CSS (hoặc thẻ &lt;style&gt;, thuộc tính style). 1&lt;div id='my-element' style='width: 300px'&gt;Hello&lt;/div&gt; 3. Layout: browser thực hiện “chia vùng” cho các element khi hiển thị trên màn hình, dựa trên các thuộc tính đã tính toán được từ bước Style. 4. Paint: tô màu cho từng pixel, bao gồm việc: vẽ chữ (render font), hình ảnh, màu, vẽ các hiệu ứng CSS như border, box-shadow… Việc tô màu này được thực hiện trên nhiều “layer” cùng một lúc (phần sau sẽ giải thích rõ hơn về layer). Đây là bước chiếm nhiều thời gian nhất. 5. Composite: gộp các layer đã được vẽ (ở bước Paint) và hiển thị lên màn hình theo đúng thứ tự của các layer đó. Như vậy, chỉ với 16ms browser phải thực hiện 5 bước như trên để có thể render ra được 1 khung hình. Vậy để đảm bảo mọi thứ đều hoàn thành dưới 16ms, việc chúng ta cần làm là tối ưu từng bước. Cụ thể là: JavaScript: Dùng requestAnimationFrame. Dùng Web workers, Micro-task cho các tác vụ nặng. Profiling with Chrome DevTools. Style: Giảm độ phức tạp của selector Giảm số lượng element bị ảnh hưởng Layout: Hạn chế kích hoạt layout Sử dụng Flexbox Hạn chế forced synchronous layout. Paint: Paint là tác vụ xử lý lâu nhất Box-shadow, large image không tốt cho paint Tạo và quản lý layer hợp lý Composite: Sử dụng transform và opacity Quản lý các layer bằng Chrome DevTools Từng bước tối ưu hiệu suất renderBước 1: Javascript1.1. Sử dụng requestAnimationFrame để thực hiện các thay đổi trên UI.Khi thực hiện các thay đổi trên UI bằng JavaScript, bạn sẽ muốn thực hiện nó ngay vào lúc bắt đầu của frame, lúc đó browser sẽ có được toàn bộ 16ms để thực hiện các thay đổi (JavaScript ⇒ Style ⇒ Layout ⇒ Paint ⇒ Composite). Để làm được điều này bạn cần dùng hàm requestAnimationFrame. Hàm này có chức năng “hẹn giờ” chạy vào đúng thời điểm của frame tiếp theo. 12345678/** * If run as a requestAnimationFrame callback, this * will be run at the start of the frame. */function updateScreen(time) &#123; // Make visual updates here.&#125;requestAnimationFrame(updateScreen); Một số đoạn code trên mạng hoặc trong các framework thường sử dụng hàm setTimeout, tuy nhiên hàm được gọi bởi setTimeout sẽ không khởi chạy lúc bắt đầu frame, dẫn đến việc không tận dụng hết được khoảng thời gian 16ms, do đó gây ra hiện tượng frame skip, gây giật, lag. 1.2. Chuyển các tác vụ nặng sang Web workersĐối với các tác vụ nặng như encode/decode, xử lý dữ liệu lớn… chúng ta nên chuyển tác vụ đó sang Web Workers. Web Workers hoạt động trên một thread riêng biệt, sẽ giúp giảm tải cho UI Thread và giúp tiết kiệm được thời gian xử lý. 123456789var dataSortWorker = new Worker(\"sort-worker.js\");dataSortWorker.postMesssage(dataToSort); // The main thread is now free to continue working on other things... dataSortWorker.addEventListener('message', function(evt) &#123; var sortedData = evt.data; // Update data on screen...&#125;); Tuy nhiên, Web Workers không thể tương tác với DOM tree, do đó một số tác vụ không thể chuyển qua Web Workers được. Trong trường hợp này ta có thể áp dụng phương pháp “micro-task”: chia nhỏ task ra, sau đó sử dụng requestAnimationFrame để cập nhật UI. Lúc này, nếu mỗi task nhỏ có thời gian thực thi bé hơn 16ms thì sẽ tránh được hiện tượng giật, lag như khi chạy cả task lớn. 123456789101112131415161718192021var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);requestAnimationFrame(processTaskList); function processTaskList(taskStartTime) &#123; var taskFinishTime; do &#123; // Assume the next task is pushed onto a stack. var nextTask = taskList.pop(); // Process nextTask. processTask(nextTask); // Go again if there’s enough time to do the next task. taskFinishTime = window.performance.now(); &#125; while (taskFinishTime - taskStartTime &lt; 3); if (taskList.length &gt; 0) requestAnimationFrame(processTaskList); &#125; 1.3. Sử dụng Chrome DevTools để “điều tra” JavaScript executionChrome DevTools là công cụ cực kỳ hữu ích. Ở tab “Timeline” của Chrome DevTools, bạn có thể kiểm tra được độ mượt của web page bằng cách: Nhấn nút Record (hoặc Ctrl + R trên Windows, Command + R trên Mac) Thực hiện animation / transition trên trang web chính Nhấn nút Stop Record. Chrome DevTools sẽ hiển thị toàn bộ các thông tin liên quan đến các tác vụ JavaScript ⇒ Style ⇒ Layout ⇒ Paint ⇒ Composite. Bạn có thể kiếm tra để xem tác vụ nào chiếm nhiều thời gian nhất và gây ra frame skip. Bước 2: Style calculationCố gắng giữ cho selector của bạn càng đơn giản càng tốt, và giảm số lượng element bị ảnh hưởng bởi selector, ví dụ: Nên: 1.title &#123; /* styles */ &#125; Không nên: 1.box:nth-last-child(-n+1) .title &#123; /* styles */ &#125; Không nên: 1*, *:before, *:after &#123; /* styles */ &#125; Nên: 1body &#123; /* styles */ &#125; Việc sử dụng các selector này cần phải cân bằng giữa việc code gọn gàng đẹp đẽ và hiệu suất. Khi sử dụng các selector phức tạp thì browser cần phải thực hiện nhiều tính toán, nhưng nếu chỉ sử dụng các selector đơn giản thì lại khiến code của chúng ta khó quản lý. Giải pháp ở đây là chúng ta nên sử dụng một số kỹ thuật quản lý style như: BEM (Block, Element, Modifier), PostCSS. Các công cụ này sẽ giúp chúng ta vừa dễ quản lý code CSS ở môi trường dev, và cũng vừa đảm bảo hiệu suất ở môi trường production sau khi build. Bước 3: Layout3.1. Hạn chế kích hoạt tính toán layoutViệc thay đổi một số thuộc tính CSS của element có thể kích hoạt browser tính toán lại layout của element đó. 12345678910111213.box &#123; width: 20px; height: 20px;&#125; /** * Changing width and height * triggers layout. */.box--expanded &#123; width: 200px; height: 350px;&#125; Khi một element bị thay đổi layout thì thường là các element khác cũng sẽ bị thay đổi theo (kích thước, vị trí…). Do đó nếu trang của bạn có nhiều element và việc kích hoạt layout diễn ra quá thường xuyên thì hoàn toàn không tốt cho performance. Bạn có thể sử dụng Chrome DevTools để kiểm tra xem web page của bạn có bị kích hoạt layout quá nhiều hay không. Ví dụ trong hình này, bạn có thể thấy sự kiện Layout chiếm tới 20.636ms, vượt qua con số 16ms và tất nhiên là sẽ dẫn đến frame skip, số lượng element cần tính toán lại layout là 1618 (rất nhiều). Để biết được những thuộc tính nào sẽ kích hoạt Layout (và lý do vì sao), bạn có thể tra cứu ở trang http://csstriggers.com/ – công cụ do một Googler viết cho mục đích tra cứu. 3.2. Sử dụng các thuộc tính mới của CSS3CSS3 có cung cấp một số thuộc tính mới không những giúp chúng ta canh chỉnh layout dễ hơn mà còn giúp tăng hiệu suất rất nhiều. Điển hình là Flexbox, việc sử dụng flexbox để canh chỉnh layout sẽ dễ hơn so với cách dùng float truyền thống. Xem bài hướng dẫn tuyệt vời về Flexbox: http://css-tricks.com/snippets/css/a-guide-to-flexbox/ Về hiệu suất, dưới đây là 2 hình ảnh đo hiệu suất của việc kích hoạt layout trên 1300 elements. Sử dụng Float: Sử dụng Flexbox: Có thể thấy con số “Self Time” giảm từ ~14ms chỉ còn ~3.5ms, đó là một sự thay đổi rất đáng kể. 3.3. Hạn chế kích hoạt layout sớmHãy xem xét đoạn code sau: thay đổi kích thước của 3 elements 1234567891011121314151617// Readvar h1 = element1.clientHeight; // Write (invalidates layout)element1.style.height = (h1 * 2) + 'px'; // Read (triggers layout)var h2 = element2.clientHeight; // Write (invalidates layout)element2.style.height = (h2 * 2) + 'px'; // Read (triggers layout)var h3 = element3.clientHeight; // Write (invalidates layout)element3.style.height = (h3 * 2) + 'px'; Khi một element (DOM) được ghi giá trị mới thì layout sẽ bị đánh dấu giá trị hết hiệu lực (invalidates) và sẽ được tính toán lại tại một thời điểm nào đó. Để đảm bảo performance, browser sẽ thực hiện tính toán lại layout vào thời điểm bắt đầu của frame tiếp theo. Tuy nhiên nếu trong thời gian frame hiện tại chưa kết thúc, ta muốn lấy giá trị kích thước của element thì lúc này browser buộc phải thực hiện tính toán layout lại sớm hơn so với thông thường để có thể trả về kết quả. Hiện tượng này gọi là “forced synchronous layout” – tạm dịch “kích hoạt layout sớm”, và nó gây ra vấn đề về performance khi ta phải thực hiện nhiều tác vụ hơn trong 1 frame. Để giải quyết, cách nhanh nhất là chúng ta sẽ “đọc trước, ghi sau”. 1234567891011// Readvar h1 = element1.clientHeight;var h2 = element2.clientHeight;var h3 = element3.clientHeight; // Write (invalidates layout)element1.style.height = (h1 * 2) + 'px';element2.style.height = (h2 * 2) + 'px';element3.style.height = (h3 * 2) + 'px'; // Document reflows at end of frame Hoặc sử dụng requestAnimationFrame để “hẹn giờ” cho cả 3 thao tác ghi vào frame tiếp theo: 123456789101112131415// Readvar h1 = element1.clientHeight; // WriterequestAnimationFrame(function() &#123; element1.style.height = (h1 * 2) + 'px';&#125;); // Readvar h2 = element2.clientHeight; // WriterequestAnimationFrame(function() &#123; element2.style.height = (h2 * 2) + 'px';&#125;); Bằng cách này, cả 3 thao tác ghi đều sẽ được thực hiện một lần trong frame tiếp theo, tốt hơn cho hiệu suất. Bạn sẽ thấy rõ tác dụng của việc hạn chế layout sớm trong một số trường hợp thực tế như sau “Layout thrashing”: 1234// Puts the browser into a read-write-read-write cycle.for (var i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + 'px';&#125; Như đoạn code trên, layout sẽ liên tục bị trigger và kích hoạt sớm ở trong vòng lặp (read: box.offsetWidth, và write: paragraphs[i].style.width) điều này là thảm họa cho browser (hình: dấu chấm than vàng là báo hiệu forced synchronous layout). Nếu đã biết về vấn đề forced synchronous layout, đoạn code trên nên được viết lại như sau: 123456789// Read.var width = box.offsetWidth; function resizeAllParagraphsToMatchBlockWidth() &#123; for (var i = 0; i &lt; paragraphs.length; i++) &#123; // Now write. paragraphs[i].style.width = width + 'px'; &#125;&#125; Nếu cảm thấy việc quản lý layout quá phức tạp, bạn có thể tham khảo sử dụng thư viện FastDOM, thư viện này giúp bạn quản lý các tác vụ read/write để đảm bảo không gây ra forced synchronous layout. Bước 4: Paint4.1. Dùng Chrome Developer Tools để phát hiện vấn đề performance khi paintBất kỳ sự thay đổi nào trên màn hình browser đều yêu cầu quá trình paint, animation, transition, lúc bôi đen đoạn text hay cả con trỏ nhấp nháy ở textbox. Để biết được browser phải vẽ lại những phần nào trên màn hình, bạn có thể bật chức năng “Show paint rectangles” ở tab “Rendering” trong Chrome Developer Tools. Những vùng bị vẽ lại sẽ được tô và hiển thị màu xanh lá cây trên màn hình. Bạn có thể xem chi tiết hoạt động vẽ của browser bằng cách kích hoạt chế độ “Paint profiler” ở tab “Timeline” khi record. Ở chế độ này, bạn có thể kiểm tra quá trình vẽ của tất cả các element trong web page. Dựa vào các thông tin này bạn có thể phân tích và đưa ra hướng giải quyết phù hợp nếu quá trình paint mất quá nhiều thời gian. Một số yếu tố khiến quá trình paint diễn ra chậm: Các hiệu ứng CSS phức tạp: box-shadow, gradient, curves Các element chồng đè lên nhau. Các hình ảnh có kích thước quá lớn … 4.2. Sử dụng hợp lý các layerTrên thực tế, quá trình vẽ diễn ra song song trên nhiều các layer khác nhau, việc phân chia các layer hợp lý sẽ giúp tiết kiệm được thời gian vẽ rất nhiều. Ví dụ trong trường hợp này, khi bạn cuộn trang thì browser phải vẽ lại layer trên cùng (text), còn layer hình bên dưới có vị trí cố định, không có gì thay đổi nên không cần phải vẽ lại nữa. Các layer này sẽ được gộp lại (ở bước cuối cùng – composite) và hiển thị lên màn hình. Làm sao để tạo layer? Vẽ – Paint – là tác vụ nặng nhất, chiếm nhiều thời gian nhất trong các bước, do đó bạn có thể thấy rõ được lợi ích của việc phân chia các layer làm sao cho browser ít phải vẽ lại nhất. Một layer (compositor layer) sẽ được tạo khi bạn sử dụng thuộc tính will-change (trên Chrome, Opera, Firefox) thuộc tính này báo hiệu cho browser biết element sẽ có sự thay đổi, do đó sẽ đưa element này vào một layer mới. 1.moving-element &#123; will-change: transform; &#125; Đối với các browser không hỗ trợ will-change bạn có thể sử dụng thuộc tính 3D transform để “ép buộc” tạo layer mới: 1.moving-element &#123; transform: translateZ(0); &#125; Cần lưu ý, việc tạo layer mới sẽ yêu cầu thêm bộ nhớ và tác vụ để quản lý các layer, do đó bạn không nên tạo quá nhiều layer, và chiến lược tao layer ở đây không cố định mà còn tùy thuộc vào tính chất của các animation, transition có trên website của bạn. Không nên: (layer explosions – tạo ra quá nhiều layer không cần thiết) 1234* &#123; will-change: transform; transform: translateZ(0);&#125; Bước 5: CompositeTại bước này, browser sẽ tiến hành gộp các compositor layer đã được vẽ (ở bước 4) và hiển thị lên màn hình. Trường hợp lý tưởng nhất cho performance là bỏ qua 2 bước Layout và Paint, công việc của browser chỉ là thay đổi các compositor layer để tạo ra một frame. Để làm được điều đó, bạn chỉ được thay đổi các thuộc tính mà Compositor có thể xử lý độc lập (mà không cần phải kích hoạt Layout và Paint). Các thuộc tính đó là transform và opacity. Tuy nhiên trên thực tế chúng ta cần phải thay đổi nhiều thuộc tính hơn nữa để đáp ứng được yêu cầu khi animate các hiệu ứng. Do đó, giải pháp chính là phải tạo và quản lý được các layer một cách hợp lý. Để quản lý được các layer, bạn có thể sử dụng công cụ Chrome Developer Tools. Trong tab “Timeline” đánh dấu vào mục Paint Tiến hành record và chọn phần Paint trên kết quả hiển thị Ở đây bạn sẽ thấy thẻ “Layer” trong phần thông tin của frame Từ đây bạn có thể tra cứu toàn bộ các frame mà web page đang có. Danh sách các layer được liệt kê dưới dạng cây (layer tree), preview dạng 3D, có thông tin về kích thước, bộ nhớ, lý do layer được tạo… Tổng kếtNhư vậy là ta đã đi từng bước để có thể tối ưu hiệu suất render cho web page: JavaScript – Dùng requestAnimationFrame – Dùng Web workers, Micro-task cho tác vụ nặng – Profiling with Chrome DevTools Style – Giảm độ phức tạp của selector – Giảm số lượng element bị ảnh hưởng Layout – Hạn chế kích hoạt layout – Sử dụng Flexbox – Hạn chế forced synchronous layout. Paint – Paint là tác vụ xử lý lâu nhất – Box-shadow, large image không tốt cho paint – Tạo và quản lý layer hợp lý Composite – Sử dụng transform và opacity – Quản lý các layer bằng Chrome DevTools Sau khi đã thực hiện những bước trên, web page của bạn sẽ hoạt động mượt mà, trơn tru với 60fps. Chúc bạn thành công! 60FPS FOR THE WIN! Chuyện ngoài lềỞ Silicon Straits Saigon, chúng tôi có một bài test dành cho Front-end Developer, đó là implement hiệu ứng scrolling sau (ảnh động, load hơi lâu): http://bit.ly/1CCYx9y Các bạn có thể vận dụng những kiến thức có được trong bài viết này để “thử sức” với hiệu ứng trên. Đây là bài làm của tôi, mặc dù không được hoàn hảo nhưng có thể dùng được cho mục đích tham khảo. Link: http://trungdq88.github.io/css-stuffs/delay-scroll/ Timeline Record: Layers (một phần): Các nguồn tham khảo trong bài viết:Một số hình ảnh và code mẫu: Google Developer: https://developers.google.com/web/fundamentals/performance/ Preventing Layout Thrashing:http://wilsonpage.co.uk/preventing-layout-thrashing/ Các trang web có hiệu ứng đẹp: http://world.mathigon.org/ http://matthew.wagerfield.com/parallax/ Khóa học: Udacity Course: Browser Rendering Optimization – Building 60 FPS Web Apps: https://www.udacity.com/course/browser-rendering-optimization–ud860 Các nguồn khác: Web Workers: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage BEM: https://bem.info/ PostCSS: https://github.com/postcss/postcss CSS Trigger: http://csstriggers.com/ Guide to Flexbox: http://css-tricks.com/snippets/css/a-guide-to-flexbox/ FastDOM: https://github.com/wilsonpage/fastdom","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"10 câu hỏi phỏng vấn mà Javascript Developer nên biết","slug":"10-cau-hoi-phong-van-ma-Javascript-Developer-nen-biet","date":"2018-06-23T15:11:00.000Z","updated":"2018-06-23T15:28:47.131Z","comments":true,"path":"2018/06/10-cau-hoi-phong-van-ma-Javascript-Developer-nen-biet.html","link":"","permalink":"http://nthung2112.github.io/2018/06/10-cau-hoi-phong-van-ma-Javascript-Developer-nen-biet.html","excerpt":"Tại hầu hết các công ty, người quản lý phải tin tưởng các developers, cho họ tham gia các cuộc phỏng vấn kỹ thuật để đánh giá các kỹ năng ứng cử viên. Nếu bạn làm tốt như một ứng cử viên, bạn sẽ cần phải phỏng vấn. Đây là cách làm.","text":"Tại hầu hết các công ty, người quản lý phải tin tưởng các developers, cho họ tham gia các cuộc phỏng vấn kỹ thuật để đánh giá các kỹ năng ứng cử viên. Nếu bạn làm tốt như một ứng cử viên, bạn sẽ cần phải phỏng vấn. Đây là cách làm. It Starts With PeopleIn “How to Build a High Velocity Development Team”, Tôi đã nêu một vài điểm đáng để lặp lại: “Nothing predicts business outcomes better than an exceptional team. If you’re going to beat the odds, you need to invest here, first.” Như Marcus Lemonis đã nói, cần tập trung vào 3 P’s: “People, Process, Product” Your early hires should be very strong, senior-level candidates. People who can hire and mentor other developers, and help the mid-level and junior developers you’ll eventually want to hire down the road. Read “Why Hiring is So Hard in Tech” for a good breakdown of the general do’s and don’ts of candidate evaluation. The best way to evaluate a candidate is a pair programming exercise. Pair program with the candidate. Let the candidate drive. Watch and listen more than you talk. A good project might be to pull tweets from the Twitter API and display them on a timeline. That said, no single exercise will tell you everything you need to know. An interview can be a very useful tool as well, but don’t waste time asking about syntax or language quirks. You need to see the big picture. Ask about architecture and paradigms — the big decisions that can have a major impact on the whole project. Syntax and features are easy to Google. It’s much harder to Google for software engineering wisdom or the common paradigms and idioms JavaScript developers pick up with experience. JavaScript is special, and it plays a critical role in almost every large application. What is it about JavaScript that makes it meaningfully different from other languages? Here are some questions that will help you explore the stuff that really matters: 1. Can you name two programming paradigms important for JavaScript app developers?JavaScript is a multi-paradigm language, supporting imperative/procedural programming along with OOP (Object-Oriented Programming) and functional programming. JavaScript supports OOP with prototypal inheritance. Good to hear: Prototypal inheritance (also: prototypes, OLOO). Functional programming (also: closures, first class functions, lambdas). Red flags: No clue what a paradigm is, no mention of prototypal oo or functional programming. 2. What is functional programming?Functional programming produces programs by composing mathematical functions and avoids shared state &amp; mutable data. Lisp (specified in 1958) was among the first languages to support functional programming, and was heavily inspired by lambda calculus. Lisp and many Lisp family languages are still in common use today. Functional programming is an essential concept in JavaScript (one of the two pillars of JavaScript). Several common functional utilities were added to JavaScript in ES5. Good to hear: Pure functions / function purity. Avoid side-effects. Simple function composition. Examples of functional languages: Lisp, ML, Haskell, Erlang, Clojure, Elm, F Sharp, OCaml, etc… Mention of features that support FP: first-class functions, higher order functions, functions as arguments/values. Red flags: No mention of pure functions / avoiding side-effects. Unable to provide examples of functional programming languages. Unable to identify the features of JavaScript that enable FP. 3. What is the difference between classical inheritance and prototypal inheritance?Class Inheritance: instances inherit from classes (like a blueprint — a description of the class), and create sub-class relationships: hierarchical class taxonomies. Instances are typically instantiated via constructor functions with the new keyword. Class inheritance may or may not use the class keyword from ES6. Prototypal Inheritance: instances inherit directly from other objects. Instances are typically instantiated via factory functions or Object.create(). Instances may be composed from many different objects, allowing for easy selective inheritance. In JavaScript, prototypal inheritance is simpler &amp;more flexible than class inheritance. Good to hear: Classes: create tight coupling or hierarchies/taxonomies. Prototypes: mentions of concatenative inheritance, prototype delegation, functional inheritance, object composition. Red Flags: No preference for prototypal inheritance &amp; composition over class inheritance. 4. What are the pros and cons of functional programming vs object-oriented programming?OOP Pros: It’s easy to understand the basic concept of objects and easy to interpret the meaning of method calls. OOP tends to use an imperative style rather than a declarative style, which reads like a straight-forward set of instructions for the computer to follow. OOP Cons: OOP Typically depends on shared state. Objects and behaviors are typically tacked together on the same entity, which may be accessed at random by any number of functions with non-deterministic order, which may lead to undesirable behavior such as race conditions. FP Pros: Using the functional paradigm, programmers avoid any shared state or side-effects, which eliminates bugs caused by multiple functions competing for the same resources. With features such as the availability of point-free style (aka tacit programming), functions tend to be radically simplified and easily recomposed for more generally reusable code compared to OOP. FP also tends to favor declarative and denotational styles, which do not spell out step-by-step instructions for operations, but instead concentrate on what to do, letting the underlying functions take care of the how. This leaves tremendous latitude for refactoring and performance optimization, even allowing you to replace entire algorithms with more efficient ones with very little code change. (e.g., memoize, or use lazy evaluation in place of eager evaluation.) Computation that makes use of pure functions is also easy to scale across multiple processors, or across distributed computing clusters without fear of threading resource conflicts, race conditions, etc… FP Cons: Over exploitation of FP features such as point-free style and large compositions can potentially reduce readability because the resulting code is often more abstractly specified, more terse, and less concrete. More people are familiar with _OO_ and imperative programming than functional programming, so even common idioms in functional programming can be confusing to new team members. FP has a much steeper learning curve than OOP because the broad popularity of OOP has allowed the language and learning materials of OOP to become more conversational, whereas the language of FP tends to be much more academic and formal. FP concepts are frequently written about using idioms and notations from lambda calculus, algebras, and category theory, all of which requires a prior knowledge foundation in those domains to be understood. Good to hear: Mentions of trouble with shared state, different things competing for the same resources, etc… Awareness of FP’s capability to radically simplify many applications. Awareness of the differences in learning curves. Articulation of side-effects and how they impact program maintainability. Awareness that a highly functional codebase can have a steep learning curve. Awareness that a highly OOP codebase can be extremely resistant to change and very brittle compared to an equivalent FP codebase. Awareness that immutability gives rise to an extremely accessible and malleable program state history, allowing for the easy addition of features like infinite undo/redo, rewind/replay, time-travel debugging, and so on. Immutability can be achieved in either paradigm, but a proliferation of shared stateful objects complicates the implementation in OOP. Red flags: Unable to list disadvantages of one style or another — Anybody experienced with either style should have bumped up against some of the limitations. Learn More: The Two Pillars of JavaScript Part 1 — Prototypal OO. The Two Pillars of JavaScript Part 2 — Functional Programming. 5. When is classical inheritance an appropriate choice?The answer is never, or almost never. Certainly never more than one level. Multi-level class hierarchies are an anti-pattern. I’ve been issuing this challenge for years, and the only answers I’ve ever heard fall into one of several common misconceptions. More frequently, the challenge is met with silence. “If a feature is sometimes usefuland sometimes dangerousand if there is a better optionthen always use the better option.”~ Douglas Crockford Good to hear: Rarely, almost never, or never. A single level is sometimes OK, from a framework base-class such as React.Component. “Favor object composition over class inheritance.” 6. When is prototypal inheritance an appropriate choice?There is more than one type of prototypal inheritance: Delegation (i.e., the prototype chain). Concatenative (i.e. mixins, Object.assign()). Functional (Not to be confused with functional programming. A function used to create a closure for private state/encapsulation). Each type of prototypal inheritance has its own set of use-cases, but all of them are equally useful in their ability to enable composition, which creates has-a or uses-a or can-do relationships as opposed to the is-a relationship created with class inheritance. Good to hear: In situations where modules or functional programming don’t provide an obvious solution. When you need to compose objects from multiple sources. Any time you need inheritance. Red flags: No knowledge of when to use prototypes. No awareness of mixins or Object.assign(). 7. What does “favor object composition over class inheritance” mean?This is a quote from “Design Patterns: Elements of Reusable Object-Oriented Software”. It means that code reuse should be achieved by assembling smaller units of functionality into new objects instead of inheriting from classes and creating object taxonomies. In other words, use can-do, has-a, or uses-a relationships instead of is-a relationships. Good to hear: Avoid class hierarchies. Avoid brittle base class problem. Avoid tight coupling. Avoid rigid taxonomy (forced is-a relationships that are eventually wrong for new use cases). Avoid the gorilla banana problem (“what you wanted was a banana, what you got was a gorilla holding the banana, and the entire jungle”). Make code more flexible. Red Flags: Fail to mention any of the problems above. Fail to articulate the difference between composition and class inheritance, or the advantages of composition. 8. What are two-way data binding and one-way data flow, and how are they different?Two way data binding means that UI fields are bound to model data dynamically such that when a UI field changes, the model data changes with it and vice-versa. One way data flow means that the model is the single source of truth. Changes in the UI trigger messages that signal user intent to the model (or “store” in React). Only the model has the access to change the app’s state. The effect is that data always flows in a single direction, which makes it easier to understand. One way data flows are deterministic, whereas two-way binding can cause side-effects which are harder to follow and understand. Good to hear: React is the new canonical example of one-way data flow, so mentions of React are a good signal. Cycle.js is another popular implementation of uni-directional data flow. Angular is a popular framework which uses two-way binding. Red flags: No understanding of what either one means. Unable to articulate the difference. 9. What are the pros and cons of monolithic vs microservice architectures?A monolithic architecture means that your app is written as one cohesive unit of code whose components are designed to work together, sharing the same memory space and resources. A microservice architecture means that your app is made up of lots of smaller, independent applications capable of running in their own memory space and scaling independently from each other across potentially many separate machines. Monolithic Pros: The major advantage of the monolithic architecture is that most apps typically have a large number of cross-cutting concerns, such as logging, rate limiting, and security features such audit trails and DOS protection. When everything is running through the same app, it’s easy to hook up components to those cross-cutting concerns. There can also be performance advantages, since shared-memory access is faster than inter-process communication (IPC). Monolithic cons: Monolithic app services tend to get tightly coupled and entangled as the application evolves, making it difficult to isolate services for purposes such as independent scaling or code maintainability. Monolithic architectures are also much harder to understand, because there may be dependencies, side-effects, and magic which are not obvious when you’re looking at a particular service or controller. Microservice pros: Microservice architectures are typically better organized, since each microservice has a very specific job, and is not concerned with the jobs of other components. Decoupled services are also easier to recompose and reconfigure to serve the purposes of different apps (for example, serving both the web clients and public API). They can also have performance advantages depending on how they’re organized because it’s possible to isolate hot services and scale them independent of the rest of the app. Microservice cons: As you’re building a new microservice architecture, you’re likely to discover lots of cross-cutting concerns that you did not anticipate at design time. A monolithic app could establish shared magic helpers or middleware to handle such cross-cutting concerns without much effort. In a microservice architecture, you’ll either need to incur the overhead of separate modules for each cross-cutting concern, or encapsulate cross-cutting concerns in another service layer that all traffic gets routed through. Eventually, even monolthic architectures tend to route traffic through an outer service layer for cross-cutting concerns, but with a monolithic architecture, it’s possible to delay the cost of that work until the project is much more mature. Microservices are frequently deployed on their own virtual machines or containers, causing a proliferation of VM wrangling work. These tasks are frequently automated with container fleet management tools. Good to hear: Positive attitudes toward microservices, despite the higher initial cost vs monolthic apps. Aware that microservices tend to perform and scale better in the long run. Practical about microservices vs monolithic apps. Structure the app so that services are independent from each other at the code level, but easy to bundle together as a monolithic app in the beginning. Microservice overhead costs can be delayed until it becomes more practical to pay the price. Red flags: Unaware of the differences between monolithic and microservice architectures. Unaware or impractical about the additional overhead of microservices. Unaware of the additional performance overhead caused by IPC and network communication for microservices. Too negative about the drawbacks of microservices. Unable to articulate ways in which to decouple monolithic apps such that they’re easy to split into microservices when the time comes. Underestimates the advantage of independently scalable microservices. 10. What is asynchronous programming, and why is it important in JavaScript?Synchronous programming means that, barring conditionals and function calls, code is executed sequentially from top-to-bottom, blocking on long-running tasks such as network requests and disk I/O. Asynchronous programming means that the engine runs in an event loop. When a blocking operation is needed, the request is started, and the code keeps running without blocking for the result. When the response is ready, an interrupt is fired, which causes an event handler to be run, where the control flow continues. In this way, a single program thread can handle many concurrent operations. User interfaces are asynchronous by nature, and spend most of their time waiting for user input to interrupt the event loop and trigger event handlers. Node is asynchronous by default, meaning that the server works in much the same way, waiting in a loop for a network request, and accepting more incoming requests while the first one is being handled. This is important in JavaScript, because it is a very natural fit for user interface code, and very beneficial to performance on the server. Good to hear: An understanding of what blocking means, and the performance implications. An understanding of event handling, and why its important for UI code. Red flags: Unfamiliar with the terms asynchronous or synchronous. Unable to articulate performance implications or the relationship between asynchronous code and UI code. ConclusionStick to high-level topics. If they can answer these questions, that typically means that they have enough programming experience to pick up language quirks &amp; syntax in a few weeks, even if they don’t have a lot of JavaScript experience. Don’t disqualify candidates based on stuff that’s easy to learn (including classic CS-101 algorithms, or any type of puzzle problem). What you really need to know is, “does this candidate understand how to put an application together?” That’s it for the spoken interview. In real interviews, I place a much stronger emphasis on coding challenges and watching candidates code. Those topics are covered in depth in my “Master the JavaScript Interview” series.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Local Storage, Session Storage và Cookie","slug":"Local-Storage-Session-Storage-va-Cookie","date":"2018-06-23T11:40:00.000Z","updated":"2018-06-23T11:45:41.597Z","comments":true,"path":"2018/06/Local-Storage-Session-Storage-va-Cookie.html","link":"","permalink":"http://nthung2112.github.io/2018/06/Local-Storage-Session-Storage-va-Cookie.html","excerpt":"Sự khác nhau và cách sử dụng Local Storage, Session Storage và CookieBạn bị lẫn lộn giữa session storage, local storage và cookies? Bài viết dưới đây sẽ giúp bạn hiểu rõ được sự khác nhau giữa 3 cách lưu trữ này. Các kiểu không gian lưu trữ khác nhau có sẵn cho các dữ liệu có thể trên máy chủ hoặc máy khách, cho phép chúng ta chọn lựa theo nhu cầu.","text":"Sự khác nhau và cách sử dụng Local Storage, Session Storage và CookieBạn bị lẫn lộn giữa session storage, local storage và cookies? Bài viết dưới đây sẽ giúp bạn hiểu rõ được sự khác nhau giữa 3 cách lưu trữ này. Các kiểu không gian lưu trữ khác nhau có sẵn cho các dữ liệu có thể trên máy chủ hoặc máy khách, cho phép chúng ta chọn lựa theo nhu cầu. 1. Local storageGiới thiệu: Khả năng lưu trữ vô thời hạn: Có nghĩa là chỉ bị xóa bằng JavaScript, hoặc xóa bộ nhớ trình duyệt, hoặc xóa bằng localStorage API. Lưu trữ được 5MB: Local Storage cho phép bạn lưu trữ thông tin tương đối lớn lên đến 5MB, lưu được lượng thông tin lớn nhất trong 3 loại. Không gửi thông tin lên server như Cookie nên bảo mật tốt hơn. Trình duyệt hỗ trợ: Trình duyệt Phiên bản Chrome &gt;= 4.0 Internet Explorer / Edge &gt;= 8.0 Firefox &gt;= 3.5 Safari &gt;= 4.0 Chrome &gt;= 11.5 Để kiểm tra xem trình duyệt có hỗ trợ localStorage hay không thì chúng ta dùng typeof như sau: 12345678if (typeof(Storage) !== 'undefined') &#123; //Nếu có hỗ trợ //Thực hiện thao tác với Storage alert('Trình duyệt của bạn hỗ trợ Storage');&#125; else &#123; //Nếu không hỗ trợ alert('Trình duyệt của bạn không hỗ trợ Storage');&#125; Xem localStorage bằng trình duyệtĐể xem localstorage bằng trình duyệt các bạn vào trang web cần xem (ở đây mình ví dụ với trang web http://book.framgia.vn/) và sau đó các bạn ấn F12 (hoặc Ctrl + shift + i) sau đó làm theo như hình sau: Chọn tab Application, di chuyển đến Storage để thấy các Storage của trình duyệt. Để xem các local Storage đang được lưu trữ, mở rộng phần Local Storage như hình. Ở đây ta có thể thấy có 2 biến Local Storage đang được lưu là pusherTransportEncrypted và lang với giá trị của 2 biến được hiển thị bên cạnh (cột Value). Như vậy, cột Key chính là danh sách các biến local Storage đang được lưu và cột Value là các giá trị tương ứng. Để xóa hết các giá trị local Storage này đi, bạn có thể chọn biểu tượng cấm (Clear All) hoặc chọn bên cạnh là biểu tượng dấu X (Delete Selected). Sử dụng Khởi tạo localStorage 12345localStorage.setItem('key', 'value');// hoặclocalStorage.key = 'value';// hoặclocalStorage['key'] = 'value'; Trong đó: key là tên biến, value là giá trị của biến muốn gán vào. Để lấy giá trị localStorage và sử dụng, ta dùng getItem 123localStorage.getItem('key');// hoặclocalStorage.key; Ví dụ cụ thể như sau: Để lấy số lượng localStorage đã có trong trình duyệt, sử dụng length như sau: 1localStorage.length; Ví dụ 12345678if (typeof(Storage) !== \"undefined\") &#123; //Nếu hỗ trợ var data = localStorage.length; console.log(data);&#125; else &#123; // Nếu không hỗ trợ alert('Trình duyệt của bạn không hỗ trợ');&#125; Để xóa 1 biến trong localStorage, sử dụng removeItem(tên_key) 1localStorage.removeItem(key); Hoặc xóa tất cả các biến trong localStorage, sử dụng clear 1localStorage.clear(); 2. Session StorageGiới thiệu: Lưu trên Client: Cũng giống như localStorage thì sessionStorage cũng dùng để lưu trữ dữ liệu trên trình duyệt của khách truy cập (client). Mất dữ liệu khi đóng tab: Dữ liệu của sessionStorage sẽ mất khi bạn đóng trình duyệt. Dữ liệu không được gửi lên Server Thông tin lưu trữ nhiều hơn cookie (ít nhất 5MB) Trình duyệt hỗ trợ Trình duyệt Phiên bản Chrome &gt;= 5.0 Internet Explorer / Edge &gt;= 8.0 Firefox &gt;= 2 Safari &gt;= 4.0 Opera &gt;= 10.5 Vì sessionStorage cũng nằm trong gói Storage nên các bạn cũng có thể sử dụng lại đoạn code kiểm tra trình duyệt có hỗ trợ Storage hay không ở phía trên. Xem Session Storage bằng trình duyệtTương tự như localStorage, có thể chọn mở rộng mục Session Storage để xem các giá trị được lưu trữ. Sử dụngsessionStorage cũng có cú pháp và cách sử dụn các thuộc tính, phương thức như localStorage: 1234567891011121314if ( typeof(Storage) !== 'undefined') &#123; // Khởi tạo sesionStorage sessionStorage.setItem('name', 'Ted Mosby'); // get sessionStorage sessionStorage.getItem('name'); // lấy ra số lượng session đã lưu trữ sessionStorage.length; // xóa 1 item localStorage sessionStorage.removeItem('name'); // xóa tất cả item trong sessionStorage sessionStorage.clear();&#125; else &#123; alert('Trình duyệt của bạn không hỗ trợ!');&#125; 3. CookieGiới thiệu: Thông tin được gửi lên server: Cookie sẽ được truyền từ server tới browser và được lưu trữ trên máy tính của bạn khi bạn truy cập vào ứng dụng, mỗi khi người dùng tải ứng dụng, trình duyệt sẽ gửi cookie để thông báo cho ứng dụng về hoạt động trước đó của bạn. Vì vậy đừng bao giờ lưu trữ những thông tin quan trọng, yêu cầu tính bảo mật cao vào cookie vì nó hoàn toàn có thể bị sửa đổi và đánh cắp, thấp chí có thể lợi dụng điều này để tấn công website của bạn. Cookie chủ yếu là để đọc phía máy chủ (cũng có thể được đọc ở phía máy khách), localStorage và sessionStorage chỉ có thể được đọc ở phía máy khách. Có thời gian sống: Mỗi cookie thường có khoảng thời gian timeout nhất định do lập trình viên xác định trước. Lưu trữ: cho phép lưu trữ tối đa 4KB và vài chục cookie cho một domain. Xem cookie bằng trình duyệtTương tự như localStorage, có thể chọn mở rộng mục Cookies để xem các giá trị cookie được lưu trữ Sử dụngCookie có thể được tạo bằng nhiều cách, bài viết này sẽ trình bày về sử dụng cookie trong javascript. JavaScript có thể tạo, đọc, và xóa cookies với document.cookie. Tạo cookie: Javascript có thể tạo cookie như sau: 1document.cookie = 'username=Ted Mosby'; Chúng ta cũng có thể thêm vào ngày hết hạn cho cookie 1document.cookie = 'username=Ted Mosby; expires=Thu, 18 Dec 2018 8:00:00 UTC'; Hoặc đặt hẹn giờ sau bao lâu cookie sẽ hết hạn với max-age (tính bằng giây) 1document.cookie = 'username=Ted Mosby; max-age=9000'; Đọc cookie: 1var x = document.cookie; document.cookie sẽ trả lại tất cả cookie trong một chuỗi tring kiểu như: cookie1 = giá trị; cookie2 = giá trị; cookie3 = giá trị; Hoặc để lấy giá trị của 1 cookie, có thể viết một hàm như sau: 123456789101112131415function getCookie(cname) &#123; var name = cname + '='; var decodedCookie = decodeURIComponent(document.cookie); var ca = decodedCookie.split(';'); for(var i = 0; i &lt;ca.length; i++) &#123; var c = ca[i]; while (c.charAt(0) == ' ') &#123; c = c.substring(1); &#125; if (c.indexOf(name) == 0) &#123; return c.substring(name.length, c.length); &#125; &#125; return '';&#125; Tham số truyền vào là cname - tên cookie muốn lấy giá trị. Tạo một biến name và thêm vào “=” để tìm kiếm trong chuỗi document.cookie Chia document.cookie dựa trên dấu ; thành một mảng nhiều phần tử và gán mảng đấy cho biến ca Vòng lặp (i=0; i&lt;ca.length; i++) để đọc mỗi giá trị c = ca[i] Nếu cookie được tìm thấy (c.indexOf(name)==0), trả về giá trị của cookie (c.substring(name.length,c.length). Nếu cookie không được tìm thấy, trả về ‘’ Ví dụ muốn lấy giá trị của cookie tên là language thì ta có thể gọi getcookie(‘language’) và kêt quả trả về là giá trị của cookie có tên đó. 12var lang = getCookie('language');console.log(lang); Kết quả: Thay đổi giá trị cookie: Trong javascript, bạn có thể thay đổi một cookie giống như cách mà bạn tạo ra cookie, tức là ghi đè giá trị mới lên cookie đã có: 1document.cookie = \"username=Barney Stinson; expires=Wed, 26 Dec 2018 8:00:00 UTC\"; Kiểm tra cookie: Để kiểm tra coookie, có thể xây dựng hàm như sau: 1234567891011function checkCookie() &#123; var username = getCookie('username'); if (username != '') &#123; alert('Welcome again ' + username); &#125; else &#123; username = prompt('Please enter your name: ', ''); if (username != '' &amp;&amp; username != null) &#123; setCookie('username', username, 365); &#125; &#125;&#125; Nếu cookie được thiết lập, nó sẽ hiển thị một lời chào Nếu cookie không được thiết lập, nó sẽ hiển thị một prompt box, hỏi tên của người dùng, lưu trữ tên của người dùng ở cookie trong 365 ngày, bằng việc gọi function setCookie đã được viết ở trên Xóa cookie: Để xóa một cookie chỉ cần xét lại giá trị ngày hết hạn expires về một thời điểm đã qua 1document.cookie = 'username=; expires=Thu, 01 Jan 1970 00:00:00 UTC'; Tham khảo tại https://www.w3schools.com/js/js_cookies.asp 4. Thông tin thêm Vì localStorage và sessionStorage được lưu trữ trên trình duyệt của người dùng, nên các bạn cần phải xem xét nội dung lưu trữ có liên quan đến vấn đề bảo mật hay không. Và cũng chính vì localStorage và sessionStorage được lưu trữ trên trình duyệt nên việc sử dụng nó sẽ không ảnh hưởng đến hiệu xuất của trang web nhưng nó sẽ làm nặng trình duyệt của người dùng (không đáng kể). Về phạm vi: sessionStorage: giới hạn trong một cửa sổ hoăc thẻ của trình duyệt. Một trang web được mở trong hai thẻ của cùng một trình duyệt cũng không thể truy xuất dữ liệu lẫn nhau. Như vậy, khi bạn đóng trang web thì dữ liệu lưu trong sessionStorage hiện tại cũng bị xóa. Còn localStorage: có thể truy xuất lẫn nhau giữa các cửa sổ trình duyệt. Dữ liệu sẽ được lưu trữ không giới hạn thời gian.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"html5","slug":"html5","permalink":"http://nthung2112.github.io/tags/html5/"}]},{"title":"Load Javascript với async và defer","slug":"Load-Javascript-voi-async-va-defer","date":"2018-06-23T11:29:00.000Z","updated":"2018-06-23T11:37:52.865Z","comments":true,"path":"2018/06/Load-Javascript-voi-async-va-defer.html","link":"","permalink":"http://nthung2112.github.io/2018/06/Load-Javascript-voi-async-va-defer.html","excerpt":"Vấn đềJavascript là 1 trong những tài nguyên chặn trang, có nghĩa là việc hiển thị HTML có thể bị chặn hay làm chậm bởi Javascript. Khi parser đọc đến &lt;script&gt; tag, bất kể là inline hay là external file, quá trình parse sẽ tạm dừng để fetch script đó về và execute. Việc này có thể là vấn đề nếu chúng ta load nhiều file Javascript trên trang, làm tăng thời gian load trang mặc dù có thể việc hiển thị html ở trang không thực sự phụ thuộc vào những file javascript đó. Và may mắn thay, thẻ &lt;script&gt; có 2 thuộc tính, đó là async và defer, cho phép chúng ta kiểm soát và load những file này theo ý muốn, tránh chặn quá trình load trang.","text":"Vấn đềJavascript là 1 trong những tài nguyên chặn trang, có nghĩa là việc hiển thị HTML có thể bị chặn hay làm chậm bởi Javascript. Khi parser đọc đến &lt;script&gt; tag, bất kể là inline hay là external file, quá trình parse sẽ tạm dừng để fetch script đó về và execute. Việc này có thể là vấn đề nếu chúng ta load nhiều file Javascript trên trang, làm tăng thời gian load trang mặc dù có thể việc hiển thị html ở trang không thực sự phụ thuộc vào những file javascript đó. Và may mắn thay, thẻ &lt;script&gt; có 2 thuộc tính, đó là async và defer, cho phép chúng ta kiểm soát và load những file này theo ý muốn, tránh chặn quá trình load trang. Mô tả cách thực thi &lt;script&gt;12345678&lt;html&gt; &lt;head&gt; ... &lt;/head&gt;&lt;body&gt; ... &lt;script src=\"script.js\" /&gt; ....&lt;/body&gt;&lt;/html&gt; Với thẻ script không có thuộc tính gì khác thì HTML file sẽ được parse cho đến khi gặp phải thẻ script, đến lúc này thì quá trình parse sẽ tạm dùng và để fetch script file về (nếu là external file), sau đó execute những code script này, sau đó mới tiếp tục lại quá trình parse html &lt;script async&gt;1&lt;script async src=\"script.js\" /&gt; Với thẻ script có thuộc tính async, khi quá trình parse html gặp phải script này, nó sẽ vẫn tiếp tục parse html cho đến khi script này được download xong, thì quá trình parse html mới tạm dừng để execute những code script này, sau đó lại tiếp tiếp quá trình parse html &lt;script defer&gt;1&lt;script defer src=\"script.js\" /&gt; Với thẻ script có thuộc tính defer, quá trình parse html sẽ không bị dừng lại mà parse cho đến khi hoàn thành, quá trình download các script file được tiến hành song song, và cuối cùng thì sẽ execute những script code này khi html đã parse xong. Vậy nên dùng khi nào?Nó phụ thuộc vào từng tình huống cụ thể. Quy tắc như sau: Nếu script là 1 module tách biệt, không phụ thuộc vào script nào khác thì nên sử dụng async cho load và execute với trang luôn Nếu script phụ thuộc vào script khác, hoặc bị script khác phụ thuộc, thì nên dùng defer, để load và execute theo thứ tự Nếu script nhỏ và các script khác phụ thuộc vào nó, thì cho load inline và không cần async hay defer Ngoài ra nên cân nhắc 1 số câu hỏi trước khi thêm các thuộc tính này1. Thẻ script đang nằm ở đâu trong trangAsync và defer có thể rất cần thiết nếu thẻ script không nằm ở cuối trang. HMTL document được parse theo thứ tự, từ thẻ mở cho đến thẻ đóng . Nếu script năm ngay gần cuối thẻ đóng thì việc sử dụng async hay defer thì cũng không có ý nghĩa lắm bởi vì việc parse html đã gần xong xuôi, và javascript không còn block gì html nữa. 2. Script đó có độc lập không?Với những file script không phụ thuộc vào những file khác, thì thuộc tính async dùng cho script đó là việc nên làm, vì nó load và execute script song song, giảm thời gian tải trang, kết quả cuối cùng nhanh hơn. 3. Script có yêu cầu việc load DOM xong mới thực hiện?Trong nhiều trường hợp, các script chứa đựng code tương tác với DOM, hoặc phụ thuộc vào các thành phần trên trang, yêu cầu trang phải parse xong thì mới execute script. Thông thường thì những file như thế sẽ được đặt ở cuối trang để chắc chắn mọi thử đã được parse. Tuy nhiên chúng ta có thể dùng thuộc tính defer thay thế, đảm bảo script sẽ được execute khi trang đã tải xong. 4.Script nhỏ và các file khác phụ thuộc vào nó?Nếu script dung lượng nhỏ, và các file khác phụ thuộc vào nó, thì nên để script đó inline. Mặc dù nó block quá trình parse HTML, nhưng nó không đáng kể vì dung lượng nhỏ. Lợi íchVới việc biết cách sử dụng các thuộc tính async, defer hợp lí thì tốc độ load trang sẽ được cải thiện hơn, mang lại cảm giác thích thú cho người dùng. Vì vậy nó giúp tối ưu SEO, giúp tăng điểm Google Page Speed (https://developers.google.com/speed/pagespeed/insights)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Functional Programming - Phần 3 - Buông bỏ","slug":"Functional-Programming-Phan-3-Buong-bo","date":"2018-06-20T08:46:00.000Z","updated":"2018-06-23T08:54:01.269Z","comments":true,"path":"2018/06/Functional-Programming-Phan-3-Buong-bo.html","link":"","permalink":"http://nthung2112.github.io/2018/06/Functional-Programming-Phan-3-Buong-bo.html","excerpt":"Functional Programming là một con đường khác, một phương pháp tư duy khác trong coding. Ở tầm nhìn trừu tượng hơn, người ta xếp Functional Programming vào nhóm “Declarative”, còn OOP thuộc nhóm “Imperative”. Từ các bài học ngữ pháp chúng ta đã biết 2 kiểu câu: câu trần thuật (Declarative Sentence), và câu mệnh lệnh (Imperative Sentence). Lập trình theo lối “Imperative Programming” là sắp xếp một loạt các mệnh lệnh liên tiếp, để máy tính thực thi tuần tự từng bước. Ở đây người ta tập trung vào “how”. Nào, hãy làm thế này, rồi làm thế kia… Một hình thức “cầm tay chỉ việc”.","text":"Functional Programming là một con đường khác, một phương pháp tư duy khác trong coding. Ở tầm nhìn trừu tượng hơn, người ta xếp Functional Programming vào nhóm “Declarative”, còn OOP thuộc nhóm “Imperative”. Từ các bài học ngữ pháp chúng ta đã biết 2 kiểu câu: câu trần thuật (Declarative Sentence), và câu mệnh lệnh (Imperative Sentence). Lập trình theo lối “Imperative Programming” là sắp xếp một loạt các mệnh lệnh liên tiếp, để máy tính thực thi tuần tự từng bước. Ở đây người ta tập trung vào “how”. Nào, hãy làm thế này, rồi làm thế kia… Một hình thức “cầm tay chỉ việc”.Ví dụ trên trang web có 4 boxes màu đỏ thế này: 12345678910111213141516&lt;style&gt;.box &#123; width: 100px; height: 100px; float: left; margin: 10px; background-color: red;&#125;.hide &#123; display: none;&#125;&lt;/style&gt;&lt;div class=\"box hide\"&gt;&lt;/div&gt;&lt;div class=\"box hide\"&gt;&lt;/div&gt;&lt;div class=\"box hide\"&gt;&lt;/div&gt;&lt;div class=\"box hide\"&gt;&lt;/div&gt; Mấy boxes này đang ẩn, ta cần làm chúng hiện ra bằng cách loại bỏ class “hide” đi. Các giáo viên tin học đáng kính ở trường xưa thường dạy viết kiểu như thế này: 1234567891011// tìm hết các tags có class \"box':const els = document.querySelectorAll('.box');// quét tất cả các tags tìm thấyfor (let i = 0; i &lt; els.length; i++) &#123; // với tag thứ i let el = els[i]; // xóa bỏ class \"hide\" để cho tag hiện lên el.classList.remove('hide'); // nếu còn phần tử phía sau thì tăng i lên 1 đơn vị // quay lại với xử lý tag thứ i + 1&#125; Họ dùng code hướng dẫn cho máy tính làm từng nhiệm vụ. Người tu luyện Functional Programming không tư duy theo cách đó. No for/while“Declarative Programming” là tập trung vào “what”. Chúng ta chỉ cần định nghĩa những quy tắc đầu vào, đầu ra. Chẳng hạn “nếu input là 1 thì output là 2”. Phần còn lại để máy tính xử lý. Người tu luyện Functional Programming không cần for loop. Code như thế này nhìn mới mẻ hơn nhiều: 12345678910111213141516const getElements = (selector) =&gt; &#123; return Array.from(document.querySelectorAll(selector));&#125;;const getRemover = (el) =&gt; &#123; return (className) =&gt; &#123; el.classList.remove(className); return el; &#125;;&#125;;const els = getElements('.box') .map(getRemover) .map(removeClass =&gt; removeClass('hide'));console.log(els); Trước tiên chúng ta tạo ra 1 pure function getElements dùng để lấy các elements trên trang thông qua CSS Selector. Tập hợp này vốn là ArrayLike, ta dùng Array.from chuyển thành Array thực sự để có thể tận dụng các phương thức trong Array prototype. Ở đây ta định nghĩa input là CSS Selector, output là 1 mảng DOM Elements. Còn getRemover lại là 1 higher-order function. Có thể gọi nó bằng cách chaining getRemover(DOMElement)(classToRemove). Chúng ta lợi dụng đặc tính của higher-order function, sau 2 lần map thì chạm tới function do getRemover ném lại. Ở đây ta định nghĩa input là DOM Element, output là function() {nhận input là className và output là DOM Element đã mất đi class đó}. Code như vậy ta có thể đem logic dùng lại ở nhiều chỗ khác nhau, chỉ cần thay đổi input. Ví dụ loại bỏ class float-left khỏi tất cả các thẻ div. 123const els = getElements('div') .map(getRemover) .map(removeClass =&gt; removeClass('float-left')); No if/elseNgười tu luyện Functional Programming cũng không cần if/else. Thậm chí họ còn tạo ra cả một chiến dịch Anti-IF! Có nhiều cách để loại bỏ hoàn toàn if/else ra khỏi chương trình của bạn. Đơn giản nhất là dùng ternary. TernaryTrong JavaScript, ternary - tam phân - có tên gọi chính thức là Toán tử Điều kiện - Conditional Operator. Nó là cách viết ngắn gọn của if/else. Hãy xem đoạn code dài dòng, rẽ nhánh phức tạp như sau: 12345678let title = 'Mr.';if (person.gender === 'female') &#123; if (!person.gotMarried) &#123; title = 'Ms.'; &#125; else &#123; title = 'Mrs.'; &#125;&#125; Có thể được viết gọn lại thành: 1const title = person.gender === 'female' ? (!person.gotMarried ? 'Ms.' : 'Mrs.') : 'Mr.'; Không còn if/else nữa. Ta cũng vô hình trung loại bỏ được var, let vì không cần gán lại giá trị cho title. Logical operatorsCách thứ 2 là khai thác sức mạnh ngầm của các logical operators &amp;&amp;, ||. Đây là những toán tử logic. Hôm trước có bạn viết 1 cái TIL ngắn khá hay. Sau đây ta quan sát chúng kỹ hơn qua lăng kính Functional Programming. Giả sử có đoạn code như sau: 1234567891011121314151617181920const sayHello = () =&gt; &#123; console.log('Hello, bonjour, nihao'); return true;&#125;;const doNothing = () =&gt; &#123; console.log('Do nothing'); return false;&#125;;const greet = (hasClient) =&gt; &#123; if (hasClient) &#123; sayHello(); &#125; else &#123; doNothing(); &#125;&#125;greet(true); // =&gt; 'Hello, bonjour, nihao'greet(false); //=&gt; 'Do nothing' Về mặt logic, hàm greet() kiểm tra điều kiện nếu có khách thì chào, nếu không thì không làm gì cả. Theo định nghĩa của &amp;&amp; và ||, chúng ta biết: expr1 &amp;&amp; expr2 trả về expr1 nếu expr1 là falsy, ngoài ra nó trả về expr2. Một điều thú vị ở đây là JavaScript engine luôn ước lượng giá trị biểu thức logic dạng này từ trái sang phải và theo nguyên tắc “đoản mạch” - short-circuit evaluation“. Tiên hữu nào giỏi Vật lý chắc còn nhớ hiện tượng “đoản mạch”, đó là khi dòng điện không chạy qua tải hoặc chỉ chạy qua một phần. Vì AND chỉ trả về true nếu cả 2 mệnh đề cùng đúng, nên ngay khi bắt gặp expr1 sai, nó lập tức kết luận mệnh đề ghép là Sai và chấm dứt tại đó luôn, không chạy qua nửa bên phải expr2 nữa. expr1 || expr2 trả về expr1 nếu expr1 là truthy, ngoài ra nó trả về expr2. Vì OR trả về true nếu ít nhất 1 mệnh đề đúng, nên ngay khi bắt gặp expr1 đúng, nó lập tức kết luận mệnh đề ghép là Đúng và bỏ qua expr2. Short-circuit thần thánh! Các lập trình viên kinh nghiệm thường lợi dụng đặc điểm này để tối ưu hiệu suất chương trình. Họ để các biểu thức tính toán phức tạp ở nửa sau của biểu thức logic. Như vậy, khi chưa rơi vào hoàn cảnh thích hợp, chúng sẽ bị bỏ qua, không cần tốn resource xử lý. Tới đây, ta đã có thể viết lại hàm greet() một cách bí hiểm như sau: 123const greet = (hasClient) =&gt; &#123; return (hasClient || doNothing()) &amp;&amp; sayHello();&#125; Bắt đầu phần nằm trong ngoặc đơn bên trái &amp;&amp;. Nếu hasClient là true thì giá trị phần này cũng là true, doNothing() bị bỏ qua. Vì phần bên trái của &amp;&amp; là true nên cuối cùng, giá trị biểu thức quy về phần bên phải &amp;&amp;, tức là sayHello(). Lập luận tương tự cho trường hợp hasClient là false, dòng chảy chương trình lập tức rẽ sang doNothing(). Lúc này giá trị nửa bên trái &amp;&amp; là false, do đó không cần quan tâm đến sayHello() nữa. Viết như trên vừa độc vừa lạ, vừa khử được if/else, mà vẫn hoàn toàn ăn khớp với điều kiện quy ước. Tuy nhiên, logical operators nếu nhìn không quen thì có vẻ hơi khó hình dung mạch suy diễn của chương trình. Tôi chỉ đưa ra đây để các tin hữu tham khảo. Trong dự án thực tế, vẫn nên dùng ternary cho đỡ hại não đồng đội: 123const greet = (hasClient) =&gt; &#123; return hasClient ? sayHello() : doNothing();&#125; Logical functionsMột cách tiếp cận khác thể hiện tinh thần Functional Programming quyết liệt hơn, đó là tạo ra các hàm đặc trách nhiệm vụ xử lý logic. Ví dụ trong Ramda.js và Sanctuary đều có ifElse , unless , when, và hàng chục hàm logic khác. Hàm greet nếu viết lại với Ramda sẽ trở nên xinh xắn như thế này: 123const R = require('ramda');const greet = R.ifElse(R.identity, sayHello, doNothing); Đó là vẻ đẹp đầy tính nghệ thuật của Function Composition. Bạn cứ ngắm nhìn nó và đừng nói gì cả! Composition cũng có nghĩa là tác phẩm, như thơ của Paul Verlaine hay nhạc của Beethoven. No new/thisCó 2 thứ luôn khiến Brendan Eich cảm thấy hài lòng khi kể về lịch sử JavaScript, đó là first-class function và prototype mechanism. Ngày nay, hầu hết developer đều biết rằng thừa kế trong JavaScript là prototype-based inheritance. Nhưng ở thời kỳ web còn hoang sơ, người ta hay dùng new và các hàm constructors để lập trình OOP trong JavaScript theo kiểu class-based, giống như bên Java vẫn làm. Classical inheritanceCổ thư ghi lại rất nhiều ví dụ kiểu này: 123456789101112function Dog(name) &#123; this.name = name; this.say = function() &#123; console.log('woof-woof, my name is ' + this.name); &#125;&#125;var rocky = new Dog('Rocky');rocky.say();var molly = new Dog('Molly');molly.say(); Hàm Dog gọi là Function Constructor, các tiền bối chân giới Đại Việt thủa trước chuyển ngữ thành “hàm dựng”. Còn chúng ta thời nay có lẽ cứ nên giữ nguyên văn. Prototypal inheritanceSang đầu kỷ thứ 3, ở tông môn Yahoo! có một vị trưởng lão tu vi rất cao thâm tên là Douglas Crockford tung ra bộ kỳ thư “JavaScript: The Good Parts”, trong đó có đoạn nhấn mạnh bản chất prototype trong JavaScript, sự khác biệt giữa classical inheritance và prototypal inheritance. Ông cho rằng từ khóa new mang theo nhiều điểm bất cập, nên khuyến khích dùng Object.create để sao chép nguyên mẫu sang đối tượng kế thừa. Tư tưởng của Douglas Crockford quả thực mới mẻ. Vào lúc đó, nhiều JavaScript engine còn chưa kịp hỗ trợ Object.create. Cuốn này vừa ra mắt đã gây náo loạn cả tin giới, trở thành sách gối đầu giường của rất nhiều tu sĩ. Object.create cho phép sao chép các properties hoặc protoype của đối tượng. Hàm Dog có thể được viết lại theo hướng prototypal inheritance như thế này: 1234567891011121314function Dog() &#123;&#125;Dog.prototype.say = function() &#123; console.log('woof-woof, my name is ' + this.name);&#125;var rocky = Object.create(Dog.prototype);rocky.name = 'Rocky';var molly = Object.create(Dog.prototype);molly.name = 'Molly';rocky.say();molly.say(); Không cần new nữa! Các cường giả sau đó nhanh chóng phát triển thêm nhiều cách tiếp cận prototypal inheritance khác, nổi bật nhất phải kể đến Concatenative inheritance, Prototype delegation và Functional inheritance. ES6 Class ngày nay chỉ vay mượn syntax của classical OOP để làm interface, còn bên trong nó chính là cơ chế prototypal inheritance. Object CompositionNhưng dù sao prototypal inheritance vẫn thuộc về OOP. Người tu luyện Functional Programming không cần new. Gần 10 năm sau bom tấn “The Good Parts”, Douglas Crockford lại một lần nữa khiến tin giới chấn động bằng “JavaScript: The Better Parts”. Thời điểm này, ông đã không còn dùng Object.create() nữa, cũng từ bỏ luôn this, for loops, for in, while… Tu vi của ông đã tiến thêm một bước lớn. Trong clip, ông nói về những tính năng mới của ES6 lúc ấy vẫn còn chưa chính thức xuất xưởng. Mấy lão quái kiệt này luôn đi trước thiên hạ vài năm. Đó cũng là khi trào lưu Functional Programming đang dần nóng trở lại, người ta bắt đầu nhắc đến khái niệm Object Composition. Đi cặp với new là this. Từ khóa this chẳng qua chỉ là kỹ xảo nhằm tạo ra một ngữ cảnh khu biệt (context) để thực thi các hàm. Trong JavaScript, mỗi hàm như 1 kết giới độc lập. Function khi được gắn lên object thì gọi là method. Ngữ cảnh method đó chạy thường chính là đối tượng sở hữu nó. Sau này mới sinh ra các thủ thuật bind, apply, call để đánh tráo context. Với những người mới học JavaScript, this đôi khi trở thành nỗi khiếp sợ. Rất khó debug các vấn đề phát sinh trong hàm nếu không biết chính xác ngữ cảnh chạy nó. Mà ngữ cảnh lại thường không ổn định. Đúng hơn, phải nói rằng chúng luôn luôn mutable. Người tu luyện Functional Programming không cần this. Đoạn code với classical OOP trên kia có thể viết lại thành: 12345678910111213141516171819202122const sayName = (state) =&gt; &#123; return Object.assign( state, &#123; say: () =&gt; &#123; console.log(`woof-woof, my name is $&#123;state.name&#125;`); &#125;, &#125; );&#125;;const createDog = (name) =&gt; &#123; let state = &#123; name, &#125;; return Object.assign(state, sayName(state));&#125;;const rocky = createDog('Rocky');rocky.say();const molly = createDog('Molly');molly.say(); Nhìn đâu cũng thấy functions. Không còn for/while, if/else, new/this. Liệu bạn đã sẵn sàng rời khỏi những phàm vật ấy? Hay nói như các nhà sư, liệu bạn có thể buông bỏ? Khi lối tư duy truyền thống đã ăn sâu vào tâm trí, hễ gặp vấn đề phân cấp đối tượng thì chúng ta sẽ nghĩ ngay đến OOP, class, prototype, inheritance… thậm chí coi chúng như giải pháp tất yếu, duy nhất. Hễ xử lý tập hợp là phải looping, hễ thấy có điều kiện thì chỉ biết dựa vào if… Đây là trở ngại rất lớn cho kẻ mới nhập đạo. Phải tìm cách rũ bỏ những thứ không cần thiết, thì mới đi xa được. Rời khỏi chúng, chỉ giữ lại một ý niệm duy nhất: FUNCTION! Nhất niệm “phân sần”! Ban đầu tất nhiên là sẽ khó khăn, lúng túng. Giống như hàng ngày bạn vẫn đi trên con đường quen thuộc từ nhà đến công sở rồi lại trở về nhà. Cho đến một hôm con đường đó bị cảnh sát chặn lại, bạn đành phải rẽ sang lối khác. Trên con đường xa lạ ấy, bạn không còn trông thấy những điểm mốc hàng ngày vẫn thấy: 1 shop lưu niệm, 1 cây xăng, 1 tiệm cầm đồ, sau ngã tư là đến ven sông, cây cầu sơn màu đỏ, một tiệm tạp hóa thường có cô em rất xinh ngồi trước cửa… Bạn không còn bắt gặp những dấu hiệu đã quen mắt. Bạn chẳng biết mình đã đi đến đâu, còn cách nhà bao nhiêu km nữa. Nhưng con đường nào đi lại vài lần thì cũng thành quen. Chẳng có gì đáng ngại. Vấn đề là, ngay khi bạn nhận thấy Functional Programming là thứ gì đó rất thú vị, đáng để học hỏi, vận dụng nó, bạn nên thực hiện ngay lập tức, đừng chờ đợi dịp nào thuận tiện, đừng chờ tìm được minh sư dẫn dắt. Nếu vậy, bạn sẽ khó mà rời khỏi lối mòn xưa cũ. Krishnamurti từng diễn giải một điều gần tương tự, đại ý thế này: Nếu bạn đi về hướng Bắc suốt những ngày tháng của cuộc đời bạn, giống như con người đã đi theo một hướng đặc biệt, rồi có người nào đó xuất hiện và nói, “Hướng đó không đúng”. Sau đó ông ta bảo bạn, “Đi về hướng Nam, hướng Đông, bất kỳ hướng nào, ngoại trừ hướng đó.” Và khi bạn thực sự chuyển động khỏi hướng đó, có một sự thay đổi ngay tại chính những tế bào não bởi vì bạn đã phá vỡ cái khuôn mẫu. Và cái khuôn mẫu đó phải được phá vỡ ngay lúc này, không phải bốn mươi năm hay một trăm năm sau.","categories":[],"tags":[{"name":"functional programming","slug":"functional-programming","permalink":"http://nthung2112.github.io/tags/functional-programming/"}]},{"title":"Functional Programming - Phần 2 - Nhập đạo","slug":"Functional-Programming-Phan-2-Nhap-dao","date":"2018-06-16T08:43:00.000Z","updated":"2018-06-23T08:53:54.125Z","comments":true,"path":"2018/06/Functional-Programming-Phan-2-Nhap-dao.html","link":"","permalink":"http://nthung2112.github.io/2018/06/Functional-Programming-Phan-2-Nhap-dao.html","excerpt":"Như vậy, Functional Programming là nghệ thuật lập trình trong đó ta: sử dụng functions để điều khiển workflow tuân thủ 2 nguyên tắc immutability và purity Nói cách khác, chư vị tin hữu muốn tu luyện Functional Programming thì phải giữ đạo tâm trong sáng, ý chí kiên định, hàng ngày chiêm nghiệm, suy diễn, cảm ngộ function, tu vi theo đó sẽ không ngừng thăng tiến. Nhưng làm thế nào để cảm ngộ “phân sần ý cảnh”? Ta phải nắm bắt, quan sát, tư duy, suy tưởng về function ra sao? Sau đây là những pháp quyết nhập môn.","text":"Như vậy, Functional Programming là nghệ thuật lập trình trong đó ta: sử dụng functions để điều khiển workflow tuân thủ 2 nguyên tắc immutability và purity Nói cách khác, chư vị tin hữu muốn tu luyện Functional Programming thì phải giữ đạo tâm trong sáng, ý chí kiên định, hàng ngày chiêm nghiệm, suy diễn, cảm ngộ function, tu vi theo đó sẽ không ngừng thăng tiến. Nhưng làm thế nào để cảm ngộ “phân sần ý cảnh”? Ta phải nắm bắt, quan sát, tư duy, suy tưởng về function ra sao? Sau đây là những pháp quyết nhập môn. Higher-order functionHigher-order function là một khái niệm đến từ Toán học. Bất cứ hàm nào tiếp nhận 1 function như tham số, hoặc trả về 1 function như kết quả, thì đều được coi là higher-order function. Dưới đây là 1 ví dụ, hàm getItem nhận vào hàm by mô tả điều kiện, lại trả về 1 hàm khác. Nó thừa tiêu chuẩn để gọi là higher-order function. 12345678const getItem = by =&gt; arr =&gt; by;// hoặc phiên bản chi tiếtconst getItem = (by) =&gt; &#123; return (arr) =&gt; &#123; return by(arr); &#125;;&#125;; Lập trình phong cách Functional Programming là khiêu vũ với các functions. Trong Functional Programming, hầu như mọi functions đều là higher-order function, vì chúng đều có thể nhận vào và ném ra các functions. Nhưng như vậy thì có lợi ích gì? Nó đơn giản cung cấp cho ta một cách khác để lập luận và suy diễn. Chẳng hạn như với hàm getItem trên kia cho phép bạn biến hóa rất nhiều dạng, tùy vào cách bạn thao túng by. Khi bạn viết getItem, bạn không cần biết sau này sẽ phải kiểm tra điều kiện ra sao, cũng không quan tâm sẽ nhận được đầu vào như thế nào. Bạn có thể tạo ra hàm tìm số lớn nhất trong 1 mảng toàn số như sau: 1234567891011// tạo hàm engine lấy max number từ mảngconst maxNumber = (arr) =&gt; &#123; return Math.max(...arr);&#125;;// rồi truyền vào getItem để được hàm cần thiếtconst getMaxNumber = getItem(maxNumber);// thử xem saogetMaxNumber([4, 6, 2, 3, 1, 8, 7, 5]);// =&gt; 8 Thế sao không truyền thẳng cái mảng số kia vào maxNumber cho khỏe? Vì trong thiết kế này ta đang cư xử với maxNumber như plugin. Còn nhiều plugins khác nữa. Ta không gọi trực tiếp plugin mà gọi qua 1 giao diện tổng quát hơn. Giờ ta lại có dữ liệu 1 nhóm người như sau: 12345678910111213141516171819202122const members = [ &#123; name: 'Alice', height: 165, &#125;, &#123; name: 'Bob', height: 152, &#125;, &#123; name: 'Celina', height: 178, &#125;, &#123; name: 'Dan', height: 194, &#125;, &#123; name: 'Eric', height: 187, &#125;,]; Ta muốn tìm người cao nhất trong nhóm thì sao? Hãy thêm 1 plugin khác. 12345678910111213// bạn tạo 1 hàm engine lấy max height từ mảngconst maxHeight = (people) =&gt; &#123; return people.reduce((prev, current) =&gt; &#123; return prev.height &gt; current.height ? prev : current; &#125;);&#125;;// rồi truyền vào getItem để được hàm cần thiếtconst getTallestPerson = getItem(maxHeight);// thử xem saogetTallestPerson(members);// =&gt; &#123; name: 'Dan', height: 194 &#125; Ví dụ trên tuy tầm thường, nhưng có thể là gợi ý tốt để bạn dùng higher-order function thiết kế những chương trình linh hoạt, dễ mở rộng. Function CompositionĐây là khái niệm Toán học mà tiếng Việt ta gọi là “hàm hợp”, hay “hàm phức hợp”. Mọi thứ trong Functional Programming đều có nguồn gốc Toán học. Function Composition là sự phối hợp, liên kết nhiều hàm lại với nhau, thành một hàm lớn, nhiều chức năng hơn. Có 2 kỹ thuật căn bản trong Function Composition là compose và pipe. ComposeHãy nhớ lại, trong không gian Functional Programming tồn tại vô số pure functions nhỏ gọn, đơn giản. Đúng triết lý “do one thing and do it well” của UNIX. Vì mỗi hàm chỉ làm 1 việc, khi muốn thực hiện nhiều hành động lên cùng một input, ta chỉ việc kết hợp các hàm cần thiết lại với nhau. Bây giờ chúng ta hãy tạm ngừng tu luyện, tạm quên tu vi để nhập phàm, quan sát và cảm ngộ nhân sinh. Lần này, bạn hóa thành con trai thứ 4 trong gia đình một thôn dân sinh sống dưới chân núi Tản Viên bằng nghề bán thịt… Một hôm bạn xin được khúc cây lớn ở chỗ ông chú làm kiểm lâm kiêm lâm tặc. Từ khúc gỗ này, bạn muốn làm ra cái thớt cho nhà dùng. Là tu sĩ mới nhập môn tu luyện Functional Programming, tuy không có tu vi, nhưng bạn vẫn hình dung được sẽ cần đến các pure functions sau: cưa(): nhận vào khúc gỗ, trả về từng khoanh tròn sấy(): nhận khoanh gỗ tươi, trả về khoanh gỗ khô bào(): nhận vào khoanh gỗ, trả về khoanh gỗ bằng phẳng khoan(): nhận vào khoanh gỗ, trả về khoanh gỗ có 2 lỗ (để gắn quai treo/móc lên cho gọn) chà(): nhận vào khoanh gỗ, trả về khoanh gỗ trơn láng (dùng giấy nhám, miền ngoài gọi giấy giáp, để đánh cho nhẵn bề mặt) móc(): nhận thớt không quai, trả về thớt có quai Mỗi hàm chỉ làm đúng 1 việc. Không hơn. Không kém. Khi đi qua chừng đó công đoạn, ta sẽ được sản phẩm mong muốn. Dĩ nhiên chúng ta đang muốn khúc gỗ được sửa đổi nên tạm bỏ qua vấn đề immutability. Đây là phiên bản mô phỏng: 1234567891011121314151617181920212223const cưa = (x) =&gt; &#123; return `$&#123;x&#125; đã cưa`;&#125;;const sấy = (x) =&gt; &#123; return `$&#123;x&#125; đã sấy`;&#125;;const bào = (x) =&gt; &#123; return `$&#123;x&#125; đã bào`;&#125;;const khoan = (x) =&gt; &#123; return `$&#123;x&#125; đã khoan`;&#125;;const chà = (x) =&gt; &#123; return `$&#123;x&#125; đã chà`;&#125;;const móc = (x) =&gt; &#123; return `$&#123;x&#125; đã gắn móc`;&#125;; Để tạo ra 1 cái thớt, ở thời viễn cổ xa xưa, các man sĩ thường code thế này: 123456789var thớt = cưa('khúc gỗ');thớt = sấy(thớt);thớt = bào(thớt);thớt = khoan(thớt);thớt = chà(thớt);thớt = móc(thớt);console.log(thớt);// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc 5 vạn năm sau, khi đã xuất hiện Toán học, các tộc nhân bộ lạc Giao Chỉ thời đại Hồng Bàng lại thích code như thế này: 123var thớt = móc(chà(khoan(bào(sấy(cưa('khúc gỗ'))))));console.log(thớt);// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc Đây chính là Toán học cơ bản. Với y = f(g(x)), ta tính g(x) trước, được bao nhiêu truyền vào f() là ra kết quả. Việc tính toán đi từ ngoặc trong cùng ra ngoài, mắt thường nhìn thấy là từ phải sang trái, từ g đến f. Lại thêm 5 ngàn năm nữa trôi qua. Lúc này đã có ES6. Một số cường giả Functional Programming sáng tạo ra phương thức compose, như thế này: 123const compose = (...fns) =&gt; &#123; return fns.reduce((f, g) =&gt; (x) =&gt; f(g(x)));&#125;; Bạn có thể dùng Babel dịch sang ES2015 cho dễ hiểu. Ý tưởng của compose là xếp cuốn chiếu các hàm lại với nhau, theo thứ tự từ trái sang phải để tạo ra một hàm mới, mà khi được thực thi, nó sẽ lần lượt gọi các hàm đã truyền vào trước đó theo thứ tự ngược lại, từ phải sang trái. Tức là nếu y = compose(f, g), thì y(x) = f(g(x));Nó sẽ tính g(x) trước rồi truyền kết quả cho f;Giả sử g(x) = z thì y(x) = f(z); Nếu bạn vẫn thấy mơ hồ thì cứ xem cái này là Đạo. Chỉ có thể cảm ngộ, không thể giảng được bằng lời! Trở lại với cái thớt. Hàm compose tất nhiên là higher-order function. Ta sẽ thử xem nó làm việc ra sao: 123const quăng_cho_tao_cái_thớt = compose(móc, chà, khoan, bào, sấy, cưa);console.log(quăng_cho_tao_cái_thớt.toString());// =&gt; bạn đoán xem log ra thứ gì? Bây giờ ta có 1 hàm, gọi là quăng_cho_tao_cái_thớt(), kết quả của sự lắp ghép bằng compose tất cả các pure functions ở trên. Ta biết compose sẽ gọi từ phải sang trái, nên công đoạn nào làm trước thì để bên phải. Chạy thử 1 phát: 123const thớt = quăng_cho_tao_cái_thớt('khúc gỗ');console.log(thớt); // =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã gắn móc Vậy là đủ công đoạn, khúc gỗ đã trở thành một cái thớt tốt. Nhưng chưa hết. Khi bạn treo cái thớt đó ở nhà, nhiều người quen đến chơi thấy đẹp hỏi mua. Nhiều đến mức bạn quyết định kinh doanh thớt. Làm thớt kinh doanh thì phải gán nhãn, vậy là bạn tạo ra một pure function mới và dùng compose để làm khuôn sản suất loại thớt commercial này. Dễ ợt, không ảnh hưởng gì đến loại thớt cho nhà dùng. 12345const nhãn = (x) =&gt; &#123; return `$&#123;x&#125; đã dán nhãn`;&#125;;const làm_thớt_để_bán = compose(nhãn, móc, chà, khoan, bào, sấy, cưa); Hoặc tận dụng lại khuôn mẫu cũ: 1const làm_thớt_để_bán = compose(nhãn, quăng_cho_tao_cái_thớt); Thử xem sao: 123const thớt_bán = làm_thớt_để_bán('khúc gỗ');console.log(thớt_bán);// =&gt; khúc gỗ đã cưa đã sấy đã bào đã khoan đã chà đã móc đã dán nhãn Để mở rộng thị phần, hướng đến phân khúc giá rẻ, bạn tạo ra dòng sản phẩm thớt tầm trung, dùng chip MediaTek, bỏ qua bước sấy khô và đánh bóng để giảm giá thành. Rất đơn giản: 1const làm_thớt_loại_hai = compose(nhãn, móc, khoan, bào, cưa); Thử xem sao: 123const thớt_loại_hai = làm_thớt_loại_hai('khúc gỗ');console.log(thớt_loại_hai);// =&gt; khúc gỗ đã cưa đã bào đã khoan đã móc đã dán nhãn Lập trình như vậy phải nói là vô cùng tao nhã, lịch thiệp! Đôi khi tôi cảm thấy phong cách lập trình Functional Programming có sự thanh tịnh đầy chất quý tộc, vừa bình dân lại vừa hàn lâm, đẹp đến mức khó hiểu! Nếu dùng OOP, có thể chúng ta còn đang loay hoay giữa một đống class Máy Cưa, Máy Bào, Máy Khoan… Hoặc 1 class Máy Làm Thớt khổng lồ có đủ methods cưa, bào, khoan… Rồi còn một mớ properties mà ta phải cân nhắc xem cái nào public, cái nào private. Rồi phải tạo instance, thừa kế qua lại mấy vòng may ra mới làm được cái thớt. Muốn thêm dòng sản phẩm lại càng khó khăn. Phải tạo class Thớt_nhàdùng, extend ra Thớtđểbán, Thớtđể_bán_loại_2, phiền phức không sao kể xiết! Functional Programming thì chỉ cần mấy hàm đơn giản, rời rạc, dùng compose lắp ráp lại như lắp ráp dây chuyền công nghệ là chế được các kiểu thớt. Function Composition tựa như một nhà máy hiện đại, mỗi chi tiết linh kiện được xử lý bằng một robot chuyên trách, kết hợp lại với nhau một cách khoa học để tạo ra sản phẩm hoàn thiện. PipeMột biến thể của compose là pipe, vận hành theo chiều ngược lại. Ta có thể implement bằng cách đảo vị trí f và g thế này: 123const pipe = (...fns) =&gt; &#123; return fns.reduce((f, g) =&gt; (x) =&gt; g(f(x)));&#125;; Hoặc giữ nguyên code của compose nhưng thay reduce bằng reduceRight: 123const pipe = (...fns) =&gt; &#123; return fns.reduceRight((f, g) =&gt; (x) =&gt; f(g(x)));&#125;; Vì pipe tổ hợp các hàm theo chiều ngược lại so với compose nên ta viết: 1const làm_thớt_dỏm = pipe(cưa, bào, nhãn); Thử xem sao: 123const thớt_dỏm = làm_thớt_dỏm('khúc gỗ');console.log(thớt_dỏm);// =&gt; khúc gỗ đã cưa đã bào đã dán nhãn Dùng pipe có vẻ thuận mắt hơn. Thứ tự các bước cưa, bào… trông khá tự nhiên. Nếu bạn quen với cách suy luận Toán học thì bạn sẽ thích compose. Còn nếu bạn muốn trực quan dễ hiểu thì cứ dùng pipe. compose và pipe là những thuật pháp nhập môn dễ học, dễ dùng, nhưng không kém uy lực, thư viện Functional Programming nào cũng có. Trong Ramda.js, ngoài compose và pipe, các tác giả còn bổ sung thêm pipeK, pipeP, composeK, composeP. Khi đã thông thạo, bạn hoàn toàn có thể tạo ra compose theo cách của bạn. Ví dụ composeBinary liên kết các hàm từ giữa sang 2 bên thay vì từ đầu này đến đầu kia, composeRandom liên kết các hàm không theo trật tự cố định… Đó là không gian sáng tạo thuộc về riêng bạn. Currying functionThuật ngữ currying và các dạng curry, curried của nó trong khoa học máy tính được Christopher Strachey đặt ra từ năm 1967 để ghi nhớ công lao của Haskell Brooks Curry, một nhà Toán học và Luận lý học người Mỹ. Currying function là làm cho 1 function trở thành “curried function”. Cái function ban đầu đó hơi ngốc nghếch, nó cần bạn truyền vào N tham số để tính toán, mà nếu thiếu 1 tham số, nó sẽ không chạy. Ví dụ hàm sum thế này: 123const sum = (a, b, c) =&gt; &#123; return a + b + c;&#125;; sum cần 3 tham số để cộng dồn lại, nếu thiếu, sẽ không tính toán ra được. 12345678// có thể ra sânsum(5, 3, 2); // =&gt; 10sum(4, 4, 2); // =&gt; 10sum(4, 3, 3); // =&gt; 10sum(3, 5, 2); // =&gt; 10// nhưngsum(4, 5); // =&gt; NaN Đây là thiếu tiền đạo cả đội không chịu ra sân tập! Nhưng cuộc sống đâu phải lúc nào cũng thuận lợi, đầy đủ cho chúng ta? Dù cả mấy tiền đạo đều bị chấn thương, treo giò, trốn tập thì các anh còn lại vẫn phải có trách nhiệm ra sân chứ! Currying chính là kỹ thuật biến hàm sum ngốc đó trở thành một function vi diệu hơn, nếu bạn gọi nó với 1 tham số, nó sẽ trả về 1 hàm tạm thời, giữ lại tham số đó, chờ khi nào đủ 3 tham số thì mới thực hiện tính toán. Hình dung bạn tổ chức một buổi party, mời 3 người bạn tham gia. Lúc này đã có mặt 2 người, còn 1 người đến muộn. Bạn quyết định không cần chờ nữa. Bữa tiệc cứ bắt đầu đã, chừng nào người kia đến thì tính tiếp. Đây là 1 cách implement cho hàm curry: 123456789101112131415161718const curry = (fn) =&gt; &#123; let totalArguments = fn.length; let next = (argumentLength, rest) =&gt; &#123; if (argumentLength &gt; 0) &#123; return (...args) =&gt; &#123; return next( argumentLength - args.length, [ ...rest, ...args, ] ); &#125;; &#125; return fn(...rest); &#125;; return next(totalArguments, []);&#125;; Và curry tất nhiên cũng là higher-order function. Thử dùng với sum xem sao: 1const curriedSum = curry(sum); curriedSum bây giờ là phiên bản curried của hàm sum trước đó. 123456curriedSum(4, 4, 2); // =&gt; 10curriedSum(4, 3, 3); // =&gt; 10curriedSum(3, 5, 2); // =&gt; 10// vàcurriedSum(5, 3); // =&gt; [Function] curriedSum(5, 3) là 1 function. Nó đang chờ đợi tham số cuối cùng xuất hiện. Nếu bây giờ ta gọi nó với 1 tham số thì kết quả sẽ được tính toán ra: 1curriedSum(5, 3)(2); // =&gt; 10 Nếu ta truyền nhiều hơn số lượng tham số còn thiếu thì sao? Ở đây là 1 tham số cuối cùng. Theo cách implement trên thì nó sẽ bỏ qua các tham số dư thừa. Các phiên bản curry của Ramda.js và Lodash FP cũng hành xử như vậy. 1curriedSum(5, 3)(2, 4, 8); // =&gt; 10 Một điểm quan trọng nữa là ta có thể phân tách hàm gốc ra từ 1 đến N phần, với N là số lượng tham số của hàm gốc đó. Chẳng hạn, nếu hàm gốc có 3 tham số, ta có thể chia nó ra 1, 2 hoặc 3 phần. Những cách viết sau là tương đương: 1234curriedSum(3, 5, 2);curriedSum(3, 5)(2);curriedSum(3)(5, 2);curriedSum(3)(5)(2); curry, cũng như compose và pipe là những kỹ thuật căn bản, ai cũng phải học, phải biết. Mọi ngôn ngữ được thiết kế với tư tưởng Functional Programming như Haskell, Scalla, Elm… đều có sẵn các hàm này. Chúng rất tinh tế và được dùng ở khắp nơi. Chỉ cần thành thạo 3 pháp quyết này thì bạn đã được xem như đệ tử Functional Programming chân chính.","categories":[],"tags":[{"name":"functional programming","slug":"functional-programming","permalink":"http://nthung2112.github.io/tags/functional-programming/"}]},{"title":"Functional Programming - Phần 1 - Con đường sáng","slug":"Functional-Programming-Phan-1-Con-duong-sang","date":"2018-06-12T08:35:00.000Z","updated":"2018-06-23T08:53:43.941Z","comments":true,"path":"2018/06/Functional-Programming-Phan-1-Con-duong-sang.html","link":"","permalink":"http://nthung2112.github.io/2018/06/Functional-Programming-Phan-1-Con-duong-sang.html","excerpt":"Lúc bấy giờ, Tin giới Tây phương xuất hiện 2 lão quái Nguyên Anh hậu kỳ đỉnh phong, chỉ thiếu nửa bước cảm ngộ ý cảnh là đột phá tới cảnh giới Hóa Thần. Một người là Đồ Linh tôn giả - tức Alan Turing, nổi danh với pháp môn Turing Machine. Người kia là Khâu Kỳ thượng tiên, Alonzo Church, tung hoành tam giới bằng đạo thuật Lambda Calculus (1). Turing Machine của Alan Turing và Lambda Calculus của Alonzo Church thực ra là hai cách tiếp cận nguyên lý xử lý tính toán trong computer, thường được giới chuyên môn gọi chung là Luận đề Church - Turing (The Church-Turing Thesis).","text":"Lúc bấy giờ, Tin giới Tây phương xuất hiện 2 lão quái Nguyên Anh hậu kỳ đỉnh phong, chỉ thiếu nửa bước cảm ngộ ý cảnh là đột phá tới cảnh giới Hóa Thần. Một người là Đồ Linh tôn giả - tức Alan Turing, nổi danh với pháp môn Turing Machine. Người kia là Khâu Kỳ thượng tiên, Alonzo Church, tung hoành tam giới bằng đạo thuật Lambda Calculus (1). Turing Machine của Alan Turing và Lambda Calculus của Alonzo Church thực ra là hai cách tiếp cận nguyên lý xử lý tính toán trong computer, thường được giới chuyên môn gọi chung là Luận đề Church - Turing (The Church-Turing Thesis). Turing Machine đặt cơ sở trên việc nắm giữ state machine và trạng thái tiến trình, còn ý tưởng Lambda Calculus được xây dựng trên các tính chất của hàm toán học. Lấy tu vi của bổn tiên hiện giờ thì chưa lĩnh hội được mấy thứ cao siêu như vậy, nên không dám lạm bàn ở đây. Chỉ biết rằng, 2 thuật pháp kể trên là khởi nguồn của 2 trường phái tu luyện mạnh nhất trong tin giới hiện nay: Object Oriented Programming và Functional Programming. Có khá nhiều cơ chế lập trình - Programming Paradigm. OOP và Functional Programming chỉ là 2 trong số đó. Trong cuốn “Programming Paradigms for Dummies: What Every Programmer Should Know“, tác giả Peter Van Roy đưa ra mô hình tổng hợp quan hệ giữa các cơ chế lập trình như thế này: Trong lịch sử công nghệ, có vẻ OOP chiếm ưu thế hơn so với Functional Programming. Bạn cứ thử nhìn xung quanh mình là biết, từ thời tập tành code đã thấy thiên địa tràn ngập quy tắc OOP rồi. Các job description, các buổi interview đều nhắc đến OOP như pháp thuật căn bản. Thảo luận kỹ thuật hầu hết xoay quanh mấy khái niệm Class, Object, Inheritance, rồi cao hơn thì SOLID, Polymorphism, Encapsulation… Nhưng, trên thế giới, từ thời Lisp đến FP, rồi Haskell, Elixir, chưa bao giờ thiếu vắng những tu tin giả đi theo con đường Functional Programming. Nhất là khoảng sau 2010, không rõ vì sao người ta bắt đầu phàn nàn nhiều hơn về OOP, trích dẫn nhiều hơn luận điểm banana/gorilla của Joe Armstrong (2), theo đó, chủ đề “Functional Programming” bắt đầu nóng dần trở lại. Tôi biết đến Functional Programming vào khoảng 2015 qua một talk show trên YouTube của “chú Bob“, nhưng không hiểu lắm nên cũng không chú ý. Phải sang 2016, tôi mới chính thức tìm hiểu sâu về Functional Programming sau khi đọc 2 loạt bài viết “Composing Software“ của Eric Elliott và “So You Want to be a Functional Programmer“ của Charles Scalfani trên Medium. Eric Elliott lần lượt giải thích từng concepts của Functional Programming một cách tường tận, dễ hiểu. Còn Charles Scalfani đúng là fan cuồng Functional Programming. Anh trình bày nó dưới dạng một hệ thống triết lý, thế giới quan đặc sắc. Thậm chí, Scalfani còn đề cao Functional Programming như nấc thang tiến hóa trong lịch sử lập trình. Lối viết của anh gây ấn tượng cực mạnh. Trước đó, Scalfani còn có bài “Goodbye, Object Oriented Programming“ gây tranh luận sôi nổi. Nhưng bạn đọc nên lưu ý, Functional Programming không bài xích OOP. Chúng chỉ là những con đường tu luyện khác nhau, cùng hướng về Đại Đạo. Trong khi viết code, ta hoàn toàn có thể phối hợp nhiều cơ chế lập trình khác nhau, miễn sao đạt đến kết quả Đúng - Nhanh - Ổn - Đẹp. ReactJS là một ví dụ tiêu biểu, có thể coi nó như 7 phần Functional Programming + 3 phần OOP. Về điểm này, Anjana Vakil có một bài thuyết trình rất hay ở GOTO 2017. Dù sao, từ đó đến nay, khuynh hướng tư duy Functional Programming vẫn từng bước lan rộng, ảnh hưởng đến thiết kế của rất nhiều chương trình hiện đại. Chỉ cần để ý một chút, chúng ta có thể nhận ra các đặc tính nổi bật của Functional Programming xuất hiện trong hầu hết frameworks và các bản cập nhật ngôn ngữ mới. Thậm chí, nếu xét kỹ, những khái niệm thoạt nhìn có vẻ không liên quan như WebComponent, Serverless, Microservice… cũng ẩn hiện tư tưởng Functional Programming. Và tôi gần như không còn đụng tới class, new, this nữa. What’s Functional Programming?Vậy rốt cuộc Functional Programming là cái gì? Nếu google bạn sẽ tìm thấy hàng tá cách giải thích khác nhau. Còn tôi chủ chương nên định nghĩa ngắn gọn thế này: Functional Programming là phương pháp lập trình lấy function làm đơn vị thao tác cơ bản. Đúng vậy. Functional Programming xét về lý tưởng thì chỉ có function, function và function. Không lệnh gán (assignment statements), không cần tới các biến (variables), không lưu giữ trạng thái toàn cục (global state). Trong Functional Programming, chúng ta điều khiển dòng chảy chương trình bằng cách phối hợp các functions lại với nhau. Chúng ta tung hứng các functions qua lại, nhận vào function, nhả ra function, lồng ghép, xâu chuỗi, biến hóa chúng theo mọi cách có thể nghĩ ra. Đó gọi là không gian “first-class functions“, nơi lập trình viên đối xử với functions như “first-class citizens”. Ở đâu functions được coi trọng như vậy, ở đó ta có thể lập trình theo cơ chế Functional Programming. JavaScript, Python, Golang, ngay cả PHP chính là như vậy. Java tính từ v8.0 ra mắt năm 2017 cũng là như vậy. Dù không hoàn hảo như Haskell, F#, etc - những tu chân giới vốn được sinh ra cho Functional Programming - nhưng ta vẫn có thể tu luyện Functional Programming được… Chỉ có điều phải vận dụng khác một chút, linh hoạt hơn một chút. Đó là lý do tại sao trong các chương trình JavaScript, Python, dù viết theo phong cách Functional Programming nhưng vẫn phải dùng đến các biến, lệnh gán để thao tác. Các tu tin giả tầng thấp muốn bắt đầu con đường Functional Programming cần phải nắm bắt những khái niệm cơ bản như Immutability, Purity, Higher-order functions, Currying function, Function Composition… Sau khi thăng cấp cảnh giới cao hơn thì có thể tìm hiểu Monad, Functor, Setoid, Idempotent, Lens… và nhiều nữa. Nào, bây giờ hãy bắt đầu hành trình… ImmutabilityImmutability nghĩa là tính bất biến. Nguyên tắc thứ nhất trong Functional Programming là: cái nào đã khai báo một lần thì mãi mãi như vậy, không bao giờ thay đổi nữa. Các biến hoặc đối tượng trong kịch bản Functional Programming nếu có thì phải immutable. Code thế này không phải là Functional Programming vì x và y bị thay đổi. 123456var x = 5;var y = 2;while (x &lt; 10) &#123; y += x; x++;&#125; Mutable là điều tối kỵ trong Functional Programming. Cần phải hạn chế đến mức thấp nhất. Các mẫu coding convention và best practices thông dụng hiện nay đều khuyến khích sử dụng const để khai báo, bỏ hẳn var , và dùng let đúng liều lượng. Đối với Object, ta nên dùng Object.freeze để lock toàn bộ thuộc tính. Cũng có thể dùng Object.defineProperty, Object.defineProperties để lock một số thuộc tính quan trọng. Các giải pháp này đều chỉ hỗ trợ 1 cấp thuộc tính. Phải chủ động code thêm nếu muốn áp dụng lên các thuộc tính con. Nếu dự án đủ phức tạp, hãy cân nhắc sử dụng các thư viện chuyên dụng như Immutable.js, Baobap… PurityPurity là tính thuần khiết, thuần túy, sự trong sạch, không bị pha tạp. Đây là nguyên tắc thứ hai trong Functional Programming: tất cả các hàm đều phải là pure function, không có hiệu ứng phụ (side effect), không được tác động lên bất cứ giá trị nào bên ngoài nó, cũng nói không với chỉnh sửa tham số input. Hàm dưới đây không phải pure function vì nó chỉnh sửa DOM element bên ngoài và thay đổi giá trị chứa trong localStorage. 123456const updateView = (html) =&gt; &#123; let $view = document.getElementById('panel'); $view.innerHTML = html; localStorage.setItem('panelCache', html); return $view;&#125; Đặc điểm quan trọng nữa của pure function là với mỗi tập giá trị đầu vào nhất định, luôn có 1 và chỉ 1 kết quả trả về tương ứng. Đây là tính chất của hàm số toán học. Hàm dưới đây không phải pure function vì trả về kết quả khác nhau cho cùng đầu vào: 123const getDuration = (timestamp) =&gt; &#123; return Date.now() - timestamp;&#125;; Pure function trong Functional Programming thường ngắn gọn, đơn giản và chỉ xử lý duy nhất 1 vấn đề logic. Đây là 1 pure function kinh điển: 123const add = (a, b) =&gt; &#123; return a + b;&#125;; Dù bạn có gọi hàng triệu lần thì add(3, 2) vẫn luôn trả về 5. Viết unit test cho pure function là nhiệm vụ dễ chịu như dạo chơi cùng một thiếu nữ ngây thơ trong trắng vậy! Immutability và Purity là 2 đặc trưng cơ bản nhất của Functional Programming, cho phép phân biệt với các cơ chế lập trình khác. Tu tin giả tu luyện theo con đường này nhất định phải giữ tâm niệm “immutable” và “pure” trong từng sát na. Chú thích1, Chữ Tàu ghi Alan Turing là 艾伦图灵 - Ngải Luân Đồ Linh, Alonzo Church là 阿隆佐邱奇 - A Long Tá Khâu Kỳ. 2, “You wanted a banana but you got a gorilla holding the banana”.","categories":[],"tags":[{"name":"functional programming","slug":"functional-programming","permalink":"http://nthung2112.github.io/tags/functional-programming/"}]},{"title":"Cấu trúc projects và đặt tên components trong React","slug":"Cau-truc-projects-va-dat-ten-components-trong-React","date":"2018-05-26T16:02:00.000Z","updated":"2018-05-26T13:12:57.001Z","comments":true,"path":"2018/05/Cau-truc-projects-va-dat-ten-components-trong-React.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Cau-truc-projects-va-dat-ten-components-trong-React.html","excerpt":"Như bạn đã biết, React chỉ là một thư viện nên nó không chỉ rõ cho người dùng cách tổ chức, phân chia cấu trúc thư mục cho dự án của mình. Xét trên một khía cạnh, có thể điều này là tốt vì dev có thể thoải mái thử rất nhiều cách khác nhau để chọn ra phương pháp phù hợp với dự án của mình. Tuy nhiên, nó lại khiến cho những dev mới bắt đầu sử dụng React cảm thấy khó hiểu. Bài viết này sẽ đưa ra một vài phương pháp phân chia folders, files giúp cho ứng dụng React của bạn có thể mở rộng một cách thuận tiện, nhất là đối với những người mới bước chân vào React và không biết phải làm như thế nào cho hợp lý.","text":"Như bạn đã biết, React chỉ là một thư viện nên nó không chỉ rõ cho người dùng cách tổ chức, phân chia cấu trúc thư mục cho dự án của mình. Xét trên một khía cạnh, có thể điều này là tốt vì dev có thể thoải mái thử rất nhiều cách khác nhau để chọn ra phương pháp phù hợp với dự án của mình. Tuy nhiên, nó lại khiến cho những dev mới bắt đầu sử dụng React cảm thấy khó hiểu. Bài viết này sẽ đưa ra một vài phương pháp phân chia folders, files giúp cho ứng dụng React của bạn có thể mở rộng một cách thuận tiện, nhất là đối với những người mới bước chân vào React và không biết phải làm như thế nào cho hợp lý. Cấu trúc files và foldersMột trong những câu hỏi dev thường gặp phải khi bắt đầu code là “Làm thế nào dể phân chia files và folders”. Để thuận tiện thì chúng ta sẽ bắt đầu từ cấu trúc đơn giản nhất mà package create-react-app đã tạo ra. Cụ thể là folder src. Đây là folder chính chứa source code, vì vậy chúng ta sẽ tập trung vào phần này. Toàn bộ những files, folder khác nằm ngoài vẫn sẽ được giữ nguyên: Tách riêng thành folder Containers và ComponentsCó thể bạn đã thấy trong một vài dự án, dev thường sử dụng hai folders có tên Components và Containers 123src├─ components └─ containers Thoạt nhìn thì có vẻ ổn, nhưng cách phân chia như trên còn tồn tại những nhược điểm như sau: Định nghĩa chức năng một cách không rõ ràng - Sử dụng cấu trúc như trên có thể gây nhầm lẫn, hiểu lần về chức năng của mỗi folder Container và Component , có nhiều người sẽ hiểu chức năng của mỗi folder theo ý khác nhau. Có người thì hiểu Containers là các components thực hiện việc xử lý logic (như handle click, button) và lấy dữ liệu từ server, còn components có nghĩa Presentational Component, thực hiện nhiệm vụ hiển thị view cho người dùng. Có người lại sử dụng Containers để chứa những route components (mỗi component là một link route, nếu như bạn sử dụng react-router), còn Components thì chứa những base component để tạo nên các route components kia. Vì thế khi làm việc trong team sẽ gây ra không đồng nhất và các member khó thống nhất trong việc sử dụng hai folder này. Components không còn linh động, reusable - Ngay cả khi bạn đã code ra một components với chức năng đặc thù, sau này bạn vẫn phải sửa lại components đó do những lí do như đổi requirements, thêm chức năng,… khiến cho file chuyển qua chuyển lại giữa 2 folders components và containers. Components trùng tên - Khi sử dụng react, tên của một component nên có ý nghĩa như chức năng của nó, và quan trọng là không nên có nhiều components trùng tên nhau trong project để tránh gây nhầm lẫn. Cách tổ chức folders như trên sẽ tạo ra 2 components có tên giống nhau, một sử dụng cho container, một sử dụng cho components (presentational - hiển thị) Giảm hiệu suất code - Bạn sẽ phải thường xuyên navigate giữa 2 folder trên khi viết cho một tính năng, do một tính năng thường sẽ gồm cả 2 loại components Một cách phân chia khác cũng có cấu trúc 2 folder như trên, nhưng phân biệt dựa trên module . Giả sử ứng dụng của bạn có một module User. Trong đó sẽ tách ra thành 2 folder components và containers: 1234src└─ User ├─ components └─ containers Theo hướng tiếp cận trên, dev sẽ không phải gặp khó khăn trong việc navigate giữa các folder khi code. Bạn sẽ không phải kéo lên, kéo xuống để tìm xem components của User ở đâu, khi đang hoàn thiện file trong containers để đối chiếu. Tuy nhiên, cách này sẽ sinh ra một đống folder containers và components nếu như hệ thống của bạn lớn và cót rất nhiều modules. Như vậy, việc tách biệt 2 folder components và containers không hẳn là hợp lý. Thay vì tách riêng ra như vậy, các components sẽ được đặt hết trong folder components ngoại trừ những components sử dụng làm screens Tái cấu trúc folders dựa trên moduleTrong folder components, chúng ta sẽ nhóm các files lại theo module hoặc feature/tính năng. Với tính năng CRUD user, chúng ta chỉ cần module User, nên folder tree sẽ có dạng như sau: 12345src└─ components └─ User ├─ Form.jsx └─ List.jsx Khi component được cấu thành bời nhiều hơn một file (chẳng hạn như phải import nhiều components khác, hay file chỉnh sửa css cho component đó), chúng ta sẽ đưa component này cùng các files liên quan vào một folder có cùng tên. Ví dụ như Form.jsx cần thêm Form.css để chỉnh style, bạn sẽ có một folder như sau: 1234567src└─ components └─ User ├─ Form │ ├─ Form.jsx │ └─ Form.css └─ List.jsx UI componentsNgoài các folder dành cho module hay tính năng trong ứng dụng của bạn, có thể thêm một folder _UI_ (hoặc base/atomic) dùng cho các component dạng UI - là những phần tử nhỏ sử dụng cho UI trong ứng dụng của bạn. Đây là những component giống các thư viện open source, thường được dùng đi dùng lại nhiều lần trong ứng dụng của bạn, không nhất thiết phải là một module lớn và không thực hiện các business logic. Những ví dụ về components dạng này như Button, Checkbox, SelectBox, Modal, DatePicker, BreadCrumb,… Đặt tên cho componentsỞ phần trên chúng ta đã thấy được cách hệ thống files và folder trong ứng dụng, còn bây giờ sẽ tìm hiểu xem đặt tên components ra sao cho phù hợp. Như đã đề cập ở trên, tên của components nên rõ ràng và không bị trùng lặp để có thể dễ tìm lại và tránh nhầm lẫn cho những thành viên khác trong team. Ngoài ra, tên components rõ ràng cũng giúp cho việc debug bằng những extension tools trở nên dễ dàng hơn trên trình duyệt (chẳng hạn như React Dev Tools) - vì khi app của bạn gặp lỗi khi đang chạy thì lỗi sẽ hiển thị ở đúng components xảy ra lỗi. Để đặt tên components, chúng ta sẽ đặt theo hướng path-based-component-naming, nghĩa là cấu thành bởi đường dẫn từ folder src/components đến file chúng ta tạo component đó. Chẳng hạn, bạn có một file với đường dẫn src/components/User/List.jsx thì tên component được sử dụng trong List.jsx sẽ được đặt là UserList: 1class UserList extends React.Component Nếu một file trong folder trùng tên với tên folder, chúng ta sẽ không cần phải lặp lại cả tên folder lẫn tên file. Chẳng hạn, có một file src/components/User/Form/Form.jsx thì thay vì sử dụng UserFormForm, chúng ta sẽ đặt là UserForm. Việc đặt tên components theo đường dẫn như trên có những ích lợi như sau: Việc search file trong text editor/IDE trở nên thuận tiện hơn - Chỉ cần gõ vào ô search của IDE hay text editor mà bạn sử dụng là có thể tìm đến file một cách nhanh chóng. Hoặc navigate đến file cũng rất thuận tiện: Tránh lặp đi lặp lại tên khi import Theo cách đặt tên như vậy, bạn sẽ luôn đặt tên file giống với chức năng, nhiệm vụ của nó. Đối với component form ở trên, chính xác thì phải là user form, nhưng do file đã nằm trong folder User nên chúng ta không cần lặp lại từ đó trong tên file của component, mà chỉ cần sử dung Form.jsx Có nhiều trường hợp, dev viết app React và đặt tên file/folder cũng như tên component một cách đầy đủ, bao gồm cả tên module lớn và nhỏ, và dần dần sau này khi app scale lên thì việc đặt tên này sẽ trở nên phức tạp hơn rất nhiều. Thử so sánh hai trường hợp sau đây: 123import ScreensUserForm from './screens/User/UserForm';// vsimport ScreensUserForm from './screens/User/Form'; Đối với module nhỏ với ít thành phần như trên thì cách đặt tên thứ hai có vẻ như không tạo nhiều khác biệt lắm, ta có thể thấy cách viết thứ nhất vẫn ổn. Tuy nhiên, nếu như app của bạn scale lên với nhiều thành phần, module, chức năng phức tạp thì việc đặt tên như vậy sẽ trở nenen vô cùng kinh khủng: 123import MediaPlanViewChannel from '/MediaPlan/MediaPlanView/MediaPlanViewChannel.jsx';// vsimport MediaPlanViewChannel from './MediaPlan/View/Channel'; Chưa kể những dòng như thế này còn lặp lại nhiều lần vì phải import nhiều thành phần cùng lúc…. Ví lí do đó, chúng ta nên đặt tên file và folder đúng với chức năng/nhiệm vụ trực tiếp của nó, thay vì thêm vào tên của những module cha. Còn tên component thì nên đặt theo đường dẫn tương đối so với folder src/components. Screens components - Dùng cho một view pageỞ trên, bài viết có nhắc đến những compoents không được đặt trong folder components, được gọi là screens. Giống như tên gọi của nó, đây là những components tượng trưng cho một màn hình hiển thị trong ứng dụng của bạn Lấy ví dụ đối với tính năng CRUD users, chúng ta sẽ có những màn hình cơ bản nhất bao gồm: List users (/users Create user (/user) Edit user (/users/:id) Như vậy, chúng ta có 3 screens khác nhau. Mỗi screen là một component cấu thành lên một page trong ứng dụng react của bạn. Screen component nên là một presentational component và không nên thực hiện xử lý business logic. Các screens sẽ nằm trong một folder screens song song với components trong đường dẫn src, vì mỗi component ở trong sẽ đại diện cho route của ứng dụng, thay vì một module nào đó: 123456src ├─ components └─ screens └─ User ├─ Form.jsx └─ List.jsx Nếu ứng dụng của bạn sử dụng react-router, chúng ta sẽ giữ một file Root.jsx trong folder screens và đưa toàn bộ các view route vào trong file này: 123456789101112131415161718import React, &#123; Component &#125; from 'react';import &#123; Router &#125; from 'react-router';import &#123; Redirect, Route, Switch &#125; from 'react-router-dom';import ScreensUserForm from './User/Form';import ScreensUserList from './User/List';const ScreensRoot = () =&gt; ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path=\"/user/list\" component=&#123;ScreensUserList&#125; /&gt; &lt;Route path=\"/user/create\" component=&#123;ScreensUserForm&#125; /&gt; &lt;Route path=\"/user/:id\" component=&#123;ScreensUserForm&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt;);export default ScreensRoot; Với cách này chúng ta đã đưa toàn bộ screens vào trong một folder có cùng tên với định nghĩa route: user/ -&gt; User/. Folder User chứa màn hình List và màn hinh Form bên trong. Từ đó bạn có thể dễ dàng tìm thấy màn hình nào render route nào bằng cách nhìn vào url. Một màn hình có thể sử dụng để render nhiều route, như chúng ta thấy màn hình Form sẽ render 2 route dành cho việc Create và Edit. Chú ý rằng, chúng ta nên thêm prefix Screen khi đặt tên cho các screen, để tránh nhầm lẫn với các component trong folder components. Như vậy tên của screen component đặt trong folder src/screens/User/List.jsx nên được đặt là ScreenUserList: 12345678910111213import React from 'react';import UserForm from '../../components/User/Form/Form';const ScreensUserForm = (&#123; match: &#123; params &#125; &#125;) =&gt; ( &lt;div&gt; &lt;h1&gt; &#123;`$&#123;!params.id ? 'Create' : 'Update'&#125;`&#125; User &lt;/h1&gt; &lt;UserForm id=&#123;params.id&#125; /&gt; &lt;/div&gt;);export default ScreensUserForm; Như trong đoạn code trên thì screen component sẽ không xử lý gì liên quan đến state (data) mà chỉ thực hiện render ra component UserForm. Cuối cùng thì chúng ta sẽ có được một cấu trúc folder như sau: 1234567891011121314src├─ components │ ├─ User│ │ ├─ Form│ │ │ ├─ Form.jsx│ │ │ └─ Form.css│ │ └─ List.jsx│ └─ UI │└─ screens ├─ User │ ├─ Form.jsx │ └─ List.jsx └─ Root.jsx Tổng kếtTóm tắt lại, chúng ta cần nhớ những điểm sau đây: Presentational và Container components được đặt trong folder src/components Nhóm các components lại dựa trên module/feature Đưa những component chung được sử dụng nhiều lần (UI components) vào trong src/components/UI Viết component screens (màn hình) thật đơn giản, ít code Nhóm các màn hình lại theo route của ứng dụng. Với route /user/list thì screen sẽ nằm trong src/screens/User/List.jsx. Components được dặt tên theo đường dẫn tương đối của so với src/components hoặc src - Tên component trong file src/components/User/List.jx sẽ có tên là UserList, tên component trong file src/screens/User/List.jsx sẽ có tên là ScreensUserList. Component trong file có cùng tên với folder chứa nó sẽ không lặp lại tên của folder. Ví dụ file src/components/User/List/List.jsx sẽ có component được đặt tên là UserList, chứ KHÔNG PHẢI là UserListList Kết luậnBài viết đã đưa ra một trong những cách để tổ chức, phân chia cũng như đặt tên cho file, folder và component khi thiết kế ứng dụng bằng React. Đương nhiên, đây chỉ là ý kiến chủ quan, bạn hoàn toàn có thể tự mình thiết lập và đưa ra những pattern mà bạn cảm thấy hợp lý, thuận tiện khi làm việc với React, miễn sao cho trải nghiệm của bản thân là tốt nhất. Xin cảm ơn!","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Gooact: React trong 160 dòng code JavaScript","slug":"Gooact-React-trong-160-dong-code-JavaScript","date":"2018-05-26T08:13:00.000Z","updated":"2018-05-26T13:12:23.679Z","comments":true,"path":"2018/05/Gooact-React-trong-160-dong-code-JavaScript.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Gooact-React-trong-160-dong-code-JavaScript.html","excerpt":"","text":"Làm thế nào để xây dựng React cho riêng mình chỉ trong vài phút.Giới thiệuReact là một thư viện tuyệt vời - nhiều nhà phát triển ngay lập tức đã yêu thích nó vì tính đơn giản, hiệu suất và cách khai báo làm việc. Nhưng cá nhân tôi có một lý do cụ thể khiến nó trở nên đặc biệt đối với tôi - và đó là cách nó hoạt động bên dưới. Tôi tìm thấy những ý tưởng đứng đằng sau React đơn giản nhưng kỳ lạ thú vị - và tôi tin rằng sự hiểu biết nguyên tắc cốt lõi của nó sẽ giúp bạn viết mã nhanh hơn và an toàn hơn. Trong bài viết này, tôi sẽ chỉ cho cho bạn cách viết một bản sao của React đầy đủ chức năng, bao gồm Component API và tự triển khai Virtual DOM. Nó được chia thành bốn phần - mỗi phần là một chủ đề chính: Elements: Trong phần này chúng ta sẽ tìm hiểu cách các khối JSX được xử lý thành phiên bản nhẹ của DOM được gọi là VDOM như thế nào. Rendering: Trong phần này tôi sẽ hướng dẫn bạn cách chuyển đổi VDOM thành DOM thông thường. Patching: Trong phần này tôi sẽ trình bày lý do tại sao thuộc tính “key” quan trọng như thế và cách sử dụng VDOM để nối lại với DOM hiện tại một cách hiệu quả. Components: Phần cuối cùng sẽ cho bạn biết về các thành phần React và quy trình tạo, vòng đời và dựng hình của chúng. Mỗi phần sẽ kết thúc bằng một ví dụ có link CodePen trực tiếp, vì vậy bạn có thể ngay lập tức kiểm tra tất cả các tiến trình chúng ta đã thực hiện. Bắt đầu nào. Elements Element là một đối tượng trọng lượng nhẹ của một DOM thực tế. Nó chứa tất cả thông tin quan trọng - như node type, attributes và danh sách children — vì vậy nó có thể dễ dàng rendered trong tương lai. Thành phần giống như cây của các elements được gọi là VDOM - một ví dụ được hiển thị bên dưới: 1234567891011121314151617181920212223242526&#123; \"type\": \"ul\", \"props\": &#123; \"className\": \"some-list\" &#125;, \"children\": [ &#123; \"type\": \"li\", \"props\": &#123; \"className\": \"some-list__item\" &#125;, \"children\": [ \"One\" ] &#125;, &#123; \"type\": \"li\", \"props\": &#123; \"className\": \"some-list__item\" &#125;, \"children\": [ \"Two\" ] &#125; ]&#125; Thay vì viết object quái dị đó mọi lúc, hầu hết các nhà phát triển React đều sử dụng cú pháp JSX, trông giống như một sự kết hợp gọn gàng giữa mã JavaScript và các thẻ HTML: 12345/** @jsx createElement */const list = &lt;ul className=\"some-list\"&gt; &lt;li className=\"some-list__item\"&gt;One&lt;/li&gt; &lt;li className=\"some-list__item\"&gt;Two&lt;/li&gt;&lt;/ul&gt;; In order to get executed it needs to be transpiled into regular function calls — notice that pragma comment which defines what function must be used:Để được thực hiện, nó cần phải được chuyển thành các gọi hàm thông thường - chú ý comment pragma là phải luôn sử dụng: 1234const list = createElement('ul', &#123;className: 'some-list'&#125;, createElement('li', &#123;className: 'some-list__item'&#125;, 'One'), createElement('li', &#123;className: 'some-list__item'&#125;, 'Two'),); Cuối cùng, function mong muốn được gọi - và nó được cho là trả về cấu trúc VDOM được mô tả ở trên. Việc triển khai của chúng tôi sẽ ngắn gọn - nhưng mặc dù có vẻ nguyên thủy, nó phục vụ mục đích cần một cách hoàn hảo: 1234const createElement = (type, props, ...children) =&gt; &#123; props = props != null ? props : &#123;&#125;; return &#123;type, props, children&#125;;&#125;; CodePen đầu tiên có sẵn ở đây— nó chứa phương pháp được mô tả ở trên với một vài cây VDOM do nó tạo ra. Rendering Rendering là một quá trình biến VDOM thành DOM hiển thị. Nói chung, nó là một thuật toán khá đơn giản mà đi qua cây VDOM và tạo ra phần tử DOM tương ứng cho mỗi node: 123456789101112131415161718192021222324252627282930313233343536const render = (vdom, parent=null) =&gt; &#123; if (parent) parent.textContent = ''; const mount = parent ? (el =&gt; parent.appendChild(el)) : (el =&gt; el); if (typeof vdom == 'string' || typeof vdom == 'number') &#123; return mount(document.createTextNode(vdom)); &#125; else if (typeof vdom == 'boolean' || vdom === null) &#123; return mount(document.createTextNode('')); &#125; else if (typeof vdom == 'object' &amp;&amp; typeof vdom.type == 'function') &#123; return mount(Component.render(vdom)); &#125; else if (typeof vdom == 'object' &amp;&amp; typeof vdom.type == 'string') &#123; const dom = document.createElement(vdom.type); for (const child of [].concat(...vdom.children)) // flatten dom.appendChild(render(child)); for (const prop in vdom.props) setAttribute(dom, prop, vdom.props[prop]); return mount(dom); &#125; else &#123; throw new Error(`Invalid VDOM: $&#123;vdom&#125;.`); &#125;&#125;;const setAttribute = (dom, key, value) =&gt; &#123; if (typeof value == 'function' &amp;&amp; key.startsWith('on')) &#123; const eventType = key.slice(2).toLowerCase(); dom.__gooactHandlers = dom.__gooactHandlers || &#123;&#125;; dom.removeEventListener(eventType, dom.__gooactHandlers[eventType]); dom.__gooactHandlers[eventType] = value; dom.addEventListener(eventType, dom.__gooactHandlers[eventType]); &#125; else if (key == 'checked' || key == 'value' || key == 'id') &#123; dom[key] = value; &#125; else if (key == 'key') &#123; dom.__gooactKey = value; &#125; else if (typeof value != 'object' &amp;&amp; typeof value != 'function') &#123; dom.setAttribute(key, value); &#125;&#125;; Code ở trên có vẻ trông đáng sợ, nhưng hãy làm cho mọi thứ trở nên ít phức tạp hơn bằng cách tách nó thành các phần nhỏ hơn: Custom Attribute Setter: Các thuộc tính được chuyển đến VDOM không phải lúc nào cũng hợp lệ về DOM - những thứ như trình xử lý sự kiện, key định danh và các giá trị phải được xử lý riêng lẻ. Primitive VDOM rendering: Primitives — như strings, numbers, booleans và nulls — được chuyển thành các node văn bản thuần túy. Complex VDOM rendering: Nodes với tag string được biến thành các phần tử DOM với hiển thị children theo đệ quy. Component VDOM rendering: Nodes với tag function tag được xử lý riêng — không chú ý nhiều đến phần đó, chúng ta sẽ thực hiện nó sau. CodePen thứ hai có sẵn ở đây— nó thể hiện thuật toán render trong hành động. Patching Patching là một quá trình hòa hợp DOM hiện có với cây VDOM mới được xây dựng. Hãy tưởng tượng bạn có một số VDOM lồng nhau sâu và cập nhật thường xuyên. Khi một cái gì đó thay đổi, ngay cả phần nhỏ nhất - mà phải được hiển thị. Triển khai native sẽ yêu cầu render toàn bộ mỗi lần cập nhật như vậy. Xóa các nút DOM hiện có. Re-render mọi thứ. Đó là lý do thực tế — xây dựng DOM và vẽ lại nó là một hoạt động khá tốn kém. Nhưng chúng ta có thể tối ưu hóa điều này bằng cách viết thuật toán và sẽ yêu cầu ít sửa đổi DOM: Xây dựng một VDOM mới. Đệ quy so sánh nó với DOM hiện có. Tìm các nút đã được thêm, xóa hoặc thay đổi theo bất kỳ cách nào. Patch(Vá) chúng lại. Nhưng sau đó một vấn đề khác nổi lên — độ phức tạp tính toán. So sánh hai cây có độ phức tạp O(n³) — ví dụ: nếu bạn định patch một ngìn elements — nó sẽ yêu cầu một tỷ so sánh. Điều đó là quá nhìu. Thay vào đó, chúng ta sẽ triển khai một thuật toán độ phức tạp O(n) với hai giả định sau: Hai elements của các loại khác nhau sẽ tạo ra những cây khác nhau. Nhà phát triển có thể gợi ý các phần tử con nào có thể không đổi qua các lần render khác nhau với prop “key”. Trong thực tế, các giả định này có giá trị đối với hầu hết các trường hợp sử dụng thực tế. Bây giờ chúng tôi đã sẵn sàng cho một phần code khác: 123456789101112131415161718192021222324252627282930313233343536const patch = (dom, vdom, parent=dom.parentNode) =&gt; &#123; const replace = parent ? el =&gt; (parent.replaceChild(el, dom) &amp;&amp; el) : (el =&gt; el); if (typeof vdom == 'object' &amp;&amp; typeof vdom.type == 'function') &#123; return Component.patch(dom, vdom, parent); &#125; else if (typeof vdom != 'object' &amp;&amp; dom instanceof Text) &#123; return dom.textContent != vdom ? replace(render(vdom)) : dom; &#125; else if (typeof vdom == 'object' &amp;&amp; dom instanceof Text) &#123; return replace(render(vdom)); &#125; else if (typeof vdom == 'object' &amp;&amp; dom.nodeName != vdom.type.toUpperCase()) &#123; return replace(render(vdom)); &#125; else if (typeof vdom == 'object' &amp;&amp; dom.nodeName == vdom.type.toUpperCase()) &#123; const pool = &#123;&#125;; const active = document.activeElement; for (const index in Array.from(dom.childNodes)) &#123; const child = dom.childNodes[index]; const key = child.__gooactKey || index; pool[key] = child; &#125; const vchildren = [].concat(...vdom.children); // flatten for (const index in vchildren) &#123; const child = vchildren[index]; const key = child.props &amp;&amp; child.props.key || index; dom.appendChild(pool[key] ? patch(pool[key], child) : render(child)); delete pool[key]; &#125; for (const key in pool) &#123; if (pool[key].__gooactInstance) pool[key].__gooactInstance.componentWillUnmount(); pool[key].remove(); &#125; for (const attr of dom.attributes) dom.removeAttribute(attr.name); for (const prop in vdom.props) setAttribute(dom, prop, vdom.props[prop]); active.focus(); return dom; &#125;&#125;; Hãy điều tra tất cả các kết hợp có thể: Primitive VDOM + Text DOM: So sánh giá trị VDOM với nội dung DOM và thực hiện full render nếu chúng khác nhau. Primitive VDOM + Element DOM : Full render. Complex VDOM + Text DOM : Full render. Complex VDOM + Element DOM of different type : Full render. Complex VDOM + Element DOM of same type : Sự kết hợp thú vị nhất, nơi diễn ra sự hòa hợp của children, xem chi tiết bên dưới. Component VDOM + any kind of DOM: Cũng giống như trong phần trước, được xử lý riêng và sẽ được triển khai sau. Như bạn có thể thấy, các nút text và phức tạp nói chung không tương thích và yêu cầu full render — may mắn thay đó là một sự thay đổi hiếm hoi. Nhưng những gì về sự hòa hợp của children đệ quy - nó thực hiện như sau: Current active element is memoized — reconciliation may break focus sometimes. DOM children are moved into temporary pool under their respective keys — index is used as a key by default. VDOM children are paired to the pool DOM nodes by key and recursively patched — or rendered from scratch if pair is not found. DOM nodes that left unpaired are removed from document. New attributes are applied to final parent DOM. Focus is returned back to previously active element. CodePen thứ ba có sẵn ở đây — bao gồm ví dụ nhỏ về list patching. Components Component về mặt khái niệm tương tự như hàm JavaScript — nó có đầu vào tùy ý được gọi là “props” và trả về tập các elements mô tả những gì sẽ xuất hiện trên màn hình. Nó có thể được định nghĩa là một stateless function hoặc derived class với trạng thái bên trong của riêng và tập các phương thức và các lifecycle hooks. Tôi sẽ ngắn gọn về lý thuyết - tốt hơn hãy xem code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Component &#123; constructor(props) &#123; this.props = props || &#123;&#125;; this.state = null; &#125; static render(vdom, parent=null) &#123; const props = Object.assign(&#123;&#125;, vdom.props, &#123;children: vdom.children&#125;); if (Component.isPrototypeOf(vdom.type)) &#123; const instance = new (vdom.type)(props); instance.componentWillMount(); instance.base = render(instance.render(), parent); instance.base.__gooactInstance = instance; instance.base.__gooactKey = vdom.props.key; instance.componentDidMount(); return instance.base; &#125; else &#123; return render(vdom.type(props), parent); &#125; &#125; static patch(dom, vdom, parent=dom.parentNode) &#123; const props = Object.assign(&#123;&#125;, vdom.props, &#123;children: vdom.children&#125;); if (dom.__gooactInstance &amp;&amp; dom.__gooactInstance.constructor == vdom.type) &#123; dom.__gooactInstance.componentWillReceiveProps(props); dom.__gooactInstance.props = props; return patch(dom, dom.__gooactInstance.render()); &#125; else if (Component.isPrototypeOf(vdom.type)) &#123; const ndom = Component.render(vdom); return parent ? (parent.replaceChild(ndom, dom) &amp;&amp; ndom) : (ndom); &#125; else if (!Component.isPrototypeOf(vdom.type)) &#123; return patch(dom, vdom.type(props)); &#125; &#125; setState(nextState) &#123; if (this.base &amp;&amp; this.shouldComponentUpdate(this.props, nextState)) &#123; const prevState = this.state; this.componentWillUpdate(this.props, nextState); this.state = nextState; patch(this.base, this.render()); this.componentDidUpdate(this.props, prevState); &#125; else &#123; this.state = nextState; &#125; &#125; shouldComponentUpdate(nextProps, nextState) &#123; return nextProps != this.props || nextState != this.state; &#125; componentWillReceiveProps(nextProps) &#123; return undefined; &#125; componentWillUpdate(nextProps, nextState) &#123; return undefined; &#125; componentDidUpdate(prevProps, prevState) &#123; return undefined; &#125; componentWillMount() &#123; return undefined; &#125; componentDidMount() &#123; return undefined; &#125; componentWillUnmount() &#123; return undefined; &#125;&#125; Các static methods được gọi internally: Render: Performs initial rendering. Stateless components are called as a regular function — result is displayed immediately. Class components are instantiated and attached to the DOM — and only then are rendered. Patching: Performs further update. Sometimes DOM node already has a component instance attached to it — pass new properties to it and patch differences. Perform full render otherwise. Các Instance methods có nghĩa là có thể bị ghi đè hoặc được gọi trong các derived classes do người dùng định nghĩa: Constructor: Handles properties and defines initial state, storing them within itself. State modifier: Handles new state, fires all required lifecycle hooks and initiates patch cycle. Lifecycle hooks: Set of methods that are fired throughout component life — on mount, during updates and just before it gets removed. Lưu ý rằng phương thức render bị thiếu — nó được định nghĩa trong các child classes. CodePen cuối cùng có ở đây — với tất cả các code chúng tôi đã thực hiện cho đến đây cùng với một ví dụ to-do đơn giản. Kết luậnĐó là tất cả của tôi — chúng ta có một bản sao React đầy đủ chức năng ngay bây giờ. Tôi sẽ gọi nó là Gooact — đó sẽ là một món quà nhỏ cho người bạn tốt của tôi. Chúng ta hãy xem xét kỹ hơn các kết quả: Gooact có thể xây dựng và patch hiệu quả các cây DOM phức tạp bằng cách sử dụng VDOM làm tham chiếu. Gooact hỗ trợ cả hai functional và class components — cùng với việc xử lý chính xác internal state và hooks lifecycle hoàn chỉnh. Gooact dùng transpiled code cung cấp bởi Babel. Gooact vừa đủ trong 160 dòng code JavaScript chưa nén. Mục đích chính của bài viết này là để chứng minh các nguyên tắc cốt lõi của cấu trúc bên trong React mà không cần phải đi sâu vào các API phụ trợ - đó là lý do tại sao chúng bị thiếu một số thứ sau trong Gooact: Gooact không hỗ trợ những thứ như fragments, portals, contexts, references và một số thứ khác đã được giới thiệu trong các phiên bản mới hơn. Gooact không triển khai React Fiber do sự phức tạp của nó — nhưng tôi có thể viết một bài về nó trong tương lai. Gooact không theo dõi các key trùng lặp và đôi khi có thể gây ra lỗi. Gooact thiếu hỗ trợ callbacks thêm cho một số methods. Như bạn có thể thấy, đó là một lĩnh vực tuyệt vời cho các tính năng và cải tiến mới - repository có sẵn ở đây, do đó, vì vậy đừng ngần ngại fork và thử nghiệm. Bạn thậm chí có thể cài đặt nó bằng cách sử dụng NPM! Tôi muốn cảm ơn toàn bộ React Team đã tạo một thư viện tuyệt vời, làm cho cuộc sống của hàng nghìn nhà phát triển trở nên dễ dàng hơn. Đặc biệt cảm ơn đến Preact tác giả chính là Jason Miller — bài viết này đã được lấy cảm hứng từ cách tối giản nó được thực hiện.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Cơ chế sử dụng Virtual DOM trong React","slug":"Co-che-su-dung-Virtual-DOM-trong-React","date":"2018-05-25T15:22:00.000Z","updated":"2018-05-25T15:35:20.184Z","comments":true,"path":"2018/05/Co-che-su-dung-Virtual-DOM-trong-React.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Co-che-su-dung-Virtual-DOM-trong-React.html","excerpt":"Khi tìm hiểu về ReactJS, chắc hẳn bạn đã nghe tới khái niệm DOM ảo (Virtual DOM). Nó giúp cho hiệu suất làm việc của React cao hơn hẳn so với các thư viện và framework Javascript khác. Nhưng bạn đã bao giờ tìm hiểu DOM ảo là gì và nó hoạt động như thế nào trong React? Hôm nay, chúng ta cùng tìm hiểu về chủ đề này nhé.","text":"Khi tìm hiểu về ReactJS, chắc hẳn bạn đã nghe tới khái niệm DOM ảo (Virtual DOM). Nó giúp cho hiệu suất làm việc của React cao hơn hẳn so với các thư viện và framework Javascript khác. Nhưng bạn đã bao giờ tìm hiểu DOM ảo là gì và nó hoạt động như thế nào trong React? Hôm nay, chúng ta cùng tìm hiểu về chủ đề này nhé. Virtual DOM là gì?Điều đầu tiên tôi muốn nói ở đây là: Virtual DOM không được phát minh ra bởi React, mà React sử dụng nó. DOM ảo là một bản sao chép trừu tượng của DOM thật (HTML DOM). Bạn có thể tưởng tượng nó giống như một bản thiết kế, chứa các chi tiết cần thiết để cấu hình lên một DOM. Ví dụ, thay vì tạo một thẻ &lt;div&gt; thật chứa các thẻ &lt;ul&gt; bên trong, nó sẽ tạo một div object chứa ul object bên trong. Cụ thể ở trong React sẽ là các React.div và React.ul. Khi tương tác, ta có thể tương tác với các object đó rất nhanh mà không phải động tới DOM thật hoặc thông qua DOM API. Tiếp theo chúng ta sẽ tìm hiểu cụ thể React tương tác với DOM ảo như thế nào nhé Virtual DOM trong ReactTrước tiên, đã bao giờ bạn tự hỏi tại sao lại phải tương tác thông qua DOM ảo, sao không render trực tiếp ở DOM thật? Vậy bạn đã thực sự hiểu rõ DOM được tạo và re-render như thế nào mỗi khi các thành phần trong DOM thay đổi? Mỗi khi có sự thay đổi, vì cấu trúc của DOM là tree structure , khi muốn thay đổi các element và các thẻ con của nó, nó phải thông qua các Reflow/Layout, sau đó các thay đổi đó sẽ được Re-painted, rất mất thời gian. Vì thế, càng nhiều các item phải reflow/repaint, web của bạn sẽ càng load chậm. Vậy React đã sử dụng DOM ảo như thế nào? Để một trang lớn như Facebook mà chúng ta dùng hàng ngày có hiệu suất làm việc cao như vậy? Để dễ hình dung, chúng ta sẽ tìm hiểu thông qua một ví dụ nho nhỏ dưới đây nhé. Đó là giao diện của một app cộng hoặc trừ 2 số. Người dùng sẽ nhập vào 2 số vào 2 ô input, sau đó chọn phép toán và in ra kết quả ở phần Output. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React, &#123; Component &#125; from 'react';export default class Calculator extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; output: '' &#125;; &#125; render() &#123; let IntegerA, IntegerB, IntegerC; return ( &lt;div className=\"container\"&gt; &lt;h2&gt;using React&lt;/h2&gt; &lt;div&gt; Input 1: &lt;input type=\"text\" placeholder=\"Input 1\" ref=\"input1\" /&gt; &lt;/div&gt; &lt;div&gt; Input 2 : &lt;input type=\"text\" placeholder=\"Input 2\" ref=\"input2\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;button id=\"add\" onClick=&#123;() =&gt; &#123; IntegerA = parseInt(this.refs.input1.value); IntegerB = parseInt(this.refs.input2.value); IntegerC = IntegerA + IntegerB; this.setState(&#123; output: IntegerC &#125;); &#125;&#125; &gt; Add &lt;/button&gt; &lt;button id=\"subtract\" onClick=&#123;() =&gt; &#123; IntegerA = parseInt(this.refs.input1.value); IntegerB = parseInt(this.refs.input2.value); IntegerC = IntegerA - IntegerB; this.setState(&#123; output: IntegerC &#125;); &#125;&#125; &gt; Subtract &lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;hr /&gt; &lt;h2&gt;Output: &#123;this.state.output&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; import React, &#123; Component &#125; from 'react';import Calculator from './Calculator';export default class Layout extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Basic Calculator&lt;/h1&gt; &lt;Calculator /&gt; &lt;/div&gt; ); &#125;&#125; Và đây là DOM thật sau lần load đầu tiên Còn đây là DOM ảo mà React tạo ra tương ứng với DOM thật bên trên. Trong React, nó cũng được gọi là một Component với tree structure gồm các Component con bên trong Sau đây, chúng ta sẽ cùng thử nhập vào 2 số và click vào button Add và xem React xử lí như thế nào nhé. 1234Input 1: 100Input 2: 50Output mong đợi sẽ là 150. Điều gì xảy ra khi ta click vào button Add? Ở ví dụ này, chúng ta set output là một state, vì thế khi một output mới được hiện ra nghĩa là ta đã set cho State đó một giá trị mới đó là 150. Đánh dấu Component dirty Trong React, khi một Component có một state mới được set, React đánh dấu nó như là một dirty Component, nghĩa là mỗi khi chúng ta gọi tới function setState() thì Component đó sẽ được đánh dấu là dirty. Cụ thể ở đây, khi ta click Add, React sẽ đánh dấu Component Calculator như thế nào: Tất cả các event khi ta thao tác với DOM, nó được gói trọn trong React event listener. Vì thế khi nút Add được click, event đó được gửi tới React event listener và sau đó nó sẽ chạy một anonymous function() Trong anonymous function(), chúng ta gọi tới function this.setState với một state value mới. Function this.setState() được chạy, Component Calculator được đánh dấu là dirty. 12//ReactUpdates.js - enqueueUpdate(component) functiondirtyComponents.push(component); Và hiện tại, Calculator của chúng ta đã được đánh dấu là dirty. Cùng xem những gì sẽ diễn ra tiếp theo Chạy qua Component lifecycleComponent lifecycle trong React là một loạt các hàm mặc định sẽ được chạy ngay trước, trong và ngay sau quá trình update một Component. Ở ví dụ này, chúng ta không overwrite các hàm đó thì nó sẽ chạy ở các giá trị mặc định. Quá trình update Component được diễn ra như sau: React sẽ kiểm tra Component đó có được mark dirty hay không, sau đó bắt đầu quá trình update. 123456//ReactUpdates.jsvar flushBatchedUpdates = function () &#123; while (dirtyComponents.length || asapEnqueued) &#123; if (dirtyComponents.length) &#123; var transaction = ReactUpdatesFlushTransaction.getPooled(); transaction.perform(runBatchedUpdates, null, transaction); Sau đó, React sẽ kiểm tra xem có pending state nào phải được update hay không hoặc có forceUpdate nào không 123if (this._pendingStateQueue !== null || this._pendingForceUpdate) &#123; this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context); Trong ví dụ này của chúng ta, trong Calculator wrapper, this.pendingStateQueue, chứa State object với giá trị Output mới 3. React chạy các lifecycle methods. Đầu tiên là componentWillReceiveProps(), tiếp đó là shouldComponentUpdate() (các phương thức này có giá trị mặc định thế nào nếu chúng ta không overwrite nó thì các bạn tự tìm hiểu nhé). Trong trường hợp này, method shouldComponentUpdate() sẽ trả về true, sau đó sẽ chạy componentWillUpdate(), render() và componentDidUpdate(). Thứ quan trọng nhất trong quá trình update ở đấy chính là render(), đó chính là chỗ mà DOM ảo được tạo lại và update DOM ảo để tìm ra sự khác biệt để sau đó cập nhật ở DOM thật, hay nói các khác là tìm ra cụ thể những element thay đổi để update chỉ những element đó trong DOM thật. Xây dựng lại Component, Update DOM ảo, tìm sự thay đổi, update DOM thật React sẽ kiểm tra các element trước và sau khi được render lại ở lần vừa rồi có giống nhau hay không, sau đó bắt đầu quá trình đồng bộ. 12var prevRenderedElement = this._renderedComponent._currentElement; var nextRenderedElement = this._instance.render(); //Calculator.render() method is called and the element is build. Quá trình đồng bộ và update DOM thật như sau: Những điểm màu đỏ nghĩa là quá trình đồng bộ sẽ được lặp lại đối với những thành phần con của nó. Và đây là DOM mà chúng ta nhận được sau quá trình đó : Trong ví dụ này, chỉ có phần Output bị thay đổi, bạn có thể nhìn thấy phần được đánh dấu flash ở hình dưới, chỉ có phần đó được DOM thật re-painted Và cây component được cập nhật tại DOM thực tế. Kết luậnQua ví dụ trên mong là bạn có thể hình dung phần nào đó cách thực hoạt động của DOM ảo trong React và tính hữu dụng của nó. Nhờ có DOM ảo, React có thể tìm ra các node bị thay đổi và update ở DOM thật chỉ ở những cái node đó, thật thuận tiện và nhanh gọn phải không nào.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Tìm Hiểu Regular Expression Javascript","slug":"Tim-Hieu-Regular-Expression-Javascript","date":"2018-05-25T14:38:00.000Z","updated":"2018-05-25T14:47:51.414Z","comments":true,"path":"2018/05/Tim-Hieu-Regular-Expression-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Tim-Hieu-Regular-Expression-Javascript.html","excerpt":"Regular expression hay còn được gọi tắt là Regex hay RegExp, là một cách để biểu diễn khuôn mẫu của string. Đây là một phần của ngôn ngữ lập trình JavaScript, cũng như nhiều ngôn ngữ lập trình khác. Nếu bạn là một lập trình viên và đã từng sử dụng Regular Expression thì bạn chắc hẳn sẽ thấy rằng nó có cú pháp rất kinh khủng và có phần “bí ẩn”. Tuy nhiên, công cụ này lại cực kì mạnh mẽ và hiệu quả khi dùng để xử lý string. Sau đây, chúng ta sẽ cùng tìm hiểu về Regular Expression trong JavaScript.","text":"Regular expression hay còn được gọi tắt là Regex hay RegExp, là một cách để biểu diễn khuôn mẫu của string. Đây là một phần của ngôn ngữ lập trình JavaScript, cũng như nhiều ngôn ngữ lập trình khác. Nếu bạn là một lập trình viên và đã từng sử dụng Regular Expression thì bạn chắc hẳn sẽ thấy rằng nó có cú pháp rất kinh khủng và có phần “bí ẩn”. Tuy nhiên, công cụ này lại cực kì mạnh mẽ và hiệu quả khi dùng để xử lý string. Sau đây, chúng ta sẽ cùng tìm hiểu về Regular Expression trong JavaScript. Khởi tạo Regular ExpressionCó hai cách để tạo ra một Regular Expression là: Sử dụng hàm khởi tạo của đối tượng RegExp Viết trực tiếp sử dụng cặp dấu “/ /“ 12var re1 = new RegExp(\"abc\");var re2 = /abc/; Cả hai cách trên ta đều thu được một Regular Expression biểu diễn một string có dạng: abc. Một số phương thức của Regular ExpressionPhương thức TestĐây là phương thức đơn giản nhất dùng để kiểm tra xem một string có chứa khuôn mẫu đã định nghĩa hay không. Nếu có thì kết quả trả về là TRUE và ngược lại thì là FALSE. 123456console.log(/abc/.test(\"abcde\"));// =&gt; trueconsole.log(/abc/.test(\"12abcde\"));// =&gt; trueconsole.log(/abc/.test(\"abxcde\"));// =&gt; false Trong ví dụ trên, 2 string “abcde” và “12abcde” đều chứa “abc” nên kết quả trả về là true. String còn lại “abxcde” không chứa “abc” nên kết quả là false. Kiểm tra trùng khớp với tập hợp các kí tựNếu chỉ kiểm tra như ví dụ trên thì bạn hoàn toàn có thể sử dụng phương thức indexOf của string thay vì sử dụng Regular Expression. Tuy nhiên, với Regular Expression thì bạn có thể kiểm tra những mẫu string phức tạp hơn. Ví dụ: 12345678console.log(/[0123456789]/.test(\"in 1992\"));// =&gt; trueconsole.log(/[0-9]/.test(\"in 1992\"));// =&gt; trueconsole.log(/[0-9]/.test(\"Hello \"));// =&gt; falseconsole.log(/[0-5]/.test(\"Gold 9999\"));// =&gt; false Ví dụ 1, 2, 3 kiểm tra xem string có chứa bất kì chữ số nào từ 0 đến 9. Ví dụ cuối cùng kiểm tra xem string có chứa bất kì chữ số nào từ 0 đến 5. JavaScript sử dụng cặp dấu ngoặc vuông [] để biểu thị việc kiểm tra string có chứa bất kì kí tự nào có trong cặp dấu [] hay không. Trong đó, dấu “-“ giữa hai kí tự dùng để chỉ 1 khoảng giữa hai kí tự đó. [0-9] là các chữ số từ 0 đến 9 [a-z] là các chữ cái từ a đến z Ngoài ra, JavaScript cung cấp sẵn một số cách biểu diễn một tập hợp các kí tự: \\d : bất kì chữ số nào từ 0 đến 9 \\w : một chữ cái \\s : kí tự trắng (dấu cách, tab, dòng mới,…) \\D : kí tự không phải số \\W : kí tự không phải chữ cái \\S : kí tự không phải kí tự trắng . : bất kì kí tự nào trừ dòng mới. Ví dụ kiểm tra ngày giờ có định dạng: dd-mm-yyyy hh:mm 12345var dateTime = /\\d\\d-\\d\\d-\\d\\d\\d\\d \\d\\d:\\d\\d/;console.log(dateTime.test(\"30-01-2003 15:20\"));// =&gt; trueconsole.log(dateTime.test(\"30-jan-2003 15:20\"));// =&gt; false Đảo ngược tập hợp các kí tựTrường hợp bạn muốn kiểm tra một string chứa bất kì kí tự nào không có trong tập hợp đã cho thì bạn có thể sử dụng kí tự “^”. Ví dụ: 12345var notBinary = /[^01]/;console.log(notBinary.test(\"1100100010100110\"));// =&gt; falseconsole.log(notBinary.test(\"1100100010200110\"));// =&gt; true Lặp lại khuôn mẫuTrong ví dụ về kiểm tra ngày giờ bên trên, “\\d” xuất hiện lặp lại rất nhiều lần. Điều này gây nên sự khó theo dõi. Do đó, JavaScript cung cấp cách thức để biểu diễn sự lặp lại khuôn mẫu: “+”: biểu thị phần tử xuất hiện &gt;= 1 lần 1234console.log(/'\\d+'/.test(\"'123'\"));// =&gt; trueconsole.log(/'\\d+'/.test(\"''\"));// =&gt; false “*”: biểu thị phần tử xuất hiện &gt;= 0 lần (có thể không xuất hiện) 1234console.log(/'\\d*'/.test(\"'123'\"));// =&gt; trueconsole.log(/'\\d*'/.test(\"''\"));// =&gt; true “?”: biểu thị phần tử xuất hiện 0 hoặc 1 lần 1234567var neighbor = /neighbou?r/;console.log(neighbor.test(\"neighbour\"));// =&gt; trueconsole.log(neighbor.test(\"neighbor\"));// =&gt; trueconsole.log(neighbor.test(\"neighbouur\"));// =&gt; false {n}: biểu thị phần tử xuất hiện đúng n lần 123456console.log(/\\d&#123;4&#125;/.test(\"1234\"));// =&gt; trueconsole.log(/\\d&#123;4&#125;/.test(\"12345\"));// =&gt; trueconsole.log(/\\d&#123;4&#125;/.test(\"123\"));// =&gt; false {x,y}: biểu thị phần tử xuất hiện từ x đến y lần 12345678910console.log(/\\d&#123;2,4&#125;/.test(\"12345\"));// =&gt; trueconsole.log(/\\d&#123;2,4&#125;/.test(\"1234\"));// =&gt; trueconsole.log(/\\d&#123;2,4&#125;/.test(\"123\"));// =&gt; trueconsole.log(/\\d&#123;2,4&#125;/.test(\"12\"));// =&gt; trueconsole.log(/\\d&#123;2,4&#125;/.test(\"1\"));// =&gt; false {x, }: biểu thị phần tử xuất hiện &gt;= x lần 123456console.log(/\\d&#123;2,&#125;/.test(\"12\"));// =&gt; trueconsole.log(/\\d&#123;2,&#125;/.test(\"1234\"));// =&gt; trueconsole.log(/\\d&#123;2,&#125;/.test(\"1\"));// =&gt; false Nhóm các phần tửTrong nhiều trường hợp bạn muốn lặp lại cả một nhóm các phần tử. Khi đó, bạn phải nhóm các phần tử đó lại sử dụng cặp dấu ngoặc đơn “( )”. 123var cartoonCrying = /boo+(hoo+)+/i;console.log(cartoonCrying.test(\"Boohoooohoohooo\"));// =&gt; true Lựa chọn khuôn mẫuTrường hợp bạn có nhiều khuôn mẫu và bạn cần kiểm tra xem string đưa ra chứa một trong các khuôn mẫu đó thì bạn có thể viết các Regular Expression tương ứng để kiểm tra. Hoặc sử dụng kí tự (|) để biểu diễn “hoặc”: 12345var animalCount = /\\d+ (pig|cow|chicken)s?/;console.log(animalCount.test(\"15 pigs\"));// =&gt; trueconsole.log(animalCount.test(\"15 pigchickens\"));// =&gt; false Phương thức ExecNếu như phương thức test chỉ kiểm tra xem có tồn tại khuôn mẫu hay không thì phương thức exec sẽ trả về một đối tượng chứa thông tin thành phần trùng khớp với khuôn mẫu, ngược lại thì trả về null. 12345var match = /\\d+/.exec(\"one two 100 200\");console.log(match);// =&gt; [\"100\", index: 8, input: \"one two 100 200\"]console.log(match.index);// =&gt; 8 Ví dụ trên trả về thành phần thoả mãn khuôn mẫu đầu tiên là: “100”. Index là vị trí đầu tiên của string thoả mãn khuôn mẫu. Khi Regular Expression chứa group với cặp dấu ngoặc đơn thì phần tử đầu tiên trong kết quả sẽ là toàn bộ thành phần trùng khớp, thành phần tiếp theo là phần trùng khớp với group đầu tiên, thành phần tiếp theo là phần trùng khớp với group thứ 2,… 123456789var quotedText = /'([^']*)'/;console.log(quotedText.exec(\"she said 'hello'\"));// =&gt; [\"'hello'\", \"hello\", index: 9, input: \"she said 'hello'\"]console.log(/bad(ly)?/.exec(\"bad\"));// =&gt; [\"bad\", undefined, index: 0, input: \"bad\"]console.log(/(\\d)+/.exec(\"123\"));// =&gt; [\"123\", \"3\", index: 0, input: \"123\"] Trích xuất dữ liệu từ stringPhương thức này đặc biệt hữu ích khi bạn muốn lấy thông tin ra từ string. Ví dụ sau đưa ra một string biểu diễn ngày, tháng, năm. Sau đó chúng ta sẽ trích xuất ra thông tin về ngày, tháng và năm ở trong đó: 123456789101112function findDate(string) &#123; var dateTime = /(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;4&#125;)/; var match = dateTime.exec(string); return &#123; day : match[1], month : match[2], year: match[3] &#125;&#125;var obj = findDate(\"30-1-2003\");console.log(obj);// =&gt; Object &#123;day: \"30\", month: \"1\", year: \"2003\"&#125; Ranh giới của stringTrong ví dụ trên, hàm findDate vẫn tìm ra kết quả nếu như string là “30-1-200300” hay “1130-1-2003”,… Đây là trường hợp không mong muốn. Regular Expression JavaScript cung cấp 2 cách để giải quyết vấn đề này: Sử dụng kí tự biểu diễn bắt đầu (^) và kết thúc ($$ string 123456789101112131415161718192021function findDate(string) &#123; var dateTime = /^(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;4&#125;)$/; var match = dateTime.exec(string); if(!match) return null; return &#123; day : match[1], month : match[2], year: match[3] &#125;&#125;var obj1 = findDate(\"30-1-2003\");console.log(obj1);// =&gt; Object &#123;day: \"30\", month: \"1\", year: \"2003\"&#125;var obj2 = findDate(\"0030-1-200300\");console.log(obj2);// =&gt; nullvar obj3 = findDate(\"Hello 30-1-2003 Haha\");console.log(obj3);// =&gt; null Sử dụng kí tự biên (\\b) 123456789101112131415161718192021function findDate(string) &#123; var dateTime = /\\b(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;4&#125;)\\b/; var match = dateTime.exec(string); if(!match) return null; return &#123; day : match[1], month : match[2], year: match[3] &#125;&#125;var obj1 = findDate(\"30-1-2003\");console.log(obj1);// =&gt; Object &#123;day: \"30\", month: \"1\", year: \"2003\"&#125; var obj2 = findDate(\"0030-1-200300\");console.log(obj2);// =&gt; nullvar obj3 = findDate(\"Hello 30-1-2003 Haha\");console.log(obj3);// =&gt; Object &#123;day: \"30\", month: \"1\", year: \"2003\"&#125; Tạo đối tượng RegExp một cách linh độngTrong nhiều trường hợp, bạn muốn tạo ra một Regular Expression với nội dung chưa được biết trước. Bạn có thể sử dụng hàm khởi tạo của RegExp theo cách sau: 12345var name = \"lampv\";var text = \"LamPV is a suspicious character.\";var regexp = new RegExp(\"\\\\b(\" + name + \")\\\\b\", \"gi\");console.log(text.replace(regexp, \"_$1_\"));// =&gt; _LamPV_ is a suspicious character. Trong đó: tham số g: chỉ ra rằng khuôn mẫu áp dụng Global, nghĩa là nó áp dụng cho tất cả thành phần trùng khớp. tham số i: chỉ ra rằng khuôn mẫu không phân biệt chữ hoa và chữ thường. Ngoài ra, ở đây tôi có sử dụng phương thức replace của string - dùng để thay thế tất cả những thành phần trùng khớp với khuôn mẫu với “_$1_”. Ở đây $$ chính là nội dung của group thứ nhất. Kết luậnTrên đây là một số kiến thức cơ bản về Regular Expression. Hy vọng qua bài viết này bạn phần nào hiểu và biết cách sử dụng công cụ hiệu quả này trong công việc lập trình của mình, đặc biệt là lập trình JavaScript. Tóm tắt một số khuôn mẫu cơ bản của Regular Expression: /abc/ : chuỗi các kí tự abc /[abc]: bất kỳ kí tự nào thuộc tập hợp a, b, c /[^abc]: bất kỳ kí tự nào không thuộc tập a, b, c /[0-9]/: bất kỳ kí tự nào thuộc đoạn từ 0 đến 9 /x+/: thành phần x xuất hiện &gt;= 1 lần /x*/: thành phần x xuất hiện &gt;= 0 lần (có thể không xuất hiện) /x?/: thành phần x xuất hiện 0 hoặc 1 lần /x{2, 4}/: thành phần x xuất hiện từ 2 đến 4 lần /(abc)/: cụm abc /a|b|c/: bất kì pattern nào trong 3 loại a, b, c /\\d/: chữ số từ 0 đến 9 /\\w/: chữ cái /\\s/: kí tự trắng (dấu cách, tab, dòng mới,…) /./ : bất kỳ kí tự nào trừ dòng mới /\\b/: ranh giới từ /^/: bắt đầu string /$$: kết thúc string Tham khảo http://eloquentjavascript.net/09_regexp.html Bài thực hành của tôi: Regexp Golf, Quoting style, Numbers again. Xác thực mã màu RGB và mã màu HEX sử dụng Regex trong Javascript","categories":[],"tags":[{"name":"regex","slug":"regex","permalink":"http://nthung2112.github.io/tags/regex/"}]},{"title":"Giới thiệu về Composing Software","slug":"Gioi-thieu-ve-Composing-Software","date":"2018-05-22T01:09:00.000Z","updated":"2018-05-25T15:58:41.743Z","comments":true,"path":"2018/05/Gioi-thieu-ve-Composing-Software.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Gioi-thieu-ve-Composing-Software.html","excerpt":"Ghi chú: Đây là phần giới thiệu về loạt bài “Composing Software” về việc học các kỹ năng functional programming và compositional software trong JavaScript ES6+ từ đầu. Hãy theo dõi còn rất nhiều thứ khác nữa!Bài viết Kế tiếp &gt;","text":"Ghi chú: Đây là phần giới thiệu về loạt bài “Composing Software” về việc học các kỹ năng functional programming và compositional software trong JavaScript ES6+ từ đầu. Hãy theo dõi còn rất nhiều thứ khác nữa!Bài viết Kế tiếp &gt;Composition: “Hành động kết hợp các parts hoặc elements để tạo thành một tổng thể.” Trong lớp học lập trình đầu tiên của tôi, tôi đã nói rằng phát triển phần mềm là “hành động phá vỡ một vấn đề phức tạp thành các vấn đề nhỏ hơn, và soạn các giải pháp đơn giản để tạo thành một giải pháp hoàn chỉnh cho vấn đề phức tạp.” Một trong những hối tiếc lớn nhất của tôi trong cuộc sống là tôi đã không hiểu ý nghĩa của bài học đó từ sớm. Tôi đã học được bản chất của thiết kế phần mềm quá muộn trong cuộc sống. Tôi đã phỏng vấn hàng trăm developers. Những gì tôi đã học được từ những buổi đó là Tôi không đơn độc. Rất ít developers phần mềm làm việc mà có nắm bắt tốt về bản chất của phát triển phần mềm. Họ không nhận thức được các công cụ quan trọng nhất chúng ta có thể có để xử lý hoặc làm thế nào để đưa chúng vào sử dụng cho tốt. 100% đã đấu tranh để trả lời một hoặc cả hai câu hỏi quan trọng nhất trong lĩnh vực phát triển phần mềm: What is function composition? What is object composition? Vấn đề là bạn không thể tránh được ‘composition’ chỉ vì bạn không biết về nó. Bạn vẫn làm điều đó - nhưng bạn làm điều đó rất tệ. Bạn viết mã với nhiều lỗi hơn và làm cho các developers khác khó hiểu hơn. Đây là một vấn đề lớn. Các ảnh hưởng ấy tốn nhất nhiều chi phí. Chúng tôi dành nhiều thời gian hơn để duy trì phần mềm hơn là chúng tôi tạo ra nó từ đầu và các lỗi của chúng tôi tác động đến hàng tỷ người trên khắp thế giới. Cả thế giới chạy trên phần mềm ngày nay. Mỗi chiếc xe mới là một siêu máy tính mini trên bánh xe, và các vấn đề với thiết kế phần mềm gây ra tai nạn thực sự và chi phí cuộc sống thực của con người. Vào năm 2013, Ban giám khảo đã tìm thấy nhóm phát triển phần mềm của Toyota có tội “Liều lĩnh không để ý” sau khi một cuộc điều tra tai nạn cho thấy spaghetti code với 10000 biến global. Hackers và governments stockpile bugs để theo dõi mọi người, ăn cắp thẻ tín dụng, khai thác tài nguyên máy tính để khởi chạy các cuộc tấn công từ chối dịch vụ phân tán (DDoS), crack mật khẩu và thậm chí điều khiển cuộc bầu cử. Chúng ta phải làm tốt hơn. You Compose Software Every DayNếu bạn là nhà phát triển phần mềm, bạn lập trình các chức năng và cấu trúc dữ liệu mỗi ngày, cho dù bạn có biết hay không. Bạn có thể làm điều đó một cách có ý thức (và tốt hơn), hoặc bạn có thể làm điều đó một cách vô tình, with duct-tape and crazy glue. Quá trình phát triển phần mềm là chia nhỏ các vấn đề lớn thành các vấn đề nhỏ hơn, xây dựng các thành phần giải quyết những vấn đề nhỏ hơn, sau đó kết hợp các thành phần lại với nhau để tạo thành một ứng dụng hoàn chỉnh. Composing FunctionsFunction composition là quá trình áp dụng một function là output của function khác. Trong đại số, có hai hàm số, f và g, (f ∘ g)(x) = f(g(x)). Vòng tròn là toán tử kết hợp. Nó thường được phát âm “kết hợp với” hoặc là “theo sau”. Bạn có thể nói như “f kết hợp với g bằng f of g of x”, or “f theo sau g bằng f of g of x”. Chúng ta nói f theo sau g bởi vì g is giá trị đầu, sau đó output của nó được chuyển thành đối số f. Mỗi lần bạn viết code như thế này, nó là composing functions: 12345678const g = n =&gt; n + 1;const f = n =&gt; n * 2;const doStuff = x =&gt; &#123; const afterG = g(x); const afterF = f(afterG); return afterF;&#125;;doStuff(20); // 42 Mỗi khi bạn viết một chuỗi promise, nó là composing functions: 1234567891011121314const g = n =&gt; n + 1;const f = n =&gt; n * 2;const wait = time =&gt; new Promise( (resolve, reject) =&gt; setTimeout( resolve, time ));wait(300) .then(() =&gt; 20) .then(g) .then(f) .then(value =&gt; console.log(value)) // 42; Tương tự như vậy, mỗi khi bạn thực hiện các gọi các chuỗi phương thức mảng, các hàm lodash, observables (RxJS, etc…) nó là composing functions. Nếu là một chuỗi, thì nó là composing. Nếu bạn chuyển một giá trị trả về vào những functions khác, nó cũng là composing. Nếu bạn gọi hai hàm theo trình tự, nó là composing nếu sử dụng dữ liệu hàm này làm dữ liệu đầu vào cho hàm kia. Nếu là một chuỗi, thì nó là composing. Khi bạn viết một functions có chủ ý, bạn sẽ làm tốt hơn. Composing functions có chủ ý, chúng ta có thể cải thiện hàm doStuff() thành 1 dòng đơn giản: 1234const g = n =&gt; n + 1;const f = n =&gt; n * 2;const doStuffBetter = x =&gt; f(g(x));doStuffBetter(20); // 42 Một trong những phản đối chung về kiểu này là khó để debug. Ví dụ, chúng ta sẽ viết function composition bằng cách nào? 12345678910111213const doStuff = x =&gt; &#123; const afterG = g(x); console.log(`after g: $&#123; afterG &#125;`); const afterF = f(afterG); console.log(`after f: $&#123; afterF &#125;`); return afterF;&#125;;doStuff(20); // =&gt;/*\"after g: 21\"\"after f: 42\"*/ Đầu tiên, hãy trừu tượng rằng “after f”, “after g” và viết vào một tiện ích nhỏ gọi là trace(): 1234const trace = label =&gt; value =&gt; &#123; console.log(`$&#123; label &#125;: $&#123; value &#125;`); return value;&#125;; Now we can use it like this: 12345678910111213const doStuff = x =&gt; &#123; const afterG = g(x); trace('after g')(afterG); const afterF = f(afterG); trace('after f')(afterF); return afterF;&#125;;doStuff(20); // =&gt;/*\"after g: 21\"\"after f: 42\"*/ Thư viện functional programming phổ biến như Lodash và Ramda bao gồm các tiện ích để thực hiện function composition dễ hơn. Bạn có thể viết lại hàm trên như thế này: 12345678910111213import pipe from 'lodash/fp/flow';const doStuffBetter = pipe( g, trace('after g'), f, trace('after f'));doStuffBetter(20); // =&gt;/*\"after g: 21\"\"after f: 42\"*/ If you want to try this code without importing something, you can define pipe like this:Nếu bạn muốn thử code này mà không cần nhập gì, bạn có thể xác định pipe như thế này: 12// pipe(...fns: [...Function]) =&gt; x =&gt; yconst pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x); Đừng lo lắng nếu bạn chưa thể theo dõi cách hoạt động. Sau đó, chúng tôi sẽ khám phá function composition chi tiết hơn. In fact, it’s so essential, you’ll see it defined and demonstrated many times throughout this text. The point is to help you become so familiar with it that its definition and usage becomes automatic. Be one with the composition. pipe() creates a pipeline of functions, passing the output of one function to the input of another. When you use pipe() (and its twin, compose()) You don’t need intermediary variables. Writing functions without mention of the arguments is called point-free style. To do it, you’ll call a function that returns the new function, rather than declaring the function explicitly. That means you won’t need the function keyword or the arrow syntax (=&gt;). Point-free style can be taken too far, but a little bit here and there is great because those intermediary variables add unnecessary complexity to your functions. There are several benefits to reduced complexity: Working MemoryBộ não con người trung bình chỉ có một vài tài nguyên được chia sẻ cho lượng tử rời rạc trong bộ nhớ làm việc working memory, và mỗi biến có khả năng tiêu thụ một trong những lượng tử đó. As you add more variables, our ability to accurately recall the meaning of each variable is diminished. Working memory models typically involve 4–7 discrete quanta. Above those numbers, error rates dramatically increase. Using the pipe form, we eliminated 3 variables — freeing up almost half of our available working memory for other things. That reduces our cognitive load significantly. Software developers tend to be better at chunking data into working memory than the average person, but not so much more as to weaken the importance of conservation. Signal to Noise RatioConcise code also improves the signal-to-noise ratio of your code. It’s like listening to a radio — when the radio is not tuned properly to the station, you get a lot of interfering noise, and it’s harder to hear the music. When you tune it to the correct station, the noise goes away, and you get a stronger musical signal. Code is the same way. More concise code expression leads to enhanced comprehension. Some code gives us useful information, and some code just takes up space. If you can reduce the amount of code you use without reducing the meaning that gets transmitted, you’ll make the code easier to parse and understand for other people who need to read it. Surface Area for BugsTake a look at the before and after functions. It looks like the function went on a diet and lost a ton of weight. That’s important because extra code means extra surface area for bugs to hide in, which means more bugs will hide in it. Less code = less surface area for bugs = fewer bugs. Composing Objects “Favor object composition over class inheritance” the Gang of Four, “Design Patterns: Elements of Reusable Object Oriented Software” “In computer science, a composite data type or compound data type is any data type which can be constructed in a program using the programming language’s primitive data types and other composite types. […] The act of constructing a composite type is known as composition.” ~ Wikipedia These are primitives: 12const firstName = 'Claude';const lastName = 'Debussy'; And this is a composite: 1234const fullName = &#123; firstName, lastName&#125;; Likewise, all Arrays, Sets, Maps, WeakMaps, TypedArrays, etc… are composite datatypes. Any time you build any non-primitive data structure, you’re performing some kind of object composition. Note that the Gang of Four defines a pattern called the composite pattern which is a specific type of recursive object composition which allows you to treat individual components and aggregated composites identically. Some developers get confused, thinking that the composite pattern is the only form of object composition. Don’t get confused. There are many different kinds of object composition. The Gang of Four continues, “you’ll see object composition applied again and again in design patterns”, and then they catalog three kinds of object compositional relationships, including delegation (as used in the state, strategy, and visitor patterns), acquaintance (when an object knows about another object by reference, usually passed as a parameter: a uses-a relationship, e.g., a network request handler might be passed a reference to a logger to log the request — the request handler uses a logger), and aggregation (when child objects form part of a parent object: a has-a relationship, e.g., DOM children are component elements in a DOM node — A DOM node has children). Class inheritance can be used to construct composite objects, but it’s a restrictive and brittle way to do it. When the Gang of Four says “favor object composition over class inheritance”, they’re advising you to use flexible approaches to composite object building, rather than the rigid, tightly-coupled approach of class inheritance. We’ll use a more general definition of object composition from “Categorical Methods in Computer Science: With Aspects from Topology” (1989): “Composite objects are formed by putting objects together such that each of the latter is ‘part of’ the former.” Another good reference is “Reliable Software Through Composite Design”, Glenford J Myers, 1975. Both books are long out of print, but you can still find sellers on Amazon or eBay if you’d like to explore the subject of object composition in more technical depth. Class inheritance is just one kind of composite object construction. All classes produce composite objects, but not all composite objects are produced by classes or class inheritance. “Favor object composition over class inheritance” means that you should form composite objects from small component parts, rather than inheriting all properties from an ancestor in a class hierarchy. The latter causes a large variety of well-known problems in object oriented design: The tight coupling problem: Because child classes are dependent on the implementation of the parent class, class inheritance is the tightest coupling available in object oriented design. The fragile base class problem: Due to tight coupling, changes to the base class can potentially break a large number of descendant classes — potentially in code managed by third parties. The author could break code they’re not aware of. The inflexible hierarchy problem: With single ancestor taxonomies, given enough time and evolution, all class taxonomies are eventually wrong for new use-cases. The duplication by necessity problem: Due to inflexible hierarchies, new use cases are often implemented by duplication, rather than extension, leading to similar classes which are unexpectedly divergent. Once duplication sets in, it’s not obvious which class new classes should descend from, or why. The gorilla/banana problem: “…the problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.” ~ Joe Armstrong, “Coders at Work” The most common form of object composition in JavaScript is known as object concatenation (aka mixin composition). It works like ice-cream. You start with an object (like vanilla ice-cream), and then mix in the features you want. Add some nuts, caramel, chocolate swirl, and you wind up with nutty caramel chocolate swirl ice cream. Building composites with class inheritance: 123456789101112class Foo &#123; constructor () &#123; this.a = 'a' &#125;&#125;class Bar extends Foo &#123; constructor (options) &#123; super(options); this.b = 'b' &#125;&#125;const myBar = new Bar(); // &#123;a: 'a', b: 'b'&#125; Building composites with mixin composition: 1234567const a = &#123; a: 'a'&#125;;const b = &#123; b: 'b'&#125;;const c = &#123;...a, ...b&#125;; // &#123;a: 'a', b: 'b'&#125; We’ll explore other styles of object composition in more depth later. For now, your understanding should be: There’s more than one way to do it. Some ways are better than others. You want to select the simplest, most flexible solution for the task at hand. ConclusionThis isn’t about functional programming (FP) vs object-oriented programming (OOP), or one language vs another. Components can take the form of functions, data structures, classes, etc… Different programming languages tend to afford different atomic elements for components. Java affords classes, Haskell affords functions, etc… But no matter what language and what paradigm you favor, you can’t get away from composing functions and data structures. In the end, that’s what it all boils down to. We’ll talk a lot about functional programming, because functions are the simplest things to compose in JavaScript, and the functional programming community has invested a lot of time and effort formalizing function composition techniques. What we won’t do is say that functional programming is better than object-oriented programming, or that you must choose one over the other. OOP vs FP is a false dichotomy. Every real Javascript application I’ve seen in recent years mixes FP and OOP extensively. We’ll use object composition to produce datatypes for functional programming, and functional programming to produce objects for OOP. No matter how you write software, you should compose it well. The essence of software development is composition. A software developer who doesn’t understand composition is like a home builder who doesn’t know about bolts or nails. Building software without awareness of composition is like a home builder putting walls together with duct tape and crazy glue. It’s time to simplify, and the best way to simplify is to get to the essence. The trouble is, almost nobody in the industry has a good handle on the essentials. We as an industry have failed you, the software developer. It’s our responsibility as an industry to train developers better. We must improve. We need to take responsibility. Everything runs on software today, from the economy to medical equipment. There is literally no corner of human life on this planet that is not impacted by the quality of our software. We need to know what we’re doing. It’s time to learn how to compose software. Continued in “The Rise and Fall and Rise of Functional Programming”","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"hof","slug":"hof","permalink":"http://nthung2112.github.io/tags/hof/"}]},{"title":"Sử dụng ký pháp BEM trong CSS","slug":"Su-dung-ky-phap-BEM-trong-CSS","date":"2018-05-20T09:05:00.000Z","updated":"2018-05-20T09:16:00.943Z","comments":true,"path":"2018/05/Su-dung-ky-phap-BEM-trong-CSS.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Su-dung-ky-phap-BEM-trong-CSS.html","excerpt":"Ký pháp BEM là gìBEM viết tắt của Blocks, Elements, Modifiers, là một phương pháp đặt tên class cho HTML và CSS. Được phát triển tại Yandex giúp lập trình viên hiểu rõ hơn mối quan hệ giữa HTML và CSS trong dự án front end.","text":"Ký pháp BEM là gìBEM viết tắt của Blocks, Elements, Modifiers, là một phương pháp đặt tên class cho HTML và CSS. Được phát triển tại Yandex giúp lập trình viên hiểu rõ hơn mối quan hệ giữa HTML và CSS trong dự án front end.Ví dụ sau đây sẽ minh hoạ cách sử dụng ký pháp BEM: 123456789/* Một Block (khối) độc lập */.btn &#123;&#125;/* Element (phần tử) con, phụ thuộc vào Block ở trên */.btn__price &#123;&#125;/* Modifier (bộ điều chỉnh) thay đổi trạng thái của Block */.btn--orange &#123;&#125;.btn--big &#123;&#125; Với cách đặt tên class này, ta có Block sẽ đại diện cho một component, và trong ví dụ ở đây, là một button .btn. Block cũng sẽ đóng vai trò là một parent mà trong nó sẽ có một hoặc nhiều hơn Element con liên quan. Tên class cho Element và mối quan hệ của nó với Block sẽ được diễn tả bằng tên của Block, tiếp theo là hai gạch dưới, và cuối cùng là tên của Element .btn__price. Thành phần thứ ba của BEM là các Modifier mà chúng sẽ giúp điều chỉnh các trạng thái hoặc phái sinh khác của Block / Element. Tên của Modifier sẽ được nối với tên Block / Element phía trước bởi 02 gạch ngang .btn--orange. Trong HTML, ký pháp BEM sẽ được dùng như sau: 1234&lt;a class=\"btn btn--big btn--orange\" href=\"http://int3ractive.com\"&gt; &lt;span class=\"btn__price\"&gt;$9.99&lt;/span&gt; &lt;span class=\"btn__text\"&gt;Subscribe&lt;/span&gt;&lt;/a&gt; Ấn tượng đầu tiên với bạn có thể là tên class quá xấu và mất thời gian hơn so với việc tạo riêng một class mới cho một kiểu button mới. Tuy nhiên, ký pháp BEM sẽ mang lại nhiều lợi ích mà tôi sẽ phân tích tiếp theo sau đây: Tại sao sử dụng ký pháp BEMTrước tiên, ký pháp BEM giúp người mới tham gia dự án dễ dàng phát hiện ra các trạng thái và các đối tượng con của một component đã được viết sẵn. Điều này giúp tránh cho họ phải viết lại những kiểu CSS đã có sẵn và hạn chế việc viết thừa code hoặc trùng kiểu CSS, điều mà rất hay xảy ra trong dự án lớn có nhiều người tham gia. Thứ hai, chỉ cần đọc HTML, bạn vẫn có thể nhanh chóng nắm được các thành phần phụ thuộc lẫn nhau. Trong ví dụ trên, bạn dễ dàng nhìn thấy .btn__price phụ thuộc vào .btn mặc dù bạn chưa biết vai trò cụ thể của nó ngay lập tức. Thứ ba, với ký pháp BEM, mọi định nghĩa chỉ có một cấp class và không lồng cấp. Điều này giúp cho độ ưu tiên (specificity) chung của hệ thống CSS thấp. Đây là một lợi thế vì sau này bạn không phải “chiến đấu” với specificity của những thuộc tính đã có sẵn (VD: siêu lồng cấp .a .b .c .d .e {...}) cũng như vận dụng những kỹ thuật không hay để thay thế được style (chẳng hạn !important hay inline CSS). Quy luật thác nước cascading của CSS là con dao hai lưỡi: nó giúp dễ dàng định nghĩa những thuộc tính và kiểu chung trên những selector tổng quát mà không cần phải khai báo lặp lại trên từng phần tử, nhưng nếu không nắm được tầm ảnh hưởng, lập trình viên CSS rất dễ gây ra những tác động phụ đến các đối tượng không liên quan khi chỉnh sửa trên những class có sẵn hoặc thậm chí viết mới. Với ký pháp BEM, lập trình viên sẽ tự tin hơn khi bắt tay chỉnh sửa hoặc viết thêm style vì đã biết rõ tầm ảnh hưởng của selector mà mình đang viết ra. Tóm lại, ký pháp BEM, nếu áp dụng triệt để, sẽ giúp cải thiện sự phối hợp giữa các thành viên trong nhóm. Ngoài ra, nó buộc người viết CSS phải đầu tư suy nghĩ về việc xây dựng những component độc lập và tái sử dụng được (phù hợp với tiêu chí của OOCSS). Sử dụng BEM với SASSVới phiên bản SASS mới nhất hiện nay, việc viết theo ký pháp BEM trong SCSS dễ dàng và thuận tiện hơn bao giờ hết. Bạn vẫn sẽ sử dụng cách viết lồng để cô lập khối component và kết hợp với biểu tượng parent &amp; của SASS để đặt tên cho Element và Modifier mà không phải đánh lại tên của Block. VD: 123456.block &#123; &amp;__element &#123;&#125; &amp;--mod &#123;&#125;&#125; Mặc dù viết lồng cấp, khi được biên dịch thành CSS, chúng vẫn được trải phẳng thành một cấp class theo đúng tinh thần của BEM: 12345.block &#123;&#125;.block__element &#123;&#125;.block--mod &#123;&#125; Nếu bạn sử dụng LibSass (nhanh hơn rất nhiều lần bản gốc Ruby) để biên dịch SASS, thì hãy đảm bảo các công cụ wrapper được cập nhật các phiên bản tương đương hoặc mới hơn như sau: node-sass 3.4.0, gulp-sass 2.1.0 (nếu sử dụng GulpJS) và grunt-sass 1.1.0 (nếu sử dụng GruntJS) Thế còn LESS? Vì tôi không sử dụng LESS nên sẽ không đề cập ở đây. Bạn có thể giúp bổ sung hướng dẫn cho LESS nếu nó có cú pháp trợ giúp tương đương. Các ý kiến không đồng tìnhVẫn có một số ý kiến hoài nghi và không đồng tình với phương pháp đặt tên này. Tên class quá xấuĐồng ý với bạn rằng BEM trông kỳ quặc, tuy nhiên khả năng mà nó đem lại vô cùng lớn và sẽ hoàn toàn xoá mờ hạn chế về mặt “ngoại hình” của nó. Ngoài ra BEM đòi hỏi phải gõ nhiều chữ hơn và chiếm nhiều byte ký tự hơn, tuy nhiên với việc sử dụng SASS như trên và việc gzip file đã trở thành tiêu chuẩn như hiện nay, những điều đó không còn là vấn đề so với lợi ích mà BEM mang lại. Descendant selector vẫn giải quyết được vấn đề như trước giờCó một chỉ trích dành cho BEM thế này: Thay vì viết 123.site-search &#123;&#125;.site-search__field &#123;&#125;.site-search--full &#123;&#125; Họ đặt vấn đề rằng tại sao không viết như thế này: 123.site-search &#123;&#125;.site-search input &#123;&#125;.site-search.full &#123;&#125; Rõ ràng cả hai cách viết đều có thể giúp hiện thực được component cụ thể này và cách thứ hai có vẻ “gọn gàng” hơn. Tuy nhiên khi CSS của toàn bộ dự án trở nên lớn và phức tạp hơn, thì rất khó tránh khỏi các kiểu được định nghĩa chồng chéo lên nhau ngoài tầm kiểm soát. Thử tưởng tượng .site-search cũng nằm trong một container tên .main và những input bên trong .main cần được style với .main input. Như vậy, input bên trong .site-search sẽ bị điều chỉnh một cách không mong muốn. Tương tự, nếu như .full trong ví dụ trên hoặc một tên phổ biến như .label được dùng như modifier, thì sẽ có rủi ro (rất cao) là một ngày nào đó một lập trình viên khác định nghĩa một class global trùng tên và sẽ làm hỏng style của element kia. Ngoài ra, khi bạn đọc trong ngữ cảnh HTML, bạn sẽ khó thấy được quan hệ ràng buộc giữa input và .full với block .site-search. “Tôi đơn giản là không thích ký pháp này”Một số người khi nhìn thấy cách đặt tên BEM đã ngay lập tức bác bỏ nó. Họ không thích BEM, đó là quyền của họ, tuy nhiên sẽ là vô lý nếu phản bác việc cần có một số quy tắc đặt tên để dễ dàng nắm bắt và quản lý CSS trong dự án trung và lớn. Hơn nữa, bạn hoàn toàn có thể nghĩ ra cho mình một cách đặt tên khác cho hợp sở thích, nhưng vẫn dựa trên nguyên tắc của BEM đã đề ra. Là kết quả đúc kết từ những kiến trúc CSS lớn và phức tạp trước đây, đề xuất của BEM không phải vô tình lại có một số điểm chung với các phương pháp quản lý CSS khác như SMACSS hay OOCSS. Lấy ví dụ khái niệm module của SMACSS: 12345678/* Ví dụ một module */.btn &#123; &#125;/* Modifier của một module */.btn-primary &#123; &#125;/* Btn Module với State */.btn.is-collapsed &#123; &#125; Trong các phương pháp quản lý CSS vừa kể trên thì chỉ có BEM là làm rõ được mối quan hệ với các thành phần con bên trong. Tóm lại, mỗi phương pháp đều có ưu nhược điểm. Quan trọng là cả team phải có phương pháp tiếp cận khoa học và áp dụng triệt để thì kiến trúc CSS của cả dự án mới vững và dễ bảo trì. Câu hỏi thường gặp:❓Hỏi: Element có modifier hay không?💬️ Đáp: Có. Element có thể có modifier riêng của nó. Ví dụ: 123.accordion__copy--open &#123; display: block;&#125; ❓Hỏi: Có cần phải đặt tên class cho tất cả element (thẻ HTML) trong block hay không?💬️ Đáp: Không cần thiết, chỉ những element cần có style riêng được viết trong CSS. Tuy nhiên cũng không nên lạm dụng những thẻ wrapper (phổ biến nhất là DIV) một cách vô tội vạ và không có chức năng vai trò cụ thể nào. Như vậy việc đặt tên element con cũng khiến bạn phải suy nghĩ một tag nào đó có thật sự cần thiết thêm vào trong block hay không. ❓Hỏi: Bên trong element con foo có một tag đóng vai trò một element con bar khác của block, vậy việc đặt tên class cho element bar này như thế nào? Có nên đặt là .block__foo__bar?💬️ Đáp: Vẫn đặt bằng tên block và hai gạch dưới rồi đến tên element .block__bar, không chen giữa bằng foo__. Nói tóm lại, tên của element chỉ cần thể hiện quan hệ phụ thuộc với block, không cần phải chỉ rõ sự lồng bên trong nhau của các element con. (Xem thêm ví dụ trong câu hỏi tiếp theo) ❓Hỏi: Một thẻ HTML có thể là element của 2 block khác nhau không?💬️ Đáp: Hoàn toàn có thể. Hãy xem ví dụ sau: 1234&lt;a class=\"btn btn--big btn--orange\" href=\"http://int3ractive.com\"&gt; &lt;span class=\"btn__price\"&gt;&lt;i class=\"icon icon--dollar-sign btn__icon\"&gt;&lt;/i&gt;9.99&lt;/span&gt; &lt;span class=\"btn__text\"&gt;Subscribe&lt;/span&gt;&lt;/a&gt; Button có biểu tượng dollar-sign là một block .icon. Có thể trong block .btn, biểu tượng dollar-sign cần được style riêng, nên cần có một cái tên xác định rõ vai trò và style cho element này là .btn__icon. Nếu block .icon.icon--dollar-sign được dùng ở một ngữ cảnh khác, thì rõ ràng nó không cần class .btn__icon nữa vì tên class đã chỉ rõ sự ràng buộc với block .btn và chỉ được thêm vào khi ở bên trong nó. ❓Hỏi: Một element con có thể đóng vai trò là block của riêng nó không? Có thể xây dựng chuỗi component phụ thuộc nhau như .a__b__c không?💬️ Đáp: Câu hỏi này thật sự ngoài tầm hiểu biết và kinh nghiệm của tôi. Có thể có những hoàn cảnh đặt biệt như vậy. Tuy nhiên, theo tôi, nếu có cũng không nên quá 2 cấp, tức là element con chỉ đặt đến .a__b__c là tối đa. Điều này là để sự phụ thuộc không quá sâu, làm giảm khả năng dùng lại của block (portability) và sự linh hoạt của các đối tượng CSS theo tinh thần OOCSS. Xem ví dụ bên dưới. 1234567/* block list */.list &#123; &#125;/* item là con của list */.list__item &#123; &#125;/* link là con của block list__item, để phân biệt với list__linkhoặc chỉ rõ mối quan hệ phụ thuộc giữa item và link*/.list__item__link &#123; &#125; Sai lầm hay mắc phải khi sử dụng BEM:Tôi xin hẹn lại về vấn đề này trong một bài viết khác, khi mà bản thân đã ứng dụng nhiều và quan sát được những ví dụ thực tiễn hơn để tổng hợp những sai lầm hay mắc phải do ảnh hưởng từ phương pháp cũ cũng như cách hiểu chưa đúng về phương pháp BEM này. Xem thêm: Bài viết giới thiệu BEM của CSSWizadry Bài viết giới thiệu BEM của Smashing Magazine Sử dụng BEM và @extend của SASS Bài viết 5 sai lầm phổ biến với BEM","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"}]},{"title":"Giới thiệu Progressive Web App","slug":"Gioi-thieu-Progressive-Web-App","date":"2018-05-18T00:30:00.000Z","updated":"2018-05-18T00:43:05.756Z","comments":true,"path":"2018/05/Gioi-thieu-Progressive-Web-App.html","link":"","permalink":"http://nthung2112.github.io/2018/05/Gioi-thieu-Progressive-Web-App.html","excerpt":"Progressive Web App (PWA) là một dạng ứng dụng web (web app) mới đang thu hút rất nhiều sự quan tâm từ các nhà phát triển web khắp thế giới đặc biệt là các doanh nghiệp hoạt động trực tuyến, tuy nhiên nó vẫn còn khá mới mẻ tại Việt Nam.","text":"Progressive Web App (PWA) là một dạng ứng dụng web (web app) mới đang thu hút rất nhiều sự quan tâm từ các nhà phát triển web khắp thế giới đặc biệt là các doanh nghiệp hoạt động trực tuyến, tuy nhiên nó vẫn còn khá mới mẻ tại Việt Nam.Đã có nhiều bài viết liên quan đến PWA dành cho lập trình viên, cho nên trong bài viết này tôi sẽ cố gắng giải thích PWA để người dùng Web phổ thông vẫn có thể hiểu. Progressive Web App là gì?PWA là ứng dụng web được viết để tận dụng những tính năng mới nhất của trình duyệt Web trên máy tính để bàn (desktop) lẫn điện thoại thông minh, nhưng đồng thời vẫn chạy được trên những trình duyệt và thiết bị cũ hơn. PWA lấy phương pháp Cải Tiến Tăng Dần (Progressive Enhancement) làm cốt lõi (nên mới có chữ Progressive). Đối với những trình duyệt và thiết bị cũ, PWA hoạt động như một mobile website thông thường. Nhưng với những trình duyệt trên thiết bị di động mới nhất, PWA hoạt động như một mobile app[^1] thực thụ. Những tác giả của khái niệm PWA (đến từ nhóm phát triển trình duyệt Chrome) đã đưa ra những đặc tính cần có của một PWA như sau: Progressive - Chạy được trên mọi (nên hiểu: tuyệt đại đa số) thiết bị, do được phát triển với phương pháp Cải Tiến Tăng Dần. Responsive - Có thiết kế giao diện tùy ứng (responsive design), hiển thị và sử dụng được trên mobile, tablet, laptop hay bất kỳ cỡ màn hình nào trong tương lai. Connectivity independent - PWA vẫn có thể hoạt động tốt với điều kiện kết nối mạng chập chờn hoặc mất hẳn (offline). App-like - Có giao diện và trải nghiệm như mobile app thực thụ. Fresh - Dù nó hoạt động như mobile app, nhưng tính năng và giao diện luôn được cập nhật tức thời nhờ nền tảng Web (không cần người dùng update từ Apple App Store hay Google Play - gọi chung là app store). Safe - PWA phải được tải thông qua giao thức TLS (hay nôm na là HTTPS), để đảm bảo việc trao đổi dữ liệu không bị bên thứ ba can thiệp. Discoverable - Thông qua file khai báo chuẩn (được thống nhất bởi tổ chức W3C), mà các PWA dễ dàng được các cỗ máy tìm kiếm đánh dấu và thông báo cho người dùng. Re-engageable - PWA cho phép việc tái tiếp cận người dùng dễ dàng hơn nhờ những tính năng đặc biệt như là push notification (thông báo chủ động). Installable - PWA cho phép người dùng dễ dàng lưu lại web app trên điện thoại (thường là trên màn hình home screen) mà không cần phải vào app store Linkable - Dễ dàng share app chỉ với đường link và không cần người nhận phải cài đặt phức tạp chỉ để xem được nội dung bạn muốn share. Những điểm khác biệt của Progressive Web App?Trước tiên cần hiểu rằng, sự tiến hóa của mobile web app cần sự hợp tác của rất nhiều bên liên quan trong đó có các nhà phát triển trình duyệt, hệ điều hành di động, và cả những chuyên gia về ngôn ngữ lập trình cho Web. Sự tiến hóa của mobile web thường đi cùng với sự phát triển và chuẩn hóa của nền tảng Web do tổ chức W3C[^2] chịu trách nhiệm. Khi tôi tư vấn và phát triển app cho khách hàng, rất nhiều lần doanh nghiệp từ chối lựa chọn giải pháp web app hoặc hybrid app với lý do chính là “HTML5 không nhanh bằng native”. Tuy nhiên điều này không còn đúng tại thời điểm hiện tại. Nhờ những cải tiến của phần cứng thiết bị, hệ điều hành di động, trình duyệt, và nhất là đặc tả Web trong vài năm gần đây mà web app đã thêm những khả năng không thua kém native app như: Giao diện tương tác mượt mà hơn, đặt biệt là hỗ trợ đồ họa 3D, animation từ phần cứng (hardware accelerated) Khả năng chơi video, audio thông qua trình duyệt mobile đã hoàn thiện và định dạng gần như đã thống nhất. Bàn phím ảo thích ứng với trường nhập web form khác nhau: email, URL, telephone… Có khả năng truy xuất các sensor và bộ phận đa phương tiện của thiết bị: định vị GPS, con quay hồi chuyển, trạng thái pin, network, camera, microphone… Cơ sở dữ liệu (CSDL) tại trình duyệt cho phép tìm kiếm và truy cập nhanh lượng dữ liệu lớn và cho phép người dùng trở lại trang web app nhanh hơn. Đặc tả mới về CSS cho phép designer và front end developer tạo giao diện tùy ứng (responsive design) và giao diện giống app dễ dàng hơn. Dù vậy, web app vẫn còn một số hạn chế so với native app. Chúng ta hãy xem PWA đã được bổ sung những khả năng gì để có thể xóa dần khoảng cách giữa web và native: Kết luậnĐược giới thiệu chính thức từ 2015, PWA đã trải qua thời gian thử nghiệm và trưởng thành đủ lâu để giờ đây chúng ta có thể khẳng định PWA chính là tương lai của Web và Web App. PWA đóng góp thêm một giải pháp ứng dụng di động nhiều hứa hẹn, giải phóng doanh nghiệp khỏi sự lệ thuộc vào app store, những hạn chế của native app. Và nếu được thiết kế hợp lý, PWA sẽ là giải pháp hợp nhất cho “mọi nền tảng” từ desktop đến mobile. Ghi chú:[^1]: Xin tóm tắt lại một số thuật ngữ về “app” trên thiết bị di động: Mobile app hoặc native app: (ở Việt Nam thường gọi tắt là “app”) là ứng dụng được cài đặt từ app store, được viết bằng ngôn ngữ lập trình dành riêng cho từng hệ điều hành di động khác nhau. (Mobile) web app: là website chạy trên trình duyệt của smart phone nhưng có trải nghiệm giống app và thường trao đổi nhiều dữ liệu giữa người dùng và website. Hybrid app: là ứng dụng được cài đặt từ app store, tuy nhiên được viết bằng cùng ngôn ngữ lập trình với web app. Dù hybrid app có thể cài được trên nhiều HĐH khác nhau nhưng nó chỉ cần được viết cùng một bộ mã nguồn với một ít điều chỉnh riêng cho mỗi loại HĐH mà nó hỗ trợ. [^2]: Tổ chức World Wide Web Consortium có trách nhiệm chuẩn hóa các đặc tả về Web và khuyến khích các trình duyệt khác nhau phải tuân theo để các website hoạt động một cách đồng nhất bất kể trình duyệt dùng để hiển thị. [^3]: URL là đường link đến một trang web bất kỳ [^4]: Các trình duyệt phổ biến nhất bao gồm: Chrome, Firefox, Safari, MS Edge, Opera, Samsung Internet, UC Browser. Tại Việt Nam, trình duyệt phổ biến thứ 2 sau Chrome là CocCoc. Tuy nhiên CocCoc cũng là một trình duyệt biến thể từ mã nguồn mở của Chrome nên những tính năng của PWA cũng sẽ được hỗ trợ. [^5]: Người dùng sẽ vẫn nhận được push notification cho dù họ không lưu app về home screen chỉ cần họ đã bấm đồng ý nhận push notification. Việc yêu cầu gửi push notification cần thận trọng và chỉ thực hiện khi người dùng đã thể hiện sự quan tâm đến dịch vụ của bạn. (Nếu không khả năng người dùng từ chối nhận push notification là rất cao)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"pwa","slug":"pwa","permalink":"http://nthung2112.github.io/tags/pwa/"}]},{"title":"Giới thiệu về redux saga","slug":"Gioi-thieu-ve-redux-saga","date":"2018-04-30T11:37:00.000Z","updated":"2018-04-30T11:52:22.931Z","comments":true,"path":"2018/04/Gioi-thieu-ve-redux-saga.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Gioi-thieu-ve-redux-saga.html","excerpt":"Redux-Saga là gì?Redux-Saga là một thư viện redux middleware, giúp quản lý những side effect trong ứng dụng redux trở nên đơn giản hơn. Bằng việc sử dụng tối đa tính năng Generators (function*) của ES6, nó cho phép ta viết async code nhìn giống như là synchronos.","text":"Redux-Saga là gì?Redux-Saga là một thư viện redux middleware, giúp quản lý những side effect trong ứng dụng redux trở nên đơn giản hơn. Bằng việc sử dụng tối đa tính năng Generators (function*) của ES6, nó cho phép ta viết async code nhìn giống như là synchronos. Saga không chỉ tồn tại trong thế giới javascript, nó còn được coi là 1 pattern. Bạn có thể xem qua về saga pattern bằng clip này: https://youtu.be/xDuwrtwYHu8 Một cách nhìn nhanh chóng thì Saga pattern là cách để quản lý những long transaction với những side effect hoặc các nguy cơ tiềm ẩn. Với mỗi transaction thành công, chúng ta đều cần có counter-transaction để revert transaction đó về trạng thái ban đầu nếu gặp trục trặc. Tham khảo thêm về saga pattern với bài viết của Roman Liutikov : Confusion about Saga pattern Side effect là gì??Ta đã biết tất cả những xử lý ở REDUCER đều phải là synchronous và pure tức chỉ là xử lý đồng bộ. Nhưng trong ứng dụng thực tế thì cần nhiều hơn vậy ví dụ như asynchronous (thực hiện một số việc như gọi một hàm AJAX để fetch dữ liệu về nhưng cần đợi kết quả chứ kết quả không trả về ngay được) hoặc là impure (thực hiện lưu, đọc dữ liệu ra bên ngoài như lưu dữ liệu ra ổ cứng hay đọc cookie từ trình duyệt… đều cần đợi kết quả). Những việc như thế trong lập trình hàm gọi nó là side effects. Generator function là gì??Khác với function bình thường là thực thi và trả về kết quả, thì Generator function có thể thực thi, tạm dừng trả về kết quả và thực thi bằng tiếp. Từ khóa để làm được việc đấy là “YIELD”. Generator được đưa ra cách đây mấy chục năm nhưng đến ES2015 mới được bổ sung, các ngôn ngữ khác đã được bổ sung tính năng này như C#, PHP, Ruby, C++, R… Redux-Saga hoạt động như thế nào??Đối với logic của saga, ta cung cấp một hàm cho saga, chính hàm này là hàm đứng ra xem xét các action trước khi vào store, nếu là action quan tâm thì nó sẽ thực thi hàm sẽ được thực thi, nếu bạn biết khái niệm hook thì hàm cung cấp cho saga chính là hàm hook. Điều đặc biệt của hàm hook này nó là một generator function, trong generator function này có yield và mỗi khi yield ta sẽ trả về một plain object. Object trả về đó được gọi Effect object. effect object này đơn giản chỉ là một object bình thường nhưng chứa thông tin đặc biệt dùng để chỉ dẫn middleware của Redux thực thi các hoạt động khác ví dụ như gọi một hàm async khác hay put một action tới store. Để tạo ra effect object đề cập ở trên thì ta gọi hàm từ thư viện của saga là redux-saga/effects. Tại sao tôi phải sử dụng Saga??Khi bắt đầu tìm tòi về redux, bạn hay tìm thấy các bài hướng dẫn sử dụng redux-thunk hoặc redux-saga để quản lý các async action. Vậy tại sao bạn lại được khuyên sử dụng redux-saga ? Trích dẫn trong document của redux-saga: Contrary to redux thunk, you don’t end up in callback hell, you can test your asynchronous flows easily and your actions stay pure. _Tạm dịch: trái với redux thunk, bạn không cần phải phát dồ lên với các callback trong mỗi action, đến với saga đi, bạn có thể test các async action với một quy trình dễ dàng mà không làm hư các action đó ! So sánh saga và thunk: redux-thunk 1234567891011121314151617181920212223import &#123; API_BUTTON_CLICK, API_BUTTON_CLICK_SUCCESS, API_BUTTON_CLICK_ERROR,&#125; from './actions/consts';import &#123; getDataFromAPI &#125; from './api';const getDataStarted = () =&gt; (&#123; type: API_BUTTON_CLICK &#125;);const getDataSuccess = data =&gt; (&#123; type: API_BUTTON_CLICK_SUCCESS, payload: data &#125;)const getDataError = message =&gt; (&#123; type: API_BUTTON_CLICK_ERROR. payload: message &#125;);const getDataFromAPI = () =&gt; &#123; return dispatch =&gt; &#123; dispatch(getDataStarted()); getDataFromAPI() .then(data =&gt; &#123; dispatch(getUserSuccess(data)); &#125;).fail(err =&gt; &#123; dispatch(getDataError(err.message)); &#125;) &#125;;&#125;; Ở đây ta có một action creator getDataFromAPI() bắt đầu async progress như sau: Đầu tiên bắn ra action cho phép store biết rằng chuẩn bị 1 API request ( dispatch(getDataStarted()) Tiếp theo thực hiện API request trả về một Promise Cuối cùng bắn ra success action nếu request thành công hoặc error action nếu có lỗi redux-saga 12345678910111213141516171819202122import &#123; call, put, takeEvery &#125; from 'redux-saga/effects';import &#123; API_BUTTON_CLICK, API_BUTTON_CLICK_SUCCESS, API_BUTTON_CLICK_ERROR,&#125; from './actions/consts';import &#123; getDataFromAPI &#125; from './api';export function* apiSideEffect(action) &#123; try &#123; const data = yield call(getDataFromAPI); yield put(&#123; type: API_BUTTON_CLICK_SUCCESS, payload: data &#125;); &#125; catch (e) &#123; yield put(&#123; type: API_BUTTON_CLICK_ERROR, payload: e.message &#125;); &#125;&#125;// the 'watcher' - on every 'API_BUTTON_CLICK' action, run our side effectexport function* apiSaga() &#123; yield takeEvery(API_BUTTON_CLICK, apiSideEffect);&#125; Cùng một process, nhưng cách implement khác nhau hoàn toàn. put thay cho dispatch function cuối (apiSaga()) giúp theo dõi tổng thể toàn bộ các action (ở đây có API_BUTTON_CLICK) Với cách gọi của redux-saga, chúng ta có thể get data từ bất kì async function nào (promise, …) Nhận xétCả 2 cách implement đều dễ đọc, tuy nhiên đối với redux-thunk , bạn phải đối đầu với một tá các promise, các callback nếu có, rất mất thời gian cho người maintain đọc và tìm code. Với redux-saga , đơn giản bạn chỉ cần track theo try/catch block để theo dõi dòng code, bên cạnh đó còn có hàm giúp bạn track các action một cách dễ dàng. Kết luậnỞ bài viết này mình đề cập đến 2 điểm nhấn chính của redux-saga là giữ cho action pure synchronos theo chuẩn redux và loại bỏ hoàn toàn callback theo javascript truyền thống. Bài viết tiếp theo mình sẽ đề cập nốt key point cuối cùng của saga là easy to test.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://nthung2112.github.io/tags/redux/"},{"name":"saga","slug":"saga","permalink":"http://nthung2112.github.io/tags/saga/"}]},{"title":"Thinking in React","slug":"Thinking-in-React","date":"2018-04-30T09:47:00.000Z","updated":"2018-04-30T10:03:55.328Z","comments":true,"path":"2018/04/Thinking-in-React.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Thinking-in-React.html","excerpt":"React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram. Một trong những phần quan trọng nhất của React là cách nó tạo ra cách nghĩ của bạn về các ứng dụng mà bạn xây dựng. Trong tài liệu này, chúng tôi sẽ hướng dẫn bạn cách để xây dựng một ứng dụng tìm kiếm sản phẩm trong table với React.","text":"React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram. Một trong những phần quan trọng nhất của React là cách nó tạo ra cách nghĩ của bạn về các ứng dụng mà bạn xây dựng. Trong tài liệu này, chúng tôi sẽ hướng dẫn bạn cách để xây dựng một ứng dụng tìm kiếm sản phẩm trong table với React. Bắt đầuGiả dụ bạn đã có sẵn một JSON API và giao diện đã sẵn sàng gọi đến nó. Cụ thể như ảnh sau: Dữ liệu trả về có dạng như sau: 12345678[ &#123;category: \"Sporting Goods\", price: \"$49.99\", stocked: true, name: \"Football\"&#125;, &#123;category: \"Sporting Goods\", price: \"$9.99\", stocked: true, name: \"Baseball\"&#125;, &#123;category: \"Sporting Goods\", price: \"$29.99\", stocked: false, name: \"Basketball\"&#125;, &#123;category: \"Electronics\", price: \"$99.99\", stocked: true, name: \"iPod Touch\"&#125;, &#123;category: \"Electronics\", price: \"$399.99\", stocked: false, name: \"iPhone 5\"&#125;, &#123;category: \"Electronics\", price: \"$199.99\", stocked: true, name: \"Nexus 7\"&#125;]; Bước 1: Chia UI thành component theo bậcViệc đầu tiên bạn sẽ phải vẽ các hộp xung quanh mỗi component ( và subcomponent ) và đặt tên cho chúng. Nhưng bạn phân vân không biết khi nào nên tạo ra component? Đối với component, một kĩ thuật được sử dụng rộng rãi để design component là sử dụng nguyên tắc đơn nhiệm. Khi các component được sinh ra quá nhiều, bạn hãy tách chúng ra thành nhiều subcomponent. Đối với việc thuường xuyên hiển thị dữ liệu JSON, bạn nên đảm bảo về tính đúng đắn của model, liệu rằng nó sẽ được map chính xác với UI ( các component ) của bạn? Bởi vì UI và các model luôn phải dính liền với cấu trúc của thông tin, có nghĩa là công việc phân chia UI sang component là không đáng kể. Cứ chia ra thành các component và hiển thị chính xác từng mẩu dữ liệu của bạn là ổn. Đối với dữ liệu trong ảnh, bạn sẽ nghĩ đến 5 component tương ứng với mỗi màu phải không? Sau đây là chi tiết cho từng component đó: FilterableProductTable (cam): chứa toàn bộ ví dụ SearchBar (xanh): nhận dữ liệu từ người dùng ProductTable (xanh lá cây): hiển thị và lọc dữ liệu dựa trên user input ProductCategoryRow (lam): hiển thị tiêu đề cho mỗi category ProductRow (đỏ): mỗi hàng là 1 sản phẩm Nếu bạn nhìn vào ProductTable , bạn sẽ thấy có header (bao gồm nhãn “Name” và “Price”) không phải là chính component của nó. Đây là vấn đề của việc tinh chỉnh. Ví dụ, chúng ta để phần header thuộc component ProductTable vì nó là một phần của việc render ra dữ liệu, đó là trách nhiệm của ProductTable. Tuy nhiên, nếu header này khi được sử dụng một cách phức tạp (như là tương tác với sắp xếp), nó sẽ phải tạo thêm một component riêng cho header gọi là ProductTableHeader chẳng hạn. Tóm lại, bạn nên phân chia cấu trúc của component và các subcomponent như sau: FilterableProductTable SearchBar ProductTable ProductCategoryRow ProductRow Bước 2: Xác định mức tối thiểu (nhưng hoàn chỉnh)Để UI của bạn tương tác tốt, bạn cần xác định các thay đổi đến dữ liệu thuộc tầng dưới (underlying data model) . Hãy sử dụng state của React. Đầu tiên bạn nên nghĩ đến việc tối giản các mutable state. Chìa khóa thành công ở đây là DRY: Don’t Repeat Yourself . Ví dụ với ứng dụng TODO, bạn chỉ cần giữ mảng các TODO item, không cần đến các state khác như để đếm số lượng. Thay vào đó, khi bạn muốn đếm số lượng của TODO item, đơn giản là lấy ra length của TODO item array. Cụ thể với dữ liệu mẫu trong bài viết này, chúng ta có: Nguyên mẫu danh sách sản phẩm Text tìm kiếm mà user nhập vào Value của checkbox Danh sách đã lọc sản phẩm Hãy suy nghĩ về việc bạn nên để cái nào là state, trong thời gian suy nghĩ, hãy đọc các câu hỏi dưới về luồng data: Có thể pass từ parent component thông qua props không? Nếu có, state là không cần thiết. Nó có giữ nguyên trạng thái dữ liệu suốt không? Nếu có, state không thể sử dụng được. Bạn có đoán được data dựa vào bất kì state hay props nào trong component không? Nếu có, chỗ này càng không phải chỗ cho state. Danh sách sản phẩm nguyên bản được pass thông qua props. Text tìm kiếm và checkbox dường như sẽ thích hợp với state vì nó có thể được thay đổi bất kì lúc nào bởi người dùng. Vậy cuối cùng, danh sách lọc sản phẩm cũng không thể nào là state bởi vì chúng có thể được tính toán thông qua list sản phẩm ban đầu dựa vào search text và checkbox. Tóm lại, bạn nên sử dụng state cho: Search text mà user nhập vào Giá trị của checkbox khi user sử dụng Bước 4: Xác định nơi sinh sống của stateHãy nhớ rằng, React là luồng dữ liệu một chiều, phụ thuộc theo luồng của các cấp component. Bạn không thể đoán ngay được component này sẽ có những state gì. Đây là việc chiếm nhiều thời gian và công sức nhất dành cho người mới tìm hiểu về react, hãy nhớ: đừng vội khẳng định state A thuộc component A. Để hình dung ra một cách rõ ràng, hãy theo các bước sau: Phân loại mỗi component sẽ render ra những gì dựa vào state đó. Tìm thử trong component cha Nếu component cha không có, tìm tiếp ở component cao hơn component cha đó Nếu bạn không tìm ra được component đang giữ state, thử tạo một conponent mới để giữ state đó và thêm nó ở đâu đó trong cấp thư mục cao hơn thư mục chứa component cha. Ví dụ cụ thể: ProductTable cần filter sản phẩm dựa vào state và SearchBar cần phải hiển thị text được nhập và state của checkbox. Component cha sẽ là FilterableProductTable Tất nhiên theo lẽ tự nhiên, search text và giá trị của checkbox sẽ được lưu ở trong FilterableProductTable. Bước 5: Thêm luồng dữ liệu… Và đây là kết quả KếtHy vọng rằng, bài viết này cho bạn ý tưởng làm thế nào để suy nghĩ về việc xây dựng các component với React. Mặc dù có thể khiến bạn gõ nhiều code hơn, hãy nhớ rằng code được đọc nhiều hơn nó được viết. Khi bạn bắt đầu xây dựng các thư viện component lớn, bạn sẽ đánh giá cao sự rõ ràng và tính mô đun, và với việc tái sử dụng code, các dòng code của bạn sẽ bắt đầu co lại.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Tổng hợp các cheat sheets tốt nhất của front-end","slug":"Tong-hop-cac-cheat-sheets-tot-nhat-cua-front-end","date":"2018-04-30T08:36:00.000Z","updated":"2018-04-30T11:52:12.794Z","comments":true,"path":"2018/04/Tong-hop-cac-cheat-sheets-tot-nhat-cua-front-end.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Tong-hop-cac-cheat-sheets-tot-nhat-cua-front-end.html","excerpt":"Chúng ta không thể nhớ thuộc lòng tất cả các API. Đây là lúc chúng ta cần các trang cheat sheets này! Dưới đây là các bản cheat sheets tốt nhất mà tôi đã thu thập được.","text":"Chúng ta không thể nhớ thuộc lòng tất cả các API. Đây là lúc chúng ta cần các trang cheat sheets này! Dưới đây là các bản cheat sheets tốt nhất mà tôi đã thu thập được. Javascript ES2015 features Javascript Javascript Regular expression React Redux Vuejs Vuex Angular 4 Flexbox SCSS Stylus GraphQL Missing your favorite cheatsheet? Please let me know in the comments!","categories":[],"tags":[{"name":"cheat sheets","slug":"cheat-sheets","permalink":"http://nthung2112.github.io/tags/cheat-sheets/"}]},{"title":"Tất cả những gì bạn cần biết về CSS-in-JS","slug":"Tat-ca-nhung-gi-ban-can-biet-ve-CSS-in-JS","date":"2018-04-30T08:19:00.000Z","updated":"2018-04-30T08:31:39.212Z","comments":true,"path":"2018/04/Tat-ca-nhung-gi-ban-can-biet-ve-CSS-in-JS.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Tat-ca-nhung-gi-ban-can-biet-ve-CSS-in-JS.html","excerpt":"TL;DR:Thinking in components — No longer do you have to maintain bunch of style-sheets. CSS-in-JS abstracts the CSS model to the component level, rather than the document level (modularity).","text":"TL;DR:Thinking in components — No longer do you have to maintain bunch of style-sheets. CSS-in-JS abstracts the CSS model to the component level, rather than the document level (modularity). Styled React Component Example You probably heard terms like CSS-in-JS, Styled Components, Radium, Aphrodite and you’re left there hanging “why is this a thing? — I’m perfectly happy with CSS-in-CSS (CSS in .css).” I’m here to shine some light on why this is a thing and hopefully we will least understand the concept and understand why it’s a thing. With that said — please feel free to use CSS-in-CSS — on no terms are you obligated to use CSS-in-JS. Whatever works best for you and makes you happy is hands down the best solution, always-always! CSS-in-JS is a delicate and controversial topic — I’m advocating having an open mind and weighing if this makes sense to you — ask yourself “will it improve my workflow?” —**in the end — that’s the only thing that matters — use tools that make you happier and more productive!** I’ve always felt awkward having to maintain a huge folder of stylesheets. I would like to try different approaches. I’ve seen many people asking if there are new styling ideas. CSS-in-JS is so far the best concept. Let’s give CSS-in-JS a shot. What is CSS-in-JS? JSS is a more powerful abstraction over CSS. It uses JavaScript as a language to describe styles in a declarative and maintainable way. It is a high performance JS to CSS compiler which works at runtime and server-side. This core library is low level and framework agnostic. It is about 6KB (minified and gzipped) and is extensible via plugins API. — source Keep in mind Inline styles and CSS-in-JS are not the same! They’re different — Quick demonstration time! How Inline Styles Works In the browser this will get attached to the DOM node like so: How CSS-in-JS works In the browser this will gets attached to the DOM like so: DifferenceSee the slight difference? CSS-in-JS attached a &lt;style&gt; tag on top of the DOM while inline styles just attached the properties to the DOM node. Why does this matter? Not all CSS features can be aliased with JavaScript event handlers , many pseudo selectors (like :disabled, :before, :nth-child) aren’t possible, styling the html and body tags isn’t supported etc. With CSS-in-JS, you have all the power of CSS at your fingertips. Since actual CSS is generated, you can use every media query and pseudo selector you can think of. Some libraries (like jss, styled-components) even add support for neat, non-CSS-native features like nesting! Brilliant article going in depth on how they’re different. “Just write the darn CSS in CSS and be done with it.” Yes — while that’s the case for how it’s been done for a long-long time — the challenge is modern web is written in components not pages. CSS was never actually made for component based approaches. CSS-in-JS solves exactly this problem. Shout-out to Vue for solving this problem beautifully even tho Vues styles have no access to components state. What are the benefits of using CSS-in-JS? Thinking in components — No longer do you have to maintain bunch of style-sheets. CSS-in-JS abstracts the CSS model to the component level, rather than the document level (modularity). CSS-in-JS leverages the full power of the JavaScript ecosystem to enhance CSS. “True rules isolation” — Scoped selectors are not enough. CSS has properties which are inherited automatically from the parent element, if not explicitly defined. Thanks to jss-isolate plugin, JSS rules will not inherit properties. Scoped selectors — CSS has just one global namespace. It is impossible to avoid selector collisions in non-trivial applications. Naming conventions like BEM might help within one project, but will not when integrating third-party code. JSS generates unique class names by default when it compiles JSON representation to CSS. Vendor Prefixing —The CSS rules are automatically vendor prefixed, so you don’t have to think about it. Code sharing — Easily share constants and functions between JS and CSS. Only the styles which are currently in use on your screen are also in the DOM (react-jss). Dead code elimination Unit tests for CSS! What are the drawbacks of using CSS-in-JS? Learning curve. New dependencies. Harder for newer teammates to adapt to the code-base. People who are new to front-end have to learn “more” things. Challenging the status quo. (not necessarily a con) The pros out-weight the cons heavily — let’s give CSS-in-JS a shot! Nothing to lose! Most popular CSS-in-JS libariesWill provide a quick hello world example for all the popular CSS-in-JS libraries— help yourself to choose which one you like the most based on the syntax. Styled Components JSS-React glamorous Radium (caveat: uses inline styles) Note: Radium uses decorators! Aphrodite Stylotron These are really simple examples which demonstrate the core functionality. All of the libraries have much more functionality included — for example, theming, dynamic props, server side rendering and much more! Excellent post going in depth about all of the features CSS-in-JS enables. Here’s the full list — go and give all the libraries a quick try! Hate it or love it — CSS-in-JS deserves a chance! Convinced CSS-in-JS is not for me? There’s another option — CSS Modules!Thanks for reading!","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"}]},{"title":"Hiểu sâu về React Higher Order Components","slug":"Hieu-sau-ve-React-Higher-Order-Components","date":"2018-04-30T08:08:00.000Z","updated":"2018-04-30T08:31:59.004Z","comments":true,"path":"2018/04/Hieu-sau-ve-React-Higher-Order-Components.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Hieu-sau-ve-React-Higher-Order-Components.html","excerpt":"Giới thiệuChắc hẳn rất nhiều người trong chúng ta đã và đang sử dụng React, và tất nhiên là kèm theo hằng tá thư viện đi kèm hỗ trợ nó (lol) Và chắc hẳn bạn đã từng gặp thư viện yêu cầu bạn viết một đoạn code kiểu này để thư viện có thể hoạt động: 1234import &#123; connect &#125; from 'react-redux';...export default connect(mapStateToProps, mapDispatchToProps)(Component); // Kết nối Component với Store của Redux bằng thư viện react-redux","text":"Giới thiệuChắc hẳn rất nhiều người trong chúng ta đã và đang sử dụng React, và tất nhiên là kèm theo hằng tá thư viện đi kèm hỗ trợ nó (lol) Và chắc hẳn bạn đã từng gặp thư viện yêu cầu bạn viết một đoạn code kiểu này để thư viện có thể hoạt động: 1234import &#123; connect &#125; from 'react-redux';...export default connect(mapStateToProps, mapDispatchToProps)(Component); // Kết nối Component với Store của Redux bằng thư viện react-redux Hoặc là thế này 123456var Radium = require('radium');@Radiumclass Button extends React.Component &#123;...&#125;// Radium thư viện hỗ trợ inline style cho React element Và boom Component của chúng ta nhận được props, styles và thậm chí là render ra một view khác Các bạn đã bao giờ tự hỏi connect() @Radium kia là gì, tại sao lại viết như vậy. Vâng trong bài viết này chúng ta sẽ cùng tìm hiểu về một khái niệm nâng cao trong React - Higher-Order Components. Higher-Order Components In a NutshellWhat are Higher-Order Components (HoCs)?Về bản chất, HoC không phải là một phần của React API, nó là một pattern xuất hiện từ những thành phần đặc tính của React. Thường được implement như một function, mà về cơ bản, là một class factory (vâng, là một class factory!) Higher Order Component (HoC) là một function nhận vào một component và trả về một component mới. EnhancedComponent = higherOrderComponent(WrappedComponent); What can I do with HOCs?Ở cấp độ cao, HoC cho phép chúng ta: Code reuse, logic và tự động trừu tượng hóa (bootstrap abstraction) Chiếm quyền render (Render Highjacking) Trừu tượng hóa (abstraction) và điều khiển (manipulation) State Điều khiển Props Chúng ta sẽ xem chi tiết về những mục này, nhưng trước tiên, chúng ta sẽ học cách implement HoCs bởi vì việc implement cho chúng ta thấy những điều có thể và hạn chế mà chúng ta thực sự có thể làm với HoC. HOC factory implementationsCó 2 cách implement HoCs thường thấy trong React: Props Proxy (PP) và Inheritance Inversion (II). Cả 2 cách cho phép các cách khác nhau để thao tác với WrappedComponent. Trước khi bắt đầu chúng ta cần một project 1234create-react-app learnHOCcd learnHOC/src/touch HOC.jsnpm start Props ProxyProps Proxy (PP) được implement thông thường theo cách sau: 1234567function pP(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125;/&gt; &#125; &#125;&#125; Phần quan trọng nhất ở đây là method render của HoC trả về một React Element của kiểu WrappedComponent. Chúng ta cũng truyền props mà HoC nhận được, vì thế phương pháp này mới có tên Props Proxy. What can be done with Props Proxy? Điều khiển props Truy cập instance thông qua Refs Trừu tượng hóa (Abstracting) State Bao WrappedComponent với elements khác Điều khiển propsChúng ta có thể đọc, thêm, sửa đổi và xóa props được truyền cho WrappedComponent. Nhưng cẩn thận với việc xóa hay sửa đổi các prop quan trọng, chúng ta nên đặt namespace cho HoC props để nó không phá vỡ WrappedComponent. Ví dụ: Thêm mới props. 123456789101112131415161718// HOC.jsimport React from 'react';function pP(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; const newProps = &#123; newProps: 'something news' &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt; &#125; &#125;&#125;module.exports = &#123; pP&#125; Sửa lại file App một chút 1234567891011121314// App.jsimport &#123;pP&#125; from './HoC'class App extends Component &#123; render() &#123; console.group('App'); console.log('render'); console.log(this.props); console.groupEnd(); ... &#125;&#125;export default pP(App); Và ở console chúng ta có kết quả Truy cập instance thông qua RefsChúng ta có thể truy cập this (instance của WrappedComponent) với ref, nhưng chúng ta sẽ cần một quá trình render đầy đủ của WrappedComponent để ref có thể được tính toán. Điều này có nghĩa là chúng ta cần trả về WrappedComponent element từ method render của HoC, để React có thể làm quá trình đối chiếu (reconciliation process) và chúng ta sẽ có ref đến WrappedComponent instance. Ví dụ: Chúng ta sẽ tìm hiểu làm thế nào để truy cập instance methods và instance của chính WrappedComponent thông qua refs 123456789101112131415161718192021// HOC.jsfunction refsPP(WrappedComponent) &#123; return class RefsPP extends React.Component &#123; proc(wrappedComponentInstance) &#123; console.group('refs Proc'); console.log(wrappedComponentInstance); wrappedComponentInstance.test(); console.groupEnd(); &#125; render() &#123; const props = Object.assign(&#123;&#125;, this.props, &#123;ref: this.proc.bind(this)&#125;) return &lt;WrappedComponent &#123;...props&#125;/&gt; &#125; &#125;&#125;module.exports = &#123; pP, refsPP&#125; Sửa file App một chút 1234567891011import &#123;pP, refsPP&#125; from './HoC'class App extends Component &#123; test() &#123; console.log('call Test'); &#125; ..... &#125;&#125;export default refsPP(App); Và ở console chúng ta có kết quả Khi WrappedComponent được render xong thì ref callback sẽ được thực thi, và chúng ta sẽ có ref đến WrappedComponent instance. Điều này có thể được sử dụng để đọc/thêm các props và gọi các instance method. Trừu tượng hóa (Abstracting) StateChúng ta có thể trừu tượng hóa state bằng cách cung cấp props và callbacks cho WrappedComponent, tương tự như Container Components làm với Presentational components. Ví dụ: Chúng ta sẽ thực hiện trừu tượng hóa state để kiểm soát input 1234567891011121314151617181920212223242526272829303132333435// HOC.jsfunction statePP(WrappedComponent) &#123; return class StatePP extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; fields: &#123;&#125; &#125; &#125; getField(fieldName) &#123; if (!this.state.fields[fieldName]) &#123; this.state.fields[fieldName] = &#123; value: '', onChange: event =&gt; &#123; this.state.fields[fieldName].value = event.target.value this.forceUpdate() &#125; &#125; &#125; return &#123; value: this.state.fields[fieldName].value, onChange: this.state.fields[fieldName].onChange &#125; &#125; render() &#123; const props = Object.assign(&#123;&#125;, this.props, &#123; fields: this.getField.bind(this), &#125;); return &lt;WrappedComponent &#123;...props&#125;/&gt; &#125; &#125;&#125; Sửa file App một chút 12345678910111213141516171819202122232425// App.jsimport &#123;pP, refsPP, statePP&#125; from './HoC'class App extends Component &#123; test() &#123; console.log('call Test'); &#125; render() &#123; console.group('App'); console.log('render'); console.log('name', this.props.fields('name')); console.log('email', this.props.fields('email')); console.groupEnd(); return ( &lt;div className=\"App\"&gt; .... &lt;form&gt; &lt;label&gt;Automatically controlled input!&lt;/label&gt; &lt;input type=\"text\" placeholder=\"Name\" &#123;...this.props.fields('name')&#125;/&gt; &lt;input type=\"email\" placeholder=\"Email\" &#123;...this.props.fields('email')&#125;/&gt; &lt;/form&gt; &lt;/div&gt; ); &#125;&#125; Và chúng ta có kết quả Việc trừu tượng hóa state có nhiều ứng dụng, và được sử dụng khá nhiều trong việc giải quyết các vấn đề mà Stateless component gặp phải như không có ref chẳng hạn. Bao WrappedComponent với elements khácChúng ta có thể bao WrappedComponent với component hoặc element khác để styling, layout hoặc mục đích khác. Cách sử dụng cơ bản có thể hoàn thành bởi Parent Components nhưng chúng ta có nhiều sự linh hoạt hơn với HoCs như đã mô tả ở trên. 123456789101112// HOC.jsfunction elmWrapPP(WrappedComponent) &#123; return class ElmWrapPP extends React.Component &#123; render() &#123; return ( &lt;div style=&#123;&#123;display: 'block'&#125;&#125;&gt; &lt;WrappedComponent &#123;...this.props&#125;/&gt; &lt;/div&gt; ) &#125; &#125;&#125; Inheritance InversionInheritance Inversion (II) thường được implement như sau: 1234567function iiHOC(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; return super.render() &#125; &#125;&#125; Như các bạn thấy, HOC trả về class (Enhancer) kế thừa (extends) WrappedComponent. Phương pháp này gọi là Inheritance Inversion là do thay vì WrappedComponent mở rộng (kế thừa) Enhancer class nào đó, nó lại được mở rộng (kế thừa) bởi Enhancer. Theo cách này, mối quan hệ giữa chúng dường như bị đảo ngược. II cho phép HoC truy cập vào WrappedComponent instance thông qua this, điều này có nghĩa là HoC có quyền truy cập state, props, component lifecycle hooks và cả phương thức render. Chúng ta sẽ không đi sau vào chi tiết chúng ta có thể làm gì với component lifecycle hooks, đó không phải là những gì cụ thể HoC làm, nó là React. Nhưng lưu ý rằng chúng ta hoàn toàn có thể tạo ra lifecycle hooks mới cho WrappedComponent. Và nhớ răng luôn gọi super.[lifecycleHook] để không phá vỡ WrappedComponent. Quá trình đối chiếu (Reconciliation process)Trước khi bắt đầu chúng ta cần tóm tát vài lý thuyết. React Elements mô tả những gì sẽ hiển thị khi React chạy quá trình đối chiếu của nó. React Elements có thể có 2 loại: String và Function. String Type React Element (STRE) đại diện các DOM node và Function Type React Element (FTRE) đại diện các Component được tạo ra bằng cách mở rộng React.Component. Đọc thêm tại post. FTRE sẽ được phân giải ra thành cây STRE trong quá trình đối chiếu của React (kết quả cuối cùng luôn là các DOM Element). Điều này rất quan trọng và nó có nghĩa là: Inheritance Inversion High Order Components không đảm bảo là đã giải quyết được toàn bộ cây con. Điều này sẽ được chứng thực khi học Render Highjacking. What can you do with Inheritance Inversion? Chiếm quyền render (Render Highjacking) Điều khiển state (Manipulating state) Render HighjackingPhương pháp này gọi là Render Highjacking bởi vì HoC kiểm soát render output của WrappedComponent và chúng ta có thể làm bất kì điều gì với nó. Trong Render Highjacking chúng ta có thể Đọc, thêm, sửa, xóa props trong bất kì React Elements nào xuất ra bởi render. Đọc và sửa đổi React elements tree xuất ra bởi render. Hiển thị elements tree theo điều kiện. Bao element tree cho mục đích styling (giống như đã nói ở PP)\\ Note: render đề cấp đến WrappedComponent.render Chúng ta không thể chỉnh sửa hoặc tạo props của WrappedComponent instace, bởi vì một React Component không thể chỉnh sửa props mà nó nhận được, nhưng chúng ta có thể thay đổi các props của các element xuất ra từ phương thức render. Như chúng ta đã nói ở trên, II HoCs không đảm bảo toàn bộ cây con được giải quyết, điều này hàm ý một số giới hạn với kỹ thuật Render Highjacking. Quy tắc chung là với Render Highjacking chúng ta có thể thao tác với element tree mà WrappedComponent.render xuất ra không nhiều hơn cũng không ít hơn. Nếu Element tree đó có chưa một Function Type React Component thì chúng ta sẽ không thể thao tác được với các con của Component đó. (Do chúng được hoãn lại bởi quá trình đối chiếu của React cho đến khi nó thực sự được render) Ví dụ 1: Render có điều kiện HOC sẽ render chính xác những gì mà WrappedComponent sẽ render trừ khi this.props.loggedIn = false. (Giả định là HoC sẽ nhận được loggedIn prop). 123456789101112// HOC.jsfunction rHII(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; if (this.props.loggedIn) &#123; return super.render() &#125; else &#123; return &lt;div&gt;Not loggedIn&lt;/div&gt; &#125; &#125; &#125;&#125; Và tất nhiên App của chúng ta không có props loggedIn (Lười quá (lol) ) nên kết quả sẽ là Ví dụ 2: Sửa đổi React Element tree xuất ra bởi render. 1234567891011121314151617181920212223242526272829303132333435363738394041// HOC.jsfunction treeII(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; const elementsTree = super.render() let newProps = &#123;&#125;; var newChilds = elementsTree.props.children.map(function (child) &#123; if (child.type === 'input') &#123; var childNewProps = &#123;value: 'may the force be with you'&#125;; var childProps = Object.assign(&#123;&#125;, child.props, childNewProps) return React.cloneElement(child, childProps, child.props.children); &#125; return child; &#125;); const props = Object.assign(&#123;&#125;, elementsTree.props, newProps) const newElementsTree = React.cloneElement(elementsTree, props, newChilds) return newElementsTree &#125; &#125;&#125;&lt;span class=\"hljs-comment\"&gt;// App.js&lt;/span&gt;&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;App&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;extends&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Component&lt;/span&gt;&lt;/span&gt; &#123; render() &#123; &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ( &lt;div className=\"App\"&gt; &lt;div className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;h2&gt;Welcome to React&lt;/h2&gt; &lt;/div&gt; &lt;p className=\"App-intro\" ref=\"appIntro\"&gt; To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;input type=\"text\" placeholder=\"Name\"/&gt; &lt;/div&gt; ); &#125;&#125; export default treeII(App); Trong ví dụ trên, nếu output render bởi WrappedComponent có chứa element con có type là `input’ thì HoC sẽ thay đổi value của nó thành ‘may the force be with you’. Chúng ta có thể làm mọi thứ ở đây, chúng ta có thể duyệt qua toàn bộ các phần tử của element tree và thay đổi bất kì props của bất kì element nào trong tree. Và đây chính xác là những gì Radium thực hiện. Note: Chúng ta không thể Render Highjack với Props Proxy. Mặc dù vẫn có thể truy cập vào phương thức render thông qua WrappedComponent.prototype.render, chúng ta sẽ cần phải mô phỏng WrappedComponent instance và các props của nó, và có khả năng là phải tự xử lý component lifecycle thay vì để React làm nó. Trong thực nghiệm của tôi, nó không có giá trị nhiều lắm và nếu chúng ta muốn Render Highjacking chúng ta nên sử dụng II thay vì PP. Hãy nhớ rằng React xử lý các component instances nội bộ và cách duy nhất để chúng ta thao tác với instances là thông qua refs. Manipulating stateHOC có thể đọc, chỉnh sửa và xóa state của WrappedComponent instance, và chúng ta cũng có thể thêm state nếu cần. Hãy nhớ rằng chúng ta đang làm rối state của WrappedComponent, điều có thể dẫn chúng ta đến việc hủy hoại mọi thứ. Hầu hết các HOC nên được giới hạn để đọc hoặc thêm state, và sau đó được đặt tên (namespace) để không làm rối state của WrappedComponent. Ví dụ: Debugging bằng cách truy cập props và state của WrappedComponent 1234567891011121314function IIHOCDEBUGGER(WrappedComponent) &#123; return class II extends WrappedComponent &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;HOC Debugger Component&lt;/h2&gt; &lt;p&gt;Props&lt;/p&gt; &lt;pre&gt;&#123;JSON.stringify(this.props, null, 2)&#125;&lt;/pre&gt; &lt;p&gt;State&lt;/p&gt;&lt;pre&gt;&#123;JSON.stringify(this.state, null, 2)&#125;&lt;/pre&gt; &#123;super.render()&#125; &lt;/div&gt; ) &#125; &#125;&#125; HOC này sẽ bao WrappedComponent với element khác đồng thời hiện các props và state của WrappedComponent. NamingKhi bao một component với HOC chúng ta đánh mất tên của WrappedComponent, điều này sẽ ảnh hưởng đến chúng ta trong quá trình dev và debugging. Mọi người thường làm là tùy chỉnh tên của HOC bằng cách lấy tên của WrappedComponent và đặt trước một cái gì đó. Dưới đây trích từ React-Redux: 123456HOC.displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)`//orclass HOC extends ... &#123; static displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)` ...&#125; Function getDisplayName được định nghĩa như sau 12345function getDisplayName(WrappedComponent) &#123; return WrappedComponent.displayName || WrappedComponent.name || ‘Component’&#125; Chúng ta thực sự không phải viết lại nó vì thư viện recompose đã cung cấp function này rồi. Phụ lụcHOC and parametersĐôi khi rất hữu ích khi sử dụng các parameters cho HOCs. Điều này ẩn trong những ví dụ bên trên và nên được phát triển tự nhiên đến Javascript developers trung gian, nhưng vì lợi ích làm cho bài viết đầy đủ, chúng ta sẽ lướt qua nó một cách nhanh chóng. Ví dụ: HOC parameters với Props Proxy thông thường. Điều quan trọng là HOCFactoryFactory function. 12345678910function HOCFactoryFactory(...params)&#123; // do something with params return function HOCFactory(WrappedComponent) &#123; return class HOC extends React.Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125;/&gt; &#125; &#125; &#125;&#125; Và chúng ta có thể sử dụng như thế này 1234HOCFactoryFactory(params)(WrappedComponent)//or@HOCFatoryFactory(params)class WrappedComponent extends React.Component&#123;&#125; Difference with Parent ComponentsNhư đã nói ở phần ‘Bao WrappedComponent với elements khác’, ở một số cách cơ bản cảu HOC ta có thể hoàn thành với Parent Component. Vậy điểm khác biệt giữ HOC và Parent Component là gì? Parent Components là React Components có vài components con. React có APIs để truy cập và thao tác với component con. Ví dụ: 123456789101112class Parent extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125; &#125;&#125;render((&lt;Parent&gt;&#123;children&#125;&lt;/Parent&gt; ), mountNode); Giờ chúng ta sẽ duyệt qua xem Parent Components có và không thể làm gì khi so sánh với HOCs và thêm vài thông tin quan trọng: Có thể Render Highjacking tương tự như với II HOC Có thể điều khiển inner props tương tự như với II HOC Có thể trừu tượng hóa state, nhưng có nhược điểm. Chúng ta sẽ không thể truy cập state của Parent Component từ bên ngoài trừ khi chúng ta tạo hooks cho nó. Điều này hạn chế tính hữu ích của nó. Bao các elements với elements khác. Đây có thể là trường hợp duy nhất Parent component làm tốt hơn HOC. Nhưng tất nhiên là HOC cũng làm đc. Thao tác với child component gặp một số vấn đề. Ví dụ nếu childrent không chỉ có 1 root element (nhiều hơn 1 first level childrent), thì chúng ta phải thêm 1 element để bao tất cả children lại, mà điều này có thể gây rườm ra cho markup của chúng ta. Trong HOCs 1 top level children root được đảm bảo bởi React/JSX. Parent Components có thể được sử dụng tự do trong Elements tree, chúng không bị hạn chế 1 Component 1 lần như HOC. Nói chung, nếu chúng ta có thể làm được nó với Parent Components thì chúng ta nên làm nó, bởi vì Parent Components ít “hack não” hơn HOCs, nhưng như những điều đã nói, với State nó kém linh hoạt hơn so với HoCs. ConclusionHi vọng là sau khi đọc bài này, mọi người sẽ hiểu hơn một chút về React HOCs. Chúng thực sự có ý nghĩa và đã được chứng minh khá tốt trong nhiều thư viện khác nhau. React mang lại rất nhiều sự đổi mới và những thư viện như Radium, React-Redux, React-Router trong số rất nhiều thư viện khác là những bằng chứng về điều đó.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"hoc","slug":"hoc","permalink":"http://nthung2112.github.io/tags/hoc/"}]},{"title":"Cách phân nhánh và chia việc trong nhóm với Git","slug":"Cach-phan-nhanh-va-chia-viec-trong-nhom-voi-Git","date":"2018-04-26T14:50:00.000Z","updated":"2018-04-30T08:06:42.792Z","comments":true,"path":"2018/04/Cach-phan-nhanh-va-chia-viec-trong-nhom-voi-Git.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Cach-phan-nhanh-va-chia-viec-trong-nhom-voi-Git.html","excerpt":"Bạn vốn làm việc một mình một cõi, “thầu nguyên con” dự án. Dù phải code sấp mặt nhưng cuộc đời vẫn thật êm xuôi: tốc độ thần thánh 500 dòng/giờ, commit code mới pặc pặc vào master, cuối ngày chỉ việc git push, tắt máy, rồi dắt gấu đi nhậu (hoặc lội suối băng đèo về nhà thay tã cho con). Ngờ đâu sếp (hoặc co-founder) xót thương bạn vất vả, bèn tuyển ngay 2 em đào nhí vào trợ giúp. Và mọi chuyện bắt đầu phức tạp từ đây: code trong team bị chồng chéo và xung đột liên tục, branch master đang thẳng thớm đẹp xinh bỗng phân nhánh như điên, tốc độ code của bạn giảm trong khi tốc độ chửi thề ngày một tăng nhanh. Bạn không còn thời giờ dắt gấu đi nhậu, cũng không thể lội kịp về nhà thay tã cho con nữa. Cuộc đời bế tắc.","text":"Bạn vốn làm việc một mình một cõi, “thầu nguyên con” dự án. Dù phải code sấp mặt nhưng cuộc đời vẫn thật êm xuôi: tốc độ thần thánh 500 dòng/giờ, commit code mới pặc pặc vào master, cuối ngày chỉ việc git push, tắt máy, rồi dắt gấu đi nhậu (hoặc lội suối băng đèo về nhà thay tã cho con). Ngờ đâu sếp (hoặc co-founder) xót thương bạn vất vả, bèn tuyển ngay 2 em đào nhí vào trợ giúp. Và mọi chuyện bắt đầu phức tạp từ đây: code trong team bị chồng chéo và xung đột liên tục, branch master đang thẳng thớm đẹp xinh bỗng phân nhánh như điên, tốc độ code của bạn giảm trong khi tốc độ chửi thề ngày một tăng nhanh. Bạn không còn thời giờ dắt gấu đi nhậu, cũng không thể lội kịp về nhà thay tã cho con nữa. Cuộc đời bế tắc. Thôi đừng vội lật bàn quýnh cả sếp lẫn đào. Hãy thử làm theo một số quy ước sau đây, đảm bảo team dev nho nhỏ xinh xinh của bạn sẽ không còn “giẫm chân” nhau nữa. Công việc xuôi buồm mát mái, tình đồng nghiệp sẽ lại thương mến thương nè. Vậy, vấn đề chính ở đây là gì?Không có gì nghiêm trọng cả, chỉ là chúng ta chưa có một quy ước phân chia nhánh (branch) hợp lý thôi. So với các chương trình quản lý phiên bản khác như SVN, khả năng phân nhánh của Git phải nói là siêu nhẹ và cực kì dễ dàng. Do đó, bạn có thể chia dự án thành 2 nhánh chính: master dev Nhánh master sẽ là nơi chứa phần code ổn định nhất, sẵn sàng để triển khai bất cứ lúc nào. Trong khi đó, nhánh dev ban đầu được tách ra từ master, và sẽ chứa phần code mới nhất được phát triển. Nói nhỏ: Một số tài liệu sẽ đặt tên nhánh tách ra là develop. Tùy bạn chọn tên gì cũng được, nhưng theo Ehkoo thì gõ dev nhanh hơn gõ develop :p Nhắc bài chút xíuĐể tạo nhánh mới trong Git, bạn dùng lệnh: 1git checkout -b &lt;tên nhánh mới&gt; [nhánh gốc] Chẳng hạn, để tạo nhánh dev từ master, bạn gõ git checkout -b dev master. Nếu không cung cấp tham số [nhánh gốc], nhánh mới tạo sẽ dựa trên nhánh hiện tại bạn đang ở. Để xem nhánh hiện tại là nhánh nào, bạn có thể dùng lệnh git branch. 123456$ git branch auth* auth-session dev graphql master Trong ví dụ trên thì nhánh hiện tại chính là auth-session. Phân chia công việcMỗi khi phát triển tính năng mới, bạn sẽ tạo một nhánh từ dev. 1git checkout -b login dev Đặt tên nhánh là gì đây?Tùy bạn thôi. Một số tài liệu sẽ khuyến khích bạn dùng tiền tố feature/&lt;tên tính năng&gt; để dễ phân biệt. Nhưng theo kinh nghiệm của Ehkoo, ngoài nhánh master, dev, và các nhánh fix-xxx, thì tất cả các nhánh còn lại đều có thể ngầm hiểu là nhánh chức năng. Nhánh này dưới quyền cai quản của bạn, nên mặc sức muốn làm gì thì làm nhé. Hãy commit thường xuyên, dù chỉ là những thay đổi nhỏ nhất. Cũng đừng ngần ngại rằng commit nhỏ sẽ khiến git log khó theo dõi. Chúng ta sẽ có cách xử lý chúng sau. Câu hỏi: Ê, lỡ như có hai hay nhiều người cùng làm chung một tính năng thì sao?Nếu vậy, bạn có thể tiếp tục chia nhỏ hơn nữa, để đảm bảo mỗi người làm việc trên một nhánh độc lập. Cũng theo kinh nghiệm riêng của Ehkoo, thì một tính năng _to_ sẽ có nhiều nhất là 2-3 người cùng phát triển. Nếu vượt quá con số này, thì nên xem lại định nghĩa và cách phân chia việc cho tính năng đó. Chuẩn bị merge vào devSau khi code hoàn tất và tất cả unit tests đã chạy thành công, giờ là lúc bạn merge/gửi code để review tính năng mới vào dev. Thông thường, sẽ có 2 trường hợp xảy ra: Trường hợp 1: Không có gì mới trong dev Giả sử lúc đó Git history của dự án giống như thế này: Như bạn thấy, nhánh login màu vàng được rẽ ra từ nhánh dev màu xanh, và trong nhánh dev không có code gì mới. Đây là trường hợp lý tưởng, đảm bảo khi merge vào dev chúng ta sẽ không bị xung đột code. Trường hợp 2: Có commits mới trong nhánh dev Trong trường hợp này, branch dev (màu xanh) đang có 2 commits phía trước branch login (màu vàng). Nếu trong 2 commits đó có chứa thay đổi liên quan đến dev, chẳng hạn như package.json, thì khả năng cao là sẽ xảy ra xung đột khi merge trực tiếp login vào. Mà dù có may mắn không xảy ra xung đột code, thì merge vào cũng sẽ làm history xấu đi. Do đó, chúng ta sẽ cần sửa lại history của nhánh login bằng cách dùng git rebase. git rebase là gì?git rebase sẽ đem những commits bên trong nhánh login và áp dụng lại vào sau commit mới nhất trong nhánh dev. Cú pháp của lệnh này là: 1git rebase &lt;tên nhánh muốn áp dụng lại&gt; Trong trường hợp hiện tại, chúng ta sẽ chạy những lệnh sau: 1234567# Cập nhật repo hiện tại, đồng thời lấy về commits mới nhất của `dev`git pull# Chuyển qua nhánh `login`, có thể bỏ qua bước này nếu bạn chắc chắn# mình đang ở `login`git checkout login# Tiến hành rebasegit rebase dev Nếu xảy ra xung đột code, bạn có thể phát hiện và giải quyết chúng sớm. Nguyên tắc chung là không sửa code của người khác, và chỉ kết hợp thêm những gì bạn làm. Việc thực hiện rebase tại nhánh chức năng do bạn phụ trách giúp giảm thiểu khả năng mất code, vì bạn là người hiểu rõ nhất phần code bạn viết. Sau khi giải quyết hết các xung đột trong code, bạn chạy git rebase –continue để tiếp tục tiến trình rebase. Bạn cũng có thể chạy git rebase –abort để hủy bỏ rebase và đưa nhánh login về lại trạng thái ban đầu. Mách nhỏ:Một cách giúp cho việc giải quyết xung đột trong code dễ dàng hơn là dùng git mergetool. Có rất nhiều công cụ hỗ trợ, và Meld là một trong số đó. Nếu chưa quen rebase, bạn có thể tạo một branch mới từ login, ví dụ: git checkout -b test login, và tiến hành rebase trên branch này. Sau khi chắc chắn là mọi thứ ổn thỏa, bạn có thể quay lại và tiến hành rebase cho login. Khi rebase xong, mong là history của bạn trông sẽ giống như thế này: Bạn thấy quen không? Chính là trường hợp 1 đã nói ở trên đó. rebase interactivelyỞ phần trên, chúng ta có băn khoăn là commit thường xuyên dễ tạo ra nhiều commit nhỏ đôi khi không cần thiết. Bạn có thể dùng git rebase để dọn dẹp chúng bằng cách thêm tham số -i (interactively) như sau: 1234# Chắc chắn rằng bạn đang ở nhánh `login`git checkout login# Rebase lên dev interactivelygit rebase dev -i Bạn sẽ được chuyển đến một giao diện tương tự như bên dưới. 12345678910pick ff80e85 A way to organize routes per modulepick 67cf18d Try Netlify Functionspick 5546901 Add Dashboard viewpick 2a66ae3 Change layoutpick 58755b4 Add Books module, 404 page.pick fd79cb9 Refactor. Reduce inline styling.pick c671f60 Restyling 404 page.pick 33ef874 Basic layout for book management page.pick 49c423a Clean up UI a bitpick 3aa2840 Init Theo lý thuyết, rebase sẽ đem từng commit và áp dụng lại theo thứ tự từ trên xuống dưới. Bởi vậy, bạn có thể thoải mái sắp xếp lại thứ tự của các commits trên. Bạn để ý lệnh pick ở phía trước mỗi commit. Lệnh này sẽ báo cho git biết hành động bạn muốn làm với commit, trong trường hợp này là áp dụng lại commit. Ngoài pick (p), chúng ta còn có: reword (r): áp dụng lại commit, và sửa commit message edit (e): áp dụng commit, nhưng dừng quá trình rebase lại để sửa code squash (s): kết hợp commit hiện tại vào commit trước nó fixup (f): giống như squash nhưng bỏ đi commit message exec (x): chạy một lệnh shell nào đó drop (d): bỏ, không sử dụng commit này Bằng cách dùng rebase interactively, chúng ta có thêm nhiều quyền để quản lý và sửa đổi commits theo ý mình, làm cho history sạch đẹp hơn. Merge vào devSau khi dọn dẹp nhánh login sạch đẹp, chúng ta có thể merge nhánh này vào dev. Thông thường, bạn – dev cứng nhất team – sẽ là người tiến hành kiểm tra và merge. Bạn có thể chọn hai cách tiếp cận: mergeBạn có thể merge trực tiếp vào dev như thế này: 1234# Chuyển qua nhánh `dev`git checkout dev# Merge `login` vào `dev`git merge login Kết quả sẽ là: Như bạn thấy, một commit mới được tạo ra, giúp bạn dễ dàng nhận biết thời điểm nhánh login được merge vào. Cách thức này gọi là merge fast-forward. Khi dự án phát triển dần theo thời gian, history của dev sẽ như thế này. Bên cạnh đó, chúng ta cũng có cách merge non-fast-forward: 1git merge login --no-ff Và đây là kết quả: Tất cả commits của login đã được kết hợp vào dev. Boom! login biến mất khỏi thế gian như chưa hề tồn tại. SAD! Lợi ích dễ thấy nhất của merge non-fast-forward là giúp cho history của bạn thẳng thớm gọn gàng, còn bất lợi là bạn không phân biệt được commits nào là của nhánh tính năng, cũng như thời điểm merge diễn ra. Trong trường hợp nhánh tính năng có quá nhiều commits nhỏ và dư thừa, chẳng hạn như những commits sửa lỗi chính tả, cập nhật thư viện…, history của bạn sẽ bị nhiễu. rebase, squash và mergeNgoài cách merge các commits của nhánh tính năng vào dev, bạn có thể rebase và squash tất cả commits lại làm một, sau đó tiến hành merge. Cách làm này giúp cho dev luôn ở trạng thái gọn gàng nhất, không chứa commit dư thừa. Trong trường hợp lý tưởng, history của dev sẽ giống như sau: Để cách làm này phát huy tối đa hiệu quả, yêu cầu commit message phải được viết thật rõ ràng và chi tiết. Merge vào masterYay! Sau một thời gian quằn quại, cuối cùng team của bạn đã ra được sản phẩm tương đối ổn. Giờ là lúc merge vào master và triển khai lên server. Lúc này, cũng như khi merge vào dev, bạn có thể chọn merge (fast-forward hoặc non-fast-forward) hay rebase, squash và merge, nhưng theo kinh nghiệm của Ehkoo, merge –no-ff sẽ là lựa chọn tốt nhất, giúp cho master và dev luôn song song với nhau. HotfixHôm nay, thứ 6, ngày 1X. Bạn chạy npm run build rồi rsync code ở master lên server. Mọi thứ hoàn toàn bình thường. Bạn vào website, click vài cái. “Ngon, chạy rồi”, bạn thầm nghĩ, “đi nhậu thoy!” Nhưng vừa vươn vai định gọi điện cho gấu, thì “ó e ò e”, chuông điện thoại reng, số máy của sếp. “Hí hí, chắc được thưởng nóng chăng?” Bạn bắt máy, và nghe giọng sếp âu yếm GẦM ở đầu dây: “LỖI RỒI MÁÁÁ!!!” Xin đừng trụy tim. Hãy hít một hơi thật sâu, rồi bình tĩnh tạo một branch mới từ master, fix-xxx chẳng hạn. Nhờ lắng nghe tiếng sếp gầm, bạn đã mau chóng mò ra lỗi trong đống code (vì bạn là dev cứng mà hihi). Bạn khẽ rủa thầm ku đào nhí viết code không kĩ, tự rủa nhẹ bản thân vì review sót. Nhưng thôi kệ, fix nhanh rồi còn về, kẻo gấu xé xác T^T. Bạn bèn merge –no-ff nhánh fix-xxx vào cả hai nhánh master và dev. Bằng cách này, phần sửa lỗi sẽ xuất hiện ở cả hai branches, giúp history không bị rẽ nhánh bất ngờ. Bạn push, và chuông điện thoại lại vang lên… Vài vấn đề linh tinh khácCó cần nhánh staging không?Trong một số dự án, ngoài dev, còn có một đội ngũ “thần bí” được gọi là QA/QC. Họ được sinh ra trong team là để bới lỗi của anh em nhà dev, nên quan hệ đôi bên không được tình thương mến thương cho lắm. Dầu vậy, họ vẫn cần một nhánh riêng có tên gọi staging. Nhánh này sẽ chứa phần code ở giữa master và dev. staging được tách ra từ dev, có nhiều tính năng hơn master, và tương đối ổn định để có thể merge vào master. Tùy vào tình hình cụ thể của team mà bạn quyết định có cần staging hay không. Viết commit message như thế nào cho chuẩn?Nếu bạn theo chuẩn rebase, squash và merge thì chuyện viết commit message tốt rất quan trọng, vì nó sẽ là tài liệu để mô tả toàn bộ một tính năng. Nhưng nên viết thế nào? Có một vài gợi ý cho bạn đây: Dòng đầu tiên không dài quá 80 chữ, luôn bắt đầu bằng động từ ở thì hiện tại, ngắn gọn súc tích, ví dụ: Add module Authentication. Bạn có thể chọn thêm tiền tố nếu cần thiết, chẳng hạn: Feature: Add module Authentication hay Fix: unable to get location params from URL Bỏ trống hai dòng Sau đó mô tả chi tiết về tính năng đang làm, những điểm cần lưu ý, phần nào của tính năng cần được cải thiện… Khuyến khích bạn kèm theo chữ ký signature khi commit bằng git commit -s Một ví dụ 1234567891011121314151617Feature: Add module AuthenticationSigned-off-by: Long Dep Trai &lt;long@ehkoo.com&gt;This module allows users to register/login into our website usingAWS Cognito account. Added routes:* /auth/register* /auth/loginUsers after registration will receive a SMS to confirm their account.TODO:* Implement social identities* Add Logout feature* Add Forgot password feature Tiếng Anh hay tiếng Việt?Tùy thuộc vào team của bạn, nhưng phải thống nhất trong toàn dự án, và viết tiếng Việt thì nhớ đừng sai chính tả kẻo bị công an bắt nhé. Có nên tag version hay không?Câu trả lời là HÊN XUI, tùy tính chất từng team. Nếu tần suất triển khai code từ master của team không cao, khoảng vài tháng/lần thì tag version là cách tốt để theo dõi những thay đổi. Hoặc nếu bạn đang xây dựng lib hoặc làm việc open source. Còn nếu team bạn theo chuẩn “move fast, break things”, thì có lẽ không cần tag version đâu. Thêm nữa, để tag version phát huy hiệu quả tối đa, thì CHANGELOG cần phải được viết kỹ càng. Đồng thời, đừng quên tag version theo semver nhé. Kết luậnChúng ta có thể tóm tắt bài này lại như sau: Dự án được chia thành nhiều nhánh, bao gồm master, dev và có thể có staging Các nhánh tính năng được chia ra từ dev, phát triển độc lập, được rebase trước khi merge lại vào dev Rebase có thể thay đổi một chút history, hoặc squash lại thành một commit duy nhất Merge có thể là fast-forward hoặc non-fast-forward dev sẽ được merge vào master mỗi khi triển khai. Trường hợp có staging, dev sẽ được merge vào staging, và staging sẽ được merge vào master. Các nhánh hotfix sẽ được chia ra từ master, sau đó merge –no-ff vào master và dev Dĩ nhiên bài viết này chỉ mang tính tham khảo, vì mỗi team mỗi công ty sẽ có những cách làm riêng. Tuy nhiên, nếu bạn không may lâm vào cảnh trái ngang như ở đầu bài, thì đây là một workflow rất nên nghiên cứu và áp dụng. Mong rằng trong tương lai, dự án của bạn sẽ không trở thành “kim tự tháp” như hình dưới đây.","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://nthung2112.github.io/tags/git/"}]},{"title":"Tìm hiểu về một số khái niệm trong Git","slug":"Tim-hieu-ve-mot-so-khai-niem-trong-Git","date":"2018-04-26T07:39:00.000Z","updated":"2018-04-30T08:06:42.823Z","comments":true,"path":"2018/04/Tim-hieu-ve-mot-so-khai-niem-trong-Git.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Tim-hieu-ve-mot-so-khai-niem-trong-Git.html","excerpt":"Giới thiệuĐối với các lập trình viên, việc sử dụng công cụ quản lý phiên bản git là điều không thể thiểu trong công việc hằng ngày và là một trong những kĩ năng cơ bản nhất mà ai cũng cần có được. Git có rất nhiều các khái niệm khác nhau nên nếu bạn chỉ là người mới làm quen với git thì đây chính là bài viết dành cho bạn. Bài viết sẽ giải thích tại sao chúng ta nên sử dụng git cũng như một số khái niệm thường gặp khi sử dụng git.","text":"Giới thiệuĐối với các lập trình viên, việc sử dụng công cụ quản lý phiên bản git là điều không thể thiểu trong công việc hằng ngày và là một trong những kĩ năng cơ bản nhất mà ai cũng cần có được. Git có rất nhiều các khái niệm khác nhau nên nếu bạn chỉ là người mới làm quen với git thì đây chính là bài viết dành cho bạn. Bài viết sẽ giải thích tại sao chúng ta nên sử dụng git cũng như một số khái niệm thường gặp khi sử dụng git. Tại sao cần sử dụng git? Thử tưởng tượng khi làm một project và bạn muốn bổ sung hoặc làm thêm tính năng mới cho project của mình. Tuy nhiên để đảm bảo rằng bạn có thể quay lại sử dụng phần code trước đó bạn đã code trong trường hợp tính năng mới gây lỗi và bạn không nhớ phải xóa những gì để khôi phục lại trạng thái code trước đó thì bạn cần phải thực hiện copy toàn bộ project đó và paste ra đâu đó để lưu trữ rồi mới bắt đầu thực hiện code tính năng mới. Như vậy mỗi lần muốn làm tính năng mới, bạn phải lặp đi lặp lại thao tác trên và rất mất thời gian. Sử dụng Git có thể giải quyết vấn đề này chỉ trong 1 vài dòng lệnh Nếu project bạn đang làm có 2 thành viên cùng làm, mỗi lần một người hoàn thành một tính năng lại phải gửi toàn bộ source code đó thông qua usb, google driver hoặc công cụ lưu trữ online nào đó cho thành viên còn lại có thể download về và paste đè lại lên phần code của người đó. Công việc này cũng mất rất nhiều thời gian và tồn tại nhiều rủi rõ khi paste code chồng lên nhau. Để giải quyết vấn đề này, ta cũng có thể sử dụng git và một remote repository Các khái niệm cơ bản trong git1. Repository là gì? Khi sử dụng git, lệnh đầu tiên mà chúng ta thường gõ: 1$ git init Lệnh này sẽ tạo ra một thư mục ẩn có tên .git và đây chính là repository (hay kho chứa). Còn phần code hay hay thư mục của project nằm cùng với thư mục .git được gọi là Working Directory. Git sử dụng repository này để lưu trữ, giám sát toàn bộ thông tin về các trạng thái của và bất cứ thay đổi nào với project lúc này sẽ được git lưu trữ lại. Có hai loại repository gồm local repository - là repository nằm trên chính máy tính của chúng ta và remote repository - là repository nằm trên một máy chủ từ xa được cung cấp bởi các nhà phân phối như Github, Gitlab hay Bitbucket, … 2. Branch là gì? Như đã nói ở trên về vấn đề khi ta muốn thêm một tính năng mới mà đảm bảo vẫn có thể dễ dàng khôi phục lại trạng thái trước đó thì ta có thể sử tạo 1 branch mới nhau sau: 1$ git branch &lt;tên-branch&gt; hoặc 1$ git checkout -b &lt;tên-branch&gt; Branch mặc định là master Branch mới được tạo ra sẽ chứa toàn bộ trạng thái và những thay đổi đã thực hiện trên project trước khi được tạo Với mỗi repository ta có thể tạo nhiều branch khác nhau và các nhánh này là độc lập với nhau nên khi ta có thay đổi đối với project trên branch này sẽ không ảnh hưởng đến các branch khác Khi tính năng được ta thử nghiệm trên nhánh mới hoàn thiện và đã được kiểm tra đầy đủ, ta có thể tiến hành hợp nhất 2 nhánh với nhau (đưa những thay đổi của nhánh này gộp vào với nhánh khác) Có hai loại branch là local branch - là branch nằm trên máy tính của chúng ta và remote branch - là branch nằm trên máy chủ từ xa 3. Làm thế nào để xóa một branch? Trong trường hợp branch chúng ta tạo ra trước đó không còn cần thiết nữa, ta có thể tiến hành xóa chúng đi bằng cách sử dụng các lệnh như sau: Đối với local branch:1$ git branch -d &lt;tên-branch&gt; Với cách xóa trên, nếu branch cần xóa chưa được gộp thay đổi với branch khác sẽ lập tức báo lỗi vào yêu cầu gộp với branch khác trước khi thực hiện xóa bằng lệnh này 1$ git branch -D &lt;tên-branch&gt; Với cách xóa này thì branch được chỉ định sẽ lập tức bị xóa kể cả trong trường hợp nó chưa được gộp với branch khác Đối với remote branch:1$ git push --delete &lt;tên-remote&gt; &lt;tên-branch&gt; hoặc 1$ git push &lt;tên-remote&gt; --delete &lt;tên-branch&gt; Lưu ý: đối với cả local branch và remote branch ta có thể tiến hành xóa đồng thời nhiều branch bằng cách liệt kê tên các branch cần xóa liền nối tiếp nhau và cách nhau một khoảng trắng 4. Push local branch lên remote server với một tên khác Thông thường khi chúng ta tiến hành push một local branch lên remote server thì tên branch mặc định của remote branch lúc này sẽ là tên của local branch, lệnh push như sau: 1$ git push &lt;tên-remote&gt; &lt;tên-branch&gt; Nhưng nếu ta muốn đổi tên của remote branch đó trên server thì ta cần sử dụng lệnh như sau: 1$ git push &lt;tên-remote&gt; &lt;tên-branch&gt;:&lt;tên-remote-branch&gt; 5. Phân biệt rebase và merge Khi muốn tiến hành gộp 2 branch lại với nhau, ta có thể sử dụng một trong hai lệnh sau: 1$ git merge &lt;tên-branch&gt; hoặc 1$ git rebase &lt;tên-branch&gt; Sẽ tiến hành gộp branch hiện tại với branch mà ta lựa chọn. Tuy có cùng chức năng là gộp nhánh nhưng cách hoạt động của merge và rebase lại khác với nhau, ta có thể so sánh sự khác biệt thông đó như sau: Giả sử ta có 2 branch cần gộp với nhau như hình sau: Đối với sử dụng merge kết quả thu được sẽ như sau: Việc sử dụng merge sẽ tạo ra một commit mới là kết hợp từ 2 commit cuối cùng của 2 nhánh cần gộp vào với nhau Log commit sẽ không bị thay đổi và thứ tự các commit sẽ được sắp xếp theo thời gian tạo commit Đối với sử dụng rebase kết quả thu được sẽ như sau: Rebase sẽ đưa toàn bộ branch Feature lên trên ‘đầu’ branch master Làm thay đổi lịch sử commit 6. Khác nhau giữa fetch và pull Khi muốn cập nhật các thay đổi từ trên remote server về local repository ta cũng có hai cách để thực hiện điều này như sau: 1$ git pull &lt;tên-remote&gt; &lt;tên-remote-branch&gt; Lệnh này sẽ tiến hành kéo các thay đổi từ trên remote server về local của chúng ta đồng thời tiến hành merge các thay đổi đó ngay 1$ git fetch &lt;tên-remote&gt; &lt;tên-remote-branch&gt; Đối với lệnh fetch, các thay đổi từ remote server sẽ được kéo về máy nhưng không tự động merge vào source code của chúng ta mà chúng ta có thể thực hiện việc này sau khi đã review lại các thay đổi đó trước khi tiến hành merge. Các thay đổi này được đẩy sang một branch khác và ta có thể sử dụng lệnh: 1$ git branch -a Để xem được các branch sau khi fetch đồng thời cũng có thể checkout sang branch đó để xem các thay đổi. Có thể hiểu đơn giản lại sự khác nhau giữa fetch và pull như sau: git pull = git fetch + git merge 7. Thế nào là git stash? Trong quá trình chúng làm việc, có những lúc chúng ta đang code dở một chức năng nào đó nhưng bất ngờ ở một chức năng trên branch khác đang có lỗi cần phải sửa gấp và chúng ta muốn lưu lại thay đổi đã làm trên nhánh hiện tại nhưng không muốn thực hiện commit dư thừa thì git stash là lệnh mà chúng ta có thể dùng để giải quyết vấn đề này. git stash cho bạn khả năng lưu lại trạng những thay đổi mà bạn đã tạo ra mà không cần thiết phải commit nó giúp bạn có thể dễ dàng chuyển sang nhánh khác làm việc và sau đó quay lại và tiếp tục những gì bạn đang làm ở nhánh đó. Các lệnh liên quan đến git stash Để lưu được những thay đổi mà không cần commit nó, ta cần thực hiện những lệnh sau:1$ git add . Để đưa toàn bộ các thay đổi đó vào trạng tháy staged, sau đó sử dụng lệnh sau để lưu thay đổi đó mà không cần commit: 1$ git stash # hoặc &quot;git stash save&quot; Để xem lại các thay đổi đã lưu, ta có thể dùng các lệnh sau: 1234$ git stash liststash@&#123;0&#125;: WIP on &lt;branch-name&gt;: &lt;lastest commit&gt;stash@&#123;1&#125;: WIP on &lt;branch-name&gt;: &lt;lastest commit&gt;stash@&#123;2&#125;: WIP on &lt;branch-name&gt;: &lt;lastest commit&gt; Để xem lại danh sách các lần đã lưu, trong trường hợp muốn xem nội dung thay đổi thì ta gõ lệnh sau: 1$ git stash list -p Hoặc nếu muốn xem cụ thể nội dung thay đổi của một lần lưu cụ thể, ta dùng lệnh: 123$ git stash show &quot;stash@&#123;n&#125;&quot;// với n là lần lưu tương ứng trong danh sách// Lưu ý phần stash@&#123;n&#125; phải nằm trong cặp ngoặc đôi Để lấy lại thay đổi được lưu trong danh sách trên ta dùng lệnh: 1$ git stash apply &quot;stash@&#123;n&#125;&quot; Hoặc lấy thay đổi gần nhất và xóa lần lưu đó 1$ git stash pop Để xóa danh sách các thay đổi đã lưu, ta dùng lệnh: 1$ git stash drop &quot;stash@&#123;n&#125;&quot; Để drop một lần lưu chỉ định hoặc 1$ git stash clear Để xóa toàn bộ những lần đã lưu 8. Làm thể nào để xóa bỏ trạng thài vài commit gần đây?Để thưc hiện công việc này chúng ta có thể sử dụng 1 trong 2 lệnh sau: 1$ git revert &lt;commit-hash-code&gt; Lệnh này sẽ tạo ra một commit mới đảo ngược lại những thay đổi trong commit được chỉ định. 1$ git reset --hard &lt;commit-hash-code&gt; Keehnh này sẽ xóa toàn bộ các commit trước đó và đưa branch hiện tại trở về trạng thái của commit-hash-code đã chọn 9. Gộp một vài commit thành một commit duy nhất? Đôi khi trong lúc làm việc, ta thường tạo ra một số commit dư thừa và sau đó muốn gộp chung số commit đó lại với một message rõ ràng hơn về mục đích chung của toàn bộ các commit đó. Để làm được điểu này, ta có thể sử dụng những lệnh sau: 1$ git rebase -i &lt;commit-hash-code&gt; Với commit-hash-code là hash code của commit cuối cùng của nhóm cần gộp hoặc: 1$ git rebase -i HEAD~&lt;index&gt; Với index là số lượng commit cần gồm so với commit cuối cùng. Ngoài ra khi thực hiện việc rebase để gộp commit, ta có các lựa chọn khác như pick|squash|fixup để quyết định kiểu gộp. Cuối cùng ta cũng có thể dùng lệnh sau để gộp commit: 123$ git reset --soft &lt;commit-hash-code&gt;$ git add .$ git commit -m&quot;New commit&quot; Với commit-hash-code là mã hash của commit trước đó mà ta muốn gộp lại từ commit cuối cùng đến commit chỉ định. 10. Phân biệt giữa git reset, reset –soft, reset –hard1$ git reset &lt;commit-hash-code&gt; Sẽ di chuyển HEAD về phía commit được chỉ định nhưng vẫn giữ nguyên trạng thái thay đổi của các file và đồng thời loại bỏ các file đó khỏi trạng thái staged 1$ git reset --soft &lt;commit-hash-code&gt; Tương tư như git reset nhưng toàn bộ các fle vẫn giữ được trạng thái staged. 1$ git reset --hard &lt;commit-hard-code&gt; Tương tự như 2 lệnh trên nhưng toàn bộ sự thay đổi của các file sẽ bị loại bỏ hoàn toàn nên hãy chú ý khi dùng lệnh này để tránh rơi vào trường hợp bao nhiêu công sức đổ xuống sông xuống biển Thế nào là cherry-pick? Bạn có thể hiểu cherry-pick cũng có một số điểm tương đồng với merge và rebase là lấy thay đổi từ một branch này và gộp vào branch khác. Nhưng điểm khác nhau lớn nhất giữa cherry-pick và merge, rebase là cherry-pick chỉ gộp một commit được chỉ định từ một nhánh khác vào nhánh hiện tại trong khi merge và rebase sẽ gộp toàn bộ các commit lại. Để sử dụng cherry-pick, ta cần xem lại log các commit sau đó lấy mã hash của commit cần được cherry-pick và checkout sang nhánh cần được gộp commit của mã hash kia và thực hiện lệnh: 1$ git cherry-pick &lt;commit-hash-code&gt; Một hình ảnh minh họa cho cherry-pick: Giả sử ta muốn lấy commit C từ branch master và gộp vào branch cherry-pick Sau khi thực hiện lệnh cherry-pick như đề cập ở trên, đây sẽ là kết quả ta thu được Như ta có thể thấy commit C từ branch master được gộp vào với branch cherry–pick dưới tên commit là C’ Git flow là gì? Git flow là một quy trình làm việc với git được thiết kế bởi Vincent Driessen. Git flow đưa ra một mô hình phân nhánh giúp hỗ trợ việc quản lý các dự án lớn dễ dàng hơn. Sơ đồ tổng quan: Các branch trong gitflow: Master branch: là branch dùng cho sản phẩm chính thức. Đây luôn là branch ổn định nhất và nó chưa lịch sử các lần release của dự án Develop branch: là nhánh dùng cho sản phẩm trong quá trình phát triển Feature: mỗi tính năng mới cho sẩn phẩm sẽ được tạo và phát triển trên một branch mới với tên quy ước feature/tên_branch. Các feature này sẽ tạo ra từ develop branch và khi được hoàn thiện sẽ được gộp trở lại với develop branch (Lưu ý: các Feature không được phép gộp trực tiếp với master branch) Release: khi develop branch đã có đủ số tính năng cần thiết để có thể release, ta có thể tạo branch mới với tên quy ước release/tên_version. Branch này sau khi được tạo xong sẽ tiến hành merge nó với đồng thời cả master branch và develop branch Hotfix branch: khi sản phẩm trên master branch của chúng ta gặp phải trục trặc và cần có bản vá ngay lập tức thì ta sẽ tạo ra hotfix branch. Branch này tương tự như release branch nhưng nó được tạo ra từ master branch thay vì từ develop branch như release (*Chú ý hotfix branch cũng cần được gộp lại với master branch với develop branch) Các lệnh trong gitflow Để khởi tạo một git-flow cho một project, ta dùng lệnh sau 1$ git flow init Lệnh này sẽ tạo ra hai branch ban đầu là master và develop Để bắt đầu một feature ta dùng lệnh 1$ git flow feature start &lt;tên-feature&gt; Sẽ tạo ra một branch mới có tên dạng feature/&lt;tên-feature&gt; Sau khi feature đó được thực hiện xong, ta có thể công bố feature đó lên remote server để mọi người cùng có thể cập nhật bằng cách gõ lệnh: 1$ git flow feature publish &lt;tên-feature&gt; Để tiến hành gộp branch đó vào develop branch ta dùng lệnh: 1$ git flow feature finish &lt;tên-feature&gt; Để tạo một bản release ta dùng lệnh: 1$ git flow release start &lt;verion-no&gt; Để tiến hành merge bản release đó vào master branch và develop branch ta dùng lệnh: 1$ git flow release finish &lt;version-no&gt; Để tạo một bản hotfix ta dùng lệnh: 1$ git flow hotfix start &lt;tên-hotfix&gt; Sau khi bản hotfix hoàn thiện ta có thể tiến hành merge lại với master branch và develop branch như sau: 1$ git flow hotfix finish &lt;tên-hotfix&gt; Kết luậnBài viết ở trên chủ yếu giới thiệu cho mọi người về các khái niệm trong git cũng như cách sử dụng nó trong công việc thường ngày của mình một cách hiệu quả hơn. Cám ơn bạn đã theo dõi.","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://nthung2112.github.io/tags/git/"}]},{"title":"Progressive Web App tương lai của nền tảng web","slug":"Progressive-Web-App-tuong-lai-cua-nen-tang-web","date":"2018-04-25T11:15:00.000Z","updated":"2018-04-30T08:06:42.807Z","comments":true,"path":"2018/04/Progressive-Web-App-tuong-lai-cua-nen-tang-web.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Progressive-Web-App-tuong-lai-cua-nen-tang-web.html","excerpt":"Tóm tắt“Mobile first” hay “Think mobile” là một trong những hot trend mà chúng ta thường được nghe gần đây, khi mà số lượng thiết bị di động và số lượng người sử dụng các thiết bị di động ngày càng lớn. Nhưng think như thế nào cho đúng là điều cần làm rõ. Bài viết này sẽ cung cấp thông tin cho bạn về cách tư duy theo PWA. PWA không hoàn toàn là một giải pháp về công nghệ, mà là một tập các tiêu chuẩn được định nghĩa cho các ứng dụng web hướng theo, nhằm mang lại trải nghiệm tốt nhất cho người dùng, với sự hỗ trợ của browser về các API có liên quan như Service Worker, Push Notification v.v…","text":"Tóm tắt“Mobile first” hay “Think mobile” là một trong những hot trend mà chúng ta thường được nghe gần đây, khi mà số lượng thiết bị di động và số lượng người sử dụng các thiết bị di động ngày càng lớn. Nhưng think như thế nào cho đúng là điều cần làm rõ. Bài viết này sẽ cung cấp thông tin cho bạn về cách tư duy theo PWA. PWA không hoàn toàn là một giải pháp về công nghệ, mà là một tập các tiêu chuẩn được định nghĩa cho các ứng dụng web hướng theo, nhằm mang lại trải nghiệm tốt nhất cho người dùng, với sự hỗ trợ của browser về các API có liên quan như Service Worker, Push Notification v.v… Trước khi bàn đến các tiêu chuẩn của PWA và cùng tìm hiểu các nghiên cứu mới về trải nghiệm của người dùng, các công nghệ hứa hẹn… Chúng ta sẽ cùng điểm qua một vài cảm nhận và suy nghĩ trong lược sử thời gian của ngành công nghệ web. Bên cạnh đó, chúng ta cũng sẽ nói đôi chút về Native App đến Hybird App và từ đó hiểu thêm về lý do ra đời của PWA. Bài viết sẽ cung cấp cho chúng ta cái nhìn tổng quát về các vấn đề ưu nhược khi phát triển ứng dụng web theo các tiêu chuẩn của PWA, những khó khăn mà lập trình viên có thể gặp phải, hơn nữa, bài viết sẽ cung cấp view nhìn để có thể scale được một dự án PWA về yếu tố con người cũng như về chi phí, hạ tầng. Bài viết khá dài, nên bạn có thể phải kiên nhẫn đọc hết những phần bên dưới, hoặc lướt qua các các heading để có thể chọn các đề mục mà mình tâm. Một vài cảm nhận về nền tảng Web &amp; App.Từ Web App đến Single Page (Web) Application Bạn có thể tìm thấy các nét sơ lược về lịch sử của trong ngành web theo Wikipedia với các cột mốc quan trọng ở đây evolutionoftheweb, và theo quan điểm cá nhân của tác giả thì trong hơn 10 năm qua có thể kể đến hai nhóm sự kiện tiêu biểu: Sự ra đời của các browsers chịu thay đổi và mau lẹ trong sự thay đổi như Firefox, Chrome. Vì chính sự ra đời này, các tiến bộ mới được nhanh chóng cài đặt, phổ biến đến cộng đồng lập trình viên và người sử dụng. Sự ra đời của AJAX có thể nói là cột mốc đáng chú ý nhất của nền tảng web, đã có thời chúng ta đi đâu cũng nghe người ta nói về điều này như là một phương tiện mang đến sức mạnh to lớn cho bất kì một website nào. Một trong các ứng dụng mang đậm dấu ấn của sự thay đổi này là Gmail, nó thay đổi cách chúng ta suy nghĩ về một phần mềm quản lý email trên nền web. Trình duyệt mới đi kèm công nghệ tiên tiến, chúng biến công việc phát triển website, ứng dụng web trở nên thú vị dành cho lập trình viên và không gian sáng tạo không giới hạn dành cho designer. Cùng với sự bùng nổ của internet, cho đến sự ra đời của AJAX, đã khiến các website từng vốn chậm chạp giờ trở nên nhanh hơn, có hiệu năng và trải nghiệm giống như một phần mềm trên desktop và được gọi là một Single Page Application (SPA). Từ Native App đến Hybird AppNgay từ những ngày bắt đầu, các ứng dụng di động đã tạo ra những điều “thật không thể tin nổi” về sự trải nghiệm đa dạng. Các thiết bị di động với cấu hình ngày càng mạnh mẽ với chu kỳ nâng cấp 1 đến 2 lần mỗi năm và người sử dụng ngày càng chịu móc hầu bao, bỏ thời gian cho các ứng dụng trên di động của mình. Bên cạnh đó, các nền tảng di động còn có sự phong phú về chủng loại, phù hợp túi tiền, sở thích của người tiêu dùng đã nhanh chóng trở thành mảnh đất màu mỡ để các nhà khởi nghiệp nghĩ về các ứng dụng nhằm tạo kết nối giữa mọi người, giải quyết công ăn việc làm, nhu cầu học tập giải trí, cải thiện cuộc sống, chăm sóc sức khoẻ… như Grab là một ví dụ về ứng dụng di động đã tạo ra không chỉ việc làm cho cho sinh viên, mà căn bản là đã thay đổi cái nhìn và thói quen truyền thống về ngành dịch vụ xe ôm. Có thể kể đến các nền tảng huy hoàng một thời như: Symbian của đế chế Nokia, Windows Phone với điện thoại O2 một thời làm mưa gió, dâu đen Blackberry những ngày hoàng kim đình đám… cho đến khi chỉ còn hai cái tên thống trị thị trường rộng lớn và màu mỡ này là iOS, Android như chúng ta đã biết. Dù vậy, trong trò chơi vương quyền vốn nguy hiểm này, tuy chưa biết kẻ nào sẽ chiến thắng cuối cùng, song có rất nhiều ông lớn vẫn không cam chịu, không dễ dàng bỏ cuộc chơi và tham vọng của mình. Và ngày nay, các ứng dụng phát triển trên hai nền tảng Android của Google, và iOS của Apple đã lên đến những con số khổng lồ tạo ra một cộng đồng người sử dụng trung thành. Điều đó cũng có nghĩa là nếu bạn muốn xây dựng ứng dụng Native App bạn cũng phải sẵn sàng phát triển hai phiên bản khác nhau. Thật không may là chi phí phát triển cho hai nền tảng này không hề nhỏ, khi mà bạn biết rằng chi phí đó kèm theo việc maintain theo thời gian là một ác mộng, và phần lớn code của chúng gần như là không thể tái sử dụng cho nhau. Đó là lúc người ta nghĩ đến điều làm thế nào để có thể viết một lần và chạy trên nhiều nền tảng, và có nhiều giải pháp cho điều này, ví dụ: Các nền tảng build/compile ra Native App như: (a) Xamarin, bạn có thể code với C# và build ra các nền tảng khác nhau như Android, iOS, Windows Phone. (b) React Native, bạn có thể Javascript để build ra Android, iOS. Các nền tảng cho phép porting các trang web hiện có, hoặc xây dựng app trên nền tảng html/css/js để build ra các ứng dụng chạy trên cả Andriod, iOS như PhoneGap, gọi là Hybird App bằng cách cung cấp bên dưới một Native App như là một Brigde Software để giúp ứng dụng có thể tương tác với phần cứng bên dưới. Hybird app ra đời tận dụng được những ưu điểm của nền tảng web, tận dụng nguồn nhân lực to lớn từ nền tảng này, giờ đây dân lập trình web cũng có thể viết app, porting ứng dụng của mình lên nền tảng mobile một cách dễ dàng. Thật vi diệu phải không? Các so sánh giữa Web và AppWeb AppƯu điểm Chạy được trên nhiều nền tảng, từ mobile đến desktop, từ Andriod đến iOS, từ Windows đến Linux v.v… Người dùng không phải cài đặt ứng dụng nặng nề có khi hàng trăm Mb, không phải nâng cấp version, chúng luôn được cập nhật mới nhất. Có thể searchable từ Google Scale ứng dụng dễ dàng với một cộng đồng lập trình viên năng động và đông đảo dễ thuê mướn. Nhược điểm Không thể can thiệp được sâu vào hệ thống mà phụ thuộc vào trình duyệt của người dùng. Các chức năng về offline có giới hạn như phụ thuộc vào trình duyệt có support hay không. Nhiều trình duyệt và các phiên bản khác nhau bạn sẽ tốn thời gian để đảm bảo chúng chạy giống nhau. Bonus: Bạn có thể xem qua hình bên dưới để nhìn thấy những gì mà Chrome có thể support Native AppƯu điểm Có thể sử dụng hầu hết các tính năng của thiết bị như camera, la bàn… Cảm giác và cái nhìn (feel and look) thân thiện với người dùng vì sử dụng các control native của thiết bị, do hệ điều hành của thiết bị cung cấp. Do sử dụng Native App, nên khi hệ điều hành của thiết bị được nâng cấp (ví dụ khi nâng cấp lên IOS 10, thì sẽ thừa kế được) Có thể work offline, truy cập vào danh bạ v.v… Có thể tận dụng các chức năng như tăng tốc nên tốc độ của Native App sẽ có peformance tốt. Nhược điểm Chi phí phát triển cao, phải gần như làm cho 2 bản dành cho iOS, Android Phải optimize cho các dòng điện thoại không phải flagship Phải cài đặt, không thể được searchable Dung lượng cài đặt rất lớn chiếm một khoảng đáng kể đặc biệt với các thiết bị có bộ nhớ thấp, việc cài đặt còn làm tăng chí phí về mặt dung lượng sử dụng 3G và người sử dụng có thể sẽ phải cân nhắc thời điểm tải. Người dùng sau khi đã cài đặt thường cũng sẽ không nhớ tới ứng dụng và họ cũng dễ dàng remove vì chiếm tài nguyên và cảm thấy chật chội. Thời gian submit và release rất lâu phải chờ đội ngũ Reviewers của App Stores duyệt qua. Điều đó có nghĩa là, khi có một bug xảy ra việc fix bug để giảm đi tác động đến khách hàng là không thể thực hiện ngay được. Điều đó cũng có nghĩa là chi phí dành cho việc testing cũng trở nên lớn hơn. Hybird AppƯu điểm Viết một lần và chạy trên nhiều nền tảng, chúng ta chỉ code một lần cái app của mình, phần còn lại cái cầu nối (Bridge Software) lo. Với các ứng dụng có porting từ web, hoặc có tính năng giống như mobile web, liên quan nặng về xử lý dữ liệu thì loại ứng dụng này là phù hợp. Có thể chạy background, offline. Nhược điểm Peformance kém: Có thể nói các ứng dụng Hybird gặp phải các vấn đề lớn về performance, bởi phải chạy trên một bridge app được viết tất cả trong 1 cồng kềnh, chúng thật sự gần như là một một trình duyệt di động mở rộng (Extended Mobile Browser) có bổ sung thêm các API. Khó customize và optimize phù hợp với chức năng của mình, đặc biệt cho các ứng dụng như Game. Các API vẫn chưa hỗ trợ đầy đủ để theo kịp sự phát triển của phần cứng và sự đa dạng của các nền tảng khác nhau. PhoneGap - Nền tảng nổi bật của Hybird AppPhoneGap là một đại diện tiêu biểu cho nhóm nền tảng Hybird App, được phát triển bởi Adobe System dùng để phát triển mobile app, nhưng không đòi hỏi user có kiến thức về Andriod, hay iOS, mà chỉ cần kiến thức về web như hình minh họa bên dưới. Bảng thống kê so sánh các công nghệNếu bạn cảm thấy quá mệt và loạn vì đống chữ ở phía trên, thì có thể nhìn vào bảng tổng hợp bên dưới để có cái nhìn nhanh về so sánh tương đối giữa các nền tảng này. Sự ra đời của PWACác thống kê thú vị 5 tỉ thiết bị đã và sẵn sàng cho nền tảng web. Có hơn 1 tỉ trang web trên thế giới. Tới quý 2, 2015, cho thấy 90% thời gian người sử dụng điện thoại ở Mỹ là tương tác với Native App, chỉ có 10% sử dụng browser. Nhưng điều này không có nghĩa là bạn cần phải xây dựng một Native App cho ứng dụng của mình, vì phần lớn thời gian người sử dụng bỏ ra lại cho những App phổ biến như Facebook, Twitter, YouTube, Instagram v.v.. Người dùng download app dễ dàng nhưng cũng dễ dàng gỡ bỏ app, bởi phần lớn các app được chạy các chương trình marketing hấp dẫn để thu hút người cài đặt, nhưng vì điện thoại rất dễ bị hết dung lượng nên user sẽ gỡ những app mà họ ít khi dùng đến. 65% người sử dụng điện thoại không hề download ứng dụng mới hàng tháng. Điều này có nghĩa là chi phí cài đặt ứng dụng ngày càng cao. Tất cả những điều này cho thấy mobile web vẫn còn rất quan trọng. Nhưng lại có thêm một nghịch lý là, trong khi tỉ lệ người dùng mobile web so với tỉ lệ người dùng desktop web tăng trưởng rất nhanh và cao, nhưng tỉ lệ convert thành giá trị như đơn hàng lại rất thấp. Một phần trong đó là vì các ứng dụng web hiện tại không được optimize cho mobile cho các vấn đề về UX/UI và trong điều kiện mạng chậm. Một website có thể tải về dưới 3s người sử dụng sẽ happy với website của bạn, và có nghĩa là tỉ lệ rời bỏ thấp, đơn hàng sẽ tăng lên. Còn từ 3s-10s thì người sử dụng chỉ có thể nói là sẽ cố kiên nhẫn. Quá 10s người sử dụng sẽ rời bỏ trang web của bạn vì họ nghĩ nó không hoạt động. (Phần viết này dựa trên sự suy đoán của tác giả) Sự phát triển mạnh mẽ của Native App, thách thức sự thống trị của Google Search Engine, nếu người sử dụng dùng app, họ sẽ không còn cần vào Google để tìm kiếm thông tin nữa và sản phẩm cốt lõi của Google sẽ gặp rất nhiều vấn đề, mà có thể kể đến là sự sụt giảm người sử dụng do các thông tin không còn đưa lên web để có thể crawl được, và kèm theo đó là sự sụt giảm về khả năng kiếm tiền của Google. Tác giả nghĩ đó cũng có thể là lý do khiến Google phải đẩy mạnh phát triển PWA để hỗ trợ cho nền tảng web, níu giữ người sử dụng ở lại nền tảng này. Có thể nói, sự ra đời của Hybird App là một cộc mốc khá quan trọng thể hiện rõ cách nhìn và sự mong mỏi của các nhà phát triển trong việc optimize chi phí. Và câu hỏi đặt ra là, tại sao các trình duyệt bản thân nó không nên là một Bridge Software cung cấp các API để các ứng dụng web có thể truy cập vào phần cứng của thiết bị. Do vậy, chúng ta có thể tin rằng, điều đó sắp tới sẽ là một phần trong những thay đổi, bổ sung của các browsers. Các tiêu chí về PWA: Progressive - Hoạt động cho tất cả mọi người, không liên quan tới việc lựa chọn browser, bởi chúng được xây dựng với những sự cải tiến như là một nguyên lý cốt lõi. Responsive - Có thể hoạt động tốt trên mọi thiết bị như desktop, mobile, tablet, với mọi kích thước màn hình. Connectivity independent - Có thể hoạt động ngay cả khi offline (dựa trên Service Worker) và hoạt động tốt trong điều kiện network chậm. App-like - Sử dụng app-shell để cung cấp các chức năng định hướng và sự tương tác giống như app. Fresh - Luôn update phiên bản mới nhất (dựa trên Service Worker) Safe - Tất cả phải được phục vụ thông qua HTTPS để tránh bị nghe lén và đảm bảo nội dung không bị giả mạo. Discoverable - Có để được nhận dạng như là ứng dụng (dựa trên Service Worker, và W3C manifests ) và cho phép Search Engines có thể tìm thấy. Re-engageable - Tạo ra sự tương tác lại ứng dụng dễ dàng thông qua các chức năng chẳng hạn như Push Notification. Installable - Có thể Add to Homescreen để giữ lại ứng dụng trên màn hình. Linkable - Dễ dàng share, chia sẽ điều mình muốn đến với người khác thông qua URL mà không cần phải cài đặt. 10 tiêu chí nhận dạng một ứng dụng được xem là PWA với sự giúp đỡ của Google Translator. PWA không hoàn toàn là một giải pháp về công nghệ, mà là một tập các tiêu chuẩn được định nghĩa cho các ứng dụng web hướng theo nhằm mang lại trải nghiệm tốt nhất cho người dùng, với sự hỗ trợ của browser về các API có liên quan như Service Worker, Push Notification v.v… Điều ý nghĩa của một ứng dụng theo tiêu chuẩn của PWA không phải là nó có thể tận dụng được sức mạnh từ phần cứng của người sử dụng hay không, như cách mà nhiều lập trình viên lần đầu nghe qua quan tâm, mà là nó giúp cho các ứng dụng web trở nên tốt hơn từ góc độ performance đến những cải tiến về UX/UI. Để hiểu được PWA là gì, cần phải nhìn về Native App và Web App ở góc độ ưu nhược điểm của từng đối tượng. Và khi nhìn thấy nhược điểm của chúng, cũng là lý do đầy đủ để chúng ta hiểu PWA ra đời như là một giải pháp hoàn thiện cả hai nền tảng này bằng cách mang ưu điểm của cả hai. Nghiên cứu mới về trải nghiệm người sử dụngNgày trước, một website tốt là một website có Page Speed cao, trong thời gian vài giây nó phải tải toàn bộ nội dung về thiết bị, tiếp theo đó trình duyệt hiển thị giao diện, cuối cùng là cho người dùng tương tác. Điều đó có nghĩa là, trong thời gian tải toàn bộ nội dung của website, người dùng chỉ nhìn thấy một màn hình trắng tinh khôi, hoặc là một dấu hiện đang tải trang với animation nhàm chán và có thể họ sẽ bắt đầu thấy mất kiên nhẫn trong các điều kiện như network bị chậm. Theo nghiên cứu của Google, một website tốt phải cho một sự trải nghiệm liên tục không gián đoạn, nhằm thuyết phục người dùng tin rằng là nó đang hoạt động để họ không rời bỏ đi chỗ khác, cũng như không cảm thấy phải khó chịu khi phải chờ đợi. Sự tải trang, các nội dung cần thiết để có thể tạo ra một ứng dụng hoàn chỉnh có thể chia thành nhiều giai đoạn phù hợp với nhu cầu và khả năng tương tác của người dùng. Ứng dụng không cần phải load tất cả mọi thứ lên sẵn trong khi có rất nhiều tính năng người dùng có thể chưa cần dùng tới hoặc là ít khi dùng tới. Các giai đoạn trải nghiệm cơ bản First Paint - Định nghĩa việc website cần tải thật nhanh để người sử dụng thấy nó hoạt động chứ không phải là một màn hình trắng tinh vô hồn. First Meaningful Paint - Định nghĩa về việc website cần phải hiển thị những điều có ý nghĩa để người sử dụng có thể nhìn thấy ví dụ như những hình ảnh banner, video v.v… gọi là Hero Element Time to Interactive - Định nghĩa về cách làm thế nào người sử dụng có thể bắt đầu tương tác với website của bạn cũng trong thời gian nhanh nhất, có thể thao tác với điều họ cần, mà không cần phải đợi tải hoàn toàn trang, ví dụ như họ đã có thể bắt đầu với search box, hoặc xem video, đi vào sản phẩm chi tiết. Google đã phát triển một công cụ gọi là Lighthouse để phân tích website của bạn theo các tiêu chí này. Tại sao PWA có thể trở thành tương lai của ngành webNhư đã nói, việc mobile web vẫn có những thế mạnh mà không thể bị đánh bại, bởi những giá trị cốt lõi chưa thể bị thay thế trong tương lai gần như đã đề cập vốn rất chi tiết ở trên. Nhưng với sự thay đổi nhanh về phần cứng cũng như về hệ sinh thái các phần mềm từ hệ điều hành cũng như Native App trên các thiết bị di động, đòi hỏi các ứng dụng web phải thay đổi để thích nghi với sự kỳ vọng cao hơn về nhu cầu trải nghiệm của người dùng. Rất khó để chấp nhận với một thiết bị đẹp, cấu hình mạnh mẽ, và đắt đỏ lại tải một trang web lên có vẻ chậm chạp, hiệu năng kém và thiết kế cẩu thả. Những lý luận và tư tưởng của PWA là tuyệt vời và có thể áp dụng để làm cho sản phẩm của chúng ta tốt hơn, điều đó hứa hẹn một thị trường hấp dẫn về các website đã có cần phải thay đổi và các website mới cần phải được build trên các nền tảng công nghệ mới và tư tưởng mới. Nếu chúng ta không nắm bắt đúng thời điểm, đúng điểm rơi của công nghệ, chúng ta sẽ bị bỏ lại phía sau, lạc hậu và khi phần lớn khách hàng quay lưng đi với mình thì đã muộn. Có rất nhiều bài học về điều này như của Nokia, của Yahoo… có thể sự đổ vỡ của các tập đoàn khổng lồ này đến từ nhiều nguyên nhân, nhưng trong số đó chắc chắn phần lớn từ các sản phẩm thiếu sáng tạo, kém hấp dẫn đối với người tiêu dùng, thậm chí không muốn nói là lạc hậu trong tồn tại của nó so với đối thủ. Những khó khăn khi ứng dụng PWA Nguồn nhân lực về PWA hiện tại đang thiếu hụt mà chưa dễ dàng được khoả lấp trong thời gian ngắn sắp tới, do các công nghệ và nền tảng vẫn còn mới. Tác giả sẽ viết một bài sắp tới để nói sâu hơn về vấn đề này cũng như giải pháp khắc phục cho các tổ chức muốn phát triển sản phẩm theo tư tưởng của PWA. Sự thiếu hỗ trợ đầy đủ từ các nhà phát triển chẳng hạn như từ Apple, nhưng điều này đang và sẽ sớm được khắc phục, bạn có thể tham khảo ở đây để thấy tính năng này đang được phát triển bởi Apple Những lo ngại của cộng đồng developer do cách hiểu sai là nó không thể sử dụng được phần cứng của thiết bị. Các lãnh đạo, cấp trên vẫn chưa thấy được nhiều value để chuyển đổi từ những website truyền thống sang nền tảng mới. Nhưng các con số và thống kê cũng cho thấy việc chuyển đổi theo tương tưởng và mô hình công nghệ mới hơn là điều không thể nào né tránh. Những nhà phát triển tiêu biểuBạn có thể nhìn qua các website này để tìm hiểu các website đó hoạt động như thế nào để tham khảo cho website của mình. Ở nước ngoài có thể kể đến: Flipkart - Ấn độ, xem chi tiết tại đây. Với phiên bản PWA mobile thời gian user ở lại website là: 3.5 phút so với phiên bản mobile cũ không PWA là 70s. 3x tăng thời gian user ở lại website. 40% tỉ lệ tương tác tăng thêm. 70% nhiều hơn CR đến từ Add to Homescreen. 3x giảm tỉ lệ sử dụng dữ liệu. Aliexpress - Trung Quốc, xem chi tiết tại đây. 104% CR cho người dùng mới tất cả trình duyệt; 82% CR tăng thêm trên iOS 2X số trang mà người sử dụng xem thêm với mỗi session cho tất cả trình duyệt. 74% tăng thêm thời gian người sử dụng với mỗi session tất cả trình duyệt. Ở thị trường Việt Nam, các site nổi tiếng có thể kể đến: Tiki - đã released version PWA vào mùa hè 2017 Sendo - dự kiến released vào cuối năm 2017 PWA dưới góc nhìn cho doanh nghiệpĐối với doanh nghiệp điều quan trọng là giảm chi phí, tăng doanh thu và lợi nhuận thì việc phát triển một ứng dụng PWA với các phương pháp luận và các giải pháp mới khiến cho chi phí phát triển dự án xét về lâu dài càng giảm, và lợi nhuận ngày càng được tối đa hoá. Sản phẩm theo nền tảng này được thừa hưởng một hệ thống lý luận và phương pháp lập trình tốt để dễ dàng scale, maintain, improve, và thay đổi trong tương lai. Điều đó có nghĩa là các tính năng được thêm mới dễ dàng với chi phí thấp, rủi ro về lỗi được giảm. PWA dưới góc nhìn cho lập trình viênBạn cần học gì, làm gì.Nếu bạn chưa từng biết làm thế nào thì đọc bài viết này Làm thế nào để trở thành Frontend developer Khả năng scale của dự án PWAPWA đã được đưa ra từ cách đây từ vài năm trước, nhưng đây là điểm rơi để các ứng dụng có thể chuyển đổi sang nền tảng này, do sự phát triển vô cùng mạnh mẽ của các framework, thư viện được xây dựng và phát triển trên nền Nodejs, đáng để kể đến như React, Angular, Polymer dựa trên trên các công cụ bundle như Grunt, Gulp, Webpack… Chúng khiến cho việc tổ chức, tối ưu code được dễ dàng, tổ chức team hiệu quả và tránh được các rủi ro. Khả năng scale của dự án là dễ dàng cả về yếu tố con người, vật lý, và chi phí. Không có sự hỗ trợ về các công cụ phát triển phần mềm từ hệ sinh thái của Nodejs, rất khó để có thể ứng dụng được các triết lý mà PWA đã đề ra, vì có thể dự án sẽ có chi phí phát triển cực lớn và rủi ro phát sinh theo nó là không thể nào dự đoán hay kiểm soát. Từ góc nhìn outsourcing Làm thế nào để decoupling các task chức năng của ứng dụng, sao cho khi có nhiều tính năng thì có thể đẩy người vào, vì nếu không thể decoupling được tính năng, các chức năng được code độc lập, mỗi người làm một phần thì khi càng push người vào, thì sự phát triển của dự án chưa chắc tương xứng. Giúp debug dễ dàng, khi có vấn đề gì xảy ra không được như mong đợi. Dự án dễ testable, có thể viết chức năng test một cách dễ dàng. Từ góc nhìn production Bao gồm cả các yếu tố của outsourcing. Điều quan tâm là việc tính scale như thế nào khi có sự tăng tưởng của người sử dụng, đặc biệt là khi các phương pháp xây dựng một ứng dụng PWA phụ thuộc nặng nào Nodejs ngay cả khi bạn dùng framework/library nào đi chăng nữa thì các công cụ để xây dựng và tổ chức source code, build source code, debug sẽ cần đến gulp/grunt hoặc là Webpack. Nodejs về hiệu năng có thể được mọi người nghĩ là kém so với các ngôn ngữ khác và khó scale. Nhưng cái nhìn đơn giản đó là chưa đúng. Chúng ta cần nhìn về ứng dụng với các công nghệ được build stack với nhau như: Nginx, Redis, Database v.v… một ứng dụng chạy nhanh cần một thiết kế tốt, có thể hoạt động ổn định và scale theo chiều ngang chứ không nên được thiết kế chỉ dựa vào ngôn ngữ. Ở góc nhìn production, các kỳ vọng về sản phẩm, về chi phí, thời gian, con người đều có đủ phương pháp lý luận và tổ chức để có thể đi đến việc dễ dàng kiểm soát và đạt được các tiêu chí đề ra. Ở một bài viết tiếp theo, chúng ta sẽ xem xét một ứng dụng open source PWA mẫu, để tìm hiểu các công nghệ được stacked như thế nào. Kết luậnQua một bài viết khá dài, tác giả hi vọng sẽ mang lại cho bạn một trong những bài viết đầy đủ và chi tiết nhằm cung cấp các view nhìn mang giá trị tham khảo về một trong những nền tảng rất hứa hẹn thay đổi tương lai của ngành lập trình và phát triển ứng dụng web. Bài viết sẽ không tránh khỏi các thiếu sót mang tính chủ quan của tác giả và cả các sai sót về các thông số, cách trình bày, bố cục, lỗi chính tả… nên hi vọng bạn đọc thông cảm bỏ qua. Nếu bạn có bất kì câu hỏi hay phản biện bổ sung nào vui lòng để lại comment bên dưới. Rất cảm ơn quý đọc giả và các bạn vì đã kiên nhẫn đọc hết bài viết. Tham khảo Getting started with Progressive Web Apps Mobile Web Hay Mobile App? Why “Progressive Web Apps vs. native” is the wrong question to ask","categories":[],"tags":[{"name":"pwa","slug":"pwa","permalink":"http://nthung2112.github.io/tags/pwa/"},{"name":"web","slug":"web","permalink":"http://nthung2112.github.io/tags/web/"}]},{"title":"Biên niên sử về bố cục trong trang web","slug":"Bien-nien-su-ve-bo-cuc-trong-trang-web","date":"2018-04-25T10:57:00.000Z","updated":"2018-04-25T11:06:06.716Z","comments":true,"path":"2018/04/Bien-nien-su-ve-bo-cuc-trong-trang-web.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Bien-nien-su-ve-bo-cuc-trong-trang-web.html","excerpt":"Giới thiệuBài viết bàn về công nghệ các lập trình viên web áp dụng để thiết kế bố cục trong trang web (website layout) - qua các thời kỳ: table, float, block-inline, flexbox, JS, Twitter Bootstrap và grid.","text":"Giới thiệuBài viết bàn về công nghệ các lập trình viên web áp dụng để thiết kế bố cục trong trang web (website layout) - qua các thời kỳ: table, float, block-inline, flexbox, JS, Twitter Bootstrap và grid. Thời trước 2010Đây là thời kỳ tối cổ với công nghệ website, người ta hầu như ít đầu tư giao diện web, việc dựng bố cục, xương sườn cho trang web sử dụng thẻ HTML &lt;table&gt; là chính. Layout Table rất đơn giản, với 1 table 3 rows, 1 row làm header, 1 row làm content, cái cuối làm footer.Nhược điểm của layout table là: rất khó khăn khi tái cấu trúc lại bố cục, khó khăn khi thiết kế vì table mục đích chính là biểu diễn dữ liệu. Các cột có chiều rộng cố định không linh hoạt, nan giải khi xử lý trên nhiều kích thước màn hình.Năm 2012, khi mới ra trường, công việc đầu tiên của tôi là đập bỏ và thay thế các layout dạng table. Tới nay thì không còn ai nghĩ tới việc việc thiết kế layout bằng table nữa.Tuy nhiên còn rất nhiều tài liệu trong các trường đại học chưa được cập nhật nên đừng ngạc nhiên khi bạn được dạy thiết kế layout bằng thẻ table nhé. Từ 2012 - Float lật đổ TableKhi layout table quá bất cập thì giải pháp thay thế tuyệt vời nhất trong giai đoạn này là dùng các thẻ HTML kết hợp với CSS property: Float.Các khối block sẽ được tách ra và “trôi” qua trái, phải, tùy theo ý muốn của lập trình viên. Ưu điểm: code sạch sẽ hơn khi dùng table, dễ thay đổi chỉnh sửa, linh hoạt trên nhiều kích thước màn hình.Khuyết điểm: dễ bị “vỡ trang”, nếu lập trình viên chưa làm chủ được float, chưa biết cách sử dụng các tuyệt chiêu như: clear, overflow… Lạm dụng float trên các bố cục phức tạp. 2013 - thời của các CSS FrameworksVào giai đoạn này, các CSS Frameworks như Bootstrap, Foundation,…Các thư viện này hỗ trợ rất đắc lực cho các lập trình viên, dễ sử dụng, dễ thiết kế bố cục, chỉ cần gắn các class phù hợp. Bên cạnh đó chúng còn liên tục cập nhật và cải tiến không ngừng.Phải nói trong thời gian đó, các CSS Frameworks nhất là Bootstrap, trở thành 1 xu hướng tới mức khi đi phỏng vấn code web, chắc ăn thế nào họ cũng hỏi bạn vài câu.Để dùng tốt Bootstrap, bạn phải học các khái niệm như Grid View System, học thuộc các class thông dụng , tận dụng tối đa các chức năng có sẵn, người giỏi nhất lúc này là người code CSS, style ít nhất.Hạn chế của các CSS Framework này là quá kềnh càng nếu ta không tận dụng hết chức năng (có thể khắc phục bằng bản tùy chỉnh).Nâng cấp phiên bản cần sửa đổi lại tên các class (v2 xài span1 - span12, v3 xài col-, v4 xài col- ). Ngày nay các CSS Frameworks như Bootstrap đã phát triển hơn khái niệm CSS rất nhiều, ta nên gọi nó với tên front-end component library, vì nó còn tích hợp nhiều thư viện JavaScript bên trong. Số lượng các front-end libraries ngày nay 2015 - CSS3 và FlexboxCSS3 đã hỗ trợ một công nghệ thiết kế layout mới, hiện đại hơn Float đó chính là Flexbox. Đúng như tên gọi flexible (linh hoạt), nó thực sự rất mạnh. Flexbox sẽ giúp bạn điều khiển được không những chiều ngang (horizontal) mà còn chiều dọc (vertical) điều mà CSS thường với position rất cứng nhắc. Flexbox có thể điều khiển được các phần tử bên trong, giúp bạn dễ dàng biểu diễn nội dung và bố cục trên các thiết bị di động. Khuyết điểm: flexbox mạnh và mới nên bạn phải bỏ nhiều công sức để học và làm chủ được nó, khó hơn so với dùng float và Bootstrap. Không khuyến khích dùng flexbox để làm bố cục toàn trang trừ trường hợp đặc biệt, chỉ dùng để bố cục các thành phần bên trong. Lý do vì flexbox phụ thuộc vào nội dung bên trong nó, nên khi bài viết dài ngắn có thể làm “biến dạng” bố cục website của bạn, chưa kể tình huống khi web load chưa kịp. Kết hợp khôn ngoan là dùng grid system để làm bố cục bên ngoài, những phần bố cục cần sự linh hoạt thì dùng flexbox. Bootstrap 4 đã tích hợp flexbox vào grid view của mình, chứng tỏ sức mạnh của flexbox và không thể bàn cãi, đồng thời cho thấy cái tiện lợi khi dùng Bootstrap. 2017 - CSS GridGrid và 1 thuộc tính CSS rất mới, ra đời 3-2017. Tuy nhiên nó đã và đang được giới công nghệ web đặc biệt quan tâm vì những tính năng ưu việt.Nếu như Flexbox phân bố các phần tử theo 1 chiều duy nhất thì Grid cho phép bạn điểu khiển phần tử theo 2 chiều - ngang và dọc.Vì đây là 1 công nghệ mới, nên các tài liệu chất lượng về nó hầu hết là bằng tiếng anh, sắp tới mình sẽ có bài viết về công nghệ này, mới các bạn theo dõi.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"}]},{"title":"[Regex] Học rồi mà như chưa học","slug":"Regex-Hoc-roi-ma-nhu-chua-hoc","date":"2018-04-25T10:23:00.000Z","updated":"2018-04-25T10:44:38.060Z","comments":true,"path":"2018/04/Regex-Hoc-roi-ma-nhu-chua-hoc.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Regex-Hoc-roi-ma-nhu-chua-hoc.html","excerpt":"Người dẫn lại bài này cũng được phen lao đao khi lục lọi lại mớ kiến thức cơ bản cũ. Đối với sự nghiệp của một coder thì phải được thực hiện liên tục, nếu không sẽ rất dễ quên và lóng ngóng dù chỉ là những kiến thức cơ bản nhất. Dẫu biết rằng search là sẽ thấy nhưng nhiều phen cũng không khỏi thẹn vì giải thích sai cho đàn em =)) Cũng may đọc lại được bài của cu em công ty, kiến thức lại nhanh chóng được khỏa lấp, vì kiến thức nội bộ nên xin được trích lại bài chia sẻ của em nó để đây cho đỡ quên.!","text":"Người dẫn lại bài này cũng được phen lao đao khi lục lọi lại mớ kiến thức cơ bản cũ. Đối với sự nghiệp của một coder thì phải được thực hiện liên tục, nếu không sẽ rất dễ quên và lóng ngóng dù chỉ là những kiến thức cơ bản nhất. Dẫu biết rằng search là sẽ thấy nhưng nhiều phen cũng không khỏi thẹn vì giải thích sai cho đàn em =)) Cũng may đọc lại được bài của cu em công ty, kiến thức lại nhanh chóng được khỏa lấp, vì kiến thức nội bộ nên xin được trích lại bài chia sẻ của em nó để đây cho đỡ quên.! 1. Tựa đềMình vẫn còn nhớ cái hôm đấy. Trong khi mãi ngắm nhìn những dòng code đến hoa mắt là lúc mặt trời đã lặn khuất sau những toà nhà đô thị từ lúc nào cũng không ai hay. Bên ngoài mưa gió bão bùng, lúc mà mình đang cố release cho cái dự án lụt không cần nước, cho nó có thể chạy được. Nhưng hôm đấy cũng không nằm ngoài dự tính, nó vẫn bị fail như bao lần trước, lần này nguyên nhân là do validate dữ liệu bị sai. Lúc đấy phải cần fix luôn ngay nhưng thật không may là anh phụ trách làm phần đấy đã tốc biến về nhà lúc nào không rõ. Còn bản thân thì chả biết tí tẹo về regex cả. Mọi thứ dường như bế tắc! Đã đến lúc mình phải đọc cái regex mà anh kia đã viết! Nhìn những dòng đấy chỉ có thể thốt lên “wth, mình đang đọc cái nồi gì thế này”. Thật không thể nếu bạn chả có kiến thức gì về nó cả. Thực ra mình và nhiều người hay mắc tật lúc cần làm gì là chỉ cần search từ khoá trên anh google rồi copy vào code của mình, tuy không hiểu rõ nhưng thấy nó chạy ổn thì ok. Đến lúc lỗi lên thì chả biết fix thế nào. Cũng vì nguyên nhân đấy mà mình mới biết là đang làm một cách sai lầm và mù quáng và bắt đầu học một cách đúng đắn hơn. Trước mắt là phải tìm hiểu về regex xem nó có gì mà nhìn vào đã thấy sợ rồi. Bạn đã từng bao giờ rơi vào trường hợp như mình chưa, cần kiểm tra định dạng một chuỗi có hợp lệ, hoặc tìm kiếm một chuỗi nằm trong một chuỗi dài khác. Đa số các bạn cần dùng đến việc validate (xác minh) tính hợp lệ của dữ liệu đều đã từ gặp phải câu hỏi đấy. Nếu bạn gặp trường hợp lúc đấy giải pháp đầu tiên bạn nghĩ đến là gì nếu chưa biết gì về regex? Có thể nó sẽ trở thành một bài toán khá hóc búa nếu bạn chỉ xử lý thuần tuý bằng cách duyệt chuỗi mà không có công cụ và thư viện xử lý. Vậy regex là gì? Nó giải quyết bài toán không tưởng ở trên như thế nào? Nó cao siêu và ảo diệu ra sao? Chúng ta hãy cùng đi tìm hiểu nào! 2. Giới thiệuTheo anh wiki Biểu thức chính quy (regular expression, viết tắt là regexp, regex hay regxp) là một chuỗi miêu tả một bộ các chuỗi khác, theo những quy tắc cú pháp nhất định. Cùng điểm một chút về lịch sử nhỉ. Khái niệm regex được bắt đầu đưa ra từ những năm 1950 khi mà nhà toán học người Mỹ Stephen Cole Kleene chính thức mô tả một ngôn ngữ chính quy Khái niệm này được sử dụng phổ biến trong các tiện ích xử lý văn bản Unix. Sau đấy, từ những năm 1980, tồn tại các cú pháp khác nhau để tạo ra các biểu thức chính quy. Các chuẩn được đưa ra và sử dụng rộng rãi nhất là cú pháp Perl Mỗi lần mình tìm hiểu xong một thời gian không dùng đến, lúc quay lại đọc đều có cảm giác như mới :). 3. Công dụngRegex được sử dụng với rất nhiều mục đích khác nhau nhưng thường được dùng nhiều với mục đích đối sánh văn bản và kiểm tra cú pháp trong các trình biên tập văn bản và các tiện ích tìm kiếm và xử lý văn bản dựa trên các mẫu được quy định. Ví dụ: Nếu bạn muốn tạo bộ lọc và muốn loại bỏ dữ liệu là những trang web mà người khác tạo ra, bạn có thể sử dụng biểu thức chính quy để loại trừ bất kỳ dữ liệu nào từ toàn bộ dải địa chỉ IP người khác sử dụng. Giả sử các địa chỉ IP đó có dải từ 198.51.100.1 - 198.51.100.25. Thay vì nhập 25 địa chỉ IP khác nhau, bạn có thể tạo biểu thức chính quy như 198.51.100.\\d* để đối sánh với toàn bộ dải địa chỉ. 4. Cách dùngCác kí tự đặc biệtBảng 4.1 Các kí tự đặc biệt trong biểu thức chính quy. Kí tự (kí hiệu, cờ) Ý nghĩa \\ Tìm với luật dưới đây: Một dấu gạch chéo ngược sẽ biến một kí tự thường liền kế phía sau thành một kí tự đặc biệt, tức là nó không được sử dụng để tìm kiếm thông thường nữa. Ví dụ, trường hợp kí tự ‘b’ không có dấu gạch chéo ngược này sẽ được khớp với các kí tự ‘b’ in thường, nhưng khi nó có thêm dấu gạch chéo ngược, ‘\\b’ thì nó sẽ không khớp với bất kì kí tự nào nữa, lúc này nó trở thành kí tự đặc biệt. Xem thêm phần word boundary character để biết thêm chi tiết. Tuy nhiên nếu đứng trước một kí tự đặc biệt thì nó sẽ biến kí tự này thành một kí tự thường, tức là bạn có thể tìm kiếm kí tự đặc biệt này trong xâu chuỗi của bạn như các kí tự thường khác. Ví dụ, mẫu /a/ có ‘’ là kí tự đặc biệt và mẫu này sẽ bị phụ thuộc vào kí tự này, nên được hiểu là sẽ tìm khớp với 0 hoặc nhiều kí tự a. Nhưng, với mẫu /a/ thì kí tự ‘’ lúc này được hiểu là kí tự thường nên mẫu này sẽ tìm kiếm xâu con là ‘a*’. Đừng quên \\ cũng là một kí tự đặc biệt, khi cần so khớp chính nó ta cũng phải đánh dấu nó là kí tự đặc biệt bằng cách đặt \\ ở trước (). ^ Khớp các kí tự đứng đầu một chuỗi. Nếu có nhiều cờ này thì nó còn khớp được cả các kí tự đứng đầu của mỗi dòng (sau kí tự xuống dòng). Ví dụ, /^A/ sẽ không khớp được với ‘A’ trong “an A” vì ‘A’ lúc này không đứng đầu chuỗi, nhưng nó sẽ khớp “An E” vì lúc này ‘A’ đã đứng đầu chuỗi. Ý nghĩa của ‘^’ sẽ thay đổi khi nó xuất hiện như một kí tự đầu tiên trong một lớp kí tự, xem phần complemented character sets để biết thêm chi tiết. $ So khớp ở cuối chuỗi. Nếu gắn cờ multiline (đa dòng), nó sẽ khớp ngay trước kí tự xuống dòng.Ví dụ, /t$/ không khớp với ‘t’ trong chuỗi “eater” nhưng lại khớp trong chuỗi “eat”. * Cho phép kí tự trước nó lặp lại 0 lần hoặc nhiều lần. Tương đương với cách viết {0,}.Ví dụ, /bo*/ khớp với ‘boooo’ trong chuỗi “A ghost booooed” nhưng không khớp trong chuỗi “A birth warbled”. + Cho phép kí tự trước nó lặp lại 1 lần hoặc nhiều lần. Tương đương với cách viết {1,}.Ví dụ, /a+/ khớp với ‘a’ trong chuỗi “candy” và khớp với tất cả kí tự a liền nhau trong chuỗi “caaaaaaandy”. ? Cho phép kí tự trước nó lặp lại 0 lần hoặc 1 lần duy nhất. Tương đương với cách viết {0,1}.Ví dụ, /e?le?/ khớp với ‘el’ trong chuỗi “angel” và ‘le’ trong chuỗi “angle” hay ‘l’ trong “oslo”.Nếu sử dụng kí tự này ngay sau bất kì kí tự định lượng nào trong số *,+,? hay {}, đều làm bộ định lượng “chán ăn” (dừng so khớp sau ngay khi tìm được kí tự phù hợp), trái ngược với đức tính “tham lam” vốn sẵn của chúng (khớp tất cả kí tự chúng tìm thấy). Ví dụ, áp dụng biểu mẫu /\\d+/ cho “123abc” ta được “123”. Nhưng áp /\\d+?/ cho chính chuỗi trên ta chỉ nhận được kết quả là “1”.Bạn có thể đọc thêm trong mục x(?=y) và x(?!y) của bảng này. . Dấu . khớp với bất kì kí tự đơn nào ngoại trừ kí tự xuống dòng.Ví dụ, /.n/ khớp với ‘an’ và ‘on’ trong chuỗi “no, an apple is on the tree”, nhưng không khớp với ‘no’. (x) Khớp ‘x’ và nhớ kết quả so khớp này, như ví dụ ở dưới. Các dấu ngoặc tròn được gọi là các dấu ngoặc có nhớ.Biểu mẫu /(foo) (bar) \\1 \\2/ khớp với ‘foo’ và ‘bar’ trong chuỗi “foo bar foo bar”. \\1 và \\2 trong mẫu khớp với 2 từ cuối.Chú ý rằng \\1, \\2, \\n được sử dụng để so khớp các phần trong regex, nó đại diện cho nhóm so khớp đằng trước. Ví dụ: /(foo) (bar) \\1 \\2/ tương đương với biểu thức /(foo) (bar) foo bar/. Cú pháp $1, $2, $n còn được sử dụng trong việc thay thế các phần của một regex. Ví dụ: ‘bar foo’.replace(/(…) (…)/, ‘$2 $1’) sẽ đảo vị trí 2 từ ‘bar’ và ‘foo’ cho nhau. (?:x) Khớp ‘x’ nhưng không nhớ kết quả so khớp. Những dấu ngoặc tròn được gọi là những dấu ngoặc không nhớ, nó cho phép bạn định nghĩa những biểu thức con cho những toán tử so khớp. Xem xét biểu thức đơn giản /(?:foo){1,2}/. Nếu biểu thức này được viết là /foo{1,2}/, {1,2} sẽ chỉ áp dụng cho kí tự ‘o’ ở cuối chuỗi ‘foo’. Với những dấu ngoặc không nhớ, {1,2} sẽ áp dụng cho cả cụm ‘foo’. x(?=y) Chỉ khớp ‘x’ nếu ‘x’ theo sau bởi ‘y’.Ví dụ, /Jack(?=Sprat)/ chỉ khớp với ‘Jack’ nếu đằng sau nó là ‘Sprat’. /Jack(?=Sprat x(?!y) Chỉ khớp ‘x’ nếu ‘x’ không được theo sau bởi ‘y’.Ví dụ: /\\d+(?!.)/ chỉ khớp với số không có dấu . đằng sau. Biểu thức /\\d+(?!.)/.exec(“3.141”)​ cho kết quả là ‘141’ mà không phải ‘3.141’. x y {n} Kí tự đứng trước phải xuất hiện n lần. n phải là một số nguyên dương.Ví dụ, /a{2}/ không khớp với ‘a’ trong “candy”, nhưng nó khớp với tất cả kí tự ‘a’ trong “caandy”, và khớp với 2 kí tự ‘a’ đầu tiên trong “caaandy”. {n,m} Kí tự đứng trước phải xuất hiện từ n đến m lần. n và m là số nguyên dương và n &lt;= m. Nếu m bị bỏ qua, nó tương đương như ∞.Ví dụ, /a{1,3}/ không khớp bất kì kí tự nào trong “cndy”, kí tự ‘a’ trong “candy”, 2 kí tự ‘a’ đầu tiên trong “caandy”, và 3 kí tự ‘a’ đầu tiên trong “caaaaaaandy”. Lưu ý là “caaaaaaandy” chỉ khớp với 3 kí tự ‘a’ đầu tiên mặc dù chuỗi đó chứa 7 kí tự ‘a’. [xyz] Lớp kí tự. Loại mẫu này dùng để so khớp với một kí tự bất kì trong dấu ngoặc vuông, bao gồm cả escape sequences. Trong lớp kí tự, dấu chấm (.) và dấu hoa thị (*) không còn là kí tự đặc biệt nên ta không cần kí tự thoát đứng trước nó. Bạn có thể chỉ định một khoảng kí tự bằng cách sử dụng một kí tự gạch nối (-) như trong ví dụ dưới đây:Mẫu [a-d] so khớp tương tự như mẫu [abcd], khớp với ‘b’ trong “brisket” và ‘c’ trong “city”. Mẫu /[a-z.]+/ và /[\\w.]+/ khớp với toàn chuỗi “test.i.ng”. [^xyz] Lớp kí tự phủ định. Khi kí tự ^ đứng đầu tiên trong dấu ngoặc vuông, nó phủ định mẫu này.Ví dụ, [^abc] tương tự như [^a-c], khớp với ‘r’ trong “brisket” và ‘h’ trong “chop” là kí tự đầu tiên không thuộc khoảng a đến c. [\\b] Khớp với kí tự dịch lùi - backspace (U+0008). Bạn phải đặt trong dấu ngoặc vuông nếu muốn so khớp một kí tự dịch lùi. (Đừng nhầm lẫn với mẫu \\b). \\b Khớp với kí tự biên. Kí tự biên là một kí tự giả, nó khớp với vị trí mà một kí tự không được theo sau hoặc đứng trước bởi một kí tự khác. Tương đương với mẫu (^\\w \\B Khớp với kí tự không phải kí tự biên. Mẫu này khớp tại vị trí mà kí tự trước và kí tự sau nó cùng kiểu: hoặc cả hai là kí tự hoặc cả hai không phải là kí tự. Bắt đầu và kết thúc chuỗi không được xem là những kí tự.Ví dụ, /\\B../ khớp với ‘oo’ trong “noonday”, và /y\\B./ khớp với ‘ye’ trong “possibly yesterday.” \\cX X là một kí tự trong khoảng A tới Z. Mẫu này khớp với một kí tự điều khiển trong một chuỗi.Ví dụ: /\\cM/ khớp với control-M (U+000D) trong chuỗi. \\d Khớp với một kí tự số. Tương đương với mẫu [0-9].Ví dụ: /\\d/ hoặc /[0-9]/ khớp với ‘2’ trong chuỗi “B2 is the suite number.” \\D Khớp với một kí tự không phải là kí tự số. Tương đương với mẫu [^0-9].Ví dụ; /\\D/ hoặc /[^0-9]/ khớp với ‘B’ trong “B2 is the suite number.” \\f Khớp với kí tự phân trang - form feed (U+000C). \\n Khớp với kí tự xuống dòng - line feed (U+000A). \\r Khớp với kí tự quay đầu dòng - carriage return (U+000D). \\s Khớp với một kí tự khoảng trắng, bao gồm trống - space, tab, phân trang - form feed, phân dòng - line feed. Tương đương với [ \\f\\n\\r\\t\\v​\\u00a0\\u1680​\\u180e\\u2000​\\u2001\\u2002​\\u2003\\u2004​\\u2005\\u2006​\\u2007\\u2008​\\u2009\\u200a​\\u2028\\u2029​​\\u202f\\u205f​\\u3000].Ví dụ: /\\s\\w*/ khớp với ‘ bar’ trong “foo bar.” \\S Khớp với một kí tự không phải khoảng trắng. Tương đương với [^ \\f\\n\\r\\t\\v​\\u00a0\\u1680​\\u180e\\u2000​\\u2001\\u2002​\\u2003\\u2004​\\u2005\\u2006​\\u2007\\u2008​\\u2009\\u200a​\\u2028\\u2029​\\u202f\\u205f​\\u3000].Ví dụ: /\\S\\w*/ khớp với ‘foo’ trong chuỗi “foo bar.” \\t Khớp với kí tự tab (U+0009). \\v Khớp với kí tự vertical tab (U+000B). \\w Khớp với tất cả kí tự là chữ, số và gạch dưới. Tương đương với mẫu [A-Za-z0-9_].Ví dụ, /\\w/ khớp với ‘a’ trong “apple,” ‘5’ trong “$5.28,” và ‘3’ trong “3D.” \\W Khớp với tất cả kí tự không phải là chữ. Tương đương với mẫu [^A-Za-z0-9_].Ví dụ, /\\W/ hoặc /[^A-Za-z0-9_]/ khớp với ‘%’ trong “50%.” \\n Trong đó, n là một số nguyên dương, một tham chiếu ngược tới chuỗi khớp thứ n trong biểu thức (đếm từ trái sang, bắt đầu bằng 1).Ví dụ, /apple(,)\\sorange\\1/ hay /apple(,)\\sorange,/ khớp với ‘apple, orange,’ trong chuỗi “apple, orange, cherry, peach.” \\0 Khớp với kí tự NULL (U+0000). Lưu ý: không được thêm bất kì một kí tự số nào sau 0, vì \\0 là một biểu diễn hệ bát phân escape sequence. \\xhh Khớp với kí tự với mã code là hh (2 số trong hệ thập lục phân) \\uhhhh Khớp với kí tự có mã hhhh (4 số trong hệ thập lục phân). Làm việc với biểu thức chính quyBảng 4.2 Những phương thức được sử dụng trong biểu thức chính quy Phương thức Mô tả exec Một phương thức của RegExp dùng để tìm kiếm chuỗi phù hợp với mẫu so khớp. Nó trả về một mảng chứa kết quả tìm kiếm. test Một phương thức của RegExp dùng để kiểm tra mẫu có khớp với chuỗi hay không. Nó trả về giá trị true hoặc false. match Một phương thức của chuỗi dùng để tìm kiếm chuỗi phù hợp với mẫu so khớp. Nó trả về một mảng chứa kết quả tìm kiếm hoặc null nếu không tìm thấy. search Một phương thức của chuỗi dùng để tìm kiếm chuỗi phù hợp với mẫu so khớp và trả về vị trí của chuỗi đó hoặc -1 nếu không tìm thấy. replace Một phương thức của chuỗi dùng để tìm kiếm một chuỗi theo mẫu so khớp và thay thế chuỗi con được khớp với một chuỗi thay thế. split Một phương thức của chuỗi dùng một biểu mẫu chính quy hoặc một chuỗi bất biến để ngắt chuỗi đó thành một mảng các chuỗi con. Ví dụMã hóa escapse chuỗi người dùng nhập vào bằng một hàm thay thế đơn giản sử dụng biểu thức chính quy: 123function escapeRegExp(string)&#123; return string.replace(/[.*+?^$&#123;&#125;()|[\\]\\\\]/g, \"\\\\$&amp;\");&#125; Bạn có thể sử dụng trang web Regex101.com , dán một đoạn regex vào đấy, nó sẽ giải thích đoạn mã đấy làm gì. Lưu ýGiữ biểu thức chính quy của bạn đơn giản. Regex đơn giản giúp người dùng khác hiểu và sửa đổi dễ dàng hơn. Biểu thức chính quy về bản chất đối sánh rất nhiều dữ liệu: nếu bạn không chỉ định cho regex biết không nên đối sánh dữ liệu nào, chúng sẽ đối sánh với những gì bạn chỉ định và bất kỳ ký tự liền kề nào. Ví dụ: site đối sánh với mysite, yoursite, theirsite, parasite–bất kỳ chuỗi có chứa “site”. Nếu bạn cần thực hiện đối sánh cụ thể, hãy thiết lập cấu trúc regex của bạn cho phù hợp. Ví dụ: nếu bạn chỉ cần đối sánh với chuỗi “site”, hãy thiết lập cấu trúc regex của bạn để “site” vừa là bắt đầu chuỗi vừa là kết thúc chuỗi: ^site$. 5. Tham khảoAnalytics Trợ giúpNguồn N.T.Giáp - Kaopiz","categories":[],"tags":[{"name":"regex","slug":"regex","permalink":"http://nthung2112.github.io/tags/regex/"}]},{"title":"Học Regular Expression và cuộc đời bạn sẽ bớt khổ","slug":"Hoc-Regular-Expression-va-cuoc-doi-ban-se-bot-kho","date":"2018-04-25T08:27:00.000Z","updated":"2018-04-30T08:06:42.792Z","comments":true,"path":"2018/04/Hoc-Regular-Expression-va-cuoc-doi-ban-se-bot-kho.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Hoc-Regular-Expression-va-cuoc-doi-ban-se-bot-kho.html","excerpt":"Regular Expression (RegEx) à? Nghe quen quen.","text":"Regular Expression (RegEx) à? Nghe quen quen. Đã bao giờ bạn ở vào các tính huống sau đây? Bạn cần xử lý validate (kiểm tra tính hợp lệ) các trường dữ liệu nhập vào ô Text Bạn cần copy và paste rất nhiều text từ chỗ này sang chỗ kiaVí dụ từ XML sang C# hoặc CSV, Excel sang C# Tìm kiếm một chuỗi nằm ở nhiều dòng trong Visual Studio hoặc Notepad++Ví dụ tôi cần tìm và xóa bỏ (replace all) các comment như thế này ở code cũ. Bạn cần bóc tách dữ liệu của một trang web.Ví dụ extract (crawling) tách lấy dữ liệu từ một trang web để lưu lại vào cơ sở dữ liệu của bạn Cơn ác mộng đọc một chuỗi string từ DB và cố gắng chuyển đổi nó sang DateTimeChuỗi ngày tháng lưu vào CSDL rất đa dạng. Rất khó để dùng hàm DateTime.TryParse() để tự động chuyển đổi một chuỗi thành Datetime ngon lành cành đào. Tìm kiếm một chuỗi, lưu chuỗi đó lại và lấy chuỗi đã lưu chèn vào chỗ nào đóHay nói cách khác, ta cần thay một chuỗi bằng một chuỗi khác, trong chuỗi mới đó lại có chứa cả chuỗi vừa bị thay thế. Như ví dụ dưới đây sẽ cho các bạn thấy. Ta cần tìm ra ClassName, nhưng không phải thay thế ClassName đó bằng Class khác mà ta sẽ nhét nó vào 2 vị trí thay vì chỉ có 1 vị trí như hiện tại. Vậy RegEx có thể giúp gì cho chúng ta trong các trường hợp trên?Regular Expression sinh ra là để giúp cho cuộc đời của bạn bớt khổ. Hãy tưởng tượng xem bạn phải nai lưng ra copy-paste bao nhiêu code. Bạn hoàn toàn có thể download các tool về để replace giúp bạn. Nhưng bạn cần bao nhiêu tool cho đủ đây. Thay vào đó, bạn hãy thử học RegEx. Bộ cú pháp này sẽ giúp cho bạn thao tác với chuỗi như dao chém chuối. Như ta thấy các ví dụ bên trên, tất cả đều là XỬ LÝ CHUỖI ví dụ Cut Copy Paste hoặc Replace chuỗi. RegEx là ngôn ngữ giúp xử lý chuỗi rất mạnh. RegEx không phải là một ngôn ngữ lập trình. Nó chỉ là một BỘ CÚ PHÁP dùng để bắt chuỗi. Nhưng nó cực kỳ phổ biến và bất kỳ ngôn ngữ lập trình nào cũng hỗ trợ. Nó có cả trăm ngàn ứng dụng và công cụ ăn theo. Hãy lần lượt xem qua các ví dụ sau đây để học cách sử dụng Regular Expression nhé. Bắt đầu sử dụng Regular ExpressionĐể bắt đầu sử dụng và học cách dùng RegEx, mình hay dùng trang web https://regex101.com/. Giao diện như sau: Trước hết các bạn hãy đọc qua một lượt các quy tắc bắt chuỗi (matching) đơn giản nhất của RegEx [xyz] Tìm và so sánh tất cả ký tự nằm trong dấu ngoặc vuông và trùng khớp với 1 ký tự trong dấu ngoặc vuông. Ví dụ: [31] sẽ trùng khớp với 3 hoặc 1, [0123456789] sẽ trùng khớp với bất kỳ một ký tự nào trong khoảng từ 0 đến 9. [a-z] So sánh và trùng khớp với một ký tự nằm trong khoảng chỉ định. Ví dụ: [a-z] sẽ trùng khớp với một ký tự trong khoảng từ a đến z nằm trong chuỗi cần test. [0-9] sẽ trùng khớp với bất kỳ một ký tự nào trong khoảng từ 0 đến 9. [^xyz] So sánh và không trùng khớp với những ký tự nằm trong khoảng chỉ định. Dấu ^ (dấu mũ) nằm trong dấu ngoặc vuông là một dấu phủ định. Ví dụ: [^a-z] sẽ không trùng khớp với tất cả các ký tự nằm trong khoảng từ a đến z. ^ Trùng khớp với phần đầu của chuỗi đích. Ví dụ: ^a sẽ trùng khớp với chữ a trong chuỗi abc, ^\\w+ sẽ trùng khớp với chữ đầu tiên – chữ “the” của chuỗi “The quick brown fox jumps over the lazy dog”. $ Trùng khớp với phần cuối của chuỗi đích. Ví dụ: c$ sẽ trùng khớp với chữ c trong chuỗi abc, \\w+$ sẽ trùng khớp với chữ cuối – chữ “dog” của chuỗi “The quick brown fox jumps over the lazy dog”. Trùng khớp với 1 hoặc nhiều lần ký tự đứng trước nó. Ví dụ \\d+ sẽ chỉ trùng với chuỗi có từ 1 con số trở lên. Trùng khớp với 0 hoặc nhiều lần ký tự đứng trước nó. Ví dụ \\d* sẽ trùng với chuỗi có chứa 1 chữ số hoặc k có chữ số nào cũng đc. ? Trùng khớp với 0 hoặc 1 lần ký tự đứng trước nó. Tương tự như nhưng nó lại chỉ nhân lên 1 lần. thì nhân lên nhiều lần. . Trùng khớp với 1 ký tự đơn bất kỳ ngoại trừ ký tự ngắt dòng (line-break) và cũng không lấy được ký tự có dấu (unicode). Ví dụ: . sẽ trùng khớp với ký tự a hoặc b hoặc c trong chuỗi abc. Nhưng . sẽ không bắt được các chữ ă hoặc ê. x{n} Trùng khớp đúng với n lần ký tự đứng trước nó. n là một số không âm. Ví dụ \\d{2} sẽ bắt đc các số có 2 chữ số đứng liền nhau. x{n,} Trùng khớp với ít nhất n lần ký tự đứng trước nó. n là một số không âm.Ví dụ \\d{2,} sẽ bắt đc các số có từ 2 chữ số trở lên đứng liền nhau. x{n,m} Trùng khớp với ít nhất n lần và nhiều nhất là m lần ký tự đứng trước nó. n và m là một số không âm và n &lt;= m. Ví dụ: a{1,3} sẽ khớp với hah, haah, haaah nhưng không khớp với haaaah. x|y Trùng khớp với x hoặc y. Ví dụ: slow|fast sẽ khớp với chữ slow hoặc fast trong chuỗi đích. \\b Trùng khớp với toàn bộ ký tự đứng trước nó. Ví dụ: hello\\b sẽ trùng khớp với toàn bộ từ hello trong chuỗi hello world nhưng sẽ không khớp với chuỗi helloworld. \\B Ngược lại với \\b, \\B sẽ không khớp với toàn bộ mà chỉ 1 phần ký tự đứng trước nó. Ví dụ: hello\\B sẽ trùng khớp với chữ hello trong chuỗi helloworld nhưng sẽ không khớp với chuỗi hello world. \\d Trùng khớp 1 ký tự số (digit). \\D Trùng khớp 1ký tự không phải số (non-digit). \\s Trùng khớp 1 ký tự khoảng trắng (whitespace) bao gồm khoảng trắng tạo ra bởi phím Tab. \\S Trùng khớp với 1 ký tự không phải là khoảng trắng (non-whitespace). \\w Trùng khớp với các ký tự là từ (word) bao gồm dấu _ (underscore) và chữ số. \\W Trùng khớp với các ký tự không phải là từ (non-word). Ví dụ: \\W sẽ khớp với ký tự % trong chuỗi “100%”. \\uxxxx Trùng khớp với 1 ký tự unicode. Ví dụ: \\u00FA sẽ khớp với ký tự “ú”, \\u00F9 sẽ khớp với ký tự “ù”. \\pL Trùng khớp với một ký tự Unicode bất kỳ ngoại trừ dấu cách. Đây chính là cú pháp viết hoàn hảo hơn của dấu .,Ví dụ \\pL+ sẽ lấy được chuỗi truyền, thuyết trong chuỗi “truyền thuyết”. Đừng lo, hãy xem qua các ví dụ từ từ rồi bạn sẽ hiểu Ví dụ đơn giảnTìm chuỗi số Tìm ngày tháng Link demo: https://regex101.com/r/3dNzjU/1 Tìm ngày tháng chính xácTrong ví dụ trên thì ta thấy có chuỗi “60/60/2018” cũng được coi là ngày tháng, như thế là không chính xác. Ta hãy viết lại cho chuẩn. Link demo: https://regex101.com/r/3dNzjU/2 Cách “tóm lấy” string cần tìm đưa vào Group Cách tạo ra code để dùng RegEx trong các ngôn ngữ lập trìnhRegEx là bộ cú pháp, tuy nhiên để áp dụng nó vào các ngôn ngữ lập trình lại phải tuân thủ theo các thư viện và quy tắc lập trình để lấy ra được các Group đã capture (thu) được. Hãy xem các tạo code ngay sau đây: Cách bắt lấy chuỗi bất kỳ Link demo: https://regex101.com/r/3dNzjU/3 Sử dụng RegEx trong thực tếTrong thực tế RegEx có thể được gõ trực tiếp ở bất kỳ trình Editor nào. Ví dụ mình hay dùng Notepad++, hoặc Visual Studio Tham khảoTham khảo thêm toàn bộ cú pháp RegEx bằng tiếng Anh tại: https://www.cheatography.com/davechild/cheat-sheets/regular-expressions/ Một số công cụ test RegEx Online https://regex101.com/ http://regexr.com/ http://www.regexpal.com/ http://regexper.com/ Bài tập về nhàBạn ngứa tay muốn thử học RegEx ngay và luôn cho nóng. Vậy hãy thử thực hành bằng một số bài tập từ dễ đến khó sau đây nhé. Bài tập nhập môn: Lấy ra các chữ có chữ test trong chuỗi sau: “that tested test is testing the tester’s tests” Lấy ra các số điện thoại trong chuỗi sau: “p:444-555-1234 f:246.555.8888 m:1235554567” Lấy ra các mã màu RGB trong chuỗi sau: “#FF006C ABC 99AAB7FF 0xF0F73611” Lấy ra các chữ có 4 ký tự trong chuỗi sau: “drink beer, it’s very nice!” Lấy ra tên file trong chuỗi URL sau: “rapidshare.com/asd/asd/File.avi.html” Đáp án ở phần comment nhé. Bài tập dành cho học sinh giỏi (lớp học thêm) Tìm cách lấy các URL trong chuỗi HTML sau: 1234567Lorem gyum&lt;b&gt;Betrag&lt;/b&gt; von &lt;a href=\"http://www.vektor.de\"&gt;Vektoren&lt;/a&gt;(Länge eines Vektors)&lt;a href=\"gcfa.com\"&gt;GCFA&lt;/a&gt; &lt;a href=\"//cdn.com/test.js\"&gt;CDN&lt;/a&gt; ist das Maß einer Menge sozu… Tìm cách loại bỏ toàn bộ COMMENT trong đoạn code sau: 123456789var sample = 0; var my_string = \"Hello World!\"; // This is a comment! function do_stuff()&#123; // This is another comment! alert(‘somethings’);/* this is a multiline comment */&#125; Tìm cách lấy ra chuỗi tiếng Nhật trong chuỗi sau: “ 1This is a demo story 前に来た時は北側からで、当時の光景はいまでも思い出せる。And it is true. Lấy ra những file ảnh và độ phân giải của ảnh từ chuỗi sau: 12345678.bash_profileworkspace.docimg0912.jpg (1280x720)updated_img0912.png (1024x768)documentation.htmlfavicon.gif img0912.jpg (1920x1600)access.htaccess Đọc nội dung từ trang tin rss sau: http://rss.cnn.com/rss/edition.rss Lấy ra các Tiêu đề, ngày giờ đăng, nội dung tin vắn Đáp án các bạn post vào phần comment và cùng trao đổi nhé. Nếu các bài tập trên đây vẫn chưa đủ, các bạn hãy làm thêm các bài tập tại trang https://regexone.com nhé, rất nhiều ví dụ hay. Kết luậnHi vọng bài viết nhỏ này đã giúp bạn học được cú pháp viết RegEx và áp dụng vào công việc thường ngày. Mình dùng Regex rất nhiều và nó là trợ thủ đắc lực trong quá trình code. Các bạn thì sao? bạn đã dùng Regex vào những việc gì? Hãy kể tên bên dưới comment để mình cùng học hỏi với nhé. Thanks các bạn đã đọc!","categories":[],"tags":[{"name":"regex","slug":"regex","permalink":"http://nthung2112.github.io/tags/regex/"}]},{"title":"Tìm hiểu Higher-Order Function (HOF) và Currying qua một số ví dụ","slug":"Tim-hieu-Higher-Order-Function-HOF-va-Currying-qua-mot-so-vi-du-3","date":"2018-04-03T04:20:00.000Z","updated":"2018-05-18T01:02:21.693Z","comments":true,"path":"2018/04/Tim-hieu-Higher-Order-Function-HOF-va-Currying-qua-mot-so-vi-du-3.html","link":"","permalink":"http://nthung2112.github.io/2018/04/Tim-hieu-Higher-Order-Function-HOF-va-Currying-qua-mot-so-vi-du-3.html","excerpt":"HOF và Currying là hai kỹ thuật không khó, thậm chí có thể bạn đang dùng nó hàng ngày mà không để ý. Cùng tìm hiểu chúng thông qua một số ví dụ. BackgroundTôi cho rằng một kỹ sư phần mềm pro không phải là người viết ra những dòng code đánh đố người đọc hay đồng nghiệp, mà là người viết những dòng code mà khi người khác đọc nó liền cảm thấy trong sáng, dễ hiểu, dễ bảo trì. Cũng như sự tiến hóa của con người, khi mà “ăn no, ăn sạch rồi ăn ngon”, thì coding cũng có slogan tương tự: “chạy được, chạy đúng, sau cùng là chạy nhanh”.Vậy, sau khi chạy được và chạy đúng rồi, chúng ta nên suy nghĩ xem ngoài việc có thể chạy nhanh hơn ko, thì đoạn code này đã sáng sủa chưa? Nếu bị/được sửa thì có dễ ko? HOF và Currying là 2 trong số ti tỉ kỹ thuật nhằm giúp chúng ta, những lập trình viên huyền thoại, đạt được tiêu chí trên.","text":"HOF và Currying là hai kỹ thuật không khó, thậm chí có thể bạn đang dùng nó hàng ngày mà không để ý. Cùng tìm hiểu chúng thông qua một số ví dụ. BackgroundTôi cho rằng một kỹ sư phần mềm pro không phải là người viết ra những dòng code đánh đố người đọc hay đồng nghiệp, mà là người viết những dòng code mà khi người khác đọc nó liền cảm thấy trong sáng, dễ hiểu, dễ bảo trì. Cũng như sự tiến hóa của con người, khi mà “ăn no, ăn sạch rồi ăn ngon”, thì coding cũng có slogan tương tự: “chạy được, chạy đúng, sau cùng là chạy nhanh”.Vậy, sau khi chạy được và chạy đúng rồi, chúng ta nên suy nghĩ xem ngoài việc có thể chạy nhanh hơn ko, thì đoạn code này đã sáng sủa chưa? Nếu bị/được sửa thì có dễ ko? HOF và Currying là 2 trong số ti tỉ kỹ thuật nhằm giúp chúng ta, những lập trình viên huyền thoại, đạt được tiêu chí trên.Trước khi đi vào khái niệm cụ thể, chúng ta cùng xem ví dụ dưới đây: Ví dụ 1Nhóc con nhà bạn nhờ bạn tìm những số tự nhiên khác 0 nhỏ hơn 20 và là số lẻ.Là một ông bố mẫu mực với niềm kiêu hãnh nhiều năm kinh nghiệm fixed hàng trăm bug nhỏ và tạo ra hàng tá bug to, bạn muốn viết một chương trình hoành tráng để lấy le với con mình. Ok, you win!.Dưới đây chắc hẳn là đoạn code đầu tiên xuất hiện trong đầu: 1234567891011function pickOddNumbers(maximum) &#123; const result = []; for (let i = 1; i &lt;= maximum; i += 1) &#123; if (i % 2 === 1) result.push(i); &#125; return result;&#125;pickOddNumbers(20); Nhưng đời không bao giờ là mơ, khi hôm sau nhóc con lại mếu máo: “Cô giáo cho thêm bài: Tìm những số tự nhiên khác 0 nhỏ hơn 20 mà nếu gấp 3 số đó rồi từ đi 2 thì thu được số chẵn.”.Bố chiều cô luôn. Vậy là bạn lại cho ra phiên bản mới: 1234567891011function pickSpecialNumbers(maximum) &#123; const result = []; for (let i = 1; i &lt;= maximum; i += 1) &#123; if (((i * 3) - 2) % 2 === 0) result.push(i); &#125; return result;&#125;pickSpecialNumbers(20); Đời vẫn ko như mơ khi cô giáo lại cho thêm bài tập: “Tìm những số tự nhiên khác 0 nhỏ hơn 20 mà nếu lấy phần dư số đó cho 9 rồi cộng thêm 2 thì thu số lẻ.”Ơ cô giáo từ từ, để bố em sửa function bên trên đã :)))) Cứ như vậy, mỗi lần cô giáo cho thêm yêu cầu là bạn lại phải sửa phiên bản cũ hoặc cho ra một bản mới, tuy yêu cầu khác nhau nhưng xử lý cơ bản là giống nhau, chỉ khác ở đoạn xử lý điều kiện cho số được chọn.Và bạn chợt nhớ tới HOF, một ứng cử viên sáng giá cho việc làm đoạn code trên sạch hơn, gọn hơn, dễ sửa hơn. Định nghĩa HOFTheo wikipedia thì: 1234A higher-order function (also functional, functional form or functor) is a function that does at least one of the following:・takes one or more functions as arguments,・returns a function as its result. Vietsub: 123HOF là một function mà cho phép thực hiện ít nhất 1 trong 2 khả năng sau:・Nhận vào một hoặc nhiều function như là tham số, hoặc/và・Trả về kết quả là một function. // Bạn có thể thấy có rất nhiều ngôn ngữ hỗ trợ HOF ở link wiki trên. Đến Java còn hỗ trợ nữa là :v Trăm nghe không bằng một thấy, trăm thấy không bằng một sờ, và chúng ta lại cùng sờ với ví dụ bên trên.Lần này là bản nâng cấp có giá trị về mặt học thuật, vì được áp dụng HOF vào cơ mà :))) 12345678910111213141516171819function pickNumbers(maximum, pickingCondition) &#123; const result = []; for (let i = 1; i &lt;= maximum; i += 1) &#123; if (pickingCondition(i)) result.push(i); &#125; return result;&#125;// Chọn ra những số lẻpickNumbers(20, function(number) &#123; return number % 2 === 1;&#125;);// Chọn ra những số mà gấp 3 số đó rồi trừ đi 2 thu số chẵnpickNumbers(20, function(number) &#123; return ((number * 3) - 2) % 2 === 0;&#125;); Với việc đưa HOF vào function bên trên, giờ thì cô giáo thích gì cũng chiều được nhé,chỉ cần thay đổi function kiểm tra điều kiện vào thôi, ko cần phải copy thành function mới nữa. Định nghĩa CurryingLại theo wikipedia: 123Currying is the technique of translating the evaluation of a functionthat takes multiple arguments (or a tuple of arguments)into evaluating a sequence of functions, each with a single argument. Vietsub: 123Currying là kỹ thuật mà cho phép chuyển đổi một function với nhiều tham sốthành những functions liên tiếp có một tham số.// Ví dụ f(a,b,c) có thể được convert thành g(a)h(b, c) hay g(a)h(b)k(c), thậm chí là đổi thứ tự của các function tương ứng... Vậy dễ dàng nhận thấy Currying là một trường hợp của HOF, vì nó thỏa mãn điều kiện trả về kết quả là một function. Cụ thể áp dụng cho ví dụ trên, có thể viết thành dạng sau: 123456789101112131415161718192021function pickNumbers(maximum) &#123; return function (pickingCondition) &#123; const result = []; for (let i = 1; i &lt;= maximum; i += 1) &#123; if (pickingCondition(i)) result.push(i); &#125; return result; &#125;;&#125;// Chọn ra những số lẻpickNumbers(20)(function (number) &#123; return number % 2 === 1;&#125;);// Chọn ra những số mà gấp 3 số đó rồi trừ đi 2 thu số chẵnpickNumbers(20)(function (number) &#123; return (number * 3 - 2) % 2 === 0;&#125;); So sánh ví dụ áp dụng Currying này với ví dụ sử dụng HOF ở trên, rõ ràng là ta chưa thấy sự ưu việt của Currying so với HOF, thậm chí còn thấy hơi rườm rà nữa.Tuy nhiên, hãy cùng xem xét ví dụ dưới đây: Ví dụ 2Viết một function lấy ra giá trị của một key của object, được chọn ra từ một mảng các objects với điều kiện. Đơn giản vậy thôi, nên việc cài đặt cũng có vẻ là đơn giản. Với HOF: 123456789101112function getValue(objects, key, pickingCondition) &#123; var object = null; for (var i = 0; i &lt; objects.length; i++) &#123; if (pickingCondition(objects[i])) &#123; object = objects[i]; break; &#125; &#125; return object ? object[key] : null;&#125;; Mỗi khi gọi function với key khác nhau, hẳn là sẽ phải gọi kiểu như vầy: 12var valueByKey1 = getValue(objects, 'key1', pickingCondition);var valueByKey2 = getValue(objects, 'key2', pickingCondition); Nếu như coi key là biết trước, chỉ thay đổi objects và pickingCondition, thì việc áp dụng Currying là hợp lý: 12345678910111213141516171819202122function getValue(key) &#123; return function (objects, pickingCondition) &#123; let object = null; for (let i = 0; i &lt; objects.length; i++) &#123; if (pickingCondition(objects[i])) &#123; object = objects[i]; break; &#125; &#125; return object ? object[key] : null; &#125;;&#125;;// Wrap getValue thành những function ngắn hơn với tên sáng nghĩa:var getValueByKey1 = getValue('key1');var getValueByKey2 = getValue('key2');// Sử dụng:var valueByKey1 = getValueByKey1(objects, pickingCondition);var valueByKey2 = getValueByKey2(objects, pickingCondition); Khá là gọn gàng. // Ngoài lề: Nếu bạn làm việc với ReactJs, hẳn bạn đã biết tới thuật ngữ Higher-Order Component, hay các selectors mà redux-form cung cấp, thì chúng đều áp dụng kỹ thuật Currying này, cũng như HOF. Dưới đây là một vài ví dụ cho thấy tác dụng tốt của Currying: Ví dụ 3Viết function để kiểm tra độ dài của một xâu s có vượt quá n hay ko. 1234567891011// Cách 1: Không dùng Curryingfunction isLengthOver(s, n)&#123; return s.length &gt; n&#125;// Cách 2: Có Curryingfunction isLengthOver(n)&#123; return function(s)&#123; return s.length &gt; n; &#125;&#125; Giả sử cả 2 cách viết trên được sử dụng cho việc validate của một field trên form, với n = 10 thì có sự khác biệt như sau: Với cách 1: 1&lt;input type=\"text\" validate=&#123;value =&gt; isLengthOver(value, 10)&#125; /&gt; Với cách 2: 1&lt;input type=\"text\" validate=&#123;isLengthOver(10)&#125; /&gt; Quá khác bọt! Ví dụ 4Viết function hiển thị tên group mà một nhân viên đang làm việc, với: Input: employeeGroupId là id của group mà nhân viên đang làm việc, Mảng chứa toàn bộ groups có trong công ty. Điều kiện rằng buộc: Một group luôn có id khác null, Nếu groupB là group con của groupA, thì groupB sẽ có parentGroupId là id của groupA. Group không là con khi parentGroupId của nó là null, Không có quan hệ vòng tròn. (Kiểu: groupA là con groupB, groupB là con groupC, groupC là con groupA) Output: Full path của group mà nhân viên đang làm việc, phân cách bởi dấu /. Ví dụ Group A / Group B / Group C Chắc hẳn bạn sẽ nghĩ tới cách dùng vòng lặp, kiểm tra chừng nào còn tìm thấy group có id bằng parentGroupId. Và tôi cũng nghĩ vậy :D 1234567891011const getGroupFullPathName = (groups, employeeGroupId) =&gt; &#123; const groupNames = []; let group = groups.find(grp =&gt; grp.id === employeeGroupId); while (group) &#123; groupNames.unshift(group.name); group = groups.find(grp =&gt; grp.id === group.parentGroupId); &#125; return groupNames.join('/');&#125;; Nhưng đoạn code trên vẫn chưa ngon, do vi phạm rule Don’t make functions within a loop của ESLint.Cụ thể: Mỗi khi vòng while được chạy thì groups.find(grp =&gt; grp.id === group.parentGroupId) lại sinh ra một anonymous function, chính là grp =&gt; grp.id === group.parentGroupId. Cách khắc phục là ta viết một currying bên ngoài vòng while là được: 123456789101112const getGroupFullPathName = (groups, employeeGroupId) =&gt; &#123; const groupNames = []; const condition = parentGroupId =&gt; group =&gt; group.id === parentGroupId; let group = groups.find(grp =&gt; grp.id === employeeGroupId); while (group) &#123; groupNames.unshift(group.name); group = groups.find(condition(group.parentDepartmentId)); &#125; return groupNames.join('/');&#125;; Kết luận:Bài quá dài. // Nếu mấy ví dụ trên dùng cú pháp của es6 và dùng các api của Array thì sẽ ngắn hơn nhiều, nhưng lại khó nhìn rõ đâu là function được nhận vào/trả ra, nên các bạn chịu khó đọc với cú pháp cơ bản vậy :D","categories":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"hof","slug":"hof","permalink":"http://nthung2112.github.io/tags/hof/"}]},{"title":"CSS Grid vs Flexbox sử dụng như thế nào","slug":"CSS-Grid-vs-Flexbox-su-dung-nhu-the-nao","date":"2018-03-25T13:52:00.000Z","updated":"2018-03-25T07:39:52.137Z","comments":true,"path":"2018/03/CSS-Grid-vs-Flexbox-su-dung-nhu-the-nao.html","link":"","permalink":"http://nthung2112.github.io/2018/03/CSS-Grid-vs-Flexbox-su-dung-nhu-the-nao.html","excerpt":"Tìm hiểu cách chúng khác nhau, và khi bạn nên sử dụng nó.CSS Flexbox đã trở nên cực kỳ quen thuộc với các lập trình viên front-end trong vài năm gần đây. Điều này không đáng ngạc nhiên, bởi vì nó giúp chúng ta tạo ra các bố cục động (dynamic layout) và sắp xếp nội dung trong các container dễ dàng hơn rất nhiều. Tuy nhiên, có một mô-đun mới gọi là CSS Grid và nó có nhiều khả năng giống như Flexbox. Trong một vài trường hợp nó tốt hơn so với Flexbox, và một số trường hợp khác thì không. Điều này có vẻ gây nhầm lẫn cho các lập trình viên. Vì vậy, bài viết này sẽ so sánh hai mô-đun, cả mức độ vi mô và vĩ mô.","text":"Tìm hiểu cách chúng khác nhau, và khi bạn nên sử dụng nó.CSS Flexbox đã trở nên cực kỳ quen thuộc với các lập trình viên front-end trong vài năm gần đây. Điều này không đáng ngạc nhiên, bởi vì nó giúp chúng ta tạo ra các bố cục động (dynamic layout) và sắp xếp nội dung trong các container dễ dàng hơn rất nhiều. Tuy nhiên, có một mô-đun mới gọi là CSS Grid và nó có nhiều khả năng giống như Flexbox. Trong một vài trường hợp nó tốt hơn so với Flexbox, và một số trường hợp khác thì không. Điều này có vẻ gây nhầm lẫn cho các lập trình viên. Vì vậy, bài viết này sẽ so sánh hai mô-đun, cả mức độ vi mô và vĩ mô. Một chiều vs hai chiềuNếu bạn rút ra một bài học từ bài viết này, thì đây là nó: Flexbox được tạo ra cho các bố cục một chiều và Grid được tạo ra cho các bố cục hai chiều. Điều này có nghĩa là nếu bạn đang đặt các item theo một hướng (ví dụ ba nút bên trong header), thì bạn nên sử dụng Flexbox: Nó sẽ linh hoạt hơn CSS Grid. Và cũng dễ dàng hơn để bảo trì và yêu cầu mã ít hơn. Tuy nhiên nếu bạn định tạo bố cục theo hai chiều - với cả các hàng và các cột - thì bạn nên sử dụng CSS Grid: Trong trường hợp này, CSS Grid sẽ linh hoạt hơn, làm cho code của bạn đơn giản hơn và dễ bảo trì hơn. Tất nhiên bạn có thể kết hợp cả hai. Trong ví dụ ở trên, giải pháp hoàn hảo là sử dụng Grid cho việc bố cục trang, và sau đó dùng Flexbox để sắp xếp nội dung bên trong header. Điều này sẽ cung cấp cho bạn những chức năng tốt nhất của cả hai mô-đun. Content-first vs layout-firstMột khác biệt quan trọng nữa giữa 2 mô-đun là Flexbox tập trung vào nội dung trong khi Grid tập trung vào bố cục. Điều này có vẻ trừu tượng, vì vậy hãy xem một ví dụ cụ thể, nó sẽ dễ hiểu hơn. Chúng ta sẽ sử dụng header. Đây là code HTML cho nó: 12345&lt;header&gt; &lt;div&gt;Home&lt;/div&gt; &lt;div&gt;Search&lt;/div&gt; &lt;div&gt;Logout&lt;/div&gt;&lt;/header&gt; Trước khi chúng ta style nó với Flexbox, các div này sẽ được xếp chồng lên nhau như thế này: Flexbox headerTuy nhiên, khi chúng ta style nó với display: flex; các item sẽ được đặt trên một dòng. 123header &#123; display: flex;&#125; Để di chuyển nút logout sang phía bên phải, chúng ta chỉ cần chọn phần tử đó và style với margin: 123header &gt; div:nth-child(3) &#123; margin-left: auto;&#125; Kết quả sẽ như thế này: Cái tôi muốn bạn để ý ở đây là chúng ta để các item tự quyết định vị trí của mình. Chúng ta không phải xác định trước bất cứ điều gì khác ngoài display: flex;. Đây là khác biệt chính giữa Flexbox và Grid, và nó sẽ trở nên rõ ràng hơn khi chúng ta tạo header này bằng cách sử dụng Grid. Mặc dù CSS Grid không được tạo ra cho header một chiều, nhưng vẫn là một ý hay khi làm điều này vì nó dạy cho chúng ta về sự khác biệt cốt lõi giữa Flexbox và Grid. Grid headerChúng ta có thể tạo header theo nhiều cách khác nhau với CSS Grid. Tôi sẽ sử dụng một cách khá đơn giản, trong đó grid của chúng ta có mười cột. 1234header &#123; display: grid; grid-template-columns: repeat(10, 1fr);&#125; Nó sẽ giống hệt với giải pháp Flexbox. Tuy nhiên, chúng ta có thể sử dụng Chrome inspector để kiểm tra các dòng cột: Sự khác biệt chính với cách tiếp cận này là chúng ta phải xác định các cột - bố cục - đầu tiên. Chúng ta bắt đầu với việc xác định chiều rộng của các cột, và sau đó chúng ta đặt nội dung vào các ô có sẵn trong grid. Cách tiếp cận này buộc chúng ta phải xác định số lượng cột mà chúng ta muốn chia trong header. Trừ khi thay đổi grid, còn không chúng ta luôn có 10 cột. Một hạn chế mà chúng ta sẽ không phải đối mặt trong Flexbox. Để thay đổi logout sang phía bên tay phải, chúng ta sẽ đặt nó vào cột thứ mười, như sau: 123header &gt; div:nth-child(3) &#123; grid-column: 10;&#125; Dùng Chrome inspector chúng ta sẽ thấy: Chúng ta không thể chỉ đơn giản style nó với margin-left: auto; vì nút logout đã được đặt trong một ô cụ thể trong bố cục, trong cột thứ ba. Để di chuyển nó, chúng ta phải tìm một ô khác cho nó. Kết hợp cả haiBây giờ chúng ta hãy xem cách kết hợp cả hai, sát nhập header vào bố cục trang web. Chúng ta sẽ bắt đầu bằng cách xây dựng bố cục trang web. Đây là HTML: 123456&lt;div class=\"container\"&gt; &lt;header&gt;HEADER&lt;/header&gt; &lt;aside&gt;MENU&lt;/aside&gt; &lt;main&gt;CONTENT&lt;/main&gt; &lt;footer&gt;FOOTER&lt;/footer&gt;&lt;/div&gt; Đây là CSS: 12345.container &#123; display: grid; grid-template-columns: repeat(12, 1fr); grid-template-rows: 50px 350px 50px;&#125; Chúng ta sẽ đặt các item trên grid như sau: 12345678910111213header &#123; grid-column: span 12;&#125;aside &#123; grid-column: span 2;&#125;main &#123; grid-column: span 10;&#125;footer &#123; grid-column: span 12;&#125; Tiếp theo, chúng ta sẽ chỉ cần thêm style cho header. Chúng ta sẽ biến header - một item trong CSS Grid - thành một Flexbox container. 123header &#123; display: flex;&#125; Chúng ta có thể thiết lập nút logout sang bên phải: 123header &gt; div:nth-child(3) &#123; margin-left: auto;&#125; Kết quả, chúng ta có một bố cục hoàn hảo sử dụng những tính năng tốt nhất từ cả Grid và Flexbox. Hai container sẽ trông như thế này: Bây giờ, bạn đã hiểu rõ sự khác biệt nói chung và cụ thể giữa Flexbox và Grid, và biết cách sử dụng chúng cùng với nhau. Trình duyệt hỗ trợTrước khi kết thúc, tôi cũng cần đề cập đến các trình duyệt hỗ trợ CSS Grid. Vào thời điểm này (25/03/2018), 84.14% website toàn cầu hỗ trợ CSS Grid, và nó đang tăng dần. Tôi tin năm 2018 sẽ là năm của CSS Grid. Nó sẽ đột phá, và sẽ trở thành một kỹ năng phải có của các lập trình viên front-end. Giống như những gì đã xảy ra với CSS Flexbox trong vài năm gần đây.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"flexbox","slug":"flexbox","permalink":"http://nthung2112.github.io/tags/flexbox/"},{"name":"grid","slug":"grid","permalink":"http://nthung2112.github.io/tags/grid/"}]},{"title":"Một số thủ thuật Chrome DevTools có thể bạn đã biết","slug":"Mot-so-thu-thuat-Chrome-DevTools-co-the-ban-da-biet","date":"2018-03-25T07:54:00.000Z","updated":"2018-03-25T15:14:28.961Z","comments":true,"path":"2018/03/Mot-so-thu-thuat-Chrome-DevTools-co-the-ban-da-biet.html","link":"","permalink":"http://nthung2112.github.io/2018/03/Mot-so-thu-thuat-Chrome-DevTools-co-the-ban-da-biet.html","excerpt":"1. Drag-and-drop in the Elements panelIn the Elements panel, you can drag and drop any HTML element and change its position across the page","text":"1. Drag-and-drop in the Elements panelIn the Elements panel, you can drag and drop any HTML element and change its position across the page 2. Reference the currently selected element in the ConsoleSelect a node in the Elements panel, and type $0 in the console to reference it. If you’re using jQuery, you can enter $($0) to access the jQuery API on this element. 3. Use the value of the last operation in the ConsoleUse $_ to reference the return value of the previous operation executed in the Console 4. Add CSS and edit the element stateIn the Elements panel there are two super useful buttons. The first lets you add a new CSS property with any selector you want, but pre-filling the currently selected element: The second one lets you trigger a state for the selected element, so you can see the styles applied when it’s active, hovered, or on focus. 5. Save to file the modified CSSClick the name of the CSS file that you edited. The inspector opens it into the Sources pane, and from there you can save it with the live edits you applied. This trick does not work for new selectors added using +, or into the element.style properties, but only for modified, existing ones. 6. Screenshot a single elementSelect an element and press cmd-shift-p (or ctrl-shift-p in Windows) to open the Command Menu, and select Capture node screenshot 7. Find an element using CSS selectorsPressing cmd-f (ctrl-f in Windows) opens the search box in the Elements panel. You can type any string in there to match the source code, or you can also use CSS selectors to have Chrome generate an image for you: 8. Shift-enter in the ConsoleTo write commands that span over multiple lines in the Console, press shift-enter. Once you’re ready, press enter at the end of the script to execute it: You can clear the console using the Clear button on the top-left of the console, or by pressing ctrl-l or cmd-k. 9. Go to…In the Sources panel: cmd-o (ctrl-o in Windows), shows all the files loaded by your page. cmd-shift-o (ctrl-shift-o in Windows) shows the functions (or classes) in the current file. cmd-l (ctrl-l in Windows) goes to a specific line. 10. Watch ExpressionInstead of writing again and again a variable name or an expression you are going to check a lot during a debug session, add it to the Watch Expression list. 11. XHR/Fetch debuggingFrom the debugger open the XHR/Fetch Breakpoints panel. You can set it to break any time a XHR/Fetch call is sent, or just on specific ones: 12. Debug on DOM modificationsRight-click an element and enable Break on Subtree Modifications. Whenever a script traverses that element’s children and modifies them, the debugger stops automatically to let you inspect what’s happening.","categories":[{"name":"Tips","slug":"Tips","permalink":"http://nthung2112.github.io/categories/Tips/"}],"tags":[{"name":"tips","slug":"tips","permalink":"http://nthung2112.github.io/tags/tips/"},{"name":"chorme","slug":"chorme","permalink":"http://nthung2112.github.io/tags/chorme/"}]},{"title":"Kiến thức cho phỏng vấn Javascript developer","slug":"Kien-thuc-cho-phong-van-Javascript-developer","date":"2018-01-02T15:12:14.000Z","updated":"2018-03-25T04:12:04.733Z","comments":true,"path":"2018/01/Kien-thuc-cho-phong-van-Javascript-developer.html","link":"","permalink":"http://nthung2112.github.io/2018/01/Kien-thuc-cho-phong-van-Javascript-developer.html","excerpt":"JavaScript is the most popular programming language and has been since 2014, according to Stack Overflow Survey. It is no wonder that over 1/3rd of all developer jobs require some JavaScript knowledge. So, if you plan to work as a developer in the near future, you should be familiar with this extremely popular language. The post’s purpose is to bring together all JavaScript concepts that are frequently brought up in developer interviews. It was written so you can review everything you need to know about JavaScript in a single place.","text":"JavaScript is the most popular programming language and has been since 2014, according to Stack Overflow Survey. It is no wonder that over 1/3rd of all developer jobs require some JavaScript knowledge. So, if you plan to work as a developer in the near future, you should be familiar with this extremely popular language. The post’s purpose is to bring together all JavaScript concepts that are frequently brought up in developer interviews. It was written so you can review everything you need to know about JavaScript in a single place. Types &amp; CoercionThere are 7 built-in types: null, undefined , boolean, number, string, object and symbol (ES6). All of these are types are called primitives, except for object. Null vs. Undefined Undefined is the absence of a definition. It is used as the default value for uninitialized variables, function arguments that were not provided and missing properties of objects. Functions return undefined when nothing has been explicitly returned. Null is the absence of a value. It is an assignment value that can be assigned to a variable as a representation of ‘no-value’. Implicit coercion Take a look at the following example: In this case, the string variable name is coerced to true and you have ‘Joey doesn’t share food!’ printed in our console. But how do you know what will be coerced to true and what will be coerced to false? Falsy values are values that will be coerced to false when forced a boolean coercion on it. Falsy values: “”, 0, null, undefined, NaN, false. Anything not explicitly on the falsy list is truthy —boolean coerced to true. Yes. You read it right. Empty arrays, objects and functions are boolean coerced to true! String &amp; Number coercion The first thing you need to be aware of is the + operator. This is a tricky operator because it works for both number addition and string concatenation. But, the *, /, and - operators are exclusive for numeric operations. When these operators are used with a string, it forces the string to be coerced to a number. == vs. === It is widely spread that == checks for equality and === checks for equality and type. Well, that is a misconception. In fact, == checks for equality with coercion and === checks for equality without coercion — strict equality. Coercion can be tricky. Take a look at the following code: What would you expect for the following comparison?console.log(a == b); (1) This comparison actually returns True. Why?What really happens under the hood is that if you are comparing a boolean with something other than a boolean, JavaScript coerces that boolean to a number and compares. (2) This comparison is now between a number and a string. JavaScript now coerces that string to a number and compares both numbers. (3) In this case, the final comparison 0 == 0 is True. 123'0' == false (1)'0' == 0 (2) 0 == 0 (3) For a fully comprehension on how such comparisons are performed, you can check ES5 documentation here. For a cheat sheet, you can click here. Some tricky comparisons to look out for: Value vs. ReferenceSimple values (also known as primitives) are always assigned by value-copy: null, undefined , boolean, number, string and ES6 symbol. Compound values always create a copy of the reference on assignment: objects, which includes arrays, and functions. To copy a compound value by value, you need to makea copy of it. The reference does not point to the original value. Scop_e_Scope refers to the execution context. It defines the accessibility of variables and functions in the code. Global Scope is the outermost scope. Variables declared outside a function are in the global scope and can be accessed in any other scope. In a browser, the window object is the global scope. Local Scope is a scope nested inside another function scope. Variables declared in a local scope are accessible within this scope as well as in any inner scopes. You may think of Scopes as a series of doors decreasing in size (from biggest to smallest). A short person that fits through the smallest door — innermost scope — also fits through any bigger doors — outer scopes. A tall person that gets stuck on the third door, for example, will have access to all previous doors — outer scopes — but not any further doors — inner scopes. HoistingThe behavior of “moving” var and function declarations to the top of their respective scopes during the compilation phase is called hoisting. Function declarations are completely hoisted. This means that a declared function can be called before it is defined. Variables are partially hoisted. var declarations are hoisted but not its assignments. let and const are not hoisted. Function Expression vs. Function Declaration Function Expression A Function Expression is created when the execution reaches it and is usable from then on — it is not hoisted. Function Declaration A Function Declaration can be called both before and after it was defined — it is hoisted. Variables: var, let and constBefore ES6, it was only possible to declare a variable using var. Variables and functions declared inside another function cannot be accessed by any of the enclosing scopes — they are function-scoped. Variables declared inside a block-scope, such as if statements and for loops, can be accessed from outside of the opening and closing curly braces of the block. Note: An undeclared variable — assignment without var, let or const — creates a var variable in global scope. ES6 let and const are new. They are not hoisted and block-scoped alternatives for variable declaration. This means that a pair of curly braces define a scope in which variables declared with either let or const are confined in. A common misconception is that const is immutable. It cannot be reassigned, but its properties can be changed! ClosureA closure is the combination of a function and the lexical environment from which it was declared. Closure allows a function to access variables from an enclosing scope — environment — even after it leaves the scope in which it was declared. The above example covers the two things you need to know about closures: Refers to variables in outer scope.The returned function access themessage variable from the enclosing scope. It can refer to outer scope variables even after the outer function has returned.sayHiToJon is a reference to the greeting function, created when sayHi was run. The greeting function maintains a reference to its outer scope — environment — in which message exists. One of the main benefits of closures is that it allows data encapsulation. This refers to the idea that some data should not be directly exposed. The following example illustrates that. By the time elementary is created, the outer function has already returned. This means that the staff variable only exists inside the closure and it cannot be accessed otherwise. Let’s go deeper into closures by solving one of the most common interview problems on this subject:What is wrong with the following code and how would you fix it? Considering the above code, the console will display four identical messages “The value undefined is at index: 4”. This happens because each function executed within the loop will be executed after the whole loop has completed, referencing to the last value stored in i, which was 4. This problem can be solved by using IIFE, which creates a unique scope for each iteration and storing each value within its scope. Another solution would be declaring the i variable with let, which creates the same result. Immediate Invoked Function Expression (IIFE)An IIFE is a function expression that is called immediately after you define it. It is usually used when you want to create a new variable scope. The (surrounding parenthesis) prevents from treating it as a function declaration. The final parenthesis() are executing the function expression. On IIFE you are calling the function exactly when you are defining it. Using IIFE: Enables you to attach private data to a function. Creates fresh environments. Avoids polluting the global namespace. ContextContext is often confused as the same thing as Scope. To clear things up, lets keep the following in mind:Context is most often determined by how a function is invoked. It always refers to the value of this in a particular part of your code.Scope refers to the visibility of variables. Function calls: call, apply and bindAll of these three methods are used to attach thisinto function and the difference is in the function invocation. .call() invokes the function immediately and requires you to pass in arguments as a list (one by one). .apply() invokes the function immediately and allows you to pass in arguments as an array. .call() and .apply() are mostly equivalent and are used to borrow a method from an object. Choosing which one to use depends on which one is easier to pass the arguments in. Just decide whether it’s easier to pass in an array or a comma separated list of arguments. Quick tip: Apply for Array — Call for Comma. Note: If you pass in an array as one of the arguments on a call function, it will treat that entire array as a single element.ES6 allows us to spread an array as arguments with the call function. 1char.knows.call(Snow, ...[\"nothing\", \"Jon\"]); // You know nothing, Jon Snow .bind() returns a new function, with a certain context and parameters. It is usually used when you want a function to be called later with a certain context. That is possible thanks to its ability to maintain a given context for calling the original function. This is useful for asynchronous callbacks and events. .bind() works like the call function. It requires you to pass in the arguments one by one separated by a comma. ‘this’ keywordUnderstanding the keyword thisin JavaScript, and what it is referring to, can be quite complicated at times. The value of thisis usually determined by a functions execution context. Execution context simply means how a function is called. The keyword thisacts as a placeholder, and will refer to whichever object called that method when the method is actually used. The following list is the ordered rules for determining this. Stop at the first one that applies: new binding — When using the new keyword to call a function, thisis the newly constructed object. Explicit binding — When call or apply are used to call a function, thisis the object that is passed in as the argument.Note: .bind() works a little bit differently. It creates a new function that will call the original one with the object that was bound to it. Implicit binding — When a function is called with a context (the containing object), thisis the object that the function is a property of.This means that a function is being called as a method. Default binding — If none of the above rules applies, thisis the global object (in a browser, it’s the window object).This happens when a function is called as a standalone function.A function that is not declared as a method automatically becomes a property of the global object. Note: This also happens when a standalone function is called from within an outer function scope. Lexical this — When a function is called with an arrow function =&gt;, thisreceives the thisvalue of its surrounding scope at the time it’s created.thiskeeps the value from its original context. Strict ModeJavaScript is executed in strict mode by using the “use strict” directive. Strict mode tightens the rules for parsing and error handling on your code. Some of its benefits are: Makes debugging easier — Code errors that would otherwise have been ignored will now generate errors, such as assigning to non-writable global or property. Prevents accidental global variables — Assigning a value to an undeclared variable will now throw an error. Prevents invalid use of delete — Attempts to delete variables, functions and undeletable properties will now throw an error. Prevents duplicate property names or parameter values — Duplicated named property in an object or argument in a function will now throw an error. (This is no longer the case in ES6) Makes eval() safer — Variables and functions declared inside an eval() statement are not created in the surrounding scope. “Secures” JavaScript eliminating this coercion — Referencing a this value of null or undefined is not coerced to the global object. This means that in browsers it’s no longer possible to reference the window object using this inside a function. new keywordThe new keyword invokes a function in a special way. Functions invoked using the new keyword are called constructor functions. So what does the new keyword actually do? Creates a new object. Sets the object’s prototypeto be the prototypeof the constructor function. Executes the constructor function with this as the newly created object. Returns the created object. If the constructor returns an object, this object is returned. What is the difference between invoking a function with the new keyword and without it? Prototype and InheritancePrototype is one of the most confusing concepts in JavaScript and one of the reason for that is because there are two different contexts in which the word prototype is used. Prototype relationship Each object has a prototypeobject, from which it inherits all of its prototype’s properties..proto is a non-standard mechanism (available in ES6) for retrieving the prototypeof an object (*). It points to the object’s “parent” —the object’s prototype.All normal objects also inherit a .constructor property that points to the constructor of the object. Whenever an object is created from a constructor function, the .proto property links that object to the .prototype property of the constructor function used to create it.(*) _Object.getPrototypeOf()_is the standard ES5 function for retrieving the prototype of an object. Prototype property Every function has a .prototype property.It references to an object used to attach properties that will be inherited by objects further down the prototype chain. This object contains, by default, a .constructor property that points to the original constructor function.Every object created with a constructor function inherits a constructor property that points back to that function. Prototype ChainThe prototype chain is a series of links between objects that reference one another. When looking for a property in an object, JavaScript engine will first try to access that property on the object itself. If it is not found, the JavaScript engine will look for that property on the object it inherited its properties from — the object’s prototype. The engine will traverse up the chain looking for that property and return the first one it finds. The last object in the chain is the built-in Object.prototype, which has null as its prototype. Once the engine reaches this object, it returns undefined. Own vs Inherited PropertiesObjects have own properties and inherited properties. Own properties are properties that were defined on the object. Inherited properties were inherited through prototype chain. Object.create(obj) — Creates a new object with the specified prototypeobject and properties. Inheritance by referenceAn inherited property is a copy by reference of the prototype object’sproperty from which it inherited that property. If an object’s property is mutated on the prototype, objects which inherited that property will share the same mutation. But if the property is replaced, the change will not be shared. Classical Inheritance vs. Prototypal InheritanceIn classical inheritance, objects inherit from classes — like a blueprint or a description of the object to be created — and create sub-class relationships. These objects are created via constructor functions using the new keyword. The downside of classical inheritance is that it causes:inflexible hierarchytight coupling problemsfragile base class problemsduplication problemsAnd the so famous gorilla/banana problem — “What you wanted was a banana, what you got was a gorilla holding the banana, and the entire jungle.” In prototypal inheritance, objects inherit directly from other objects. Objects are typically created via Object.create(), object literals or factory functions. There are three different kinds of prototypal inheritance: Prototype delegation — A delegate prototype is an object which is used as a model for another object. When you inherit from a delegate prototype, the new object gets a reference to the prototype and its properties.This process is usually accomplished by using Object.create(). Concatenative inheritance — The process of inheriting properties from one object to another by copying the object’s prototype properties, without retaining a reference between them.This process is usually accomplished by using Object.assign(). Functional inheritance — This process makes use of a factory function(*) to create an object, and then adds new properties directly to the created object.This process has the benefit of allowing data encapsulation via closure.(*)Factory function is a function that is not a class or constructor that returns an object without using the new keyword. You can find a complete article on this topic by Eric Elliott here. Favor composition over class inheritanceMany developers agree that class inheritance should be avoided in most cases. In this pattern you design your types regarding what they are, which makes it a very strict pattern. Composition, on the other hand, you design your types regarding what they do, which makes it more flexible and reusable. Here is a nice video on this topic by Mattias Petter Johansson Asynchronous JavaScriptJavaScript is a single-threaded programming language. This means that the JavaScript engine can only process a piece of code at a time. One of its main consequences is that when JavaScript encounters a piece of code that takes a long time to process, it will block all code after that from running. JavaScript uses a data structure that stores information about active functions named Call Stack. A Call Stack is like a pile of books. Every book that goes into that pile sits on top of the previous book. The last book to go into the pile will be the first one removed from it, and the first book added to the pile will be the last one removed. The solution to executing heavy pieces of code without blocking anything is asynchronous callback functions. These functions are executed later — asynchronously. The asynchronous process begins with an asynchronous callback functions placed into a Heap or region of memory. You can think of the Heap as an Event Manager. The Call Stack asks the Event Manager to execute a specific function only when a certain event happens. Once that event happens, the Event Manager moves the function to the Callback Queue. Note: When the Event Manager handles a function, the code after that is not blocked and JavaScript continues its execution. The Event Loop handles the execution of multiple pieces of your code over time. The Event Loop monitors the Call Stack and the Callback Queue. The Call Stack is constantly checked whether it is empty or not. When it is empty, the Callback Queue is checked if there is a function waiting to be invoked. When there is a function waiting, the first function in the queue is pushed into the Call Stack, which will run it. This checking process is called a ‘tick’ in the Event Loop. Let’s break down the execution of the following code to understand how this process works: Initially the Browser console is clear and the Call Stack and Event Manager are empty. first() is added to the Call Stack. console.log(“First message”) is added to the Call Stack. console.log(“First message”) is executed and the Browser console displays “First message”_._ console.log(“First message”) is removed from the Call Stack. first() is remove from the Call Stack. setTimeout(second, 0) is added to the Call Stack. setTimeout(second, 0) is executed and handled by the Event Manager. And after 0ms the Event Manager moves second() to the Callback Queue. setTimeout(second, 0) is now completed and removed from the Call Stack. third() is added to the Call Stack. console.log(“Third message”) is added to the Call Stack. console.log(“Third message”) is executed and the Browser console displays “Third message”_._ console.log(“Third message”) is removed from the Call Stack. Call Stack is now empty and the second() function is waiting to be invoked in the Callback Queue. The Event Loop moves second() from the Callback Queue to the Call Stack. console.log(“Second message”) is added to the Call Stack. console.log(“Second message”) is executed and the Browser console displays “Second message”. console.log(“Second message”) is removed from the Call Stack. second() is removed from the Call Stack. Note: The second() function is not executed after 0ms. The time you pass in to setTimeout function does not relate to the delay of its execution. The Event Manager will wait the given timebefore moving that function into the Callback Queue. Its execution will only take place on a future ‘tick’ in the Event Loop.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Cải thiện tốc độ Web App với Tinder","slug":"Cai-thien-toc-do-Web-App-voi-Tinder","date":"2017-12-25T11:29:59.000Z","updated":"2018-03-24T03:25:31.654Z","comments":true,"path":"2017/12/Cai-thien-toc-do-Web-App-voi-Tinder.html","link":"","permalink":"http://nthung2112.github.io/2017/12/Cai-thien-toc-do-Web-App-voi-Tinder.html","excerpt":"Tinder recently swiped right on the web. Their new responsive Progressive Web App — Tinder Online — is available to 100% of users on desktop and mobile, employing techniques for JavaScript performance optimization, Service Workers for network resilience and Push Notifications for chat engagement. Today we’ll walk through some of their web perf learnings.","text":"Tinder recently swiped right on the web. Their new responsive Progressive Web App — Tinder Online — is available to 100% of users on desktop and mobile, employing techniques for JavaScript performance optimization, Service Workers for network resilience and Push Notifications for chat engagement. Today we’ll walk through some of their web perf learnings. Journey to a Progressive Web AppTinder Online started with the goal of getting adoption in new markets, striving to hit feature parity with V1 of Tinder’s experience on other platforms. The MVP for the PWA took 3 months to implement using React as their UI library and Redux for state management. The result of their efforts is a PWA that delivers the core Tinder experience in 10% of the data-investment costs for someone in a data-costly or data-scarce market: Comparing the data-investment for Tinder Online vs the native apps. It’s important to note that this isn’t comparing apples to apples, however. The PWA loads code for new routes on demand, and the cost of additional code is amortized over the lifetime of the application. Subsequent navigations still don’t cost as much data as the download of the app. Early signs show good swiping, messaging and session length compared to the native app. With the PWA: Users swipe more on web than their native apps Users message more on web than their native apps Users purchase on par with native apps Users edit profiles more on web than on their native apps Session times are longer on web than their native apps PerformanceThe mobile devices Tinder Online’s users most commonly access their web experience with include: Apple iPhone &amp; iPad Samsung Galaxy S8 Samsung Galaxy S7 Motorola Moto G4 Using the Chrome User Experience report (CrUX), we’re able to learn that the majority of users accessing the site are on a 4G connection: Note: Rick Viscomi recently covered CrUX on PerfPlanet and Inian Parameshwaran covered rUXt for better visualizing this data for the top 1M sites. Testing the new experience on WebPageTest and Lighthouse (using the Galaxy S7 on 4G) we can see that they’re able to load and get interactive in under 5 seconds: There is of course lots of room to improve this further on median mobile hardware (like the Moto G4), which is more CPU constrained: Tinder are hard at work on optimizing their experience and we look forward to hearing about their work on web performance in the near future. Performance OptimizationTinder were able to improve how quickly their pages could load and become interactive through a number of techniques. They implemented route-based code-splitting, introduced performance budgets and long-term asset caching. Route-level code-splittingTinder initially had large, monolithic JavaScript bundles that delayed how quickly their experience could get interactive. These bundles contained code that wasn’t immediately needed to boot-up the core user experience, so it could be broken up using code-splitting. It’s generally useful to only ship code users need upfront and lazy-load the rest as needed. To accomplish this, Tinder used React Router and React Loadable. As their application centralized all their route and rendering info a configuration base, they found it straight-forward to implement code splitting at the top level. In summary: React Loadable is a small library by James Kyle to make component-centric code splitting easier in React. Loadable is a higher-order component (a function that creates a component) which makes it easy to split up bundles at a component level. Let’s say we have two components “A” and “B”. Before code-splitting, Tinder statically imported everything (A, B, etc) into their main bundle. This was inefficient as we didn’t need both A and B right away: After adding code-splitting, components A and B could be loaded as and when needed. Tinder did this by introducing React Loadable, dynamic import() and webpack’s magic comment syntax (for naming dynamic chunks) to their JS: For “vendor” (library) chunking, Tinder used the webpack CommonsChunkPlugin to move commonly used libraries across routes up to a single bundle file that could be cached for longer periods of time: Next, Tinder used React Loadable’s preload support to preload potential resources for the next page on control component: Tinder also used Service Workers to precache all their route level bundles and include routes that users are most likely to visit in the main bundle without code-splitting. They’re of course also using common optimizations like JavaScript minification via UglifyJS: 12345678new webpack.optimize.UglifyJsPlugin(&#123; parallel: true, compress: &#123; warnings: false, screw_ie8: true &#125;, sourceMap: SHOULD_SOURCEMAP &#125;), ImpactAfter introducing route-based code-splitting their main bundle sizes went down from 166KB to 101KB and DCL improved from 5.46s to 4.69s: Long-term asset cachingEnsuring long-term caching of static resources output by webpack benefits from using [chunkhash] to add a cache-buster to each file. Tinder were using a number of open-source (vendor) libraries as part of their dependency tree. Changes to these libraries would originally cause the [chunkhash] to change and invalidate their cache. To address this, Tinder began defining a whitelist of external dependencies and splitting out their webpack manifest from the main chunk to improve caching. The bundle size is now about 160KB for both chunks. Preloading late-discovered resourcesAs a refresher, is a declarative instruction to the browser to load critical, late-discovered resources earlier on. In single-page applications, these resources can sometimes be JavaScript bundles. Tinder implemented support for to preload their critical JavaScript/webpack bundles that were important for the core experience. This reduced load time by 1s and first paint from 1000ms to about 500ms. Performance budgetsTinder adopted performance budgets for helping them hit their performance goals on mobile. As Alex Russell noted in “Can you afford it?: real-world performance budgets”, you have a limited headroom to deliver an experience when considering slow 3G connections being used on median mobile hardware. To get and stay interactive quickly, Tinder enforced a budget of ~155KB for their main and vendor chunks, asynchronous (lazily loaded) chunks are ~55KB and other chunks are ~35KB. CSS has a limit of 20KB. This was crucial to ensuring they were able to avoid regressing on performance. Webpack Bundle AnalysisWebpack Bundle Analyzer allows you to discover what the dependency graph for your JavaScript bundles looks like so you can discover whether there’s low-hanging fruit to optimize. Tinder used Webpack Bundle Analyzer to discover areas for improvement: Polyfills: Tinder are targeting modern browsers with their experience but also support IE11 and Android 4.4 and above. To keep polyfills &amp; transpiled code to a minimum, they use For polyfills, they use babel-preset-env and core-js. Slimmer use of libraries: Tinder replaced localForage with direct use of IndexedDB. Better splitting: Split out components from the main bundles which were not required for first paint/interactive Code re-use: Created asynchronous common chunks to abstract chunks used more than three times from children. CSS: Tinder also removed critical CSS from their core bundles (as they had shifted to server-side rendering and delivered this CSS anyway) Using bundle analysis led to also also taking advantage of Webpack’s Lodash Module Replacement Plugin. The plugin creates smaller Lodash builds by replacing feature sets of modules with noop, identity or simpler alternatives: Webpack Bundle Analyzer can be integrated into your Webpack config. Tinder’s setup for it looks like this: 12345678910plugins: [ new BundleAnalyzerPlugin(&#123; analyzerMode: 'server', analyzerPort: 8888, reportFilename: 'report.html', openAnalyzer: true, generateStatsFile: false, statsFilename: 'stats.json', statsOptions: null &#125;) The majority of the JavaScript left is the main chunk which is trickier to split out without architecture changes to Redux Reducer and Saga Register. CSS StrategyTinder are using Atomic CSS to create highly reusable CSS styles. All of these atomic CSS styles are inlined in the initial paint and some of the rest of the CSS is loaded in the stylesheet (including animation or base/reset styles). Critical styles have a maximum size of 20KB gzipped, with recent builds coming in at a lean &lt; 11KB. Tinder use CSS stats and Google Analytics for each release to keep track of what has changed. Before Atomic CSS was being used, average page load times were ~6.75s. After they were ~5.75s. Tinder Online also uses the PostCSS Autoprefixer plugin to parse CSS and add vendor prefixes based on rules from Can I Use: 12345678910111213141516new webpack.LoaderOptionsPlugin(&#123; options: &#123; context: paths.basePath, output: &#123; path: './' &#125;, minimize: true, postcss: [ autoprefixer(&#123; browsers: [ 'last 2 versions', 'not ie &lt; 11', 'Safari &gt;= 8' ] &#125;) ] &#125;&#125;), Runtime performanceDeferring non-critical work with requestIdleCallback()To improve runtime performance, Tinder opted to use requestIdleCallback() to defer non-critical actions into idle time. 1requestIdleCallback(myNonEssentialWork); This included work like instrumentation beacons. They also simplified some HTML composite layers to reduce paint count while swiping. Using requestIdleCallback() for their instrumentation beacons while swiping: before.. and after.. Dependency upgradesWebpack 3 + Scope Hoisting In older versions of webpack, when bundling each module in your bundle would be wrapped in individual function closures. These wrapper functions made it slower for your JavaScript to execute in the browser. Webpack 3 introduced “scope hoisting” — the ability to concatenate the scope of all your modules into one closure and allow for your code to have a faster execution time in the browser. It accomplishes this with the Module Concatenation plugin: 1new webpack.optimize.ModuleConcatenationPlugin() Webpack 3’s scope hoisting improved Tinder’s initial JavaScript parsing time for vendor chunk by 8%. React 16 React 16 introduced improvements that decreased React’s bundle size compared to previous versions. This was in part due to better packaging (using Rollup) as well as removing now unused code. By updating from React 15 to React 16, Tinder reduced the total gzipped size of their vendor chunk by ~7%. The size of react + react-dom used to be~50KB gzipped and is now just ~35KB. Thanks to Dan Abramov, Dominic Gannaway and Nate Hunzaker who were instrumental in trimming down React 16’s bundle size. Workbox for network resilience and offline asset cachingTinder also use the Workbox Webpack plugin for caching both their Application Shell and their core static assets like their main, vendor, manifest bundles and CSS. This enables network resilience for repeat visits and ensures that the application starts-up more quickly when a user returns for subsequent visits. OpportunitiesDigging into the Tinder bundles using source-map-explorer (another bundle analysis tool), there are additional opportunities for reducing payload size. Before logging in, components like Facebook Photos, notifications, messaging and captchas are fetched. Moving these away from the critical path could save up to 20% off the main bundle: Another dependency in the critical path is a 200KB Facebook SDK script. Dropping this script (which could be lazily loaded when needed) could shave 1 second off initial loading time. ConclusionsTinder are still iterating on their Progressive Web App but have already started to see positive results from the fruits of their labor. Check out Tinder.com and stay tuned for more progress in the near future! With thanks and congrats to Roderick Hsiao, Jordan Banafsheha, and Erik Hellenbrand for launching Tinder Online and their input to this article. Thanks to Cheney Tsai for his review. Related reading: A Pinterest PWA performance case study A Treebo React &amp; Preact performance case study Twitter Lite and high-performance PWAs at scale This article was cross-posted from Performance Planet. If you’re new to React, I’ve found React for Beginners a comprehensive starting point.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"JavaScript Start-up Performance","slug":"JavaScript-Start-up-Performance","date":"2017-12-16T07:46:39.000Z","updated":"2017-12-16T07:59:58.668Z","comments":true,"path":"2017/12/JavaScript-Start-up-Performance.html","link":"","permalink":"http://nthung2112.github.io/2017/12/JavaScript-Start-up-Performance.html","excerpt":"JavaScript Start-up PerformanceAs web developers, we know how easy it is to end up with web page bloat. But loading a webpage is much more than shipping bytes down the wire. Once the browser has downloaded our page’s scripts it then has to parse, interpret &amp; run them. In this post, we’ll dive into this phase for JavaScript, why it might be slowing down your app’s start-up &amp; how you can fix it. Historically, we just haven’t spent a lot of time optimizing for the JavaScript Parse/Compile step. We almost expect scripts to be immediately parsed and executed as soon as the parser hits a &lt;script&gt; tag. But this isn’t quite the case. Here’s a simplified breakdown of how V8 works: A simplified view of how V8 works. This is our idealized pipeline that we’re working towards. Let’s focus on some of the main phases.","text":"JavaScript Start-up PerformanceAs web developers, we know how easy it is to end up with web page bloat. But loading a webpage is much more than shipping bytes down the wire. Once the browser has downloaded our page’s scripts it then has to parse, interpret &amp; run them. In this post, we’ll dive into this phase for JavaScript, why it might be slowing down your app’s start-up &amp; how you can fix it. Historically, we just haven’t spent a lot of time optimizing for the JavaScript Parse/Compile step. We almost expect scripts to be immediately parsed and executed as soon as the parser hits a &lt;script&gt; tag. But this isn’t quite the case. Here’s a simplified breakdown of how V8 works: A simplified view of how V8 works. This is our idealized pipeline that we’re working towards. Let’s focus on some of the main phases. What slows our web apps from booting up?Parsing, Compiling and Executing scripts are things a JavaScript engine spends significant time in during start-up. This matters as if it takes a while, it can delay how soon users can interact with our site. Imagine if they can see a button but not click or touch it for multiple seconds. This can degrade the user experience. Parse &amp; Compile times for a popular website using V8’s Runtime Call Stats in Chrome Canary. Notice how a slow Parse/Compile on desktop can take far longer on average mobile phones. Start-up times matter for performance-sensitive code. In fact, V8 - Chrome’s JavaScript engine, spends a large amount of time parsing and compiling scripts on top sites like Facebook, Wikipedia and Reddit: The pink area (JavaScript) represents time spent in V8 and Blink’s C++, while the orange and yellow represent parse and compile. Parse and Compile have also been highlighted as a bottleneck by a number of large sites &amp; frameworks you may be using. Below are tweets from Facebook’s Sebastian Markbage and Google’s Rob Wormald: Sam Saccone calls out the cost of JS parse in ‘Planning for Performance’As we move to an increasingly mobile world, it’s important that we understand the time spent in Parse/Compile can often be 2–5x as long on phones as on desktop. Higher-end phones (e.g the iPhone or Pixel) will perform very differently to a Moto G4. This highlights the importance of us testing on representative hardware (not just high-end!) so our users’ experiences don’t suffer.Parse times for a 1MB bundle of JavaScript across desktop &amp; mobile devices of differing classes. Notice how close a high-end phone like an iPhone 7 is to perf on a Macbook Pro vs the performance as we go down the graph towards average mobile hardware.If we’re shipping huge bundles for our app, this is where endorsing modern bundling techniques likecode-splitting, tree-shaking and Service Worker caching can really make a huge difference. That said, even a small bundle, written poorly or with poor library choices can result in the main thread being pegged for a long time in compilation or function call times. It’s important to holistically measure and understand where our real bottlenecks are.### What Are JavaScript Parse &amp; Compile bottlenecks for the average website?“Buuuut, I’m not Facebook”, I hear you say dear, reader. “How heavy are Parse &amp; Compile times for average sites out in the wild?”, you might be asking. Let’s science this out!I spent two months digging into the performance of a large set of production sites (6000+) built with different libraries and frameworks — like React, Angular, Ember and Vue. Most of the tests were recently redone on WebPageTest so you can easily redo them yourself or dig into the numbers if you wish. Here are some insights.Apps became interactive in 8 seconds on desktop (using cable) and 16 seconds on mobile (Moto G4 over 3G)What contributed to this? Most apps spent an average of 4 seconds in start-up (Parse/Compile/Exec)..on desktop.On mobile, parse times were up to 36% higher than they were on desktop.Was everyone shipping huge JS bundles? Not as large as I had guessed, but there’s room for improvement. At the median, developers shipped 410KB of gzipped JS for their pages. This is in line with the 420KB over ‘average JS per page’ reported by the HTTPArchive. The worst offenders were sending anywhere up to 10MB of script down the wire. Oof.HTTPArchive stat: the average page ships down 420KB of JavaScriptScript size is important, but it isn’t everything. Parse and Compile times don’t necessarily increase linearly when the script size increases. Smaller JavaScript bundles generally do result in a faster load time (regardless of our browser, device &amp; network connection) but 200KB of our JS !== 200KB of someone else’s and can have wildly different parse and compile numbers.### Measuring JavaScript Parse &amp; Compile todayChrome DevToolsTimeline (Performance panel) &gt; Bottom-Up/Call Tree/Event Log will let us drill into the amount of time spent in Parse/Compile. For a more complete picture (like the time spent in Parsing, Preparsing or Lazy Compiling), we can turn on V8’s Runtime Call Stats. In Canary, this will be in Experiments &gt; V8 Runtime Call Stats on Timeline.Chrome Tracingabout:tracing — Chrome’s lower-level Tracing tool allows us to use the disabled-by-default-v8.runtime_stats category to get deeper insights into where V8 spends its time. V8 have a step-by-step guide on how to use this that was published just the other day.WebPageTestWebPageTest’s “Processing Breakdown” page includes insights into V8 Compile, EvaluateScript and FunctionCall time when we do a trace with the Chrome &gt; Capture Dev Tools Timeline enabled.We can now also get out the Runtime Call Stats by specifying disabled-by-default-v8.runtime_stats as a custom Trace category (Pat Meenan of WPT now does this by default!).For a guide on how to get the most out of this, see this gist I wrote up.User TimingIt’s possible to measure Parse times through the User Timing API as Nolan Lawson points out below: The third &lt;script&gt; here isn’t important, but it’s the first &lt;script&gt; being separate from the second (performance.mark() starting before the &lt;script&gt; has been reached) that is. This approach can be affected on subsequent reloads by V8’s preparser. This could be worked around by appending a random string to the end of the script, something Nolan does in his optimize-js benchmarks. I use a similar approach for measuring the impact of JavaScript Parse times using Google Analytics: A custom Google Analytics dimension for ‘parse’ allows me to measure JavaScript parse times from real users and devices hitting my pages in the wild. DeviceTiming Etsy’s DeviceTiming tool can help measure parse &amp; execution times for scripts in a controlled environment. It works by wrapping local scripts with instrumentation code so that each time our pages are hit from different devices (e.g laptops, phones, tablets) we can locally compare parse/exec. Daniel Espeset’s Benchmarking JS Parsing and Execution on Mobile Devices goes into more detail on this tool. What can we do to lower our JavaScript parse times today? Ship less JavaScript. The less script that requires parsing, the lower our overall time spent in the parse &amp; compile phases will be. Use code-splitting to only ship the code a user needs for a route and lazy load the rest. This probably is going to help the most to avoid parsing too much JS. Patterns like PRPL encourage this type of route-based chunking, now used by Flipkart, Housing.com and Twitter. Script streaming: In the past, V8 have told developers to use async/defer to opt into script streaming for parse-time improvements of between 10–20%. This allows the HTML parser to at least detect the resource early, push the work to the script streaming thread and not halt the document parsing. Now that this is done for parser-blocking scripts too, I don’t think there’s anything actionable we need to do here. V8 recommend loading larger bundles earlier on as there’s only one streamer thread (more on this later) Measure the parse cost of our dependencies, such as libraries and frameworks. Where possible, switch them out for dependencies with faster parse times (e.g switch React for Preact or Inferno, which require fewer bytes to bootup and have smaller parse/compile times). Paul Lewis covered framework bootup costs in a recent article. As Sebastian Markbage has also noted, a good way to measure start-up costs for frameworks is to first render a view, delete and then render again as this can tell you how it scales. The first render tends to warm up a bunch of lazily compiled code, which a larger tree can benefit from when it scales. If our JavaScript framework of choice supports an ahead-of-time compilation mode (AoT), this can also help heavily reduce the time spent in parse/compile. Angular apps benefit from this for example: Nolan Lawson’s ‘Solving the Web Performance Crisis’ What are browsers doing to improve Parse &amp; Compile times today?Developers are not the only ones to still be catching up on real-world start-up times being an area for improvement. V8 discovered that Octane, one of our more historical benchmarks, was a poor proxy for real-world performance on the 25 popular sites we usually test. Octane can be a poor proxy for 1) JavaScript frameworks (typically code that isn’t mono/polymorphic) and 2) real-page app startup (where most code is cold). These two use-cases are pretty important for the web. That said, Octane isn’t unreasonable for all kinds of workloads. The V8 team has been hard at work improving start-up time and we’ve already seem some wins here: We also estimate a 25% improve on V8 parse times for many pages looking at our Octane-Codeload numbers: And we’re seeing wins in this area for Pinterest too. There are a number of other explorations V8 has started over the last few years to improve Parsing and Compile times. Code caching From using V8’s code caching Chrome 42 introduced code caching — a way to store a local copy of compiled code so that when users returned to the page, steps like script fetching, parsing and compilation could all be skipped. At the time we noted that this change allowed Chrome to avoid about 40% of compilation time on future visits, but I want to provide a little more insight into this feature: Code caching triggers for scripts that are executed twice in 72 hours. For scripts of Service Worker: Code caching triggers for scripts that are executed twice in 72 hours. For scripts stored in Cache Storage via Service Worker: Code caching triggers for scripts in the first execution. So, yes. If our code is subject to caching V8 will skip parsing and compiling on the third load. We can play around with these in chrome://flags/#v8-cache-strategies-for-cache-storage to look at the difference. We can also run Chrome with — js-flags=profile-deserialization to see if items are being loaded from the code cache (these are presented as deserialization events in the log). One caveat with code caching is that it only caches what’s being eagerly compiled. This is generally only the top-level code that’s run once to setup global values. Function definitions are usually lazily compiled and aren’t always cached. IIFEs (for users of optimize-js ;)) are also included in the V8 code cache as they are also eagerly compiled. Script Streaming Script streaming allows async or defer scripts to be parsed on a separate background thread once downloading begins and improves page loading times by up to 10%. As noted earlier, this now also works for sync scripts. Since the feature was first introduced, V8 have switched over to allowing all scripts, even parser blocking &lt;script src=””&gt; to be parsed on a background thread so everyone should be seeing some wins here. The only caveat is that there’s only one streaming background thread and so it makes sense to put our large/critical scripts in here first. It’s important to measure for any potential wins here. Practically, &lt;script defer&gt; in the &lt;head&gt; so we can discover the resource early and then parse it on the background thread. It’s also possible to check with DevTools Timeline whether the correct scripts get streamed — if there’s one big script that dominates the parse time, it would make sense to make sure it’s (usually) picked up by the streaming. Better Parsing &amp; Compiling Work is ongoing for a slimmer and faster Parser that frees up memory and is more efficient with data structures. Today, the largest cause of main thread jank for V8 is the nonlinear parsing cost. Take a snippet of UMD: (function (global, module) { … })(this, function module() { my functions }) V8 won’t know that module is definitely needed so we won’t compile it when the main script gets compiled. When we decide to compile module, we need to reparse all of the inner functions. This is what makes V8’s parse-times non-linear. Every function at n-th depth is parsed n times and causes jank. V8 are already working on collecting info about inner functions during the initial compile, so any future compilations can ignore their inner functions. For module-style functions, this should result in a large perf improvement. See ‘The V8 Parser(s) — Design, Challenges, and Parsing JavaScript Better’ for the full story. V8 are also exploring offloading parts of JavaScript compilation to the background during startup. Precompiling JavaScript? Every few years, it’s proposed engines offer a way to precompile scripts so we don’t waste time parsing or compiling code pops up. The idea is if instead, a build-time or server-side tool can just generate bytecode, we’d see a large win on start-up time. My opinion is shipping bytecode can increase your load-time (it’s larger) and you would likely need to sign the code and process it for security. V8’s position is for now we think exploring avoiding reparsing internally will help see a decent enough boost that precompilation may not offer too much more, but are always open to discussing ideas that can lead to faster startup times. That said, V8 are exploring being more aggressive at compiling and code-caching scripts when you update a site in a Service Worker and we hope to see some wins with this work. We discussed precompilation at BlinkOn 7 with Facebook and Akamai and my notes can be found here. The Optimize JS lazy-parsing parens ‘hack’ JavaScript engines like V8 have a lazy parsing heuristic where they pre-parse most of the functions in our scripts before doing a complete round of parsing (e.g to check for syntax errors). This is based on the idea that most pages have JS functions that are lazily executed if at all. Pre-parsing can speed up startup times by only checking the minimal a browser needs to know about functions. This breaks down with IIFEs. Although engines try to skip pre-parsing for them, the heuristics aren’t always reliable and this is where tools like optimize-js can be useful. optimize-js parses our scripts in advance, inserts parenthesis where it knows (or assumes via heuristics) functions will be immediately executed enabling faster execution. Some of the paren-hacked functions are sure bets (e.g IIFEs with !). Others are based on heuristics (e.g in a Browserify or Webpack bundle it’s assumed all modules are eagerly loaded which isn’t necessarily the case). Eventually, V8 hopes for such hacks to not be required but for now this is an optimization we can consider if we know what you’re doing. V8 are also working on reducing the cost for cases where we guess wrong, and that should also reduce the need for the parens hack ConclusionsStart-up performance matters. Acombination of slow parse, compile and execution times can be a real bottleneck for pages that wish to boot-up quickly. Measure how long your pages spend in this phase. Discover what you can do to make it faster. We’ll keep working on improving V8 start-up performance from our end as much as we can. We promise ;) Happy perfing! Read More Planning for Performance Solving the Web Performance Crisis by Nolan Lawson JS Parse and Execution Time Measuring Javascript Parse and Load Unpacking the Black Box: Benchmarking JS Parsing and Execution on Mobile Devices (slides) When everything’s important, nothing is! The truth about traditional JavaScript benchmarks Do Browsers Parse JavaScript On Every Page Load With thanks to V8 (Toon Verwaest, Camillo Bruni, Benedikt Meurer, Marja Hölttä, Seth Thompson), Nolan Lawson (MS Edge), Malte Ubl (AMP), Tim Kadlec (Synk), Gray Norton (Chrome DX), Paul Lewis, Matt Gaunt and Rob Wormald (Angular) and for their reviews of this article. Update: Thanks to some awesome members of the community, this article is now available in Chinese and Russian too.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Hiểu rõ về Regular Expressions: RegEx không khó như tưởng tượng","slug":"Hieu-ro-ve-Regular-Expressions-RegEx-khong-kho-nhu-tuong-tuong","date":"2017-12-15T15:23:22.000Z","updated":"2017-12-15T15:29:08.323Z","comments":true,"path":"2017/12/Hieu-ro-ve-Regular-Expressions-RegEx-khong-kho-nhu-tuong-tuong.html","link":"","permalink":"http://nthung2112.github.io/2017/12/Hieu-ro-ve-Regular-Expressions-RegEx-khong-kho-nhu-tuong-tuong.html","excerpt":"Are you one of those people who stays away from regular expressions because it looks like a foreign language? I was one. Not anymore. Think of all those sounds, traffic signs and smells that you can recognize. Regular expressions are no different. It’s like a sign language to analyze strings. We are going to get our head around regular expressions today. At least, regularly used expressions. Much like any programming language, a regular expression is a succinct language in its own right. We will know how to put regular expressions to good use by the end of this article. We will solve simple problems and learn loads in the process. Are you willing to invest 30 minutes and come out enlightened in RegEx? Settle down then.","text":"Are you one of those people who stays away from regular expressions because it looks like a foreign language? I was one. Not anymore. Think of all those sounds, traffic signs and smells that you can recognize. Regular expressions are no different. It’s like a sign language to analyze strings. We are going to get our head around regular expressions today. At least, regularly used expressions. Much like any programming language, a regular expression is a succinct language in its own right. We will know how to put regular expressions to good use by the end of this article. We will solve simple problems and learn loads in the process. Are you willing to invest 30 minutes and come out enlightened in RegEx? Settle down then. Why regular expressions?We each have our own ‘why’, don’t we? One may be to test if the string is a valid hex color code. You may be writing a processor library such as Sass that leverages RegEx. I’ll let the universe throw the why at you and help you cover the how. 0. Get Your Playground ReadyReferencesMost of the time, I find this page adequate to get going: Regular Expressions from MDN. In fact, that page is all you need. You can stop reading this post. Right now. Close this tab. 😉 Still with me? Thanks. You need a sandbox to play around in. Luckily, one is available on your browser. Just use the DevTools in your browser’s console. Familiarize yourself with the syntaxTo start with, we are going to use the /expression/.test(‘string’) syntax. An expression is any regular expression that we build. A string is the string under test. The test method returns true or false depending on the match. Slashes mark the start and end of the expression. Treat them like the double quotes (“) and single quotes (‘) that you use to the mark start and end of a plain string. The expression between / is a literal. They are treated as literal characters. Variable names wouldn’t be resolved down to their contents. To make it dynamic, we’ll have to go via the constructor route, using new RegEx(variable_name) syntax. This will come to rescue towards the end of the post. Do it right now. Just type this into your browser console. 12/a/.test(\"a\"); //true/a/.test(\"b\"); //false If that works, you are ready. Don’t worry about what it is. That’s what we are going to breakdown into pieces in the following lines. Let’s dive in… 1. Start Small With LettersLet’s start small. We need to find if a string has a particular character. Look for the character a in a string. Here is the expression in all its glory: 123/a/.test(\"abc\"); //true /a/.test(\"bcd\"); //false /a/.test(\"cba\"); //true The expression does what we asked for, “Look for a in the string under test”. In our case, abc and bca do have the character a. But bcd does not have it. BreakdownNow, that’s a lot of slashes and backslashes. Let’s break them down. We’ve seen that /expression/ is how we build regular expressions. So no question about slash there. In fact, we can even assign it to a variable and make it look better. The same code: 1234let e=/a/; e.test(\"abc\"); //true e.test(\"bcd\"); //false e.test(\"cba\"); //true The expression between slashes is just a single character a in our case. We are looking only for that one character. Reach Multi-CharactersLet’s scale the solution. What if you want to find more than one character? Put them in sequence. Treat them as a substring. Here is an example: 1234/ab/.test(\"abacus\"); //true /bac/.test(\"abacus\"); //true /abc/.test(\"abacus\"); //false /abas/.test(\"abacus\"); //false The string under test should contain the exact expression within slashes. We get a match if that condition is met. bac is within abacusbut abas is not in abacus as it is. Even though we have those characters scrambled, we do not get an exact match. Review Ground CoveredSymbol /…/ . Slash (/) marks the start and end of the regular expression. Ignore the dots, that’s where we place the pattern. The /a/ character between slashes is a pattern matched on string under test. The /abc/ characters between slashes are looked up as a sub-string during the pattern matching test on string under test. 2. Patterns in NumbersLet’s spice it up a bit. Let’s say you want to find out if a string is full of numeric characters. Here it is: 123let e=/0|1|2|3|4|5|6|7|8|9/;e.test(\"42\"); //true e.test(\"The answer is 42\"); //true First of all, the pattern looks pretty long. But the same long streak of characters can be expressed in just two characters. I reserved it towards end of this section for a dramatic closure. The second case shouldn’t be true. We’ll deal with it a bit later. For now, the pipe symbol (|) means or. Outside of regular expressions, we’ve used it as a bitwise or and conditional or with double pipes (||). That’s the same guy. I could call that easy and call it a day. But you would scream for something better, right? We are developers. We spend the best part of our day thinking about better Bash and Git aliases to save few keystrokes. Should I type in nine pipe symbols? Nah. Here we go again: 123e=/[0123456789]/; e.test(\"42\"); //true e.test(\"The answer is 42\"); //still true This is better. 9 pipes were replaced with 2 square brackets. 7 characters were saved. That’s 77.7% less keystrokes. By the way, anything within square brackets is considered as Either this or that. It is a character set. In our case, the string should contain either 0, or 1, or 2, or…bear with me, I promised myself to write 1000 words a day, or 3 or 4 or 5. All right, let’s stop. You get it. What are you saying? It still looks quite lengthy? Not satisfied? Okay, here we go once again: 1234e=/[0-9]/; e.test(42); //true e.test(\"42\"); //true e.test(\"The answer is 42\"); //true! How about that? Looks much cleaner, doesn’t it? Anything within square brackets [] means or. 0-9 marks a range, meaning zero to nine. So the test looks for characters from zero to nine in the test string. As you can see, the test takes numbers too. The prefix and suffix patternsLet’s now address that failing second case. The answer is 42 matches our test because our pattern looks for numeric characters somewhere within the string. Not start to end. Let’s bring in ^ and $ to help us. ^ means the start of the string. He is a double agent and he’ll trip us off. His second avatar is unmasked only in the last section. $ means the end of the string. Let’s get the prefix pattern sorted out: 123/^a/.test(\"abc\"); //true /^a/.test(\"bca\"); //false /^http/.test(\"https://pineboat.in\"); //true /^http/.test(\"ftp://pineboat.in\"); //false Any pattern that follows ^ should be at the start of the string under test. The second string starts with b while our pattern looks for a. The fourth one looks for http while the string starts with ftp. This is the reason they fail. The suffix patternsThe suffix pattern follows. $ at the end of the pattern directs the test to look for end of string. 12/js$/.test(\"regex.js\"); //true /js$/.test(\"regex.sj\"); //false That should sound in your head like, “Look for js and then the end of the string”. Better yet, “Look for a string that ends in js”. Pattern match End to EndThat paves the road to pattern match start to end, you might as well call it end to end. 1234let e=/^[0-9]$/ e.test(\"42\"); //false - NO! e.test(\"The answer is 42\"); //false e.test(\"7\"); //true Surprisingly, the first one failed when we added ^ and $. /^[0-9]$/ reads like, “Go to the start of the string. Look for a single numeral from the character set. Check if the string ends right there.” That’s the reason the last entry returned true. It is just a single number, start to end. That’s not what we wanted. We wanted to test if the string had one or more numerals. We are very close. One last thing we need to learn is how to instruct the pattern to look for more than one character in the set. Tale of Three MusketeersA question mark (?), a plus (+) and an asterisk (*) met at a battle ground. Each is differently sighted. The humble question mark (?)says, “I can see none or just one.” Plus (+) says, “I need to see at least one or more.” Asterisk (*) says, “I get you both. I can see none, one, or more.” One of them is cleverly hiding what he is capable of. The question mark gets on stage first: 12345/a?/.test(\"\"); //true /a?/.test(\"a\"); //true /a?/.test(\"b\"); //true! /a?/.test(\"aa\"); //true /^a?$/.test(\"aa\"); //false Matches empty string “”as ? stands for 0 or 1 Matches aone match Matches b matches 0 occurrence Matches aaone match and the second a is not part of the pattern /^a?$/ does not match aa It looks for zero or one a, start to end, nothing more, nothing less The plus (+) looks at question mark and remarks, “I’m impressed, but your focus is so binary!”. And takes the stage to show off: 1234567/a+/.test(\"a\"); //true /a+/.test(\"aa\"); //true /a+/.test(\"ba\"); //true! /^a+$/.test(\"aa\"); //true /a+/.test(\"\"); //false /a+/.test(\"b\"); //false /^a+$/.test(\"ab\"); //false Remember what plus (+) said? It can match one or more occurrences of preceding pattern. All those returning true have one or more a. We even managed to get a whole string comprised only of a in the last one that returned true with /^a+$/. false should make sense now, but a word on the last one that returned false. /^a+$/ looks for a start to end, no other characters allowed. This is why ab failed the test. Finally, star (*) of the show gets on stage. He boasts that, “I can duel alone or duel you both at once” and says, “I can match zero, one or more”. 12345678/a*/.test(\"a\"); //true /a*/.test(\"aa\"); //true /a*/.test(\"ba\"); //true /a*/.test(\"\"); //true /a*/.test(\"b\"); //true /^a*$/.test(\"aa\"); //true /^a*$/.test(\"\"); //true /^a*$/.test(\"ab\"); //false Except the last one, was able to handle all else. /^a$/ reads like, 0 or more a start to end. Which is why empty string “” passed the test and “ab” failed. Back to the Universal AnswerRemember where were we before we met the three musketeers? Yes, “The answer is 42”. Now if we need to look for only numerals, one or more, start to end, what do we do? 12345//Let's throw in a plus let e=/^[0-9]+$/ e.test(\"4\"); //true e.test(\"42\"); //true e.test(\"The answer 42\"); //false - Hurray The plus sign (+) in [0-9]+ comes to our rescue. Plus means more than one occurrence of the character or pattern in front of it. In our case, more than one numerals. It also fails the match for our last case The answer is 42 because, there are no numerals at the start of the string. Practice Patterns Can you try to write a pattern for hexadecimal numbers (consisting of numerals 0–9 and letters a-f, with an optional # in front)? How about a binary number? Can you test if a string is full of just 0 and 1? That Dramatic EndOh, I almost forgot. [0-9] stands for any of the numeric character set and also has a shorthand version \\d. 1let e=/^\\d+$/; e.test(\"4\"); //true e.test(\"42\"); //true e.test(\"The answer 42\"); //false - Hurray Just two characters denoting numerals. And No, it doesn’t get any shorter than that. There are a whole bunch of such special patterns to specify clusters such as numbers (\\d), alpha numeric characters (\\w), white spaces (\\s). Review [123] The expression within square brackets are a character setAny one of the characters match will pass the test. Just ONE character. [0-9]Looks for a single numeric digit between 0 to 9 [0-5]Looks for a single numeric digit between 0 to 5 [a-z]Looks for a single letter between a to z [A-F]Looks for a single letter between A to F [123]+Plus (+) looks for one or more occurrence of the characters within the set This one matches a “23132” sub-string that consists of 1, 2 and 3 within a larger string “abc23132”. | Pipe symbol stands for or \\dA shorthand for numeralsMatches a single numeric digit. \\DA shorthand for non-numeric charactersAnything other than numerals that’ll be matched by \\d 3. Recurrence Match to Find DuplicatesThis is the actual problem I was trying to solve. I dove deep into regular expressions, which eventually led to this post. You’ve been given a string. Find out if it has been infused with duplicate characters before sunset. Here is the solution for duplicate characters appearing immediately after an occurrence: 123let e=/(\\w)\\1/; e.test(\"abc\"); //false e.test(\"abb\"); //true The expression does not match any part of the string abc as there are no duplicate characters in sequence. So it returns false. But it matches bb part of the string abb and returns true. Go ahead, type that on your DevTool console. Look at this! Let’s break it down to understandable pieces. Backslash \\ UnleashedI’ve been a little quiet about the backslash that was introduced in the last section. To those who have been there and done that, it may not have been a surprise. They might have escaped the confusion. But if you are new to programming world, you need to know more about backslash. In the regular expression language, backslash is special. The backslash alters the meaning of the characters that follow them. Ring a bell? What do you call \\n when you encounter it in a string? Yes, a new line. We’ve got something similar here. In fact, \\n is what you use as a pattern if you want to look for a new line. That’s called escaping the usual meaning of n and giving it a whole new attire called new line. \\d A shorthand for numeralsMatches a single numeric digit \\D A shorthand for non-numeric charactersAnything other than numerals that’ll be matched by \\d \\sShorthand for single white space character such as space, new line or tab. \\S Antonym of \\sanything other than white space \\wShorthand for alpha-numeric characterMatches a-z, A-Z, 0–9 and underscore _. \\WAntonym of \\w Recallable MatchesWe started this section with the solution for finding duplicate characters. /(\\w)\\1/ matched “abb”. That shows use of memory and recall within regular expressions. Consider the use of brackets in this format (expression). The resulting string that matches the expression within a bracket is remembered for later use. \\1 remembers and uses the match from first expression that is within brackets. Likewise, \\2 from second set of brackets. And so on. Let’s translate our expression (\\w)\\1 to plain English: Match any alpha-numeric character on a given string. Remember it as \\1. Check if that character appears right next to the first occurrence. Extension 1 — Reverse PairsLet’s say we want to find two characters appearing in reverse order right next to each other. That is like abba. ab is reversed as ba and is right next to each other. Here is the expression: 1234let e=/(\\w)(\\w)\\2\\1/; e.test(\"aabb\"); //false e.test(\"abba\"); //true e.test(\"abab\"); //false The first (\\w) matches a and remembers it as \\1. The second (\\w) matches b and remembers it as \\2. Then the expression expects \\2 to occur first followed by \\1. Hence, abba is the only string that matches the expression. Extension 2 — No duplicatesThis time, we are going to look at sequence of characters with no duplicates. No character should be followed by the same character. Plain and simple. Here, take a look at the solution: 1234let e=/^(\\w)(?!\\1)$/; e.test(\"a\"); //true e.test(\"ab\"); //false e.test(\"aa\"); //false Not the one we wanted, but close. The middle one shouldn’t be false. But we threw in a few more symbols that need explaining. That means confronting the most powerful musketeer once again. Return of the Question MarkRemember the three musketeers we met earlier. The humble question mark is actually the most powerful manipulator that can get other symbols to do his bidding. That is, if you take the backslash for granted. A combination of brackets, question mark and exclamation mark (?!), is called a look ahead. A negative look ahead to be precise. a(?!b) matches a only if it is not followed by b. Across JavaScript ecosystem, the exclamation mark means not. But its cousin CSS takes a u-turn and !important means it is actually very important and should not be overridden. I almost scrolled past Chen’s tweet thinking it is marked not important. I digress. On the other hand, (?=) is a positive look ahead. a(?=b) matches a only if it is followed by b. We had a solution. (\\w)(?!\\1) looks for a character without recurrence. But only for one character. We need to group it and look for 1 or more occurrences of characters with the use of plus (+). That’s all. 123let e=/^((\\w)(?!\\1))+$/; e.test(\"madam\"); //false e.test(\"maam\"); //false But it doesn’t seem to be working. If we group the pattern within plain brackets like ((\\w)(?!\\1)), the \\1 does not represent(\\w), it represents higher level bracket pair that groups the pattern. So it fails. What we need is a forgetful grouping option. That’s where the question mark, ?, strikes back. It pairs with a colon, (?:) and wipes out any function of memory that the brackets can bring in. One last time: 123let e=/^(?:(\\w)(?!\\1))+$/; e.test(\"madam\"); //true e.test(\"maam\"); //false This time, the first level of brackets are not remembered, thanks to ?:, hence, \\1 remembers the match returned by \\w. It helps us use the plus + against the overall grouping to find similar pairs of characters start to end, which works like magic. In English, “Look for a character. Look ahead to ensure it is not followed by the same character. Do this from start to end for all characters.” Review \\w represents all the alpha-numeric charactersIf you capitalize ‘w’ and use \\W’, that would mean all characters other than alpha-numeric ( )The expression within a bracket is remembered for later use \\1 remembers and uses the match from first expression that is within brackets \\2 from second set of brackets. And so on. a(?!b)A combination of brackets, question mark and exclamation mark (?!), is called a look ahead This matches a only if it is not followed by b a(?=b) The other side of the coinMatch a only if it is followed by b. (?:a)Forgetful grouping Look for a but don’t remember itYou can’t use \\1 pattern to reuse this match 4. Alternating SequenceThe usecase is simple. Match a string that uses only two characters. Those two characters should alternate throughout the length of the string. Two sample tests for “abab” and “xyxyx” will do. It wasn’t easy. I got it wrong on several attempts. This answer directed me down the right street. Here is the solution: 123456let e=/^(\\S)(?!\\1)(\\S)(\\1\\2)*$/; e.test(\"abab\"); //true e.test(\"$#$#\"); //true e.test(\"#$%\"); //false e.test(\"$ $ \"); //false e.test(\"xyxyx\"); //false This is where you say, “I’ve had enough!” and throw in the towel. But wait for the Aha moment! You are 3 feet away from the gold ore, not the right time to stop digging. Let’s first make sense out of results before we arrive at ‘how?’ abab matches. $#$# matches, this is no different from abab. #$% fails as there is a third character. $ $ fails though they are pairs, because space is excluded in our pattern. All is well except, xyxyx fails, because our pattern doesn’t know how to handle that last x. We’ll get there. Let’s take a look at the tools added to our belt. It’ll start to make sense soon. One piece at a timeYou already know most of the pieces. \\S is the opposite of \\s. \\S looks for non white space characters. Now comes the plain English version of /^(\\S)(?!\\1)(\\S)(\\1\\2)*$/. Start from the start /^ Look for a non-white space character (\\S) Remember it as \\1 Look ahead and see if the first character is not followed by the same character (?!\\1).Remember this is a negative look ahead. If we are good so far, look for another character (\\S) Remember it as \\2 Then look for 0 or more pairs of first two matches (\\1\\2)* Look for such pattern until end of the string $/ Apply that to our test cases. “abab” and “$#$#” match. Tail EndAfter looking at the solution you may think this does not demand a separate section. But the simplicity of it is elegant. Let’s fix that one failing case xyxyx. As we’ve seen, the last trailing x is the problem. We have a solution for xyxy. All we need is a pattern to say “Look for an optional occurrence of first character”. As usual, let’s start with the solution. 1let e=/^(\\S)(?!\\1)(\\S)(\\1\\2)*\\1?$/; e.test(\"xyxyx\"); //true e.test(\"$#$#$\"); //true The question mark strikes again. There is no escaping him. It’s better we make him our ally than our enemy. A question mark ? after a character or pattern means 0 or 1 match for the preceding pattern. It is non-greedy in gobbling up characters. In our case, \\1? means, 0 or 1 match of the first character remembered through first set of brackets. Easy. Relax. Review \\SRepresents all characters excluding white space such as a space and new linesNote that it is capital S a*The asterisk or star, looks for 0 or more occurrences of the preceding character. In this case, it is 0 or more aRemember plus (+) which looks for 1 or more? Yeah, these guys are cousins. a(?!b)This combination of brackets, question mark and exclamation mark (?!) is called a look ahead.This matches a only if it is not followed by b.For example, it matches a in aa, ax, a$ but does not match ab Though it uses bracket, it does not remember the matching character after a. \\sSmall caps s matches a single white space character such as a space or new line. a(?=b)This matches a that is followed by b. ^ab*$You may think this translates to 0 or more occurrences of ab, but it matches a followed by 0 or more b For example: This matches abbb, aand ab, but does not match abab ^(ab)*$This matches 0 or more pairs of ab That means it will match empty string “”, aband abab, but not abb a?? matches 0 or 1 occurrence of preceding character or pattern\\1? matches 0 or 1 recurrence of first remembered match 5. Match an email addressWarning for ProductionRegular expressions alone may not help validate emails. Some would even argue that regular expressions should not be used as it can never match 100% of the emails. Think about all the fancy domain names popping up. Also consider inclusion of symbols within email addresses, such as dot (.) and plus (+). You need to validate email twice. Once on the client side to help users avoid misspelled addresses. Start with a semantic input tag type &lt;input type=&#39;email&#39;&gt;. Some of the browsers automatically validate it without any extra scripting on the front end. Validate it once again on the server by actually sending a confirmation email. Haven’t you seen one such lately? Just try to subscribe to this pineboat. You’ll get an actual email asking you to confirm that it is yours. That confirmation is a solid proof that your email is valid. That was smooth sailing, wasn’t it? RegEx for EmailNow that we added the disclaimer, you’d actually want to see a pattern right? No, search for regular expression for an email address. One such result from perl module goes for more than a page. So, I am not even going to attempt it. Such long regular expressions are generated by computers through pattern builders. Not for mere mortals like us. 6. Match a Strong PasswordIf you are a coffee person, this is the right time to get a strong one. Because we are at last section of this post, but the longest one so far. It introduces very few new operators and patterns. But it reuses many patterns. As usual, we reserve the shortest optimized one for last. The ASCII range is the best part of this post. Because, I learned it while researching for this post. Now, the problem. Remember that registration form that took several attempts before you could meet their strong password requirements? Weak, good, strong, and very strong? Yeah, we are going to build that validation. The password should: have a minimum of 4 characters contain lowercase contain uppercase contain a number contain a symbol This is a tricky one. Once you start consuming letters, you can’t come back to check if they meet any other condition.There in lies our clue. We can’t look back, but we can look ahead! Length of the stringLet’s first test if the string password is 4 characters long. Pretty simple. Use .length on the password string. Done, right? No, who needs a simple solution? Let’s spice it up. 123456789//expression with just lookahead//wouldn't consume any charactere1=/^(?=.&#123;4,&#125;)$/; e1.test(\"abc\") //falsee1.test(\"abcd\") //false //after lookahead, //pattern to consume character is needed.e2=/^(?=.&#123;4,&#125;).*$/; e2.test(\"abc\") //false e2.test(\"abcd\") //true You may remember (?=) from our previous work on “no duplicates” That’s a look ahead useIt does not consume any character The dot (.) is an interesting characterIt means, any character. {4,}Stands for at least 4 preceding characters with no maximum limit \\d{4}Would look for exactly 4 numerals \\w{4,20}Would look for 4 to 20 alpha-numeric characters Let’s translate /^(?=.{4,})$/. “Start from the beginning of the string. Look ahead for at least 4 characters. Don’t remember the match. Come back to the beginning and check if the string ends there.” Doesn’t sound right. Does it? At least the last bit. Which is why we brought in the variation /^(?=.{4,}).$/. An extra dot and a star. It reads like this, “Start from the beginning. Look ahead for 4 characters. Don’t remember the match. Come back to the beginning. Consume all the characters using . and see if you reach the end of the string.” This makes sense now. Doesn’t it? Which is why abc fails and abcd passes the pattern. At least One NumberThis is going to be easy. 123456e=/^(?=.*\\d+).*$/ e.test(\"\"); //false e.test(\"a\"); //false e.test(\"8\"); //true e.test(\"a8b\"); //true e.test(\"ab890\"); //true Start from the beginning of the string /^. Look ahead for 0 or more characters ?=.. Check if 1 or more numbers follow \\d+. Once it matches, come back to the beginning (because we were in look ahead). Consume all the characters in the string until end of the string .$/. At Least One Lowercase LetterThis one follows the same patter as above. 1234e=/^(?=.*[a-z]+).*$/; e.test(\"\"); //false e.test(\"A\"); //false e.test(\"a\"); //true Translation? Sure. “Start from the… okay.” Instead of \\d+, we have [a-z]+ which is a character set of letters from a to z. At least One Uppercase LetterLet’s not overkill. [A-Z] instead of [a-z] from the previous section will do. At least One SymbolThis is going to be challenging. One way to match symbols is to place a list of symbols in a character set. /^(?=.[-+=_)(\\&amp;\\^%\\$#@!~”’:;|}]{[/?.&gt;,&lt;]+).*$/.test(“$”) That’s all the symbols in a character set. Properly escaped where necessary. It’ll take months for me to write it in plain English. So to save all of us from eternal pain, here is a simple one: 1234567891011121314//considers space as symbol let e1; e1=/^(?=.*[^a-zA-Z0-9])[ -~]+$/ e1.test(\"_\"); //true e1.test(\" \"); //true //does not take space let e2; e2=/^(?=.*[^a-zA-Z0-9])[!-~]+$/ e2.test(\" \"); //false e2.test(\"_\"); //true //the underscore exception let e3; e3=/^(?=.*[\\W])[!-~]+$/ e3.test(\"_\"); //false Wait, what’s that ^ coming again from the middle of no where? If you have reached this far, this is where you realize that unassuming innocent ^ that marks start of a string is a double agent. Which means, the end is not too far. He has been exposed. Within a character set, ^ negates the character set. That is, [^a-z] means, any character other than a to z. [^a-zA-Z0-9] then stands for any character other than lower case alphabets, upper case alphabets, and numerals. We could have used \\W instead of the long character set. But \\W stands for all alpha-numeric characters including underscore _. As you can see in the third set of examples above, that will not accept underscore as a valid symbol. CharSet RangeThe curious case of [!-~]. They stand next to each other in the keyboard, but their ASCII values are diagonally opposite. Remember a-z? A-Z? 0–9? These are not constants. They are actually based on the ASCII range of their values. The ASCII table has 125 characters. zero (0) to 31 are not relevant to us. Space starts from 32 going all the way up to 126 which is tilda(~). The exclamation mark is 33. So [!-~] covers all the symbols, letters and numbers we need. The seed for this idea came from another solution to the symbol problem. Assemble the TroopsBringing it all together, we get this nice looking piece of regular expression /^(?=.{5,})(?=.[a-z]+)(?=.\\d+)(?=.[A-Z]+)(?=.[^\\w])[ -~]+$/. That’s starting to haunt and intimidate us. Though we’ve been studying them individually. This is where the syntax for dynamically building expression object comes in handy. We are going to build each piece separately and assemble them later. 123456789101112131415161718192021222324252627282930313233//start with prefix let p = \"^\"; //look ahead // min 4 chars p += \"(?=.&#123;4,&#125;)\"; // lower case p += \"(?=.*[a-z]+)\"; // upper case p += \"(?=.*[A-Z]+)\"; // numbers p += \"(?=.*\\\\d+)\"; // symbols p += \"(?=.*[^ a-zA-Z0-9]+)\"; //end of lookaheads //final consumption p += \"[ -~]+\"; //suffix p += \"$\"; //Construct RegEx let e = new RegEx(p); // tests e.test(\"aB0#\"); //true e.test(\"\"); //false e.test(\"aB0\"); //false e.test(\"ab0#\"); //false e.test(\"AB0#\"); //false e.test(\"aB00\"); //false e.test(\"aB!!\"); //false // space is in our control e.test(\"aB 0\"); //false e.test(\"aB 0!\"); //true If your eyes are not tired yet, you’d have noticed two strange syntax in the above code. One, we didn’t use /^, instead we used just ^. We didn’t use $/ to end the expression either, instead just $.The reason is that the RegEx constructor automatically adds starting and trailing slashes for us. Two, to match numbers we used \\d instead of the usual \\d. This is because the variable p is just a normal string within double quotes. To insert a backslash, you need to escape the backslash itself.\\d resolves to \\d within the RegEx constructor Apparently, there should be server side validations for passwords too. Think about SQL injection vulnerabilities if your framework or language doesn’t handle it already. 7. ConclusionThat brings us to the end of the story. But this is the beginning of a journey. We just scratched the pattern matching portion of RegEx with test method. exec method builds on this foundation to return matched sub-strings based on pattern. String object has methods such as match, search, replace, and split that widely uses regular expressions. Hope this sets you off to explore those capabilities further with a solid understanding on composing patterns for RegEx. 8. Call To ActionNo, after all this difficulty we’ve been through, I am not going to ask you to subscribe. Just make good software. If any code blocks presented here do not work, leave a comment on this github issue I created specially for this post. Hope it was useful! Share it if others would benefit. You’ve been wonderful. Appreciate your time. This content is far long by recent standards. Thanks for reading. Originally published at www.pineboat.in.","categories":[],"tags":[{"name":"Regex","slug":"Regex","permalink":"http://nthung2112.github.io/tags/Regex/"}]},{"title":"React, Inline Functions, and Performance","slug":"React-Inline-Functions-and-Performance","date":"2017-12-08T07:43:28.000Z","updated":"2017-12-12T15:03:58.752Z","comments":true,"path":"2017/12/React-Inline-Functions-and-Performance.html","link":"","permalink":"http://nthung2112.github.io/2017/12/React-Inline-Functions-and-Performance.html","excerpt":"My wife and I just got through a huge remodel. We were beyond excited to show people the new digs. We showed my mother-in-law. She walked in the beautifully remodeled bedroom, looked up at the fantastically framed window and said: “No blinds?” 😐 Our new bedroom; holy crap it looks like a magazine picture. Also, no blinds. I find myself with the same emotion when I’m talking about React. I’ll be getting through the first lecture of a workshop, showing off some cool new OSS, and invariably somebody says: “inline functions? I heard those are slow.”","text":"My wife and I just got through a huge remodel. We were beyond excited to show people the new digs. We showed my mother-in-law. She walked in the beautifully remodeled bedroom, looked up at the fantastically framed window and said: “No blinds?” 😐 Our new bedroom; holy crap it looks like a magazine picture. Also, no blinds. I find myself with the same emotion when I’m talking about React. I’ll be getting through the first lecture of a workshop, showing off some cool new OSS, and invariably somebody says: “inline functions? I heard those are slow.”It wasn’t always this way. But the last few months it comes up literally every day. As an instructor and library author, it gets exhausting. Unfortunately, I’m a dummy and I rant on twitter instead of writing something that might be insightful to others. So, this is my attempt at the better option 😂. What is an “inline function”In the context of React, an inline function is a function that is defined while React is “rendering”. There are two meanings of “render” in React that people often get confused about: (1) getting the React elements from your components (calling your component’s render method) during an update and (2) actually rendering updates to the DOM. When I refer to “rendering” in this article, I’m talking about #1. Here are a few examples of inline functions: Premature optimization is the root of all evilBefore we go any further, we need to talk about how to optimize a program. Ask any performance expert and they will tell you not to prematurely optimize your program. All of them. Yes, every single one of them. 100% of people with deep performance experience will tell you not to prematurely optimize your code. If you aren’t measuring, you can’t even know if your optimizations are better, and you certainly won’t know if they make things worse! I remember a talk my friend Ralph Holzmann gave about how gzip works that really solidified this idea for me. He talks about an experiment he did with LABjs, an old script loading library. You can watch from 30:02 to about 32:35 in this video to hear about it, or just keep reading. At the time, the source for LABjs did something a little awkward for performance. Instead of using normal object notation (obj.foo) it stored the keys in strings and used bracket notation to access the objects (obj[stringForFoo]). The idea was that after minifying and gzipping, the unnaturally written code would be smaller than the naturally written code. You can see it here. Ralph forked the code and removed the optimizations by writing the code naturally, without thinking about how to optimize for minification and gzip. Turns out, removing the “optimizations” shaved off 5.3% of the file size! If you aren’t measuring, you can’t even know if your optimizations are better, and you certainly won’t know if they make things worse! Not only can premature optimization explode development time while hurting code cleanliness, it can even backfire and cause performance problems as it did for LABjs. Had the author been measuring, rather than just imagining performance issues, he would have saved development time, had cleaner code, and better performance. Don’t prematurely optimize. Alright, back to React. Why do people say inline functions are slow?Two reasons: Memory/garbage collection concerns, and shouldComponentUpdate. Memory and garbage collectionFirst, folks (and eslint configs) are concerned about memory and garbage collection costs around creating inline functions. This mostly spilled over from the days before arrow functions became ubiquitous. Lots of code would call bind inline, which has historically had poor performance. For example: Performance issues with Function.prototype.bind got fixed here and arrow functions are either a native thing or are transpiled by babel to plain functions; in both cases we can assume it’s not slow. Remember, you don’t sit back and imagine “I bet that code is slow”. You write your code naturally, then you measure it. If there are performance problems, fix them. We don’t need to prove an inline arrow function is fast, somebody else needs to prove it’s slow. Otherwise it’s a premature optimization. As far as I’ve seen, nobody has presented an analysis of their app that indicates inline arrow functions are slow. Until then, it’s not even worth talking about — but I’ll offer one more thought anyway 😝 If the cost of creating an inline function is high enough to warrant an eslint rule against it, why would we want to move that expense to the hot path of initialization? By prematurely optimizing we’ve slowed down the initialization of the component by 3x! If all the handlers were inline, the initial render would only have to create one function. Instead, we’ve created three. We haven’t measured anything though, so we have no reason to believe any of this is a problem. If you want to completely miss the point, go make an eslint rule that requires inline functions everywhere to speed up the initial render 🤦🏾‍♀️. PureComponent and shouldComponentUpdateThis is where the real meat of the problem lives. You can see real performance improvements by understanding two things: shouldComponentUpdate and JavaScript strict equality comparisons. If you don’t understand them well, you can inadvertently make your React code harder to work with in the name of performance. When you call setState, React will compare the old React elements to a new set of React elements (this is called r_econciliation_, you can read about it here) and then use that information to update the real DOM elements. Sometimes that can get slow if you’ve got a lot of elements to check (like a big SVG). In these cases, React provides an escape hatch called shouldComponentUpdate. If your component has shouldComponentUpdate defined, before React compares the old and new elements, it will ask shouldComponentUpdate if anything changed. If it returns false, then React will completely skip the element diff, saving some time. If your component is large enough, this can have considerable impact on performance. The most common way to optimize a component is to extend React.PureComponent instead of React.Component. A PureComponent will diff your props and state in shouldComponentUpdate so you don’t have to. 1class Avatar extends React.PureComponent &#123; ... &#125; Avatar will now use a “strict equality comparison” on its props and state when being asked to update, hopefully speeding things up. Strict Equality ComparisonThere are six primitive types in JavaScript: string, number, boolean, null, undefined, and symbol. When you do a “strict equality comparison” on two primitives that hold the same value, you’ll get true. For example: 123const one = 1const uno = 1one === uno // true When PureComponent diffs props it uses a strict equality comparison. This works out great for inlined primitive values: . The prop diffing problem arises because of non-primitive types — err, excuse me, type. There is only one other type and that’s Object. What about functions and arrays you say? Well, actually those are just objects. Functions are regular objects with the additional capability of being callable. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures LOL, okay JavaScript. So anyway, strict equality checks on objects, even with seemingly similar values, will evaluate to false: So, if you inline an object in your JSX, it will fail the PureComponent prop diff and move on to diffing the more expensive React elements. The element diff will come up empty and now we’ve wasted time on both diffs. Since functions are objects and PureComponent does a strict equality check on props, an inline function will always fail the prop diff and move on to the element diff in the reconciler. You can see this isn’t just about inline functions. The function is simply the lead singer of the object, function, array three-piece performance postulation proliferation. In order to make shouldComponentUpdate happy, you have to keep referential identity of the function. For experienced JavaScript developers, it’s not too bad. But, Michael and I have led workshops with over 3,500 people at varying levels of experience and it ain’t easy for a lot of folks. ES classes don’t offer any help either, leading us down all sorts of JavaScript paths: Learning how to keep referential identity of a function leads to surprisingly long conversations. There’s usually no reason why we’re forcing people to do this other than an eslint config yelled at them. I’d like to show that you can have inline functions and performance optimizations both at the same time. But first, I have a personal performance story. My own experience with PureComponentWhen I first learned about PureRenderMixin (the thing from earlier versions of React that later became PureComponent) I put in a bunch of measurements and measured my app’s performance. I then added PureRenderMixin to every single component. When I took the optimized set of measurements I was hoping to have a cool story to tell about how much faster everything got. Much to my surprise, my app got slower 🤔. Why? Well, think about it. If you have a Component how many diffs are there? If you have a PureComponent how many diffs are there? The answers are “just one” and “at least one and sometimes two”, respectively. If a component usually changes when there’s an update, then a PureComponent will be doing two diffs instead of just one (props and state in shouldComponentUpdate, and then the normal element diff). Which means it’s going to be slower usually but faster occasionally. Apparently, most of my components changed most of the time, so on the whole, my app got slower. Oops. There are no silver bullets when it comes to performance. You have to measure. The three scenariosAt the start of the article I showed three types of inline functions. Now that we have some background, let’s talk about each one them. But please remember to keep PureComponent on the shelf until you have a measurement to justify it. DOM component event handler123&lt;button onClick=&#123;() =&gt; this.setState(…)&#125;&gt;click&lt;/button&gt; It’s common to do nothing more than setState inside of event handlers for buttons, inputs, and other DOM components. This often makes an inline function the cleanest approach. Instead of bouncing around the file to find the event handlers, they’re colocated. The React community generally welcomes colocation. The button component (and every other DOM component) can’t even be a PureComponent, so there are no shouldComponentUpdate referential identity concerns here. So, the only reason to think this is slow is if you think simply defining a function is a big enough expense to worry about. We’ve discussed that there is no evidence anywhere that it is. It’s simply armchair performance postulation. These are fine until proven otherwise. A “custom event” or “action”123&lt;Sidebar onToggle=&#123;(isOpen) =&gt; &#123; this.setState(&#123; sidebarIsOpen: isOpen &#125;)&#125;&#125;/&gt; If Sidebar is a PureComponent we will be breaking the prop diff. Again, since the handler is simple, the colocation can be preferable. With an event like onToggle, why is Sidebar even diffing it? There are only two reasons to include a prop in the shouldComponentUpdate diff: You use the prop to render. You use the prop to perform a side-effect in componentWillReceiveProps, componentDidUpdate, or componentWillUpdate. Most on props do not meet either of these requirements. Therefore, most PureComponent usages are over-diffing, forcing developers to maintain referential identity of the handler needlessly. We should only diff the props that matter. That way people can colocate handlers and still get the performance gains you’re seeking (and since we’re concerned about performance, we’re diffing less!). For most components, I’d recommend creating a PureComponentMinusHandlers class and inherit from that instead of inheriting from PureComponent. It could just skip all checks on functions. Have your cake and eat it too. Well, almost. If you receive a function and pass that function directly into another component, it’ll get stale. Check this out: Here’s a codesandbox running that app. So, if you like the idea of inheriting from a PureRenderWithoutHandlers, make sure you don’t ever pass your ignored handlers directly to other components — you need to wrap them one way or another. Now we either have to maintain referential identity, or we have to avoid referential identity! Welcome to performance optimization. At least with this approach it’s the optimized component that has to deal with it, not the code using it. I’m going to be candid, that example app is an edit I made after publishing that Andrew Clark brought to my attention. And here you thought I was smart enough to know when to manage referential identity and when not to! 😂 A render prop Render props are a pattern used to create a component that exists to compose and manage shared state. (You can read more about them here.) The contents of the render prop are unknowable to the component. For example: That means an inline render prop function won’t cause problems with shouldComponentUpdate: It can’t ever know enough to be a PureComponent. So, the only other objection is back to believing that simply defining functions is slow. Repeating from the first example: there’s no evidence to support that. It’s simply armchair performance postulation. In summary Write your code naturally, code to the design. Measure your interactions to find slow paths. Here’s how. Use PureComponent and shouldComponentUpdate only when you need to, skipping prop functions (unless they are used in lifecycle hooks for side-effects).","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Cải thiện tốc độ Web App với Pinterest ","slug":"Cai-thien-toc-do-Web-App-voi-Pinterest","date":"2017-12-08T06:57:03.000Z","updated":"2017-12-12T15:03:58.744Z","comments":true,"path":"2017/12/Cai-thien-toc-do-Web-App-voi-Pinterest.html","link":"","permalink":"http://nthung2112.github.io/2017/12/Cai-thien-toc-do-Web-App-voi-Pinterest.html","excerpt":"Pinterest’s new mobile web experience is a Progressive Web App. In this post we’ll cover some of their work to load fast on mobile hardware by keeping JavaScript bundles lean and adopting Service Workers for network resilience. Login to https://pinterest.com on your phone to experience their new mobile site","text":"Pinterest’s new mobile web experience is a Progressive Web App. In this post we’ll cover some of their work to load fast on mobile hardware by keeping JavaScript bundles lean and adopting Service Workers for network resilience. Login to https://pinterest.com on your phone to experience their new mobile site Why a Progressive Web App (PWA)? Some history.The Pinterest PWA started because they were focused on international growth, which led them to the mobile web. After analyzing usage for unauthenticated mobile web users, they realized that their old, slow web experience only managed to convert 1% of users into sign-ups, logins or native app installs. The opportunity to improve this conversation rate was huge, leading them to an investment in the PWA. Building and shipping a PWA in a quarter Over 3 months, Pinterest rebuilt their mobile web experience using React, Redux and webpack. Their mobile web rewrite led to several positive improvements in core business metrics. Time spent is up by 40% compared to the old mobile web experience, user-generated ad revenue is up 44% and core engagements are up 60%: Their mobile web rewrite also led to several improvements in performance. Loading fast on average mobile hardware over 3GPinterest’s old mobile web experience was a monolith — it included large bundles of CPU-heavy JavaScript that pushed out how quickly Pin pages could load and get interactive. Users often had to wait 23 seconds before any UI was usable at all: Pinterest’s old mobile web site took 23 seconds to get interactive. They would send down over 2.5MB of JavaScript (~1.5MB for the main bundle, 1MB lazily loaded in) taking multiple seconds to get parsed and compiled before the main thread finally settled down enough to be interactive. Their new mobile web experience is a drastic improvement. Not only did they break-up &amp; shave hundreds of KB off their JavaScript, taking down the size of their core bundle from 650KB to 150KB but they also improved on key performance metrics. First Meaningful Paint was down from 4.2s to 1.8s and Time To Interactive reduced from 23s to 5.6s. This is on average Android hardware over a slow 3G network connection. On repeat visits, the situation was even better. Thanks to Service Worker caching of their main JavaScript, CSS and static UI assets they were able to bring down time to interactive on repeat visits all the way down to 3.9s: Although Pinterest vend iOS &amp; Android apps, they were able to deliver the same core home feed experience these apps do on the web in a fraction of the upfront download cost — just ~150KB minified &amp; gzipped. This contrasts with the 9.6MB required to deliver this experience for Android and 56MB for iOS: It’s important to note that this isn’t comparing apples to apples, however. The PWA loads code for new routes on demand, and the cost of additional code is amortized over the lifetime of the application. Subsequent navigations still don’t cost as much data as the download of the app. Pinterest’s Progressive Web App in Firefox, Edge and Safari on mobile. Route-based JavaScript chunkingGetting a web page to load and get interactive quickly benefits from only loading the code a user needs upfront. This reduces network transmission &amp; JavaScript parse/compile times. Non-critical resources can then be lazily loaded as needed. Pinterest started breaking up their multi-megabyte JavaScript bundles by splitting them into three different categories of webpack chunks that worked quite well: a vendor chunk which contained external dependencies (react, redux, react-router, etc) ~ 73KB an entry chunk which contained a majority of the code required to render the app (i.e. common libs, the main shell of the page, our redux store) ~ 72KB async route chunks which contained code pertaining to individual routes ~13–18KB A Network waterfall for the experience highlights how a shift to progressively delivering code as needed avoids the need for monolithic bundles: For long-term caching, Pinterest also use a chunk-specific hash substitution for each filename. Pinterest uses webpack’s CommonsChunkPlugin to break out their vendor bundles into their own cacheable chunk: They also used React Router for adding code-splitting to the experience: Use babel-preset-env to only transpile what target browsers needPinterest use Babel’s babel-preset-env to only transpile ES2015+ features unsupported by the modern browsers they target. Pinterest targets the last two versions of modern browsers, and their .babelrc setup looks a little like: There are further optimizations they can do to only conditionally serve polyfills as needed (e.g the Internationalization API for Safari) but this is planned for the future. Analyzing room for improvement with Webpack Bundle Analyzer Webpack Bundle Analyzer is an excellent tool for really understanding what dependencies you’re sending down to your users in JavaScript bundles. Below, you’ll see a lot of purple, pink and blue blocks in its output for an earlier build of Pinterest. These are async chunks for routes being lazily loaded in. Webpack Bundle Analyzer allowed Pinterest to visualize that most of these chunks contained duplicate code: Webpack Bundle Analyzer helped visualize the size ratio of this problem between all their chunks. Using the information about duplicate code in chunks, Pinterest were able to make a call. They moved duplicate code in async chunks to their main chunk. It increased the size of the entry chunk by 20% but decreased the size of all lazily loaded chunks by up to 90%! Image OptimizationMost of the lazy-loading of content in the Pinterest PWA is handled by an infinite Masonry grid. It has built-in support for virtualization and only mounting children that are in the viewport. Pinterest also uses a progressive loading technique for images in their PWA. A placeholder with the dominant color is initially used for each Pin. Pin images are served as Progressive JPEGs, which improve image quality with each scan: React performance pain-pointsPinterest ran into some rendering performance issues with React as part of their use of this Masonry grid. Mounting and unmounting large trees of components (like Pins) can be slow. There’s a lot that goes into a Pin: Although at the time of writing Pinterest are using React 15.5.4, their hope is that React 16 (Fiber) will help a lot with reducing time spent unmounting. In the mean time, Virtualizing the grid helped significantly with component unmount time. Pinterest also throttle insertion of Pins so that they can measure/render the first Pins quicker, but means there’s more overall work for the device’s CPU. Navigation TransitionsTo improve perceived performance, Pinterest also update the selected state of navigation bar icons independent of the route. This enables navigations from one route to another to not feel slow due to blocking on the network. The user gets visual UI painted quickly while we’re waiting for the data to arrive: Experience using ReduxPinterest use normalizr (which normalizes nested JSON according to a schema) for all of their API data. This is viewable from the Redux DevTools: The downside to this process is that denormalization is slow so they ended up heavily relying on reselect’s selector pattern for memoizing denormalization during renders. They also always denormalize at the lowest level possible to ensure individual updates don’t cause large re-renders. As an example, their grid item lists are just Pin IDs with the Pin component denormalizing itself. If there are changes to any given Pin, the full grid does not have to re-render. The trade-off is that there are a lot of Redux subscribers in the Pinterest PWA, though this hasn’t resulted in noticeable perf issues. Caching assets with Service WorkersPinterest use the Workbox libraries for generating and managing their Service Workers: Today, Pinterest cache any JavaScript or CSS bundles using a cache-first strategy and also cache their user-interface (the application shell). In a cache-first setup, if a request matches a cache entry, respond with that. Otherwise try to fetch the resource from the network. If the network request succeeds, update the cache. To learn more about caching strategies with Service Worker, read Jake Archibald’s Offline Cookbook. They define a precache for the initial bundles loaded by the application shell (webpack’s runtime, vendor and entryChunks) too. As Pinterest is a site with a global presence, supporting multiple languages, they also generate a per-locale Service Worker configuration so they can precache locale bundles. Pinterest also use webpack’s named chunks to precache top-level async route bundles. This work was rolled out in several smaller, iterative steps. 1st: Pinterest’s Service Worker only did runtime caching of scripts lazy-loaded on demand. This was to take advantage of V8’s code caching, helping skip some of the parse/compile cost on repeat views so they can load quicker. Scripts served from Cache Storage where a Service Worker is present can eagerly opt into code caching as there’s a good chance the browser knows the user will end up using these resources on repeat views. After this, Pinterest progressed to pre-caching their vendor and entry chunks. Next, Pinterest started precaching a few of the most used routes (like the home page, pin page, search page etc). Finally, they started generating a Service Worker for each locale so that they could also cache the locale bundle. This was important for not just repeat load performance, but also enabling basic offline rendering for most of their audience: Application Shell challengesPinterest found implementing their application shell a little tricky. Because of desktop-era assumptions about how much data could be sent down over a cable connection, initial payloads were large containing a lot of non-critical info, like user’s experiment groups, user info, contextual information etc. They had to ask themselves: “do we cache this stuff in the application shell? or take the perf hit of making a blocking network request before rendering anything to fetch it at all”. They decided to cache it in the application shell, which required some management of when to invalidate the app shell (logout, user information updates from settings etc). Each request response has an appVersion — if the app version changes, they unregister the Service Worker, register the new one then on the next route change they do a full page reload. Adding this information to the application shell is a little trickier, but worth avoiding the render blocking request for. Auditing with LighthousePinterest used Lighthouse for one-off validations that their performance improvements were on the right track. It was useful for keeping an eye on metrics such as Time to Consistently Interactive. Next year they hope to use Lighthouse as a regression mechanism to verify that page loads remain fast. The FuturePinterest just deployed support for Web Push notifications and have also been working on the unauthenticated (logged-out) experience for their PWA. They are interested in exploring support for to preload critical bundles &amp; reducing the amount of unused JavaScript delivered to users on first load. Stay tuned for more awesome perf work in the future!","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"22 React projects open source","slug":"22-React-projects-open-source","date":"2017-12-08T06:37:30.000Z","updated":"2017-12-12T15:03:58.737Z","comments":true,"path":"2017/12/22-React-projects-open-source.html","link":"","permalink":"http://nthung2112.github.io/2017/12/22-React-projects-open-source.html","excerpt":"This is a collection of open source apps built with React.JS library. In this observation, we compared nearly 1,000 popular React projects to pick the top 22. (React Native: 11, React: 11) React is an open source JavaScript library built by Facebook, providing a view for data rendered as HTML. To evaluate the quality, Mybridge AI considers a variety of factors to determine how useful the projects are for programmers. To give you an idea on the quality, the average number of Github stars from the 22 projects was 3,584. Open source projects can be useful both for beginners to learn from reading the code and for advanced programmers to save time by using the existing code. The aim of this collection is to help you pick a great project right away without having to spend hours of searching.","text":"This is a collection of open source apps built with React.JS library. In this observation, we compared nearly 1,000 popular React projects to pick the top 22. (React Native: 11, React: 11) React is an open source JavaScript library built by Facebook, providing a view for data rendered as HTML. To evaluate the quality, Mybridge AI considers a variety of factors to determine how useful the projects are for programmers. To give you an idea on the quality, the average number of Github stars from the 22 projects was 3,584. Open source projects can be useful both for beginners to learn from reading the code and for advanced programmers to save time by using the existing code. The aim of this collection is to help you pick a great project right away without having to spend hours of searching. Note that React UI components, boilerplates, tools and frameworks are separated out to make this curation more specific to full-working apps built with React. No 1) Redux The Complete React Web Course (2nd Edition): Build apps using Redux, Webpack, React-Router [10,556 recommends, 4.8/5 stars] No 2) React Native The Complete React Native and Redux Course: Build iOS and Android App fast from scratch. [46,695 recommends, 4.6/5 stars] No 3) Beginner React for Beginners. By Wes Bos [14,955 recommends] React native iOS and Android apps that give attendees a schedule for the F8 conference. Courtesy of Alex Kotlyarskiy [11,081 Stars] Hacker News iOS and Android App: Made with React Native. Courtesy of Simar Singh [3,224 Stars] Dribbble app built with React Native. Courtesy of Catalin MIRON [1,778 Stars] Ready-to-use chat interface for iOS and Android React-Native apps. Courtesy of Farid from Safi [4,006 Stars] iOS’s Stocks App clone: Written in React Native available both iOS and Android. Courtesy of kf [1,352 Stars] A Zhihu Daily App client implemented using React Native (Android and iOS). Courtesy of Race604 [3,521 Stars] A Camera app for React Native (also supports barcode scanning). Courtesy of @CharlieHawker [4,248 Stars] Github client written with react-native. Courtesy of David Tse [1,635 Stars] iOS and Android NBA App built with React Native. Courtesy of WangZixiao [1,715 Stars] React Native Reddit Reader. Courtesy of Andrei Hrabouski [323 Stars] FB Basketball game clone built in React.JS Native. Courtesy of Farid from Safi [344 Stars] A Soundcloud client built with React / Redux. Courtesy of Andrew Nguyen [3,888 Stars] Calculator built with React (Website), Electron (Desktop), and React Native (iOS &amp; Android). Courtesy of Benoit VALLON [4,080 Stars] React-color: Color Pickers from Sketch, Photoshop, Chrome &amp; more. Courtesy of Case Sandberg [4,460 Stars] Gatsby: Transform plain text into dynamic blogs and websites using React.js. Courtesy of kylemathews [15,427 Stars] Sentry is cross-platform crash reporting built with React. Courtesy of Armin Ronacher [14,749 Stars] Isomorphic500: A web application featuring photos from 500px, built on express using React and Flux with yahoo/fluxible. Courtesy of gp [1,311 Stars] A React &amp; react-router-powered implementation of Hacker News using its Firebase API. Courtesy of Arthur Stolyar [1,765 Stars] A playground for in-browser interpreters. Built with React/Redux. Courtesy of Mican [659 Stars] Perseus: Khan Academy’s new exercise question editor and renderer built with React [756 Stars] React-based Imgur-like isomorphic demo app. Courtesy of Brandon Tilley [86 Stars] Flatris: Tetris app for Cosmos, built with React. Courtesy of Ovidiu Cherecheș [304 Stars] That’s it for Amazing React Projects. If you like this curation, read best daily articles based on your programming skills on our website Recommend &amp; share..","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"React Component Patterns","slug":"React-Component-Patterns","date":"2017-11-28T03:53:16.000Z","updated":"2017-11-30T14:56:01.140Z","comments":true,"path":"2017/11/React-Component-Patterns.html","link":"","permalink":"http://nthung2112.github.io/2017/11/React-Component-Patterns.html","excerpt":"Stateful x Stateless, Container x Presentational, HOCs, Render Callbacks and moreIt’s been a while since I’ve been working with React — a Facebook library to build user interfaces using JavaScript — and there are a few concepts I wish I knew when I was just starting. This text is an attempt to summarize some patterns I learned during my experience so far — and also may be useful for developers who are just about to enter this awesome component-based world.","text":"Stateful x Stateless, Container x Presentational, HOCs, Render Callbacks and moreIt’s been a while since I’ve been working with React — a Facebook library to build user interfaces using JavaScript — and there are a few concepts I wish I knew when I was just starting. This text is an attempt to summarize some patterns I learned during my experience so far — and also may be useful for developers who are just about to enter this awesome component-based world. Stateful x Stateless ComponentsJust as Stateful and Stateless web services, React components can also hold and manipulate state during application usage (Stateful) — or just be a simple component that takes the input props and returns what to display (Stateless). A simple Stateless button component that depends on props only: And a Stateful counter component example (using Button component): As you can see, the last one’s constructor holds a component state, while the first one is a simple component that renders a text via props. This separation of concerns may look simple but makes Button component highly reusable. Container x Presentational ComponentsWhen working with external data, we can divide components into this two new categories. Containers are responsible to reach data that lives outside React scope, like connecting to Redux or Relay — while Presentational components are free of dependencies from the rest of the app, depending only on its own state or props received. Let’s take a users list as a Presentational component example: This list can be updated using our Container component: This approach divides data-fetching from rendering and also makes UserListreusable. If you want to learn more about this pattern, there’s an awesome article from Dan Abramov explaining it precisely. Higher-Order ComponentsHigher-Order Components — or just HOCs_ — _are useful when you want to reuse a component logic. They are JavaScript functions that take a component as an argument and returns a new component. Let’s say you need to build an expandable menu component that shows some children content when user clicks on it. So, instead of controlling the state on its parent component, you can simply create a generic HOC to handle it: This approach allows us to apply our logic to our ToggleableMenu component using the JavaScript decorator syntax: Now we can pass any children to ToggleableMenu component: If you’re familiar with Redux’s connect or React Router’s withRouter functions, you’re already using HOCs! Render CallbacksAnother great way to make a component logic reusable is by turning your component children into a function — that’s why Render Callbacks are also called Function as Child Components. We can take an example of our expandable menu HOC and rewrite it using the Render Callback pattern: Now we can pass a function as our Toggleable component children: The code above is already using a function as children, but, if we want to reuse it just as we did in our HOC example (multiple menus), we could simply create a new component that uses Toggleable logic: Our brand new ToggleableMenu component is ready to be used: Our Menu component looks exactly the same as our HOC example! This approach is really useful when we want to change the rendered content itself regardless of state manipulation: as you can see, we’ve moved our render logic to our ToggleableMenu children function, but kept the state logic to our Toggleablecomponent!","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"The Front-End Checklist","slug":"The-Front-End-Checklist","date":"2017-11-28T03:36:59.000Z","updated":"2017-11-30T14:56:01.153Z","comments":true,"path":"2017/11/The-Front-End-Checklist.html","link":"","permalink":"http://nthung2112.github.io/2017/11/The-Front-End-Checklist.html","excerpt":"An Exhaustive List of all the Elements you need to have/test Before Launching your Website To Production. The Front-End Checklist is an exhaustive list of all elements you need to have / to test before launching your site / HTML page to production. It is based on Front-End developers’ years of experience, with additions coming from other open-source checklists. David Dias is the main author/creator and posted the guide to GitHub where it has taken off! The guide is also available below. Don’t forget to thank David for an awesome guide!","text":"An Exhaustive List of all the Elements you need to have/test Before Launching your Website To Production. The Front-End Checklist is an exhaustive list of all elements you need to have / to test before launching your site / HTML page to production. It is based on Front-End developers’ years of experience, with additions coming from other open-source checklists. David Dias is the main author/creator and posted the guide to GitHub where it has taken off! The guide is also available below. Don’t forget to thank David for an awesome guide! Table of Contents Head HTML Webfonts CSS Images JavaScript Security Performance Accessibility SEO How To UseAll items in the Front-End Checklist are required for the majority of the projects, but some elements can be omitted or are not essential (in the case of an administration web app, you may not need RSS feed for example). Some resources possess an emoticon to help you understand which type of content / help you may find on the checklist: 📖: documentation or article 🛠: online tool / testing tool 📹: media or video content Head Notes: You can find a list of everything that could be found in the of an HTML document. Meta tag Doctype: The Doctype is HTML5 and is at the top of all your HTML pages. 12&lt;!-- Doctype HTML5 --&gt;&lt;!doctype html&gt; 📖 Determining the character encoding — HTML5 W3C The next 3 meta tags (Charset, X-UA Compatible and Viewport) need to come first in the head. Charset: The charset declared (UTF-8) is declared correctly. 12&lt;!-- Set character encoding for the document --&gt;&lt;meta charset=\"utf-8\"&gt; X-UA-Compatible: The X-UA-Compatible meta tag is present. 12&lt;!-- Instruct Internet Explorer to use its latest rendering engine --&gt;&lt;meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\"&gt; 📖 Specifying legacy document modes (Internet Explorer) Viewport: The viewport is declared correctly. 12&lt;!-- Viewport for responsive web design --&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; Title: A title is used on all pages (SEO: Google calculate the pixel width of the characters used in the title, cut off between 472 and 482 pixels. Average character limit would be around 55-characters). 12&lt;!-- Document Title --&gt;&lt;title&gt;Page Title less than 65 characters&lt;/title&gt; 📖 Title — HTML — MDN 🛠 SERP Snippet Generator Description: A meta description is provided, it is unique and doesn’t possess more than 150 characters. 12&lt;!-- Meta Description --&gt;&lt;meta name=\"description\" content=\"Description of the page less than 150 characters\"&gt; 📖Meta Description — HTML — MDN Favicons: Each favicon has been created and displays correctly. If you have only a favicon.ico, put it at the root of your site. Normally you won’t need to use any markup. However, it’s still good practice to link to it using the example below. Today, PNG format is recommended over .ico format (dimensions: 32x32px). 1234&lt;!-- Standard favicon --&gt;&lt;link rel=\"icon\" type=\"image/x-icon\" href=\"https://example.com/favicon.ico\"&gt;&lt;!-- Recommended favicon format --&gt;&lt;link rel=\"icon\" type=\"image/png\" href=\"https://example.com/favicon.png\"&gt; 🛠 Favicon Generator 🛠 RealFaviconGenerator 📖 Favicon Cheat Sheet 📖 Favicons, Touch Icons, Tile Icons, etc. Which Do You Need? — CSS Tricks 📖 PNG favicons — caniuse Apple Touch Icon: Apple touch favicon apple-mobile-web-app-capable are present. (Create your Apple Icon file with at least 200x200px dimension to support all dimensions that you may need) 12&lt;!-- Apple Touch Icon --&gt;&lt;link rel=\"apple-touch-icon\" href=\"/custom-icon.png\"&gt; 📖 Configuring Web Applications Windows Tiles: Windows tiles are present and linked. 12&lt;!-- Microsoft Tiles --&gt;&lt;meta name=\"msapplication-config\" content=\"browserconfig.xml\" /&gt; Minimum required xml markup for the browserconfig.xml file is as follows: 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;browserconfig&gt; &lt;msapplication&gt; &lt;tile&gt; &lt;square70x70logo src=\"small.png\"/&gt; &lt;square150x150logo src=\"medium.png\"/&gt; &lt;wide310x150logo src=\"wide.png\"/&gt; &lt;square310x310logo src=\"large.png\"/&gt; &lt;/tile&gt; &lt;/msapplication&gt;&lt;/browserconfig&gt; 📖 Browser configuration schema reference Canonical: Use rel=”canonical” to avoid duplicate content. 12&lt;!-- Helps prevent duplicate content issues --&gt;&lt;link rel=\"canonical\" href=\"http://example.com/2017/09/a-new-article-to-red.html\"&gt; 📖 Use canonical URLs — Search Console Help — Google Support 📖 5 common mistakes with rel=canonical — Google Webmaster Blog HTML tags Language attribute: The lang attribute of your website is specified and related to the language of the current page. 1&lt;html lang=\"en\"&gt; Direction attribute: The direction of lecture is specified on the html tag (It can be used on another HTML tag). 1&lt;html dir=\"rtl\"&gt; 📖 dir — HTML — MDN Alternate language: The language tag of your website is specified and related to the language of the current page. 1&lt;link rel=\"alternate\" href=\"https://es.example.com/\" hreflang=\"es\"&gt; Conditional comments: Conditional comments are present for IE if needed. 📖 About conditional comments (Internet Explorer) — MSDN — Microsoft RSS feed: If your project is a blog or has articles, an RSS link was provided. inline critical CSS: CSS which styles content that is immediately visible during pageload (“above the fold content”) is called “critical CSS”. It is embedded before your principal CSS call and between in a single line (minified). 🛠 Critical by Addy Osmani on Github automates this CSS order: All CSS files are loaded before any JavaScript files in the . (Except the case where sometimes JS files are loaded asynchronously on top of your page). Social metaFacebook OG and Twitter Cards are, for any website, highly recommended. The other social media tags can be considered if you target a particular presence on those and want to ensure the display. Facebook Open Graph: All Facebook Open Graph (OG) are tested and no one is missing or with a false information. Images need to be at least 600 x 315 pixels, 1200 x 630 pixels recommended. 1234567&lt;meta property=\"og:type\" content=\"website\"&gt;&lt;meta property=\"og:url\" content=\"https://example.com/page.html\"&gt;&lt;meta property=\"og:title\" content=\"Content Title\"&gt;&lt;meta property=\"og:image\" content=\"https://example.com/image.jpg\"&gt;&lt;meta property=\"og:description\" content=\"Description Here\"&gt;&lt;meta property=\"og:site_name\" content=\"Site Name\"&gt;&lt;meta property=\"og:locale\" content=\"en_US\"&gt; 📖 A Guide to Sharing for Webmasters 🛠 Test your page with the Facebook OG testing Twitter Card: 1234567&lt;meta name=\"twitter:card\" content=\"summary\"&gt;&lt;meta name=\"twitter:site\" content=\"@site_account\"&gt;&lt;meta name=\"twitter:creator\" content=\"@individual_account\"&gt;&lt;meta name=\"twitter:url\" content=\"https://example.com/page.html\"&gt;&lt;meta name=\"twitter:title\" content=\"Content Title\"&gt;&lt;meta name=\"twitter:description\" content=\"Content description less than 200 characters\"&gt;&lt;meta name=\"twitter:image\" content=\"https://example.com/image.jpg\"&gt; 📖 Getting started with cards — Twitter Developers 🛠 Test your page with the Twitter card validator HTMLBest practices HTML5 Semantic Elements: HTML5 Semantic Elements are used appropriately (header, section, footer, main…). 📖 HTML Reference Error pages: Error 404 page and 5xx exist. Remember that the 5xx error pages need to have their CSS integrated (no external call on the current server). Noopener: In case you are using external links with target=”_blank”, your link should have a rel=”noopener” attribute to prevent tab nabbing. If you need to support older versions of Firefox, use rel=”noopener noreferrer”. 📖 About rel=noopener Clean up comments: Unnecessary code needs to be removed before sending the page to production. HTML testing W3C compliant: All pages need to be tested with the W3C validator to identify possible issues in the HTML code. 🛠 W3C validator HTML Lint: I use tools to help me analyze any issues I could have on my HTML code. 🛠 Dirty markup Link checker: There are no broken links in my page, verify that you don’t have any 404 error. 🛠 W3C Link Checker Adblockers test: Your website shows your content correctly with adblockers enabled (You can provide a message encouraging people to disable their adblocker). Webfonts Webfont format: WOFF, WOFF2 and TTF are supported by all modern browsers. 📖 WOFF — Web Open Font Format — Caniuse. 📖 WOFF 2.0 — Web Open Font Format — Caniuse. 📖 TTF/OTF — TrueType and OpenType font support 📖 Using @font-face — CSS-Tricks Webfont size: Webfont sizes don’t exceed 2 MB (all variants included). CSS Notes: Take a look at CSS guidelines and Sass Guidelines followed by most Front-End developers. If you have a doubt about CSS properties, you can visit CSS Reference_._ Responsive Web Design: The website is using responsive web design. CSS Print: A print stylesheet is provided and is correct on each page. Preprocessors: Your page is using a CSS preprocessor (Sass is preferred). Unique ID: If IDs are used, they are unique to a page. Reset CSS: A CSS reset (reset, normalize or reboot) is used and up to date. (If you are using a CSS Framework like Bootstrap or Foundation, a Normalize is already included into it.) 📖 Reset.css 📖 Normalize.css 📖 Reboot JS prefix: All classes (or id- used in JavaScript files) begin with js- and are not styled into the CSS files. 123&lt;div id=\"js-slider\" class=\"my-slider\"&gt;&lt;!-- Or --&gt;&lt;div id=\"id-used-by-cms\" class=\"js-slider my-slider\"&gt; Embedded or inline CSS: Avoid at all cost embeding CSS in &lt;style&gt; tags or using inline CSS: only use for valid reasons (e.g. background-image for slider, critical CSS). Vendor prefixes: CSS vendor prefixes are used and are generated accordingly with your browser support compatibility. 🛠 Autoprefixer CSS online Performance Concatenation: CSS files are concatenated in a single file. (Not for HTTP/2) Minification: All CSS files are minified. Non-blocking: CSS files need to be non-blocking to prevent the DOM from taking time to load. 📖 loadCSS by filament group 📖 Example of preload CSS using loadCSS Unused CSS: Remove unused CSS. 🛠 UnCSS Online 🛠 🛠 PurifyCSS 🛠 Chrome DevTools Coverage CSS testing Stylelint: All CSS or SCSS files are without any errors. 🛠 stylelint, a CSS linter 📖 Sass guidelines Responsive web design: All pages were tested at the following breakpoints: 320px, 768px, 1024px (can be more / different according to your analytics). CSS Validator: The CSS was tested and pertinent errors were corrected. 🛠 CSS Validator Desktop Browsers: All pages were tested on all current desktop browsers (Safari, Firefox, Chrome, Internet Explorer, EDGE…). Mobile Browsers: All pages were tested on all current mobile browsers (Native browser, Chrome, Safari…). OS: All pages were tested on all current OS (Windows, Android, iOS, Mac…). Pixel perfect: Pages are close to pixel perfect. Depending on the quality of the creatives, you may not be 100% accurate, but your page needs to be close to your template. Pixel Perfect — Chrome Extension Reading direction: All pages need to be tested for LTR and RTL languages if they need to be supported. 📖 Building RTL-Aware Web Apps &amp; Websites: Part 1 — Mozilla Hacks 📖 Building RTL-Aware Web Apps &amp; Websites: Part 2 — Mozilla Hacks Images Notes: For a complete understanding of image optimization, check the free ebook Essential Image Optimizationfrom Addy Osmani. Best practices Optimization: All images are optimized to be rendered in the browser. WebP format could be used for critical pages (like Homepage). 🛠 Imagemin 🛠 Use ImageOptim to optimise your images for free. Picture/Srcset: You use picture/srcset to provide the most appropriate image for the current viewport of the user. 📖 How to Build Responsive Images with srcset Retina: You provide layout images 2x or 3x, support retina display. Sprite: Small images are in a sprite file (in the case of icons, they can be in an SVG sprite image). Width and Height: Set width and height attributes on if the final rendered image size is known (can be omitted for CSS sizing). Alternative text: All have an alternative text which describe the image visually. 📖 Alt-texts: The Ultimate Guide Lazy loading: Images are lazyloaded (A noscript fallback is always provided). JavaScriptBest practices JavaScript Inline: You don’t have any JavaScript code inline (mixed with your HTML code). Concatenation: JavaScript files are concatenated. Minification: JavaScript files are minified (you can add the .min suffix). 📖 Minify Resources (HTML, CSS, and JavaScript) JavaScript security: 📖 Guidelines for Developing Secure Applications Utilizing JavaScript Non-blocking: JavaScript files are loaded asynchronously using async or deferred using defer attribute. 📖 Remove Render-Blocking JavaScript Modernizr: If you need to target some specific features you can use a custom Modernizr to add classes in your tag. 🛠 Customize your Modernizr JavaScript testing ESLint: No errors are flagged by ESLint (based on your configuration or standards rules). 📖 ESLint — The pluggable linting utility for JavaScript and JSX SecurityScan and check your web site securityheaders.io Observatory by Mozilla ASafaWeb — Automated Security Analyser for ASP.NET Websites Best practices HTTPS: HTTPS is used on every pages and for all external content (plugins, images…). 🛠 Let’s Encrypt — Free SSL/TLS Certificates 🛠 Free SSL Server Test 📖 Strict Transport Security HTTP Strict Transport Security (HSTS): The HTTP header is set to ‘Strict-Transport-Security’. 🛠 Check HSTS preload status and eligibility 📖 HTTP Strict Transport Security Cheat Sheet — OWASP 📖 Transport Layer Protection Cheat Sheet — OWASP Cross Site Request Forgery (CSRF): You ensure that requests made to your server-side are legitimate and originate from your website / app to prevent CSRF attacks. 📖 Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet — OWASP Cross Site Scripting (XSS): Your page or website is free from XSS possible issues. 📖 XSS (Cross Site Scripting) Prevention Cheat Sheet — OWASP 📖 DOM based XSS Prevention Cheat Sheet — OWASP Content Type Options: Prevents Google Chrome and Internet Explorer from trying to mime-sniff the content-type of a response away from the one being declared by the server. 📖 X-Content-Type-Options — Scott Helme X-Frame-Options (XFO): Protects your visitors against clickjacking attacks. 📖 X-Frame-Options — Scott Helme 📖 RFC7034 — HTTP Header Field X-Frame-Options PerformanceBest practices Weight page: The weight of each page is between 0 and 500 KB. 🛠 Website Page Analysis 📖 Size Limit: Make the Web lighter Minified: Your HTML is minified. 🛠 W3C Validator Lazy loading: Images, scripts and CSS need to be lazy loaded to improve the response time of the current page (See details in their respective sections). Cookie size: If you are using cookies be sure each cookie doesn’t exceed 4096 bytes and your domain name doesn’t have more than 20 cookies. 📖 Cookie specification: RFC 6265 📖 Cookies 🛠 Browser Cookie Limits Third party components: Third party iframes or components relying on external JS (like sharing buttons) are replaced by static components when possible, thus limiting calls to external APIs and keeping your users activity private. 🛠 Simple sharing buttons generator Preparing upcoming requests 📖 Explanation of the following techniques DNS resolution: DNS of third-party services that may be needed are resolved in advance during idle time using dns-prefetch. 1&lt;link rel=\"dns-prefetch\" href=\"https://example.com\"&gt; Preconnection: DNS lookup, TCP handshake and TLS negociation with services that will be needed soon is done in advance during idle time using preconnect. 1&lt;link rel=\"preconnect\" href=\"https://example.com\"&gt; Prefetching: Resources that will be needed soon (e.g. lazy loaded images) are requested in advance during idle time using prefetch. 1&lt;link rel=\"prefetch\" href=\"image.png\"&gt; Preloading: Resources needed in the current page (e.g. scripts placed at the end of ) in advance using preload. 1&lt;link rel=\"preload\" href=\"app.js\"&gt; 📖 Difference between prefetch and preload Performance testing Google PageSpeed: All your pages were tested (not only the homepage) and have a score of at least 90/100. 🛠 Google PageSpeed 🛠 Test your mobile speed with Google 🛠 WebPagetest — Website Performance and Optimization Test Accessibility Notes: You can watch the playlist A11ycasts with Rob Dodson _📹_ Best practices Progressive enhancement: Major functionality like main navigation and search should work without JavaScript enabled. 📖 Enable / Disable JavaScript in Chrome Developer Tools Color contrast: Color contrast should at least pass WCAG AA (AAA for mobile). 🛠 Contrast ratio Headings H1: All pages have an H1 which is not the title of the website. Headings: Headings should be used properly in the right order (H1 to H6). 📹 Why headings and landmarks are so important — A11ycasts #18 Landmarks Role banner: has role=”banner”. Role navigation: has role=”navigation”. Role main: has role=”main”. 📖 Using ARIA landmarks to identify regions of a page Semantics Specific HTML5 input types are used: This is especially important for mobile devices that show customized keypads and widgets for different types. 📖 Mobile Input Types Form Label: A label is associated with each input form element. In case a label can’t be displayed, use aria-labelinstead. 📖 Using the aria-label attribute — MDN Accessibility testing Accessibility standards testing: Use the WAVE tool to test if your page respects the accessibility standards. 🛠 Wave testing Keyboard navigation: Test your website using only your keyboard in a previsible order. All interactive elements are reachable and usable. Screen-reader: All pages were tested in a screen-reader (VoiceOver, ChromeVox, NVDA or Lynx). Focus style: If the focus is disabled, it is replaced by visible state in CSS. 📹 Managing Focus — A11ycasts #22 SEO Google Analytics: Google Analytics is installed and correctly configured. Headings logic: Heading text helps to understand the content in the current page. sitemap.xml: A sitemap.xml exists and was submitted to Google Search Console (previously Google Webmaster Tools). robots.txt: The robots.txt is not blocking webpages. 🛠 Test your robots.txt with Google Robots Testing Tool Structured Data: Pages using structured data are tested and are without errors. Structured data helps crawlers understand the content in the current page. 📖 Introduction to Structured Data — Search — Google Developers 🛠 Test your page with the Structured Data Testing Tool 🛠 Complete list of vocabularies that can be used as structured data. Schema.org Full Heirarchy Sitemap HTML: An HTML sitemap is provided and is accessible via a link in the footer of your website. 📖 Sitemap guidelines — Google Support 🛠 Sitemap generator","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"front-end","slug":"front-end","permalink":"http://nthung2112.github.io/tags/front-end/"}]},{"title":"Nghiên cứu cải thiện tốc độ web app với React và Preact: Treebo","slug":"Nghien-cuu-cai-thien-toc-do-web-app-voi-React-va-Preact-Treebo","date":"2017-11-15T01:26:38.000Z","updated":"2017-11-15T01:33:31.147Z","comments":true,"path":"2017/11/Nghien-cuu-cai-thien-toc-do-web-app-voi-React-va-Preact-Treebo.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Nghien-cuu-cai-thien-toc-do-web-app-voi-React-va-Preact-Treebo.html","excerpt":"Treebo is India’s top rated budget hotel chain, operating in a segment of the travel industry worth $20 billion. They recently shipped a new Progressive Web App as their default mobile experience, initially using React and eventually switching to Preact in production. What they saw compared to their old mobile site was a 70%+ improvement in time to first paint , 31% improvement in time-to-interactive. and loaded in under 4 seconds over 3G for many typical visitors and on their target hardware. It was interactive in under 5s using WebPageTest’s slower 3G emulation in India.","text":"Treebo is India’s top rated budget hotel chain, operating in a segment of the travel industry worth $20 billion. They recently shipped a new Progressive Web App as their default mobile experience, initially using React and eventually switching to Preact in production. What they saw compared to their old mobile site was a 70%+ improvement in time to first paint , 31% improvement in time-to-interactive. and loaded in under 4 seconds over 3G for many typical visitors and on their target hardware. It was interactive in under 5s using WebPageTest’s slower 3G emulation in India. Switching from React to Preact was responsible for a 15% improvement in time-to-interactive alone. You can check out Treebo.com for their full experience but today we would like to dive into some of the technical journey that made shipping this PWA possible. Treebo’s Progressive Web App A Performance JourneyThe old mobile siteTreebo’s old mobile site was powered by a monolithic Django setup. Users had to wait for a server side request for every page transition on the website. This original setup had a first paint time of 1.5s, a first meaningful paint time of 5.9s and was first interactive in 6.5s. A basic single-page React appFor their first iteration of the rewrite Treebo started off with a Single Page Application built using React and a simple webpack setup. You can take a look at the actual code used below. This generates some simple (monolithic) JavaScript and CSS bundles. This experience had a first paint of 4.8s, was first interactive in about 5.6s and their meaningful header images painted in about 7.2s. Server-side RenderingNext, they went about optimizing their first paint a little so they tried out Server-side Rendering. It’s important to note, server side rendering is not free. It optimizes one thing at the cost of another. With server-side rendering, your server’s response to the browser is the HTML of your page that is ready to be rendered so the browser can start rendering without having to wait for all the JavaScript to be downloaded and executed. Treebo used React’s renderToString() to render components to an HTML string and injecting state for the application on initial boot up. In Treebos’ case, using server side rendering dropped their first paint time to 1.1s and first meaningful paint time down to 2.4s — this improved how quickly users perceived the page to be ready, they could read content earlier on and it performed slightly better at SEO in tests. But the downside was that it had a pretty negative impact on time to interactive. Although users could view content, the main thread got pegged while booting up their JavaScript and just hung there. With SSR, the browser had to fetch and process a much larger HTML payload than before and then still fetch, parse/compile and execute the JavaScript. It was effectively doing more work. This meant that first interactive happened about 6.6s, regressing. SSR can also push TTI back by locking up the main thread on lower-end devices. Code-splitting &amp; route-based chunkingThe next thing Treebo looked at was route-based chunking to help bring down their time-to-interactive numbers. Route-based chunking aims to serve the minimal code needed to make a route interactive, by code-splitting the routes into “chunks” that can be loaded on demand. This encourages delivering resources closer to the granularity they were authored in. What they did here was they split out their vendor dependencies, their Webpack runtime manifests and their routes — into separate chunks. This reduced the time to first interactive down to 4.8s. Awesome! The only downside was that it started the current route’s JavaScript download only after their initial bundles were done executing, which was also not ideal. But it did at least have some positive impact on the experience. For route-based code-splitting and this experience, they’re doing something a little bit more implicit. They’re using React Router’s declarative support for getComponent with a webpack import() call to asynchronously load in chunks. The PRPL Performance PatternRoute-based chunking is a great first step in intelligently bundling code for more granular serving and caching. Treebo wanted to build on this and looked to the PRPL patternfor inspiration. PRPL is a pattern for structuring and serving PWAs, with an emphasis on the performance of app delivery and launch. PRPL stands for: Push critical resources for the initial URL route. Render initial route. Pre-cache remaining routes. Lazy-load and create remaining routes on demand. A PRPL visualization by Jimmy Moon The “Push” part encourages serving an unbundled build designed for server/browser combinations that support HTTP/2 to deliver the resources the browser needs for a fast first paint while optimizing caching. The delivery of these resources can be triggered efficiently using or HTTP/2 Push. Treebo opted to use to preload the current route’s chunk ahead of time. This had the impact of dropping their first interactive times since the current route’s chunk was already in the cache when webpack made a call to fetch it after their initial bundles finished executing. It shifted the time down a little bit and so the first interactive happened at the 4.6s mark. The only con they had with preload is that it’s not implemented cross-browser. However, there’s an implementation of link rel preload in Safari Tech Preview. I’m hopeful that it’s going to land and stick this year. There’s also work underway to try landing it in Firefox. HTML Streaming One difficulty with renderToString() is that it is synchronous, and it can become a performance bottleneck in server-side rendering of React sites. Servers won’t send out a response until the entire HTML is created. When web servers stream out their content instead, browsers can render pages for users before the entire response is finished. Projects like react-dom-stream can help here. To improve perceived performance and introduce a sense of progressive rendering to their app, Treebo looked to HTML Streaming. They would stream the head tag with link rel preload tags set up to early preload in their CSS and their JavaScripts. They then perform their server side rendering and send the rest of the payload down to the browser. The benefit of this was that resource downloads started earlier on, dropping their first paint to 0.9s and first interactive to 4.4s. The app was consistently interactive around the 4.9/5 second mark. The downside here was that it kept the connection open for a little bit longer between the client and server, which could have issues if you run into longer latency times. For HTML streaming, Treebo defined an early chunk with the content, then they have the main content and the late chunks. All of these being injected into the page. This is what it looks like: Effectively, the early chunk has got their rel=preload statements for all of their different script tags. The late chunk has got the server rendered html and anything that’s going to include state or actually use the JavaScript that’s being loaded in. Inlining critical-path CSS CSS Stylesheets can block rendering. Until the browser has requested, received, downloaded and parsed your stylesheets, the page can remain blank. By reducing the amount of CSS the browser has to go through, and by inlining (critical-path styles) it on the page, thus removing a HTTP request, we can get the page to render faster. Treebo added support for Inlining their critical-path CSS for the current route and asynchronously loading in the rest of their CSS using loadCSS on DOMContentLoaded. It had the effect of removing the critical-path render blocking link tag for stylesheets and inlining fewer lines of core CSS, improving first paint times to about 0.4s. The downside was that time to first interactive went up a bit to 4.6s as the payload size was larger with inline styles and took time to parse before JavaScript could be executed. Offline-caching static assets A Service Worker is a programmable network proxy, allowing you to control how network requests from your page are handled. Treebo added support for Service Worker caching of their static assets as well a custom offline page. Below we can see their Service Worker registration and how they used sw-precache-webpack-plugin for resource caching” Caching static assets like their CSS and JavaScript bundles means pages load up (almost) instantly on repeat visits as they load from the disk cache rather than having to go back out to the network each time. Diligently defined caching headers can have this same effect with respect to disk cache hit-rates, but it’s Service Worker that gives us offline support. Serving JavaScript cached using Service Worker using the Cache API (as we covered in JavaScript Start-up Performance) also has the nice property of early-opting Treebo into V8’s code cache so they save a little time on start-up during repeat visits. Next, Treebo wanted to try getting their vendor bundle-size and JS execution time down, so they switched from React to Preact in production. Switching from React to PreactPreact is a tiny 3KB alternative to React with the same ES2015 API. It aims to offer high performance rendering with an optional compatibility later (preact-compat) that works with the rest of the React ecosystem, like Redux. Part of Preact’s smaller size comes from removing Synthetic Events and PropType validations. In addition it: Diffs Virtual DOM against the DOM Allows props like class and for Passes (props, state) to render Uses standard browser events Supports fully async rendering Subtree invalidation by default In a number of PWAs, switching to Preact has led to smaller JS bundle sizes and lower initial JavaScript boot-up times for the application. Recent PWA launches like Lyft, Uber and Housing.com all use Preact in production. Note: Working with a React codebase and want to use Preact? Ideally, you should use preact and preact-compat for your dev, prod and test builds. This will enable you to discover any interop bugs early on. If you would prefer to only alias preact and preact-compat in Webpack for production builds (e.g if your preference is using Enzyme), make sure to thoroughly test everything works as expected before deploying to your servers. In Treebo’s case, this switch had the impact of dropping their vendor bundle sizes from 140kb all the way down to 100kb. This is all gzipped, by the way. It dropped first interactive times from 4.6s to 3.9s on Treebo’s target mobile hardware which was a net win. You can do this in your Webpack config by aliasing react to preact-compat, and react-dom to preact-compat as well. The downside to this approach was that they did have to end up putting together a few workarounds in order to get Preact working exactly with all the different pieces of the React ecosystem that they wanted to use. Preact tends to be a strong choice for the 95% of cases you would use React; for the other 5% you may end up needing to file bugs to work around edge-cases that are not yet factored in. Notes: As WebPageTest does not currently offer a way to test real Moto G4s directly from India, performance tests were run under the “Mumbai — EC2 — Chrome — Emulated Motorola G (gen 4) — 3GSlow — Mobile” setting. Should you wish to look at these traces they can be found here_._ Skeleton screens “A skeleton screen is essentially a blank version of a page into which information is gradually loaded.” ~Luke Wroblewski Treebo like to implement their skeleton screens using preview enhanced components (a little like skeleton screens for each component). The approach is basically to enhance any atomic component (Text, Image etc) to have a preview version, such that if the source data that is required for the component is not present, it shows the preview version of the component instead. For example, if you look at the hotel name, city name, price etc in the list items above, they’re implemented using Typography components like which take two extra props, preview and previewStyle which is used like so. Basically, if the hotel.name does not exist then the component changes the background to a greyish color with the width and other styles set according to the previewStyle passed down (width defaults to 100% if no previewStyle is passed). Treebo likes this approach because the logic to switch to the preview mode is independent of the data actually being shown which makes it flexible. If you look at the “Incl. of all taxes” part, it’s just static text, which could have been shown right at the start but that would’ve looked very confusing to the user since the prices are still loading during the api call. So to get the static text “Incl. of all prices” into a preview mode alongside the rest of the ui they just use the price itself as the logic for the preview mode. This way while the prices are loading you get a preview UI and once the api succeeds you get to see the data in all its glory. Webpack-bundle-analyzerAt this point, Treebo wanted to perform some bundle analysis to look at what other low-hanging fruit they could optimize. Note: If you’re using a library like React on mobile, it’s important to be diligent about the other vendor libraries you are pulling in. Not doing so can negatively impact performance. Consider better chunking your vendor libraries so that routes only load those that are needed Treebo used webpack-bundle-analyzer to keep track of their bundle size changes and to monitor what modules are contained in each route chunk. They also use it to find areas where they can optimize to reduce bundle sizes such as stripping moment.js’ locales and reusing deep dependencies. Optimizing moment.js with webpackTreebo relies heavily on moment.js for their date manipulations. When you import moment.js and bundle it with Webpack, your bundle will include all of moment.js and it’s locales by default which is ~61.95kb gzipped. This seriously bloats your final vendor bundle size. To optimize the size of moment.js, there are two webpack plugins available: IgnorePlugin, ContextReplacementPlugin Treebo opted to remove all locale files with the IgnorePlugin since they didn’t need any of the them. new webpack.IgnorePlugin(/^.\\/locale$/, /moment$/) With the locales stripped out, the moment.js’ bundled size dropped to ~16.48kb gzipped. The biggest improvement as a side effect of stripping out moment.js’ locales was that the vendor bundle size dropped from ~179kb to ~119kb. That’s a massive 60kb drop from a critical bundle that has to be served on first load. All this translates to a considerable decrease in first interaction times. You can read more about optimizing moment.js here. Reusing existing deep dependenciesTreebo was initially using the “qs” module to perform query string operations. Using the webpack-bundle-analyzer output they found that “react-router” included the “history” module which in-turn included the “query-string” module. Since there were two different modules both accomplishing the same operations, replacing “qs” with this version of “query-string” (by installing it explicitly) in their source code, dropped their bundle size by a further 2.72kb gzipped (size of the “qs” module). Treebo have been good open source citizens. They’ve been using a lot of open source software. In return, they’ve actually open sourced most of their Webpack configuration, as well as a boilerplate that contains a lot of the set up they’re using in production. You can find that here: https://github.com/lakshyaranganath/pwa They’ve also committed to trying to keep that up to date. As they evolve you can take advantage of them as another PWA reference implementation. Conclusions and the futureTreebo knows that no application is perfect, they actively explore many methods to keep improving the experience they deliver to their users. Some of which are: Lazy Loading ImagesSome of you might have figured out from the network waterfall graphs before that the website image downloads are competing for bandwidth with the JS downloads. Since image downloads are triggered as soon as the browser parses the img tags, they share the bandwidth during JS downloads. A simple solution would be lazy loading images only when they come into the user’s viewport, this will see a good improvement in our time to interactive. Lighthouse highlights these problems well in the offscreen images audit: Dual Importing Treebo also realise that while they are asynchronously loading the rest of the CSS for the app (after inlining the critical css), this approach is not viable for their users in the long run as their app grows. More features and routes means more CSS, and downloading all of that leads to bandwidth hogging and wastage. Merging approaches followed by loadCSS and babel-plugin-dual-import, Treebo changed their approach to loading CSS by using an explicit call to a custom implemented importCss(‘chunkname’) to download the CSS chunk in parallel to their import(‘chunkpath’) call for their respective JS chunk. With this new approach, a route transition results in two parallel asynchronous requests, one for JS and the other for CSS unlike the previous approach where all of the CSS was being downloaded on DOMContentLoaded. This is more viable since a user will only ever download the required CSS for the routes they are visiting. A/B Testing Treebo are currently implementing an AB testing approach with server side rendering and code splitting so as to only push down the variant that user needs during both server and client side rendering. (Treebo will follow up with a blog post on how they tackled this). Eager Loading Treebo ideally don’t want to always load all the split chunks of the app on load of the initial page since they want to avoid the bandwidth contention for critical resource downloads — this also wastes precious bandwidth for mobile users especially if you’re not caching it with service-worker for their future visits. If we look at how well Treebo is doing on metrics like consistently interactive, there’s still much room for improvement: This is an area they’re experimenting with improving. One example is eager loading the next route’s chunk during the ripple animation of a button. onClick Treebo make a webpack dynamic import() call to the next route’s chunk entry and delay the route transition with a setTimeout. They also want to make sure that the next route’s chunk is small enough to be downloaded within the given 400ms timeout on a slow 3g network. That’s a wrap.It’s been fun collaborating on this write-up. There’s obviously more work to be done, but we hope you found Treebo’s performance journey an interesting read :) You can find us over on twitter at @addyosmani and @__lakshya (yep, double underscore xD) we would love to hear your thoughts. With thanks to _@zouhir_,_ _@developit and @samcccone for their reviews and input.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"preact","slug":"preact","permalink":"http://nthung2112.github.io/tags/preact/"}]},{"title":"Cách chính xác 100% để cấu trúc ứng dụng React","slug":"Cach-chinh-xac-100-de-cau-truc-ung-dung-React","date":"2017-11-13T16:51:55.000Z","updated":"2017-11-15T01:22:22.141Z","comments":true,"path":"2017/11/Cach-chinh-xac-100-de-cau-truc-ung-dung-React.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Cach-chinh-xac-100-de-cau-truc-ung-dung-React.html","excerpt":"When it comes to structuring a React app, the ideal structure is the one that allows you to move around your code with the least amount of effort. In this post, I’d like to tell you how _I_ structure my React apps, and what drove my decisions. Along the way I’ll mention some options I don’t use because they don’t suit me, but that might serve you well. I’d also like to hear how you do things and what you’ve found works well down in the comments.","text":"When it comes to structuring a React app, the ideal structure is the one that allows you to move around your code with the least amount of effort. In this post, I’d like to tell you how _I_ structure my React apps, and what drove my decisions. Along the way I’ll mention some options I don’t use because they don’t suit me, but that might serve you well. I’d also like to hear how you do things and what you’ve found works well down in the comments. What works for youMaybe this was always obvious to you, but it’s only just clicked for me: the structure of an app has nothing to do with computers. Imagine for a moment an app with only one file for all your components, reducers, the store, utilities, everything. A terrible idea, of course. Now, have a think about why the above would be a bad thing. We both know you didn’t really stop and ponder, so I’ll just tell you what I think. The problem with this giant file is that it’s going to be difficult to navigate. But what if you could have bookmarks for each area of the code, maybe one bookmark per function. Maybe the ability to have nested bookmarks. How about a table of contents for all of these bookmarks? This might seem like a daft thought experiment, but I think it’s worth establishing that the only thing you’re trying to do when deciding on a file structure is to maximise how easily you can navigate through your code. Your ‘files’ are nothing more than markers to parts of the code that will wind up being a single chunk of JS at the end of the day. And this is why you can never get a straight answer to the question “what’s the best way to structure my app” — it depends so much on your own navigation habits and preferences that it’s not a question anyone else can answer for you. To work out what the 100% correct application structure was for me, I set out to quantify my most common code-related activities: Create a new component. Usually this is a copy/paste of some existing component. Import one module into another. Here I mean the actual typing out of import { SomeComponent } from ‘../blah/de/blah.js’;. Jump to source. This is when I’m looking at a file, and it has a reference to something external, say a component, and I jump to where that component is defined. Open a known file. Probably doesn’t need a description, but I want my bullet points to look nice and uniform, so this is where I think in my head “I want to open the header nav”, so I use a keyboard shortcut and type the file name to open it. Dammit, now this is the bullet point with the longest description and it didn’t even need one in the first place. Browse for a file I don’t know the name of. Maybe I didn’t work on the little widget that shows the drop down below the user profile photo and don’t know what it’s called. So I want to go browsing the directory structure for this component. Change tab to another open file. This is exactly what it sounds like. I currently have 7 files open, and I want to switch from one tab to another, by clicking on a tab name (or using the keyboard). Next, I had a think about how often I do each of these things. I went back and counted the components I’ve created in the last year, the average number of imports per file, and took some wild guesses at the others, to come up with the following: Sorted by the order that I thought of the things With this data in my hot little hands, I was ready to objectively look at all the aspects of structuring a React app. Let us go through them one by one. Directory structureAs a general rule, if a module (a utility, component, etc.) is only used within another module, then I want it nested in the directory structure like so: &lt;HeaderNav&gt; will only be referenced from within the &lt;Header&gt; component, so it lives as a child. A &lt;Button&gt; could be referenced from anywhere, so it lives at the top level. That rule is great, but I also know that following a super strict set of rules here can be annoying. Technically everything resides under App and under Page too. But I’m not going to represent that in my directory structure, because I don’t want to. This might sound flippant but it’s quite fundamental. If following your own rules creates a structure that is harder to navigate, you’ve taken your eyes off the prize. Outside of components, I don’t think directory structure is very important. You can agonise over whether your reducers and your action creators should be in the same directory as your services until you’re a shade of blue. But if you ask me, any basic structure with sane folder names (actionCreators, reducers, data, etc.) is all you need. This may be the first point where we differ in our needs and wants. I have established that I rarely open files by browsing through a directory structure, so naturally I apply a lower importance to directory structures. I’ve also never worked on a project with more than a few hundred components. If you rely more heavily on navigating a directory structure, or you’re Facebook with 30,000 components, then your needs will likely vary. Another thing: I would suggest naming your components in a ‘fully qualified’ (and globally unique) way. For example, HeaderNav is inside Header, so you could argue that it could just be named Nav. If that suits you, cool. But I open files by typing their names, and look at the text on tabs to switch files. In both these cases, having a fully qualified name is useful. And of course if you’re following BEM where the block matches the component name, you’re going to need globally unique component names anyway. What about container components?Container components are a tricky one, because they’re sort of components, but sort of not. I see two broad approaches to fitting container components into your structure: Treat them exactly like presentational components Leave them out of the directory structure. They will live ‘in the background’, just providing data to a component In the first case, you would actually reference the container component in your markup. So, with the example of a header component that has its own container, it might be included like so: So here I’m passing through some specific data to the and components, while it’s quite clear that the is going to look after its own data needs. If this is how you roll, the logical structure will be something like this: The second option is to leave container components out of the structure; to think of them like implementation details of the component that they wrap. So maybe your would wrap itself in a container component at the point of export. Something like this: And then you reference it like this: The downside is that it isn’t immediately clear that will be provided data from somewhere else. The upside is one less step in the component hierarchy. If this is how you want to do things, you can then just have the container as a function that lives in the same directory as the component it provides data to: (Also note that I exported the ‘raw’ Header as well as the default export of the container-wrapped Header. The former is for unit tests, and your linter might tell you that you’re being confusing by exporting a non-default constant with the same name as the file. I tend to agree with the linter.) I have used the first approach in a medium sized project and it worked quite well. I recently tried out the second example in a new project (that only has 6 container components) and it didn’t quite feel right, so I’ll stick with the first option. I see no problem with either approach. Side note: I think there’s a fine art to recognising the point at which it makes sense to say “you know what, it doesn’t really matter” and moving on with your day. This article nails it and is a nice short read. (Warning: there’s a swear word in the title of that article, so don’t click the link if you’re offended by the word fuck.) Self-contained componentsMy rule: if I have a project with more components than a Klein bottle has sides, I put each component in a directory along with a CSS file and a test. This rule is common for good reason, but even if you do have everything neatly tucked away in the same directory, you’re still quite free to make one huge mistake… Take a look at your nearest file that contains a component. At the top of that file you will probably see a list of all other files that the component relies on as a neat set of imports. Unless, that is, you share CSS classes between components. Then you also have a bunch of dependencies that aren’t listed. Sure, you will save 7 seconds by using that .modal-wrapper class in your component because it already had the shadow you wanted, but oh boy do you even know the world of pain that you have just inflicted upon your future self… [deleted scene: 14 paragraph rant about why this is a bad idea] Trying to convince some people to not share CSS classes between components is like trying to convince people to “avoid using global variables in JavaScript” or “vaccinate your chickens” — some folks just aren’t gonna listen. CSS-module users are no doubt wiggling their butts feeling pretty darn pleased with themselves right now. And they have good reason to be — they have a setup that can enforce the explicit import of CSS classes. If you care about keeping your CSS tightly coupled with your components, you should be using CSS modules too. File namingOne rule that I find immensely useful is this: name your file the same as the thing you’re exporting from that file To some this is not even worth typing out it’s so obvious. But I’ve seen plenty of code where this isn’t the case and boy does it make it slow to move around. (Don’t forget, all of this is personal. When I say “slow to move around”, it’s totally OK for you to think “it wouldn’t make it slow for me”, and therefore decide that there is no point in naming a file the same as its default export.) Something I do very often is open a file by typing its name. If I have a utility function called toString then I fully expect that I will have a file called toString that I can open by typing exactly that. Something else that I do very often is switch tabs to a file that I already have open. For this I’ll expect that tab to have “toString.js” as it’s name. Structures like the below make me want to curl up in a ball in a fireplace that is in use: It staggers me that some people are happy to work like this. Even if your IDE is clever and puts the directory in the tab name for non-unique filenames, you still have a bunch of redundancy there, and will run out of tab room sooner, and you still can’t type the filename to open it. I don’t even need to try this approach to know I won’t like it. Like my cousin’s new band, Mass Spectrometer that “don’t really fit into any known genre”. Get someone else to drive you to the gig. Having said that, I understand that there is reasoning behind this — it means your import statement is this: 1**import** Link **from** '../Link'; Instead of this: 1**import** Link **from** '../Link/Link'; It’s a clear trade-off. Shorter import statements vs file names that match exports. Let’s me just look this up… I import a module into another module, on average, 18 times a week. I open a file by typing its name roughly 840 times a week, and I look for a name on a tab roughly 1,892 times a week. So I’ll take one extra (auto-completed) word in my import path, thanks. Savvy readers will be shouting at their screens: there are two solutions to this that allow you have the file name match the thing being exported, and avoid having to type it twice in the import statement. The first is to put an index.js file in every directory that exports a component, like so: Since Node will look for an index.js file when resolving an import path, a path to ../Link is really a path to ../Link/index.js which is a file that points to the actual component file. If typing fewer characters in your imports is important, then maybe an extra file for every directory sounds like good value. I think it’s a bad deal and I will repeat one more time that it’s seriously OK to have a different opinion on the matter. The second ‘solution’ is this monstrosity: By this point you will know that if Node doesn’t find ../Link/index.js it’s going to check to see if ../Link/package.json exists. If it does, it’s going to resolve to the value of the main property. I think you have to really really hate typing one extra word in your import statements to go as far as creating a package.json file for every component. It’s just weird. And the more weird shit you put in your code, the weirder you become. These two types of ‘redirecting’ files both mean that your import statement no longer points to the file where the thing is defined. In the olden days, this would break the ability to ‘jump to source’ — something that is crucial to me being able to move throughout my code with ease and speed. WebStorm is clever and will resolve these hops (it will ‘know’ that I don’t want to jump into the index.js file, I want to jump all the way to the Link.js file), but if your text editor isn’t so clever, this might leave you with a lot of index.js files open, or jumping to source might not work at all. So before subscribing to an approach, try it out and see if it’s going to be a hindrance to the way you work. .js vs .jsx extensionsUntil recently I’d always used .jsx extensions for any file that contained JSX, and used .js for anything that was vanilla JavaScript. This gave a clear distinction when opening/viewing files and as a bonus, you’ll get proper JSX syntax highlighting in GitHub. However Facebook suggests not using the .jsx extension, so I’ve recently been using just .js and I’m glad I didn’t waste too much time weighing the pros and cons because it makes zero difference to me. I recommend flipping a coin to decide. Index files for utilsAs a result of writing this article, and really thinking about what matters to me, I have actually made a change to one small aspect of my personal preference for app structure. I used to create an index.js file for my utils, like so: So that I could import multiple utilities in one go like this: So neat! Whenever I added a new util (0.8 times per week) I would simply add the util file and a new entry in the index file. Whenever I saw a PR that added a util and forgot to add it to index.js I would remind the developer to add that in. I would also occasionally discover utilities that weren’t in index.js, so would have to add them myself. Such an elegant solution. For some reason it took until September 2017 for me to realise that this only added complexity. And that actually ditching the index.js and doing this was better: It’s fewer lines, one less file, and one less thing to explain to new developers. But those long import paths burn my eyes, so let’s take a look at a couple of solutions. There are two of them, as is often the case with couples. Solution one is to use Webpack’s alias resolving to refer to my utils directory without a relative path. Here I’ve mapped Utils to src/app/utils; the result is pretty, and aligns nicely with the way I import other utilities. Capital ‘U’ by convention to differentiate it from npm packages In the olden days this would confuse some text editors because they wouldn’t know what or where Utils/formatDate was. My IDE is clever and reads my Webpack config (it actually runs webpack under the hood), and makes the connection to the correct file (so I can jump to source, get autocomplete, etc). (The theme continues: the tools we use and the way we use them should most definitely be taken into account when thinking about how to structure our apps.) So… it’s a beautiful, neat, solution. But what’s behind the scenes? This is a nice solution but it has two negative impacts. It adds complexity. We now have more moving parts to achieve the exact same outcome. It reduces clarity. Someone unfamiliar with your Webpack config can’t look at an import statement and know what it’s referring to. The second solution is to convince myself that I don’t care about the dots and leave them as they are. To convince myself, I thought about how often I type out an import path, and as it turns out it’s exactly as often as I make coffee. Then I thought about how really, it’s not so hard to type eight dots and five slashes, compared to the time it takes to put the little coffee pod in the machine, measure out a teaspoon of sugar into a cup, milk the cow just a little bit (shout out to Daisy) and press the picture of a cup. The trade-offs between these two options are representative of many different decisions (in life, and in programming), so this feels like a good time to debut my clarity/obscurity-simplicity/complexity matrix. ClObSiCo for short For me, the decision between these two is a close call. In the end though, I will favour clarity and simplicity wherever possible, so even though having ../../../../ in an import statement is an eyesore, it is the clear and simple winner. Index files for componentsIt’s not my cup of tea, but another thing you might like to do in the battle against the import dots is to create a library for your components. Maybe this gets your motor running: You already know how to do this in your Webpack config: Then in your components directory add an index.js file with a row for each component like so: Boom. n exports per fileHaving one export per file — where the thing being exported and the filename are the same — works a lot of the time and I think is a good general rule for components and utility functions. But I don’t think this works for constants. I also like to start with a single file for all action creators, until it becomes a burden. Same for reducers. In my experience it doesn’t make much difference whether you have eight, 10-line reducers in a single file or eight different files. If you think it has a significant impact on how quickly you can locate a particular piece of code, then do what works for you. Heck, maybe Redux ducks make your boat float. Sure, whatever. What works for the teamNow seems like a good time to explain the title of this post. If you’re working on a project that is just you, then you might be able to find a React structure that is 100% correct, for you. In fact I think it’s well worth aiming for this. But the more people there are on a team, the less likely it is that you’ll find something ‘optimal’, and the more likely other factors will come into play. The big one is compromise. Be aware of distinction bias. You can probably tell from the above that for some items I would be happy to go another way if a team member expressed a strong preference. If someone really wanted to use .jsx extensions or have a Utils alias, I’d be cool with that because although it’s not my preference, it won’t reduce my ability to work quickly. But if someone really really wanted every damn file to be named index.js then it’d be on like Donkey Kong. Another consideration: if you have, say, 30 developers on a team and you’re starting a new project, you might want to structure it as closely to previous projects as possible, no use reinventing the wheel. Or maybe you’ll want to learn from past mistakes and have a different structure, fix that badly-invented wheel. Another little thing: as your team gets bigger, git conflicts will become a bigger part of your day, and erring on the side of smaller files will be a benefit. If you have a mixture of skill levels on the team, that should encourage you to favour simplicity and clarity. On the flip side, if you have a team of seasoned front end engineers (mmm, seasoned), then go nuts and make it as complex as you like. As long as everyone is on the same wavelength, it doesn’t matter how weird it looks from the outside. SummaryI have a confession to make. I always struggle with summaries. It’s like, I just wrote you a whole blog post, what more do you want from me! So it’s not a summary, but I think the most interesting aspect of all the different approaches to application structure is the way people deal with disagreements. There’s a whole class of internet comments that can be summarised as “I disagree and that makes me ANGRY”. Which is a pity, because when two reasonable people disagree, there’s very often something interesting going on, just waiting to be discovered. And since I’m already doing a terrible job of wrapping this up, how about a movie recommendation? If you liked District 9, and haven’t watched Chappie yet, then watching Chappie is something you should immediately go and do. Thanks for reading. Bye!","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Làm thế nào để tổ chức tốt hơn những ứng dụng React","slug":"Lam-the-nao-de-to-chuc-tot-hon-nhung-ung-dung-React","date":"2017-11-13T16:48:00.000Z","updated":"2017-11-13T16:49:59.849Z","comments":true,"path":"2017/11/Lam-the-nao-de-to-chuc-tot-hon-nhung-ung-dung-React.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Lam-the-nao-de-to-chuc-tot-hon-nhung-ung-dung-React.html","excerpt":"I’ve been working on very large web applications for the past few years, starting from ground zero and, with a dozen other developers, making them scale up to now be used by millions of people. And sometimes, if you didn’t start with a good architecture, it can become difficult to keep your code organized. Nathanael Beisiegel wrote an interesting article where he explains his strategy in the organization of large React applications, but I still wasn’t completely satisfied by his approach. So I decided to spend some time to figure out what could be the best way to organize my future React projects.","text":"I’ve been working on very large web applications for the past few years, starting from ground zero and, with a dozen other developers, making them scale up to now be used by millions of people. And sometimes, if you didn’t start with a good architecture, it can become difficult to keep your code organized. Nathanael Beisiegel wrote an interesting article where he explains his strategy in the organization of large React applications, but I still wasn’t completely satisfied by his approach. So I decided to spend some time to figure out what could be the best way to organize my future React projects.Note: I use Redux files in all the examples of this article. If you don’t know what Redux is, you can have a look to the documentation here. Note2: All examples are based on ReactJS, but you can use exactly the same structure for a React-Native application. What are the challenges when you build an application?This has happened or will happen to pretty much all developers over the course of their career: You build an application for a client with a team of a few developers, everything works very well all together. Your client requires new features, fine, you add them. Your client asks you to remove some features and add new ones, it starts to get complicated, you didn’t think about that, but you make it work even though it’s not perfect. Your client now wants you to change another feature, remove some others and add another one that wasn’t expected. At that point, you grab the scotch tape and start patching some code. You are not really proud of it but it works. 6 months later, after some other iterations, the code of the application gets really complicated to read and understand, everything looks like some Italian spaghetti pasta. Until the day your client decides to create a new version of the application, with some fresh new code and features. In some cases, you end-up keeping complicated legacy code that lives with the new code, and this becomes even harder to maintain. And all of this happened because your app wasn’t properly designed from the beginning. When I started to learn React, I found a few very good articles explaining how to create Todo lists or very simple games. Those articles were very useful to understand the basics of React, but I quickly got to a point where I wasn’t able to find much about how I could use React to build actual applications, something with a few dozens pages and hundreds of components. After some research, I learned that every React boilerplate project on Github results to similar structures, they organize all the files by type. This might look familiar to you: 12345678910111213141516171819202122232425262728293031/src /actions /notifications.js /components /Header /Footer /Notifications /index.js /containers /Home /Login /Notifications /index.js /images /logo.png /reducers /login.js /notifications.js /styles /app.scss /header.scss /home.scss /footer.scss /notifications.scss /utils index.js This architecture might be okay to build your website or application, but I believe that it is not the best architecture. When you organize your files by type, as your application grows, it often becomes difficult to maintain. By the time you realize this, it’s too late and you will have to invest a lot of time and money to change everything, or to support what you have for the next few years. The good thing with React is that you can structure your application in any way you like. You are not forced to follow a certain folder structure, React is simply a javascript library. What could be a better approach to organize your application?For a couple of years I worked for a financial institution which used Ember as their main javascript framework to build all their new web applications. One interesting thing about Ember is the ability to structure your project by features, instead of by type. And this changes everything. Pods in Ember are great but still limited, and I wanted something much more flexible. After a few experiments, trying to find what would be the best structure, I got to a point where I decided to group all related features together, and nest them as needed. This is what I use now: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/src /components /Button /Notifications /components /ButtonDismiss /images /locales /specs /index.js /styles.scss /index.js /styles.scss /scenes /Home /components /ButtonLike /services /processData /index.js /styles.scss /Sign /components /FormField /scenes /Login /Register /locales /specs /index.js /styles.scss /services /api /geolocation /session /actions.js /index.js /reducer.js /users /actions.js /api.js /reducer.js index.js store.js Each component, scene or service (a feature) has everything it needs to work on its own, such as its own styles, images, translations, set of actions as well as unit or integration tests. You can see a feature like an independent piece of code you will use in your app (a bit like node modules). To work properly, they should follow these rules: A component can define nested components or services. It cannot use or define scenes. A scene can define nested components, scenes or services. A service can define nested services. It cannot use or define components or scenes. Nested features can only use from its parent. Note: By parent feature, I mean a parent, grandparent, great-grandparent etc… You cannot use a feature that is a “cousin”, this is not allowed. You will need to move it to a parent to use it. Let’s break this down. ComponentsYou all already know what a component is, but one important thing in this organization is the ability to nest a component into another component. Components defined at the root level of your project, in the components folder, are global and can be used anywhere in your application. But if you decide to define a new component inside another component (nesting), this new component can only be used its direct parent. Why would you want to do that? When you develop a large application, it happens quite often that you need to create a component that you definitively know you won’t reuse anywhere else, but you need it. If you add it at the root level of your components folder, it will get lost with hundreds of components. Sure, you could categorize them, but when it’s time to do some clean-up, you won’t remember what they are all for or if they are still being used somewhere. Although, if you define at the root level only the main components of your application, such as buttons, form fields, thumbnails, but also more complicated one like listComments, formComposer with their own children components, it gets much easier to find what you need. Example: 1234567891011/src /components /Button /index.js /Notifications /components /ButtonDismiss /index.js /actions.js /index.js /reducer.js Button can be used anywhere in your application. Notifications can also be used anywhere. This component defines a component ButtonDismiss. You cannot use ButtonDismiss anywhere else than in the Notifications component. ButtonDismiss uses Button internally, this is authorized because Button is defined at the root level of components. ScenesA scene is a page of your application. You can see a scene just like any component, but I like to separate them into their own folder. If you use React-Router or React Native Router, you can import all your scenes in your main index.js file and setup your routes. With the same principle components can be nested, you can also nest a scene into a scene, and also define components or services into a scene. You have to remember that if you decide to define something into a scene, you can only use it within the scene folder itself. Example: 12345678910111213141516171819202122232425/src /scenes /Home /components /ButtonShare /index.js /index.js /Sign /components /ButtonHelp /index.js /scenes /Login /components /Form /index.js /ButtonFacebookLogin /index.js /index.js /Register /index.js /index.js Home has a component ButtonShare, it can only be used by the Home scene. Sign has a component ButtonHelp. This component can be used by Login or Register scenes, or by any components defined in those scenes. Form component uses ButtonHelp internally, this is authorized because ButtonHelp is defined by a parent. The Register scene cannot use any of the components defined in Login, but it can use the ButtonHelp. ServicesNot everything can be a component, and you will need to create independent modules that can be used by your components or scenes. You can see a service like a self-contained module where you will define the core business logic of your application. This can eventually be shared between several scenes or even applications, such as a web and native version of you app. 1234567891011/src /services /api /services /handleError /index.js /index.js /geolocation /session /actions.js /index.js /reducer.js I recommend you to create services to manage all api requests. You can see them as a bridge/an adapter between the server API and the view layer (scenes and components) of your application. It can take care of network calls your app will make, get and post content, and transform payloads as needed before being sent or saved in the store of your app (such as Redux). The scenes and components will only dispatch actions, read the store and update themselves based on the new changes. Wrapping upI’ve been working with this architecture for the past few months on a personal project built with React-Native, and I can tell you this saved me a lot of time. It’s much more simpler to have all related entities grouped together, it makes things easier to work with. This architecture is one of many other ways to organize your project, that’s the way I like it now and I hope this will help you improve yours! If you are interested to see working projects, I have a few on my Github account that follows this architecture: https://github.com/alexmngn/react-rock-paper-scissors (ReactJS) https://github.com/alexmngn/react-native-authentication (React-Native) Feel free to add a comment below or contact me directly if you have any question, I’ll be more than happy to help. Have fun!","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Làm thế nào để cấu trúc các components trong React? ","slug":"Lam-the-nao-de-cau-truc-cac-components-trong-React","date":"2017-11-13T16:41:33.000Z","updated":"2017-11-13T16:46:09.489Z","comments":true,"path":"2017/11/Lam-the-nao-de-cau-truc-cac-components-trong-React.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Lam-the-nao-de-cau-truc-cac-components-trong-React.html","excerpt":"Programming is quite a complex task. Especially crafting clean code is hard. We need to take care of many elements — naming variables, scoping functions, handling errors, ensuring security, monitoring performance etc. Still to name single most difficult thing in programming I would go with writing loosely coupled &amp; highly cohesive components. It doesn’t matter if we’re talking about object-oriented or functional programming. Structuring system is the hardest thing and it has a big impact on the overall project. It takes years to become proficient in designing software architecture (&amp; probably one can never really master it — in such a fast moving industry mastery is always one step ahead, there is always a way to improve design).","text":"Programming is quite a complex task. Especially crafting clean code is hard. We need to take care of many elements — naming variables, scoping functions, handling errors, ensuring security, monitoring performance etc. Still to name single most difficult thing in programming I would go with writing loosely coupled &amp; highly cohesive components. It doesn’t matter if we’re talking about object-oriented or functional programming. Structuring system is the hardest thing and it has a big impact on the overall project. It takes years to become proficient in designing software architecture (&amp; probably one can never really master it — in such a fast moving industry mastery is always one step ahead, there is always a way to improve design). I really enjoy working with React &amp; I think its biggest advantage is how simple React is. There is a difference between simple &amp; easy https://www.infoq.com/presentations/Simple-Made-Easy. And I really mean React is simple. Of course, you need to spend some time to get to know it. But after you understand core concepts, everything else is just a consequence. The hard part comes next. Coupling &amp; CohesionThose are the metrics that more or less describe how difficult it will be to change the behaviour of the code. Coupling &amp; cohesion are used in object-oriented programming and refer to some form of classes. We’ll use them in reference to React components since the same rules apply. Coupling is connection or dependency between elements. If changing one element requires changing another element then we say there is tight coupling. If elements are loosely coupled, changing one element does not imply changes in the other. For example, let’s take a look at displaying bank transfer amount. If displaying amount knows how rates are calculated, then anytime internal structure of transfer changes, displaying code also needs to be updated. If we design system to be loosely coupled, based on the interface of an element, then changes to transfer shouldn’t result in changes to the view layer. Loosely coupled components are easier to manage and maintain. Cohesion tells if element’s responsibilities form one thing. That metric is connected with Single Responsibility Principle or Unix principle: Do one thing and do it well. If account balance formatter also calculates interest rates and checks the permission to display history, then it has many responsibilities and those are not related to each other. Probably, there should be different components for permission handling or interest rates. On the other hand, if there are multiple components one for integer part, one for floating and one for currency, then anytime programmer wants to display balance, they would need to find all elements. The challenge is to create highly cohesive components. Structuring componentsThere are many ways we can structure components. We want components to be reusable, but only to the degree that is reasonable. We want to build small components that can be used to build bigger concepts. Ideally, we want to build loosely coupled &amp; highly cohesive components, so our system is easier to maintain and grow. In React components props can be treated like function arguments and that’s exactly the case for functional stateless components. How we define props in a component, defines how a component can be reused. We’ll use expense manager domain and we’ll analyze expense details formatter. Let’s suppose that expense model looks like this: There are several possibilities to model expense details formatter: no props at all passing expense object passing only required properties passing map of properties passing format as a child We’ll discuss each of them to see what are benefits and flaws of using each and every. Keep in mind that context is the king and everything depends on the system. That’s exactly what we’re paid for — building proper abstraction. No props at allThe simplest solution &amp; the one that is often the starting point is building a component with hard-coded data. Passing no props, of course, doesn’t give us any flexibility and component is suitable to be used only in single place. Of course, in the example of expense details, we can see from the beginning that component needs to accept some props. Nevertheless, there are cases that components without any props is good solution. Firstly, we can use components without props for “constant” content like badges, logos, company info etc. Building even small components makes a system more maintainable. Keeping information in one place allows making changes in one place. Don’t repeat yourself. Passing expense objectIn case of expense details definitely, we need to pass data to the component. First, we’ll take a look at passing expense object. Passing expense object to expense details component makes perfect sense. Expense details formatter is highly coherent -&gt; it displays data of expense. Whenever we want to change formatting, this is the only place that’s going to change. Also changing expense details formatter does not introduce any side effects to expense object itself. The component is tightly coupled to expense object. Is that a bad thing? Definitely not, but we must be aware how that influences our system. Passing expense object as props, results that expense details component relies on the internal structure of expense. Whenever we change the internal structure of expense, we’ll also need to change expense details. Of course, we’ll only need to make changes in one place. How does that design affect future changes? If we want to add, change or remove a field, we’ll only need to change one component. What if we want to add different date formatters? We could add another prop for date formatting. We start adding additional properties to make the component more flexible. As long as there are only a few options, everything is great. The problem starts after system grows and we have a lot of props for different use cases. 1const ExpenseDetails = (&#123; expense, dateFormat, withCurrency, currencyFormat, isOverdue, isPaid ... &#125;) Adding props makes the component more reusable, but it can also be a sign that there are multiple responsibilities of the component. The same rule applies to the function. We can create a function with a number of parameters, but as soon as that number is greater than 3–4, it starts to do a lot of things. And probably that’s the time to split function into smaller one. As number of component props grow, we can decide to split component into more defined ones like: OverdueExpenseDetails, PaidExpenseDetails etc. Passing only required propertiesTo be less coupled with expense object itself, we can pass only required properties. We’re passing each and every property separately, so we’re moving the responsibility a bit to one who is using component. If internal structure of expense changes, it’s not affecting expense details formatter itself -&gt; but probably it can affect every place that is using component because props need to be changed. When passing props as separate properties, a component is more abstract. How passing only required fields affect future design? Adding/updating/removing fields is not easy now. Whenever we want to add a field, we not only need to change the implementation of expense details but also change every place where component is used :( 1const ExpenseDetails = (&#123; category, description, amount, date, account, comment, case ... &#125;) =&gt; ( ... ) On the other hand, supporting multiple date formatting is done almost out-of-the-box. Since we’re passing date as a prop, we can pass formatted date. Deciding how to display particular field is in the hands of the one who uses the component. That is no longer the case of expense details component implementation. Passing map/array of propertiesGoing even more abstract, we could pass a map of properties. The one who uses component is in control over formatting expense details. The object passed to the component has to be properly formatted. That solution has many flaws. We have very little control over how the component will look. The order of reduce is not specified, so we’ll need to add some kind of order. Instead of a map, we could pass an array with objects to overcome that problem, but it still will have drawbacks. Passing map/array as props is not coupled to expense at all but is also not coherent at all. Adding/removing new properties is only a matter of changing prop, but we have no control over the formatting of the component itself. If we want to change only the formatting of the category, it’s not possible it this solution. (To be precise, there is always a way to tweak stuff. For example by passing another props with formatting config. Yet that solution is no longer clean and straightforward.) Passing format as a childWe could also take as little responsibility as possible and pass data as a child. In that case, expense details is only a container to provide some structure and styling. To display details the one using component has to provide all information. Probably in case of expense details, it’s not a good solution, since we’ll need to repeat a lot. Still, flexibility is huge and there are a lot of different formatting possibilities. Adding/removing/updating fields is only a matter of changing the use of the component. The same goes with date formatting. We lose coherence, but that’s the price we had to pay. Context is the kingAs you can see, we’re exchanging different advantages and possibilities. Which one is the best? It depends on: on project itself on stage of project on the component — do we want more specific components or few with options on one’s preferences on requirements — is that component supposed to change frequently &amp; used frequently There is no single good solution. One size doesn’t fit all. How we structure our components has a great impact on how we’ll maintain a system and how expandable it will be. It all depends on the context. Thankfully we have plenty of options and we can pick and choose. Components are a great abstraction to build both small and big systems. It’s only a case of picking right solution.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Cách hoạt động của JavaScript: Quản lý bộ nhớ + 4 cách xử lý memory leaks thông dụng","slug":"Cach-hoat-dong-cua-JavaScript-Quan-ly-bo-nho-4-cach-xu-ly-memory-leaks-thong-dung","date":"2017-11-13T16:26:26.000Z","updated":"2017-11-13T16:31:14.306Z","comments":true,"path":"2017/11/Cach-hoat-dong-cua-JavaScript-Quan-ly-bo-nho-4-cach-xu-ly-memory-leaks-thong-dung.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Cach-hoat-dong-cua-JavaScript-Quan-ly-bo-nho-4-cach-xu-ly-memory-leaks-thong-dung.html","excerpt":"A few weeks ago we started a series aimed at digging deeper into JavaScript and how it actually works: we thought that by knowing the building blocks of JavaScript and how they come to play together you’ll be able to write better code and apps. The first post of the series focused on providing an overview of the engine, the runtime, and the call stack. Thе second post examined closely the internal parts of Google’s V8 JavaScript engine and also provided a few tips on how to write better JavaScript code.","text":"A few weeks ago we started a series aimed at digging deeper into JavaScript and how it actually works: we thought that by knowing the building blocks of JavaScript and how they come to play together you’ll be able to write better code and apps. The first post of the series focused on providing an overview of the engine, the runtime, and the call stack. Thе second post examined closely the internal parts of Google’s V8 JavaScript engine and also provided a few tips on how to write better JavaScript code.In this third post, we’ll discuss another critical topic that’s getting ever more neglected by developers due to the increasing maturity and complexity of programming languages that are being used on a daily basis — memory management. We’ll also provide a few tips on how to handle memory leaks in JavaScript that we at SessionStack follow as we need to make sure SessionStack causes no memory leaks or doesn’t increase the memory consumption of the web app in which we are integrated. OverviewLanguages, like C, have low-level memory management primitives such as malloc() and free(). These primitives are used by the developer to explicitly allocate and free memory from and to the operating system. At the same time, JavaScript allocates memory when things (objects, strings, etc.) are created and “automatically” frees it up when they are not used anymore, a process called garbage collection. This seemingly “automatical” nature of freeing up resources is a source of confusion and gives JavaScript (and other high-level-language) developers the false impression they can choose not to care about memory management. This is a big mistake. Even when working with high-level languages, developers should have an understanding of memory management (or at least the basics). Sometimes there are issues with the automatic memory management (such as bugs or implementation limitations in the garbage collectors, etc.) which developers have to understand in order to handle them properly (or to find a proper workaround, with a minimum trade off and code debt). Memory life cycleNo matter what programming language you’re using, memory life cycle is pretty much always the same: Here is an overview of what happens at each step of the cycle: Allocate memory — memory is allocated by the operating system which allows your program to use it. In low-level languages (e.g. C) this is an explicit operation that you as a developer should handle. In high-level languages, however, this is taken care of for you. Use memory — this is the time when your program actually makes use of the previously allocated memory. Read and write operations are taking place as you’re using the allocated variables in your code. Release memory — now is the time to release the entire memory that you don’t need so that it can become free and available again. As with the Allocate memory operation, this one is explicit in low-level languages. For a quick overview of the concepts of the call stack and the memory heap, you can read our first post on the topic. What is memory?Before jumping straight to memory in JavaScript, we’ll briefly discuss what memory is in general and how it works in a nutshell. On a hardware level, computer memory consists of a large number offlip flops. Each flip flop contains a few transistors and is capable of storing one bit. Individual flip flops are addressable by a unique identifier, so we can read and overwrite them. Thus, conceptually, we can think of our entire computer memory as a just one giant array of bits that we can read and write. Since as humans, we are not that good at doing all of our thinking and arithmetic in bits, we organize them into larger groups, which together can be used to represent numbers. 8 bits are called 1 byte. Beyond bytes, there are words (which are sometimes 16, sometimes 32 bits). A lot of things are stored in this memory: All variables and other data used by all programs. The programs’ code, including the operating system’s. The compiler and the operating system work together to take care of most of the memory management for you, but we recommend that you take a look at what’s going on under the hood. When you compile your code, the compiler can examine primitive data types and calculate ahead of time how much memory they will need. The required amount is then allocated to the program in the call stack space. The space in which these variables are allocated is called the stack space because as functions get called, their memory gets added on top of the existing memory. As they terminate, they are removed in a LIFO (last-in, first-out) order. For example, consider the following declarations: 123int n; // 4 bytesint x[4]; // array of 4 elements, each 4 bytesdouble m; // 8 bytes The compiler can immediately see that the code requires4 + 4 × 4 + 8 = 28 bytes. That’s how it works with the current sizes for integers and doubles. About 20 years ago, integers were typically 2 bytes, and double 4 bytes. Your code should never have to depend on what is at this moment the size of the basic data types. The compiler will insert code that will interact with the operating system to request the necessary number of bytes on the stack for your variables to be stored. In the example above, the compiler knows the exact memory address of each variable. In fact, whenever we write to the variable n, this gets translated into something like “memory address 4127963” internally. Notice that if we attempted to access x[4] here, we would have accessed the data associated with m . That’s because we’re accessing an element in the array that doesn’t exist — it’s 4 bytes further than the last actual allocated element in the array which is x[3], and may end up reading (or overwriting) some of m’s bits. This would almost certainly have very undesired consequences for the rest of the program. When functions call other functions, each gets its own chunk of the stack when it is called. It keeps all its local variables there, but also a program counter that remembers where in its execution it was. When the function finishes, its memory block is once again made available for other purposes. Dynamic allocationUnfortunately, things aren’t quite as easy when we don’t know at compile time how much memory a variable will need. Suppose we want to do something like the following: 123int n = readInput(); // reads input from the user...// create an array with \"n\" elements Here, at compile time, the compiler does not know how much memory the array will need because it is determined by the value provided by the user. It, therefore, cannot allocate room for a variable on the stack. Instead, our program needs to explicitly ask the operating system for the right amount of space at run-time. This memory is assigned from the heap space. The difference between static and dynamic memory allocation is summarized in the following table: Differences between statically and dynamically allocated memory To fully understand how dynamic memory allocation works, we need to spend more time on pointers, which might be a bit too much of a deviation from the topic of this post. If you’re interested in learning more, just let me know in the comments and we can go into more details about pointers in a future post. Allocation in JavaScriptNow we’ll explain how the first step (allocate memory) works in JavaScript. JavaScript relieves developers from the responsibility to handle memory allocations — JavaScript does it by itself, alongside declaring values. 1234567891011121314151617var n = 374; // allocates memory for a numbervar s = 'sessionstack'; // allocates memory for a string var o = &#123; a: 1, b: null&#125;; // allocates memory for an object and its contained valuesvar a = [1, null, 'str']; // (like object) allocates memory for the // array and its contained valuesfunction f(a) &#123; return a + 3;&#125; // allocates a function (which is a callable object)// function expressions also allocate an objectsomeElement.addEventListener('click', function() &#123; someElement.style.backgroundColor = 'blue';&#125;, false); Some function calls result in object allocation as well: 12var d = new Date(); // allocates a Date objectvar e = document.createElement('div'); // allocates a DOM element Methods can allocate new values or objects: 123456789var s1 = 'sessionstack';var s2 = s1.substr(0, 3); // s2 is a new string// Since strings are immutable, // JavaScript may decide to not allocate memory, // but just store the [0, 3] range.var a1 = ['str1', 'str2'];var a2 = ['str3', 'str4'];var a3 = a1.concat(a2); // new array with 4 elements being// the concatenation of a1 and a2 elements Using memory in JavaScriptUsing the allocated memory in JavaScript basically, means reading and writing in it. This can be done by reading or writing the value of a variable or an object property or even passing an argument to a function. Release when the memory is not needed anymoreMost of the memory management issues come at this stage. The hardest task here is to figure out when the allocated memory is not needed any longer. It often requires the developer to determine where in the program such piece of memory is not needed anymore and free it. High-level languages embed a piece of software called garbage collector which job is to track memory allocation and use in order to find when a piece of allocated memory is not needed any longer in which case, it will automatically free it. Unfortunately, this process is an approximation since the general problem of knowing whether some piece of memory is needed is undecidable (can’t be solved by an algorithm). Most garbage collectors work by collecting memory which can no longer be accessed, e.g. all variables pointing to it went out of scope. That’s, however, an under-approximation of the set of memory spaces that can be collected, because at any point a memory location may still have a variable pointing to it in scope, yet it will never be accessed again. Garbage collectionDue to the fact that finding whether some memory is “not needed anymore” is undecidable, garbage collections implement a restriction of a solution to the general problem. This section will explain the necessary notions to understand the main garbage collection algorithms and their limitations. Memory referencesThe main concept garbage collection algorithms rely on is the one of reference. Within the context of memory management, an object is said to reference another object if the former has an access to the latter (can be implicit or explicit). For instance, a JavaScript object has a reference to its prototype (implicit reference) and to its properties’ values (explicit reference). In this context, the idea of an “object” is extended to something broader than regular JavaScript objects and also contains function scopes (or the global lexical scope). Lexical Scoping defines how variable names are resolved in nested functions: inner functions contain the scope of parent functions even if the parent function has returned. Reference-counting garbage collectionThis is the simplest garbage collection algorithm. An object is considered “garbage collectible” if there are zero references pointing to it. Take a look at the following code: 1234567891011121314151617181920212223242526272829var o1 = &#123; o2: &#123; x: 1 &#125;&#125;;// 2 objects are created. // 'o2' is referenced by 'o1' object as one of its properties.// None can be garbage-collected var o3 = o1; // the 'o3' variable is the second thing that // has a reference to the object pointed by 'o1'. o1 = 1; // now, the object that was originally in 'o1' has a // single reference, embodied by the 'o3' variablevar o4 = o3.o2; // reference to 'o2' property of the object. // This object has now 2 references: one as // a property. // The other as the 'o4' variableo3 = '374'; // The object that was originally in 'o1' has now zero // references to it. // It can be garbage-collected. // However, what was its 'o2' property is still // referenced by the 'o4' variable, so it cannot be // freed.o4 = null; // what was the 'o2' property of the object originally in // 'o1' has zero references to it. // It can be garbage collected. Cycles are creating problemsThere is a limitation when it comes to cycles. In the following example, two objects are created and reference one another, thus creating a cycle. They will go out of scope after the function call, so they are effectively useless and could be freed. However, the reference-counting algorithm considers that since each of the two objects is referenced at least once, neither can be garbage-collected. 12345678function f() &#123; var o1 = &#123;&#125;; var o2 = &#123;&#125;; o1.p = o2; // o1 references o2 o2.p = o1; // o2 references o1\\. This creates a cycle.&#125;f(); Mark-and-sweep algorithmIn order to decide whether an object is needed, this algorithm determines whether the object is reachable. The Mark-and-sweep algorithm goes through these 3 steps: Roots: In general, roots are global variables which get referenced in the code. In JavaScript for example, a global variable that can act as a root is the “window” object. The identical object in Node.js is called “global”. A complete list of all roots gets built by the garbage collector. The algorithm then inspects all roots and their children and marks them as active (meaning, they are not garbage). Anything that a root cannot reach will be marked as garbage. Finally, the garbage collector frees all memory pieces that are not marked as active and returns that memory to the OS. A visualization of the mark and sweep algorithm in action This algorithm is better than the previous one since “an object has zero reference” leads to this object being unreachable. The opposite is not true as we have seen with cycles. As of 2012, all modern browsers ship a mark-and-sweep garbage-collector. All improvements made in the field of JavaScript garbage collection (generational/incremental/concurrent/parallel garbage collection) over the last years are implementation improvements of this algorithm (mark-and-sweep), but not improvements over the garbage collection algorithm itself, nor its goal of deciding whether an object is reachable or not. In this article, you can read in a greater detail about tracing garbage collection that also covers mark-and-sweep along with its optimizations. Cycles are not a problem anymoreIn the first example above, after the function call returns, the two objects are not referenced anymore by something reachable from the global object. Consequently, they will be found unreachable by the garbage collector. Even though there are references between the objects, they’re not reachable from the root. Counter intuitive behavior of Garbage CollectorsAlthough Garbage Collectors are convenient they come with their own set of trade-offs. One of them is non-determinism. In other words, GCs are unpredictable. You can’t really tell when a collection will be performed. This means that in some cases programs use more memory that it’s actually required. In other cases, short-pauses may be noticeable in particularly sensitive applications. Although non-determinism means one cannot be certain when a collection will be performed, most GC implementations share the common pattern of doing collection passes during allocation. If no allocations are performed, most GCs stay idle. Consider the following scenario: A sizable set of allocations is performed. Most of these elements (or all of them) are marked as unreachable (suppose we null a reference pointing to a cache we no longer need). No further allocations are performed. In this scenario, most GCs will not run any further collection passes. In other words, even though there are unreachable references available for collection, these are not claimed by the collector. These are not strictly leaks but still, result in higher-than-usual memory usage. What are memory leaks?Just like the memory suggests, memory leaks are pieces of memory that the application have used in the past but is not needed any longer but has not yet been return back to the OS or the pool of free memory. Programming languages favor different ways of managing memory. However, whether a certain piece of memory is used or not is actually an undecidable problem. In other words, only developers can make it clear whether a piece of memory can be returned to the operating system or not. Certain programming languages provide features that help developers do this. Others expect developers to be completely explicit about when a piece of memory is unused. Wikipedia has good articles on manual and automatic memory management. The four types of common JavaScript leaks1: Global variablesJavaScript handles undeclared variables in an interesting way: when a undeclared variable is referenced, a new variable gets created in the global object. In a browser, the global object would be window, which means that 123function foo(arg) &#123; bar = \"some text\";&#125; is the equivalent of: 123function foo(arg) &#123; window.bar = \"some text\";&#125; Let’s say the purpose of bar is to only reference a variable in the foo function. A redundant global variable will be created, however, if you don’t use var to declare it. In the above case, this won’t cause much harm. You can surely imagine a more damaging scenario though. You can also accidentally create a global variable using this: 12345function foo() &#123; this.var1 = \"potential accidental global\";&#125;// Foo called on its own, this points to the global object (window)// rather than being undefined.foo(); You can avoid all this by adding ‘use strict’; at the beginning of your JavaScript file which would switch on a much stricter mode of parsing JavaScript which prevents the unexpected creation of global variables. Unexpected globals is certainly an issue, however, more often than not your code would be infested with explicit global variables which by definition cannot be collected by the garbage collector. Special attention needs to be given to global variables used to temporarily store and process large bits of information. Use global variables to store data if you must but when you do, make sure to assign it as null or reassign it once you are done with it. 2: Timers or callbacks that are forgottenLet’s take setInterval for example as it’s often used in JavaScript. Libraries which provide observers and other instruments that accept callbacks usually make sure all references to the callbacks become unreachable once their instances are unreachable too. Still, the code below is not a rare find: 1234567var serverData = loadData();setInterval(function() &#123; var renderer = document.getElementById('renderer'); if(renderer) &#123; renderer.innerHTML = JSON.stringify(serverData); &#125;&#125;, 5000); //This will be executed every ~5 seconds. The snippet above shows the consequences of using timers that reference nodes or data that’s no longer needed. The renderer object may be replaced or removed at some point which would make the block encapsulated by the interval handler redundant. If this happens, neither the handler, nor its dependencies would be collected as the interval would need to be stopped first (remember, it’s still active). It all boils down to the fact that serverData which surely stores and processes loads of data will not be collected either. When using observers, you need to make sure you make an explicit call to remove them once you are done with them (either the observer is not needed anymore, or the object will become unreachable). Luckily, most modern browsers would do the job for you: they’ll automatically collect the the observer handlers once the observed object becomes unreachable even if you forgot to remove the listener. In the past some browsers were unable to handle these cases (good old IE6). Still, though, it’s in line with best practices to remove the observers once the object becomes obsolete. See the following example: 123456789101112131415var element = document.getElementById('launch-button');var counter = 0;function onClick(event) &#123; counter++; element.innerHtml = 'text ' + counter;&#125;element.addEventListener('click', onClick);// Do stuffelement.removeEventListener('click', onClick);element.parentNode.removeChild(element);// Now when element goes out of scope,// both element and onClick will be collected even in old browsers // that don't handle cycles well. You no longer need to call removeEventListener before making a node unreachable as modern browsers support garbage collectors that can detect these cycles and handle them appropriately. If you leverage the jQuery APIs (other libraries and frameworks support this too) you can also have the listeners removed before a node is made obsolete. The library would also make sure there are no memory leaks even when the application is running under older browser versions. 3: Closures A key aspect of JavaScript development are closures: an inner function that has access to the outer (enclosing) function’s variables. Due to the implementation details of the JavaScript runtime, it is possible to leak memory in the following way: 1234567891011121314151617var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) // a reference to 'originalThing' console.log(\"hi\"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(\"message\"); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); Once replaceThing is called, theThing gets a new object which consists of a big array and a new closure (someMethod). Yet, originalThing is referenced by a closure that’s held by the unused variable (which is theThing variable from the previous call to replaceThing). The thing to remember is that once a scope for closures is created for closures in the same parent scope, the scope is shared. In this case, the scope created for the closure someMethod is shared with unused. unused has a reference to originalThing. Even though unused is never used, someMethod can be used through theThing outside of the scope of replaceThing (e.g. somewhere globally). And as someMethod shares the closure scope with unused, the reference unused has to originalThing forces it to stay active (the whole shared scope between the two closures). This prevents its collection. In the above example, the scope created for the closure someMethod is shared with unused, while unused references originalThing. someMethod can be used through theThing outside of the replaceThing scope, despite the fact that unused is never used. The fact that unused references originalThing requires that it remains active since someMethod shares the closure scope with unused. All this can result in a considerable memory leak. You can expect to see a spike in memory usage when the above snippet is run over and over again. Its size won’t shrink when the garbage collector runs. A linked list of closures is created (its root is theThing variable in this case), and each the closure scopes carries forward an indirect reference to the big array. This issue was found by the Meteor team and they have a great article that describes the issue in great detail. 4: Out of DOM referencesThere are cases in which developers store DOM nodes inside data structures. Suppose you want to rapidly update the contents of several rows in a table. If you store a reference to each DOM row in a dictionary or an array, there will be two references to the same DOM element: one in the DOM tree and another in the dictionary. If you decide to get rid of these rows, you need to remember to make both references unreachable. 123456789101112131415var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image')&#125;;function doStuff() &#123; elements.image.src = 'http://example.com/image_name.png';&#125;function removeImage() &#123; // The image is a direct child of the body element. document.body.removeChild(document.getElementById('image')); // At this point, we still have a reference to #button in the //global elements object. In other words, the button element is //still in memory and cannot be collected by the GC.&#125; There’s an additional consideration that has to be taken into account when it comes to references to inner or leaf nodes inside a DOM tree. If you keep a reference to a table cell (a tag) in your code and decide to remove the table from the DOM yet keep the reference to that particular cell, you can expect a major memory leak to follow. You might think that the garbage collector would free up everything but that cell. This will not be the case, however. Since the cell is a child node of the table and children keep references to their parents, this single reference to the table cell would keep the whole table in memory. We at SessionStack try to follow these best practices in writing code that handles memory allocation properly, and here’s why: Once you integrate SessionStack into your production web app, it starts recording everything: all DOM changes, user interactions, JavaScript exceptions, stack traces, failed network requests, debug messages, etc.With SessionStack, you replay issues in your web apps as videos and see everything that happened to your user. And all of this has to take place with no performance impact for your web app.Since the user can reload the page or navigate your app, all observers, interceptors, variable allocations, etc. have to be handled properly, so they don’t cause any memory leaks or don’t increase the memory consumption of the web app in which we are integrated. There is a free plan so you can give it a try now. Resources http://www-bcf.usc.edu/~dkempe/CS104/08-29.pdf https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156 http://www.nodesimplified.com/2017/08/javascript-memory-management-and.html https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Giải thích React Lifecycle - componentDidMakeSense","slug":"Giai-thich-React-Lifecycle-componentDidMakeSense","date":"2017-11-04T16:42:53.000Z","updated":"2017-11-04T16:45:48.181Z","comments":true,"path":"2017/11/Giai-thich-React-Lifecycle-componentDidMakeSense.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Giai-thich-React-Lifecycle-componentDidMakeSense.html","excerpt":"Learn the React lifecycle methods and when/how to use them React is incredible because it allows you to build your UI using a declarative API. You tell React what you want the interface to look like, and it handles the rest. As users interact with the application, the state changes which causes updates to the DOM. React provides a set of methods to seamlessly intercept the changes at any point during the updates and take control of the UI. The component lifecycle is typically one of the final pieces to truly mastering React, and this article will ensure that you have a firm grasp. The lifecycle of a component can be defined as the time from when the component is first being inserted into the DOM, the entire time the component is in the DOM, and the point when the component is being removed from the DOM. There is a unique lifecycle for every React component in your code.","text":"Learn the React lifecycle methods and when/how to use them React is incredible because it allows you to build your UI using a declarative API. You tell React what you want the interface to look like, and it handles the rest. As users interact with the application, the state changes which causes updates to the DOM. React provides a set of methods to seamlessly intercept the changes at any point during the updates and take control of the UI. The component lifecycle is typically one of the final pieces to truly mastering React, and this article will ensure that you have a firm grasp. The lifecycle of a component can be defined as the time from when the component is first being inserted into the DOM, the entire time the component is in the DOM, and the point when the component is being removed from the DOM. There is a unique lifecycle for every React component in your code. Check out gitconnected &gt;The community and network for developers and software engineers. Overview of the lifecycleThe lifecycle methods are hooks to allow you to read state changes and control UI updates. The lifecycle can be broken down into 3 categories: Mounting: The component is being added to the DOM. Updates: The component receives changes props or state and is called when the component is being re-rendered. Unmounting: The component is being removed from the DOM. The lifecycle methods provide entry points to take over any of these steps. Any method that begins with componentWill means you access it before the event occurs and any method prepended with componentDid means you capture it after the event occurs. Mounting constructor() componentWillMount() render() componentDidMount() Updating componentWillReceiveProps() shouldComponentUpdate() componentWillUpdate() render() componentDidUpdate() Unmounting componentWillUnmount() constructorThis method is called when your component is being created and before mounting (being added to the DOM). Its primary use is to initialize state and .bind(this) for the component’s methods. If you do neither of these, then there is no need for a constructor. componentWillMountThis method is executed right before a component is added to the DOM / render(). It is generally recommended that you use the constructor, but this method is still included in the API mostly for backwards compatibility. You should avoid calling any functions that cause side effects in this method as setState won’t trigger a change and there is no DOM to interact with. Note that this is also the only lifecycle method called on the server. componentDidMountYour component has now been rendered and exists in the DOM. This is the point when you should initiate AJAX requests, add event listeners, and perform any set up that requires a DOM. Calling setState during this method or any time after will cause a re-render. componentWillReceivePropsWhen your component receives new props from its parent, componentWillReceiveProps(nextProps) is triggered. This is a great time to check if there are changes in the incoming props when compared to your current props and trigger a state change based on the new values. A common use-case for this is resetting state based on a change. shouldComponentUpdateThis method exists purely for performance improvements. Renders and reconciliations are expensive in React. shouldComponentUpdate(nextProps, nextState) provides the developer the ability to return a boolean true/false from this method which controls whether React should perform the reconciliation operations and DOM updates. The default behavior is for React to render every update, which works in most cases. If shouldComponentUpdate() returns false, then componentWillUpdate(), render(), and componentDidUpdate() will not be invoked. componentWillUpdateReact invokes this method immediately before rendering when new props or state are being received. There is not much use for componentWillUpdate(nextProps, nextState) and should probably be avoided (similar to componentWillMount). You should not do anything that would change the state at this point — use componentWillReceiveProps if you need to do anything before a render. Note that this method is not called on the initial render. componentDidUpdateImmediately after React builds you a shiny new UI, componentDidUpdate(prevProps, prevState) is invoked. This is a great time to interact with the DOM or instantiate a new network request based on what the new interface should look like. componentWillUnmountYour component had a great life and now it’s time for it to leave the UI. This is the moment to clean up everything that was associated with adding and maintaining your component while it was living on the UI. BONUS: componentDidCatchcomponentDidCatch(error, info) is a new lifecycle that was added in React 16. React was notorious for crashing the an entire application if a JavaScript error was thrown inside the React app. It corrupted React’s internal state which blew up the app and yielded cryptic error messages. componentDidCatch solves this by catching any JavaScript error occurring in a component’s tree for the children of the component that implements the method. It is able to capture the error and display a fallback UI.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Hướng dẫn xây dựng ứng dụng React Redux CRUD","slug":"Huong-dan-xay-dung-ung-dung-React-Redux-CRUD","date":"2017-11-04T16:38:19.000Z","updated":"2017-11-04T16:40:27.398Z","comments":true,"path":"2017/11/Huong-dan-xay-dung-ung-dung-React-Redux-CRUD.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Huong-dan-xay-dung-ung-dung-React-Redux-CRUD.html","excerpt":"Building a single-page CRUD app using React and Redux can be challenging because you’ll have to deal w/ new techniques and terms like “Reducers”, “Actions”, “Middlewares”, “Stores” and so on. Perhaps the trickiest part is making async requests and handling responses. While there are many examples, there is no well established pattern for making async requests and handling responses in Redux apps(just yet). In this blog I’ll provide a general approach on how to build a Blog app that has 3 pages and show navigate b/w them. Further, I’ll also establish a pattern for making async requests and handling four async states: “loading”, “success”, “error” and “success-and-navigate”. Source code: https://github.com/rajaraodv/react-redux-blog Let’s get started.","text":"Building a single-page CRUD app using React and Redux can be challenging because you’ll have to deal w/ new techniques and terms like “Reducers”, “Actions”, “Middlewares”, “Stores” and so on. Perhaps the trickiest part is making async requests and handling responses. While there are many examples, there is no well established pattern for making async requests and handling responses in Redux apps(just yet). In this blog I’ll provide a general approach on how to build a Blog app that has 3 pages and show navigate b/w them. Further, I’ll also establish a pattern for making async requests and handling four async states: “loading”, “success”, “error” and “success-and-navigate”. Source code: https://github.com/rajaraodv/react-redux-blog Let’s get started. STEP 1 — Write Detailed Mocks For Each Page And Phases.In our app we have 3 pages: An Index page that shows a list of Posts, a Post details page and a New Post page. Each page has “Success”, “Loading” and “Error” phases because they all make AJAX calls to load/delete posts, so we need to mock those things as well. 1.1 Success Phase — Detailed Mocks when things are working Note: You can click on the pictures to Zoom and read 1.2 Loading Phase — Detailed Mocks when they are loading 1.3 Error Phase — Detailed Mocks when there is an Error STEP 2 — Divide Each Page Into ComponentsLook at all the phases of each page and roughly divide each page into components based on “purpose” and based on physical location. This helps you identify reusable components across different pages and also any additional ones in a specific phase. For example, you may need a “Spinner” or an “Error” component for different phases. Note: this doesn’t need to be perfect. You can make changes later on. 2.1 — Success Phase: Divide Each Page Into Components Index page: 1. Shows list of posts, 2. Allows navigating to Post form page to create new post. So we end up w/ PostsList and Header components. Post details page: 1. Shows details of the post, 2. Allows navigating back to Index page 3. Index page. So we end up with PostDetails and Header components. 3. New Post page: 1. Allows creating posts and 2. allows navigating back to Index. Again we end up with PostForm and Header component. Notice that we can reuse Header across all 3 pages because of the physical location. So we end up with four components (instead of 6): 1. PostsList, 2. PostDetails 3. PostForm and 4. Header components. 2.2 — Loading Phase: Divide Each Page Into ComponentsIf you look at the mock, we are simply displaying “loading..” text in each page and not using some fancy spinner or “toast”. So we don’t have any more components. 2.3 — Error Phase: Divide Each Page Into ComponentsIf you look at the mock, we are simply throwing an alert popup and not using any custom modals. So we don’t have any more components. So net-net, we have 4 components (1. PostsList, 2. PostDetails 3. PostForm and 4. Header) Redux Terms:Redux Terms — “Actions” And “States”Every component does two things: 1. Listen to the user and server events and send them to JS functions. In Redux, events are represented as a JSON object called “Actions”. 1&#123;\"type\": \"FETCH_POST\", \"id\": 1234&#125; // &lt;-- Action 2. Render DOM based on some data. This data is called a“state”, which is also a JSON object. 1&#123;\"post\": &#123;\"id\": 1234, \"title\": \"My Redux Post\"&#125;&#125; // &lt;-- state Redux Terms — “Action Creators”These are functions that listen to DOM or server events and return formal JSON “Action” object. 123456function fetchPost(id) &#123;return &#123; type: FETCH_POST, result: makeServerRequest(\"http://postsServer.com/api/id\") &#125;;&#125; See Action Creators for our app. Redux Terms — “Dispatching an Action”Redux provides a function called “dispatch” which allows us to pass the “Action” JSON object to all other components. Dispatching an Action means simply calling the dispatch function w/ the action JSON object. 1//Call the \"Action Creator\" w/ post's id and then use it's return //value (Action JSON object) to finally dispatch it to \"reducers\"dispatch(fetchPost(id)) or dispatch(&#123;type:\"FETCH_POST\", id:1234&#125;) The components calls Action creators to receive Actions and then dispatches the actions. Redux then send the actions to “Reducers” Redux Terms — “Reducers”Reducers are functions that take an Action and the current state that was sent to them via “dispatch”, apply action to the current state and return a new state. And Redux re-renders all components whenever there is a new state. 1234//If the action is FETCH_POST_SUCCESS, return a new \"activePost\" //state w/ new post)case FETCH_POST_SUCCESS: return &#123;activePost: &#123;post: action.payload.data, error:null, loading: false&#125;&#125;; See Reducers “reducer_posts.js” and main “index.js” (this combines multiple reducers into one) OK, before we go ahead to step 3, let’s understand how to deal with Async Actions because every page makes AJAX calls. PATTERN: Dealing With Async ActionsIf component is loading an object(e.g. list of Posts) via AJAX call to the server, that object’s state should keep track of all the potential states. Initial state for such objects should look like: {objName: {obj:null, loading: false, error:null}}. Further, such components should dispatch up to 4 actions such as “FETCH_OBJ”(for loading), “FETCH_OBJ_SUCCESS”, “FETCH_OBJ_FAILURE” and “OBJ_RESET”(to cleanup dirty previous state). For example, if we are loading list of posts.. Note: You can click on the pictures to zoom and read Initial State: Initial state should look like, 1&#123;postsList:&#123;posts:[], loading:false, error:null&#125;&#125; Actions: FETCH_OBJ — Dispatch this to make the server request and also let other components know we are loading. This helps current/other components show “loading” or hide or do something. 1dispatch(&#123;“type”: “FETCH_POSTS”, loading: true&#125;) Once Redux gets this and passes it through reducers, the new state will look something like: 1&#123;postList: &#123;posts:null, error: null, loading: true&#125;&#125; 2. FETCH_OBJ_SUCCESS: Dispatch this when you get successful response. This is to show the actual data and also to cancel “loading” 1dispatch(&#123;\"type\": \"FETCH_POSTS_SUCCESS\", \"posts\":[post1, post2]) Once Redux gets this and passes it through reducers, the new state will look something like: 1&#123;postsList:&#123;posts:[post1, post2], error:null, loading: false&#125;&#125; 3.FETCH_OBJ_FAILURE: Dispatch this when you get a failed response. This is to show some error message and also to cancel “loading”. 1dispatch(&#123;\"type\": \"FETCH_POSTS_FAILURE\", \"error\": \"Error message\"&#125;) Once Redux gets this and passes it through reducers, the new state will look something like: 1&#123;postList:&#123;posts:null, error:&#123;msg: \"Error msg\"&#125;, loading: false&#125;&#125; 4.RESET_OBJ: Dispatch this to reset the component’s state after success/failure. This is optional but can be useful when you want to reuse a “dirty” component from previous AJAX request. 1dispatch(&#123;\"type\": \"RESET_POST\", loading: false, \"post\": null, \"error\": \"Error message\"&#125;) Once Redux gets this and passes it through reducers, the new state will look something like: 1&#123;postList:&#123;post:null, error:null, loading: false&#125;&#125; STEP 3 — List State and Actions For Each Component (AND For Each Phase)Take a look at each component one by one and each phase and list of state and actions. We have 4 components: 1. PostsList, 2. PostDetails 3. PostForm and 4. Header components. 3.1 PostList Component — List State And Actions States: List out various data that may change the display of the component in all phases of the component. Shows list of Posts. Let’s call the state as “posts” (an array). Shows “Loading..”, if it’s in the processing fetching the posts. Let’s call this state “loading”(boolean) Shows “Error” if there is an error. Let’s call this state as “error”(null or error info). Since all the above are related to PostList, let’s put them in a single state object called postList. 1&#123; postsList: &#123;posts: [], error:null, loading: false&#125; //initial state Actions: This component makes a “AJAX” call to load posts, so we’ll use the above mentioned pattern and create 4 actions. 1.Asks server for list of posts. Let’s call this action as: “FETCH_POSTS”. 123456export function fetchPosts() &#123; const request = axios.get(`$&#123;ROOT_URL&#125;/posts`);return &#123; type: FETCH_POSTS, payload: request &#125;;&#125; 2.Tells every component that it received posts (success case). Let’s call this “FETCH_POSTS_SUCCESS” 123456export function fetchPostsSuccess(posts) &#123; return &#123; type: FETCH_POSTS_SUCCESS, payload: posts &#125;;&#125; 3.Tells every component that there was an error(failure case). Let’s call this “FETCH_POSTS_FAILURE” 123456export function fetchPostsFailure(error) &#123; return &#123; type: FETCH_POSTS_FAILURE, payload: error &#125;;&#125; 4. Resetting data is not required because this is the 1st page (you’ll see how this is useful in other 2 pages) 3.2 PostDetails Component — List State And Actions Note: You can click on the pictures to zoom and read 3.3 PostForm Component — State And Actions 3.4 Header Component — List State And Actions STEP 4 — Create Action Creators For Each ActionWe have a total of 12 actions(4 actions x 3 pages), create action creators for each one. Please see the source code here. 12345678910111213141516//Example Action creators...export function fetchPosts() &#123; const request = axios.get(`$&#123;ROOT_URL&#125;/posts`);return &#123; type: FETCH_POSTS, payload: request &#125;;&#125;export function fetchPostsSuccess(posts) &#123; return &#123; type: FETCH_POSTS_SUCCESS, payload: posts &#125;;&#125;... Redux Term: “Reducers”Reducers are functions that take “state” from Redux and “action” JSON object and returns a new “state” to be stored back in Redux. 1. Reducer functions are called by the “Container” containers when there is a user or server action.2. If the reducer changes the state, Redux passes the new state to each component and React re-renders each component 1234The below function takes the current \"postsList\" inside \"...state\" and merges new \"postList\" and creates a **new** state(json), if the action is \"FECTH_POSTS_SUCCESS\"case FETCH_POSTS_SUCCESS: return &#123; …state, postsList: &#123;posts: action.payload, error:null, loading: false&#125; &#125;; STEP 5 — Write Reducers For Each ActionWe have 12 actions, we need to write reducers for each one of them. Please look at the source code for details here. Redux Term: “Presentational” and “Container” ComponentsKeeping React and Redux logic inside each component can make it messy, so Redux recommends creating a dummy presentation only component called “Presentational” component and a parent wrapper component called “Container” component that deals w/ Redux, dispatch “Actions” and more. The parent Container then passes the data to the presentational component, handle events, deal with React on behalf of Presentational component. Legend: Yellow dotted lines = “Presentational” components. Black dotted lines = “Container” components. STEP 6 — Implement Every Presentational ComponentWe have 4 components: PostsList, PostDetails, PostForm and Header. Let’s create presentational components for each one. 6.1 Implement Presentational Component — PostsList Note: You can click on the pictures to zoom and read 6.2 Implement Presentational Component — PostDetails 6.3 Implement Presentational Component — PostForm Note: In the actual code, I am using the awesome redux-form library for form-validation. I’ll blog about it in a different post. 6.4 Implement Presentational Component — Header Note: You can click on the pictures to zoom and read STEP 7 — Create Container Component For Some/All Presentational ComponentWe have 4 components: PostList, PostDetails, PostForm and Header. Let’s create container components for each one. 7.1 Create Container Component — PostsListContainer 7.2 Create Container Component — PostDetailsContainer 7.3 Create Container Component — PostFormContainer 7.4 Create Container Component — HeaderContainer STEP 8 — Finally Bring Them All TogetherBelow code is a simplified version of wiring everything together. Please see source code of the main index.js and reducers.js to get started. 123456789101112131415161718192021222324import React from 'react'; &lt;-- Main React libimport ReactDOM from 'react-dom'; &lt;-- Main React DOM libimport &#123; Provider &#125; from 'react-redux';&lt;-- Injects Redux to compsimport &#123; createStore, applyMiddleware &#125; from 'redux';&lt;- Reduximport &#123; Router, browserHistory &#125; from 'react-router';&lt;- Navigationimport reducers from './reducers'; &lt;- Import reducersimport promise from 'redux-promise';//Configure middleware w/ redux-promise for AJAX requestsconst createStoreWithMiddleware = applyMiddleware( promise)(createStore);const store = createStoreWithMiddleware(reducers);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;- Inject global redux state to comps &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=”/” component=&#123;App&#125;&gt; &lt;- Wrapper for all pages &lt;IndexRoute component=&#123;PostsIndex&#125; /&gt; &lt;-wrapper Index page &lt;Route path=”posts/new” component=&#123;PostsNew&#125; /&gt; &lt;- New page &lt;Route path=”posts/:id” component=&#123;PostsShow&#125; /&gt; &lt;-Details &lt;/Route&gt; &lt;/Router&gt;&lt;/Provider&gt; , document.getElementById('body')); That’s it for now!","categories":[],"tags":[]},{"title":"Làm thế nào để kết hợp NodeJS Back End với ReactJS Front End","slug":"Lam-the-nao-de-ket-hop-NodeJS-Back-End-voi-ReactJS-Front-End","date":"2017-11-04T16:34:28.000Z","updated":"2017-11-04T16:36:30.636Z","comments":true,"path":"2017/11/Lam-the-nao-de-ket-hop-NodeJS-Back-End-voi-ReactJS-Front-End.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Lam-the-nao-de-ket-hop-NodeJS-Back-End-voi-ReactJS-Front-End.html","excerpt":"In this post, I want to show how you can build the front and back end of a website using NodeJS for the back end. We’ll use node to create endpoints, and set up a database in JSON format. Then, we’ll create a front end application using React that will post to the database, and also fetch data from it.","text":"In this post, I want to show how you can build the front and back end of a website using NodeJS for the back end. We’ll use node to create endpoints, and set up a database in JSON format. Then, we’ll create a front end application using React that will post to the database, and also fetch data from it.For this example, I’ll be making a guestbook, where users can submit their names and leave messages. Because users won’t need to log in, or retrieve any data, I won’t need to store anything in a session. Here’s the way this will likely work: Basically, we will have this all one one page, with a form for submitting a message, alongside the actual guestbook. To make this work we’’ll start by creating the endpoints for our POST and GET requests. We’ll set up our database, deploy it, so that we can create a React app, and pull data from the online API. Here’s the order in which I like to do things. You may prefer to work differently. This process makes sense to me, because each step builds on the step before it. During this tutorial, I’ll go through each step in more detail. To see how the finished project could work, here’s a link to my project: http://ethan.jarrell.webdeveloper.surge.sh/GuestBook STEP 1 -Our database collection will contain 2 items: The name of the user The message the user writes If you haven’t already done so, go ahead and install MongoDB, and get it running on port 27017. Then, on the command line, we’ll create the database. We’ll call our database signatures. And the collection, guest_signatures. 12345&gt; Show dbs&gt; Use signaturesswitched to db signatures&gt; show collections&gt; db.createCollection(guest_signatures) Now that we have that set up, we can switch to the text editor, and create the models for the database. STEP 2 -Use the command line to start a new express app. Make the new directory, and then use npm init to create the app. This will automatically create your pkg.JSON file. Since this will be a very basic app, we’ll only need 2 other files in our express app. One for our routes. I like to include all my dependencies in this file as well. Then our second fill will be for our models/schema. We’ll tackle the model file first. It should look something like this: 12345678910111213141516const mongoose = require('mongoose');let Schema = mongoose.Schema;const signatureSchema = new Schema(&#123; guestSignature: &#123; type: mongoose.Schema.Types.Mixed, required: true, &#125;, message: &#123; type: mongoose.Schema.Types.Mixed, required: true, &#125;,&#125;)const Signature = mongoose.model('Signature', signatureSchema);module.exports = Signature; STEP 3 -Before we create our endpoints here, let’s go ahead an list our dependencies at the top of our file. We don’t need too many. 1234567891011//====LIST DEPENDENCIES===//const express = require('express');const parseurl = require('parseurl');const bodyParser = require('body-parser');const path = require('path');const expressValidator = require('express-validator');const mongoose = require('mongoose');const Signature = require('./models/signature.js')const app = express();const url = 'mongodb://localhost:27017/signatures';//=========================// You don’t necessarily need to connect with mongoose, so feel free to use MongoClient, if you prefer that. We’re also using the Signature schema that we just created in the previous step. Now, let’s create our endpoints. We only have one model, and we’re only going to read and write to it for now, so we’re only going to have 2 endpoints. Our root directory “/”, where we’ll redirect to our API Our api, we’ll call “/api/signatures, where we’ll read and write to. At our API endpoint, we’ll have a GET and a POST. We’ll reference our models, using the find() and create() methods for GET and POST respectively. And our response will need to be in JSON format, so that we can easily access the data there from React later on. Here’s how those endpoints might look: 12345678910111213141516171819202122232425262728//====ROOT DIRECTORY===//app.get('/', function(req, res) &#123; res.json('you did it');&#125;);//==========================////====GET ALL SIGNATURES===//app.get('/api/signatures', function(req, res) &#123; Signature.find(&#123;&#125;).then(eachOne =&gt; &#123; res.json(eachOne); &#125;) &#125;)//==========================////====POST NEW SIGNATURE===//app.post('/api/signatures', function(req, res) &#123; Signature.create(&#123; guestSignature: req.body.SignatureOfGuest, message: req.body.MessageofGuest, &#125;).then(signature =&gt; &#123; res.json(signature) &#125;);&#125;);//==========================// The only thing I didn’t really mention was the req.body.SignatureOfGuest and req.body.MessageofGuest. Everything else in this section refers to something we’ve already created, like our database, collections and models. This refers to the name of the field that we’ll use in our React App, Our input will have to use the names SignatureOfGuest and MessageofGuest, so we’ll need to remember that. STEP 4 -Now, we’ll want to connect to our local database from out text editor. If you remember, we had this constant in our list: 1const url = 'mongodb://localhost:27017/signatures'; We’ll write a function using this constant to connect to our local database. 123456789//====MONGOOSE CONNECT===//mongoose.connect(url, function (err, db) &#123; if (err) &#123; console.log('Unable to connect to the mongoDB server. Error:', err); &#125; else &#123; console.log('Connection established to', url); &#125;&#125;);//==========================// In order to make sure everything is working properly, we’ll also need to add an app.listen at the end of our file. At this point, it’s a good idea to pause, and make sure the endpoints and local connection works. You can do that by using Postman to make GET and POST requests. If the endpoints or connections don’t work, you should be able to diagnose the problem here based on the error messages you receive. If everything is working, it should allow you to appropriately read and write to the database. Once everything is working, it’s time to set up our account on Heroku and Mlab. STEP 5-Sign up for a Heroku account here. And create an mLab account here. STEP 6 - After creating your mLab account, click on the Create New button and select a Single node sandbox. There are paid options as well, but the sandbox has plenty of space for getting started. Give your database a name. Since my local database is signatures, I’m using the same name for my mLab database. Now that you have your database created, you can start a new collection from here. You will also need to add a User or Users who can access your database. Without doing this step, and adding yourself as a User with access, authentication will always fail when you try to deploy it. Now your database is running on mLab. When you click on the database, you should see some information at the top, telling you how to integrate the connection. It should look something like this: 1mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;[@ds7](http://twitter.com/ds129024 \"Twitter profile for @ds129024\")9234.mlab.com:9234/signatures The actual url of the database will just have the username and password replaced with your username and password. Now let’s head back to our text editor. We currently have the database running locally at this location: 1const url = 'mongodb://localhost:27017/signatures'; To change it, so that we are connected to mLab, simply update the url variable with the information from mLab. It should look something like this: 1const url = 'mongodb://username:password@ds79234.mlab.com:9234/signatures'; However, you’ll likely be putting this on github, or another public place. You don’t want your mlab username and password in a public sphere where anyone can see it. To fix that, we’ll set an environment variable on the command line, and then update our url variable one more time in the text editor. On the command line, use this command: 1export MONGOLAB_URI=\"mongodb://username:password@ds79234.mlab.com:9234/signatures'; Of course, replacing it with your own username, password, numbers and database name. Now, back in our text editor, we will change our url variable to the following: 1const url = process.env.MONGOLAB_URI; We’ll also want to change our app.listen to reflect the new port. It could look like this: 12app.listen(process.env.PORT || 3000);console.log('starting applicaiton. Good job!'); This way, it will try to run from mongolab, but if it can’t make the connection, it will still listen on port 3000 by default. This will also allow you to run the app locally or from mlab, in case you want to test changes on the local version. The final step in making the connection is deploying your code to your Heroku App. to do this, you can use the following code from the command line: 1heroku config:set MONGOLAB_URI=mongodb://username:password@ds79234.mlab.com:9234/signatures Your app should be successfully deployed on heroku, and you can open it from there now. If you are getting errors, double check to make sure it’s running locally. If so, then it’s probably an error along the way in the connection. In these last two steps, there’s quite a bit of repetitive code. I’m going to outline the high level code here. STEP 7 -Use ‘create-react-app’ from the command line to create a new react app. STEP 8 -Now, we’ll want to create a form, to allow for user input. Here’s how we do that. In a new component, we’ll create a new class. 1class GuestBook extends Component 2. We’ll use a constructor and super method to pass props down. 12constructor(props) &#123; super(props); 3. Use the this keyword to handle the name and message of guest, and bind it to (this). 12this.handleSignatureOfGuest = this.handleSignatureOfGuest.bind(this); this.handleMessageofGuest = this.handleMessageofGuest.bind(this); 4. Set the state of the name and message of guest to an empty string. 1234this.state = &#123; SignatureOfGuest: \"\", MessageofGuest: \"\", &#125;; 5. Listen for an event on the state of both the name and message input. 123456handleSignatureOfGuest(event) &#123; this.setState(&#123; SignatureOfGuest: event.target.value &#125;); &#125; handleMessageofGuest(event) &#123; this.setState(&#123; MessageofGuest: event.target.value &#125;); &#125; 6. Create a function that changes the name and message to the value of the target input. 123456addToGuestBook = event =&gt; &#123; event.preventDefault(); this.setState(&#123; SignatureOfGuest: event.target.value, MessageofGuest: event.target.value,&#125;); 7. I’m now using axios to post the input data to our database, which is on heroku. 12345678910axios.post('&lt;[your-heroku-url here&gt;'](https://ancient-sea-87841.herokuapp.com/api/signatures%27), &#123; SignatureOfGuest: this.state.SignatureOfGuest, MessageofGuest: this.state.MessageofGuest, &#125;) .then(response =&gt; &#123; console.log(response, 'Signature added!'); &#125;) .catch(err =&gt; &#123; console.log(err, 'Signature not added, try again'); &#125;); 8. Then I’m resetting the state of the input to an empty string. 12345this.setState(&#123; SignatureOfGuest: \"\", MessageofGuest: \"\", &#125;);&#125;; 9. Finally, we’ll make a render method, and return our page with the input fields. Inside the input of each field, we’ll give it an onChange, name, and value. the onChange will be set to the.handlemessage or this.handlename, for each field. The name of each field will be set to what we called it in our node app. The value will use state, and we’ll set that to this.state.message, and this.state.name. 1234567891011121314&lt;input onChange=&#123;this.handleSignatureOfGuest&#125; name=\"SignatureOfGuest\" className=\"NameinputForm\" value=&#123;this.state.SignatureOfGuest&#125; placeholder=\"Enter your name\" /&gt; &lt;textarea onChange=&#123;this.handleMessageofGuest&#125; name=\"MessageofGuest\" className=\"MessageinputForm\" value=&#123;this.state.MessageofGuest&#125; placeholder=\"Type a message\" /&gt; 10. Then we’ll add a submit button, where we call the function from earlier. 1234567&lt;button className=\"submitbuttonguestbook\" type=\"submit\" onClick=&#123;this.addToGuestBook&#125; &gt; Submit to Guestbook&lt;i className=\"GuestBookButton2\" aria-hidden=\"true\" /&gt; &lt;/button&gt; STEP 9-Now we’ll make another component where we’ll render the data that’s being stored in our database. Then we can export that component, and put it on our guestbook page. Inside this component we’ll do the following: In a new component, we’ll create a new class. 1class GuestNames extends Component &#123; 2. We’ll use a constructor and super method to pass props down. 12constructor(props) &#123; super(props); 3. Use this.state to set the state of our guestbook messages to an empty string. 123this.state = &#123; messages: \"\", &#125;; 4. Use a componentDidMount lifecycle method 1componentDidMount() &#123; 5. Inside that method we’ll use fetch and the url of our heroku api to fetch the information from the database. 123fetch('&lt;your-heroku-url-goes-here&gt;['](https://ancient-sea-87841.herokuapp.com/api/signatures%27)) .then(results =&gt; &#123; return results.json(); 6. We’ll map over the data, and return the data we want. 12345data.map((msg) =&gt; &#123; return( &lt;div key=&#123;msg.results&#125;&gt; &lt;h3 className=\"h3msg\"&gt;&#123;msg.message&#125;&lt;/h3&gt;&lt;h2 className=\"h2sig\"&gt;-&#123;msg.guestSignature&#125;&lt;/h2&gt; &lt;/div&gt; 7. Now we’ll use this.setState to set the state of the messages to the new state using the data we just fetched. 1this.setState(&#123;messages: messages&#125;); 8. Now we’ll create render mehod. 1render() &#123; 9. Inside the render method, we’ll create JSX elements to render our data inside the component. I’m using this.state.messages inside an &lt;h6&gt; tag. 1234return (&lt;div className=\"guestdataContainer\"&gt; &lt;h6&gt;Guestbook Messages&lt;/h6&gt; &#123;this.state.messages&#125; &lt;/div&gt; 10. Finally, we’ll export the component, so we can use it on other pages. 1export default GuestNames; Again, if you have any questions feel free to reach out. Thanks!","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"nodejs","slug":"nodejs","permalink":"http://nthung2112.github.io/tags/nodejs/"}]},{"title":"Tổng hợp các cheatsheets tốt nhất của Front-end","slug":"Tong-hop-cac-cheatsheets-tot-nhat-cua-Front-end","date":"2017-11-04T16:28:52.000Z","updated":"2017-11-04T16:31:09.386Z","comments":true,"path":"2017/11/Tong-hop-cac-cheatsheets-tot-nhat-cua-Front-end.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Tong-hop-cac-cheatsheets-tot-nhat-cua-Front-end.html","excerpt":"It’s rather impossible to remember all the APIs by heart. This is when cheatsheets jump in! Here are the best front-end cheatsheets I’ve gathered.","text":"It’s rather impossible to remember all the APIs by heart. This is when cheatsheets jump in! Here are the best front-end cheatsheets I’ve gathered. Javascript ES2015 featureshttps://devhints.io/es6 Javascripthttp://overapi.com/javascript Javascript Regular expressionhttps://www.debuggex.com/cheatsheet/regex/javascript Reacthttps://devhints.io/react Reduxhttps://github.com/linkmesrl/react-journey-2016/blob/master/resources/egghead-redux-cheat-sheet-3-2-1.pdf Vuejshttps://vuejs-tips.github.io/cheatsheet/ Vuexhttps://vuejs-tips.github.io/vuex-cheatsheet/ Angular 4https://angular.io/guide/cheatsheet Flexboxhttps://yoksel.github.io/flex-cheatsheet/ SCSShttps://devhints.io/sass Stylushttps://devhints.io/stylus GraphQLhttps://raw.githubusercontent.com/sogko/graphql-shorthand-notation-cheat-sheet/master/graphql-shorthand-notation-cheat-sheet.png","categories":[],"tags":[{"name":"front-end","slug":"front-end","permalink":"http://nthung2112.github.io/tags/front-end/"}]},{"title":"Đi ăn và hiểu những điều cơ bản của Express.js","slug":"Di-an-va-hieu-nhung-dieu-co-ban-cua-Express-js","date":"2017-11-04T16:25:21.000Z","updated":"2017-11-04T16:33:58.328Z","comments":true,"path":"2017/11/Di-an-va-hieu-nhung-dieu-co-ban-cua-Express-js.html","link":"","permalink":"http://nthung2112.github.io/2017/11/Di-an-va-hieu-nhung-dieu-co-ban-cua-Express-js.html","excerpt":"If you have ever visited a sit-down restaurant, then you can understand the basics of Express. But if you are just starting to build your first Node.js back end…you might be in for a bumpy ride. Yes — it is certainly easier to learn Node if you have past experience with JavaScript. But the challenges you will face while building a back end are completely different than the ones you face while using JavaScript on the front end. When I learned Node, I chose the hard way. I studied eBooks, written tutorials, and videos over and over until I finally understood why I was doing what I was doing. There is an easier way. I am going to use a restaurant analogy to explain four key parts of your first Express app. Express.js is a popular framework for organizing your code, and I would recommend it for any beginner. I’ll explain further in a moment.","text":"If you have ever visited a sit-down restaurant, then you can understand the basics of Express. But if you are just starting to build your first Node.js back end…you might be in for a bumpy ride. Yes — it is certainly easier to learn Node if you have past experience with JavaScript. But the challenges you will face while building a back end are completely different than the ones you face while using JavaScript on the front end. When I learned Node, I chose the hard way. I studied eBooks, written tutorials, and videos over and over until I finally understood why I was doing what I was doing. There is an easier way. I am going to use a restaurant analogy to explain four key parts of your first Express app. Express.js is a popular framework for organizing your code, and I would recommend it for any beginner. I’ll explain further in a moment.Here are the four key parts we will cover: The require statements Middleware Routing App.listen()/ Starting the server In this analogy, you are a restaurant owner looking to hire a general manager — the person who creates all the processes and manages the place so that it runs smoothly and customers leave happy. Here is a preview of what is next: By the end, you will understand the functionality of every part of a basic Express app. Step 1: hiring the manager (require statements)In this example, you are the restaurant owner. And you need to hire an expert to run the day-to-day operations of your new restaurant. You certainly aren’t an expert, and you can’t leave it to the waitstaff and kitchen to figure out. If you want to run an efficient and safe restaurant, you need someone to keep your staff working at maximum efficiency. Express is the new manager. The first part is pretty straightforward. Like with any other NPM package, you need to npm install the express module and then use a require statement to load the module. Unlike many other NPM packages, you also need to use this line: 1const app = express(); This is because you need a variable to hold your new Express application. Express is not a default part of Node. Step 2: making decisions at the restaurant (middleware)Let’s take a step back here. What are some common routines that happen at restaurants? There are three that immediately jump into my head: Seating new customers Taking food orders Presenting the check at the end of the meal For each one, there are a series of checks that you need to run before you can execute the action. For example, before you seat customers you need to know: Are they wearing a shirt and shoes (and pants)? Otherwise, they cannot be seated. If they want to sit at the bar, are they 21 years old (if you are in the United States)? This ain’t a beach bar! Similarly, in your code, you will need to validate that requests have certain criteria before they can continue. For example, if a person tries to log in to your site: Do they have an account? Did they enter the correct password? This is where the concept of middleware comes in. Middleware functions allow you to take action on any incoming request and modify it before sending back a response. In your restaurant, you need a series of rules to decide if you should seat incoming people or not. Let’s say a couple walks through your door. You have one rule before giving them a table: are they wearing a shirt and shoes? First, you start with app.use(). This means that these are simply rules that need to be applied for the routes coming up next. They are not a GET, POST, PUT or DELETE. In line 4, you have an anonymous function with the parameters req, res and next. For the purposes of this code block, you are just inspecting the request (req) to see if it has shirt and shoes. You also need to use the next() function at the end because you are simply validating clothing here. Later, in the routes, you will allow the guests to get an actual table. In lines 5 and 6, you check if they have a shirt and shoes. And in lines 7–9, you only proceed if they have both. The code block above is missing one important thing: A path. This is the specific string included with the request. And since it is missing a path, it will run on every single request. Can you imagine? When customers entered the restaurant… ordered food… asked for the check… employees would be forced to look up and down at them to make sure they were clothed! That is a quick way to go out of business. So, we change line 4 in the example above. Now, we will only run this code when a user requests along the ‘/table’ route. The full explanation: Step 3: executing common routines (routing)Let’s continue with the seating example. So far, we only know how to validate whether someone should be seated or not. But we do not actually know how to lead them to a table and sit them down. This is where routes come in. Routes allow us to script specific actions based on the path. The options are GET, POST, PUT and DELETE, but we will focus on GET and POST for now. In the context of a restaurant, we need to create a GET request in order to choose a specific table and seat the guests. GETs do not modify or add to your database. They just retrieve information based on specific parameters. In this case, let’s say that you need to create a procedure to seat a party of two. The number 2 came from the customer request. Okay, before I explain: Yes, this is only sending a message at the end. It has not actually found a specific table to seat the customer yet. I would need to search an array for an open table, have more of a back story…that is outside of the scope of this tutorial. In line 12, we define the procedure for finding a table when a guest requests along the ‘/table’ route. Just like the middleware example above, we have request and response parameters available. It also has a parameter, amount. This is two, in this example. In fact, everything after the function declaration in line 12 is technically middleware since it modifies a user request. You will see in the diagram at the end. In line 13, we access the number of people in the party from the parameters of the request object. That is not declared anywhere since the request came from the user, and we do not have any front-end code. So here is what the request might look like if this was a real app: 12345req = &#123; params: &#123; amount: 2; &#125;&#125; In line 13, our party variable accesses the amount property of the params object within the request. Finally in line 14, we send a response back to the customer: we are looking for the appropriately sized table. That is a lot at once. Here is a diagram: Step 3.5: making your restaurant efficient (router)Now you can trace the full path from request to response. But as your app grows in size, you will not want to code the rules for each route individually. You will find that some routes share the same rules, so you need to find a way to apply one set of rules to multiple routes. In terms of seating, you can either seat your customers at the bar or at a table. Those have rules in common like shirt + shoes, but seating at the bar requires every member of the party to be 21. And, in terms of serving customers, you will need to use a slightly different procedure for serving the appetizer, main course, and dinner. But, those three routes have plenty in common as well. This is where the router comes in. The router lets you group your routes so that you can create common rules. We need to create middleware to cover each of these cases. I will just cover the seating cases for now since it will overwrite the code above. Here is the full code snippet: I am going to cover each part individually. In line 4, we declare our router. In lines 6 and 14, we now have seatingRouter.use() in place of app.use() to indicate that this middleware is only related to seatingRouter routes. Finally, in line 21, we add more middleware to show that every seatingRouter route begins with ‘/seating’. So, if someone requested a seat at the bar, the full path would be ‘/seating/bar.’ This may feel a little out of order, since you might expect the path to be defined when you create the router in line 4. That is normal! Here is that in diagram form: And, when you add a GET route, it goes above the last statement where you assign routes to the router. Step 4: opening for business (ports)Okay, last part. So far, you have hired a manager, defined what to do before accepting customer requests, and determined what to do with specific customer requests once they come in. Now, you just need to determine the address for the location where all this will happen. Your server has ports that are kind of like the address for the restaurant itself.Since your server can handle many types of restaurants (or server-side scripts) at once, you need to tell it where each script should run. In the example above, the port is 3000 and it is located on your computer. So if you type: 1[https://localhost:3000/](https://localhost:3000/) into your browser, and you are running your Node app, the server knows to run the specific script. In this case, as soon as you enter the URL, you will log the message in the console and be able to use any of your routes. If the restaurant itself is your entire app, then it is now open for business at the address 3000.","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://nthung2112.github.io/tags/nodejs/"},{"name":"expressjs","slug":"expressjs","permalink":"http://nthung2112.github.io/tags/expressjs/"}]},{"title":"Các nguyên tắc cơ bản của Redux","slug":"Cac-nguyen-tac-co-ban-cua-Redux","date":"2017-10-10T15:41:15.000Z","updated":"2017-10-10T15:48:47.120Z","comments":true,"path":"2017/10/Cac-nguyen-tac-co-ban-cua-Redux.html","link":"","permalink":"http://nthung2112.github.io/2017/10/Cac-nguyen-tac-co-ban-cua-Redux.html","excerpt":"Redux là gì và tại sao phải cần nó trong React/React Native Ngoài Redux ra thì còn cái nào để quản lý state nữa không? 3 Nguyên tắc của Redux Nguyên tắc 1: Store ( Single Source of Truth ) Nguyên tắc 2: Action ( State is Read-Only ) Nguyên tắc 3: Reducer ( Changes are made with Pure Functions ) Tóm tắt cách hoạt động: Bức tranh tổng quát của Redux Cách học Redux Chia sẻ cách học Redux: Một số resources hay","text":"Redux là gì và tại sao phải cần nó trong React/React Native Ngoài Redux ra thì còn cái nào để quản lý state nữa không? 3 Nguyên tắc của Redux Nguyên tắc 1: Store ( Single Source of Truth ) Nguyên tắc 2: Action ( State is Read-Only ) Nguyên tắc 3: Reducer ( Changes are made with Pure Functions ) Tóm tắt cách hoạt động: Bức tranh tổng quát của Redux Cách học Redux Chia sẻ cách học Redux: Một số resources hay Redux là gì và tại sao phải cần nó trong React/React NativeTóm tắt React: Nguyên tắc một app React là dựa vào component. Mỗi component có state và props. Nếu state của một component thay đổi thì nó sẽ được render lại. Props để truyền data từ component cha sang component con Vấn đề là khi ta muốn truyền props từ 2 component không phải cha-con thì sẽ xảy ra vấn đề Ví dụ sau, một app nhỏ chỉ có Main -&gt; Parent -&gt; Child như sau thì truyền props đơn giản Nhưng với app phức tạp hơn một tý, khi muốn truyền props giữa 2 component không phải cha-con thì rất phức tạp: Đó là lý do tại sao nên dùng Redux: Tóm lại cần một cơ chế để quản lý state trong React/React Native. Không phải cứ React/React Native là phải dùng Redux. Cũng không phải Redux chỉ được dùng trong React/React Native Ngoài Redux ra thì còn cái nào để quản lý state nữa không?Thực ra Redux dựa theo ý tưởng của Flux. Ngoài Redux ra bạn có thể dùng: Mobx ( Cài này phổ biến chỉ sau Redux ) Jumpsuit ( đặt tên ngáo thật ) Nhưng lập trình React Native thì nên dùng Redux với Mobx. 3 Nguyên tắc của ReduxĐáng lẽ ra mình sẽ viết bài “Tại sao cần Redux và cách dùng”. Nhưng để hiểu được tại sao và cách dùng thì nên hiểu nguyên tắc chính của nó, từ đó khi học chúng ta sẽ để ý những nguyên tắc này mà học theo. Nơron thần kinh trong não mới bắt đầu liên kết lại. Cũng giống như bạn học lập trình hướng đối tượng sẽ có 4 nguyên tắc: trừu tượng, đóng gói, kế thừa, đa hình vậy. Từ đó mới học class , object, properties, method, access modifier, khởi tạo, kế thừa, interface, vv Nguyên tắc này từ đâu? Đương nhiên từ nhóm tạo ra nó rồi, một trong đó là Dan Abramov Nguyên tắc 1: Store (Single Source of Truth)Chỉ có một cây object trong một ứng dụng, và người ta đặt nó là store.Ví dụ mình có viết một ứng dụng tìm việc làm đơn giản: Thì sẽ được một store như sau: auth: dùng để quản lý đăng nhập jobs: danh sách job tải từ web service likedJobs: danh sách job đã thích Nguyên tắc 2: Action (State is Read-Only)Không update store trực tiếp được, muốn thay đổi cái store thì phải truyền action vào. Mà action nghe cao siêu vậy thôi, chứ nó chỉ là một object trong Javascript. Quy định duy nhất của của object này là phải có type. ( type thường là chuỗi string )Ví dụ action đăng nhập Facebook thành công: Ví dụ action thích một công việc nào đó: Nguyên tắc 3: Reducer (Changes are made with Pure Functions)Sẽ có một cái hàm nhận cái action ở trên, rồi trả về state mới. Mà hàm này phải là pure function. Mà pure function là sao? Cái pure function này viết cả bài cũng được. Nhưng đại ý chính là pure function không gây side effects như: thay đổi giá trị tham số, không gọi web service hay database trong hàm này. Tóm tắt cách hoạt động:Khi người dùng nhấn like một job ( nhấn button like ) -&gt; tạo action: Sau đó Reducer là một cái hàm, nó trả về state mới Sau đó ở component nào muốn xài thì liên hệ store để truy cập dữ liệu trong store. Bức tranh tổng quát của ReduxHình này mới mô tả một chiều của dữ liệu: giữa action, reducer và store Đây mới là hình đầy đủ: Cách học ReduxĐương nhiên còn có nhiều phần chi tiết bên trong mình chưa đề cập đến như: Action Creator: dùng để tạo action, thao tác logic. Chúng cũng là những hàm bình thường nhưng sẽ trả về là action thôi chứ không có gì gê gớm. createStore: tạo store applyMiddleware: thành phần trung gian như lưu store offline ( local storage ), async action như tải data trên web service, vv connect, mapStateToProps: kết nối store với component, để component có thể xài được state trong store. Chia sẻ cách học Redux: Xem video hướng dẫn từ chính anh tạo ra Redux:https://egghead.io/courses/getting-started-with-redux Lên youtube xem cách dùng redux trong một ứng dụng React/React Native để hiểu được những phần còn thiếu ở trên cũng như cách tổ chức code trong ứng dụng. Đọc document của Redux từ đầu đến cuối, trong này có hướng dẫn code app To Do List:http://redux.js.org/docs/introduction/ Muốn master thì viết lại các hàm, các middleware như connect, applyMiddleware. Mà muốn làm được thì cũng phải master React tại phải dùng Higher-Order Components Một số resources hayThe Complete React Native and Redux Course Advanced React and Redux Hình chôm từ: https://www.udemy.com/full-stack-universal-react-with-redux-express-and-mongodb/ https://www.theodo.fr/blog/2016/03/getting-started-with-react-redux-and-immutable-a-test-driven-tutorial-part-2/","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://nthung2112.github.io/tags/redux/"}]},{"title":"Kiến trúc tổng quan của Angular 2/4 - P2","slug":"Kien-truc-tong-quan-cua-Angular-2-4-P2","date":"2017-10-01T09:02:02.000Z","updated":"2017-10-01T10:01:15.067Z","comments":true,"path":"2017/10/Kien-truc-tong-quan-cua-Angular-2-4-P2.html","link":"","permalink":"http://nthung2112.github.io/2017/10/Kien-truc-tong-quan-cua-Angular-2-4-P2.html","excerpt":"Data bindingHãy tưởng tượng rằng, bạn đang phải code 1 ứng dụng web mà việc tương tác, thay đổi giá trị trên DOM diễn ra liên tục. Sẽ thực sự là 1 cơn ác mộng nếu bạn phải tự tay thực hiện toàn bộ các thao tác update, create value trên các HTML DOM khi có hành động của người dùng mà không sử dụng 1 framework nào khác ngoài mấy thư viện kiểu jQuery :-s Với Angular, chúng ta có 1 thuật ngữ là data binding, một cơ chế phối hợp nhịp nhàng các thành phần của template với component. Việc này rất đơn giản, chúng ta chỉ cần thêm binding markup vào HTML là Angular tự hiểu và connect chúng tới Component. Như diagram bên dưới, có 4 kiểu data binding syntax. Mỗi kiểu đều có chiều dữ liệu từ DOM tới COMPONENT, từ COMPONENT tới DOM, và có cả kiểu có 2 chiều dữ liệu.","text":"Data bindingHãy tưởng tượng rằng, bạn đang phải code 1 ứng dụng web mà việc tương tác, thay đổi giá trị trên DOM diễn ra liên tục. Sẽ thực sự là 1 cơn ác mộng nếu bạn phải tự tay thực hiện toàn bộ các thao tác update, create value trên các HTML DOM khi có hành động của người dùng mà không sử dụng 1 framework nào khác ngoài mấy thư viện kiểu jQuery :-s Với Angular, chúng ta có 1 thuật ngữ là data binding, một cơ chế phối hợp nhịp nhàng các thành phần của template với component. Việc này rất đơn giản, chúng ta chỉ cần thêm binding markup vào HTML là Angular tự hiểu và connect chúng tới Component. Như diagram bên dưới, có 4 kiểu data binding syntax. Mỗi kiểu đều có chiều dữ liệu từ DOM tới COMPONENT, từ COMPONENT tới DOM, và có cả kiểu có 2 chiều dữ liệu. Ở ví dụ HeroListComponent, template có 3 kiểu: app/hero-list.component.html (binding) 123&lt;li&gt;&#123;&#123;hero.name&#125;&#125;&lt;/li&gt;&lt;hero-detail [hero]=\"selectedHero\"&gt;&lt;/hero-detail&gt;&lt;li (click)=\"selectHero(hero)\"&gt;&lt;/li&gt; Markup có chức năng hiển thị giá trị của component’s hero.name property với thẻ . Markup [hero] property binding truyền giá trị của selectedHero từ parent HeroListComponent tới các hero property của HeroDetailComponent. (click) event binding gọi phương thức selectHero khi user click vào hero’s name. Kiểu quan trọng thứ 4, được gọi là Two-way data binding. Chỉ với 1 markup notation đơn giản sử dụng ngModel directive, ta có thể kết hợp việc binding event và property. app/hero-detail.component.html (ngModel) 1&lt;input [(ngModel)]=\"hero.name\"&gt; Angular xử lý toàn bộ data bindings trên mỗi JavaScript event, xuất phát từ gốc của cây application component duyệt tới toàn bộ components lá. Data binding đóng một vai trò quan trọng trong việc giao tiếp giữa template và component. Data binding còn là công cụ giao tiếp giữa parent và child components. DirectivesAngular templates là dynamic. Khi ứng dụng Angular thực hiện render template, chúng transforms DOM theo các lệnh nhận được từ directives. Một directive là một class bắt đầu với @Directive decorator. Có thể coi một component là một directive-với-một-template; @Component decorator thực chất là một @Directive decorator kế thừa từ template-oriented features. While a component is technically a directive, components are so distinctive and central to Angular applications that this architectural overview separates components from directives. Câu trích dẫn trên cho chúng ta lý do tại sao chúng ta lại tách Component ra khỏi Directive trong kiến trúc Angular. Có 2 loại directives: structural và attribute directives. Chúng xuất hiện giữa element tag như 1 thuộc tính (attributes). Structural directives tùy chỉnh layout bằng cách thêm mới, xóa bỏ và thay thế elements trong DOM. Ví dụ dưới đây sử dụng 2 loại built-in structural directives: app/hero-list.component.html (structural) 12&lt;li *ngFor=\"let hero of heroes\"&gt;&lt;/li&gt;&lt;hero-detail *ngIf=\"selectedHero\"&gt;&lt;/hero-detail&gt; *ngFor giúp liệt kê các hero từ mảng heroes trong mỗi thẻ &lt;li&gt; *ngIf include HeroDetail component nếu có một hero được select. Attribute directives thay thế appearance hoặc behavior của các element. Bên trong templates, chúng chẳng có gì khác các HTML attributes thông thường, ngoại trừ tên :)) ngModel directive, implements two-way data binding, là một ví dụ của attribute directive. ngModel thay đổi behavior của element (Ví dụ tiêu biểu là các &lt;input&gt;) bằng cách thiết lập value property hiển thị ra cũng như thay đổi chúng theo events. app/hero-detail.component.html (ngModel) 1&lt;input [(ngModel)]=\"hero.name\"&gt; Ngoài ra, chúng ta còn nhiều directives có thể chỉnh sửa cấu trúc layout (ngSwitch) hoặc thay đổi DOM elements và components (ngStyle và ngClass). Dĩ nhiên, bạn cũng có thể tự viết một directives. Components như HeroListComponent chính là một loại custom directive. Services Service có thể là bấy kỳ giá trị, hàm, class,… tính năng nào cần thiết cho ứng dụng của bạn hoạt động. Hầu hết mọi thứ đề có thể trở thành service (lol). Một service điển hình là một class được thu hẹp lại trong một mục đích rõ ràng. Ví dụ: logging service data service message bus tax calculator application configuration Không có một chút đặc trưng của Angular về services. Angular cũng không có bất kỳ định nghĩa nào về service. No service base class, and no place to register a service. Tuy nhiên services lại là nền tảng của bất kỳ ứng dụng Angular nào. Components cũng là một services. Dưới đây là một service class có nhiệm vụ logs lên browser console: app/logger.service.ts (class) 12345export class Logger &#123; log(msg: any) &#123; console.log(msg); &#125; error(msg: any) &#123; console.error(msg); &#125; warn(msg: any) &#123; console.warn(msg); &#125;&#125; Còn đây là HeroService có nhiệm vụ lấy về mảng các heroes và trả về chúng cùng với resolved Promise. HeroService phụ thuộc vào Logger service và BackendService khác nắm giữ việc communication với server. app/hero.service.ts (class) 12345678910111213141516export class HeroService &#123; private heroes: Hero[] = []; constructor( private backend: BackendService, private logger: Logger) &#123; &#125; ) getHeroes() &#123; this.backend.getAll(Hero).then( (heroes: Hero[]) =&gt; &#123; this.logger.log(`Fetched $&#123;heroes.length&#125; heroes.`); this.heroes.push(...heroes); // fill cache &#125;); return this.heroes; &#125;&#125; Services are everywhere. Component classes như một miếng thịt nạc không có mỡ =)) . Không có bất kì đoạn code nào fetch data từ server, validate user input, hoặc log lên console. Tất các các tasks đó được giao cho services. Công việc của một component lúc này không hơn việc cho phép người sử dụng trải nghiệm dịch vụ. Đứng giữa view (rendered bởi template) và tầng application logic. Khi code Angular, không ai ép bạn làm theo parttern này, cũng không quy định nguyên tắc gì về service, tuy nhiên chắc hẳn mọi người sẽ không phàn nàn nếu bạn hoàn thành 1 component với hơn 3000 lines code =)) Angular giúp ta thực hiện các nguyên tác này dễ dàng hơn bằng cách support Dependency injection. Dependency injection Dependency injection là một cách cung cấp các new instance của một class cùng với các dependencies phụ thuộc mà nó cần. Hầu hết các dependencies là services. Angular sử dụng dependency injection để chuẩn bị một new component cùng với các services mà nó cần.@Việc khai báo các services cần thiết cho một component cũng với kiểu dữ liệu của nó được thực hiện trong chính constructor parameters. Ví dụ về constructor của HeroListComponent và HeroService ở đây chính là một dependency : app/hero-list.component.ts (constructor) 1constructor(private service: HeroService) &#123; &#125; Khi Angular khởi tạo một component, nó sẽ hỏi injector về các services mà component cần. Một injector lưu giữ container các service instances đã được tạo trước đó. Nếu có một yêu cầu về service instance không có trong container, injector sẽ tạo và thêm mới nó rồi add nó vào container trước khi trả lại service cho Angular. Khi tất cả các request services được giải quyết (resolved) và được hoàn thành (returned), Angular có thể gọi các component’s constructor cùng với các tham số là các services. Đó chính là dependency injection. Quá trình injection của HeroService có thể trông giống sơ đồ sau: Nếu injector không có HeroService, Vậy làm thể nào để Angular biết nơi cần lấy và tạo ra nó Như đã mô tả trước đó, bạn cần phải đăng ký (registered) HeroService với provider của HeroComponent cùng injector. Một provider có thể create và return một service. Bạn có thể register providers trong modules hoặc trong components. Thông thường, chúng ta add providers vào root module, ez, ta có instance của service tồn tại ở mọi nơi (ngon). app/app.module.ts (module providers) 12345providers: [ BackendService, HeroService, Logger], Một cách khác, ta có thể register ở level component trong providers property của @Component metadata: app/hero-list.component.ts (component providers) 123456@Component(&#123; moduleId: module.id, selector: 'hero-list', templateUrl: 'hero-list.component.html', providers: [ HeroService ]&#125;) Registering ở level component nghĩa là bạn có thể lấy ra các new instance của service với mỗi một new instance của component đó. Các điểm cần nhớ về dependency injection: Dependency injection được móc vào Angular framework và có thể sử dụng ở mọi nơi. Injector có 2 cơ chế chính. Injector duy trì một container các service instances mà chúng đã tạo ra. Injector có thể tạo mới service instance từ provider. Provider là nơi khai báo cách tạo ra service. Register providers với injectors. THE ENDTham khảohttps://angular.io/docs/ts/latest/guide/architecture.html","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://nthung2112.github.io/tags/angular/"},{"name":"architecture","slug":"architecture","permalink":"http://nthung2112.github.io/tags/architecture/"}]},{"title":"Kiến trúc tổng quan của Angular 2/4  - P1","slug":"Kien-truc-tong-quan-cua-Angular-2-4-P1","date":"2017-10-01T08:43:49.000Z","updated":"2017-10-01T09:59:54.207Z","comments":true,"path":"2017/10/Kien-truc-tong-quan-cua-Angular-2-4-P1.html","link":"","permalink":"http://nthung2112.github.io/2017/10/Kien-truc-tong-quan-cua-Angular-2-4-P1.html","excerpt":"Đôi điều về Angular 2 Hiểu đơn giản là một framework để giúp lập trình viên xây dựng các ứng dụng client với HTML và JavaScript/Typescript … Việc render HTML templates sẽ được thực hiện bởi Angularized-markup, việc cần làm của một developer là viết các component để quản lý template, thêm mới các xử lý logic bên trong các service, đóng gói component và service thành một module. Một ứng dụng Angular2 được chạy dựa trên việc bootstrapping root module vào Angular’s bootstrapper.","text":"Đôi điều về Angular 2 Hiểu đơn giản là một framework để giúp lập trình viên xây dựng các ứng dụng client với HTML và JavaScript/Typescript … Việc render HTML templates sẽ được thực hiện bởi Angularized-markup, việc cần làm của một developer là viết các component để quản lý template, thêm mới các xử lý logic bên trong các service, đóng gói component và service thành một module. Một ứng dụng Angular2 được chạy dựa trên việc bootstrapping root module vào Angular’s bootstrapper. Dựa vào sơ đồ kiến trúc trên ta có thể liệt kê ra 8 thành phần chính tạo ra một ứng dụng Angular 2: Module Component Template Metadata Data Binding Service Directive Dependency Injection ModulesAngular apps sử dụng hệ thống module, hay còn gọi là Angular modules hoặc NgModules.Trong bài viết này chủ yếu là giới thiệu các modules; Để tìm hiểu sâu hơn xin vui lòng tham khảo Angular modules.Mỗi ứng dụng Angular đều phải có ít nhất một Angular module class, là root module, hay còn được đặt tên theo quy ước là AppModule. Trong các ứng dụng nhỏ, đôi khi chỉ có duy nhất 1 module chính là root module , tuy nhiên ở hầu hết các ứng dụng, còn có thêm nhiều feature modules.Dù là root hay là feature module, thì mỗi class đều có @NgModule decorator. Decorators là design pattern thường được dùng để thay đổi hành vi, chức năng của JavaScript classes. Angular cung cấp sẵn nhiều decorators gắn các metadata vào các classes để dễ dàng biết được ý nghĩa và cách thức hoạt động. NgModule là một decorator function (single metadata object) có các thuộc tính mô tả các module. Các thuộc tính quan trọng là: declarations - Khai báo các View classes thuộc về module. Angular có 3 loại view classes: components, directives, pipes. exports - Một tập con của declarations khả dụng trong component templates của các module khác. imports - Các module khác được exported các classes cần thiết bởi component templates được declarations bên trong module này. providers - Tạo ra các global collection of services có thể truy cập ở mọi ngõ ngách của ứng dụng. bootstrap - Main application view, hay còn được gọi là root component, chứa tất cả các app views. Duy nhất root module có thuộc tính bootstrap. Dưới đây là một root module đơn giản: app/app.module.ts 12345678910import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';@NgModule(&#123; imports: [ BrowserModule ], providers: [ Logger ], declarations: [ AppComponent ], exports: [ AppComponent ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; Trong trường hợp này, thuộc tính export của AppComponent chỉ đơn giản mô tả cách export; nó thì không cần thiết trong thực tế. Một root module không có lý do gì để export bất cứ điều gì, đơn giản là các component khác ko cần thiết phải import root module. Khởi chạy ứng dụng bằng cách bootstrapping root module. Trong quá trình development, chúng ta sẽ bootstrap AppModule trong file main.ts. app/main.ts 1234import &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; AppModule &#125; from './app.module';platformBrowserDynamic().bootstrapModule(AppModule); Angular modules vs. JavaScript modulesAngular Module: Class decorator với @NgModule — đây là 1 một tính tăng cơ bản Angular. Javascript Module: JavaScript cũng có một hệ thống module để quản lý các JavaScript objects. Nó hoàn toàn khác biệt và không liên quan tới Angular module system. Trong JavaScript mỗi file là một module và tất cả các đối tượng được định nghĩa trong file đều thuộc về module đó. Các module khai báo đối tượng public bằng cách sử dụng từ khóa export. Các module JavaScript khác sử dụng từ khóa import để truy cập vào đối tượng public từ các module khác. 12import &#123; NgModule &#125; from '@angular/core';import &#123; AppComponent &#125; from './app.component'; 1export class AppModule &#123; &#125; Tìm hiểu thêm về Javascript Module. Angular libraries Angular được ví như 1 con tàu chuyên chở các JavaScript modules. Cũng có thể ví là các library modules. Mỗi Angular library name đều bắt đầu với tiền tố @angular.Bạn cài đặt chúng với npm package manager và import các phần lại bằng câu lệnh JavaScript import. Lấy ví dụ, import Angular’s Component decorator từ @angular/core library như sau: 1import &#123; Component &#125; from '@angular/core'; Bạn cũng có thể import Angular modules từ Angular libraries sử dụng câu lệnh JavaScript import: 1import &#123; BrowserModule &#125; from '@angular/platform-browser'; Trong ví dụ về root module bên trên, application module cần BrowserModule. Để truy cập tới BrowserModule, ta thêm vào @NgModule metadata imports: 1imports: [ BrowserModule ], Theo cách này, ta đang sử dụng cả Angular and JavaScript module systems cùng nhau. ComponentsMột component điều khiển từng chức năng trên màn hình view.Ví dụ, view sau được điều khiển bởi các components: The app root với navigation links. The list of heroes. The hero editor. Chúng ta cần định nghĩa component’s application logic—những gì sẽ support trên view—bên trong một class. Class sẽ tương tác với view thông qua API của các properties và methods. Ví dụ, HeroListComponent có một heroes property trả về 1 mảng các heroes lấy từ service. HeroListComponent cũng có sẵn phương thức selectHero() để get các thuộc tính của selectedHero khi người dùng chọn user từ danh sách. app/hero-list.component.ts (class) 123456789101112export class HeroListComponent implements OnInit &#123; heroes: Hero[]; selectedHero: Hero; constructor(private service: HeroService) &#123; &#125; ngOnInit() &#123; this.heroes = this.service.getHeroes(); &#125; selectHero(hero: Hero) &#123; this.selectedHero = hero; &#125;&#125; Angular creates, updates, và destroys components cùng với user di chuyển xuyên suốt trong application. App có thể lấy các action ở từng thời điểm tron lifecycle thông qua lifecycle hooks, như ngOnInit() được khai báo bên trên. TemplatesChúng ta định nghĩa component’s view với template của nó. Một template là mã code HTML giúp Angular render component. Một template có thể có đôi chút khác biệt với HTML thông thường, đây là 1 ví dụ cho template của HeroListComponent: app/hero-list.component.html 12345678&lt;h2&gt;Hero List&lt;/h2&gt;&lt;p&gt;&lt;i&gt;Pick a hero from the list&lt;/i&gt;&lt;/p&gt;&lt;ul&gt; &lt;li *ngFor=\"let hero of heroes\" (click)=\"selectHero(hero)\"&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;hero-detail *ngIf=\"selectedHero\" [hero]=\"selectedHero\"&gt;&lt;/hero-detail&gt; Mặc dù template này sử dụng các thành phần cơ bản HTML như &lt;h2&gt; và &lt;p&gt;, nhưng cũng có đôi chút khác biệt như *ngFor, , (click), [hero], và &lt;hero-detail&gt; sử dụng Angular’s template syntax. Trên dòng cuối cùng của template, &lt;hero-detail&gt; tag là custom element thể hiện cho new component, HeroDetailComponent. HeroDetailComponent là một component khác với HeroListComponent chúng ta đang xem. HeroDetailComponent mô tả chi tiết từng hero, mà người dùng đã select từ HeroListComponent. HeroDetailComponent là con (child) của HeroListComponent. Element có thể được code thoải mái giữa native HTML elements MetadataMetadata giúp Angular biết cách xử lý các class. Quay trở lại code HeroListComponent bên trên, ta thấy rằng đó chỉ đơn giản là 1 class, ko có dấu ấn gì của 1 framework cả, no “Angular” omg Thực tế, HeroListComponent thực chất chỉ là 1 class. Nó không phải là 1 component cho tới khi ta khai báo nó với Angular. Để khai báo với Angular rằng HeroListComponent là 1 component, ta sẽ gắn thẻ metadata vào class này. Trong TypeScript, việc gắn thẻ metadata sử dụng decorator. Dưới đây là metadata cho HeroListComponent: app/hero-list.component.ts (metadata) 123456789@Component(&#123; moduleId: module.id, selector: 'hero-list', templateUrl: 'hero-list.component.html', providers: [ HeroService ]&#125;)export class HeroListComponent implements OnInit &#123;/* . . . */&#125; Decorator ở đây chính là @Component, định nghĩa class ngay bên dưới như một component class. @Component decorator khởi tạo một object với các thông tin mà Angular cần thể tạo và biểu diễn một component &amp; view. Dưới đây là một số option cấu hình cho @Component: moduleId: Tập hợp các source dựa trên address (module.id) với module-relative URLs như templateUrl. selector: CSS selector ra lệnh cho Angular create và insert một thể hiện component khi nó tìm thấy tag trong parent HTML. Ví dụ, nếu một app’s HTML có chứa , thì Angular sẽ inserts một instance của HeroListComponent view giữa các tags. templateUrl: module-relative address của component’s HTML template. providers: Mảng các dependency injection providers cho services cần thiết để component hoạt động. Đây là 1 cách khai báo với Angular rằng, component’s constructo yêu cầu 1 HeroService để nó có thể thu được danh sách các heroes phục vụ việc hiển thị lên màn hình. Metadata trong @Component giúp Angular biết cách lấy những thành phần chính tạo nên component.Template, Metadata, và Component được sử dụng cùng với nhau với mục đích tạo nên View.Ngoài @Component, chúng ta còn có @Injectable, @Input, và @Output là những decorators rất hay được sử dụng. Tham khảohttps://angular.io/docs/ts/latest/guide/architecture.html","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://nthung2112.github.io/tags/angular/"},{"name":"architecture","slug":"architecture","permalink":"http://nthung2112.github.io/tags/architecture/"}]},{"title":"Các kỹ thuật SEO tối thiểu mà developer cần nắm vững trong lập trình web","slug":"Cac-ky-thuat-SEO-toi-thieu-ma-developer-can-nam-vung-trong-lap-trinh-web","date":"2017-10-01T08:28:15.000Z","updated":"2017-10-01T08:40:38.907Z","comments":true,"path":"2017/10/Cac-ky-thuat-SEO-toi-thieu-ma-developer-can-nam-vung-trong-lap-trinh-web.html","link":"","permalink":"http://nthung2112.github.io/2017/10/Cac-ky-thuat-SEO-toi-thieu-ma-developer-can-nam-vung-trong-lap-trinh-web.html","excerpt":"Trong khi đang làm việc tại công ty Basic (1 công ty của Nhật hoạt động trong lĩnh vực Web &amp; Media Marketing, vận hành 2 website ferret và ferretOne), tôi được giao nhiệm vụ tối ưu hoá công cụ tìm kiếm cho website phocase (1 website bán phụ kiện điện thoại), để hoàn thành công việc này tôi đã phải tìm hiểu và học thêm các kiến thức, tiện đây xin được tổng hợp lại và chia sẻ với các bạn những điều cần nhớ về SEO với vai trò là 1 kỹ sư. TLDR; Bài viết này dành cho nhiều đối tượng nên tương đối dài, hãy chọn lọc các kiến thức cần thiết cho mình thôi nhé :v","text":"Trong khi đang làm việc tại công ty Basic (1 công ty của Nhật hoạt động trong lĩnh vực Web &amp; Media Marketing, vận hành 2 website ferret và ferretOne), tôi được giao nhiệm vụ tối ưu hoá công cụ tìm kiếm cho website phocase (1 website bán phụ kiện điện thoại), để hoàn thành công việc này tôi đã phải tìm hiểu và học thêm các kiến thức, tiện đây xin được tổng hợp lại và chia sẻ với các bạn những điều cần nhớ về SEO với vai trò là 1 kỹ sư. TLDR; Bài viết này dành cho nhiều đối tượng nên tương đối dài, hãy chọn lọc các kiến thức cần thiết cho mình thôi nhé :v ★ Bạn có thể nhận được gì khi đọc bài viết này ? Sự tương tác giữa các Marketer và Director trở nên dễ dàng hơn Nhận biết các đoạn code mà vô tình làm giảm thứ hạng của website trên bộ máy tìm kiếm Đề xuất các giải pháp SEO có thể thực hiện được ở phía Developer Nắm bắt được bức tranh/bối cảnh SEO năm 2017 Nắm bắt chính xác tài liệu được Google chính thức công khaiCó thể tìm kiếm rất nhiều thông tin trên các trang web, nhưng tối thiểu thì hãy thực hiện những chính sách được Google đưa ra về rule của 1 website. Search Engine Optimization Starter Guide Ngoài ra bạn cũng có thể tìm hiểu thêm các thông tin tại website chính thức của Google: Official news on crawling and indexing sites for the Google index ★ Kiểm tra lại các biện pháp SEO trước đó để nắm được các thông tin hữu íchHãy tìm kiếm trong Search Console Help các từ khoá liên quan tới các công việc đã thực hiện từ trước, rất có thể bạn sẽ phát hiện ra những kỹ thuật bị bỏ sót mà mình không hề nghĩ tới. Chẳng hạn nếu như bạn có sử dụng thẻ alt với ảnh trên website, thì tôi khuyên bạn nên thử tìm kiếm trong Search Console Help các ảnh đã được đánh tag trước đó.Việc nhồi nhét quá nhiều keyword trong thẻ alt có thể khiến search engineer đưa vào danh sách spam, đây cũng có thể là cách để bạn phòng tránh việc đó.Search Console Help Chính sách của Google đối với Mobile SiteMobile First Index (MFI)Ngày 5/11/2016, Google chính thức công bố chính sách của mình đối với Mobile site: Mobile-first Indexing Về cơ bản, cho tới thời điểm hiện tại ngoài rank được đánh cho các website hướng PC Desktop, Google còn bổ sung thêm rank cho các website chú trọng nội dung và thiết kế tới SP (Smart phone) Ngày 5/4/2017, Tại hội nghị Next10x Conference, Các kỹ sư của Google đã chính thức công bố mục tiêu áp dụng vào trong năm nay, tuy nhiên chưa công bố chính thức khoảng thời gian. Trước khi áp dụng MFI (Hiện tại) PC Search: Hiển thị theo trình tự của rank cho nội dung PC site SP Search: Hiển thị theo trình tự của rank cho nội dung PC site Sau khi áp dụng MFI (Chưa xác định thời gian) PC Search: Hiển thị theo trình tự chú trọng vào rank cho nội dung SP site (Không có nghĩa là không tính đến rank của PC site) SP Search: Hiển thị theo trình tự của rank cho nội dung SP site ★ Các site có khả năng chịu ảnh hưởng Có sự khác biện lớn giữa phiên bản PC và SP Còn nhiều thông tin tồn tại trên phiên bản cho PC nhưng lại ko có trên phiên bản SP Đã hỗ trợ và có chiến lược SEO cho PC site nhưng lại chưa có cho SP site Ngoài header vs footer ra, các nội dung chính là khác nhau Cấu trúc HTML khác nhau Tốc độ hiển thị cho SP site quá chậm Mobile FriendlyNgày 21/4/2015, Google công bố : thứ tự xuất hiện trên kết quả tìm kiếm có liên quan tới UI, UX trong trường hợp truy cập trang web trên Smart Phone DeviceRolling out the mobile-friendly update Chỉ ảnh hưởng tới thứ tự xuất hiện kết quả tìm kiếm trên Mobile DeviceẢnh hưởng trong phạm vi toàn bộ các ngôn ngữ trên thế giớiÁp dụng cho các page riêng rẽ, chứ không phải toàn bộ trang web Nếu như website đó không được coi là Mobile Friendly sẽ có thứ tự thấp và không được ưu tiên xuất hiện trên kết quả tìm kiếm. Điều này có tác động trực tiếp tới doanh thu của các website thương mại điện tử (EC site) Sử dụng website sau, có thể kiểm tra tính thân thiện với thiết bị mobile của 1 trang webMobile Friendly Check ★ Các hạng mục cần kiểm tra Font size có thích hợp (&gt;= 16px) không? Có sử dụng thẻ meta và chỉ định viewport cho mobile không? Khoảng cách của các liên kết có bị quá hẹp không? (phòng ngừa lỗi) Nội dung trang web có bị tràn ra ngoài màn hình không? Website có được hiển thị trong vòng 3s không? (Nếu việc hiển thị tốn quá &gt; 3s, thì 40% người dùng sẽ thoát trang web đó) Đối với các website không thoả mãn tối thiểu các điều kiện trên sẽ có thể có có thứ hạng thấp trong kết quả tìm kiếm. ★ Mobile Friendly Support &amp; Yêu cầu craw lại websiteBằng cách sử dụng GoogleSearchConsole, bạn có thể nắm rõ được chi tiết các thành phần trên website mình không thoả mãn các hạng mục kiểm tra phía trên.Google Webmaster Home Sau khi giải quyết các vấn đề trên, hãy gửi yêu cầu cho Google crawl lại các URL đó.Chi tiết các bạn có thể tham khảo link sau về việc Yêu cầu Google crawl lại các URL ★ Các hạng mục để đánh giá về UX First view của trang web sẽ được hiển thị trong vòng 1 giây (Google recommended) Chuẩn bị riêng biệt kích thước hình ảnh với PC Site, để giảm dung lượng của một trang web Sử dụng công cụ YUI Compressor và JSMin để rút ngắn đoạn code dài như thư viện Thiết lập các nội dung có thể tab được lớn hơn 48px Để xác nhận tốc độ hiển thị của web site, bạn có thể dụng công cụ: PageSpeed Insights ★ Chuyển tiếp quảng cáoĐối với các quảng cáo chuyển tiếp thì đến khi hiển thị target page, thì hiển thị quảng cáo với link [Skip this page] giống như ảnh bên dưới, từ tháng 11 năm 2016 sẽ vi phạm điều luật của Google. Quote: https://london3.jp/2014/12/skip/ ★ Các tác động dẫn tới việc giảm thứ hạng rank Nội dung chính nằm trong Popup (kể cả Modal) Trước khi dẫn tới main content (nội dung chính) của website thì hiển thị quảng cáo giống trong ảnh trên First view có chưa quảng cáo với kích thước lớn, nếu không scroll thì không thấy được nội dung chính ★ Các tác động không ảnh hưởng tới thứ hạng rank Pop-up cấp quyền sử dụng Cookie Các hiển thị như xác minh độ tuổi với cơ sở dựa vào pháp luật Các page mà chỉ một bộ phận cụ thể người dùng được hiển thị, chẳng hạn như một trang đăng nhập. Banner quảng cáo Pop-up mà không chiếm nhiều diện tích màn hình Hơn nữa, trong cuộc đối thoại giữa Google với người sử dụng có câu hỏi: Về nội dung Pop-up (Quảng cáo) thì, liệu có khả năng nội dung ẩn bên trong nó lại được Googlebot ưu tiên ko ? Về phía Google đã trả lời là:「Chính xác là có khả năng đó」, như vậy thì việc hiển thị quảng cáo dù là = Pop-up hay Modal cũng là không nên. Cài đặt XML Sitemap &amp; Đăng ký RSS FeedCông việc này đã được Google hướng dẫn rất chi tiết tại link sau:Best practices for XML sitemaps &amp; RSS/Atom feeds RSS, Atom Register và PubSubHubbub(PuSH)Được sử dụng như Sitemap, có format tương tự RSS và Atom trong RSS Reader.。 ★ Lợi ích khi đăng ký Feed Chỉ URL được cập nhật gần đây nhất được đăng ký. Tần suất Crawl cao hơn Sitemap thông thường Việc thông báo cho Google các Page được create/update gần đây nhất là một phương pháp sử dụng Feed có tần suất Crawl cao hơn một cách hiệu quả. ★ Thực hiện index theo thời gian thực dựa vào PubSubHubbub (PuSH)Một cách để thực hiện index realtime khác đó là: Sử dụng phương thức PubSubHubbub (hay còn gọi là PuSH) giúp thông báo tới Google các thay đổi tại thời điểm mà các trang được update. Danh sách các repository thực hiện việc implement PuSH được viết trên nhiều ngôn ngữ lập trình Trường hợp code bằng PHP, có thể sử dụng file được Download từ thư viện sau đây:pubsubhubbub-php-master/library/publisher.php 123require_once './publisher.php' ;$publisher = new Publisher('http://pubsubhubbub.appspot.com/');$publisher-&gt;publish_update('http://example.com/article/1'); Đăng ký Sitemap★ HTML Sitemap Sitemap cho người sử dụng truy cập trang web Thường xuyên quản lý để tránh các liên kết lỗi Việc phân loại sẵn các Category giúp cải thiện khả năng sử dụng ★ XML SitemapViệc tạo sẵn một Sitemap có định dạng XML chính là công cụ đắc lực, trợ giúp Search Engine index website của bạnDưới đây là các loại Sitemap: Loại File XML Vai trò sitemap.xml Mô tả cấu trúc website, bao gồm cả mobile sitemap movie.xml Hiển thị các nội dung video trong tìm kiếm image.xml Hiển thị các nội dung ảnh trong tìm kiếm news.xml Khai báo các tệp tin được gửi tới Google News Với mỗi file XML được cài đặt chính xác, góp phần xúc tiến việc index website của bạn Tuy nhiên nếu crawler không visit, chúng ta cần thực hiện cải thiện lại Sitemap đã tạo trước đó Trên SP site việc giới hạn quyền truy cập webiste mobile trên device = .htaccess có thể khiến Search Engine Bot không vô được, vì vậy hãy cho phép Googlebot-Mobile có quyền truy cập. Trong thực tế, đối với việc create/submit Sitemap chúng ta có thể tham khảo thêm tại link Build and submit a sitemap , có hướng dẫn chi tiết các loại tool giúp tạo và test sitemap, rất tiện lợi. ★ Video, Image SitemapViệc Crawler thu thập thông tin tìm kiếm liên quan tới Video và Ảnh là tương đối khó khăn, do đó chúng ta cần sử dụng Sitemap chuyên dụng có chứa thông tin cho Video và Image.Về cách create thì bạn có thể tạo file XML chỉ chứa các video và ảnh mới tạo hoặc bổ sung chúng vào 1 file XML đã tồn tại đều ok, tuy nhiên hãy thiết lập một sitemap chứa nhiều thông tin.Sitemap Protocol : Video extension, Title, Duration, Description Hơn nữa, bằng cách sử dụng Video Sitemap, khi tiến hành tìm kiếm Video lẫn Image trong Search Engine, Video có thể được tìm thấy trong kết quả.Ví dụ file movie.xml như sau: 1xmlns:video=&quot;http://www.google.com/schemas/sitemap-video/1.1&quot; Khi vận hành 1 EC site (Website thương mại điện tử) sử dụng Image Sitemap, doanh nghiệp có thể thu hút và tiếp cận được đối tượng người dùng tìm kiếm sản phẩm muốn mua bằng ảnh trên máy tìm kiếm. Những điều cần lưu ý khi sử dụng tag HTML【Title】Trong SEO, thẻ Title là một trong số những thẻ tag có tầm ảnh hưởng nhất, Trong 1 page chỉ được có 1 thẻ title trong head tag.index.html 123&lt;head&gt; &lt;title&gt;Page title&lt;/title&gt;&lt;/head&gt; Nếu trong thẻ title có từ khóa tìm kiếm của user sẽ được bôi đậm trên kết quả tìm kiếm Mỗi Page nên có 1 thẻ title với nội dung khác nhau Trên kết quả tìm kiếm của Search Engine sẽ chỉ hiển thị tối đa ~32 ký tự trong nội dung của thẻ title Nếu trong thẻ title có chứa các từ khóa không cần thiết sẽ làm giảm trọng số của từ khóa mong muốn được tìm kiếm Nên lựa chọn nội dung của thẻ title sao cho dựa vào đó có thể đoán được phần nào nội dung của web page Cần lưu ý rằng trên Search Engine sẽ chỉ hiển thị khoảng 32 ký tự cho tiêu đề (title) của 1 website, và thậm chí là 24 ký tự khi người dùng tìm kiếm trên thiết bị di dộng.Nếu đặt tiêu đề cho page không liên quan tới nội dung của page sẽ làm giảm lượng người dùng truy cập, dẫn tới rank website bị giảm. Cho dù người dùng có truy cập vào nhưng do nội dung chính và tiêu đề không giống nhau, họ sẽ mau chóng rời đi -&gt; tỷ lệ bounce rate sẽ ngày càng tăng. 【Description】Trước tiên khi thiết lập Description, nội dung hiển thị trên search engine sẽ thay đổi tại đây: Việc thêm mô tả cho nội dung mà người dùng mong muốn tìm kiếm, góp phần làm tăng tỷ lệ click rate trên search result.Tuy nhiên nếu xét về mức độ ảnh hưởng về ranking trong thứ hạng xuất hiện trên Search Engine thì có vẻ là không lớn lắm. Hơn nữa ở thời điểm hiện tại dù không có mô tả rõ ràng cho page thì Google cũng hiện thị Description mà nó tự động tạo ra cho web page. Dựa vào các mô tả mà Google tự động sinh ra cho trang web, với các trường hợp đưa ra Description phán đoán chính xác thông tin trên website: Khuyến khích để Google tự động tạo description cho web page Các page khác nhau phải có nội dung khác nhau Nội dung description cần nhất quán với title tag Trên search engine chỉ hiển thị khoảng 124 ký tự cho phần description Khi tìm kiếm bằng thiết bị di động thì chỉ hiển thị khoảng 80 ký tự cho phần description Không bắt buộc văn phong phải chính xác tuy nhiên nội dung của tag phải rõ ràng, chuẩn xác. Bạn có thể sử dụng tool sau để đánh giá description trên 1 web page: http://seolaboratory.jp/description/ 【h1】Do việc lạm dụng thẻ h1 quá nhiều dẫn tới Google đã hạ chỉ số đánh giá của nó, tuy nhiên do vẫn còn xuất hiện trên kết quả tìm kiếm, nên đối với SEO vẫn còn khá quan trọng. Mỗi page chỉ nên có 1 thẻ h1 Mặc dù Google có công bố chính thức rằng có thể thiết lập nhiều thẻ h1, tuy nhiên nếu làm vậy sẽ gây khó khăn cho việc nhận biết chủ đề của nội dung web page Có thể thiết thể ảnh bên trong thẻ tag h1 /iphone6/?color=”white” 123&lt;h1&gt; &lt;img src=&quot;/images/iphone6_white.jpg&quot; alt=&quot;Danh sách bao da cho điện thoại iPhone 6 được nữ giới ưa chuộm&quot; /&gt;&lt;/h1&gt; Với cách đặt ảnh như trên thì nó cũng được nhận diện như 1 phần của h1 tag, do đó hãy mô tả chính xác ảnh bằng cách thêm nội dung vào thuộc tính alt (văn bản thay thế). ★ Keyword truyền tải bởi TDH (Title Description H1)Nếu bạn đặt từ khóa mình muốn SEO trong tất cả các thẻ TDH（Title Description H1）sẽ là cách đầu tiên giúp Google nhận biết chính xác từ khóa cần SEO.Do đó, cần xem xét 3 thẻ trên có chứa từ khóa mình cần lên top không? Lưu ý với thẻ【img】và thuộc tính 【alt】Bằng cách sử dụng thuộc tính alt mô tả nội dung trong ảnh và video, thì người khiếm thị (Sử dụng tính năng đọc văn bản) hoặc người dùng có tốc độ mạng internet chậm cũng có thể dễ dàng nhận được thông tin về website của bạn, điều này được Google đánh giá rất cao. Tham khảo source code bên dưới về Google Search ConsoleNguồn: https://support.google.com/webmasters/answer/114016?hl=vi Cách sử dụng không tốt thẻ img với thuộc tính alt 123456&lt;img src=\"puppy.jpg\" alt=\"\"/&gt;&lt;img src=\"puppy.jpg\" alt=\"puppy dog baby dog pup pups puppies doggies pups litter puppies dog retriever labrador wolfhound setter pointer puppy jack russell terrier puppies dog food cheap dogfood puppy food\"/&gt; Việc nhồi nhét quá nhiều từ khóa vào thuộc tính alt dẫn tới việc bị google nhận diện thành Spam content. Cách sử dụng tối ưu thẻ img với thuộc tínhalt 123&lt;img src=\"puppy.jpg\" alt=\"puppy\"/&gt;&lt;img src=\"puppy.jpg\" alt=\"Dalmatian puppy playing fetch\"&gt; Nếu có thể thì tốt nhất hãy mô tả bằng câu văn thay vì chỉ sử dụng 1 từ khóa cho các img tag. ★ Các hạng mục khác được khuyến khi khi sử dụng thẻ 【img】 (Không bắt buộc) Thống nhất file name và nội dung thuộc tính alt Có thể thiết lập nội dung trong alt mà không có khoảng trắng Cố gắng thiết lập mô tả cho ảnh sao cho gần với nội dung trong bức ảnh đó nhất có thể Các ảnh tương tự nhau thì nên để trong cùng 1 thư mục host Nếu một ảnh giống nhau được sử dụng ở nhiều nơi, thì hãy mô tả thật chi tiết ảnh đó trên website của mình, khi đó Google sẽ nhận diện ảnh của site bạn là original image, và hiển thị trên search result ! ★ Khả năng index và thu thập dữ liệu ở cùng thời điểm【Khả năng thu thập dữ liệu】Để crawler của GoogleBot dễ dàng thu thập dữ liệu, chúng ta cần Cấu trúc, sử dụng thẻ HTML phải đúng chuẩn Với các page có nội dung liên quan cần có liên kết tới nhau, để đảm bảo khả năng crawler trải dài trên toàn bộ website 【Khả năng index - đánh chỉ mục tìm kiếm】Nếu đã chuẩn bị sẵn các thuộc tính alt cho ảnh, âm thanh, video trên website của mình thì khi GoogleBot crawl sẽ index được chính xác nội dung của chúng. 【a】tagHãy thiết lập chuẩn xác anchor link (text), việc này sẽ giúp truyền tải thông tin tới Google dễ dàng hơn. Các implement có thể ảnh hưởng tới khả năng crawler Sử dụng javascript để di chuyển tới link cần vô (Google có khả năng nhận biết điều đó) Tìm kiếm bên trong website bằng cách gửi form Link content sử dụng FLASH 【rel=”next” or “prev”】Khi thiết lập Pagination cho website cần chỉ định thuộc tính rel với giá trị next hoặc prev ★ rel=”prev/next” được xếp hạng ưu tiên hơn rel=”canonical”Ví dụ vể rel=”canonical” cho mọi người dễ hiểu 1&lt;link rel=\"canonical\" href=\"http://example.com/wordpress/seo-plugin/\"&gt; Cho dù bạn có để link trên các page 2, 3, 4 về page 1 bằng thuộc tính canonical, thì next và prev vẫn được đánh giá ưu tiên hơn canonical, do đó với các URL không có parameter giống nhau như bên dưới sẽ không được tính là next và prev. Ví dụ chưa tối ưu 1234http://example.com/iphone7?page=1http://example.com/iphone7?color=red&amp;page=2http://example.com/iphone7?page=3http://example.com/iphone7?page=4 Ví dụ tối ưu: được tính là next và prev 123456789101112131415// page=http://example.com/iphone7?color=red&amp;page=1http://example.com/iphone7?color=red&amp;page=2http://example.com/iphone7?color=red&amp;page=3http://example.com/iphone7?color=red&amp;page=4// viết tắt p=http://example.com/foo.htmlhttp://example.com/foo.html?p=2http://example.com/foo.html?p=3// Sử dụng URL path thay thế cho param pagehttp://example.com/foo/1/http://example.com/foo/2/http://example.com/foo/3/ ★ Các điểm cần lưu ý 1 page chỉ được phép có 1 next và 1 prev Absolute path thì ngon hơn Relative path URL (Không bắt buộc) Trường hợp hiển thị kết quả tìm kiếm của 1 page có sử dụng điều kiện filter, thì ở trong trang điều kiện đó cũng cần bổ sung thuốc tính next và prev Nếu bạn không muốn hiển thị một page trên kết quả tìm kiếm, hãy học cách sử dụng canonical 【rel=”nofollow”】Với các target link có gắn thuộc tính rel=”nofollow” sẽ không được search engine visit. Thuộc tính này xuất hiện ở thẻ meta và thẻ a.Hơn nữa, khi GoogleBot visit target link, nó cũng tính toán độ tin cậy của các target link trên website và đánh giá thứ hạng site đó. ★ Khuyến khích sử dụng “nofollow” với link trỏ tới các website sau Các bảng tin và ô comment có thể được người dùng nhập Liên kết tới bookmark site Liên kết tới ranking site Liên kết khi nhận được đánh giá bằng tiền powerd by… link ★ Các liên kết có thể gây ảnh hướng xấu tới website cần lưu ý Các link mà người dùng không nhìn thấy, bị ẩn đi cũng như không click được Liên kết qua lại bằng các trang web hỗ trợ liên kết lẫn nhau Các liên kết đến các trang web được Google xác định là có mã nguồn độc hại Sử dụng【robots.txt】để không bị crawl thừaNếu không muốn search engin crawl trong những trường hợp dưới đây, hãy thiết lập file robot.txt Các web page có chất lượng thấp, các web page không muốn xuất hiện trên kết quả tìm kiếm File robots.txt được đặt ở thư mục gốc (root directory) của website, Các Bot search engine sẽ tự động đọc và lấy ra. Ví dụ về nội dung file robots.txt 12345User-Agent: *Disallow: /*/matome/Disallow: /ajax/*.jsonDisallow: /image/Disallow: /search Hơn nữa Google cũng hỗ trợ tool kiểm tra file robots.txt : Google robots.txt Tester 【rel=”noindex”】Hãy sử dụng nó khi bạn có chủ ý muốn 1 page nào đó trên website của mình không xuất hiện trên kết quả tìm kiếm của Google. ★ Điểm khác biệt với robots.txtSử dụng robots.txt đồng nghĩa với việc không cho Bot Search Enginer thu thập dữ liệu cũng như xếp hạng page đó. Trong khi sử dụng noindex thì sau một thời điểm nào đó khi link tới website của bạn được share nhiều trên mạng xã hội, thì SEO rank vẫn còn và link tới web page đó vẫn được xếp hạng. ★ Mục đích chính của việc sử dụng “noindex” Với các page chất lượng thấp, nếu có gắn thuộc tính noindex sẽ ko bị xếp hạng thấp website Support các page chưa được setting trong robots.txt cho tới thời điểm hiện tại 404 Page (Thiết lập ở các page trả về status lỗi 404) Cách thức setting: 1&lt;meta name=”robots” content=”noindex”&gt; ★ Cách kiểm tra tình trạng index của một websiteCó thể dùng Google Search Console - Index Status Hiển thị Rich snippetsRich Snippets là đoạn thông tin đặc biệt dùng để hiển thị các thông tin thêm có trong những bài viết đặc biệt (bài đánh giá, sản phẩm, ứng dụng, công thức nấu ăn, địa chỉ công ty..v.v..) trên các máy tìm kiếm (Google, Yahoo, Bing) nhằm cung cấp thêm những thông tin giá trị đến người tìm kiếm giúp họ xác định kết quả tìm kiếm mà họ đang cần. Nhìn vào kết quả tìm kiếm sau, ta thấy có một điều rất đặc biệt: Xuất hiện ảnh thumbnail trong kết quả :v Rich Snippets có 10 loại phổ biến sau: Author Breadcrumbs Event Organizations People Products Recipes Review Software Application Facebook Share Việc sử dụng các markup bằng cấu trúc được công bố trên schema.org sẽ làm tăng khả năng hiển thị rich snippet trên kết quả tìm kiếm của google.Hiện tại thì rich snippet không ảnh hưởng tới rank của 1 website, tuy nhiên có thể ảnh hưởng tới thứ hạng trong kết quả tìm kiếm: Google Webmaster Central office-hours hangout Ví dụ về 1 page có hiển thị snippets 123456789&lt;section itemscope itemtype=\"http://schema.org/Game\"&gt; &lt;h1&gt;Monster Hunter Game Series&lt;/h1&gt; &lt;span itemprop=\"name\"&gt;Monster Hunter Double Cross&lt;/span&gt; &lt;p itemprop=\"description\"&gt;Latest Monhan Series with 6 large main Monsters&lt;/p&gt; &lt;div itemprop=\"author\" itemscope itemtype=\"http://schema.org/Corporation\"&gt; &lt;p itemprop=\"name\"&gt;CONAMI&lt;/p&gt; &lt;p itemprop=\"email\"&gt;example@conamikan.jp&lt;/p&gt; &lt;/div&gt;&lt;/section&gt; Những lưu ý về URL (Đường dẫn)【Soft 404】Tình trang một page có status=200 nhưng nội dung page đó lại cho biết URL này không tồn tại được gọi là soft 404 Chi tiết thêm về lỗi này bạn có thể tham khảo tại đây: https://support.google.com/webmasters/answer/181708?hl=vi Sử dụng Google Search Console, để dễ dàng confirm lại các page dính lỗi soft 404 Gần đây Google Bot có khả năng phân biệt được lỗi soft 404, nên sẽ ko có hình phạt nào được áp dụng với site dính lỗi này. Trả về status code = 404 khi có lỗi trong CakePHP 1throw new NotFoundException(); Ngoài ra, bạn có thể tìm hiểu thêm về lỗi soft 404 ở đây: https://www.suzukikenichi.com/blog/does-google-penalize-your-site-for-having-soft-404/ Chuẩn hóa URLViệc hiển thị 1 web page có nội dung giống nhau nhưng với nhiều URL khác nhau trên trình duyệt xảy ra khá phổ biến. Tuy nhiên, nếu việc này xảy ra với Google search engine thì có thể website của bạn sẽ bị áp dụng các hình phạt làm giảm thứ hạng tìm kiếm. Chính vì lẽ đó chúng ta cần chuẩn hóa lại URL. ★ Các lợi ích có được khi quy chuẩn hóa đường dẫnGiả sử: Việc url một website có chứa www và ko chưa www được coi là các page khác nhauVấn đề: Lúc này việc đánh giá rank cho website bị phân tán giữa các link có và ko có wwwHướng giải quyết: Có thể chuyển hướng (301 redirect) các page có www sang page ko có www ★ 301 Redirect Wiki: List of HTTP status codes Khi thay đổi tên miền/url, hãy sử dụng chuyển hướng 301 sang đường dẫn mới Từ sau khi thiết lập 301 Redirect, có thể mất tới một tháng đẻ Bot Search crawl lại website ★ Ví dụ sử dụng 301 Redirect Sử dụng 301 Redirect trong việc có và không có www trên URL Loại bỏ việc thêm index.html vào sau URL Trường hợp Pagination /search/?page=1 và /search/ hiển thị nội dung giống nhau Trường hợp có và ko có dấu slash (/) sau URL. Ex: /search/ và /search Lưu ý khi code: tùy vào chức năng của trình duyệt web, nếu thực hiện điều hướng 301 từ 1 URL tới 1 URL nhất định thì việc di chuyển page này sẽ được lưu vào cache cho tới khi trình duyệt xóa nó đi. 【Canonical】Cùng một nội dung tương tự nhau (Có thể là 1 bài viết được chia làm nhiều phần), thì không chỉ người dùng mà Google Bot cũng muốn biết bài viết nào là bài viết gốc, câu trả lời cho vấn đề này chính là thuộc tính rel=”canonical”. Mặt khác chắc hẳn bạn cũng gặp phải trường hợp Single Page và Search Page có chứa 1 lượng lớn nội dung trùng lặp. Nhờ việc thiết lập canonical cho 1 page, mà ta có thể ngăn ngừa được việc Google đánh tụt thứ hạng tìm kiếm từ nội dung bị trùng lặp Ví dụ khi website có 2 phiên bản cho Desktop và Mobile: 12345&lt;head&gt; ... &lt;link rel=\"canonical\" href=\"http://www.example.com/\" /&gt; ...&lt;/head&gt; Ngoài canonical, còn có thể sử dụng đồng thời với alternate được giải thích chi tiết bên dưới. ★ Ví dụ về sử dụng Canonical Trên kết quả tìm kiếm xuất hiện nhiều page có content giống nhau Mobile page và Desktop page có nội dung tương tự nhau Thiết lập URL để Google Analytics tiến hành đo lường các thông số Khi công khai cùng 1 nội dung trên nhiều website Trường hợp không sử dụng 301 redirect Trường hợp sử dụng mirror site để giảm tải cho web/detect DDOS. (Tuyên nhiên việc này ko được khuyến khích sử dụng vì dễ bị nhận diện là spam) 【Alternate】Thẻ alternate được khuyến khích sử dụng khi bạn có : Một phiên bản website được phiên dịch hoàn toàn sang một ngôn ngữ khác 2 trang với cấu trúc, nội dung tương tự nhau và chỉ có một vài điểm nhấn khác biệt về ngôn ngữ trong nội dung Ví dụ: Website example.com 12345&lt;head&gt; ... &lt;link rel=\"alternate\" href=\"http://example.com/\" /&gt; ...&lt;/head&gt; Khi sử dụng alternate, chúng ta thông báo cho Bot biết website cho smart phone là sp.example.com. Khi sử dụng canonical, chúng ta thông báo cho Bot biết phiên bản website chính thức của hệ thống là example.com Website sp.example.com 12345&lt;head&gt; ... &lt;link rel=\"canonical\" href=\"http://sp.example.com/\" /&gt; ...&lt;/head&gt; canonical dùng để thông báo với Search Engine đâu là page gốc (original page). Có thể ví như quan hệ n:1alternate trở thành quan hệ 1:1 khi cùng tham chiếu tới canonical và alternate Thuộc tính canonical và alternate trên website https://ferret-plus.com/1426 đã giúp Bot Search Engine biết được phiên bản nào là website dành cho thiết bị di động. CloakingCloaking là sự che đậy hay che dấu một cái gì đó. Trong kỹ thuật SEO thì cloaking ám chỉ hành động của webmaster che dấu bot của search engine như Google crawl các nội dung mà người dùng nhìn thấy, đồng thời đề xuất cho các cậu Bot nhìn thấy các nội dung được Onpage optimize tốt nhằm mục đích đạt được các vị trí cao trên Search Engine. Việc tồn tại các thông tin trên website mà hiển thị giữa GoogleBot và người sử dụng khác biệt nhau sẽ ảnh hưởng tới thứ hạng hiển thị của website trên kết quả tìm kiếm. (Website có hành vi này sẽ bị google áp dụng các hình phạt) Website khi truy cập = PC hiện ra thông báo「Hãy truy cập bằng smart phone」, dù cho khi User-Agent là smart phone truy cập có hiển thị chính xác đi chăng nữa cũng rất có thể bị Google hiểu là Cloaking ??? Website ở tình trạng bị hack cũng có thể bị đưa vào trạng thái Cloaking, hãy thường xuyên quan sát log để tìm ra các hành động khả nghi và tiến hành deploy lại nếu cần. Đánh giá độ ổn định của URLCác bộ máy tìm kiếm có tiêu chí để xếp hạng URL là: URL đã cung cấp thông tin cho người sử dụng trong một thời gian dài bao lâu?.Do đó khi bạn thay đổi URL, sử dụng 301 Redirect thì cũng ko có gì đảm bảo là toàn bộ ranking của URL trên site cũ sẽ được chuyển hết sang URL site mới. ★ Các hạng mục cần kiểm tra khi thiết kế URL Có chứa ext của file như .php hay không ? Việc này sẽ gây ảnh hưởng nếu chuyển framework ví dụ từ CakePHP sang Rails chẳng hạn. Có thể dùng dấu - hoặc _ trong URL, tuy nhiên Google khuyến khích sử dụng dấu - để phân tách từ khóa Toàn bộ ký tự trong URL phải được viết thường URL dài cũng không vấn đề (Sẽ giải thích sau) URL không nên chia quá nhiều cấp, nằm sâu trong nhiều directory Chứa từ khóa thì càng tốt (Có thể chứa tiếng Nhật) URL không die cho dù sau này có áp dùng nhiều thay đổi SEO đi chăng nữa Không sinh ra duplicated content ★ Đảm bảo việc thiết kế URL không sinh ra nội dung trùng lặpWeb Page bên dưới sinh ra nội dung trùng lặp, dó đó kiểu thiết kế URL này không được khuyến khíchVí dụ：Anime Home Page Hero list page All characters list page Khi đó giả sử ta có nhân vật tên là “yamada”, khi đó nội dung 2 trang sau là giống nhau và đều mô tả về “yamada” heros/yamada.html characters/yamada.html Cùng 1 nội dung nhưng lại khác URL là một thiết kế tồi và bị xếp vào duplicated content. URL dài cũng không vấn đềTheo Google công bố thì độ dài của URL có thể ngắn hoặc dài tùy ý Độ dài của URL thì không ảnh hưởng tới rankingTuy nhiên cần đủ để nhận diện được URL Mặc dù không ảnh hưởng tới SEO, tuy nhiên trình duyệt IE chỉ support URL có độ dài tối đa 2083 ký tự, nên hãy setting URL length &lt;= 2083 ★ Các khuyến khích về URL Vì URL là thứ hiển thị trên kết quả search, nên hãy chọn các từ đơn trong URL có liên quan tới nội dung bài viết Khi URL có chứa từ ngữ trùng với từ khóa mà user search thì sẽ được bôi đậm trên kết quả Search engine sử dụng dấu “-“ để tách từ, nên URL cũng nên sử dụng dấu “-“ để ngăn cách các từ khóa trong nó. Mặt khác việc sử dụng quá nhiều GET parameter như ?color=2 trong URL có thể khiến URL khó nhớ, dễ nhầm lẫn, và khó chia sẻ. Dẫn tới việc truy cập phải URL không chính xác nếu không đủ parameter. Cấu trúc liên kết cần được chú trọng hơn cấu trúc thư mụcChúng ta có 2 đường dẫn sau: https://viblo.asia/cau-truc-duong-dan-nao-tot-cho-seo-file-name-hay-thu-muc.htmlhttps://viblo.asia/seo/seo-onpage/cau-truc-duong-dan-nao-tot-cho-seo-file-name-hay-thu-muc.html Như bạn đã biết, hai đường dẫn trên đều là 2 đường dẫn tối ưu cho SEO. Đường dẫn thứ nhất là đường dẫn kiểu file name và đường dẫn thứ hai là đường dẫn theo kiểu thư mục. Câu hỏi đặt ra ở đây là đường dẫn nào tốt hơn? ★ Nếu cấu trúc thư mục quá sâu có thể khiến Bot ko crawl đượcTham khảo link : https://support.google.com/webmasters/answer/156184?hl=viGoogle Bot sẽ crawl theo thứ tự từ nông tới sâu, dó đó URL ở các cấp sâu mà không được liên kết tới bởi page nào trong site có thể rơi vào tình trạng được crawl chậm và không được đánh index.Với tư cách là developer, bạn đừng quên tạo các link trong site internal liên kết tới các page quan trọng của site. Lưu ý: Việc tạo cấu trúc thư mục đơn giản chỉ giúp cho Google Bot crawl dễ dàng hơn chứ không ảnh hưởng tới thứ hạng trên Search Result. ★ Cấu trúc liên kết ảnh hưởng tới SEOCấu trúc liên kết được tóm gọn trong câu sau: “Khi bạn click vào liên kết bao nhiêu lần cũng vẫn access được page đó”. Cấu trúc link nếu vượt quá 5 cấp có thể khiến Google index chậm. Về cơ bản chỉ nên setting dưới 4 cấp đổ lại. Tham khảo: http://s-supporter.hatenablog.jp/entry/seo-difference-of-the-hierarchy#ディレクトリ階層とリンク階層の違い Lưu ý khi thêm Parameter vào URLTheo kỹ sư John Muelle từ Google thì việc thêm params vào URL của các dynamic page để dễ dàng thay đổi nội dung được khuyến khích. Just wanted to add that from Google’s point of view, the clean, parameterized URL is generally preferred to any unnecessary URL-rewriting. If you want a nice-looking URL-line in search, use breadcrumb markup instead. Tuy nhiên trên kết quả search thì với những page động sử dụng params để thay đổi nội dung cần thiết lập thêm Canonical để tránh xảy ra hiện tượng duplicated content. Dùng GET params sẽ làm giảm indexViệc sử dụng quá nhiều GET params có thể làm khả năng index giảm đi, do đó cần tránh thêm quá nhiều param là URL quá dài, hoặc thực hiển chuyển đổi url động sang url tĩnh với param ngắn hơn. ★ Chuyển đối URL tĩnhViệc chuyển đổi URL động sang tĩnh có thể hiểu đơn giản như sau: loại bỏ bớt GET params, chuyển nó vào path của URL Ví dụ:Ta có 1 URL khá dài với 3 GET params 1https://phocase.jp/iphone7/?color=3&amp;material=3&amp;category=cute Ta sẽ đưa category vào path của URL, lúc này số lượng params chỉ còn là 2 1https://phocase.jp/iphone7/cute/?color=3&amp;material=3 ★ Các điểm cần lưu ý khi chuyển đổi sang URL tĩnh Loại bỏ các params không cần thiết Không quản lý param theo session ID Thực hiển chuyển đổi các params có thẻ đưa vào URL path Không nên đưa quá nhiều param vào URL path dẫn tới URL quá dài, giảm khả năng index cũng như crawl URL càng có ý nghĩa càng tốt ★ Các thức đơn giản để thực chuyển đổi tĩnhĐể chuyển đổi sang URL tĩnh có thể implement lại routing của system, tuy nhiên cách đơn giản nhất là thiết lập lại file .htaccess 123RewriteEngine OnRewriteRule http://phocase.jp/([0-9]+)/$ http://phocase.jp/?color=$1 [L,NC] How To Create Temporary and Permanent Redirects with Apache and Nginx Các điểm cần lưu ý với Site contentSite có số lượng index lớnTheo nguồn tin chính thức từ Google thì việc 1 website có quá nhiều page không được chú trọng vào nội dung sẽ được coi là 1 website vô nghĩa, chỉ nên tập trung vào 1 số lượng page có nội dung được chú trọng thay vì tạo ra hàng loạt các page có nội dung nghèo nàn. ★ Site ranking Thông tin chỉ được tồn tại/sở hữu duy nhất bởi website Có chứ nhiều nội dung dễ hiểu như ảnh và video Mô tả thông tin chi tiết, rõ ràng và dễ hiểu Khi implement các page động thì số lượng page được index sẽ tăng lên, do đó cần xác định trước số lượng tối đa page sẽ được sinh ra. ★ Cách thức đối ứng Sử dụng chức năng URL parameter trong Google Search Console Sử dụng noindex content bằng file robots.txtJapanese search quality guidelines Tồn tại nội dung hữu ích với First View không?Khi truy cập 1 website mà ko thực hiện scroll xuống dưới, thì phạm vi người dùng quan sát được trên màn hình lúc này được gọi là First view Về cơ bản First view có kích thước khoảng 500×950px thì cần lưu ý những điểm sau: ★ Các điểm cần lưu ý Không setting external link Setting keyword cho SEO vừa phải Thiết lập alt cho ảnh, và tên file ảnh phải có liên quan tới nội dung bức ảnh Các công cụ mà tác giả đang sử dụng https://adwords.google.co.jp/KeywordPlanner http://www.related-keywords.com https://www.google.com/intl/ja_jp/analytics https://www.similarweb.com","categories":[],"tags":[{"name":"seo","slug":"seo","permalink":"http://nthung2112.github.io/tags/seo/"}]},{"title":"Tạo loading Facebook bằng CSS thật đơn giản!","slug":"Tao-loading-Facebook-bang-CSS-that-don-gian","date":"2017-09-27T04:31:18.000Z","updated":"2017-10-01T08:27:03.106Z","comments":true,"path":"2017/09/Tao-loading-Facebook-bang-CSS-that-don-gian.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Tao-loading-Facebook-bang-CSS-that-don-gian.html","excerpt":"Dạo gần đây nhà mình hay mất mạng, mà ai cũng biết rồi dân IT, Design, Gaming, XXX, mà không có internet thì hỡi ơi cứ như là sống ở thời kì đồ đá. Nhưng cũng nhờ thế mà tình cờ phát hiện được cái loading hay hay của facebook, twitter, bitbucket … nếu mạng bạn quá chậm nó sẽ show ra tương tự giống này. Sau đây là chút tò mò và mô phỏng để có được sự nhấp nháy kì lạ đó.","text":"Dạo gần đây nhà mình hay mất mạng, mà ai cũng biết rồi dân IT, Design, Gaming, XXX, mà không có internet thì hỡi ơi cứ như là sống ở thời kì đồ đá. Nhưng cũng nhờ thế mà tình cờ phát hiện được cái loading hay hay của facebook, twitter, bitbucket … nếu mạng bạn quá chậm nó sẽ show ra tương tự giống này. Sau đây là chút tò mò và mô phỏng để có được sự nhấp nháy kì lạ đó. Vẽ Photoshop cái khungBước này chỉ để chảnh chó là biết Photoshop thôi nha, chớ ai dùng gì vẽ cũng được, hoặc đếch cần vẽ cũng chẳng sao :D! Mình chụp cái hình nó lại, mở cái gì đó lên check lại được mấy cái mã màu của nó.Cụ thể là: Thumnail: #f6f7f9; background: #e9ebee; background line: #ebedf0; box-shadow: #d0d1d5; còn thiếu màu trắng tinh của trung tình cho các box bự.Các bác có thắc mắc vụ lấy mã màu gì không? Nói chung các bác lấy mã nào cũng được tại đang chém nên vẽ bậy đó thôi. Okay, xong vụ lấy mã màu, giờ thì xác định vị trí cũng như kích thước của từng thành phần trong của cái box này. Cụ thể là: Thumbnail: 40x40 Line: height 6px còn width thì tuỳ chỉnh thấy đụp đụp là ổn nhé các bác Khoản cách của line: 13px, số hơi xui tí. Cái box bự: 520x325. Thế là có dữ liệu thô rồi, nhào vào phần lên cúc trúc html nào. Lên cấu trúc HTMLRồi bây giờ chúng ta tạo 1 thưc mục, tạo 1 file tên là index.html mở nó lên bằng editor nào mà bạn thích, rồi chiến: Nghía qua cái box bằng đôi mắt không được lé của chúng ta thì các thành phần chính như sao: Cái box to class=”box-loading” Cái thumbnail class=”box-thumbnail” Có khoản 5 cái line với các kích thước khác nhau nên chúng ta có thể đặt tên là “box-line-xs, -sm, -df, -lg, -lgx” 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Loading-facebook&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box-loading\"&gt; &lt;div class=\"box-thumbnail\"&gt;&lt;/div&gt; &lt;div class=\"box-line-sm\"&gt;&lt;/div&gt; &lt;div class=\"box-line-xs\"&gt;&lt;/div&gt; &lt;div class=\"box-line-df\"&gt;&lt;/div&gt; &lt;div class=\"box-line-lgx\"&gt;&lt;/div&gt; &lt;div class=\"box-line-lg\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Okay vậy là xong rồi cái phần html nhé, quá nhanh và quá huy hiểm. Lên cấu trúc CSSĐã done html rồi thì bây giờ ta tạo 1 file style.css nhé. Để tô màu chơi cho vui thôi.Nhớ link vào file html nhé 1&lt;link href=\"style.css\"&gt; Sau đó ta mở file style.css và viết vào giống thế lầy. 123456789101112131415161718body &#123; background: #e9ebee;&#125;.box-loading &#123; background: #fff; height: 325px; width: 520px; display: block; box-shadow: 0 1px 1px rgba(0,0,0,0.1); -o-box-shadow: 0 1px 1px rgba(0,0,0,0.1); -moz-box-shadow: 0 1px 1px rgba(0,0,0,0.1); -webkit-box-shadow: 0 1px 1px rgba(0,0,0,0.1); border-radius: 3px; -o-border-radius: 3px; -moz-border-radius: 3px; -webkit-border-radius: 3px; margin: 0 auto;&#125; Để có được kết quả là cái box: Canh chỉnh box content Phần box-shadow mình viết như thế để nó gần giống với mã màu của cái line trên facebook và cũng như là all device, để vào phần Sass các bạn sẽ thấy thú vị hơn ở chổ này nhé. Tiếp đến là mấy cái line: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556body &#123; background: #e9ebee;&#125;// cái nào có class là box- thì nó sẽ nhận css[class*=\"box-\"] &#123; height: 6px; width: 400px; background: #f6f7f9; margin-bottom: 13px; margin-right: 5px;&#125;.box-loading &#123; background: #fff; height: 305px; width: 500px; padding: 10px; display: block; box-shadow: 0 1px 1px rgba(0,0,0,0.1); -o-box-shadow: 0 1px 1px rgba(0,0,0,0.1); -moz-box-shadow: 0 1px 1px rgba(0,0,0,0.1); -webkit-box-shadow: 0 1px 1px rgba(0,0,0,0.1); border-radius: 3px; -o-border-radius: 3px; -moz-border-radius: 3px; -webkit-border-radius: 3px; margin: 0 auto;&#125;.box-thumbnail &#123; height: 40px; width: 40px; float: left; margin-right: 20px; display: inline-block;&#125;// chịu khó viết style cho từng line nhé.box-line-sm &#123; width: 120px; margin-top: 10px; margin-left: 50px;&#125;.box-line-xs &#123; width: 80px; margin-left: 50px;&#125;.box-line-df &#123; margin-top: 30px; width: 380px;&#125;.box-line-lg &#123; width: 200px;&#125;.box-line-lgx &#123; width: 450px;&#125; Animation CSS loadingCác bạn thấy nãy giờ toàn là trò mèo đúng không? Giờ chúng ta mới vào phần trọng tâm của cái loading facebooking 1234567891011121314151617[class*=\"box-line\"],.box-thumbnail &#123; animation: timeline; // tên của animation để truyền action animation-duration: 1s; // thời gian thực thi action animation-timing-function: linear; // hiệu ứng cho action, có nhiều lắm thực chất nó là cubic-bezier, ai muốn custom thì xem link này http://cubic-bezier.com animation-iteration-count: infinite; // số lần chạy action, mình cho nó vô tận luôn background: linear-gradient(to right, #eeeeee 8%, #dddddd 18%, #eeeeee 33%); // gradient cho từng cái line background-size: 800px auto; // kích thước của cái bóng mờ mờ (gradient)&#125;// hành động của animation cho nó chạy từ trái sang phải@keyframes timeline &#123; 0% &#123; background-position: -350px 0;&#125; 100% &#123; background-position: 400px 0; &#125;&#125; Recode CSS thành SASSCái này cũng chẳng có gì hấp dẫn lắm, nhưng viết luôn cho bác nào thích chơi với thằng thứ ba thì chơi: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081body &#123; background: #e9ebee;&#125;[class*=\"box-\"] &#123; height: 6px; width: 400px; background: #f6f7f9; margin-bottom: 13px; margin-right: 5px;&#125;@mixin box-shadow($box_shadow) &#123; box-shadow: $box_shadow; -o-box-shadow: $box_shadow; -moz-box-shadow: $box_shadow; -webkit-box-shadow: $box_shadow;&#125;@mixin border-radius($border_radius) &#123; border-radius: $border_radius; -o-border-radius: $border_radius; -moz-border-radius: $border_radius; -webkit-border-radius: $border_radius;&#125;.box &#123; &amp;-loading &#123; background: #fff; height: 305px; width: 500px; padding: 10px; display: block; margin: 0 auto; @include box-shadow(0 0 0 rgba(0,0,0,0.1)); @include border-radius(3px); &#125; &amp;-thumbnail &#123; height: 40px; width: 40px; float: left; margin-right: 20px; display: inline-block; &#125;&#125;.box-line &#123; &amp;-sm &#123; width: 120px; margin-top: 10px; margin-left: 50px; &#125; &amp;-xs &#123; width: 80px; margin-left: 50px; &#125; &amp;-df &#123; margin-top: 30px; width: 380px; &#125; &amp;-lg &#123; width: 200px; &#125; &amp;-lgx &#123; width: 450px; &#125;&#125;[class*=\"box-line\"],.box-thumbnail &#123; animation: timeline; animation-duration: 1s; animation-timing-function: linear; animation-iteration-count: infinite; background: linear-gradient(to right, #eeeeee 8%, #dddddd 18%, #eeeeee 33%); background-size: 800px auto; background-position: 100px 0;&#125;@keyframes timeline &#123; 0% &#123; background-position: -350px 0;&#125; 100% &#123; background-position: 400px 0; &#125;&#125; Các bác có thể xem trên này luôn cho tiện nhá. Lời kếtOkay thế là có cái loading của facebook rồi, mặt dù là hàng face nhưng hi vọng cũng có thế giúp ít cho bác nào muốn dùng. Lưu ý: Bạn nên đọc lại kỹ một chút về các thuộc tínhbackground: linear-gradient, background-size, background-position và các thuộc tính animation, trước khi làmNên tự gõ, đừng copy rồi paste, vì như thế bạn chẳng nhớ gì đâu.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"trick","slug":"trick","permalink":"http://nthung2112.github.io/tags/trick/"}]},{"title":"Một bộ phim hoạt hình giới thiệu về Redux","slug":"Mot-bo-phim-hoat-hinh-gioi-thieu-ve-Redux","date":"2017-09-22T07:25:25.000Z","updated":"2017-10-01T08:24:53.462Z","comments":true,"path":"2017/09/Mot-bo-phim-hoat-hinh-gioi-thieu-ve-Redux.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Mot-bo-phim-hoat-hinh-gioi-thieu-ve-Redux.html","excerpt":"One thing that causes even more confusion than Flux is the difference between Flux and Redux, a pattern that was inspired by Flux. In this article I’ll explain the differences between the two. If you haven’t read the last article about Flux, you should do that first.","text":"One thing that causes even more confusion than Flux is the difference between Flux and Redux, a pattern that was inspired by Flux. In this article I’ll explain the differences between the two. If you haven’t read the last article about Flux, you should do that first. Why change Flux?Redux solves the same problems as Flux, plus some. Just like Flux, it makes state changes in apps more predictable. If you want to change state, you have to fire off an action. There’s no way to change the state directly because the thing holding the state (the store) only has a getter, not setters. These basics of Flux and Redux are pretty similar. So why a different pattern? Redux creator Dan Abramov saw an opportunity to improve on Flux. He wanted better developer tools. He saw that if you moved a couple of things around, you could make better developer tools possible, but still have the same predictability that Flux gives you. He wanted hot reloading and time travel debugging (there’s another cartoon to explain these). But there were some problems which made developer tooling hard to do with Flux. Problem 1: The code for stores can’t be reloaded without wiping out the stateIn Flux, the store contains two things: The state change logic The current state itself Having these two on the same object is a problem for hot reloading. When you reload the store object to see the effect that the new state change logic has, you lose the state that the store is holding on to. Plus, you mess up the event subscriptions that tie the store to the rest of the system. Solution Separate these two functions. Have one object that holds on to the state. This object doesn’t get reloaded. Have another object that contains all of the state change logic. This object can be reloaded because it doesn’t have to worry about holding on to any state. Problem 2: The state is being rewritten with every actionIn time travel debugging, you keep track of each version of a state object. That way, you can go back to an earlier state. Each time the state is changed, you need to add the old state to an array of previous state objects. But because of the way JavaScript works, simply adding the variable to the array won’t work. This doesn’t create a snapshot of the object, it just creates a new pointer to the same object. To make it work, each version needs to be an entirely separate object so that you aren’t accidentally changing past versions. SolutionWhen an action comes in to the store, don’t handle it by changing the state. Instead, copy the state and make changes to the copy. Problem 3: There aren’t good places for third-party plugins to jump inWhen you’re making developer tools, you need to be able to write them generically. A user should be able to just drop the tool in without having to custom fit their own code around it. For this to work, you need extension points… places where the code expects to have things added to it. An example is logging. Let’s say you want to console.log() every action as it comes in, and then console.log() the state that results from it. In Flux, you’d have to subscribe to the dispatcher’s updates and to updates from each store. But that’s custom code, not something a third-party module can easily do. SolutionMake it easy to wrap parts of the system in other objects. These other objects add their bit of functionality on top of the original. You can see these kinds of extension points in things like “enhancers” or “higher order” objects, as well as middleware. In addition, use a tree to structure the state change logic. This makes it so the store only emits one event to notify the views that the state has changed. This event comes after the whole state tree has been processed. Note: With these problems and solutions, I‘m focusing on the developer tooling use case. These changes help in other use cases, too. On top of that, there are other differences between Redux and Flux. For example, Redux also reduces boilerplate and it makes it easier to reuse logic in the store. Here’s a list of some other upsides to Redux_._ So let’s see how Redux makes these things possible. The new cast of charactersThe cast of characters changes a little bit from Flux to Redux. Action creators Redux keeps the action creator from Flux. Whenever you want to change the state of the application, you shoot off an action. That’s the only way that the state should be changed. As I said in the article on Flux, I think of the action creator as a telegraph operator. You go to the action creator knowing basically what message you want to send, and then the action creator formats that in a way that the rest of the system can understand. Unlike Flux, action creators in Redux do not send the action to the dispatcher. Instead, they return a formatted action object. The storeI described stores in Flux as over-controlling bureaucrats. All state changes must be made personally by a store and have to go through the action pipeline, instead of being requested directly. The store in Redux is still controlling and bureaucratic, but it’s a little bit different. In Flux, you can have multiple stores. Each store has its own little fiefdom, and it is in total control. It holds on to its little slice of state, and has all the logic for changing that little slice of state. The Redux store tends to delegate more. And it has to. In Redux, there is only one store… so if it did everything itself, it would be taking on too much work. Instead, it takes care of holding on to the whole state tree. It then delegates the work of figuring out what state changes need to happen. The reducers, headed up by the root reducer, take on this task. You might have noticed there’s no dispatcher. That’s because, in a bit of a power grab, the store has also taken over dispatching. The reducersWhen the store needs to know how an action changes the state, it asks the reducers. The root reducer takes charge and slices the state up based on the state object’s keys. It passes each slice of state to the reducer that knows how to handle it. I think of the reducers as a department of white-collar workers who are a little overzealous about photocopying. They don’t want to mess anything up, so they don’t change the state that has been passed in to them. Instead, they make a copy and make all their changes on the copy. This is one of the key ideas of Redux. The state object isn’t manipulated directly. Instead, each slice is copied and then all of the slices are combined into a new state object. The reducers pass their copies back to the root reducer, which pastes the copies together to form the updated state object. Then the root reducer sends the new state object back to the store, and the store makes it the new official state. If you have a small application, you might only have one reducer making a copy of the whole state object and making its changes. Or if you have a large application, you might have a whole tree of reducers. This is another difference between Flux and Redux. In Flux, the stores aren’t necessarily connected to each other and they have a flat structure. In Redux, the reducers are in a heirarchy. This hierarchy can have as many levels as needed, just like the component hierarchy. The views: smart and dumb componentsFlux has controller views and regular views. The controller views act as middle managers, managing the communication between the store and their child views. In Redux, there’s a similar concept: smart and dumb components. The smart components are the managers. They follow a few more rules than the controller views, though: Smart components are in charge of the actions. If a dumb component underneath them needs to trigger an action, the smart component passes a function in via the props. The dumb component can then just treat that as a callback. Smart components do not have their own CSS styles. Smart components rarely emit DOM of their own. Instead, they arrange dumb components, which handle laying out DOM elements. Dumb components don’t depend on action files directly, since all actions are passed in via props. This means that the dumb component can be reused in a different app that has different logic. They also contain the styles that they need to look reasonably good (though you can allow for custom styling — just accept a style prop and merge it in to the default styles). The view layer binding To connect the store to the views, Redux needs a little help. It needs something to bind the two together. This is called the view layer binding. If you’re using React, this is react-redux. The view layer binding is kind of like the IT department for the view tree. It makes sure that all of the components can connect to the store. It also takes care of a lot of technical details so that the rest of the hierarchy doesn’t have to understand them. The view layer binding introduces three concepts: The Provider component: This is wrapped around the component tree. It makes it easy for the root component’s children to hook up to the store using connect(). connect(): This is a function provided by react-redux. If a component wants to get state updates, it wraps itself using connect(). Then the connect function will set up all the wiring for it, using the selector. selector: This is a function that you write. It specifies what parts of the state a component needs as properties. The root component All React applications have root components. This is just the component at the top level of the component hierarchy. But in Redux applications, this component takes on more responsibility. The role it plays is kind of like a C-level executive. It puts all of the teams in place to tackle the work. It creates the store, telling it what reducer to use, and brings together the view layer binding and the views. The root component is pretty hands-off after it initializes the app, though. It doesn’t get caught up in the day-to-day concerns of triggering rerenders. It leaves that to the components below it, assisted by the view layer binding. How they all work togetherLet’s see how these parts work together to create a functioning app. The setupThe different parts of the app need to be wired up together. This happens in setup. 1. Get the store ready. The root component creates the store, telling it what root reducer to use, using createStore(). This root reducer already has a team of reducers which report to it. It assembled that team of reducers using combineReducers(). 2. Set up the communication between the store and the components. The root component wraps its subcomponents with the provider component and makes the connection between the store and the provider. The Provider creates what’s basically a network to update the components. The smart components connect to network using connect(). This ensures they’ll get state updates. 3. Prepare the action callbacks. To make it easier for dumb components to work with actions, the smart components can setup action callbacks by using bindActionCreators(). This way, they can just pass down a callback to the dumb component. The action will be automatically dispatched after it is formatted. The data flowNow that the application is set up, the user can start interacting with it. Let’s trigger an action to see the data flow. 1. The view requests an action. The action creator formats it and returns it. 2. The action is either dispatched automatically (if bindActionCreators() was used in setup), or the view dispatches the action. 3. The store receives the action. It sends the current state tree and the action to the root reducer. 4. The root reducer cuts apart the state tree into slices. Then it passes each slice to the subreducer that knows how to deal with it. 5. The subreducer copies the slice and makes changes to the copy. It returns the copy of the slice to the root reducer. 6. Once all of the subreducers have returned their slice copies, the root reducer pastes all of them together to form the whole updated state tree, which it returns to the store. The store replaces the old state tree with the new one. 7. The store tells the view layer binding that there’s new state. 8. The view layer binding asks the store to send over the new state. 9. The view layer binding triggers a rerender. So that’s how I think of Redux and its differences from Flux. Hope it helps! Coming up nextI’m making a list of topics. If you have any suggestions, or there are any parts of the React ecosystem that you find confusing and you’d like to see explained, let me know on Twitter. Resources Redux docs Dan Abramov’s React Europe talk The Evolution of Flux Frameworks Smart and Dumb Components The upsides of using Redux The downsides of using Redux JS Jabber: The Evolution of Flux Libraries with Andrew Clark and Dan Abramov","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://nthung2112.github.io/tags/redux/"}]},{"title":"Redux thật là đơn giản (Phần 2)","slug":"Redux-that-la-don-gian-Phan-2","date":"2017-09-22T07:13:23.000Z","updated":"2017-10-01T08:24:53.492Z","comments":true,"path":"2017/09/Redux-that-la-don-gian-Phan-2.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Redux-that-la-don-gian-Phan-2.html","excerpt":"Redux với React Native Bài trước Nguyên Lý của Redux các bạn đã nắm được cơ bản phần lý thuyết về Redux và dùng cho việc gì, sau đây chúng ta sẽ đi vào áp dụng nó với React hoặc React Native, ở đây mình chọn React Native vì nó vẫn đang còn khá HOT :D (Thực ra React hay React Native thì đều dùng Redux là y hệt nhau)","text":"Redux với React Native Bài trước Nguyên Lý của Redux các bạn đã nắm được cơ bản phần lý thuyết về Redux và dùng cho việc gì, sau đây chúng ta sẽ đi vào áp dụng nó với React hoặc React Native, ở đây mình chọn React Native vì nó vẫn đang còn khá HOT :D (Thực ra React hay React Native thì đều dùng Redux là y hệt nhau)Đầu tiên các bạn vào link:https://facebook.github.io/react-native/docs/getting-started.html để làm theo và tạo 1 project với React Native. Lưu ý: Máy phải được cài sẵn yarn (https://yarnpkg.com/en/) hoặc dùng npm sau khi đã cài node, vì nếu cài yarn thì nó sẽ đồng thời cài node luôn cho bạn. Phần 1: Tạo giao diện màn hình với React NativeSau khi install xong, tạo thêm thư mục src -&gt; file Main.js như sau: Ở đây mình sẽ minh họa tạo chức năng hết sức đơn giản là Bấm — Tăng — Giảm 1 số dùng React Native + Redux có màn hình hiển thị lên như sau: Main.js Trong thư mục components ta tạo thêm 1 component có tên Button.js, thực tế bạn không cần phải viết hẳn 1 component chỉ render mỗi cái Button như này, do mình muốn tách nhỏ component nên tạm lấy ví dụ viết 1 component con riêng ra. (trong component này mình có dùng react-native-elements cài đặt nó qua yarn bằng lệnh sau:yarn add react-native-elements Component để hiển thị text number: Okay tới đây coi như xong giao diện, như vậy bạn đã có 1 app counter khá đơn giản :D và hoàn toàn có thể làm dùng React Native đơn giản hơn nhiều, nhưng để hiểu về Redux thì chúng ta nên bắt đầu từ việc đơn giản đã. Phần 2: Cài đặt ReduxStep1: install Redux, React-Redux dependencies yarn add redux react-redux Step 2: Tạo cấu trúc thư mục project như hình: 3 nhân tố của Redux là actions, reducers và store tương ứng với 3 thư mục trong project. actions: index.js chứa các action (nó sẽ export ra cho các class có thể gọi tới các function bên trong nó) types.js định nghĩa các hằng số về kiểu của actions: reducers: Tạo 1 reducer counterReducer: làm nhiệm vụ update state counter mỗi khi có action click Tiếp theo tạo file index.js, file này có nhiệm vụ combine các reducers con thành 1 reducer duy nhất để đưa vào store Store:tạo 1 file index.js trong thư mục store. (Mình có config thêm redux-devtools-extension để tiện debug và xem store khi redux hoạt động trên extention của chrome). Step 3: connect React component với store của Redux Việc cần làm là làm sao để kết nối toàn bộ components của app với store của Redux. Thư viện react-redux đã cung cấp 1 thằng có tên Provider để làm cầu nối cho React và Redux, chúng ta chỉ việc bọc nó bao ngoài root component của React và truyền 1 tham số duy nhất là store vào (store đã được tạo ở thư mục store và được import vào file này). Step 4: Gọi 1 action từ 1 component và map data từ store ra View Quay lại bài trước như đã biết thì flow của redux: action → reducer → store → View 3 bước đã thực hiện xong ở trên, việc còn lại là store và View tương tác như nào, câu hỏi đặt ra là : Phát đi 1 action từ component → store như thế nào? Cập nhật data thay đổi từ store → View ra sao? Nhiệm vụ quan trọng này được thực hiện bởi hàm connect() trong react-redux. Hàm connect() có 2 tham số: mapDispatchToProps(dispatch) nhiệm vụ map hàm dispatch() của store trở thành 1 thuộc tính của props của component đó, cụ thể ở code bên dưới thì actions chính là 1 props của component đó và giờ muốn phát đi 1 action ta chỉ việc gọi this.props.actions.tên_action_ mapStateToProps(state) nhiệm vụ hết sức đơn giản giống như cái tên của nó, biến các state từ store thành props của component và sau đó show ra View Để đơn giản và ngắn gọn hơn ta sẽ bỏ đi hàm mapDispatchToProps(dispatch) và thay bằng việc truyền trực tiếp actions vào hàm connect() cuối cùng sẽ là: connnect(mapStateToProps, actions)(COMPONENT) Quay trở lại code React Native ở trên, ở phần View ta có: main.js Giải thích: Actions được import từ thư mục actions → được truyền vào là tham số thứ 2 của hàm connect() Mỗi khi button đc bấm thì ta gọi tới hàm handle tương ứng để xử lý actions, nhớ rằng đã thực hiện connnect(null, actions) ở trên thì bây giờ các actions export ra từ file index trong thư mực actions trở thành các thuộc tính của props trong component Main.js → khi gọi tới action thì ta chỉ việc gọi this.props.action_name_tương_ứng_ Tiếp theo là hiển thị ra View ở component child.js Ở file này ta vừa gán thuộc tính counter : state.counter lúc này counter cũng trở thành 1 props của component Child → gọi show ra View ta chỉ cần gọi như thông thường {this.props.counter} Như vậy là 1 app counter đơn giản bằng React Native và Redux đã thực hiện xong tóm lại flow như sau: 1. View gồm 2 button Increase và Decrease và 1 component hiển thị number 2. Khi Button được click → dispatch() tới 1 action creator có têncounterIncrease() 3. counterIncrease() sẽ tạo ra 1 Object (Trong redux action phải là 1 plain object có thuộc tính là type và payload, type là bắt buộc) ở đây chỉ có 1 thuộc tính {type:”INCREASE”} sau đó nó truyền tới counterReducer() để xử lý. 4. counterReducer(state, action) =&gt; kiểm tra xem action có kiểu type = “increase” trả ra 1 state mới là: state + 1 (state của redux là immutable) 5 ở component View(Child) hiển thị number ta sẽ dùng hàm mapStateToProps(state) đẻ nhận state là counter rồi update vào View. → App đã chạy ngon lành :D Giả sử bây giờ yêu cầu bài toán có thay đổi chút như sau: Nếu click vào nút tăng hoặc giảm mà sau 1s con số mới thay đổi. Nâng cao hơn chút là nếu click vào button increase number thì number chạy từ 0 cho tới 1 con số bất kỳ trong khoảng 1s rồi dừng lại. Bình thường ở bài toán trên ta bấm nút thì ngay lập tức action đáp trả kết quả, nhưng trong thực tế có nhiều bài toán ko lập tức có thay đổi luôn điển hình như call api tới server để fetch data, thì phải mất 1 lúc kết quả mới được trả về. Hay như bài toán bấm nút thì sau 1s mới thay đổi → thì những điều này người ta gọi đó là side-effect . Như đã biết thì Redux yêu cầu 1 object được trả ra phải là Plain object: {type: ACTION_TYPE, payload:params} và reducer phải là pure function,hay nói cách khác là hoàn toàn ko có side-effect. Okay có lẽ bài thứ 2 về redux đến đây là dài rồi :)) Mình sẽ giải quyết vấn đề side-effect ở bài sau dùng Redux-middleware Hẹn gặp lại các bạn về bài cuối của Redux. Source code ví dụ trên: check out branch lesson_2 https://github.com/tridungbk2010/react-native-class","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://nthung2112.github.io/tags/redux/"}]},{"title":"Redux thật là đơn giản! (Phần 1)","slug":"Redux-that-la-don-gian-Phan-1","date":"2017-09-22T07:02:19.000Z","updated":"2017-10-01T08:24:53.481Z","comments":true,"path":"2017/09/Redux-that-la-don-gian-Phan-1.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Redux-that-la-don-gian-Phan-1.html","excerpt":"Nguyên lý cơ bản của ReduxRedux nổi lên trong vòng 2 năm nay như 1 hiện tượng, nó thậm chí thay thế luôn kiến trúc Flux của Facebook dùng cho React, và hiện tại Facebook cũng khuyến cáo dev chuyển qua dùng Redux vì nhiều ưu điểm được cải tiến từ Flux. Mặc dù nó ko còn tính thời sự như hơn 1 năm trước nhưng mình vẫn quyết định viết series Redux để giúp các bạn mới học React và Redux tiếp cận dễ dàng hơn.","text":"Nguyên lý cơ bản của ReduxRedux nổi lên trong vòng 2 năm nay như 1 hiện tượng, nó thậm chí thay thế luôn kiến trúc Flux của Facebook dùng cho React, và hiện tại Facebook cũng khuyến cáo dev chuyển qua dùng Redux vì nhiều ưu điểm được cải tiến từ Flux. Mặc dù nó ko còn tính thời sự như hơn 1 năm trước nhưng mình vẫn quyết định viết series Redux để giúp các bạn mới học React và Redux tiếp cận dễ dàng hơn.Series gồm 3 phần: Phần 1: Nguyên lý cơ bản của Redux Phần 2: Cài đặt và sử dụng với React Native Phần 3: Redux-middleware (Thunk, Saga, Observable) nên dùng cái nào? Mời các bạn đón đọc! Lịch sử Redux (Câu chuyện vui) Năm Quý Tị (2013), Facebook gia tộc bố cáo thiên hạ rằng Ăn Gô La đại pháp (Angular) của Google gia tộc chậm chạp, nặng nề, cho xuất thế một bộ chiêu thức gọi là Rối An Tâm Pháp (React). Thế nhưng Rối An Tâm Pháp lại chỉ là một bộ tâm pháp cường thân kiện thể, không thể dùng để rèn luyện nội công (chỉ là một library để render view). Do đó, không lâu sau Facebook gia tộc tiếp tục cho ra đời một bộ tâm pháp cơ bản (kiến trúc thiết kế) và một công pháp cùng tên là Phờ Lắc thần công (Flux). Nghe đồn Rối An Tâm Pháp và Phờ Lắc Thần Công kết hợp lại sẽ thành tuyệt học dời non lấp bể, không gì không làm đc. Nhân sĩ giang hồ (coder) vốn nhẹ dạ cả tin lại rủ nhau tu luyện. Phờ Lắc thần công rối rắm khó học, nhân sĩ 10 phần học thì 4–5 phần tẩu hỏa nhập ma, phần còn lại cũng trầy da tróc vẩy mà công lực cũng chẳng được như lời Facebook gia tộc quảng cáo. Bấy giờ có một nhân sĩ giang hồ tự là Đan (Dan Abramov), đang tu luyện đồng thời Phờ lắc thần công và Ê La thần công (Elm) mới nhận ra rằng hai môn võ công có nhiều điểm chung, chỉ khác chiêu thức, Đan bèn nảy ra ý định hợp nhất hai môn này lại. Không lâu sau (5/2015), Đan cho xuất thế một bộ công pháp mang tên Rì Đắt thần công (Redux), mang ưu điểm của cả hai môn võ công đồng thời loại bỏ những phức tạp dư thừa của Phờ Lắc thần công. Nhân sĩ giang hồ nghe vậy mừng lắm, thế là lại kéo nhau đi học Rì Đắt, còn Đan thì được Facebookgia tộc mời về làm tộc nhân. Trích “JavaScript Lược Sử Giang Hồ” Đọc qua đoạn đậm màu sắc kiếm hiệp ở trên chắc các bạn phần nào cũng hình dung được Redux sinh ra để làm gì đúng ko? 1. Redux sinh ra để làm gì?Do yêu cầu cho các ứng dụng single-page sử dụng Javascript ngày càng trở lên phức tạp thì code của chúng ta phải quản lý nhiều state hơn. State có thể bao gồm là data trả về từ phía Server và được cached lại hay như dữ liệu được tạo ra và thao tác ở phía client mà chưa được đẩy lên phía server. UI state cũng trở lên phức tạp vì chúng ta cần quản lý việc active Routes, selected tabs, spinners, điều khiển phân trang …vv. Việc quản lý từng thay đổi của state là rất khó: Vì nếu như khi ta thay đổi 1 Model -&gt; Model khác cũng thay đổi theo và nếu 1 View thay đổi -&gt; Model thay đổi -&gt; Model khác nữa cũng thay đổi theo. Về phía Front-end development, thì được kỳ vọng xử lý các vấn đề như “optimistic updates” (Hiểu như thể một thay đổi trên giao diện được thực hiện thành công trước khi được xác nhận từ phía server), render phía server, featching data trước khi thực hiện chuyển trang …vv. Nếu như ko có một luồng xử lý khoa học và rõ ràng thì việc quản lý dữ liệu với các dự án lớn là vô cùng phức tạp. Vấn đề phức tạp như đề cập ở trên sẽ còn càng khó xử lý hơn nữa vì chúng ta đang trộn lẫn 2 khái niệm mà nó ko tự nhiên với tư duy thông thường của con người đó là: Biến đổi dữ liệu (Mutation) và tính bất đồng bộ (Asynchronicity), mặc dù chúng sẽ là tuyệt vời nếu dùng tách rời nhau, nhưng hoạt động cùng nhau sẽ gây ra sự hỗn độn. React JS đã cố gắng giải quyết điều này ở trong tầng View bằng việc loại bỏ Bất đồng bộ và Không thao tác trực tiếp trên DOM, tuy nhiên việc quản lý state là tùy thuộc vào cách của bạn do vậy đây chính là lí do Redux xuất hiện để giúp bạn quản lý state một cách khoa học và hiệu quả hơn. 2. Tại sao người ta hay dùng React với Redux?Redux ra đời lấy cảm hứng từ tư tưởng của ngôn ngữ Elm và kiến trúc Flux của Facebook . Do vậy Redux thường dùng kết hợp với React. Tuy nhiên hoàn toàn có thể sử dụng với các framework khác như Angular, Angular2, Backbone, Falcor, Deku, Swift. Vậy bạn có cần biết Flux trước khi đến với Redux ko? câu trả lời là KHÔNG vì thật sự nếu bạn đã dùng flux thì cũng tốt, còn không thì bạn lại dễ tiếp cận hơn (tránh lối mòn :D). 3. Quản lý state bằng Redux như thế nào?Giả xử chúng ta có 1 ứng dụng mà các node như trong hình là tượng trưng cho một single page application được mô hình tree-node. Hình dung app của chúng ta vận hành bằng việc chuyển đổi qua lại data gữa các node, mỗi node (trang con) chứa một state và các node con nhận data được truyền từ node cha vào node con. Giả sử nếu có 1 action ở node d3 được kích hoạt và ta muốn thay đổi state d4 và c3 thì luồng dữ liệu sẽ được truyền từ node d3 trở về node gốc là a, xong sau đó từ node a lại phát đi data đến các node con: Cập nhật state cho node d4: d3-c2-b1-a-b2-c4-d4 Cập nhật state cho node c3: d3-c2-b1-a-b2-c3 Với những bài toán nhỏ (chỉ cần dùng React JS ko cần Redux) thì update state qua lại giữa các page có thể dễ dàng nhưng bạn thử hình dung ứng dụng lớn hơn có rất nhiều nhánh và node con thì việc thao tác update state qua lại giữa các page trở nên phức tạp hơn khiến cho flow của code cũng khó đọc và khó debug hơn. Và giải pháp Redux đưa ra là như sau: Quay lại bài toán ở trên thì ta chỉ cần map Action từ node d3 về store của redux rồi ở node c3 và d4 chỉ cần connect với store và cập nhật data thay đổi -&gt; hết sức đơn giản phải ko? 4. Nguyên tắc hoạt động của ReduxVừa xong phần lý thuyết để phần nào các bạn mường tượng ra triết lý của Redux tiếp theo sau đây mình sẽ đi sâu vào giải thích cụ thể hơn các thành phần của Redux a. Khái niệm cốt lõi: Hãy tưởng tượng state của app của bạn được mô tả như 1 object thuần dưới đây: 12345678910&#123; todos: [&#123; text: 'Eat food', completed: true &#125;, &#123; text: 'Exercise', completed: false &#125;], visibilityFilter: 'SHOW_COMPLETED'&#125; Thật sự thì nó trông giống như 1 model ko có phương thức setters ( nghĩa là chỉ có thể lấy ra data mà ko cho phép thay đổi data đó), điều này để tránh các thay đổi tùy tiện trong khi code gây ra việc khó debug. Để thay đổi state, chỉ có 1 cách duy nhất là dispatch 1 action (Mình sẽ nói ở phần sau). b. 3 nguyên tắc của Redux Single source of truth: State của toàn bộ ứng dụng được lưu trong trong 1 store duy nhất là 1 Object mô hình tree. - State is read-only: Chỉ có 1 cách duy nhất để thay đổi state đó là tạo ra một action (là 1 object mô tả những gì xảy ra) Changes are made with pure functions: Để chỉ rõ state tree được thay đổi bởi 1 action bạn phải viết pure reducers c. Nguyên lý vận hành ActionsTrong Redux action là 1 pure object định nghĩa 2 thuộc tính là : type: kiểu mô tả action, và payload: giá trị tham số truyền lên 1234&#123; type: \"KIEU_ACTION\", payload: //tham số&#125; ReducersAction có nhiệm vụ mô tả những gì xảy ra nhưng lại không chỉ rõ phần state nào của response thay đổi -&gt; Việc này sẽ là của Reducer đảm nhiệm: Reducer nhận 2 tham số vào: 1 state cũ và action được gửi lên sau đó trả ra một state mới, ko làm thay đổi state cũ. 1(previousState, action) =&gt; newState StoreStore là 1 object lưu trữ state của toàn bộ ứng dụng có 3 phương thức sau: getState(): Giúp lấy ra state hiện tại dispatch(action): Thực hiện gọi 1 action subscrible(listener):Nó có vai trò cực quan trọng, luôn luôn lắng nghe xem có thay đổi gì ko rồi ngay lập tức cập nhật ra View Để cho dễ hiểu hơn mình sẽ minh họa bằng ví dụ sau: Ta có 1 reducer, khở tạo store thông qua hàm createStore(reducer), trong Redux. Phân tích vị dụ trên ta có: Step 1: Khởi tạo store cho project mà nó nhận tham số đầu vào là reducer counter ở trên: 1const store = createStore(counter); Step 2: Sau đó giả sử ta muốn tăng giá trị lên 1 thì call action với type là “INCREMENT” dùng hàm dispatch() của store: 123document.addEventListener('click', () =&gt; &#123; store.dispatch(&#123;type:\"INCREMENT\"&#125;);&#125;); Step 3: lúc này là nhệm vụ của reducer, sẽ xem kiểu action gọi lên là gì “INCREMENT” hay “DECREMENT” để nó return ra 1 new state cụ thể ở đây là state + 1. Step 4: thằngsubcrible() trong store sẽ làm nhiệm vụ cập nhật tình hình thay đổi ra View: 123store.subcrible(() =&gt; &#123; document.body.innerText = store.getState(); &#125;); Đến đây thì cơ bản bạn đã nắm được nguyên lý hoạt động cơ bản nhất của Redux mà tôi tạm rút gọn lại flow là: action -&gt; reducer -&gt; store -&gt; View 5. Tóm lạiỞ phạm vi bài này mình đã trình bày nguyên lý cơ bản và cách thức hoạt động của Redux để các bạn có thể nắm được cũng như hình dung nó sinh ra để làm việc gì, bài viết mới thể hiện được các tình huống đơn giản nhất thông qua ví dụ đơn giản, còn trong khi làm dự án thực tế công việc chủ yếu là tương tác với server (fetch data) và xử lý data sau đó, thì đó là về bất đồng bộ asynchronous và xử lý side-effect sau mỗi action được gọi. Việc này sẽ được Redux xử lý với Redux-middleware Hẹn gặp lại các bạn ở phần 2 về Redux: “Redux-middleware” 6. Nguồn tham khảo: http://redux.js.org/ https://toidicodedao.com/2016/08/18/js-truyen-ki-chuong-2-vo-lam-day-song/ https://egghead.io/lessons/javascript-redux-store-methods-getstate-dispatch-and-subscribe","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://nthung2112.github.io/tags/redux/"}]},{"title":"Những khái niệm Javascript bạn cần biết khi phỏng vấn","slug":"Nhung-khai-niem-Javascript-ban-can-biet-khi-phong-van","date":"2017-09-09T02:11:28.000Z","updated":"2018-05-18T01:01:57.921Z","comments":true,"path":"2017/09/Nhung-khai-niem-Javascript-ban-can-biet-khi-phong-van.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Nhung-khai-niem-Javascript-ban-can-biet-khi-phong-van.html","excerpt":"Tự họcCó hàng ngàn người đang học JavaScript và web development với hy vọng có được một công việc. Thường xuyên tự học những kiến thức hổng trong sự hiểu biết của con người về ngôn ngữ JavaScript. Thật ngạc nhiên là cần ít ngôn ngữ để tạo ra các trang web phức tạp. Những người làm toàn bộ các trang web thường không nắm được các nguyên tắc cơ bản của Javascript. Khá dễ dàng để tránh các chủ đề phức tạp và thực hiện các tính năng sử dụng các kỹ năng cơ bản. Cũng khá dễ để tạo ra một trang web bằng cách dựa vào Stack Overflow mà không hiểu code đang được copied.","text":"Tự họcCó hàng ngàn người đang học JavaScript và web development với hy vọng có được một công việc. Thường xuyên tự học những kiến thức hổng trong sự hiểu biết của con người về ngôn ngữ JavaScript. Thật ngạc nhiên là cần ít ngôn ngữ để tạo ra các trang web phức tạp. Những người làm toàn bộ các trang web thường không nắm được các nguyên tắc cơ bản của Javascript. Khá dễ dàng để tránh các chủ đề phức tạp và thực hiện các tính năng sử dụng các kỹ năng cơ bản. Cũng khá dễ để tạo ra một trang web bằng cách dựa vào Stack Overflow mà không hiểu code đang được copied. Nếu bạn đang tìm kiếm để làm chủ phỏng vấn JavaScript, hãy vào đây Step Up Your JS: A Comprehensive Guide to Intermediate JavaScript Phỏng vấnVấn đề là các câu hỏi kiểm tra sự hiểu biết của bạn về JS là chính xác là những công ty công nghệ yêu cầu trong các cuộc phỏng vấn của họ. Nó trở nên rất nhanh khi người ứng tuyển biết đủ để vượt qua, nhưng không có sự hiểu biết chắc chắn về ngôn ngữ này. Đây là những khái niệm được hỏi thường xuyên trong cách cuộc phỏng vấn về phát triển web. Điều này giả định bạn đã biết những điều cơ bản như loops, functions, và callbacks. Khái niệm Value vs. Reference — Understand how objects, arrays, and functions are copied and passed into functions. Know that the reference is what’s being copied. Understand that primitives are copied and passed by copying the value. Scope — Understand the difference between global scope, function scope, and block scope. Understand which variables are available where. Know how the JavaScript engine performs variable lookup. Hoisting — Understand that variable and function declarations are hoisted to the top of their available scope. Understand that function expressions are not hoisted. Closures — Know that a function retains access to the scope that it was created in. Know what this lets us do, such as data hiding, memoization, and dynamic function generation. this — Know the rules of this binding. Know how it works, know how to figure out what it will be equal to in a function, and know why it’s useful. new — Know how it relates to object oriented programming. Know what happens to a function called with new. Understand how the object generated by using new inherits from the function’s prototype property. apply, call, bind — Know how each of these functions work. Know how to use them. Know what they do to this. Prototypes &amp; Inheritance — Understand that inheritance in JavaScript works through the [[Prototype]] chain. Understand how to set up inheritance through functions and objects and how new helps us implement it. Know what the __proto__ and prototype properties are and what they do. Asynchronous JS — Understand the event loop. Understand how the browser deals with user input, web requests, and events in general. Know how to recognize and correctly implement asynchronous code. Understand how JavaScript is both asynchronous and single-threaded. Higher Order Functions — Understand that functions are first-class objects in JavaScript and what that means. Know that returning a function from another function is perfectly legal. Understand the techniques that closures and higher order functions allow us to use. Tài nguyên khácNếu các link trên chưa đủ, có vô số tài nguyên trên mạng để giúp bạn tìm hiểu những khái niệm này. Cá nhân tôi đã tạo Step Up Your JS: A Comprehensive Guide to Intermediate JavaScript để giúp các dev nâng cao kiến thức của họ. Nó bao gồm các khái niệm này và nhiều hơn nữa. Đây là những resources Tôi đã đọc hoặc xem ít nhất và có thể gợi ý cho bạn: Step Up Your JS You Don’t Know JS JavaScript is Sexy javascript.com Frontend Masters Eloquent JavaScript Chúc may mắn trong cuộc phỏng vấn của bạn.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"interview","slug":"interview","permalink":"http://nthung2112.github.io/tags/interview/"}]},{"title":"Truy cập và thay đổi các biến CSS với Javascript","slug":"Truy-cap-va-thay-doi-cac-bien-CSS-voi-Javascript","date":"2017-09-08T13:46:11.000Z","updated":"2017-09-09T01:20:21.873Z","comments":true,"path":"2017/09/Truy-cap-va-thay-doi-cac-bien-CSS-voi-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Truy-cap-va-thay-doi-cac-bien-CSS-voi-Javascript.html","excerpt":"Tại sao nó tốt hơn sử dụng biến SASSBiến trong SASS đã được sử dụng trong một thời gian. Chúng cho phép bạn định nghĩa một biến một lần lúc runtime và sử dụng biến đó ở nhiều nơi.↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓","text":"Tại sao nó tốt hơn sử dụng biến SASSBiến trong SASS đã được sử dụng trong một thời gian. Chúng cho phép bạn định nghĩa một biến một lần lúc runtime và sử dụng biến đó ở nhiều nơi.↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ Tương tác với các biến CSS với JS post-runtime.Trong bản demo này chúng ta sẽ xây dựng một form đơn giản và sẽ sử dụng JS để tự động cập nhật các biến CSS (trong trường hợp này là thay đổi color và margin của một dấu chấm) jsfiddle result JSFiddle Demo Chúng ta hãy nhìn vào những phần dưới đây: CSScss with root vars Đây là một vài thông tin về CSS :root, ở đây cũng vậy. Từ MDN: The :root CSS pseudo-class matches the root element of a tree representing the document. In HTML, :root represents the html element and is identical to the selector html, except that its specificity is higher. Các biến CSS được định nghĩa trong :root và được sử dụng ở dòng 13–14. -- là định nghĩa chuẩn của CSS cho các biến. HTMLform markup Dễ dàng ở đây, lưu ý các thuộc tính input trên type=&quot;range&quot;. Chúng giữ giá trị min và max cũng như giá trị khởi tạo value. Tương tự cho loại input type=&quot;color&quot;. Giá trị màu khởi tạo là #2cba92. JAVASCRIPTjs accessing css vars Thông tin từng dòng: 4 — lấy phần tử footer 5 — lấy tất cả input trên trang NodeList 7 — input CHANGE EventListener 8 — input MOUSEMOVE EventListener(updates dynamic margin on slide) 10 — hàm đặt lại giá trị mong muốn CSS var(chú ý chúng ta thêm px vào biến cho margin ở dòng line 14) Và đó tất cả cho Truy cập và thay đổi các biến CSS với Javascript.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"}]},{"title":"Cheatsheet cơ bản về Flexbox","slug":"Cheatsheet-co-ban-ve-Flexbox","date":"2017-09-06T00:05:26.000Z","updated":"2017-09-06T00:55:37.240Z","comments":true,"path":"2017/09/Cheatsheet-co-ban-ve-Flexbox.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Cheatsheet-co-ban-ve-Flexbox.html","excerpt":"Tổng quan về cách sử dụng flexible box layoutI spent the last days wrapping my head around flexbox, and how to use it correctly. Maybe you can relate to when I say, that it is not that easy to understand how it exactly works, or why some CSS rules don’t behave as expected under certain circumstances. In this article, I just want to give a summary of what I think is important to know. So please keep in mind that this will not be an exhaustive description of all possible CSS rules and scenarios.","text":"Tổng quan về cách sử dụng flexible box layoutI spent the last days wrapping my head around flexbox, and how to use it correctly. Maybe you can relate to when I say, that it is not that easy to understand how it exactly works, or why some CSS rules don’t behave as expected under certain circumstances. In this article, I just want to give a summary of what I think is important to know. So please keep in mind that this will not be an exhaustive description of all possible CSS rules and scenarios. What’s flexbox? Flexbox is a layout mode which is designed for laying out more complex applications and webpages. — w3.org When using the flexbox layout model we distinguish between the two main elements: flex container and flex items. The flex container is the parent element of your flex items. You set display: flex or display: inline-flex on this element to activate the flex layout mode. Before outlining the details of a flex container or flex items, I want to talk about the terminology of the flex box layout model, which I found somehow confusing in the beginning. Here’s what I found about that in the flexbox specification: An illustration of the various directions, sizing and positioning terms as applied to a ‘row’ flex container. First of all, in flexbox layout there is no horizontal or vertical. Instead, we orientate ourselves by a main axis and a cross axis. Flex items are always laid out along the main-axis. In the image above, you can see, that the main-axis for a row flex container goes from the left end of the flex container (main start) to the right end (main end). Basically, a column flex container is just a row flex container tilted by 90 degrees to the right. An illustration of the various directions, sizing and positioning terms as applied to a ‘column’ flex container. For a column flex container things would look a bit different. As you can see in the image on the left, as soon as you use flex-direction: column, the main-axis points towards the bottom of the screen, while the cross-axis goes from the right end to the left end of the flex container. So basically the whole picture is just tilted to the right, by 90 degrees. This helped me a lot to orientate myself within a column flex container, since the CSS properties change their effective direction between row and column flex containers. Now that’s all we need for now. In the following sections I’m going to describe the different CSS rules which are applicable for flex container and flex items. The Flex Container CSS RulesLet’s start with the CSS rules which are used on the flex container. I included some screenshots and put the respective CSS setting into the caption of the images. flex-directionThis rule determines if the flex-items are aligned in a row or in a column. Additionally, there is an option to align them in reverse order, heading from main-end to main-start. flex-direction: row; (default) flex-direction: column; flex-wrapIf you add more flex-items to a line, you will get to the point where there is not enough space for more. Since the flex-items shrink by default (see: flex-shrink the flex-items section) the items will get smaller the more items you add. By using flex-wrap you can control this behaviour if the items should stay in the same line (this is the default behaviour; flex-wrap: nowrap;) or wrap to the next line ( flex-wrap: wrap; or flex-wrap: wrap-reverse;) flex-wrap: nowrap; as as applied to a ‘row’ flex-containerflex-wrap: wrap; flex-flowThis is the first shorthand I will show you today. You can combine the CSS rules flex-direction and flex-wrap within one single CSS rule. The following list should speak for itself: flex-flow: row wrap; flex-flow: row wrap-reverse; flex-flow: column wrap; flex-flow: column wrap-reverse; justify-contentTo position the flex-items alongside the main axis, you can use justify-content: justify-content: flex-start; (default behaviour)justify-content: flex-end;justify-content: center;justify-content: space-between;justify-content; space-around; align-itemsNow that you learned about justify-content to lay out items along the main axis, this is an easier one. align-items is used to align items along the cross-axis on the current line. align-items: flex-start; (default behaviour)align-items: flex-end;align-items: center;align-items: stretch;align-items: baseline; As you see, align-items also allows to stretch items to use the available space in the current line, as well as align-items: baseline;aligns items along the bottom line of their first line of text. But what do you do if you don’t want to align the items within one line, but rather align the whole bunch of items within the available space of the flex-container? That’s what align-content is used for. align-contentLet’s have a look how we can align the whole bunch of flex-items within our flex container: align-content: flex-start; (default behaviour)align-content: flex-end;align-content: center;align-conent; stretch; That was a rather short overview of what you are capable to do with flex-container CSS rules. In the next section I’m going to show you how you can adjust the behaviour of flex-items. The Flex Item CSS RulesIn the last section you learned how to align all flex items at once — either within their line or within the available space of their flex container. Now it’s time to have a look at flex-grow ,flex-shrink ,flex-basis and the flex shorthand for those three rules. flex-growDefines if items cang row to use the available space along the main-axis. The default value is 0, which means that flex-items don’t grow automatically. In the following pictures you can see which effect flex-grow has on flex items in a ‘row’ and in a ‘column’ container. flex-grow: 0; (default behaviour) in a ‘row’ containerflex-grow: 1; in a ‘row’ containerflex-grow: 0; (default behaviour) in a ‘column’ containerflex-grow: 1; in a ‘column’ container With flex-grow it is also possible to let certain items grow more than others. Example: We have three items. Two of them have flex-grow set to 1, while one of them got flex-grow set to 2. What happened here? First of all, all flex-grow values of a line are added, which results in a total of 4 which represents 100% of our available space.Then each item is sized according to the relational size of its flex-grow setting to the sum of all flex-grow settings of said line. According to that calculation, the first two items get 25% of the available space and the third one gets 50%. Please note that I did not consider the padding and margin which is set in the image. flex-shrinkBy default, the shrink rule is set to 1. This means that as soon as the window is resized, the flex items will shrink if necessary. Possible values are 0 and 1. Example: The flex item of the following picture has a width of 500px. With flex-shrink set to it’s default value 1, resizing the window means that the item will shrink to less than 500px width. When setting flex-shrink to 0, the item will not shrink and would exceed the window size and a scrollbar appears. The item has a width of 500px. (Sidenote: flex-grow is switched off)flex-shrink is turned on — resizing the window also resizes the item.flex-shrink turned off. The item exceeds the window (scrollbars omitted in this picture) flex-basisThe flex basis defines the initial main-size of a flex item. This setting will be evaluated before the available space is distributed to flex-grow, or the items are resized by flex-shrink. The initial main size of the flex item before free space is distributed to the flex factors. — w3.org flex-basis accepts either a length in px || em || rem or percentages, as well as auto. If flex-basis is set to auto, the width will be calculated based on content size. So the more you increase the content of a flex item, the bigger it gets. As soon as you set a fixed size to flex-basis, the content of the item will adjust to fit into the item. flex-basis: auto;flex-basis: auto; with more contentflex-basis: 100px; The flex shorthandBecause it is way more comfortable to set the above rules all at once, there is a shorthand to do so: The default setting for this is flex: 0 1 auto; With the shorthand you define flex-grow with the first, flex-shrink with the second, and flex-basis with the third argument. It is also possible to omit the last parameter: flex: 0 1 which defaults flex-basis to zero_._ The following pictures show some examples how you can arrange flex-items using the flex shorthand. flex: 0 1 auto (default behaviour) The item size is defined by its content. flex: 0 1 auto; (default behaviour) flex: 1 1 auto flex: 1 1 auto; flex: 0 0 autoThis is the same as the example in the above section “flex-shrink”. Shrinking is turned off, which leads to the item overflowing the window size. flex: 0 0 auto; Relative size of flex-items To use the same “relative” sizing technique I described in the section “flex-grow”, you have to set flex-basis to zero. In the next picture, the first item has flex: 2 1 0; while the second item has flex: 1 1 0; The first item got 2/3 of the available size while the second one got 1/3 ConclusionWell that article grew a bit bigger than it was planned, but in the end, I hope you enjoyed the read. Maybe this article can serve as a handy guide to look up the different CSS rules if you want to brush up your knowledge, as this is something one might not memorize completely. As I said in the beginning, this was never meant to be an exhaustive list of szenarios and rules which can apply, if you are interested in this in detail, I would suggest to read the articles I mentioned in the beginning of the article, as well as parts of the specification (if you don’t want to read the whole thing) Understanding Flexbox: Everything you need to know (Ohans Emmanuel) 11 things I learned reading the flexbox spec (David Gilbertson) CSS Flexible Box Layout Module Level 1 At first, I planned to also create this as a handy cheatsheet, but then I found a really good one by Chris Coyier which I want to share with you: A Complete Guide to Flexbox Thanks for reading this article!","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"flexbox","slug":"flexbox","permalink":"http://nthung2112.github.io/tags/flexbox/"}]},{"title":"Một số SASS Mixins nên sử dụng","slug":"Mot-so-SASS-Mixins-nen-su-dung","date":"2017-09-01T02:53:15.000Z","updated":"2017-09-05T01:12:39.032Z","comments":true,"path":"2017/09/Mot-so-SASS-Mixins-nen-su-dung.html","link":"","permalink":"http://nthung2112.github.io/2017/09/Mot-so-SASS-Mixins-nen-su-dung.html","excerpt":"Danh sách một số SASS mixins mà các Web designers nên có để công việc của họ nhanh hơn. Tôi đã sử dụng SASS không quá lâu, nhưng kể từ khi tôi bắt đầu với nó, Tôi đã sử dụng một số mixins để auto một số thứ trong dự án của tôi. Mixins giống như các hàm tự động tạo ra code CSS và giúp bạn tiết kiệm viết code giống nhau lặp đi lặp lại. Có một số lượng tốt thư viện SASS mixin sẵn có trên web (eg. bourbon) một hoặc một số trong số đó bạn có thể đã sử dụng. Hoặc như tôi, bạn có thể đã tạo ra một bộ tùy chỉnh bằng cách thu thập các mixins siêu hữu ích từ web.","text":"Danh sách một số SASS mixins mà các Web designers nên có để công việc của họ nhanh hơn. Tôi đã sử dụng SASS không quá lâu, nhưng kể từ khi tôi bắt đầu với nó, Tôi đã sử dụng một số mixins để auto một số thứ trong dự án của tôi. Mixins giống như các hàm tự động tạo ra code CSS và giúp bạn tiết kiệm viết code giống nhau lặp đi lặp lại. Có một số lượng tốt thư viện SASS mixin sẵn có trên web (eg. bourbon) một hoặc một số trong số đó bạn có thể đã sử dụng. Hoặc như tôi, bạn có thể đã tạo ra một bộ tùy chỉnh bằng cách thu thập các mixins siêu hữu ích từ web.Tạo thư viện tùy chỉnh luôn luôn phục vụ tốt và gọn gàng. Bằng cách này bạn tránh thêm code không cần thiết và chỉ thêm những gì bạn thực sự cần. Dưới đây là danh sách một số SASS mixins tiện dụng Tôi đã sử dụng hằng ngày với các dự án của tôi. Một số trong số chúng được thu thập từ web, một số đơn giản là đủ để viết cho mình. Kiểm tra các đoạn mixins dưới đây, cách sử dụng ví dụ, và output của chúng: 1. Thêm kích thướcMột mixin đơn giản để cho kích thước vào một box. 1234@mixin box($width, $height=$width) &#123; width: $width; height: $height;&#125; UsageBạn phải cung cấp ít nhất một tham số để làm cho nó hoạt động: 1234567.square &#123; @include box(50px);&#125;.rectangle &#123; @include box(100px, 50px);&#125; Output123456789.square &#123; width: 50px; height: 50px;&#125;.rectangle &#123; width: 100px; height: 50px;&#125; 2. ClearfixImplementing micro-clearfix hack the SASS way. 1234567@mixin clearfix &#123; &amp;:after &#123; content: \"\"; display: table; clear: both; &#125;&#125; Usage123.cf &#123; @include clearfix;&#125; Output12345.cf:after &#123; content: \"\"; display: table; clear: both;&#125; 3. OpacityCSS Opacity with fallback for IE8+. 12345@mixin opacity($opacity) &#123; opacity: $opacity; $opacity-ie: $opacity * 100; filter: alpha(opacity = $opacity-ie); //IE8&#125; Output123.fade &#123; @include opacity(.4);&#125; Output1234.fade &#123; opacity: .4; filter: alpha(opacity = 40); //IE8&#125; 4. PositioningEasy and quick CSS positioning, thanks to Hugo Giraudel. 12345678910111213141516171819202122@mixin position($position, $args) &#123; @each $o in top right bottom left &#123; $i: index($args, $o); @if $i and $i + 1 &lt;= length($args) and type-of(nth($args, $i + 1)) == number &#123; #&#123;$o&#125;: nth($args, $i + 1); &#125; &#125; position: $position;&#125;// Positioning helpers@mixin absolute($args: '') &#123; @include position(absolute, $args);&#125;@mixin fixed($args: '') &#123; @include position(fixed, $args);&#125;@mixin relative($args: '') &#123; @include position(relative, $args);&#125; UsageYou should only use absolute(), relative(), and fixed() functions to add the respective positioning to the elements. Parameters are optional and can be given as demonstrated below: 1234567891011.menu li &#123; @include relative;&#125;.sub-menu &#123; @include absolute(top 100% left 0);&#125;.sticky-bar &#123; @include fixed(top 0 left 0);&#125; 5. Rem unitsImplementing CSS rem units with pixel fallback. 1234@mixin font-size($size, $base: 16) &#123; font-size: $size; // fallback for old browsers font-size: ($size / $base) * 1rem;&#125; Usage1234567body &#123; @include font-size(16);&#125;p &#123; @include font-size(12, 10);&#125; Bạn phải cung cấp ít nhất một giá trị khi sử dụng mixin, giá trị này sẽ được coi là font-size và sẽ được xuất ra sau khi được tính toán với font-size mặc định (16). Hoặc bạn có thể cung cấp một giá trị cơ sở khác nếu bạn muốn. Output1234body &#123; font-size: 16px; font-size: 1rem;&#125; 6. Vendor prefixingVendor prefixing made easy with full control over prefixes, customize as you use: 12345678910@mixin prefix($property, $value, $vendors: webkit moz ms o, $default: true) &#123; @if $vendors &#123; @each $vendor in $vendors &#123; #&#123;\"-\" + $vendor + \"-\" + $property&#125;: #&#123;$value&#125;; &#125; &#125; @if $default &#123; #&#123;$property&#125;: #&#123;$value&#125;; &#125;&#125; Usage123456789html &#123; @include prefix('box-sizing', 'border-box', moz webkit);&#125;*,*:before,*:after &#123; @include prefix('box-sizing', 'inherit', moz webkit);&#125; As shown above, you may provide the vendor prefixes as the 3rd parameter in the mixin, each separated by a space. Output12345678910111213html &#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;&#125;*,*:before,*:after &#123; -moz-box-sizing: inherit; -webkit-box-sizing: inherit; box-sizing: inherit;&#125; 7. Media queriesHandling CSS Media queries was never this easy: 12345678910111213141516171819202122232425@mixin screen($size) &#123; $desktop: \"(min-width: 1024px)\"; $tablet: \"(min-width: 768px) and (max-width: 1023px)\"; $mobile: \"(max-width: 767px)\"; @if $size == desktop &#123; @media only screen and #&#123;$desktop&#125; &#123; @content; &#125; &#125; @else if $size == tablet &#123; @media only screen and #&#123;$tablet&#125; &#123; @content; &#125; &#125; @else if $size == mobile &#123; @media only screen and #&#123;$mobile&#125; &#123; @content; &#125; &#125; @else &#123; @media only screen and #&#123;$size&#125; &#123; @content; &#125; &#125;&#125; Usage1234567891011.wrapper &#123; margin: 0 auto; width: 100%; @include screen('tablet') &#123; width: 90%; &#125; @include screen('desktop') &#123; width: 85%; &#125;&#125; Output1234567891011121314.wrapper &#123; margin: 0 auto; width: 100%;&#125;@media only screen and (min-width: 768px) and (max-width: 1023px) &#123; .wrapper &#123; width: 90%; &#125;&#125;@media only screen and (min-width: 1024px) &#123; .wrapper &#123; width: 85%; &#125;&#125; In place of ‘mobile’, ‘tablet’, or ‘desktop’, you may also provide a custom breakpoint values, for eg: 12345.wrapper &#123; @include screen('(min-width: 1367px)') &#123; width: 1280px; &#125;&#125; 8. Retina ImagesShow the retina images on retina-friendly devices only: 1234567891011@mixin retina($image, $width, $height) &#123; @media (min--moz-device-pixel-ratio: 1.3), (-o-min-device-pixel-ratio: 2.6/2), (-webkit-min-device-pixel-ratio: 1.3), (min-device-pixel-ratio: 1.3), (min-resolution: 1.3dppx) &#123; /* Serving 2x image on Retina display */ background-image: url($image); background-size: $width $height; &#125;&#125; Usage1234.logo &#123;background-image: url(\"img/logo.png\"); @include retina(\"img/logo@2x.png\", 100px, 21px);&#125; Output12345678910.logo &#123; background-image: url(\"img/logo.png\");&#125;@media (min--moz-device-pixel-ratio: 1.3), (-o-min-device-pixel-ratio: 2.6 / 2), (-webkit-min-device-pixel-ratio: 1.3), (min-device-pixel-ratio: 1.3), (min-resolution: 1.3dppx) &#123; .logo &#123; /* Serving HQ image on Retina display */ background-image: url(\"img/logo@2x.png\"); background-size: 100px 21px; &#125;&#125; The above example usage may not be perfect and you may add more rules for specifying width and height of the element to be optimized for retina screen. 9. CSS3 KeyframesCSS3 keyframes can’t be implemented with the vendor prefixing mixin mentioned above. The below mixin is meant to render keyframes correctly with the vendor prefixes: 12345678910111213@mixin keyframes($name) &#123; @-webkit-keyframes #&#123;$name&#125; &#123; @content; &#125; @-moz-keyframes #&#123;$name&#125; &#123; @content; &#125; @keyframes #&#123;$name&#125; &#123; @content; &#125;&#125; Usage12345678@include keyframes(animate) &#123; 50% &#123; transform: rotate(90deg); &#125; 100% &#123; transform: rotate(-90deg); &#125;&#125; Output123456789101112131415161718192021222324@-webkit-keyframes animate &#123; 50% &#123; transform: rotate(90deg); &#125; 100% &#123; transform: rotate(-90deg); &#125;&#125;@-moz-keyframes animate &#123; 50% &#123; transform: rotate(90deg); &#125; 100% &#123; transform: rotate(-90deg); &#125;&#125;@keyframes animate &#123; 50% &#123; transform: rotate(90deg); &#125; 100% &#123; transform: rotate(-90deg); &#125;&#125; 10. Background GradientQuick and simple SASS mixin to implement CSS linear gradients: 12345678910111213@mixin gradient($start-color, $end-color, $orientation) &#123; background: $start-color; @if $orientation == 'vertical' &#123; background: -webkit-linear-gradient(top, $start-color, $end-color); background: linear-gradient(to bottom, $start-color, $end-color); &#125; @else if $orientation == 'horizontal' &#123; background: -webkit-linear-gradient(left, $start-color, $end-color); background: linear-gradient(to right, $start-color, $end-color); &#125; @else &#123; background: -webkit-radial-gradient(center, ellipse cover, $start-color, $end-color); background: radial-gradient(ellipse at center, $start-color, $end-color); &#125;&#125; Usage123.gradient &#123; @include gradient(#07c, #06f, vertical);&#125; Output12345.gradient &#123; background: #07c; background: -webkit-linear-gradient(top, #07c, #06f); background: linear-gradient(to bottom, #07c, #06f);&#125; 11. @font-face123456789101112@mixin font-face($font-name, $file-name, $weight: normal, $style: normal) &#123; @font-face &#123; font-family: quote($font-name); src: url($file-name + '.eot'); src: url($file-name + '.eot?#iefix') format('embedded-opentype'), url($file-name + '.woff') format('woff'), url($file-name + '.ttf') format('truetype'), url($file-name + '.svg##&#123;$font-name&#125;') format('svg'); font-weight: $weight; font-style: $style; &#125;&#125; Usage1@include font-face(\"MyFont\", \"path/to/MyFont\", $style: normal, $weight: normal); Output1234567@font-face &#123; font-family: \"MyFont\"; src: url(\"path/to/MyFont.eot\"); src: url(\"path/to/MyFont.eot?#iefix\") format(\"embedded-opentype\"), url(\"path/to/MyFont.woff\") format(\"woff\"), url(\"path/to/MyFont.ttf\") format(\"truetype\"), url(\"path/to/MyFont.svg#MyFont\") format(\"svg\"); font-weight: normal; font-style: normal;&#125; 12. Centering a block12345@mixin center-block &#123; display: block; margin-left: auto; margin-right: auto;&#125; Usage123.wrapper &#123; @include center-block;&#125; Output12345.wrapper &#123; display: block; margin-left: auto; margin-right: auto;&#125; 13. Vertical centering123456@mixin center-vertically &#123; position: absolute; top: 50%; left: 50%; @include prefix(transform, translate(-50%, -50%), 'webkit' 'ms');&#125; Usage123.vc-box &#123; @include center-vertically;&#125; Output12345678.vc-box &#123; position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); transform: translate(-50%, -50%);&#125; Kết thúc ở đây, hy vọng nó có ích. Vui lòng chỉ ra vấn đề hoặc chia sẻ các đề xuất của bạn qua nhận xét. Thanks :)","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"sass","slug":"sass","permalink":"http://nthung2112.github.io/tags/sass/"}]},{"title":"Hướng dẫn toàn tập về Flexbox","slug":"Huong-dan-toan-tap-ve-Flexbox","date":"2017-08-31T08:32:14.000Z","updated":"2017-09-05T01:12:39.022Z","comments":true,"path":"2017/08/Huong-dan-toan-tap-ve-Flexbox.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Huong-dan-toan-tap-ve-Flexbox.html","excerpt":"BackgroundThe Flexbox Layout (Flexible Box) module nhằm cung cấp một cách hiệu quả hơn việc bố trí, sắp xếp và cân đối không gian giữa các phần tử trong một Container, ngay cả khi kích thước của các phần tử này chưa được biết hay nói cách khác là động (flex). Mục đích chính của Flex layout là cung cấp một flex container có khả năng thay đổi các item bên trong nó chiều rộng, chiều cao, thứ tự của các item giúp cho Flex container này hiển thị tốt trên mọi thiết bị và mọi kích cỡ màn hình. Các item trong một flex container sẽ tự mở rộng để lấp đầy không gian hoặc tự co lại để ngăn chặn chống tràn (Overflow).","text":"BackgroundThe Flexbox Layout (Flexible Box) module nhằm cung cấp một cách hiệu quả hơn việc bố trí, sắp xếp và cân đối không gian giữa các phần tử trong một Container, ngay cả khi kích thước của các phần tử này chưa được biết hay nói cách khác là động (flex). Mục đích chính của Flex layout là cung cấp một flex container có khả năng thay đổi các item bên trong nó chiều rộng, chiều cao, thứ tự của các item giúp cho Flex container này hiển thị tốt trên mọi thiết bị và mọi kích cỡ màn hình. Các item trong một flex container sẽ tự mở rộng để lấp đầy không gian hoặc tự co lại để ngăn chặn chống tràn (Overflow).Quan trọng nhất, Flexbox layout dựa trên phương hướng bố trí ngược với cách bố trí bình thường (block theo chiều dọc và inline theo chiều ngang). Mặc dù những trang này hoạt động tốt, nhưng chúng thiếu tính linh hoạt để hỗ trợ các ứng dụng lớn hoặc phức tạp (đặc biệt liên quan đến thay đổi hướng, thay đổi kích cỡ, kéo dài, co lại, etc.). Chú ý: Flexbox layout là thích hợp nhất với các thành phần của một ứng dụng, và bố trí quy mô nhỏ, trong khi đó Grid layout là dành cho bố trí quy mô lớn hơn. Khái niệm cơ bản &amp; Thuật ngữFlexbox là một module toàn bộ chứ không phải một thuộc tính duy nhất, nó bao gồm rất nhiều thứ kể cả các thuộc tính. Một số trong chúng là để được đặt cho container (element cha, được gọi là “flex container”) trong khi những thứ khác là để được đặt cho children (gọi là “flex items”). Flex container là thành phần lớn bao quanh chứa các phần tử (Flex items) bên trong. Flex items là phần tử con nằm trong thành phần lớn bao quanh gọi là những Flex items, các bạn có thể sắp xếp thứ tự của các Flex items này. Nếu cách bố trí thông thường dựa trên luồng block và inline, flex layout là dựa vào “flex-flow directions”. Nhìn vào những thông số kỹ thuật và giải thích ý tưởng của flex layout ở hình bên dưới. Về cơ bản, những items sẽ được sắp xếp theo một trong hai trục chính (từ main-start đên main-end) hoặc trục dọc (từ cross-start đến cross-end). main axis - The main axis of a flex container is the primary axis along which flex items are laid out. Beware, it is not necessarily horizontal; it depends on the flex-direction property (see below). main-start | main-end - The flex items are placed within the container starting from main-start and going to main-end. main size - A flex item’s width or height, whichever is in the main dimension, is the item’s main size. The flex item’s main size property is either the ‘width’ or ‘height’ property, whichever is in the main dimension. cross axis - The axis perpendicular to the main axis is called the cross axis. Its direction depends on the main axis direction. cross-start | cross-end - Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side. cross size - The width or height of a flex item, whichever is in the cross dimension, is the item’s cross size. The cross size property is whichever of ‘width’ or ‘height’ that is in the cross dimension. Properties for the Parent (flex container) displayĐây là định nghĩa một flex container; inline hoặc block tùy thuộc vào giá trị nhất định. Nó cho phép một flex context cho tất cả con trực tiếp của nó. 123.container &#123; display: flex; /* or inline-flex */&#125; Chú ý rằng CSS columns không có tác dụng trong vùng flex container. flex-direction Định nghĩa này cho trục chính, do đó định nghĩa direction flex items đặt ở trong flex container. Flexbox là một khái niệm layout đơn hướng. Hãy nghĩ flex items là chủ yếu đặt trong hàng ngang hoặc cột dọc. 123.container &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row (default): từ trái sang phải trong ltr; từ phải sang trái rtl row-reverse: phải sang trái trong ltr; trái sang phải trong rtl column: giống như row nhưng từ trên xuống dưới column-reverse: giống như row-reverse nhưng từ trên xuống dưới flex-wrap Mặc định, flex items sẽ cố gắng đặt vào 1 dòng. Bạn có thể thay đổi điều đó và những items sẽ wrap khi có thuộc tính này. 123.container&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap (default): các flex items sẽ được hiển thị trên một dòng wrap: các flex items sẽ hiển thị thành nhiều dòng, từ trên xuống dưới. wrap-reverse: các flex items sẽ hiển thị thành nhiều dòng từ dưới lên trên. Có một vài ví dụ thực tế của flex-wrap ở đây. flex-flow (Áp dụng cho: phần tử cha flex container)Đây là cách viết gọn của thuộc tính flex-direction và flex-wrap, chúng cùng nhau định nghĩa flex container’s trục chính hay trục dọc. Mặc định là row nowrap. 1flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt; justify-contentĐiều này xác định sự sắp xếp theo trục chính. It helps distribute extra free space left over when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size. It also exerts some control over the alignment of items when they overflow the line. 123.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;&#125; flex-start (default): items are packed toward the start line flex-end: items are packed toward to end line center: items are centered along the line space-between: items are evenly distributed in the line; first item is on the start line, last item on the end line space-around: items are evenly distributed in the line with equal space around them. Note that visually the spaces aren’t equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies. space-evenly: items are distributed so that the spacing between any two items (and the space to the edges) is equal. align-itemsThis defines the default behaviour for how flex items are laid out along the cross axis on the current line. Think of it as the justify-content version for the cross-axis (perpendicular to the main-axis). 123.container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start: cross-start margin edge of the items is placed on the cross-start line flex-end: cross-end margin edge of the items is placed on the cross-end line center: items are centered in the cross-axis baseline: items are aligned such as their baselines align stretch (default): stretch to fill the container (still respect min-width/max-width) align-contentThis aligns a flex container’s lines within when there is extra space in the cross-axis, similar to how justify-content aligns individual items within the main-axis. Note: this property has no effect when there is only one line of flex items. 123.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start: lines packed to the start of the container flex-end: lines packed to the end of the container center: lines packed to the center of the container space-between: lines evenly distributed; the first line is at the start of the container while the last one is at the end space-around: lines evenly distributed with equal space around each line stretch (default): lines stretch to take up the remaining space Thuộc tính của Children (flex items) orderMặc định các phần tử được sắp xếp theo giá trị nguồn html, với thuộc tính order chúng ta có thể xắp xếp lại thứ tự các phần tử theo ý muốn mà ko cần thay đổi giá trị nguồn html. 123.item &#123; order: &lt;integer&gt;;&#125; flex-growThis defines the ability for a flex item to grow if necessary. It accepts a unitless value that serves as a proportion. It dictates what amount of the available space inside the flex container the item should take up. If all items have flex-grow set to 1, the remaining space in the container will be distributed equally to all children. If one of the children has a value of 2, the remaining space would take up twice as much space as the others (or it will try to, at least). 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; Số âm không hợp lệ với thuộc tính này. flex-shrinkĐịnh nghĩa một flex item có thể khả năng thu nhỏ nếu cần thiết. 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; Số âm không hợp lệ với thuộc tính này. flex-basisĐịnh nghĩa kích thước mặc định của một phần tử trước khi phân bố không gian của phần còn lại. Nó có thể là một chiều dài (e.g. 20%, 5rem, etc.) hay một từ khóa. Từ khóa auto có nghĩa là “nhìn vào thuộc tính width hoặc height của tôi” (which was temporarily done by the main-size keyword until deprecated). The content keyword means “size it based on the item’s content” - this keyword isn’t well supported yet, so it’s hard to test and harder to know what its brethren max-content, min-content, and fit-content do. 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; If set to 0, the extra space around content isn’t factored in. If set to auto, the extra space is distributed based on its flex-grow value. See this graphic. flexĐây là viết tắt cho flex-grow, flex-shrink và flex-basis. Các thông số thứ hai và thứ ba (flex-shrink và flex-basis) là tùy chọn. Mặc định là 0 1 auto. 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; It is recommended that you use this shorthand property rather than set the individual properties. The short hand sets the other values intelligently. align-selfThis allows the default alignment (or the one specified by align-items) to be overridden for individual flex items. Please see the align-items explanation to understand the available values. 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; Note that float, clear and vertical-align have no effect on a flex item. ExamplesLet’s start with a very very simple example, solving an almost daily problem: perfect centering. It couldn’t be any simpler if you use flexbox. 12345678910.parent &#123; display: flex; height: 300px; /* Or whatever */&#125;.child &#123; width: 100px; /* Or whatever */ height: 100px; /* Or whatever */ margin: auto; /* Magic! */&#125; This relies on the fact a margin set to auto in a flex container absorb extra space. So setting a vertical margin of auto will make the item perfectly centered in both axis. Now let’s use some more properties. Consider a list of 6 items, all with a fixed dimensions in a matter of aesthetics but they could be auto-sized. We want them to be evenly and nicely distributed on the horizontal axis so that when we resize the browser, everything is fine (without media queries!). 1234567891011121314.flex-container &#123; /* We first create a flex layout context */ display: flex; /* Then we define the flow direction and if we allow the items to wrap * Remember this is the same as: * flex-direction: row; * flex-wrap: wrap; */ flex-flow: row wrap; /* Then we define how is distributed the remaining space */ justify-content: space-around;&#125; Done. Everything else is just some styling concern. Below is a pen featuring this example. Be sure to go to CodePen and try resizing your windows to see what happens. See the Pen Demo Flexbox 1. Let’s try something else. Imagine we have a right-aligned navigation on the very top of our website, but we want it to be centered on medium-sized screens and single-columned on small devices. Easy enough. 1234567891011121314151617181920212223/* Large */.navigation &#123; display: flex; flex-flow: row wrap; /* This aligns items to the end line on main-axis */ justify-content: flex-end;&#125;/* Medium screens */@media all and (max-width: 800px) &#123; .navigation &#123; /* When on medium sized screens, we center it by evenly distributing empty space around items */ justify-content: space-around; &#125;&#125;/* Small screens */@media all and (max-width: 500px) &#123; .navigation &#123; /* On small screens, we are no longer using row direction but column */ flex-direction: column; &#125;&#125; See the Pen Demo Flexbox 2. Let’s try something even better by playing with flex items flexibility! What about a mobile-first 3-columns layout with full-width header and footer. And independent from source order. 12345678910111213141516171819202122232425262728293031323334353637.wrapper &#123; display: flex; flex-flow: row wrap;&#125;/* We tell all items to be 100% width */.header, .main, .nav, .aside, .footer &#123; flex: 1 100%;&#125;/* We rely on source order for mobile-first approach * in this case: * 1\\. header * 2\\. nav * 3\\. main * 4\\. aside * 5\\. footer *//* Medium screens */@media all and (min-width: 600px) &#123; /* We tell both sidebars to share a row */ .aside &#123; flex: 1 auto; &#125;&#125;/* Large screens */@media all and (min-width: 800px) &#123; /* We invert order of first sidebar and main * And tell the main element to take twice as much width as the other two sidebars */ .main &#123; flex: 2 0px; &#125; .aside-1 &#123; order: 1; &#125; .main &#123; order: 2; &#125; .aside-2 &#123; order: 3; &#125; .footer &#123; order: 4; &#125;&#125; See the Pen Demo Flexbox 3. Prefixing FlexboxFlexbox requires some vendor prefixing to support the most browsers possible. It doesn’t just include prepending properties with the vendor prefix, but there are actually entirely different property and value names. This is because the Flexbox spec has changed over time, creating an “old”, “tweener”, and “new” versions. Perhaps the best way to handle this is to write in the new (and final) syntax and run your CSS through Autoprefixer, which handles the fallbacks very well. Alternatively, here’s a Sass @mixin to help with some of the prefixing, which also gives you an idea of what kind of things need to be done: 1234567891011121314151617181920212223242526272829303132@mixin flexbox() &#123; display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex;&#125;@mixin flex($values) &#123; -webkit-box-flex: $values; -moz-box-flex: $values; -webkit-flex: $values; -ms-flex: $values; flex: $values;&#125;@mixin order($val) &#123; -webkit-box-ordinal-group: $val; -moz-box-ordinal-group: $val; -ms-flex-order: $val; -webkit-order: $val; order: $val;&#125;.wrapper &#123; @include flexbox();&#125;.item &#123; @include flex(1 200px); @include order(2);&#125; Related Properties A Complete Guide to Grid Almanac entries on Grid properties, like grid-row / grid-column BugsFlexbox is certainly not without its bugs. The best collection of them I’ve seen is Philip Walton and Greg Whitworth’s Flexbugs. It’s an open source place to track all of them, so I think it’s best to just link to that.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"flexbox","slug":"flexbox","permalink":"http://nthung2112.github.io/tags/flexbox/"}]},{"title":"Cách thức hoạt động của Flexbox - Giải thích với ảnh gif đầy màu sắc","slug":"Cach-thuc-hoat-dong-cua-Flexbox","date":"2017-08-31T02:45:26.000Z","updated":"2017-08-31T15:55:28.617Z","comments":true,"path":"2017/08/Cach-thuc-hoat-dong-cua-Flexbox.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Cach-thuc-hoat-dong-cua-Flexbox.html","excerpt":"Flexbox hứa hẹn sẽ giải quyết nhiều vấn đề hiện đang tồn tại trong CSS thuần (ví dụ như căn chỉnh chiều dọc). Nhưng để có thể làm chủ và sử dụng được flexbox thì lại là việc không hề dễ dàng. Nguyên tắc cơ bản của Flexbox là làm cho việc dàn trang linh hoạt và trực quan hơn. Để thực hiện được điều này, các thành phần bao ngoài (containers) được tự quyết định cách phân bố các phần tử con (items) – bao gồm cả kích thước và khoảng cách giữa chúng. Điều này về nguyên tắc nghe có vẻ tốt. Nhưng chúng ta hãy xem nó có vẻ như trong thực tế.","text":"Flexbox hứa hẹn sẽ giải quyết nhiều vấn đề hiện đang tồn tại trong CSS thuần (ví dụ như căn chỉnh chiều dọc). Nhưng để có thể làm chủ và sử dụng được flexbox thì lại là việc không hề dễ dàng. Nguyên tắc cơ bản của Flexbox là làm cho việc dàn trang linh hoạt và trực quan hơn. Để thực hiện được điều này, các thành phần bao ngoài (containers) được tự quyết định cách phân bố các phần tử con (items) – bao gồm cả kích thước và khoảng cách giữa chúng. Điều này về nguyên tắc nghe có vẻ tốt. Nhưng chúng ta hãy xem nó có vẻ như trong thực tế.Trong bài viết này, chúng ta sẽ nghiên cứu 5 thuộc tính nổi trội nhất của Flexbox, khám phá chức năng cũng như cách sử dụng chúng và kết quả đạt được. Thuộc tính #1: Display: FlexHãy xem ví dụ trang web dưới đây: Có 4 thẻ divs kích cỡ khách nhau được đánh dấu với các màu khác nhau đặt trong thẻ div container màu xám. Mặc định mỗi thẻ div sẽ có thuộc tính là display: block. Mỗi ô vuông vì vậy sẽ chiếm hết bề ngang của mỗi dòng. Để bắt đầu với Flexbox, bạn cần đưa container của bạn về dạng của flex container như sau: 123#container &#123; display: flex;&#125; Chưa có thay đổi gì ngoài việc các thẻ div hiển thị trên cùng một dòng. Tuy nhiên đây lại là một sự thay đổi rất đáng kể. Chúng ta đặt tên cho vùng xung quanh đó gọi là flex context. Bây giờ bạn có thể bắt đầu định vị trí cho chúng mà không gặp nhiều khó khăn như khi sử dụng CSS thông thường Thuộc tính #2: Flex DirectionMột Flexbox container có hai trục: một trục chính và một trục dọc, mặc định hiển thị như dưới đây: Mặc định, các items được sắp xếp theo hướng của trục chính, từ trái qua phải. Đây là lí do tại sao các ô vuông hiển thị trên cùng một dòng khi bạn sử dụng display: flex. Tuy nhiên, bạn có thể thay đổi trục chính bằng thuộc tính Flex-direction. 1234#container &#123; display: flex; flex-direction: column;&#125; Có một sự khác biệt quan trọng tạo ra ở đây: flex-direction: column không sắp xếp các ô vuông trên trục dọc (across axis) thay vì trục chính (main axis). Nó làm trục chính thay đổi, xoay từ ngang thành dọc. Bạn có thể sắp xếp flex-direction theo một số cách khác như: row-reverse and column-reverse. Thuộc tính #3: Justify ContentJustify-content sắp xếp các items theo theo main axis. Chúng ta sẽ nghiên cứu chi tiết hơn về sự khác nhau giữa trục chính và trục dọc. Trước hết, hãy quay lại với flex-direction: row. 12345#container &#123; display: flex; flex-direction: row; justify-content: flex-start;&#125; Bạn có năm thuộc tính để sử dụng với justify-content: Flex-start Flex-end Center Space-between Space-around Sự khác nhau giữa space-around và space-between hơi khó để nhận ra. Với space-between, các ô vuông sẽ được căn cách đều nhau, không bao gồm khoảng cách giữa ô vuông đầu và cuối với container Space-around đặt một khoảng cách ở hai bên cạnh mỗi ô vuông — có nghĩa là khoảng cách giữa ô vuông ngoài cùng phía đầu và cuối với container sẽ bằng một nửa khoảng cách giữa các ô vuông với nhau (Giả sử mỗi ô vuông đều có một giá trị căn lề bằng nhau và không bị ghi đè, vì vậy khoảng cách giữa 2 ô vuông sẽ gấp đôi). Chú ý: Hãy nhớ rằng thuộc tính justify-content hoạt động theo trục chính, và flex-direction làm thay đổi trục chính. Đây là điều quan trọng nhất để bạn chuyển sang phần tiếp theo… Thuộc tính #4: Align ItemsNếu như bạn đã nắm được thuộc tính justify-content, align-items sẽ không khó khăn. Trong khi justify-content hoạt động theo trục chính, align-items áp dụng đối với trục dọc. Hãy thiết lập lại flex-direction thành row, để hai trục hiển thị như hình trên. Sau đó, bắt đầu đi sâu vào giá trị của align-items. flex-start flex-end center stretch baseline Ba giá trị đầu tiên chính xác là giống như justify-content, vì vậy không có gì quá lạ ở đây. Tuy nhiên, hai giá trị kế tiếp có một chút khác biệt. Với giá trị stretch, các items sẽ chiếm toàn bộ trục chính, và baseline, đáy của những tags paragraph sẽ được canh đều. (Chú ý với align-items: stretch, Tôi đã phải đặt chiều cao của ô vuông là auto. Nếu không, thuộc tính chiều cao sẽ ghi đè lên stretch.) Với baseline, hãy lưu ý rằng nếu bạn bỏ đi tags paragraph, các ô vuông sẽ được căn lề dưới như hình sau: Để minh họa rõ hơn cho trục chính và trục dọc với nó, hãy kết hợp thuộc tính justify-content và align-items và xem sự khác biệt giữa 2 giá trị center của thuộc tính flex-direction: Với dòng, các ô vuông được thiết lập dọc theo một trục chính ngang. Với cột, chúng xếp dọc theo trục chính thẳng đứng. Các ô vuông được căn giữa cả theo trục ngang và dọc trong 2 trường hợp, cả 2 trường hợp đều ko thay đổi! Thuộc tính #5: Align SelfAlign-self cho phép bạn thao tác thủ công liên kết của một phần tử riêng biệt. Nó sẽ đè lên thuộc tính align-items của 1 ô vuông. Tất cả thuộc tính đều như nhau, bởi vì mặc định nó là auto, nên các ô vuông sẽ theo thuộc tính align-items của container bao nó. 1234567#container &#123; align-items: flex-start;&#125;.square#one &#123; align-self: center;&#125;// Only this square will be centered. Hãy xem kết quả. Bạn sẽ đặt thuộc tính align-self cho 2 ô vuông, và thuộc tính align-items: center và flex-direction: row với các ô vuông còn lại. ConclusionMặc dù chỉ là những tìm hiểu cơ bản về Flexbox, tôi tin những điều này cũng cung cấp cho bạn những kiến thức để dàn trang một cách cơ bản nhất cũng như sắp xếp nội dung chính bài viết của bạn. Cảm ơn vì đã đọc!","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"flexbox","slug":"flexbox","permalink":"http://nthung2112.github.io/tags/flexbox/"}]},{"title":"Trở thành Functional Programmer - Phần 6","slug":"Tro-thanh-Functional-Programmer-Phan-6","date":"2017-08-23T16:30:13.000Z","updated":"2017-08-23T16:30:49.096Z","comments":true,"path":"2017/08/Tro-thanh-Functional-Programmer-Phan-6.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Tro-thanh-Functional-Programmer-Phan-6.html","excerpt":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP.","text":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP. Bước tiếp theo Thông qua 5 phần trước, tôi đã giới thiệu đến các bạn tất cả các concepts tuyệt vời mà FP mang lại, nhưng đồng thời cũng dấy lên trong các bạn câu hỏi : “Giờ thì sao? Liệu những kiến thức đó có thể có ích gì cho tôi trong công việc hàng ngày chứ?” Câu trả lời sẽ là tùy theo từng người. Nếu bạn có thể/đang làm việc với các ngôn ngữ Pure Functional Language như là Elm hay Haskell, thì bạn có thể tận dụng toàn bộ những kiến thức đã đề cập đến, đồng thời các ngôn ngữ đó sẽ hỗ trợ bạn trong việc vận dụng chúng một cách thuận tiện nhất. Còn nếu bạn vẫn đang tiếp tục sử dụng các ngôn ngữ Imperative như Javascript - giống như hầu hết các lập trình viên hiện nay, thì bạn vẫn có thể vận dụng những concepts đã học được, nhưng sẽ cần một vài tùy chỉnh và nguyên tắc cần tuân thủ. Functional Javascript - Code JS theo hướng Functional Javascript có thể thực hiện rất nhiều concepts của FP. Mặc dù nó không thuần khiết (pure) cho lắm, nhưng JS vẫn có lựa chọn để sử dụng khả năng immutability (tính bất biến) hoặc nếu sử dụng các thư viện đã có, thì việc hỗ trợ FP concepts còn mạnh mẽ hơn. Mặc dù áp dụng FP vào JS không hoàn toàn lý tưởng, nhưng nếu bạn có thể tận dụng một vài lợi ích từ FP thì tại sao không thử nhỉ? Immutability - Tính bất biếnĐiều đầu tiên mà ta có thể xem xét áp dụng là tính bất biến. Trong phiên bản ES2015 - hay còn gọi là ES6, có một từ khóa mới đã được giới thiệu có tên là const. Và đúng như tên gọi của từ khóa này, nó được dùng để khai báo một biến mà giá trị không thể gán lại được : 123const a = 1;a = 2; // sẽ có exception có tên là TypeError trong Chrome, Firefox hoặc Node // nhưng không có nếu dùng Safari (bản 10/2016) Ở đây biến a được khai báo là một hằng số (const) nên nó sẽ không thể được set lại giá trị nữa. Vì thế mà đoạn code a = 2 sẽ sinh ra Exception (ngoại trừ Safari). Tuy nhiên, có một vấn đề với const, đó là nó vẫn chưa hoàn toàn implement tính bất biến một cách đầy đủ. Đoạn code dưới đây sẽ thể hiện hạn chế này: 123456const a = &#123; x: 1, y: 2&#125;;a.x = 2; // KHÔNG CÓ EXCEPTION!a = &#123;&#125;; // có exception TypeError Bạn sẽ thấy rằng khi set a.x = 2 thì sẽ không gây ra lỗi. Thứ duy nhất mà từ khóa const áp dụng để kiểm tra tính bất biến chỉ là biến a. Còn tất cả những thành phần mà a có thể liên kết đến thì vẫn có thể thay đổi được (Ở đây sẽ hiểu là keyword const chỉ check a có là object vẫn tạo ra từ đầu hay không, mà không check được các thuộc tính của a bị thay đổi). Tôi thấy khá là thất vọng khi nhận ra điều này, vì nếu được implement một cách hoàn hảo, JS đã có thể trở nên tốt hơn rất nhiều. Vậy liệu có cách nào để chúng ta có thể áp dụng tính bất biến vào JS một cách toàn diện nhất không? Câu trả lời là Có thể, nhưng chúng ta phải sử dụng một thư viện có tên là Immutable. Thư viện này sẽ hỗ trợ tính bất biến tốt hơn so với const nhưng lại khiến code của chúng ta giống Java hơn là Javascript. Currying và CompositionỞ các series trước đó, chúng ta đã học được cách viết hàm hỗ trợ khả năng Currying. Dưới đây là một ví dụ phức tạp hơn: 1const f = a =&gt; b =&gt; c =&gt; d =&gt; a + b + c + d Để ý rằng phiền toái đầu tiên là chúng ta phải chỉ rõ phần currying (a =&gt; b =&gt; c =&gt; d) Và nếu phải gọi hàm f, thì mọi thứ sẽ còn phức tạp hơn 1console.log(f(1)(2)(3)(4)); // prints 10 Quá nhiều dấu ngoặc đơn như trên là đủ để khiến lập trình Lisp phải khóc ròng rồi (Lisp dùng nhiều dấu ngoặc đơn, nên nếu lập trình viên Lisp còn phải khóc trước số lượng dấu ngoặc đơn như này thì đủ thấy sự kinh khủng của dòng code trên là như nào :D) Và vì thế có rất nhiều thư viện để giải quyết vấn đề này. Và thư viện mà tôi thích nhất có tên là Ramda Khi dùng Ramda thì chúng ta có thể viết lại đoạn code trên như sau: 1234const f = R.curry((a, b, c, d) =&gt; a + b + c + d);console.log(f(1, 2, 3, 4)); // prints 10console.log(f(1, 2)(3, 4)); // also prints 10console.log(f(1)(2)(3, 4)); // also prints 10 Phần định nghĩa hàm không được cải thiện nhưng lắm, nhưng chúng ta đã loại bỏ được việc yêu cầu phải viết dấu ngoặc đơn ở phần gọi hàm phía sau. Đồng thời mỗi lần gọi hàm ‘f’, chúng ta có thể áp dụng đúng hoặc ít hơn số lượng tham số nếu muốn. Dưới đây sẽ là code viết lại hàm mult5AfterAdd10 (ở Phần 4) sử dụng Ramda: 123const add = R.curry((x, y) =&gt; x + y);const mult5 = value =&gt; value * 5;const mult5AfterAdd10 = R.compose(mult5, add(10)); Ngoài khả năng trên, Ramda còn có một số hàm đã được viết sẵn để hỗ trợ việc viết các hàm theo phong cách Currying, ví dụ như là R.add hoặc R.multiply, giúp chúng ta đỡ phải viết nhiều code hơn: 1const mult5AfterAdd10 = R.compose(R.multiply(5), R.add(10)); Các hàm Map, Reduce, Filter trong JSMột khả năng nữa của thư viện Ramda là việc cung cấp sẵn các hàm map, filter, reduce. Mặc dù các hàm này đã có trong Array.prototype của JS core, nhưng các hàm này của Ramda cao cấp hơn ở chỗ chúng là các curried function. 12345678const isOdd = R.flip(R.modulo)(2);const onlyOdd = R.filter(isOdd);const isEven = R.complement(isOdd);const onlyEven = R.filter(isEven);const numbers = [1, 2, 3, 4, 5, 6, 7, 8];console.log(onlyEven(numbers)); // prints [2, 4, 6, 8]console.log(onlyOdd(numbers)); // prints [1, 3, 5, 7] Hàm R.modulo yêu cầu 2 tham số, đầu tiên là dividend (số bị chia), tiếp theo là divisor (số chia). Biến isOdd sẽ là hàm được dùng để lấy ra phần dư của việc lấy số bị chia chia cho 2. Nếu phần dư là 0 sẽ tương đương với giá trị false, thể hiện số bị chia không phải là số lẻ, còn nếu phần dư là 1 thì sẽ tương đương với giá trị true, thể hiện số bị chia là số lẻ. Hàm R.flip được dùng để đổi vị trí giữa 2 tham số của hàm R.modulo, khiến giá trị tham số truyền vào lúc đầu sẽ là số chia (ở đây là 2).(kết quả cuối cùng khi gọi isOdd với 1 tham số sẽ trả về kết quả là tham số đó có phải là số chẵn hay không. VD isOdd(4) = false hay isOdd(5) = true). Và hàm isEven sẽ là phần bù của hàm isOdd (tức là giá trị trả về của isEven sẽ ngược với isOdd nên ta có thể sử dụng hàm R.complement) Tiếp theo, hàm onlyOdd là kết quả của hàm filter với hàm dùng để lọc dữ liệu là isOdd, và hàm này sẽ cần tham số là một mảng các số nguyên để thực hiện. Tương tự với hàm onlyEven, chỉ khác là hàm này dùng isEven là hàm để lọc dữ liệu. Khi chúng ta truyền một mảng vào tham số numbers tới hàm onlyOdd hoặc onlyEven, hàm isOdd và isEven sẽ nhận tham số là từng phần tử trong mảng và thực hiện trả về kết quả 0 hoặc 1, tương ứng với true và false, và từ đó hàm onlyOdd hoặc onlyEven sẽ giữ lại các giá trị mong muốn (chỉ số lẻ hoặc số chẵn). Những thiếu sót của Javascript Với tất cả những thư viện và những tính năng được chính JS hỗ trợ, chúng ta có thể có những bước tiến nhất định trong việc áp dụng FP vào JS. Tuy nhiên, có một sự thật không thể chối cãi rằng JS vẫn chỉ là một Imperative Language đang cố để thỏa mãn tất cả mọi người. Rất nhiều lập trình viên frontend đang mắc kẹt với JS bởi lẽ đến thời điểm hiện tại, đó hầu như là lựa chọn duy nhất và không thể tránh khỏi. Nhưng xu hướng hiện nay thì rất nhiều lập trình viên JS đang viết code JS một cách không trực tiếp. Thay vào đó, họ viết một ngôn ngữ khác và biên dịch, hay nói chính xác hơn, biến đổi chúng thành Javascript. Một trong số các ngôn ngữ cho việc trên là CoffeScript. Và với AngularJS 2, TypeScript đã được giới thiệu với tính năng tương tự. Ngoài ra thì Babel cũng được coi như một công cụ để biến đổi JS. Xu thế hiện nay cho thày càng ngày càng có nhiều người sử dụng cách tiếp cận này trong sản phẩm của mình. Nhưng hạn chế rõ ràng nhất là các ngôn ngữ này đều xuất phát từ JS và chỉ có thể làm nó tốt hơn một chút mà thôi. Vậy thì sao chúng ta không triệt để hẳn, biến đổi từ một ngôn ngữ Pure Functional Language sang JS nhỉ? Và đó chính là cách mà Elm được phát triển. Elm Trong suốt series này, chúng ta đã từng sử dụng Elm để hỗ trợ trong việc hiểu về FP. Vậy Elm là gì? Và chúng ta có thể dùng Elm như thế nào?Elm là một ngôn ngữ hoàn toàn là Pure Functional Language, mà source code được viết bởi Elm sau đó sẽ được biến đổi thành code Javascript. Và vì thế, ta có thể sử dụng Elm để tạo ra các Web Application theo Kiến Trúc Elm, hay còn gọi là TEA (kiến trúc này thực tế đã gây cảm hứng cho các kỹ sư tạo ra Redux). Ngôn ngữ Elm sẽ không có bất kỳ lỗi Runtime Error nào (lỗi khi thực hiện code). Elm đã được sử dụng trong môi trường production (môi trường sản phẩm thật) bởi các công ty như là NoRedink, mà công ty đó hiện đang có Evan Czapliki - người tạo ra Elm - làm việc (trước đây ông đã làm cho Prezi). Để biết thêm chi tiết, mời các bạn tham khảo bài nói chuyện 6 tháng làm Elm với production, được tạo ra bởi Richard Feldman và những tín đồ Elm. Liệu tôi có phải thay đổi tất cả code JS của mình bằng Elm không?Không. Bạn có thể thay thế từng phần một. Bài viết sau đây sẽ mô tả chi tiết khả năng này : Làm thế nào để sử dụng Elm trong công việc Vì sao học Elm? Làm việc với một ngôn ngữ Pure Functional Language vừa có sự hạn chế và sự tự do. Sự hạn chế đến từ việc bạn không thể làm những thứ đã làm được trước đó (mà những thứ này hầu hết lại giới hạn output mà bạn có thể tạo ra), nhưng đồng thời, sự tự do sẽ được thể hiện ở những phần mềm không có lỗi, có thiết kế tốt, bởi lẽ các phần mềm được viết bởi Elm sẽ tuân theo TEA (Kiến trúc Elm), một mô hình phù hợp với FP. FP sẽ giúp bạn trở thành một lập trình viên chất lượng hơn. Tất cả các ý tưởng trong series bài viết này chỉ là những phần trên của tảng băng trôi. Chỉ khi áp dụng chúng vào trong thực tế, bạn mới biết được sự lợi hại và hữu ích của FP trong việc phát triển các phần mềm phù hợp với nhiều yêu cầu, đồng thời tăng trưởng một cách ổn định. Javascript là một ngôn ngữ được viết trong 10 ngày, sau đó được chỉnh sửa trong 2 thập kỉ gần đây để cố gắng trở thành một ngôn ngữ vừa functional, vừa hướng đối tượng, trong khi bản chất vẫn là một imperative language. Trong khi đó, Elm được thiết kế dựa trên 30 năm kinh nghiệm làm việc với Haskell, và hàng thập kỷ nghiên cứu trong toán học cũng như khoa học máy tính. Đồng thời kiến trúc Elm(TEA) đã được thiết kế và tinh chỉnh hàng năm trời, và là kết quả từ luận văn của Evan về vấn đề hỗ trợ functional của các ngôn ngữ lập trình. Bạn có thể tham khảo bài nói Watch Controlling Time and Space để biết rõ hơn Evan đã hiện thực hóa ý tưởng của mình như thế nào khi thiết kế ra TEA Elm được thiết kế cho lập trình viên frontend. Mục tiêu của nó là khiến cuộc đời lập trình viên dễ thở hơn. Mời tham khảo bài nói Let’s be Mainstream để hiểu rõ hơn mục tiêu này. Tương lai Việc biết trước tương lai sẽ diễn biến như thế nào là bất khả thi, nhưng chúng ta có thể có một vài dự đoán có cơ sở. Dưới đây là các dự đoán của tôi về tương lai: Sẽ có thêm nhiều ngôn ngữ được viết để biến đổi ra JS.Các ý tưởng của FP đã tồn tại trên 40 năm sẽ được tái nhìn nhận và sử dụng để giải quyết những vấn đề phức tạp của phần mềm hiện nayHiện trạng của các thiết bị phần cứng hiện nay, như hàng Gigabytes bộ nhớ giá rẻ và chip xử lý nhanh sẽ biến các kỹ thuật FP thành khả thiCPUs sẽ tăng trưởng theo hướng có nhiều nhân hơn là tăng tốc độ xử lýPhần mềm có trạng thái biến đổi khi thực hiện sẽ được coi là một trong những vấn đề lớn nhất trong các hệ thống phần mềm phức tạp. Lý do khiến tôi viết series này là bởi vì tôi tin rằng FP sẽ là tương lai của ngành phần mềm, và bởi vì tôi cũng đã tốn vài năm để học nó (hiện tại tôi vẫn đang tiếp tục học FP) Nên mục tiêu của tôi với bài viết này là để giúp mọi người có thể hiểu được những concepts của FP một cách dễ dàng và nhanh chóng hơn so với tôi, đồng thời nếu có thể - giúp các bạn trở thành những lập trình viên tốt hơn, và có sự nghiệp sáng giá trong tương lai. Kể cả việc dự đoán rằng Elm sẽ là một ngôn ngữ phát triển trong tương lai của tôi có thể sai, thì tôi vẫn có thể tự tin khẳng định rằng FP và Elm sẽ nằm trên quỹ đạo chuyển động của tương lai - cho dù đó là tương lai nào đi nữa. Hy vọng rằng sau series này, mọi người sẽ tự tin hơn vào khả năng của mình, cũng như củng cố, nắm vững được những concepst mà tôi đã giới thiệu. Lời cuối cùng, chúc mọi người may mắn trong những nỗ lực phía trước. Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: Learn Elm Programming Và đây là Twitter của tác giả : @cscalfani","categories":[],"tags":[]},{"title":"Trở thành Functional Programmer - Phần 5","slug":"Tro-thanh-Functional-Programmer-Phan-5","date":"2017-08-23T16:28:13.000Z","updated":"2017-08-24T00:53:11.555Z","comments":true,"path":"2017/08/Tro-thanh-Functional-Programmer-Phan-5.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Tro-thanh-Functional-Programmer-Phan-5.html","excerpt":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP.","text":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP. Concept 8 : Referential Transparency - Tham chiếu minh bạch Referential Transparency - Tham chiếu minh bạch là một cụm từ khá là màu mè được dùng để mô tả khả năng của pure function (nếu chưa rõ pure function là gì, mời xem lại Phần 1) khi các vị trí sử dụng pure function đều có thể được thay thế bằng phần định nghĩa của chính nó (nói đơn giản là chỗ nào gọi hàm thì đều có thể thay thế bằng phần thân - các biểu thức định nghĩa hàm). Ví dụ dưới đây sẽ giúp chúng ta hiểu rõ hơn. Giả sử ta có một biểu thức toán học khá quen thuộc như sau : y = x + 10 Và khi gán giá trị cụ thể cho x: x = 3 Thì chúng ta có thể thay thế 3 ở vị trí của x vào biểu thức, khiến biểu thức trở thành : y = 3 + 10 Có thể thấy là y = 3 + 10 vẫn là một biểu thức hoàn toàn hợp lệ. Và với pure function, việc thay thế tương tự như trên là hoàn toàn có thể. Dưới đây là một hàm trong Elm được dùng để thêm dấu nháy đơn vào trước và sau một String : 12quote str = &quot;&apos;&quot; ++ str ++ &quot;&apos;&quot; Và đây là một ngữ cảnh dùng hàm ở trên: 12findError key = &quot;Unable to find &quot; ++ (quote key) Ở đấy hàm findError sẽ xuất ra một message thông báo lỗi khi việc tìm kiếm key không thành công. Vì hàm quote là một pure function, chúng ta có thể thay thế việc gọi hàm đó trong thân hàm findError bằng chính phần thân hàm của hàm quote như sau : 12findError key = &quot;Unable to find &quot; ++ (&quot;&apos;&quot; ++ str ++ &quot;&apos;&quot; ) Việc thay thế này tôi gọi là Tái cấu trúc ngược - Reverse Refactoring (vì nó nghe hợp tai thôi), và được định nghĩa là quá trình có thể được sử dụng bởi lập trình viên hoặc chương trình phần mềm (ví dụ như bộ biên dịch - compiler hay là phần mềm test) để hiểu về ý nghĩa và luồng hoạt động của code, đặc biệt khi tìm hiểu các hàm đệ quy. Execution Order - Thứ tự thực hiện Hầu hết các phần mềm hiện nay đều là đơn luồng (single-thread), có nghĩa là trong một thời điểm, có một và chỉ một đoạn code được thực hiện. Ngay cả khi bạn làm ra một phần mềm theo hướng đa luồng, hầu hết các luồng sẽ bị chặn và phải chờ cho các tác vụ xử lý I/O hoàn thành (tác vụ I/O là các tác vụ liên quan đến xử lý input và output của hệ thống như file, network,... Dưới đây là một cách lý giải cho việc chúng ta thường sẽ nghĩ theo các bước tuần tự khi viết code. Trước hết hãy xem ví dụ sau : 1234567891. Lấy bánh mỳ 2. Đặt 2 lát bánh mỳ vào máy nướng3. Chọn mức nướng4. Bấm nút bắt đầu nướng5. Chờ cho đến khi bánh mỳ nướng xong6. Cất máy nướng 7. Lấy bơ 8. Lấy dao cắt bơ9. Phết bơ vào bánh mỳ nướng Nhìn vào các bước thực hiện cho việc tạo ra bánh mỳ nướng bơ ở trên, chúng ta có thể thấy có 2 luồng hoạt động độc lập : Lấy bơ và nướng bánh. Và 2 luồng hoạt động này chỉ tương tác với nhau ở bước cuối cùng - bước thứ 9. Vì thế chúng ta có thể thực hiện 2 công việc sau song song với nhau : 1 việc bao gồm các bước từ 1 đến 6, và 1 việc bao gồm 2 bước 7 và 8. Và ta sẽ đưa 2 công việc này thành 2 luồng. Nhưng khi chúng ta làm như vậy, mọi thứ sẽ trở nên phức tạp hơn : Luồng thứ 1 Lấy bánh mỳ Đặt 2 lát bánh mỳ vào máy nướng Chọn mức nướng Bấm nút bắt đầu nướng Chờ cho đến khi bánh mỳ nướng xong Cất máy nướng Luồng thứ 2 Lấy bơ Lấy dao cắt bơ Chờ luồng thứ nhất thực hiện xong Phết bơ vào bánh mỳ nướng Ở đây luồng thứ 2 có thêm một công việc là chờ luồng thứ 1 thực hiện xong. Vậy điều gì sẽ xảy ra với luồng thứ 2 nếu luồng thứ 1 thất bại? Nguyên tắc và cách thức để 2 luồng có thể giao tiếp và hợp tác với nhau là gì? Ai sẽ sở hữu bánh mỳ nướng: Luồng 1, luồng 2, hay cả hai? Tất cả các câu hỏi trên sẽ xảy ra khi chúng ta muốn làm đa luồng, và nếu cứ để nguyên ở dạng đơn luồng, chúng ta có thể bỏ qua không cần phải suy nghĩ gì đến các vấn đề phức tạp ở trên. Vậy là bạn đã hiểu lý do vì sao con người luôn tự nhiên suy nghĩ và thực hiện công việc theo một luồng có thứ tự duy nhất rồi chứ. Nhưng chúng ta cần nâng cao tối đa hiệu năng của phần mềm bằng mọi cách có thể, nên việc áp dụng đa luồng sẽ trở thành một điều ta cần nỗ lực để có thể đạt được những kết quả đáng ghi nhận. Tuy nhiên, sẽ có 2 vấn đề khi làm việc với đa luồng. Đầu tiên, các phần mềm đa luồng sẽ rất khó để viết, đọc, lý giải, test và debug (đương nhiên rồi). Thứ hai, một số ngôn ngữ như Javascript thì không hỗ trợ đa luồng, hoặc các ngôn ngữ có hỗ trợ thì hỗ trợ một cách nghèo nàn. Nhưng sẽ ra sao nếu thứ tự thực hiện bỗng chốc trở nên không còn quan trọng nữa, mọi thứ có thể thực hiện song song? Điều này nghe có vẻ điên rồ, nhưng tôi sẽ cho bạn thấy rằng nó có thể. Hãy xem một đoạn code Elm mô tả cho lý luận trên: 12345678buildMessage message value = let upperMessage = String.toUpper message quotedValue = &quot;&apos;&quot; ++ value &quot;&apos;&quot; in upperMessage ++ &quot;: &quot; ++ value Ở đây hàm buildMessage nhận 2 tham số là message và value, sau đó sẽ trả về message phiên bản chữ hoa, kèm với một dấu hai chấm và value nằm trong dấu nháy đơn. Trong hàm này 2 biến upperMessage và quotedValue là độc lập với nhau. Ta sẽ cùng tìm hiểu lý do vì sao có thể kết luận được như vậy? Để xét về tính độc lập, sẽ có 2 nội dung cần được xác nhận là đúng. Thứ nhất, các đối tượng được xét đến đều phải là pure function. Điều này là cực kỳ quan trọng bởi vì các đối tượng này phải biệt lập với các xử lý khác bên ngoài. Nếu các đối tượng này không pure, chúng ta sẽ không bao giờ biết được chúng có độc lập hay không. Và trong trường hợp đó, ta sẽ phải dựa vào thứ tự được gọi của các hàm này được viết trong code để xác định thứ tự thực hiện của chúng. Và đó là cách mà các ngôn ngữ Imperative hoạt động. Thứ hai, để xác định tính độc lập, thì output của một hàm không được các hàm còn lại lấy làm input. Nếu điều này bị vi phạm, thì chúng ta sẽ phải chờ một hàm được thực hiện xong thì mới thực hiện tiếp hàm còn lại, và điều này thì khiến chúng không còn độc lập nữa. Trong ví dụ tôi vừa nêu, cả upperMessage và quotedValue đều là kết quả của 2 hàm pure và chúng đều không yêu cầu output của lẫn nhau. Do đó, 2 hàm này có thể thực hiện theo BẤT KỲ THỨ TỰ NÀO. Bộ biên dịch (compiler) - vì thế có thể tự quyết định thứ tự thực hiện của 2 hàm trên mà không cần sự chỉ đạo cụ thể của người lập trình. Việc này chỉ có thể khả thi với các ngôn ngữ được xác định là Pure Functional Language (là các ngôn ngữ FP mà các biểu thức - expression đều là pure - hay nói cách khác, không tạo ra side-effect), bởi vì nếu không sẽ rất khó, thậm chí là không thể xử lý các side-effect khi chúng xảy ra. Thứ tự thực hiện trong các ngôn ngữ Pure Functional Language có thể được quyết định bởi trình biên dịch (compiler). Đây thực sự là một lợi ích hiển nhiên khi trong thời đại ngày nay, các bộ vi xử lý thay vì được nâng cao tốc độ thì chúng sẽ được trang bị ngày càng nhiều nhân hơn. Việc thứ tự thực hiện có thể được quyết định bởi trình biên dịch sẽ khiến cho code có thể được chạy song song trên nhiều nhân một lúc, và vì thế, hiệu năng sẽ được nâng cao. Đáng tiếc là với các ngôn ngữ Imperative, chúng ta không thể tận dụng tối đa việc CPU có nhiều nhân, trừ khi có sự thay đổi ở phần thấp, thậm chí là lõi của ngôn ngữ, mà khi đó thì sẽ kéo theo rất nhiều thay đổi trong kiến trúc của các phần mềm viết ra dựa trên các ngôn ngữ đó. Với các ngôn ngữ Pure Functional Language, chúng ta sẽ có tiềm năng vận dụng các nhân của CPU một cách hiệu quả nhất mà không cần phải thay đổi bất cứ dòng code nào. Type Annotation - Xác định kiểu dữ liệu Trong các ngôn ngữ có kiểu dữ liệu tĩnh (Statically Typed Language), kiểu được định nghĩa trong cùng 1 dòng. Dưới đây là một đoạn code Java để tham khảo : 123public static String quote(String str) &#123; return &quot;&apos;&quot; + str + &quot;&apos;&quot;;&#125; Bạn hãy để ý phần xác định kiểu trả về của hàm và của tham số đều được viết trong cùng dòng với phần định nghĩa hàm. Và khi ta dùng generics, thì nhìn còn tệ hơn nữa : 123private final Map&lt;Integer, String&gt; getPerson(Map&lt;String, String&gt; people, Integer personId) &#123; // ...&#125; Ở đây các phần dùng để xác định kiểu dữ liệu sẽ là Map&lt;Integer, String&gt;, Map&lt;String, String&gt;, Integer, và bởi vì chúng nằm lẫn với phần định nghĩa hàm, chứa cả tên hàm và các biến, nên chúng ta sẽ mất thời gian và cần nhiều sự tập trung để có thế tìm ra tên các tham số. Ngược lại, với các ngôn ngữ có kiểu dữ liệu động (Dynamically Typed Language), chúng ta không gặp phải vấn đề ở trên. Ví dụ như với Javascript, hàm ở trên sẽ chỉ cần viết như sau là đủ : 123var getPerson = function(people, personId) &#123; //...&#125;; Có thể thấy rằng phiên bản bằng JS ở trên dễ đọc hơn rất nhiều vì ko có những khai báo kiểu dữ liệu loằng ngoằng như với phiên bản của Java. Vấn đề duy nhất ở đây là mặc dù dễ đọc hơn, nhưng chúng ta đã phải bỏ qua sự an toàn khi định nghĩa rõ kiểu dữ liệu. Ta có thể dễ dàng truyền vào các biến có kiểu không phù hợp, như là một số cho biến people hoặc một Object cho biến personID. Và việc truyền nhầm kiểu dữ liệu này chỉ có thể phát hiện đến khi các đoạn code được thực hiện, nên có thể sẽ xảy ra lỗi sau khi chúng ta đã đưa code lên môi trường thật hàng tháng trời. Nhưng với Java thì sẽ không gặp lỗi này, và sẽ được phát hiện khi code được biên dịch (compile). Đó là những điểm lợi và bất lợi giữa kiểu dữ liệu động và tĩnh, và nếu chúng ta có thể kết họp ưu điểm của cả hai, bao gồm syntax đơn giản dễ hiểu bên phía Javascript và sự an toàn khi định rõ kiểu dữ liệu bên Java, thì chẳng phải sẽ rất tuyệt hay sao? Và thực tế là chúng ta có thể làm được. Đây là một ví dụ về một hàm trong Elm với việc định rõ kiểu dữ liệu: 123add : Int -&gt; Int -&gt; Intadd x y = x + y Hãy để ý rằng thông tin về kiểu dữ liệu của tham số và giá trị trả về của hàm được viết bằng một dòng riêng biệt. Và sự tách riêng như này đem đến rất rất nhiều điều khác biệt. Nếu lần đầu nhìn vào đoạn code trên, bạn có thể nghĩ rằng phần khai báo thông tin kiểu dữ liệu (dòng đầu tiên) có lỗi đánh máy. Tôi cũng đã từng cảm thấy như vậy. Lúc đó tôi đã nghĩ dấu -&gt; đầu tiên nên là dấu phẩy. Nhưng thực tế thì câu lệnh đó hoàn toàn chính xác. Nếu đặt thêm vài dấu đóng mở ngoặc, bạn sẽ bắt đầu thấy nó có vẻ hợp lý hơn : 1add : Int -&gt; ( Int -&gt; Int) Biểu thức ở trên chỉ ra rằng hàm add là một hàm có một tham số có kiểu Int và trả về một hàm cũng có một tham số kiểu Intvới kết quả trả về là một giá trị Int. Dưới đây là một khai báo hàm phức tạp hơn một chút: 123doSomething : String -&gt; (Int -&gt; (String -&gt; String))doSomething prefix value suffix = prefix ++ (toString value) ++ suffix Đoạn code trên được dùng để khai báo một hàm có tên là doSomething sẽ nhận một tham số có kiểu String, và trả về 1 hàm (tạm gọi là hàm A). Hàm A là hàm nhận một tham số có kiểu Int, và trả về 1 hàm (hàm B). Hàm B là hàm nhận một tham số có kiểu String, và trả về kết quả là giá trị kiểu String. Có thể thấy rằng tất cả các hàm đều chỉ có một tham số. Đó là bởi tất cả các hàm trong Elm đều hỗ trợ Currying. Và bởi vì dấu ngoặc đơn luôn được đặt vào từ phía ngoài cùng bên phải, lần lượt theo từng dấu mũi tên nên chúng ta có thể bỏ qua không cần chỉ định rõ, và kết quả sẽ là: 1doSomething : String -&gt; Int -&gt; String -&gt; String Dấu ngoặc đơn chỉ thực sự cần thiết khi chúng ta muốn truyền hàm trong tham số. Nếu không sử dụng chúng thì việc xác định kiểu dữ liệu sẽ trở nên mù mờ. Ví dụ: 123takes2Params : Int -&gt; Int -&gt; Stringtakes2Params num1 num2 = -- do something sẽ khác hoàn toàn so với : 123takes1Param : (Int -&gt; Int) -&gt; Stringtakes1Param f = -- do something take2Params là một hàm yêu cầu 2 tham số Int, để có thể trả về giá trị kiểu String. Nhưng take1Param là hàm yêu cầu 1 tham số là một hàm f, mà hàm f đó có 1 tham số là Int và trả về kết quả là Int. Và đây là phần định kiểu dữ liệu cho hàm map chúng ta đã dùng ở phần trước 123map : (a -&gt; b) -&gt; List a -&gt; List bmap f list = // ... Ở đây dấu ngoặc đơn là cần thiết bởi vì hàm f dùng trong hàm map sẽ có kiểu là (a -&gt; b), với ý nghĩa là một hàm nhận vào giá trị kiểu a và trả về giá trị kiểu b. Chữ a ở đây được hiểu với nghĩa là bất kỳ kiểu nào. Nếu một kiểu có ký tự hoa, thì nó sẽ là một kiểu cụ thể, ví dụ như String. Còn nếu một kiểu chỉ có ký tự thường, nó có thể là bất cứ kiểu dữ liệu nào. Vì thế kiểu a có thể là String hay Int đều được. Nếu bạn nhìn thấy kiểu định nghĩa hàm là (a -&gt; a) thì nó sẽ có ý nghĩa là kiểu dữ liệu của tham số và giá trị trả về PHẢI giống nhau, mặc dù có thể là bất kỳ kiểu dữ liệu nào (tức là nếu hàm nhận input kiểu Int thì phải trả về kiểu Int, nhận input kiểu String thì phải trả về kiểu String). Nhưng trong trường hợp của hàm map được viết là (a -&gt; b). Điều đó có nghĩa là hàm f Có thể trả về kiểu dữ liệu khác với tham số nhưng CŨNG có thể trả về kiểu dữ liệu giống với kiểu của tham số. Nhưng khi kiểu của a đã được xác định, thì a sẽ mang kiểu đó trong suốt phần định nghĩa kiểu dữ liệu của hàm. Ví dụ nếu a là kiểu Int và b là String thì định nghĩa kiểu dữ liệu phía trên của hàm map sẽ tương đương với : 1(Int -&gt; String) -&gt; List Int -&gt; List String Bạn sẽ thấy rằng tất cả các chỗ dùng a trong định nghĩa kiểu dữ liệu đã được thay thế bằng Int (ở phần định nghĩa hàm f có (a -&gt; b), cũng như phần tham số thứ 2 là List a), và tất cả các chỗ dùng b đều được thay thế bằng String. Kiểu dữ liệu List Int có nghĩa là một danh sách chứa các phần tử có kiểu Int, và List String tương đương với một danh sách chứa các phần tử có kiểu String. Nếu bạn đã từng sử dụng generics trong Java hoặc các ngôn gnữu khác, thì hẳn bạn sẽ thấy quen thuộc với concept này (ví dụ trong Java là List&lt;T&gt;). Đầu của tôi!!!! Hôm nay đến đây thôi là đủ. Trong phần tiếp theo, cũng là phần cuối cùng của series này, tôi sẽ đề cập đến việc sử dụng tất cả những concept mà tôi đã giới thiệu vào công việc hàng ngày như thế nào, cụ thể sẽ là trong việc lập trình Javascript nhưng theo hướng functional, và lập trình với Elm. Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: Learn Elm Programming Và đây là Twitter của tác giả : @cscalfani","categories":[],"tags":[]},{"title":"Trở thành Functional Programmer - Phần 4","slug":"Tro-thanh-Functional-Programmer-Phan-4","date":"2017-08-23T16:26:54.000Z","updated":"2017-08-24T00:53:04.969Z","comments":true,"path":"2017/08/Tro-thanh-Functional-Programmer-Phan-4.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Tro-thanh-Functional-Programmer-Phan-4.html","excerpt":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP.","text":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP. Concept 7 : Currying Tiếp tục câu chuyện ở cuối Phần 3 , lý do khiến chúng ta gặp phải vấn đề trong việc kết hợp hai hàm mul5 và add là bởi vì hàm mult5 có 1 tham số, trong khi hàm add lại có 2. Chúng ta có thể giải quyết vấn đề này bằng cách giới hạn lại mỗi hàm chỉ lấy một tham số. Nghe có vẻ hơi kỳ kỳ, nhưng tin tôi đi, ý tưởng này không tệ một chút nào đâu. Chúng ta sẽ chỉ đơn giản là viết một hàm add vẫn có hai tham số, nhưng có khả năng nhận giá trị cho một tham số trong một thời điểm. Và hàm hỗ trợ khả năng này được biết đến với cái tên là Curried Function. Một Curried Fuction là một hàm chỉ nhận một tham số trong một thời điểm. Điều này sẽ cho phép chúng ta gán giá trị tham số đầu tiên của hàm add trước khi kết hợp với hàm mult5. Và sau đó khi hàm mult5AfterAdd10 được gọi, hàm add sẽ nhận giá trị tham số thứ hai. Trong Javascript, chúng ta có thể đạt được điều này bằng cách viết lại hàm add như sau: 1var add = x =&gt; y =&gt; x + y Phiên bản này của hàm add sẽ nhận hai tham số gồm x và y, nhưng một tham số (x) sẽ được set khi gọi hàm lần đầu tiên và tham số còn lại (y) sẽ được set khi gọi hàm lần thứ 2. Cụ thể hơn, đầu tiên, hàm add sẽ nhận giá trị cho tham số x, và trả về một hàm mới với một tham số có tên là y, với giá trị kết quả trả về là tổng của hai tham số x và y. Và bây giờ chúng ta có thể sử dụng phiên bản trên của hàm add để tạo ra hàm mult5AfterAdd10 như mong muốn : 12var compose = (f, g) =&gt; x =&gt; f(g(x));var mult5AfterAdd10 = compose(mult5, add(10)); Hàm compose sẽ nhận 2 tham số là f và g, và trả về một hàm nhận 1 tham số x, mà khi được gọi sẽ thực hiện lần lượt 2 hàm g và f lên với tham số nhận được (gọi hàm g(x), kết quả nhận được truyền vào hàm f, tương đương với việc gọi f(g(x))). Vậy chính xác ta đã làm gì? Theo lý thuyết thì ta đã tạo ra một phiên bản curried function của hàm add truyền thống. Việc này làm hàm add trở nên linh động hơn, bởi vì 2 tham số có thể được set ở 2 thời điểm khác nhau. Tham số đầu tiên, 10 được truyền vào để tạo ra hàm mult5AfterAdd10, và tham số thứ 2 được truyền vào khi thực hiện hàm mul5AfterAdd10 với một tham số bất kỳ. Đến đây, bạn có thể nghĩ rằng làm thế nào để viết lại hàm add theo phong cách trên bằng ngôn ngữ Elm. Tôi xin giải đáp luôn là bạn không cần phải làm thế đâu. Trong Elm và các ngôn ngữ FP khác, tất cả các hàm đều là curried function. Vậy là hàm add trong Elm vẫn giữ nguyên cách khai báo : 12add x y = x + y Và đây là cách mà hàm mult5AfterAdd10 nên được viết: 12mult5AfterAdd10 = (mult5 &lt;&lt; add 10) Về mặt cú pháp, có thể nói rằng Elm đã đánh bại hoàn toàn Javascript cũng như các ngôn ngữ Imperative khác bởi vì nó đã được tối ưu cho những concept cơ bản của FP như là Currying hay Composition. Currying và Tái cấu trúc code Ngoài khả năng dùng để tạo ra các hàm hợp như đã mô tả ở trên, Currying còn rất hữu ích khi chúng ta thực hiện tái cấu trúc code. Đó là khi ta muốn tạo một hàm tổng với rất nhiều tham số, và sau đó sử dụng nó để tạo ra các hàm cụ thể phù hợp với từng ngữ cảnh sử dụng, mà yêu cầu ít tham số hơn. Lấy ví dụ, khi chúng ta có 2 hàm sau đây dùng để thêm 1 hoặc 2 dấu ngoặc nhọn vào trước và sau 1 String: 1234bracket str = &quot;&#123;&quot; ++ str ++ &quot;&#125;&quot;doubleBracket str = &quot;&#123;&#123;&quot; ++ str ++ &quot;&#125;&#125;&quot; Và đây là một số ngữ cảnh chúng ta sẽ sử dụng 2 hàm đó : 1234bracketedJoe = bracket &quot;Joe&quot;doubleBracketedJoe = doubleBracket &quot;Joe&quot; Chúng ta có thể tổng quát hóa 2 hàm bracket và doubleBracket thành 1 hàm như sau : 12generalBracket prefix str suffix = prefix ++ str ++ suffix Nhưng như vậy thì mỗi khi sử dụng hàm generalBracket, chúng ta sẽ phải truyền thêm giá trị dấu đóng/mở ngoặc : 1234bracketedJoe = generalBracket &quot;&#123;&quot; &quot;Joe&quot; &quot;&#125;&quot;doubleBracketedJoe = generalBracket &quot;&#123;&#123;&quot; &quot;Joe&quot; &quot;&#125;&#125;&quot; Cái chúng ta thực sự muốn là tập hợp các lợi ích của cả 2 cách: sử dụng đơn giản (truyền mỗi String vào hàm), nhưng không được lặp code. Nếu chúng ta sắp xếp lại thứ tự các tham số của hàm generateBracket, chúng ta có thể tạo ra 2 hàm bracket và doubleBracket vì hàm generateBracket vốn đã hỗ trợ Currying rồi: 123456generalBracket prefix suffix str = prefix ++ str ++ suffixbracket = generalBracket &quot;&#123;&quot; &quot;&#125;&quot;doubleBracket = generalBracket &quot;&#123;&#123;&quot; &quot;&#125;&#125;&quot; Để ý rằng bằng việc đưa các tham số có vẻ như sẽ được set cố định trước lên đầu tiên, trong ví dụ này là prefix và suffix, và đưa các tham số sẽ được set sau cùng vào phía sau, chúng ta có thể tạo ra các phiên bản cụ thể và phù hợp với nhu cầu sử dụng từ hàm generalBracket. Thứ tự các tham số là rất quan trọng trong việc tận dụng khả năng Currying. Đồng thời, ta cũng có thể nhận thấy là các hàm bracket và doubleBracket đều được viết dưới dạng Point-free Notation, cụ thể trong trường hợp này tham số str được loại bỏ. Cả 2 hàm bracket và doubleBracket đều là những hàm đang chờ đợi tham số cuối cùng. Và giờ chúng ta có thể sử dụng 2 hàm đó như trước khi tái cấu trúc code : 1234bracketedJoe = bracket &quot;Joe&quot;doubleBracketedJoe = doubleBracket &quot;Joe&quot; Nhưng lần này chúng ta đã sử dụng một hàm tổng quát hỗ trợ Currying có tên generalBracket. Một số hàm functional cơ bản Giờ chúng ta sẽ đến với 3 hàm cơ bản thường được sử dụng trong Functional Programming. Nhưng trước tiên, tôi muốn mời bạn xem đoạn code sau trong Javascript: 123for (var i = 0; i &lt; something.length; ++i) &#123; // do stuff&#125; Có một vấn đề khá điển hình với đoạn code trên. Mặc dù không phải là bug, nhưng đoạn code trên sẽ được chúng ta viết hoặc copy paste mỗi lần muốn sử dụng vòng lặp (boilerplate code - code khuôn mẫu), nên sẽ khiến việc viết đọc code trở nên mệt mỏi dần theo thời gian. Nếu làm việc với các ngôn ngữ Imperative như là Java, C#, Javascript, PHP, Python,… bạn sẽ dễ dàng nhận thấy mình phải liên tục viết đi viết lại các dòng code tương tự như trên nhiều hơn bất cứ thứ gì khác. Và đó chính là vấn đề mà tôi muốn nói đến. Vì vậy tiếp theo đây chúng ta sẽ bàn về việc khử các đoạn code nhàm chán đó. Hãy đưa chúng và một hàm (hoặc một vài hàm) và ta sẽ không bao giờ phải viết một vòng lặp for một lần nào nữa. Thực tế thì điều đó khá là bất khả thi, nếu như chúng ta không biết đến FP. Trước hết, hãy bắt đầu bằng việc thay đổi một mảng có tên là things: 12345var things = [1, 2, 3, 4];for (var i = 0; i &lt; things.length; ++i) &#123; things[i] = things[i] * 10; // MUTATION ALERT !!!!&#125;console.log(things); // [10, 20, 30, 40] Bạn có nhận thấy điều gì ở đây ko? Đó chính là Mutability - biến things đã bị thay đổi giá trị Chúng ta sẽ thử lại, lần này sẽ không thay đổi giá trị biến things nữa: 123456var things = [1, 2, 3, 4];var newThings = [];for (var i = 0; i &lt; things.length; ++i) &#123; newThings[i] = things[i] * 10;&#125;console.log(newThings); // [10, 20, 30, 40] Lần này thì chúng ta không thay đổi giá trị của biến things, nhưng về mặt kỹ thuật thì chúng ta vẫn thay đổi giá trị của biến newThings, nhưng chúng ta sẽ bỏ qua và chấp nhận điều đó, vì hiện tại ta vẫn đang sử dụng Javascript. Khi chuyển sang các ngôn ngữ FP, bạn sẽ không thay đổi biến được nữa đâu. Mục đích mà tôi muốn nói ở đây là giải thích rõ ràng hơn cách hoạt động của những hàm cơ bản trong FP (map, reduce, filter,… ), cũng như tác dụng của chúng trong việc giảm bớt những phiền phức không đáng có trong code của mình. Do đó code JS có thể không mô tả đúng hoàn toàn cách các hàm đó thực hiện, nhưng về concept thì các bạn cứ yên tâm mà theo dõi nhé. Giờ với đoạn code ở trên (không thay đổi biến things), chúng ta sẽ đưa nó vào một hàm cơ bản đầu tiên có tên là map, với nhiện vụ là ánh xạ (map) từng giá trị của mảng cũ đến một mảng mới, thông qua một hàm biến đổi f: 1234567var map = (f, array) =&gt; &#123; var newArray = []; for (var i = 0; i &lt; array.length; ++i) &#123; newArray[i] = f(array[i]); &#125; return newArray;&#125;; Ta có thể thấy hàm map ngoài tham số là một mảng cần biến đổi, sẽ nhận thêm một tham số là f, đại diện cho việc mà chúng ta muốn xử lý với từng phần tử trong mảng cũ trước khi đưa vào mảng mới. (VD : nhân đôi từng phần tử thì hàm f sẽ là var f = x =&gt; x *2, hoặc cộng mỗi phần tử thêm 1 thì hàm f sẽ là var f = x =&gt; x+1, …) Và với code ban đầu, chúng ta có thể viết lại bằng cách sử dụng hàm map như sau : 12var things = [1, 2, 3, 4];var newThings = map(v =&gt; v * 10, things); Bạn có thể thấy là chúng ta đã không còn sử dụng vòng lặp for nữa, đồng thời code cũng trở nên dễ hiểu hơn (chúng ta có thể hiểu đoạn code trên là tạo ra một newThings là một mảng gồm các phần tử như mảng things, nhưng mỗi phần tử có giá trị được nhân lên 10 lần). Về mặt kỹ thuật thì vẫn có vòng lặp for ở trong hàm map. Nhưng ít ra thì chúng ta sẽ không phải copy paste hoặc gõ lại cái đoạn code mẫu đó thêm một lần nữa. Giờ thì chúng ta sẽ viết thêm một hàm có filter để lọc các phần tử của một mảng theo điều kiện bất kỳ: 12345678var filter = (pred, array) =&gt; &#123; var newArray = [];for (var i = 0; i &lt; array.length; ++i) &#123; if (pred(array[i])) newArray[newArray.length] = array[i]; &#125; return newArray;&#125;; Lưu ý hàm dùng để xác định có lấy phần tử đó hay không được truyền thông qua biến pred, chỉ trả về giá trị Boolean thôi nhé. Hàm này sẽ trả về TRUE khi chúng ta muốn giữ lại phần tử, và FALSE nếu chúng ta muốn loại nó ra. Và đây là cách sử dụng hàm filter để lấy ra các phần tử là số lẻ trong một mảng : 1234var isOdd = x =&gt; x % 2 !== 0;var numbers = [1, 2, 3, 4, 5];var oddNumbers = filter(isOdd, numbers);console.log(oddNumbers); // [1, 3, 5] Sử dụng hàm filter vừa viết ở trên sẽ đơn giản và dễ dàng hơn rất nhiều với việc phải đóng mở vòng for, set các biến lưu giá trị,… những công việc nhàm chán lại hay sai. Hàm thường xuyên được sử dụng trong FP tôi muốn giới thiệu cuối cùng có tên là reduce. Về cơ bản, nó được dùng với giá trị đầu vào là một danh sách, và kết quả trả ra là một giá trị đơn lẻ (nên mới được gọi là reduce - rút gọn), nhưng thực tế thì có rất nhiều cách để áp dụng. Hàm reduce thường được biết đến với cái tên là fold trong FP: 123456var reduce = (f, start, array) =&gt; &#123; var acc = start; for (var i = 0; i &lt; array.length; ++i) acc = f(array[i], acc); // f() takes 2 parameters return acc;&#125;); Hàm reduce sẽ gồm 3 tham số, bao gồm một hàm f dùng để thực hiện rút gọn (reduce), một giá trị khởi đầu start và một mảng để thao tác array. Để ý rằng hàm dùng cho việc rút gọn là f sẽ nhận 2 tham số, một là giá trị hiện tại của mảng array, một là giá trị tích lũy acc đang được tính toán và thay đổi khi duyệt qua từng phần tử trong mảng. Giá trị acc ở bước cuối cùng sẽ được trả về và cũng là kết quả của hàm reduce. Ví dụ dưới đây sẽ giúp chúng ta hiểu rõ hơn cách hoạt động của hàm này : 1234var add = (x, y) =&gt; x + y;var values = [1, 2, 3, 4, 5];var sumOfValues = reduce(add, 0, values);console.log(sumOfValues); // 15 Hàm add sẽ nhận vào 2 tham số và trả về tổng của chúng. Hàm reduce của chúng ta chấp nhận các hàm cho việc rút gọn với 2 tham số, nên trong trường hợp này hàm add là hoàn toàn hợp lý. Chúng ta bắt đầu với giá trị start là 0 và truyền vào một mảng values, do đó kết quả nhận lại của hàm reduce sẽ là tổng các phần tử trong mảng values. Trong hàm reduce, giá trị tổng các phần tử sẽ được tích lũy, cộng dồn sau mỗi lần duyệt từng phần tử của mảng. Bắt đầu acc = start = 0, giá trị đầu tiên của mảng là 1, lần thực hiện đầu tiên của hàm add sẽ là add(1,0) và acc mang giá trị 1 giá trị thứ 2 của mảng là 2, acc = 1, hàm add lúc này sẽ được gọi với giá trị add(2, 1),và acc = 3 Tiếp tục như vậy đến cuối cùng, giá trị acc = 15 sau lần duyệt phần tử cuối cùng (5) của mảng value và được trả về bởi hàm reduce. Có thể thấy rằng, mỗi hàm map, filter, reduce sẽ cho phép chúng ta thực hiện các biến đổi thông thường với một mảng mà không phải viết những đoạn code sử dụng vòng lặp dài dòng và khó hiểu nữa. Nhưng trong FP, khi mà chúng ta chỉ có đệ quy, còn vòng lặp thì không tồn tại, thì các hàm duyệt và biến đổi mảng ở trên sẽ trở nên cực kì hữu ích và cần thiết. Đầu của tôi!!!! Hôm nay đến đây thôi là đủ. Trong các phần sau của bài viết này, tôi sẽ nói về các vấn đề như là Referential Integrity, Execution Order, Types và một vài thứ nữa Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: Learn Elm Programming Và đây là Twitter của tác giả : @cscalfani","categories":[],"tags":[]},{"title":"Trở thành Functional Programmer - Phần 3","slug":"Tro-thanh-Functional-Programmer-Phan-3","date":"2017-08-23T16:25:03.000Z","updated":"2017-08-24T00:52:55.335Z","comments":true,"path":"2017/08/Tro-thanh-Functional-Programmer-Phan-3.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Tro-thanh-Functional-Programmer-Phan-3.html","excerpt":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP.","text":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP. Concept 5: Function Composition - Hàm hợp Lười là một trong những đặc trưng của lập trình viên chúng ta. Điển hình cho cái tính lười này là sự ngán ngẩm khi phải thực hiện đi thực hiện lại công việc chỉnh sửa, test, deploy code mà mình đã từng viết trước đó. Vì thế, chúng ta luôn luôn tìm ra những cách để chỉ làm một lần và đem ra tái sử dụng một lúc nào đó. Tái sử dụng code (code reuse) là một thứ thật tuyệt vời nhưng rất khó để đạt được. Nếu các đoạn code quá cụ thể thì ta không thể nào tái sử dụng được. Nhưng nếu các đoạn code đó lại quá chung chung thì lại rất khó khi áp dụng vào từng trường hợp cụ thể. Do đó chúng ta cần một sự cân bằng giữa hai tính chất trên, cần một cách để tạo ra các khối code nhỏ, có thể dễ dàng tái sử dụng - giống như các viên gạch vậy - để tạo nên các chức năng phức tạp. Trong FP, hàm được coi như các khối vật liệu xây dựng nên chương trình. Chúng ta sẽ viết các hàm cho những công việc cụ thể, nhưng sau đó chúng ta có thể ghép chúng lại như ghép Lego vậy. Và concept mô tả cho việc này có tên là Function Composition - Hàm hợp Vậy nó hoạt động như thế nào? Để hiểu rõ hơn, hãy cùng bắt đầu với 2 hàm Javascript sau : 123456var add10 = function(value) &#123; return value + 10;&#125;;var mult5 = function(value) &#123; return value * 5;&#125;; Nhìn 2 hàm này khá là rối rắm, nên chúng ta có thể viết lại bằng cách sử dụng Arrow function như sau: 12var add10 = value =&gt; value + 10;var mult5 = value =&gt; value * 5; Gọn hơn rồi nhỉ. Lúc này hãy thử tưởng tượng rằng chúng ta có một hàm nhận một giá trị số rồi cộng với 10, sau đó nhân kết quả nhận được với 5. Chúng ta có thể viết như sau : 1var mult5AfterAdd10 = value =&gt; 5 * (value + 10) Mặc dù đây chỉ là một ví dụ đơn giản, nhưng chúng ta sẽ có cảm giác rằng mình không hề muốn viết hàm này từ con số 0 một chút nào. Lý do đầu tiên, vì chúng ta có thể phạm phải một số sai lầm như là quên mất dấu đóng/mở ngoặc. Lý do thứ hai, chúng ta đã có 2 hàm trước đó, add10 dùng để cộng thêm 10 vào 1 giá trị, mult5 dùng để nhân 5 lần giá trị nhận được, nên việc viết lại hàm mul5AfterAdd10 thực chất chỉ là viết lại những gì đã viết. Và vì thế, chúng ta sẽ dùng 2 hàm add10 và mult5 làm thành phần cho việc xây dựng nên hàm mới: 1var mult5AfterAdd10 = value =&gt; mult5(add10(value)); Ta đã vừa sử dụng các hàm đã có để tạo nên hàm mult5AfterAdd10, nhưng vẫn còn cách cải thiện đoạn code trên. Chúng ta sẽ nhắc lại một chút về toán học. f ∘ g là phép hợp hàm và được diễn giải là hàm f kết hợp với hàm g, hoặc theo ngôn ngữ phổ thong, hàm f sau hàm g. Vì thế (f ∘ g)(x) tương đương với việc gọi hàm f sau khi gọi hàm g với tham số là x, hay viết gọn lại là f(g(x)). Ví dụ ở trên sẽ tương đương với mult5 ∘ add10 hoặc là hàm mult5 theo sau hàm add10, và vì thế tên hàm sẽ là mult5AfterAdd10. Và đó chính xác là những gì mà chúng ta đã làm. Ta gọi hàm mult5 sau khi gọi hàm add10 với tham số là value, hay viết gọn là mult5(add10(value)). Vì Javascript không hỗ trợ FP một cách hoàn toàn nên code có vẻ khá phức tạp, chúng ta hãy nhìn sang phiên bản của Elm: 123456add10 value = value + 10mult5 value = value * 5mult5AfterAdd10 value = (mult5 &lt;&lt; add10) value Toán tử &lt;&lt; được dùng để kết hợp hàm ở trong Elm. Và việc sử dụng toán tử này sẽ cho chúng ta một hình dung khá rõ ràng về luồng xử lý dữ liệu. Đầu tiên, biến value được truyền cho hàm add10, sau đó sẽ được truyền sang hàm mult5. Đồng thời hãy lưu ý dấu mở và đóng ngoặc ở hàm mult5AfterAdd10, cụ thể là ở đoạn (mult5 &lt;&lt; add10). Việc sử dụng đóng mở ngoặc ở đây nhằm đảm bảo rằng 2 hàm sẽ được kết hợp trước khi xử lý tham số value. Ta cũng có thể kết hợp nhiều hàm nếu thích : 12f x = (g &lt;&lt; h &lt;&lt; s &lt;&lt; r &lt;&lt; t) x Ở đây biến x sẽ được truyền vào hàm t, kết quả được truyền sang hàm r, sau đó kết quả ở hàm rlại sang hàng s và tiếp tục cho đến hết hàm g. Phiên bản hàm hợp tương đương ở Javascript sẽ là g(h(s(r(t(x))))) - trông như một đống ngổn ngang toàn dấu đóng mở ngoặc. Concept 6 : Point-Free Notation(Lời người dịch : Từ này mình không tìm thấy từ tiếng Việt tương ứng, theo ý hiểu của mình có nghĩa là ký hiệu hàm mà không phải chỉ định rõ tham số nên được gọi là Point - Free) Có một phong cách viết code mà không phải chỉ định rõ tham số với tên gọi là Point-Free Notation. Ban đầu phong cách này nhìn có thể kỳ cục nhưng theo thời gian, chúng ta sẽ cảm nhận được tác dụng của sự vắn tắt này. Quay trở lại ví dụ về hàm mult5AfterAdd10, ta nhận thấy rằng biến value được ghi ra hai lần. Một lần trong danh sách tham số và một lần được sử dụng trong thân hàm 123-- This is a function that expects 1 parametermult5AfterAdd10 value = (mult5 &lt;&lt; add10) value Nhưng thực tế thì tham số này là không cần thiết vì hàm add10 - hàm ở ngoài cùng bên phải của hàm hợp, cũng dùng chính xác tham số đó. Dưới đây sẽ là phiên bản point-free tương đương với hàm trên: 123-- This is also a function that expects 1 parametermult5AfterAdd10 = (mult5 &lt;&lt; add10) Khi viết theo cách này, thực tế sẽ đem lại cho ta rất nhiều lợi ích. Đầu tiên, chúng ta không phải chỉ rõ các tham số được rút gọn, do đó chúng ta không phải mất thời gian để nghĩ tên cho tất cả các tham số đó. Thứ hai, viết theo kiểu này sẽ dễ đọc và suy luận hơn vì nó sẽ bớt rối rắm. Ví dụ phía trên rất đơn giản, nhưng hãy tưởng tượng nếu một hàm nhận nhiều hơn một tham số. Rắc rối chốn thiên đường Từ đầu bài viết đến giờ, chúng ta đã tìm hiểu cách Hàm hợp hoạt động và lý do cũng như cách chúng ta nên viết hàm dưới dạng Point-Free Notation cho sự mạch lạc, rõ ràng và linh động. Giờ, hãy thử áp dụng các ý tưởng trên vào một bối cảnh khác và xem chúng hoạt động ra sao nhé. Tưởng tượng chúng ta thay hàm add10 bằng hàm add như sau : 1234add x y = x + ymult5 value = value * 5 Câu hỏi giờ là : Làm thế nào để tạo ra hàm mult5After10 chỉ với 2 hàm trên. Trước khi đi tiếp, tôi khuyên bạn hãy dừng lại và nghĩ một chút. Không có gì nghiêm trọng cả, chỉ đơn giản là dừng lại và thử ngẫm nghĩ một chút thôi. Ok, nếu bạn đã bỏ thời gian suy nghĩ, thì có thể bạn đã nghĩ đến giải pháp như dưới đây: 123-- This is wrong !!!!mult5AfterAdd10 = (mult5 &lt;&lt; add) 10 Nhưng thực tế nó sẽ không hoạt động. Vì sao? Vì hàm add cần hai - hai chứ không phải một tham số. Nếu trong Elm nhìn có vẻ không hiển nhiên, chúng ta sẽ quay lại với phiên bản Javascript: 1var mult5AfterAdd10 = mult5(add(10)); // cái này không hoạt động Đoạn code này không đúng, nhưng lý do là vì sao? Nguyên nhân là vì hàm add chỉ lấy 1 trong 2 tham số để tính toán, tạo ra kết quả sai, mà kết quả sai đó sẽ được truyền sang hàm mult5, dẫn đến kết quả cuối cùng không đúng. Trong thực tế, với Elm, bộ biên dịch - compiler sẽ không bao giờ bỏ qua những dòng code sai định dạng như trên (và đó là một trong những điểm tuyệt vời của Elm). Chúng ta có thể viết lại như sau : 1var mult5AfterAdd10 = y =&gt; mult5(add(10, y)); // not point-free Đây không phải là cách viết hàm theo phong cách point-free, nhưng ít ra thì nó sẽ đảm bảo được kết quả đúng. Nhưng giờ thì ta không thể dùng toán tử kết hợp các hàm lại thành hàm hợp nữa (là phần &lt;&lt;). Thay vì thế ta đang tạo ra một hàm mới. Sau này nếu kịch bản trở nên phức tạp hơn, ví dụ như muốn kết hợp hàm mult5AfterAdd10 với một cái gì đó khác, lúc này mọi thứ sẽ trở nên thực sự rắc rối. Vì thế khi chúng ta không thể kết hợp hai hàm ở trên, có một điều ta nhận thấy rõ ràng là Hàm hợp có sự hạn chế nhất định. Điều đó thật tệ vì Hàm hợp là một concept khá mạnh mẽ. Vậy làm thế nào để chúng ta giải quyết vấn đề trên? Chúng ta cần thứ gì để có thể thổi bay sự rắc rối này? Giả sử chúng ta có thể làm cách nào đó để chỉ truyền cho hàm add một giá trị tham số trước tiên (khi tạo hàm hợp) , và tham số thứ 2 sẽ được truyền vào sau đó khi thực hiện hàm hợp - ở đây là lúc hàm mult5AfterAdd10 được gọi, chẳng phải vấn đề ở trên sẽ dễ dàng được giải quyết sao. Và thực tế là cách đó có tồn tại, với tên gọi là Currying. Đầu của tôi!!!! Hôm nay đến đây thôi là đủ. Trong các phần sau của bài viết này, tôi sẽ nói về các vấn đề như là Currying, các functional functions cơ bản (như là map, filter, fold,… ), Referential Transparency và một vài thứ nữa Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: Learn Elm Programming Và đây là Twitter của tác giả : @cscalfani","categories":[],"tags":[]},{"title":"Trở thành Functional Programmer - Phần 2","slug":"Tro-thanh-Functional-Programmer-Phan-2","date":"2017-08-23T16:22:32.000Z","updated":"2017-08-24T00:52:47.992Z","comments":true,"path":"2017/08/Tro-thanh-Functional-Programmer-Phan-2.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Tro-thanh-Functional-Programmer-Phan-2.html","excerpt":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP.","text":"Những bước đầu tiên của việc hiểu rõ các concepts trong lập trình hàm (Functional Programming - FP) là những bước quan trọng nhất, và đôi khi là những bước khó khăn nhất. Nhưng với cách tiếp cận đúng đắn, mọi thứ sẽ trở nên dễ hiểu hơn rất nhiều. Và đây là series được tạo ra nhằm mục đích giúp các bạn dễ thở hơn trong quá trình tiếp cận với FP. Một chút lưu ý Tôi mong các bạn sẽ đọc các dòng code một cách từ tốn. Và hãy đảm bảo rằng bạn đã hoàn toàn hiểu rõ, nắm vững các nội dung vừa đọc được trước khi tiếp tục. Các phần tiếp theo được phát triển từ các phần trước đó, nên nếu bạn vội vã, bạn có thể bỏ qua một vài kiến thức quan trọng, cần thiết cho các phần sau này. Tái cấu trúc - Refactoring Phần này sẽ nói về Tái cấu trúc - một kỹ thuật khá quen thuộc đối với các lập trình viên. Sau đây mời các bạn xem một đoạn code Javascript: function validateSsn(ssn) {if (/^\\d{3}-\\d{2}-\\d{4}/.exec(ssn)) console.log(‘Valid SSN‘); else console.log(‘Invalid SSN‘); } function validatePhone(phone) { if (/^(\\d{3})\\d{3}-\\d{4}/.exec(phone)) console.log(‘Valid Phone Number‘); else console.log(‘Invalid Phone Number‘);} Hẳn là bạn đã từng viết những dòng code kiểu như thế này, và theo thời gian, bạn sẽ dần nhận ra rằng 2 hàm phía trên khá là giống nhau, chỉ có đôi chút khác biệt (phần được bôi đậm). Vì thế, thay vì copy lại hàm validateSSn và thay đổi để tạo ra hàm validatePhone mới, chúng ta có thể chỉ tạo một hàm và biến các phần khác nhau thành tham số. Trong ví dụ này, chúng ta nên tham số hóa phần value, phần regulare expression và phần message được in ra (là những phần bôi đậm ở trên). Đây là code sau khi refactor: 123456function validateValue(value, regex, type) &#123; if (regex.exec(value)) console.log(&apos;Invalid &apos; + type); else console.log(&apos;Valid &apos; + type);&#125; Các tham số ssn và phone ở trong phần code cũ đã được thay thế bằng biến value. 2 biểu thức chính quy (regulare expression) /^\\d{3}-\\d{2}-\\d{4}$/ và /^\\(\\d{3}\\)\\d{3}-\\d{4}$/ được thay thế bằng biến regex. Và phần sau của message gồm SNS và Phone Number sẽ được thay thế bằng biến type. Việc chỉ có một hàm như thế này sẽ tốt hơn rất nhiều so với việc có 2, hoặc xấu hơn là 3, 4 hay 10 hàm. Việc này sẽ giúp code của bạn sạch sẽ và dễ bảo trì hơn. Ví dụ, nếu có lỗi xảy ra, bạn sẽ chỉ phải fix ở một chỗ thay vì tìm kiếm trong tất cả source code để tìm các chỗ mà hàm này CÓ THỂ đã được copy/paste và thay đổi. Tiếp theo chúng ta cùng xem xét trường hợp phức tạp hơn một chút : 123456789101112function validateAddress(address) &#123; if (parseAddress(address)) console.log(&apos;Valid Address&apos;); else console.log(&apos;Invalid Address&apos;);&#125;function validateName(name) &#123; if (parseFullName(name)) console.log(&apos;Valid Name&apos;); else console.log(&apos;Invalid Name&apos;);&#125; Ở đây parseAddress và parseFullName là 2 hàm đều nhận vào một chuỗi và trả về true nếu parse thành công. Bạn sẽ refactor code trong trường hợp này như thế nào đây? Giống như trường hợp trước đó, ta có thể sử dụng biến value cho address và name, type cho Address và Name giống như đã làm trước đó, nhưng ở vị trí của biểu thức chính quy lúc trước giờ lại là 2 hàm khác nhau. Nếu như chúng ta có thể đưa hàm vào tham số thì … Concept 3: Higher-Order Functions(Chú thích của người dịch: High-order Function mình đã tìm hiểu nhưng khó có từ tiếng Việt tương đương, bạn có thể hiểu Higher-Order Functions có nghĩa là Hàm có cấp bậc cao hơn - với ý nghĩa là hàm có nhiều khả năng và linh hoạt hơn so với các ngôn ngữ Imperative Programming thông thường như Java, C, C++) Rất nhiều ngôn ngữ lập trình không hỗ trợ việc đưa hàm vào thành tham số. Một số ngôn ngữ thì có thể nhưng cách thực hiện thì không hề dễ dàng chút nào. Trong Functional Programming, một hàm sẽ được coi như là một công dân hạng nhất trong ngôn ngữ đó. Hay nói cách khác, hàm sẽ giống như các loại giá trị (số, text, object,…) khác. Bởi vì hàm sẽ được coi như các loại giá trị khác, nên hàm có thể được truyền dưới dạng tham số. Mặc dù không phải là ngôn ngữ hỗ trợ FP chính thống, nhưng một vài concept trong FP có thể được thực hiện bởi Javascript. Và đây là cách thu gọn hai hàm ở trên thành một bằng việc đưa hàm thực hiện việc parse dữ liệu thành tham số của hàm mới có tên là parseFunc: 123456function validateValueWithFunc(value, parseFunc, type) &#123; if (parseFunc(value)) console.log(&apos;Invalid &apos; + type); else console.log(&apos;Valid &apos; + type);&#125; Và hàm mới của chúng ta được gọi là Higher-order Function. Higher-order Functions là các hàm hoặc nhận hàm làm tham số, hoặc trả về hàm, hoặc vừa nhận hàm làm tham số vừa trả về hàm. Và giờ chúng ta có thể viết lại cả 4 hàm trên bằng cách sử dụng hàm validateValueWithFunc như sau ( lưu ý rằng hàm Regex.exec sẽ trả về true nếu chuỗi ký tự match với biểu thức chính quy ): 1234validateValueWithFunc(&apos;123-45-6789&apos;, /^\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;$/.exec, &apos;SSN&apos;);validateValueWithFunc(&apos;(123)456-7890&apos;, /^\\(\\d&#123;3&#125;\\)\\d&#123;3&#125;-\\d&#123;4&#125;$/.exec, &apos;Phone&apos;);validateValueWithFunc(&apos;123 Main St.&apos;, parseAddress, &apos;Address&apos;);validateValueWithFunc(&apos;Joe Mama&apos;, parseName, &apos;Name&apos;); Code được viết lại như trên nhìn ngon hơn hẳn so với việc có 4 hàm từa tựa nhau nhỉ? :D Để ý kĩ hơn một chút, 2 hàm sử dụng biểu thức chính quy nhìn có vẻ khá là rườm rà, nhất là khi sau này biểu thức chính quy có thể trở nên dài và phức tạp hơn. Chúng ta có thể làm cho nó gọn hơn bằng cách đưa phần gọi biểu thức chính quy ra ngoài như sau : 1234567var parseSsn = /^\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;$/.exec;var parsePhone = /^\\(\\d&#123;3&#125;\\)\\d&#123;3&#125;-\\d&#123;4&#125;$/.exec;validateValueWithFunc(&apos;123-45-6789&apos;, parseSsn, &apos;SSN&apos;);validateValueWithFunc(&apos;(123)456-7890&apos;, parsePhone, &apos;Phone&apos;);validateValueWithFunc(&apos;123 Main St.&apos;, parseAddress, &apos;Address&apos;);validateValueWithFunc(&apos;Joe Mama&apos;, parseName, &apos;Name&apos;); Mọi thứ tốt hơn rồi nhỉ. Sau này nếu muốn kiểm tra một số điện thoại khác, thay vì phải copy lại biểu thức chính quy, ta có thể sử dụng hàm parsePhone và validateValueWithFunc. Tuy nhiên, hãy thử tưởng tượng nếu chúng ta có nhiều biểu thức chính quy cần thực hiện, ngoài 2 hàm parseSsn và parsePhone thì sẽ ra sao nhỉ? Để ý rằng mỗi khi gọi hàm xử lý biểu thức chính quy, ta đều phải gọi thêm .exec vào cuối, và nếu số lượng biểu thức chính quy tăng lên thì sẽ khá là phiền phức, và tin tôi đi, sẽ có lúc bạn sẽ quên mất không thêm .exec vào đó. Để tránh mắc phải lỗi này, chúng ta có thể tạo ra một hàm dạng high-order function được dùng để trả về hàm exec từ biểu thức chính quy truyền vào như sau : 123456789function makeRegexParser(regex) &#123; return regex.exec;&#125;var parseSsn = makeRegexParser(/^\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;$/);var parsePhone = makeRegexParser(/^\\(\\d&#123;3&#125;\\)\\d&#123;3&#125;-\\d&#123;4&#125;$/);validateValueWithFunc(&apos;123-45-6789&apos;, parseSsn, &apos;SSN&apos;);validateValueWithFunc(&apos;(123)456-7890&apos;, parsePhone, &apos;Phone&apos;);validateValueWithFunc(&apos;123 Main St.&apos;, parseAddress, &apos;Address&apos;);validateValueWithFunc(&apos;Joe Mama&apos;, parseName, &apos;Name&apos;); Ở đây, hàm makeRegexParser nhận tham số là một biểu thức chính quy, và trả về hàm exec của biểu thức chính quy đó, với tham số là một chuỗi string. Lúc này, hàm validateValueWithFunc sẽ nhận chuỗi string từ biến value, sau đó truyền sang hàm parseSsn hoặc parsePhone, đối ví dụ trên thực chất sẽ là hàm exec được trả về từ hàm parseSsn hoặc parsePhone. Như các bạn đã thấy, đây tuy chỉ là một quá trình tái cấu trúc code nho nhỏ, nhưng nó đã thể hiện khả năng và sự tiện lợi của High-order function khi hỗ trợ việc trả về hàm. Lợi ích của việc thay đổi này sẽ thể hiện một cách rõ ràng hơn khi hàm makeRegexParser trở nên phức tạp hơn. Dưới đây là một ví dụ khác về một High-order function có kết quả trả về là một hàm : 12345function makeAdder(constantValue) &#123; return function adder(value) &#123; return constantValue + value; &#125;;&#125; Chúng ta có một hàm makeAdder nhận vào tham số là constantValue (giá trị cố định), và trả về một hàm tên là adder, với khả năng cộng thêm giá trị constantValue vào tham số truyền vào. Đây là cách hàm adder có thể sử dụng : 1234var add10 = makeAdder(10);console.log(add10(20)); // prints 30console.log(add10(30)); // prints 40console.log(add10(40)); // prints 50 Chúng ta đã tạo ra một hàm có tên là add10 bằng việc truyền giá trị 10 vào hàm makeAdder, mà hàm add10 sẽ hoạt động đúng như tên của nó, cộng thêm 10 vào bất kỳ biến nào truyueenf vào. Để ý rằng hàm adder có thể truy cập đến biến constantValue ngay cả khi hàm makeAddr đã hoàn thành. Lý do là bởi vì biến constantValue đã ở trong cùng một scope (phạm vi) khi hàm adder được tạo. Khả năng này rất quan trọng bởi vì nếu thiếu nó, việc hàm trả về hàm sẽ không còn nhiều lợi ích nữa. Vì thế việc hiểu cách hoạt động và tên gọi của khả năng này cũng là điều mà chúng ta cần tìm hiểu, và nó có tên là Closure. Concept 4: Closures - Bao đóng Dưới đây là một ví dụ giả tưởng nhằm minh họa việc hàm sử dụng closures: 12345678910function grandParent(g1, g2) &#123; var g3 = 3; return function parent(p1, p2) &#123; var p3 = 33; return function child(c1, c2) &#123; var c3 = 333; return g1 + g2 + g3 + p1 + p2 + p3 + c1 + c2 + c3; &#125;; &#125;;&#125; Trong ví dụ này, hàm child có thể truy cập các biến của chính nó, các biến của hàm parent và cả các biến của hàm grandParent nữa.(đủ g1, g2, g3, p1, p2, p3, c1, c2, c3) Hàm parent có thể truy cập các biến của chính nó và của hàm grandParent. (bao gồm g1, g2, g3, p1, p2, p3) Hàm grandParent chỉ có thể truy cập các biến của chính nó. (bao gồm g1, g2, g3). (Mọi người có thể tham khảo hình vẽ kim tự tháp phía bên trên để hiểu rõ hơn). Sau đây là 1 ví dụ sử dụng hàm 3 đời ở trên : 1234var parentFunc = grandParent(1, 2); // returns parent() - trả về hàm parent() với g1 = 1, g2 = 2, g3 = 3var childFunc = parentFunc(11, 22); // returns child() - trả về hàm child() với g1 = 1, g2 = 2, g3 = 3, p1 = 11, p2 = 22, p3 = 33console.log(childFunc(111, 222)); // prints 738 - in ra 738 vì :// 1 + 2 + 3 + 11 + 22 + 33 + 111 + 222 + 333 == 738 Ở đây, biến parentFunc sẽ giữ cho scope của hàm parent tồn tại sau khi thực hiện hàm grandParent, lúc này hàm parent sẽ trả về và tham chiếu thông qua biến parentFunc (scope của parent ở đây sẽ bao gồm các giá trị được hàm parent tham chiếu đến, tức là sẽ lưu giữ các giá trị g1, g2, g3, p1, p2, p3). Tương tự như vậy, biến childFunc sẽ giữ scope của hàm child tồn tại sau khi thực hiện gọi hàm parent thông qua biến parentFunc, lúc này hàm child được trả về và tồn tại vì có biến childFunc tham chiếu đến. Mỗi khi một hàm được tạo ra, tất cả các giá trị nằm trong scope của nó ở thời điểm hàm được tạo sẽ được lưu trữ và có thể truy cập trong suốt vòng đời của hàm đó. Và hàm sẽ còn tồn tại chừng nào còn có tham chiếu (reference) đến nó. Ví dụ, scope của hàm child sẽ còn tồn tại cho đến khi nào biến childFunc vẫn tham chiếu đến nó. Một closure (bao đóng) là một scope của một hàm mà sẽ tồn tại chừng nào còn có tham chiếu đến hàm đó. Lưu ý rằng, trong Javascript, closures sẽ gây ra nhiều rắc rối bởi vì các biến có thể thay đổi (mutable), và vì thế các biến đó có thể bị/được thay đổi giá trị từ lúc chúng được đóng lại cho đến lúc hàm trả về được gọi. (Ở đây đóng lại ý nói lúc dùng High-order function để trả về một hàm, lúc này các biến trong scope của hàm đó vẫn có thể truy cập và thay đổi giá trị, do đó đến lúc thực thi hàm này, các biến này giá trị có thể khác so với lúc được trả về, gây ra các kết quả không mong muốn) Thật may mắn là các biến trong FP sẽ là bất biến (immutable - đã nói đến ở phần 1), nên các lỗi có thể xảy ra do Closure như trong JS sẽ không gặp phải nữa. Đầu của tôi!!!! Hôm nay đến đây thôi là đủ. Trong các phần sau của bài viết này, tôi sẽ nói về các vấn đề như là Functional Composition, Currying, các functional functions cơ bản (như là map, filter, fold,… ), và một vài thứ nữa Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: Learn Elm Programming Và đây là Twitter của tác giả : @cscalfani","categories":[],"tags":[]},{"title":"Trở thành Functional Programmer - Phần 1","slug":"Tro-thanh-Functional-Programmer-Phan-1","date":"2017-08-23T16:19:26.000Z","updated":"2017-08-24T00:52:40.637Z","comments":true,"path":"2017/08/Tro-thanh-Functional-Programmer-Phan-1.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Tro-thanh-Functional-Programmer-Phan-1.html","excerpt":"Việc sáng tỏ, ngộ ra concept của Functional Programming thường là một trong những bước phát triển quan trọng nhất trong sự nghiệp lập trình của bạn, và đôi khi cũng là bước khó khăn nhất. Tuy nhiên chúng ta có thể vượt qua nó một cách dễ dàng với cách tiếp cận đúng đắn. Bài viết sau đây sẽ hướng dẫn mọi người đến được với vùng chân lý đó.","text":"Việc sáng tỏ, ngộ ra concept của Functional Programming thường là một trong những bước phát triển quan trọng nhất trong sự nghiệp lập trình của bạn, và đôi khi cũng là bước khó khăn nhất. Tuy nhiên chúng ta có thể vượt qua nó một cách dễ dàng với cách tiếp cận đúng đắn. Bài viết sau đây sẽ hướng dẫn mọi người đến được với vùng chân lý đó. Bắt đầu từ việc học lái xe Lần đầu lái xe thường là những kỉ niệm đau thương và khốn khổ nhất của chúng ta. Sẽ thật dễ dàng khi nhìn người khác lái, nhưng khi thực sự đặt tay vào vô-lăng, mọi thứ bỗng trở nên khó khăn hơn chúng ta tưởng. Và chúng ta sẽ phải tập luyện bằng xe của gia đình cho đến khi có thể làm chủ những đoạn đường xung quanh nhà trước khi thoát xác lên cung đường cao tốc. Nhưng cuối cùng thì thông qua quá trình luyện tập lặp đi lặp lại và một số khoảng thời gian khiến gia đình thót tim, cuối cùng bạn cũng sẽ học được cách lái xe và có bằng lái cho riêng mình. Với tấm bằng lái trong tay, chúng ta có thể lái bất cứ cái xe nào nếu có thể nổ máy. Và với mỗi chuyến đi, sự tự tin, làm chủ tay lái sẽ ngày càng được củng cố. Và cũng sẽ đến cái ngày chúng ta phải lái xe cuả người khác, hay là phải thay chiếc xe cà tàng bằng một chiếc mới hiện đại hơn. Cảm xúc khi lái một chiếc xe khác sẽ như thế nào nhỉ? Liệu có giống với cảm xúc khi lần đầu chạm tay vào vô lăng? Không hẳn. Lần đầu tiên lái xe, chúng ta hoàn toàn bỡ ngỡ. Mặc dù trước đó đã ngồi trên xe nhưng chúng ta chỉ có vai trò là hành khách. Còn lầu đầu tiên lái xe là khi có qtoàn quyền điều khiển chiếc xe đó. Còn với lần lái chiếc xe thứ hai trở đi, chúng ta chỉ tìm kiếm câu trả lời cho những câu hỏi đơn giản : Chìa khóa ở đâu nhỉ? Đèn ở đâu nhỉ? Chỉnh gương với đèn chiếu ở đâu ta? Sau những thắc mắc đó, mọi thứ diễn ra thật tự nhiên như nước chảy mây trôi, việc lái xe thật dễ dàng hơn không biết bao nhiêu lần so với lần đầu cầm lái. Nguyên do cho sự việc trên là chiếc xe mới sẽ vận hành giống gần hết chiếc xe cũ. Cả 2 chiếc xe đều có những thứ cơ bản cho việc lái xe, và các thứ đó hầu hết đều ở cùng một vị trí Một vài thứ nho nhỏ sẽ được thay đổi, hoặc thêm chí có thêm vài tính năng mới, nhưng chúng ta hầu hết sẽ không dùng chúng vào lần đầu tiên, thậm chí lần thứ 2. Dần dần sau cùng chúng ta mới học sử dụng các tính năng mới, mà chỉ là các tính năng mà chúng ta quan tâm thôi. Việc học lập trình cũng tương tự như học lái xe vậy. Lần đầu tiên bao giờ cũng là lần khó khăn nhất. Nhưng khi bạn đã quen rồi, thì những lần sau sẽ trở nên dễ dàng hơn rất nhiều. Mỗi khi bạn bắt đầu việc học một ngôn ngữ mới, sẽ có một số câu hỏi bạn sẽ thường tự hỏi mình như là : Làm thế nào để tạo một module? Làm thế nào để tìm kiếm trong 1 mảng? Tham số cho hàm thay thế chuỗi là gì? Bạn hoàn toàn tự tin rằng mình sẽ sử đụng được ngôn ngữ mới này, bởi vì nó gợi nhớ lại cho bạn những kỉ niệm, hiểu biết với ngôn ngữ cũ, cùng với một vài điều mới mẻ với hy vọng rằng làm cho cuộc đời của bạn trở nên đẹp đẽ hơn. Đến con tàu vũ trụ đầu tiên Giờ hãy thử tưởng tượng rằng bạn đã lái hàng tá xe ô tô trong cuộc đời, rồi đến một ngày bạn được đặt vào khoang điều khiển của một chiếc Tàu không gian. Lúc này bạn bỗng trở nên hoang mang, không biết rằng liệu những kinh nghiệm lái xe có giúp ích được gì cho mình không. Bạn cảm giác như mình đang bắt đầu lại từ con số 0 tròn trĩnh. (Chúng ta là lập trình viên, chúng ta đếm từ số 0) Bạn có thể bắt đầu việc luyện tập với cảm giác rằng mọi thứ sẽ trở nên rất khác ở trong không gian, và cách vận hành con tàu khác hoàn toàn này sẽ rất khác so với việc lái xe trên mặt đất. Tuy nhiên thì các định luật vật lý đều không thay đổi. Chỉ khác ở chỗ cách bạn di chuyển trong cùng một vũ trụ mà thôi. Và với việc học Functional Programming (lập trình hàm) cũng tương tự như vậy. Bạn dự đoán, cảm giác rằng mọi thứ sẽ rất khác. Khác đến nỗi mà khiến cho những kinh nghiệm, kiến thức đã từng có được sẽ bị xóa sổ, không quay lại được như xưa nữa. Và mọi thứ sẽ được mở đầu bằng câu nói kinh điển dưới đây. Quên tất cả những thứ đã biếtMọi người rất thích câu nói sau đây, và nó cũng khá đúng trong hầu hết các trường hợp: Học lập trình hàm (FP) cũng giống như bắt đầu lại mọi thứ vậy. Không hoàn toàn là như vậy, nhưng đó là một suy nghĩ khá hiệu quả khi tiếp xúc với FP. Có rất nhiều concepts giống nhau giữa lập trình mà bạn đã biết và FP, nhưng việc tiếp cận FP với tư tưởng rằng mình sẽ phải học lại tất cả mọi thứ thường tỏ ra hiệu quả nhất. Với cách tiếp cận chính xác, bạn sẽ có những tư tưởng, suy nghĩ đúng đắn, là những thứ sẽ giúp bạn không bỏ cuộc khi việc học hành trở nên khó khăn. Bạn sẽ phải xác định rằng có rất nhiều thứ mà bạn đã từng học và làm quen trên con đường làm lâp trình viên từ trước đến giờ, khi đến với FP, sẽ biến mất hoặc không thể sử dụng được nữa. Liên hệ với việc lái xe, bạn có thể quen với việc dùng số lùi để đậu xe. Tuy nhiên một con tùa không gian sẽ không có số lùi. Có thể bạn sẽ nghĩ rằng : CÁI GÌ CƠ? KHÔNG CÓ SỐ LÙi!?! TÔI LÁI TÀU THẾ QUÁI NÀO KHI KHÔNG CÓ SỐ LÙI BÂY GIỜ?! Thực tế là tàu không gian có thể di chuyển trong không gian 3 chiều (ô tô là 2 chiều), nên sẽ không cần số lùi. Khi bạn nắm rõ cách hoạt động của tàu không gian, bạn sẽ không cần phải sử dụng số lùi thêm một lần nào nữa. Và rồi bạn sẽ thấy rằng mấy cái xe thật là cùi =)) Với FP cũng vậy, tuy nhiên: Học FP sẽ mất thời gian. Vì thế hãy kiên nhẫn Và giờ chúng ta cùng đến với miền đất hứa của Functional Programming, bỏ qua vùng đất lạnh lẽo, nhàm chán của Imperative Programming đã quá quen thuộc. Những gì dược viêt tiếp theo đây là một series bài viết giới thiệu các Concepts của FP với mục đích giúp người đọc làm quen trước khi đi vào bất kì ngôn ngữ lập trình FP nào. Hoặc nếu bạn đã sử dụng FP rồi, thì đây sẽ là bài viết giúp bạn hiểu rõ hơn những việc mình đang làm . Và mong các bạn không vội vàng. Hãy dành thời gian đọc những gì tôi sắp viết sau đây, cũng như dành thời gian để hiểu những đoạn code ví dụ. Bạn có thể tạm dừng sau mỗi đoạn để kiến thức ngấm hoàn toàn vào người, sau đó hãy quay lại và tiếp tục. Điều quan trọng nhất là kiến thức của bạn. Concept 1: Purity - Sự thuần khiết Khi những lập trình viên FP nói về Purity, đó là khi họ muốn đề cập đến Pure Function . Pure Function là những hàm hết sức đơn giản, chỉ thao tác dựa trên tham số đầu vào. Đây là một ví dụ về một hàm được gọi là Pure trong Javascript : 1234var z = 10;function add(x, y) &#123; return x + y;&#125; Bạn có thể nhận thấy rằng hàm add không hề đụng vào biến z. Hàm đó không đọc giá trị của biến z, cũng như không thay đổi giá trị biến z. Nó chỉ đơn giản là đọc 2 tham số x và y, là 2 tham số đầu vào, rồi trả về giá trị là tổng của 2 tham số đó. Hàm add, vì lý do đó, được gọi là Pure Function. Nếu hàm add có bất kỳ xử lý nào liên quan đến biến z, hàm đó sẽ không còn là pure nữa. Chúng ta cùng tham khảo một hàm khác: 123function justTen() &#123; return 10;&#125; Nếu hàm justTen là pure, thì nó chỉ có thể trả về một giá trị duy nhất, cố định. Nguyên nhân là vì hàm này không có bất kì một tham số nào. Và để đảm bảo nó là pure function, hàm này sẽ không thể truy cập bất kì giá trị nào ngoài các tham số của nó. Ở đây không có tham số nào, nên giá trị trả về của hàm này lúc nào cũng là một giá trị cố định. Và pure function mà không có tham số nào để thực hiện thì có vẻ hơi vô nghĩa, và chúng ta nên thay thế hàm justTen bằng một hằng số (constant) thì tốt hơn. Hầu hết các Pure Function đều có ít nhất một tham số. Tiếp theo chúng ta đến với một hàm khác: 123function addNoReturn(x, y) &#123; var z = x + y&#125; Dễ dàng nhận thấy rằng hàm addNoReturn không có giá trị trả về. Hàm này chỉ đơn giản là xử lý việc cộng 2 tham số x và y rồi lưu vào biến z, nhưng không trả về giá trị tông.Đây mặc dù vẫn là một pure function khi nó chỉ xử lý các tham số của chính mình. Nó thực hiện việc cộng 2 input, nhưng vì không trả về bất cứ giá trị gì, nên nó vô dụng (vì chúng ta không có cách nào lấy được giá trị đã được xử lý). Một Pure Function chỉ có giá trị sử dụng khi có giá trị trả về. Và giờ chúng ta quay lại hàm add lúc đầu một lần nữa : 123456function add(x, y) &#123; return x + y;&#125;console.log(add(1, 2)); // prints 3console.log(add(1, 2)); // still prints 3console.log(add(1, 2)); // WILL ALWAYS print 3 Có thể thấy rằng việc thực hiện add(1,2) luôn trả về giá trị 3. Không phải là một điều gì quá ngạc nhiên, nhưng điều này chỉ có thể thực hiện nếu hàm đó là pure function. Nếu hàm add sử dụng bất kì một biến nào ở bên ngoài, thì bạn sẽ không bao giờ dự đoán được kết quả trả về Pure Function sẽ luôn trả về cùng output với cùng input, bất kể có thực hiện bao nhiêu lần. Vì pure function sẽ không tác động đến các biến nằm ngoài chúng, nên các hàm sau sẽ được coi là impure (không thuần khiết =)) ): 1234writeFile(fileName);updateDatabaseTable(sqlCmd);sendAjaxRequest(ajaxRequest);openSocket(ipAddress); Tất cả các hàm này đều có một đặc tính chung được gọi là Side Effects (tác dụng phụ). Khi bạn gọi và thực thi chúng, các hàm này sẽ thay đổi file, cập nhật cơ sử dữ liệu, gửi data về phía server hoặc gọi hệ điều hành để lấy socket. Chúng làm nhiều thứ hơn là chỉ thao tác với tham số đầu vào và trả về output. Vì thế, bạn có thể không bao giờ dự đoán được giá trị mà những hàm này sẽ trả về. Pure Function đảm bảo việc hàm sẽ không có Side Effects. Trong các ngôn ngữ Imperative Language như là Javascript, Java, hay C#, Side Effects xuất hiện ở khắp mọi nơi. Điều này khiến cho việc debug rất khó vì biến có thể được thay đổi ở bất kỳ đâu trong chương trình. Vì thế khi có một lỗi xảy ra do một biến thay đổi thành giá trị không muốn muốn, bạn sẽ phải tìm ở đâu? Khắp mọi ngóc ngách? Điều đó thật không tốt chút nào. Đến đây, có thể bạn sẽ thắc mắc rằng: VẬY LÀM THẾ QUÁI NÀO MÀ TÔI CÓ THỂ LÀM VIỆC CHỈ VỚI PURE FUNCTION CHỨ?! Trong FP, Pure Function không phải là thứ duy nhất mà bạn sẽ vieests. FP không thể loại trừ hoàn toàn Side Effects, mà chỉ có thể cô lập chúng. Vì các phần mềm phải giao tiếp, thao tác với thế giới thực, nên một số thành phần bắt buộc phải impure. Mục tiêu của FP là tối thiểu hóa hết mức có thể số lượng impure code và tách biệt chúng hoàn toàn khỏi các phần khác của chương trình. Concept 2 - Immutability : Sự bất biến Bạn còn nhớ lần đầu nhìn thấy dòng code kiểu như này chứ : 12var x = 1;x = x + 1; Khi đó, hẳn là người nào đó dạy bạn lâp trình đã nói rằng : Hãy quên những gì đã học ở môn Toán đi? Vì trong toán học, x không bao giờ bằng x+1 được cả Nhưng trong các ngỗn ngữ Imperative Programming, các câu lệnh trên có nghĩa là, lấy giá trị hiện tại của biến x, cộng nó thêm 1 và gán kết quả trả về vào lại biến x. Tuy nhiên sang đến FP, x = x + 1 lại trở thành không đúng, không được phép. Và bạn sẽ phải nhớ lại những gì mà bạn đã bị bắt phải quên trước đó về toán học. Hmm… Trong Functional Programming không có khái niệm về biến (variable) Để lưu trữ các giá trị, khái niệm biến (variable) vẫn được sử dụng, nhưng các biến này đều là hằng số (constant), tức là nếu biến x đã lưu một giá trị nào đó (là 1 chẳng hạn), thì giá trị của biến x sẽ không thay đổi, vẫn giữ nguyên là 1 như ban đầu được set (và chúng ta gọi là biến hằng số - constant variable) Nếu bạn đang lo lắng về bộ nhớ, thì bạn có thể an tâm khi trong FP, x thường chỉ là biến cục nên thời gian tồn tại thường rất ngắn. Tuy nhiên trong suốt thời gian tồn tại, giá chị của x là bất biến. Đây là một ví dụ về biến hằng số trong Elm, một ngôn ngữ thuần FP cho lập trình Web: 12345addOneToSum y z = let x = 1 in x + y + z Nếu bạn không quen với syntax dạng ML-Style , hãy để tôi giải thích. Hàm addOneToSum nhận 2 tham số là y và z. Trong block của let, biến x được gán với giá trị 1, tức là x sẽ giữ giá trị đó trong suốt phần đời của nó. Vòng đời của x sẽ kết thúc khi hàm kết thúc chạy, cụ thể hơn là sau khi block let được thực hiện. Bên trong block in, các dòng lệnh có thể chứa và tham chiếu đến các giá trị được định nghĩa trông phần block let, ở đây là x. Kết quả của việc tính toán x + y + z được xử lý và trả về, cụ thể hơn ở đây là 1 + y + z sẽ được tính toán trả về, vì x = 1. Và bạn có thể thấy bối rối mà thắc mắc rằng : TÔI LÀM TRÌNH KIỂU MÉO GÌ KHI MÀ KHÔNG CÓ BIẾN SỐ ĐÂY?! Hãy bình tĩnh và nghĩ đến thời điểm mà bạn muốn thay đổi giá trị của biến số. Sẽ có 2 trường hợp cơ bản nhảy ra trong đầu bạn : Thay đổi biến số chứa nhiều giá trị (vd như thay đổi một/nhiều thuộc tính của một đối tượng hoặc bản ghi) và thay đổi biến số chứa một giá trị (vd như bộ đếm trong vòng lặp). FP xử lý việc thay đổi các giá trị trong một bản ghi bằng cách tạo ra một bản sao của bản ghi với dữ liệu được cập nhật. FP xử lý trường hợp thay đổi giá trị này bằng cách: không copy lại tất cả các thành phần của bản ghi, mà sử dụng các cấu trúc dữ liệu để thực hiện việc này một cách hiệu quả nhất. Về việc xử lý trường hợp thay đổi biến số chứa một giá trị, FP cũng làm tương tự như trên, cũng bằng cách tạo ra một bản sao của biến số đó. Và sẽ KHÔNG có vòng lặp trong FP đâu. ĐẦU TIÊN THÌ KHÔNG CÓ BIẾN, VÀ GIỜ THÌ KHÔNG CÓ VÒNG LẶP?! GHÉT RỒI ĐẤY Bình tình nào. Không phải là chúng ta không thể tạo ra các vòng lặp trong FP (tôi không chơi chữ đâu nhé), mà chỉ đơn giản là chúng ta sẽ không có các cấu trúc lặp như là for, while, do, repeat, … thôi. Functional Programming sử dụng đệ quy cho việc lặp. Dưới đây là 2 cách thực hiện vòng lặp trong Javascript: 123456789101112// simple loop constructvar acc = 0;for (var i = 1; i &lt;= 10; ++i) acc += i;console.log(acc); // prints 55// without loop construct or variables (recursion)function sumRange(start, end, acc) &#123; if (start &gt; end) return acc; return sumRange(start + 1, end, acc + start)&#125;console.log(sumRange(1, 10, 0)); // prints 55 Bạn có thể thấy rằng, bằng việc sử dụng đệ quy, chúng ta có thể thực hiện được đúng như những gì mà vòng lặp for phía trên đã thực hiện. Với việc sử dụng hàm sumRange gọi lại chính nó sau mỗi lần chạy với tham số start mới (start + 1) và tham số acc mới (acc + start). Hàm này không hề thay đổi các giá trị mới. Thay vào đó nó sử dụng các giá trị mới được tính toán từ các giá trị cũ. Thật không may, việc này khá là khó để có thể nhìn thấy rõ ràng trong Javascript, kể cả bạn đã bỏ ra chút thời gian để nghiên cứu về nó, bởi 2 lý do sau đây. Thứ nhất là do syntax trong Javascript khá là khó nhìn và thứ hai, là bạn có thể không quen với tư duy suy nghĩ theo đệ quy. Nếu sử dụng Elm, việc đọc sẽ trở nên dễ dàng hơn, và do đó, dễ hiểu hơn đối với bạn: 12345sumRange start end acc = if start &gt; end then acc else sumRange (start + 1) end (acc + start) Đây là kết quả đoạn code trên thực hiện: 123456789101112sumRange 1 10 0 = -- sumRange (1 + 1) 10 (0 + 1)sumRange 2 10 1 = -- sumRange (2 + 1) 10 (1 + 2)sumRange 3 10 3 = -- sumRange (3 + 1) 10 (3 + 3)sumRange 4 10 6 = -- sumRange (4 + 1) 10 (6 + 4)sumRange 5 10 10 = -- sumRange (5 + 1) 10 (10 + 5)sumRange 6 10 15 = -- sumRange (6 + 1) 10 (15 + 6)sumRange 7 10 21 = -- sumRange (7 + 1) 10 (21 + 7)sumRange 8 10 28 = -- sumRange (8 + 1) 10 (28 + 8)sumRange 9 10 36 = -- sumRange (9 + 1) 10 (36 + 9)sumRange 10 10 45 = -- sumRange (10 + 1) 10 (45 + 10)sumRange 11 10 55 = -- 11 &gt; 10 =&gt; 5555 Bạn có thể cho rằng vòng lặp for sẽ dễ hiểu hơn. Trong khi vấn đề này vẫn đang được tranh cãi khá là nhiều, mà có thể nguyên nhân chủ yếu là do sự quen thuộc, thì có một sự thật là các vòng lặp for cần đến khả năng biến đổi của hàm số, mà điều này được cho là không tốt trong FP. Tôi sẽ không giải thích chi tiết những lợi ít của tính bất biến trong bài viết này, nhưng bạn có thể xem phần Global Mutate State trong bài viết Vì sao Lập trình viên cần có giới hạn để biết thêm chi tiết. Một lợi ích rõ ràng của tính bất biến, đó là nếu bạn phải truy cập đến một giá trị bất kỳ trong chương trình của bạn, bạn chỉ có thể có quyền đọc nó, và điều đó tương đương với việc không ai có thể thay đổi giá trị của nó. Kể cả chính bạn. Và do đó sẽ tránh được những thay đổi không mong muốn. Và nếu chương trình của bạn hỗ trợ đa luồng (multi-threaded), thì sẽ không có bất kỳ một thread nào có thể khiến bạn đau đầu. Giá trị được set sẽ là hằng số, và nếu bất kì một thread nào muốn thay đổi nó, thread đó sẽ phải tạo một giá trị mới từ cái cũ. Quay trở lại những năm 90, tôi đã từng viết một Game Engine cho trò chơi Creature Crunch , và nguyên nhân gây ra nhiều bug nhất chính là các vấn đề liên quan đến xử lý đa luồng. Tôi ước gì mình đã biết về Tính bất biến lúc đó. Mà thực ra điều tôi quan tâm nhất khi ấy là sự khác nhau giữa tốc độ đọc 2x và 4x của ổ đĩa CD-ROM sẽ ảnh hưởng thế nào đến hiệu năng chạy game. Tính bất biến tạo ra các dòng code đơn giản hơn và an toàn hơn Đầu của tôi!!!!Tạm thời đến đây thôi là đủ. Trong các phần sau của bài viết này, tôi sẽ nói về các vấn đề như là High-order Function, Functional Composition, Curring, v..v… Nếu bạn muốn tham gia vào cộng đồng các nhà phát triển web muốn học và giúp đỡ lẫn nhau về FP trong Elm, mời các bạn tham gia Group Facebook sau: Learn Elm Programming Và đây là Twitter của tác giả : @cscalfani","categories":[],"tags":[]},{"title":"Giải thích về Value và Reference trong Javascript","slug":"Explaining-Value-vs-Reference-in-Javascript","date":"2017-08-21T12:32:28.000Z","updated":"2017-08-31T00:53:23.895Z","comments":true,"path":"2017/08/Explaining-Value-vs-Reference-in-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Explaining-Value-vs-Reference-in-Javascript.html","excerpt":"Dùng một cái nhìn đơn giản của bộ nhớ máy tính giải thích điều này Javascript có 5 kiểu dữ liệu được thông qua value: Boolean, null, undefined, String, và Number. Chúng ta sẽ gọi chung là primitive types. Javascript có 5 kiểu dữ liệu được thông qua reference: Array, Function, và Object. Về mặt kỹ thuật đó là Objects, vì vậy chúng ta sẽ đề cập đến chúng chung chung như Objects.","text":"Dùng một cái nhìn đơn giản của bộ nhớ máy tính giải thích điều này Javascript có 5 kiểu dữ liệu được thông qua value: Boolean, null, undefined, String, và Number. Chúng ta sẽ gọi chung là primitive types. Javascript có 5 kiểu dữ liệu được thông qua reference: Array, Function, và Object. Về mặt kỹ thuật đó là Objects, vì vậy chúng ta sẽ đề cập đến chúng chung chung như Objects. Primitives (Nguyên thủy)Nếu một kiểu nguyên thủy được gán cho một biến, chúng ta có thể nghĩ rằng biến đó chứa đựng giá trị nguyên thủy. 123var x = 10;var y = 'abc';var z = null; x chứa đựng 10. y chứa đựng &#39;abc&#39;. Để củng cố ý tưởng này, chúng tôi sẽ cung cấp một hình ảnh về những gì các biến này và các giá trị tương ứng giống như trong bộ nhớ. Khi chúng ta gán các biến này cho các biến khác sử dụng dấu =, Chúng ta copy giá trị cho biến mới. Chúng được sao chép theo giá trị. 12345var x = 10;var y = 'abc';var a = x;var b = y;console.log(x, y, a, b); // -&gt; 10, 'abc', 10, 'abc' Cả a và x bây giờ chứa 10. Cả b và y bây giờ chứa &#39;abc&#39;. Chúng là tách biệt, vì các giá trị được sao chép. Khi thay đổi một biến nó không thay đổi cái khác. Hãy suy nghĩ là các biến như không có mối quan hệ với nhau. 12345678var x = 10;var y = 'abc';var a = x;var b = y;a = 5;b = 'def';console.log(x, y, a, b); // -&gt; 10, 'abc', 5, 'def' ObjectsThis will feel confusing, but bear with me and read through it. Once you get through it, it’ll seem easy. Variables that are assigned a non-primitive value are given a reference to that value. That reference points to the object’s location in memory. The variables don’t actually contain the value. Objects are created at some location in your computer’s memory. When we write arr = [], we’ve created an array in memory. What the variable arr receives is the address, the location, of that array. Let’s pretend that address is a new data type that is passed by value, just like number or string. An address points to the location, in memory, of a value that is passed by reference. Just like a string is denoted by quotation marks (&#39;&#39; or &quot;&quot;), an address will be denoted by arrow brackets, &lt;&gt;. When we assign and use a reference-type variable, what we write and see is: 121) var arr = [];2) arr.push(1); A representation of lines 1 and 2 above in memory is: 1. 2. Notice that the value, the address, contained by the variable arr is static. The array in memory is what changes. When we use arr to do something, such as pushing a value, the Javascript engine goes to the location of arr in memory and works with the information stored there. Assigning by ReferenceWhen a reference type value, an object, is copied to another variable using =, the address of that value is what’s actually copied over as if it were a primitive. Objects are copied by reference instead of by value. 12var reference = [1];var refCopy = reference; The code above looks like this in memory. Each variable now contains a reference to the same array. That means that if we alter reference, refCopy will see those changes: 12reference.push(2);console.log(reference, refCopy); // -&gt; [1, 2], [1, 2] We’ve pushed 2 into the array in memory. When we use reference and refCopy, we’re pointing to that same array. Reassigning a ReferenceReassigning a reference variable replaces the old reference. 1var obj = &#123; first: 'reference' &#125;; In memory: When we have a second line: 12var obj = &#123; first: 'reference' &#125;;obj = &#123; second: 'ref2' &#125; The address stored in obj changes. The first object is still present in memory, and so is the next object: When there are no references to an object remaining, as we see for the address #234 above, the Javascript engine can perform garbage collection. This just means that the programmer has lost all references to the object and can’t use the object any more, so the engine can go ahead and safely delete it from memory. In this case, the object { first: &#39;reference&#39; } is no longer accessible and is available to the engine for garbage collection. == and ===When the equality operators, == and ===, are used on reference-type variables, they check the reference. If the variables contain a reference to the same item, the comparison will result in true. 12var arrRef = [’Hi!’];var arrRef2 = arrRef;console.log(arrRef === arrRef2); // -&gt; true If they’re distinct objects, even if they contain identical properties, the comparison will result in false. 12var arr1 = ['Hi!'];var arr2 = ['Hi!'];console.log(arr1 === arr2); // -&gt; false If we have two distinct objects and want to see if their properties are the same, the easiest way to do so is to turn them both into strings and then compare the strings. When the equality operators are comparing primitives, they simply check if the values are the same. 12var arr1str = JSON.stringify(arr1);var arr2str = JSON.stringify(arr2);console.log(arr1str === arr2str); // true Another option would be to recursively loop through the objects and make sure each of the properties are the same. Passing Parameters through FunctionsWhen we pass primitive values into a function, the function copies the values into its parameters. It’s effectively the same as using =. 1234567var hundred = 100;var two = 2;function multiply(x, y) &#123; // PAUSE return x * y;&#125;var twoHundred = multiply(hundred, two); In the example above, we give hundred the value 100. When we pass it into multiply, the variable x gets that value, 100. The value is copied over as if we used an = assignment. Again, the value of hundred is not affected. Here is a snapshot of what the memory looks like right at the PAUSE comment line in multiply. Pure FunctionsWe refer to functions that don’t affect anything in the outside scope as pure functions. As long as a function only takes primitive values as parameters and doesn’t use any variables in its surrounding scope, it is automatically pure, as it can’t affect anything in the outside scope. All variables created inside are garbage-collected as soon as the function returns. A function that takes in an Object, however, can mutate the state of its surrounding scope. If a function takes in an array reference and alters the array that it points to, perhaps by pushing to it, variables in the surrounding scope that reference that array see that change. After the function returns, the changes it makes persist in the outer scope. This can cause undesired side effects that can be difficult to track down. Many native array functions, including Array.map and Array.filter, are therefore written as pure functions. They take in an array reference and internally, they copy the array and work with the copy instead of the original. This makes it so the original is untouched, the outer scope is unaffected, and we’re returned a reference to a brand new array. Let’s go into an example of a pure vs. impure function. 123456789101112function changeAgeImpure(person) &#123; person.age = 25; return person;&#125;var alex = &#123; name: 'Alex', age: 30&#125;;var changedAlex = changeAgeImpure(alex);console.log(alex); // -&gt; &#123; name: 'Alex', age: 25 &#125;console.log(changedAlex); // -&gt; &#123; name: 'Alex', age: 25 &#125; This impure function takes in an object and changes the property age on that object to be 25. Because it acts on the reference it was given, it directly changes the object alex. Note that when it returns the person object, it is returning the exact same object that was passed in. alex and alexChanged contain the same reference. It’s redundant to return the person variable and to store the reference in a new variable. Let’s look at a pure function. 12345678910111213function changeAgePure(person) &#123; var newPersonObj = JSON.parse(JSON.stringify(person)); newPersonObj.age = 25; return newPersonObj;&#125;var alex = &#123; name: 'Alex', age: 30&#125;;var alexChanged = changeAgePure(alex);console.log(alex); // -&gt; &#123; name: 'Alex', age: 30 &#125;console.log(alexChanged); // -&gt; &#123; name: 'Alex', age: 25 &#125; In this function, we use JSON.stringify to transform the object we’re passed into a string, and then parse it back into an object with JSON.parse. By performing this transformation and storing the result in a new variable, we’ve created a new object. There are other ways to do the same thing such as looping through the original object and assigning each of its properties to a new object, but this way is simplest. The new object has the same properties as the original but it is a distinctly separate object in memory. When we change the age property on this new object, the original is unaffected. This function is now pure. It can’t affect any object outside its own scope, not even the object that was passed in. The new object needs to be returned and stored in a new variable or else it gets garbage collected once the function completes, as the object is no longer in scope. Test YourselfValue vs. reference is a concept often tested in coding interviews. Try to figure out for yourself what’s logged here. 1234567891011121314151617function changeAgeAndReference(person) &#123; person.age = 25; person = &#123; name: 'John', age: 50 &#125;; return person;&#125;var personObj1 = &#123; name: 'Alex', age: 30&#125;;var personObj2 = changeAgeAndReference(personObj1);console.log(personObj1); // -&gt; ?console.log(personObj2); // -&gt; ? The function first changes the property age on the original object it was passed in. It then reassigns the variable to a brand new object and returns that object. Here’s what the two objects are logged out. 12console.log(personObj1); // -&gt; &#123; name: 'Alex', age: 25 &#125;console.log(personObj2); // -&gt; &#123; name: 'John', age: 50 &#125; Remember that assignment through function parameters is essentially the same as assignment with =. The variable person in the function contains a reference to the personObj1 object, so initially it acts directly on that object. Once we reassign person to a new object, it stops affecting the original. This reassignment does not change the object that personObj1 points to in the outer scope. person has a new reference because it was reassigned but this reassignment doesn’t change personObj1. An equivalent piece of code to the above block would be: 123456789101112131415var personObj1 = &#123; name: 'Alex', age: 30&#125;;var person = personObj1;person.age = 25;person = &#123; name: 'john', age: 50&#125;;var personObj2 = person;console.log(personObj1); // -&gt; &#123; name: 'Alex', age: 25 &#125;console.log(personObj2); // -&gt; &#123; name: 'John', age: '50' &#125; The only difference is that when we use the function, person is no longer in scope once the function ends. Kết thúc. Bắt đầu viết code nào.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"Thực hành tối ưu những ứng dụng React","slug":"Optimizing-React-Apps-in-Practice","date":"2017-08-21T12:21:55.000Z","updated":"2017-08-31T01:00:24.154Z","comments":true,"path":"2017/08/Optimizing-React-Apps-in-Practice.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Optimizing-React-Apps-in-Practice.html","excerpt":"React có thể chậm. Ý tôi là, bất kỳ ứng dụng React với kích thước trung bình có thể có vẻ chậm. Nhưng trước khi bạn bắt đầu tìm kiếm các phương án thay thế, bạn nên biết rằng bất kỳ ứng dụng Angular hay Ember cỡ trung bình nào cũng chậm. Tin vui là: Nếu bạn quan tâm đến hiệu suất, nó khá dễ dàng để làm bất kỳ ứng dụng React trở nên siêu nhanh ⚡.️ Đây là cách.","text":"React có thể chậm. Ý tôi là, bất kỳ ứng dụng React với kích thước trung bình có thể có vẻ chậm. Nhưng trước khi bạn bắt đầu tìm kiếm các phương án thay thế, bạn nên biết rằng bất kỳ ứng dụng Angular hay Ember cỡ trung bình nào cũng chậm. Tin vui là: Nếu bạn quan tâm đến hiệu suất, nó khá dễ dàng để làm bất kỳ ứng dụng React trở nên siêu nhanh ⚡.️ Đây là cách. Measuring React PerformanceWhat do I mean by “slow”? Let’s take an example: I’m working on an open-source project called admin-on-rest, which leverages material-ui and Redux to provide an admin GUI for any REST API. This application has a datagrid page, displaying a list of records in a table. When the user changes the sort order, or goes to the next page, or filters the result, the interface isn’t as responsive as I would expect. The following screencast shows the refresh slowed down five times: To see what’s happening, I append a ?react_perf to the URL. This enables Component Profiling since React 15.4. I wait for the initial datagrid to load. Then I open the Chrome Developer Tools on the Timeline tab, hit the “Record” button, and click on a table header to update the sort order. Once the data refreshes, I hit the “Record” button again to stop recording, and Chrome displays a yellow flamegraph with a “User Timing” label. If you’ve never seen a flamegraph, it can look intimidating, but it’s actually very easy to use. This “User Timing” graph shows the time passed in each of your components. It hides the time spend inside React internals (you can’t optimize this time anyway), so it lets you focus on optimizing your app. The Timeline displays screenshots of the window at various stages, this lets me zoom in to the moment I clicked on the table header: It seems that my app rerenders the &lt;List&gt; component just after clicking on the sort button, before even fetching the REST data. And this takes more than 500ms. The app just updates the sort icon in the table header, and displays a grey overlay on the datagrid to show that the data is being fetched. To put it otherwise, the app takes half a second to provide visual feedback to a click. Half a second is definitely perceivable — UI experts say that users perceive an interface change as instantaneous when it’s below 100ms. A change slower than that is what I mean by “slow”. Why Did You Update?In the flamegraph above, you can see many tiny pits. That’s not a good sign. It means that many components are rerendered. The flamegraph shows that the &lt;Datagrid&gt; update takes the most time. Why did the app rerender the entire datagrid before fetching new data? Let’s dig down. Understanding the causes of a rerender often implies adding console.log() statements in render() functions. For functional components, you can use the following one-liner Higher-Order Component (HOC): 12345678// in src/log.jsconst log = BaseComponent =&gt; props =&gt; &#123; console.log(`Rendering $&#123;BaseComponent.name&#125;`); return &lt;BaseComponent &#123;…props&#125; /&gt;;&#125;export default log;// in src/MyComponent.jsimport log from ‘./log’;export default log(MyComponent); Tip: Another React performance tool worth mentioning is why-did-you-update. This npm package patches React to emit console warnings whenever a component rerenders with identical props. Caveats: The output is verbose, and it doesn’t work on functional components. In the example, when the user clicks on a header column, the app emits an action, which changes the state: the list sort order (currentSort) is updated. This state change triggers the rerendering of the &lt;List&gt; page, which in turn rerenders the entire &lt;Datagrid&gt; component. We want the datagrid header to be immediately rendered to show the sort icon change as a feedback to user action. What makes a React app slow is usually not a single slow component (that would translate in the flamegraph as one large pit). What makes a React app slow is, most of the time, useless rerenders of many components. You may have read that the React VirtualDom is super fast. That’s true, but in a medium size app, a full redraw can easily render hundreds of components. Even the fastest VirtualDom templating engine can’t make that in less than 16ms. Cutting Components To Optimize ThemHere is the &lt;Datagrid&gt; component render() method: 12345678910111213141516171819202122232425262728293031323334353637383940// in Datagrid.jsrender() &#123; const &#123; resource, children, ids, data, currentSort &#125; = this.props; return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &#123;Children.map(children, (field, index) =&gt; &lt;DatagridHeaderCell key=&#123;index&#125; field=&#123;field&#125; currentSort=&#123;currentSort&#125; updateSort=&#123;this.updateSort&#125; /&gt; )&#125; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;ids.map(id =&gt; ( &lt;tr key=&#123;id&#125;&gt; &#123;Children.map(children, (field, index) =&gt; &lt;DatagridCell record=&#123;data[id]&#125; key=&#123;`$&#123;id&#125;-$&#123;index&#125;`&#125; field=&#123;field&#125; resource=&#123;resource&#125; /&gt; )&#125; &lt;/tr&gt; ))&#125; &lt;/tbody&gt; &lt;/table&gt; );&#125; This seems like a very simple implementation of a datagrid, yet it is very inefficient. Each &lt;DatagridCell&gt; call renders at least two or three components. As you can see in the initial interface screencast, the list has 7 columns, 11 rows, that means 7113 = 231 components rerended. When only the currentSort changes, it’s a waste of time. Even though React doesn’t update the real DOM if the rerendered VirtualDom is unchanged, it takes about 500ms to process all the components. In order to avoid a useless rendering of the table body, I must first extract it: 123456789101112131415161718192021222324252627282930// in Datagrid.jsrender() &#123; const &#123; resource, children, ids, data, currentSort &#125; = this.props; return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &#123;React.Children.map(children, (field, index) =&gt; &lt;DatagridHeaderCell key=&#123;index&#125; field=&#123;field&#125; currentSort=&#123;currentSort&#125; updateSort=&#123;this.updateSort&#125; /&gt; )&#125; &lt;/tr&gt; &lt;/thead&gt; &lt;DatagridBody resource=&#123;resource&#125; ids=&#123;ids&#125; data=&#123;data&#125;&gt; &#123;children&#125; &lt;/DatagridBody&gt; &lt;/table&gt; ); );&#125; I created a new &lt;DatagridBody&gt; component by extracting the table body logic: 12345678910111213141516171819// in DatagridBody.jsimport React, &#123; Children &#125; from 'react';const DatagridBody = (&#123; resource, ids, data, children &#125;) =&gt; ( &lt;tbody&gt; &#123;ids.map(id =&gt; ( &lt;tr key=&#123;id&#125;&gt; &#123;Children.map(children, (field, index) =&gt; &lt;DatagridCell record=&#123;data[id]&#125; key=&#123;`$&#123;id&#125;-$&#123;index&#125;`&#125; field=&#123;field&#125; resource=&#123;resource&#125; /&gt; )&#125; &lt;/tr&gt; ))&#125; &lt;/tbody&gt;);export default DatagridBody; Extracting the table body has no effect on performance, but it reveals the path to optimization. Large, general purpose components are hard to optimize. Small, single-responsibility components are much easier to deal with. shouldComponentUpdateThe React documentation is very clear about the way to avoid useless rerenders: shouldComponentUpdate(). By default, React always renders a component to the virtual DOM. In other terms, it’s your job as a developer to check that the props of a component didn’t change and skip rendering altogether in that case. In the case of the &lt;DatagridBody&gt; component above, there should be no rerender of the body unless the props have changed. So the component should be completed as follows: 123456789101112131415161718192021222324252627import React, &#123; Children, Component &#125; from 'react';class DatagridBody extends Component &#123; shouldComponentUpdate(nextProps) &#123; return (nextProps.ids !== this.props.ids || nextProps.data !== this.props.data); &#125; render() &#123; const &#123; resource, ids, data, children &#125; = this.props; return ( &lt;tbody&gt; &#123;ids.map(id =&gt; ( &lt;tr key=&#123;id&#125;&gt; &#123;Children.map(children, (field, index) =&gt; &lt;DatagridCell record=&#123;data[id]&#125; key=&#123;`$&#123;id&#125;-$&#123;index&#125;`&#125; field=&#123;field&#125; resource=&#123;resource&#125; /&gt; )&#125; &lt;/tr&gt; ))&#125; &lt;/tbody&gt; ); &#125;&#125;export default DatagridBody; Tip: As an alternative to implementing shouldComponentUpdate() manually, I could inherit from React’s PureComponent instead of Component. This would compare all props using strict equality (===) and rerender only if any of the props change. But I know that resource and children cannot change in that context, so I don’t need to check for their equality. With this optimization, the rerendering of the &lt;Datagrid&gt; component after clicking on a table header skips the table body and its 231 components entirely. This reduces the update time from 500ms to 60ms. That’s a net performance improvement of more than 400ms! Tip: Don’t get fooled by the flamegraph width, it’s zoomed even more than the previous flamegraph. This one is definitely better! The shouldComponentUpdate optimization has removed a lot of pits in the graph, and reduced the overall rendering time. I can use the same trick to avoid even more rerenders (e.g. to avoid rendering the sidebar, the action buttons, the table headers that didn’t change, the pagination). After about an hour of work, the entire page renders just 100ms after clicking on a header column. That’s fast enough — even if there is still room for optimization. Adding a shouldComponentUpdate method may seem cumbersome, but if you care about performance, most of the components you write should end up with one. Don’t do it everywhere — executing shouldComponentUpdate on simple components is sometimes slower than just rendering the component. Don’t do that too early in the life of an application either — this would be premature optimization. But as your apps grow, and you can detect performance bottlenecks in your components, add shouldComponentUpdate logic to remain fast. RecomposeI’m not very happy with the previous change on &lt;DatagridBody&gt;: because of shouldComponentUpdate, I had to transform a simple, functional component to a class-based component. This adds more lines of code, and every line of code has a cost — to write, to debug, and to maintain. Fortunately, you can implement the shouldComponentUpdate logic in a higher-order component (HOC) thanks to recompose. It’s a functional utility belt for React, providing for instance the pure() HOC: 1234567891011121314151617181920// in DatagridBody.jsimport React, &#123; Children &#125; from 'react';import pure from 'recompose/pure';const DatagridBody = (&#123; resource, ids, data, children &#125;) =&gt; ( &lt;tbody&gt; &#123;ids.map(id =&gt; ( &lt;tr key=&#123;id&#125;&gt; &#123;Children.map(children, (field, index) =&gt; &lt;DatagridCell record=&#123;data[id]&#125; key=&#123;`$&#123;id&#125;-$&#123;index&#125;`&#125; field=&#123;field&#125; resource=&#123;resource&#125; /&gt; )&#125; &lt;/tr&gt; ))&#125; &lt;/tbody&gt;);export default pure(DatagridBody); The only difference between this code and the initial implementation is the last line: I export pure(DatagridBody) instead of DatagridBody. pure is like PureComponent, but without the extra class boilerplate. I can even be more specific and target only the props that I know may change, using recompose’s shouldUpdate() instead of pure(): 12345678910// in DatagridBody.jsimport React, &#123; Children &#125; from 'react';import shouldUpdate from ‘recompose/shouldUpdate’;const DatagridBody = (&#123; resource, ids, data, children &#125;) =&gt; ( ...);const checkPropsChange = (props, nextProps) =&gt; (nextProps.ids !== props.ids || nextProps.data !== props.data);export default shouldUpdate(checkPropsChange)(DatagridBody); The checkPropsChange function is pure, and I can even export it for unit tests. The recompose library offers more performance HOCs, like onlyUpdateForKeys(), which does exactly the type of check I did in my own checkPropsChange: 1234567// in DatagridBody.jsimport React, &#123; Children &#125; from 'react';import onlyUpdateForKeys from ‘recompose/onlyUpdateForKeys’;const DatagridBody = (&#123; resource, ids, data, children &#125;) =&gt; ( ...);export default onlyUpdateForKeys([‘ids’, ‘data’])(DatagridBody); I warmly recommend recompose. Beyond performance optimization, it helps you extract data fetching logic, HOC composition, and props manipulation in a functional and testable way. ReduxIf you’re using Redux to manage application state (which I also recommend), then connected components are already pure. No need to add another HOC. Just remember that if only one of the props change, then the connected component rerenders — this includes all its children, too. So even if you use Redux for page components, you should use pure() or shouldUpdate() for components further down in the render tree. Also, beware that Redux does the props comparison using strict equality. Since Redux connects the state to a component’s props, if you mutate an object in the state, Redux props comparison will miss it. That’s why you must use immutability in your reducers. For instance, in admin-on-rest, clicking on a table header dispatches a SET_SORT action. The reducer listening to that action must pay attention to replace objects in the state, not update them: 12345678910111213141516171819202122232425262728293031323334// in listReducer.jsexport const SORT_ASC = 'ASC';export const SORT_DESC = 'DESC';const initialState = &#123; sort: 'id', order: SORT_DESC, page: 1, perPage: 25, filter: &#123;&#125;,&#125;;export default (previousState = initialState, &#123; type, payload &#125;) =&gt; &#123; switch (type) &#123; case SET_SORT: if (payload === previousState.sort) &#123; // inverse sort order return &#123; ...previousState, order: oppositeOrder(previousState.order), page: 1, &#125;; &#125; // replace sort field_ return &#123; ...previousState, sort: payload, order: SORT_ASC, page: 1, &#125;; // ... default: return previousState; &#125;&#125;; With this reducer, when Redux checks for changes using triple equal, it finds that the state object is different, and rerenders the datagrid. But had we mutated the state, Redux would have missed the state change, and skipped rerendering by mistake: 12345678910111213141516171819// don't do this at homeexport default (previousState = initialState, &#123; type, payload &#125;) =&gt; &#123; switch (type) &#123; case SET_SORT: if (payload === previousState.sort) &#123; // never do this previousState.order = oppositeOrder(previousState.order); return previousState; &#125; // never do that either previousState.sort = payload; previousState.order = SORT_ASC; previousState.page = 1; return previousState; // ... default: return previousState; &#125;&#125;; To write immutable reducers, other developers like to use immutable.js, also from Facebook. I find it unnecessary, since ES6 destructuring makes it easy to selectively replace a component properties. Besides, Immutable is heavy (60kB), so think twice before you add it to your project dependencies. ReselectTo prevent useless renders in (Redux) connected components, you must also make sure that the mapStateToProps function doesn’t return new objects each time it is called. Take for instance the &lt;List&gt; component in admin-on-rest. It grabs the list of records for the current resource (e.g. posts, comments, etc) from the state using the following code: 123456789101112131415161718// in List.jsimport React from 'react';import &#123; connect &#125; from 'react-redux';const List = (props) =&gt; ...const mapStateToProps = (state, props) =&gt; &#123; const resourceState = state.admin[props.resource]; return &#123; ids: resourceState.list.ids, data: Object.keys(resourceState.data) .filter(id =&gt; resourceState.list.ids.includes(id)) .map(id =&gt; resourceState.data[id]) .reduce((data, record) =&gt; &#123; data[record.id] = record; return data; &#125;, &#123;&#125;), &#125;;&#125;;export default connect(mapStateToProps)(List); The state contains an array of all the previously fetched records, indexed by resource. For instance, state.admin.posts.data contains the list of posts: 12345&#123; 23: &#123; id: 23, title: “Hello, World”, /* … */ &#125;, 45: &#123; id: 45, title: “Lorem Ipsum”, /* … */ &#125;, 67: &#123; id: 67, title: “Sic dolor amet”, /* … */ &#125;,&#125; The mapStateToProps function filters this state object to return only the records actually displayed in the list. Something like: 1234&#123; 23: &#123; id: 23, title: “Hello, World”, /* … */ &#125;, 67: &#123; id: 67, title: “Sic dolor amet”, /* … */ &#125;,&#125; The problem is that each time mapStateToProps runs, it returns a new object, even if the underlying objects didn’t change. As a consequence, the &lt;List&gt; component rerenders every time something in the state changes — while id should only change if the date or ids change. Reselect solves this problem by using memoization. Instead of computing the props directly in mapStateToProps, you use a selector from reselect, which returns the same output if the input didn’t change. 123456789101112131415161718192021222324252627import React from 'react';import &#123; connect &#125; from 'react-redux';import &#123; createSelector &#125; from 'reselect'const List = (props) =&gt; ...const idsSelector = (state, props) =&gt; state.admin[props.resource].idsconst dataSelector = (state, props) =&gt; state.admin[props.resource].dataconst filteredDataSelector = createSelector( idsSelector, dataSelector (ids, data) =&gt; Object.keys(data) .filter(id =&gt; ids.includes(id)) .map(id =&gt; data[id]) .reduce((data, record) =&gt; &#123; data[record.id] = record; return data; &#125;, &#123;&#125;))const mapStateToProps = (state, props) =&gt; &#123; const resourceState = state.admin[props.resource]; return &#123; ids: idsSelector(state, props), data: filteredDataSelector(state, props), &#125;;&#125;;export default connect(mapStateToProps)(List); Now the &lt;List&gt; component will only rerender if a subset of the state changes. As for recompose, reselect selectors are pure functions, easy to test and compose. It’s a great way to code your selectors for Redux connected components. Beware of Object Literals in JSXOnce your components become more “pure”, you start detecting bad patterns that lead to useless rerenders. The most common is the usage of object literals in JSX, which I like to call “The infamous \\{\\{”. Let me give you an example: 1234567import React from 'react';import MyTableComponent from './MyTableComponent';const Datagrid = (props) =&gt; ( &lt;MyTableComponent style=&#123;&#123; marginTop: 10 &#125;&#125;&gt; ... &lt;/MyTableComponent&gt;) The style prop of the &lt;MyTableComponent&gt; component gets a new value every time the &lt;Datagrid&gt; component is rendered. So even if &lt;MyTableComponent&gt; is pure, it will be rendered every time &lt;Datagrid&gt; is rendered. In fact, each time you pass an object literal as prop to a child component, you break purity. The solution is simple: 12345678import React from 'react';import MyTableComponent from './MyTableComponent';const tableStyle = &#123; marginTop: 10 &#125;;const Datagrid = (props) =&gt; ( &lt;MyTableComponent style=&#123;tableStyle&#125;&gt; ... &lt;/MyTableComponent&gt;) This looks very basic, but I’ve seen this mistake so many times that I’ve developed a sense for detecting the infamous \\{\\{ in JSX. I routinely replace it with constants. Another usual suspect for hijacking pure components is React.cloneElement(). If you pass a prop by value as second parameter, the cloned element will receive new props at every render. 12345678// badconst MyComponent = (props) =&gt; &lt;div&gt;&#123;React.cloneElement(Foo, &#123; bar: 1 &#125;)&#125;&lt;/div&gt;;// goodconst additionalProps = &#123; bar: 1 &#125;;const MyComponent = (props) =&gt; &lt;div&gt;&#123;React.cloneElement(Foo, additionalProps)&#125;&lt;/div&gt;; This has bitten me a couple times with material-ui, for instance with the following code: 123456789import &#123; CardActions &#125; from 'material-ui/Card';import &#123; CreateButton, RefreshButton &#125; from 'admin-on-rest';const Toolbar = (&#123; basePath, refresh &#125;) =&gt; ( &lt;CardActions&gt; &lt;CreateButton basePath=&#123;basePath&#125; /&gt; &lt;RefreshButton refresh=&#123;refresh&#125; /&gt; &lt;/CardActions&gt;);export default Toolbar; Although &lt;CreateButton&gt; is pure, it was rendered every time &lt;Toolbar&gt; was rendered. That’s because material-ui’s &lt;CardActions&gt; adds a special style to its first child to accommodate for margins — and it does so with an object literal. So &lt;CreateButton&gt; received a different style prop every time. I solved it using recompose’s onlyUpdateForKeys() HOC. 123456// in Toolbar.jsimport onlyUpdateForKeys from 'recompose/onlyUpdateForKeys';const Toolbar = (&#123; basePath, refresh &#125;) =&gt; ( ...);export default onlyUpdateForKeys(['basePath', 'refresh'])(Toolbar); ConclusionThere are many other things you should do to keep your React app fast (using keys, lazy loading heavy routes, the react-addons-perf package, using ServiceWorkers to cache app state, going isomorphic, etc), but implementing shouldComponentUpdate correctly is the first step — and the most rewarding. React isn’t fast by default, but it offers all the tools to be fast whatever the size of the application. This may seem counterintuitive, especially since many frameworks offering an alternative to React claim themselves as n times faster. But React puts developer experience before performance. That’s the reason why developing large apps with React is such a pleasant experience, without bad surprises, and a constant implementation rate. Just remember to profile your app every once in a while, and dedicate some time to add a few pure() calls where it’s needed. Don’t do it first, or spend too much time to over optimize each and every component — except if you’re on mobile. And remember to test on various devices to get a good impression of your app’s responsiveness from a user’s point of view. If you want to read more about React performance optimization, here is a list of great articles on the subject: React Rally: Animated — React Performance Toolbox: A fabulous slide deck by Christopher Chedeau (Vjeux), one of the React Native developers. He’s French, by the way. Progressive Web Apps with React.js: Part 2 — Page Load Performance by Addy Osmany, who works at Google and writes a lot of blog posts about web performance Optimizing the Performance of Your React Application focuses on the react-addons-perf package to profile React apps precisely React Higher Order Components in depth, interesting for the introduction of Render Hijacking A Deep Dive into React Perf Debugging describes a step-by-step debugging session with Chrome dev Tools Making React reactive: the pursuit of high performing, easily maintainable React apps on using Observables to avoid rerenders","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Use const Until You Have to Use let","slug":"Use-const-Until-You-Have-to-Use-let","date":"2017-08-21T11:44:18.000Z","updated":"2017-08-21T15:42:19.465Z","comments":true,"path":"2017/08/Use-const-Until-You-Have-to-Use-let.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Use-const-Until-You-Have-to-Use-let.html","excerpt":"Aloha, web surfer. So perhaps you’re a let fan who came here to see what was up. Or maybe you’re a beginner, just moving out of var town and into the wild west that is ES6 variable declaration. Whatever your experience level may be, I hope this article provides valuable insights and leaves you with a solid rule of thumb for instantiating variables in Javascript. My other hope is that, upon finishing this article, you can confidently part ways with var – it is time.","text":"Aloha, web surfer. So perhaps you’re a let fan who came here to see what was up. Or maybe you’re a beginner, just moving out of var town and into the wild west that is ES6 variable declaration. Whatever your experience level may be, I hope this article provides valuable insights and leaves you with a solid rule of thumb for instantiating variables in Javascript. My other hope is that, upon finishing this article, you can confidently part ways with var – it is time. Once Upon A Time……in a specification authored somewhere in California… …a keyword for variable instantiation was created and called var. If you remember your first day learning Javascript, it probably involved var. This little keyword was our only option for declaring variables in Javascript for a long time. In fact, every web site and application that used Javascript between it’s inception in 1995 and the release of ECMAScript 2015 (ES6) used var and only var to create variables. (Someone fact check me on this statement, but I think it’s accurate.) The var keyword is no longer relevant, but in order to truly understand our present, we must understand our past. Some important things to know about variables created with the var keyword: 1231) They are function scoped2) Their declarations get hoisted3) They can be declared without a value 1 “They are function scoped”This means that var creates a variable that only exists inside of the function where it was declared. (Unless it was not declared inside a function. In that case, it exists ~everywhere~ 😲. More on this in fact #3.) Here’s a code snippet that illustrates the behavior of a function scoped variable: 123456function logA() &#123; var a = 2; console.log(a); // inside of `logA()`, `a` exists with value 2&#125;console.log(a); // ReferenceError! Outside of logA(), `a` is not defined. I think it’s worth clarifying that when I say “inside of” logA(), I mean “between logA()’s curly brackets”. 2 “Their declarations get hoisted” 🏋Variable hoisting basically boils down to the fact that a variable declared with var can be instantiated after it gets used. This code… 123456function logB() &#123; b = 2; // using b to hold the number 2 console.log(b); // using b to print 2 in the console var b; // instantiating b 🤔&#125; …will get transformed into something like this code… 123456function logB() &#123; var b; // instantiation is hoisted to the top of logB()'s scope b = 2; console.log(b);&#125; …at compile time (yes, Javascript gets compiled). That’s why it doesn’t matter (to the browser) where we instantiate our variables – the declarations get to skip the line every time. There’s a dark side to the way var gets hoisted, though. Javascript’s compiler can be a bit too helpful in some situations. If we use a variable within a function but don’t instantiate the variable in that function, the compiler will look for a var in the parent function scope. If it doesn’t find it there, it will keep looking all the way up the scope chain until it gets to the global scope. If it still doesn’t see a var declaration up there, it will just go ahead and make one for you, as demonstrated in this snippet: 12345function logC() &#123; c = 2; console.log(c); // 2&#125;// c is not instantiated in this program, yet it just works... Yikes. I guess this could be convenient sometimes when messing around in a REPL or something… But for the most part, this is bananas. &quot;use strict&quot;; prevents this and should be included at the top of any ES5 script. 3 “They can be declared without a value”You may have seen someone do something along these lines before: 1234567// declare all my variables at the top of the scriptvar a, b, c;// use them down herea = 1;b = 2;c = a + b; Put a pin in this because it becomes important later. Times Have ChangedThe three facets of var that I just covered come together to create an extremely flexible variable declaration mechanism. While flexibility itself is not a bad thing and having only one variable instantiation keyword means a little more flexibility is necessary, var is simply doing too much. Function scope isn’t a problem, but reassigning variables is so-so and should only be used for for loops and times when it’s completely unavoidable (and when it’s unavoidable, it probably means we have bigger fish to fry). The same goes for declaring variables without values. Lastly, being allowed to use a variable whether we declared it or not is silly. So, in order to address these drawbacks of var and save us developers from the pitfalls these “helpful” features can cause, the ES6 specification introduced two new variable keywords: const and let. Remember, the primary goal of this post is to show that it’s time to ditch var. Times have changed and var doesn’t make the cut. Let me explain…In 2015, Javascript’s variable declaration family grew to include let, which deviates significantly from var in that it is block scoped. This basically means that we now have two units of scope available: 1 Functions12345function() &#123; let i = 'aye'; // `i` is scoped to this function console.log(i); // \"aye\"&#125;console.log(i); // ReferenceError 2 Blocks12345&#123; let i = 'oi'; // `i` is scoped to this block console.log(i); // \"oi\"&#125;console.log(i); // ReferenceError The let keyword has another helpful constraint: the variable cannot be accessed before its declaration (let does get hoisted though). One thing let shares with var is that it can be used to declare a variable without an initial value. Like in the example above, we could have done 1234&#123; let i; i = 'oi';&#125; and it would’ve worked. Bookmarks for let 👓 Are Let / Const Hoisted? YDKJS Blocks As Scopes YDKJS Let YDKJS Garbage Collection YDKJS Let loops Const stop, won’t stopOkay, const is my favorite variable declaration keyword in Javascript. I default to const over let and never use var. As a rule, I always use const unless I have to use let. Remember how variables declared with var can be instantiated with empty values? This type of instantiation is allowed with let, too. It is not so with const. Oh no, const requires that you provide a value up front. Otherwise, it will turn its nose up at you and refuse to create a variable, “If you don’t know what’s going in the variable, monsieur/madame, then why do you need it at all?” – this is good. But there’s more! const goes one step further and ensures that the variable cannot be reassigned [note: this does not mean the variable is immutable]. For example, 12const a = 'ay';a = 2; // TypeError: Assignment to constant variable. Comparing const to var: 1 const is block scoped, var is function scoped. 2 const has to be instantiated with a value, var does not 3 const cannot be reassigned, var can 4 const cannot be accessed prior to instantiation, var can So basically const is the strictest variable instantiation tool we have at our disposal. The constraints it provides protect us from several possible errors, making the development process smoother. Exceptions: When to use letWhile I recommend defaulting to const, some situations demand the use of let. Here is a quote by Eric Elliot from a great article he wrote about the three keywords: 1`let`, is a signal that the variable may be reassigned, such as a counter in a loop, or a value swap in an algorithm. It also signals that the variable will be used only in the block it’s defined in, which is not always the entire containing function. In other words, for loops and mathematical algorithms are the only times we would need to reach for let. Other than that, const is the strongest, safest bet. Use const until you have to use letI hope this article helped you on your quest to understand let and const and how they differ from var. I also hope you can comfortably ditch var and use const until you have to use let. I’m still learning myself and there are certainly gaps in this article. Feel free to correct me when I’m wrong or bring missing information to light.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://nthung2112.github.io/tags/es6/"}]},{"title":"How to use Memoize to cache JavaScript function results and speed up your code","slug":"How-to-use-Memoize-to-cache-JavaScript-function-results","date":"2017-08-21T07:58:54.000Z","updated":"2017-08-21T15:42:19.418Z","comments":true,"path":"2017/08/How-to-use-Memoize-to-cache-JavaScript-function-results.html","link":"","permalink":"http://nthung2112.github.io/2017/08/How-to-use-Memoize-to-cache-JavaScript-function-results.html","excerpt":"","text":"Functions are an integral part of programming. They help add modularity and reusability to our code. It’s quite common to divide our program into chunks using functions which we can call later to perform some useful action. Sometimes, a function can become expensive to call multiple times (say, a function to calculate the factorial of a number). But there’s a way we can optimize such functions and make them execute much faster: caching. For example, let’s say we have a function to return the factorial of a number: 1234function factorial(n) &#123; // Calculations: n * (n-1) * (n-2) * ... (2) * (1) return factorial&#125; Great, now let’s find factorial(50). The computer will perform calculations and return us the final answer, sweet! When that’s done, let’s find factorial(51). The computer again performs a number of calculations and gets us the result, but you might have noticed that we’re already repeating a number of steps that could have been avoided. An optimized way would be: 1factorial(51) = factorial(50) * 51 But our function performs the calculations from scratch every time it’s called: 1factorial(51) = 51 * 50 * 49 * ... * 2 * 1 Wouldn’t it be cool if somehow our factorial function could remember the values from its previous calculations and use them to speed up the execution? In comes memoization, a way for our function to remember (cache) the results. Now that you’ve a basic understanding of what we’re trying to achieve, here’s a formal definition: Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again Memoizing in simple terms means memorizing or storing in memory. A memoized function is usually faster because if the function is called subsequently with the previous value(s), then instead of executing the function, we would be fetching the result from the cache. Here’s what a simple memoized function might look like (and here’s a CodePen in case you want to interact with it): 12345678910111213141516171819202122232425// a simple function to add somethingconst add = (n) =&gt; (n + 10);add(9);// a simple memoized function to add somethingconst memoizedAdd = () =&gt; &#123; let cache = &#123;&#125;; return (n) =&gt; &#123; if (n in cache) &#123; console.log('Fetching from cache'); return cache[n]; &#125; else &#123; console.log('Calculating result'); let result = n + 10; cache[n] = result; return result; &#125; &#125;&#125;// returned function from memoizedAddconst newAdd = memoizedAdd();console.log(newAdd(9)); // calculatedconsole.log(newAdd(9)); // cached Memoization takeawaysSome takeaways from the above code are: memoizedAdd returns a function which is invoked later. This is possible because in JavaScript, functions are first class objects which lets us use them as higher order functions and return another function. cache can remember its values since the returned function has a closure over it. It’s essential that the memoized function is pure. A pure function will return the same output for a particular input no mater how many times it’s called, which makes the cache work as expected. Writing your own memoize functionThe previous code works fine but what if we wanted to turn any function into a memoized function? Here’s how to write your own memoize function (codepen): 1234567891011121314151617181920212223242526272829// a simple pure function to get a value adding 10const add = (n) =&gt; (n + 10);console.log('Simple call', add(3));// a simple memoize function that takes in a function// and returns a memoized functionconst memoize = (fn) =&gt; &#123; let cache = &#123;&#125;; return (...args) =&gt; &#123; let n = args[0]; // just taking one argument here if (n in cache) &#123; console.log('Fetching from cache'); return cache[n]; &#125; else &#123; console.log('Calculating result'); let result = fn(n); cache[n] = result; return result; &#125; &#125;&#125;// creating a memoized function for the 'add' pure functionconst memoizedAdd = memoize(add);console.log(memoizedAdd(3)); // calculatedconsole.log(memoizedAdd(3)); // cachedconsole.log(memoizedAdd(4)); // calculatedconsole.log(memoizedAdd(4)); // cached Now that’s great! This simple memoize function will wrap any simple function into a memoized equivalent. The code works fine for simple functions and it can be easily tweaked to handle any number of arguments as per your needs. Another alternative is to make use of some de-facto libraries such as: Lodash’s _.memoize(func, [resolver]) ES7 @memoize decorators from decko Memoizing recursive functionsIf you try passing in a recursive function to the memoize function above or _.memoize from Lodash, the results won’t be as expected since the recursive function on its subsequent calls will end up calling itself instead of the memoized function thereby making no use of the cache. Just make sure that your recursive function is calling the memoized function. Here’s how you can tweak a textbook factorial example (codepen): 12345678910111213141516171819202122232425262728293031// same memoize function from beforeconst memoize = (fn) =&gt; &#123; let cache = &#123;&#125;; return (...args) =&gt; &#123; let n = args[0]; if (n in cache) &#123; console.log('Fetching from cache', n); return cache[n]; &#125; else &#123; console.log('Calculating result', n); let result = fn(n); cache[n] = result; return result; &#125; &#125;&#125;const factorial = memoize( (x) =&gt; &#123; if (x === 0) &#123; return 1; &#125; else &#123; return x * factorial(x - 1); &#125; &#125;);console.log(factorial(5)); // calculatedconsole.log(factorial(6)); // calculated for 6 and cached for 5 A few points to note from this code: The factorial function is recursively calling a memoized version of itself. The memoized function is caching the values of previous factorials which significantly improves calculations since they can be reused factorial(6) = 6 * factorial(5) Is memoization same as caching?Yes, kind of. Memoization is actually a specific type of caching. While caching can refer in general to any storing technique (like HTTP caching) for future use, memoizing specifically involves caching the return values of a function. When to memoize your functionsAlthough it might look like memoization can be used with all functions, it actually has limited use cases: In order to memoize a function, it should be pure so that return values are the same for same inputs every time Memoizing is a trade-off between added space and added speed and thus only significant for functions having a limited input range so that cached values can be made use of more frequently It might look like you should memoize your API calls however it isn’t necessary because the browser automatically caches them for you. See HTTP caching for more detail The best use case I found for memoized functions is for heavy computational functions which can significantly improve performance (factorial and fibonacci are not really good real world examples) If you’re into React/Redux you can check out reselect which uses a memoized selector to ensure that calculations only happen when a change happens in a related part of the state tree. Further readingThe following links can be useful if you would like to know more about some of the topics from this article in more detail: Higher order functions in JavaScript Closures in JavaScript Pure functions Lodash’s _.memoize docs and source code More memoization examples here and here reactjs/reselect I hope this article was useful for you, and you’ve gained a better understanding of memoization in JavaScript.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"advanced","slug":"advanced","permalink":"http://nthung2112.github.io/tags/advanced/"}]},{"title":"3 Reasons why I stopped using React.setState","slug":"3-Reasons-why-I-stopped-using-React-setState","date":"2017-08-21T07:43:25.000Z","updated":"2017-08-21T15:44:01.374Z","comments":true,"path":"2017/08/3-Reasons-why-I-stopped-using-React-setState.html","link":"","permalink":"http://nthung2112.github.io/2017/08/3-Reasons-why-I-stopped-using-React-setState.html","excerpt":"Since a few months I’ve stopped using React’s setState on all my new React components. Don’t get me wrong, I didn’t stop having local component state, I just stopped using React to manage it. And it’s been delightful! Using setState is tricky for beginners. Even experienced React programmers easily introduce subtle bugs when using React’s own state mechanism, like this: Bug introduced by forgetting that React state is asynchronous; the log is always one item behind","text":"Since a few months I’ve stopped using React’s setState on all my new React components. Don’t get me wrong, I didn’t stop having local component state, I just stopped using React to manage it. And it’s been delightful! Using setState is tricky for beginners. Even experienced React programmers easily introduce subtle bugs when using React’s own state mechanism, like this: Bug introduced by forgetting that React state is asynchronous; the log is always one item behind The excellent Reacts docs sum up everything that could go wrong when using setState: To summarize, there are 3 issues when using setState: 1. setState is asynchronousMany devs don’t realize this initially, but setState is asynchronous. If you set some state, than take a look at it, you will still see the old state.This is the most tricky part of setState. setState calls don’t look asynchronous, and naively calling setState introduces very subtle bugs. The next gist demonstrates that nicely: At first glance this might look fine. Two event handlers and a utility function that fire the onSelect event if provided. However, this Select component has a bug that is nicely demonstrated in the GIF above. onSelect is always fired with the previous value of state.selection, because setState hasn’t done it’s job yet when the fireOnSelect helperis invoked. I think the least React could do here is rename the method to scheduleState or make the callback required. This bug is easily fixed, the tricky part is realizing it’s there. 2. setState causes unnecessary rendersThe second issue with setState is that it always triggers a re-render. Often those re-renders are unnecessary. You can use the printWasted method from the React performance tools to find out when this happens. But roughly speaking there are several reasons why a re-render may be unnecessary: The new state is actually the same as the previous one. This can often be addressed by implementing shouldComponentUpdate. You may already be using a (pure render) library to solve this for you. Sometimes the changed state is relevant for the rendering, but not under all circumstances. For example when some data is only conditionally visible. Thirdly, as pointed out in Aria Buckles’ talk at React Europe 2015, sometimes instance state is not relevant for the rendering at all! This is often householding state related to managing event listeners, timer ID’s etc. 3. setState is not sufficient to capture all component stateFollowing the last point above, not all component state should be stored and updated using setState. More complex components often have administration that is needed by lifecycle hooks to manage timers, network requests, events etc. Managing those with setState not only causes unnecessary renders, but also causes related lifecycle hooks to be triggered again, leading to weird situations. Managing local component state with MobX(Surprise, surprise) At Mendix we already rely on MobX to manage all our stores. However, we were still using React’s own state mechanism for local component state. Recently, we switched to managing local component state with MobX as well. That looks like this: For completeness sake: No unexpected bugs when using a state mechanism that is synchronous The above code snippet is not only more concise, MobX also addresses all of the setState related issues: Changes to the state are immediately reflected in the local component state. This makes our logic simpler and code reuse easier. You don’t have to compensate for the fact that the state might not have been updated yet. MobX determines at runtime which observables are relevant for rendering. So observables that are temporarily irrelevant for the rendering, won’t cause a re-rendering. Until they are relevant again. For this reason, there are also no rendering penalties (or lifecycle issues) when marking fields as @observable that are not relevant for rendering at all. So renderable and non-renderable state is treated uniformly. In addition, state stored in our components now works the same as state stored in any of our stores. This makes it trivial to refactor components, and move local component state into a separate store or vice versa. Which is demonstrated in this egghead tutorial. MobX effectively turns your components into small stores Furthermore, rookie mistakes like assigning values directly to the state object cannot be made anymore when using observables for state. Oh, and don’t worry about implementing shouldComponentUpdate or PureRenderMixin, MobX already takes care of that as well. Finally, you might be wondering, what if I want to wait until setState has finished? Well, you can still use the _compentDidUpdate l_ifecycle hook for that. Sounds cool! How do I get started with MobX?Pretty simple, follow the 10 minute interactive introduction or watch the aforementioned video. You can simply take a single component from your code base, slap @observer on it and introduce some @observable properties. You don’t even have to replace your existing setState calls, they continue to work while using MobX. Although, within a few minutes you might find them so convoluted that you will replace them anyway :). (Oh, and if you don’t like decorators, no worries, it works with good ol’ ES5 as well). TL;DR:I’ve stopped using React to manage local component state. I use MobX instead. Now React is truly “just the view” :). MobX now manages both local component state and state in stores. It is concise, synchronous, efficient and uniform. From experience, I’ve learned that MobX is even easier to explain to React beginners than React’s own setState. It keeps our components clean and simple. JSBin using setState for state management JSBin using MobX observables for state management","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"mobx","slug":"mobx","permalink":"http://nthung2112.github.io/tags/mobx/"}]},{"title":"What I’ve Learned Over 5 Years as a Software Developer","slug":"What-I’ve-Learned-Over-5-Years-as-a-Software-Developer","date":"2017-08-20T17:22:53.000Z","updated":"2017-08-20T17:47:33.433Z","comments":true,"path":"2017/08/What-I’ve-Learned-Over-5-Years-as-a-Software-Developer.html","link":"","permalink":"http://nthung2112.github.io/2017/08/What-I’ve-Learned-Over-5-Years-as-a-Software-Developer.html","excerpt":"It’s July 3rd 2017 at the time of publishing this article. Why am I mentioning such a seemingly arbitrary fact? Because today marks the five-year anniversary of beginning my software engineering career. Before this, I did undertake some work experience and completed some freelance projects, but I had no commercial exposure until I started my graduate scheme at Sky on this very day in 2012. Rather than dive into some self-indulgent drivel, I’d love to share five of the most important things I’ve learned thus far; I believe that all developers should embrace them.","text":"It’s July 3rd 2017 at the time of publishing this article. Why am I mentioning such a seemingly arbitrary fact? Because today marks the five-year anniversary of beginning my software engineering career. Before this, I did undertake some work experience and completed some freelance projects, but I had no commercial exposure until I started my graduate scheme at Sky on this very day in 2012. Rather than dive into some self-indulgent drivel, I’d love to share five of the most important things I’ve learned thus far; I believe that all developers should embrace them. 1. Throw yourself in the deep endI remember my first day in the NOW TV Xbox 360 team. I’d just finished a 7-month stint on a graduate scheme, working on a number of small internal projects using Ruby and JavaScript. My new team, in contrast, used C#, .NET, and Silverlight. Needless to say, I had no idea where to begin; I covered C#, .NET, and a touch of XAML in the final year of my degree, but not to a commercially-acceptable level. Although my colleagues were incredibly accommodating and helpful, I nonetheless realised that I had to get up to speed if I was to meaningfully contribute to the codebase. As well as working on tickets, I: studied the various aspects of the codebase and searched online for information on concepts that I didn’t understand paired with senior developers to gain insights into effectively implementing new features and refactoring others read books, documentation, and other literature covering: C#; .NET; Silverlight; design patterns; unit testing; and the software development lifecycle (SDLC) Of course, one can only learn at a set pace, and as I’ll cover later, too much work will ultimately come to a head. However, by placing oneself on an alien project, one will naturally push oneself to work as hard as possible; humans are naturally curious creatures, and we thrive in new settings, regardless of how difficult the challenges ahead may be. If somebody offers you an amazing opportunity but you are not sure you can do it, say yes — then learn how to do it later! Richard Branson 2. Be humbleOnce one has gained enough experience as a developer, or in any other capacity for that matter, one consequently gains confidence, and is now in a position to contribute to more complex parts of a codebase, to open source projects, and to the community in general in a variety of ways, such as articles. It can be easy to patronise others who may not have the same skill set, or general level of aptitude, as you. “That’s easy! How can you not know that?!” or “You obviously forgot to run the build script” may be tempting responses to simple questions, but remember that you were once naïve and lacking knowledge. Be kind and humble towards others as if you were at their level. Empathise! Another important facet of humility is to admit when one is wrong. I’ve encountered my share of developers who, rather than admit that they’ve misunderstood a concept or take ownership of a problem they’ve created, attempt to bullshit their way out of a situation. “You’re incapable of understanding my work! I can’t be wrong.” Well yes, you can. 3. Listen and be open-minded, but don’t be afraid of demonstrating assertionOn the subject of humility, it is important to be open-minded towards both alternative points of view and new information regarding concepts and ideas to which one is completely new. While the latter case may seem natural, few people are willing to challenge their own views and ultimately alter their own positions; being malleable will allow one to refine one’s opinions and knowledge which can then be applied to a similar situation further down the road. That said, there is nothing wrong with pushing back if one has experience within the domain of a specific problem and is therefore aware of common pitfalls and best practices. By demonstrating confidence and effective persuasion techniques, one might bring new information to the attention of one’s colleagues. Being assertive does not make you an arsehole. Me 4. Embrace change, but don’t jump on the bandwagonTo a new developer, the rate of change that one witnesses might seem unmanageable; I would like to counter this by arguing that this is not necessarily the case. In the JavaScript world, it’s clear that new libraries and frameworks are released regularly, and certain programmers (read: hipsters) will adopt them quickly without giving much thought to their applicability to a particular use case. One might therefore feel obliged to follow the emergence of technologies in order to continue to provide value as a developer. I initially felt this pressure, but it’s completely avoidable when one views this in reverse. Whenever I’m starting a new project, I seek technologies from which it may benefit, and investigate them with the outcome of answering these questions: Does is naturally lend itself to my problem? Is it mature? Does it have a strong community? Is it well-tested? This is by no means an exclusive list, but I’ve found that this mindset points me in the right direction. I was admittedly very cynical of React when it first emerged. “XML in JS?! Surely this is just a pointless abstraction of the DOM.” Then I tried it in a new role for an app that rendered large lists of items, which would re-render as a consequence of various interactions; it clicked that it was a great library for this particular application, and I thus realised how wrong I was. One should definitely endeavour to be aware of new approaches, and to use them if appropriate, but there’s no obligation to use the new hotness for the sake of it; the main goal of software engineering is to, well, deliver software, and choosing the wrong tech could hinder this achievement. 5. Balance work and playAs soon as I wrote my first Hello World program at university, I almost became addicted to programming. Initially, my ability was limited, thus most of my code was ugly (but that’s OK; it’s part of the learning process.) Once I had worked in the industry for a while and became competent, however, I would spend my evenings and weekends working on all sorts of side projects, and I loved it. I felt that I had truly found my calling, and I just couldn’t stop. Some of these manifested into relatively successful open source projects, as well as contributions to existing codebases. This really gave me a sense of self-esteem, so I kept going. I would enter JavaScript competitions, such as the brilliant js13kGames and JS1k, write articles, and go on to publish a screencast series for SitePoint. I even interviewed with some big tech companies, which resulted in lots of practice and reading. By the end of this, I was completely burned out. I had lost all motivation and could no longer bring myself to program in my spare time. Furthermore, my other hobbies, which allowed me to escape technology when needed, were put on the back burner; I was essentially a code production unit. It’s important to challenge oneself while one has the opportunity; these means not only enabled me to improve as a developer, but have really advanced my career. However, rest is critical. You’re a human being; your capacity to learn abstract concepts and work without sufficient breaks will naturally diminish, given our evolutionary origins. If you feel burnout approaching, take a step back for a while. Not just for a week or so; I’m talking a month or two. Trust me, you’ll know when you’re ready to resume, plus your projects won’t be going anywhere.","categories":[],"tags":[]},{"title":"Our Best Practices for Writing React Components","slug":"Our-Best-Practices-for-Writing-React-Components","date":"2017-08-20T16:06:29.000Z","updated":"2017-08-21T15:42:19.451Z","comments":true,"path":"2017/08/Our-Best-Practices-for-Writing-React-Components.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Our-Best-Practices-for-Writing-React-Components.html","excerpt":"When I first started writing React, I remember seeing many different approaches to writing components, varying greatly from tutorial to tutorial. Though the framework has matured considerably since then, there doesn’t seem to yet be a firm ‘right’ way of doing things. Over the past year at MuseFind, our team has written a lot of React components. We’ve gradually refined our approach until we’re happy with it. This guide represents our suggested best practices. We hope it will be useful, whether you’re a beginner or experienced.","text":"When I first started writing React, I remember seeing many different approaches to writing components, varying greatly from tutorial to tutorial. Though the framework has matured considerably since then, there doesn’t seem to yet be a firm ‘right’ way of doing things. Over the past year at MuseFind, our team has written a lot of React components. We’ve gradually refined our approach until we’re happy with it. This guide represents our suggested best practices. We hope it will be useful, whether you’re a beginner or experienced.Before we get started, a couple of notes: We use ES6 and ES7 syntax. If you’re not sure of the distinction between presentational and container components, we recommend you read this first. Please let us know in the comments if you have any suggestions, questions, or feedback. Class Based ComponentsClass based components are stateful and/or contain methods. We try to use them as sparingly as possible, but they have their place. Let’s incrementally build our component, line by line. Importing CSS12345import React, &#123; Component &#125; from 'react'import &#123; observer &#125; from 'mobx-react'import ExpandableForm from './ExpandableForm'import './styles/ProfileContainer.css' I like CSS in JavaScript, I do — in theory. But it’s still a new idea, and a mature solution hasn’t emerged. Until then, we import a CSS file to each component. We also separate our dependency imports from local imports by a newline. Initializing State12345678import React, &#123; Component &#125; from 'react'import &#123; observer &#125; from 'mobx-react'import ExpandableForm from './ExpandableForm'import './styles/ProfileContainer.css'export default class ProfileContainer extends Component &#123; state = &#123; expanded: false &#125; You can also use the older approach of initializing state in the constructor. More on that here. We prefer the cleaner way. We also make sure to export our class as the default. propTypes and defaultProps12345678910111213141516171819import React, &#123; Component &#125; from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; string, object &#125; from 'prop-types'import ExpandableForm from './ExpandableForm'import './styles/ProfileContainer.css'export default class ProfileContainer extends Component &#123; state = &#123; expanded: false &#125; static propTypes = &#123; model: object.isRequired, title: string &#125; static defaultProps = &#123; model: &#123; id: 0 &#125;, title: 'Your Name' &#125; propTypes and defaultProps are static properties, declared as high as possible within the component code. They should be immediately visible to other devs reading the file, since they serve as documentation. If using React 15.3.0 or higher, use the prop-types package instead of React.PropTypes — nicely destructured, of course. All your components should have propTypes. Methods1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; string, object &#125; from 'prop-types'import ExpandableForm from './ExpandableForm'import './styles/ProfileContainer.css'export default class ProfileContainer extends Component &#123; state = &#123; expanded: false &#125; static propTypes = &#123; model: object.isRequired, title: string &#125; static defaultProps = &#123; model: &#123; id: 0 &#125;, title: 'Your Name' &#125; handleSubmit = (e) =&gt; &#123; e.preventDefault() this.props.model.save() &#125; handleNameChange = (e) =&gt; &#123; this.props.model.changeName(e.target.value) &#125; handleExpand = (e) =&gt; &#123; e.preventDefault() this.setState(&#123; expanded: !this.state.expanded &#125;) &#125; With class components, when you pass methods to subcomponents, you have to ensure that they have the right this when they’re called. This is usually achieved by passing this.handleSubmit.bind(this) to the subcomponent. We think this approach is cleaner and easier, maintaining the correct context automatically via the ES6 arrow function. Passing setState a FunctionIn the above example, we do this: 1this.setState(&#123; expanded: !this.state.expanded &#125;) Here’s the dirty secret about setState — it’s actually asynchronous. React batches state changes for performance reasons, so the state may not change immediately after setState is called. That means you should not rely on the current state when calling setState — since you can’t be sure what that state will be! Here’s the solution — pass a function to setState, with the previous state as an argument. 1this.setState(prevState =&gt; (&#123; expanded: !prevState.expanded &#125;)) (Thanks to Austin Wood for his help with this section). Destructuring Props123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import React, &#123; Component &#125; from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; string, object &#125; from 'prop-types'import ExpandableForm from './ExpandableForm'import './styles/ProfileContainer.css'export default class ProfileContainer extends Component &#123; state = &#123; expanded: false &#125; static propTypes = &#123; model: object.isRequired, title: string &#125; static defaultProps = &#123; model: &#123; id: 0 &#125;, title: 'Your Name' &#125; handleSubmit = (e) =&gt; &#123; e.preventDefault() this.props.model.save() &#125; handleNameChange = (e) =&gt; &#123; this.props.model.changeName(e.target.value) &#125; handleExpand = (e) =&gt; &#123; e.preventDefault() this.setState(prevState =&gt; (&#123; expanded: !prevState.expanded &#125;)) &#125; render() &#123; const &#123; model, title &#125; = this.props return ( &lt;ExpandableForm onSubmit=&#123;this.handleSubmit&#125; expanded=&#123;this.state.expanded&#125; onExpand=&#123;this.handleExpand&#125;&gt; &lt;div&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;input type=\"text\" value=&#123;model.name&#125; onChange=&#123;this.handleNameChange&#125; placeholder=\"Your Name\"/&gt; &lt;/div&gt; &lt;/ExpandableForm&gt; ) &#125;&#125; Components with many props should have each prop on a newline, like above. Decorators12@observerexport default class ProfileContainer extends Component &#123; If you’re using something like mobx, you can decorate your class components like so — which is the same as passing the component into a function. Decorators are flexible and readable way of modifying component functionality. We use them extensively, with mobx and our own mobx-models library. If you don’t want to use decorators, do the following: 12345class ProfileContainer extends Component &#123; // Component code&#125;export default observer(ProfileContainer) ClosuresAvoid passing new closures to subcomponents, like so: 1234567&lt;input type=\"text\" value=&#123;model.name&#125; // onChange=&#123;(e) =&gt; &#123; model.name = e.target.value &#125;&#125; // ^Not this. Use the below: onChange=&#123;this.handleChange&#125; placeholder=\"Your Name\"/&gt; Here’s why: every time the parent component renders, a new function is created and passed to the input. If the input were a React component, this would automatically trigger it to re-render, regardless of whether its other props have actually changed. Reconciliation is the most expensive part of React. Don’t make it harder than it needs to be! Plus, passing a class method is easier to read, debug, and change. Here’s our full component: Functional ComponentsThese components have no state and no methods. They’re pure, and easy to reason about. Use them as often as possible. propTypes123456789101112import React from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; func, bool &#125; from 'prop-types'import './styles/Form.css'ExpandableForm.propTypes = &#123; onSubmit: func.isRequired, expanded: bool&#125;// Component declaration Here, we assign the propTypes before the component declaration, so they are immediately visible. We’re able to do this because of JavaScript function hoisting. Destructuring Props and defaultProps123456789101112131415161718192021import React from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; func, bool &#125; from 'prop-types'import './styles/Form.css'ExpandableForm.propTypes = &#123; onSubmit: func.isRequired, expanded: bool, onExpand: func.isRequired&#125;function ExpandableForm(props) &#123; const formStyle = props.expanded ? &#123;height: 'auto'&#125; : &#123;height: 0&#125; return ( &lt;form style=&#123;formStyle&#125; onSubmit=&#123;props.onSubmit&#125;&gt; &#123;props.children&#125; &lt;button onClick=&#123;props.onExpand&#125;&gt;Expand&lt;/button&gt; &lt;/form&gt; )&#125; Our component is a function, which takes its props as its argument. We can expand them like so: 123456789101112131415161718192021import React from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; func, bool &#125; from 'prop-types'import './styles/Form.css'ExpandableForm.propTypes = &#123; onSubmit: func.isRequired, expanded: bool, onExpand: func.isRequired&#125;function ExpandableForm(&#123; onExpand, expanded = false, children, onSubmit &#125;) &#123; const formStyle = expanded ? &#123;height: 'auto'&#125; : &#123;height: 0&#125; return ( &lt;form style=&#123;formStyle&#125; onSubmit=&#123;onSubmit&#125;&gt; &#123;children&#125; &lt;button onClick=&#123;onExpand&#125;&gt;Expand&lt;/button&gt; &lt;/form&gt; )&#125; Note we can also use default arguments to act as defaultProps in a highly readable manner. If expanded is undefined, we set it to false. (A bit of a forced example, since it’s a boolean, but very useful for avoiding ‘Cannot read of undefined’ errors with objects). Avoid the following ES6 syntax: 1const ExpandableForm = (&#123; onExpand, expanded, children &#125;) =&gt; &#123; Looks very modern, but the function here is actually unnamed. This lack of name will not be a problem if your Babel is set up correctly — but if it’s not, any errors will show up as occurring in &lt;&gt; which is terrible for debugging. Unnamed functions can also cause problems with Jest, a React testing library. Due to the potential for difficult-to-understand bugs (and the lack of real benefit) we recommend using function instead of const. WrappingSince you can’t use decorators with functional components, you simply pass it the function in as an argument: 12345678910111213141516171819202122import React from 'react'import &#123; observer &#125; from 'mobx-react'import &#123; func, bool &#125; from 'prop-types'import './styles/Form.css'ExpandableForm.propTypes = &#123; onSubmit: func.isRequired, expanded: bool, onExpand: func.isRequired&#125;function ExpandableForm(&#123; onExpand, expanded = false, children, onSubmit &#125;) &#123; const formStyle = expanded ? &#123;height: 'auto'&#125; : &#123;height: 0&#125; return ( &lt;form style=&#123;formStyle&#125; onSubmit=&#123;onSubmit&#125;&gt; &#123;children&#125; &lt;button onClick=&#123;onExpand&#125;&gt;Expand&lt;/button&gt; &lt;/form&gt; )&#125;export default observer(ExpandableForm) Here’s our full component: Conditionals in JSXChances are you’re going to do a lot of conditional rendering. Here’s what you want to avoid: Actual code I wrote in my early days at MuseFind… forgive me No, nested ternaries are not a good idea. There are some libraries that solve this problem (JSX-Control Statements), but rather than introduce another dependency, we settled on this approach for complex conditions: A refactored version of the above. Use curly braces wrapping an IIFE, and then put your if statements inside, returning whatever you want to render. Note that IIFE’s like this can cause a performance hit, but in most cases it will not be significant enough to warrant losing the readability factor. Update: Many commenters have recommended extracting this logic to a subcomponent that conditionally returns different buttons based on props. They’re right — splitting up your components as much as possible is always a good call. But keep the IIFE approach in mind as a fallback for quick conditionals. Also, when you only want to render an element on one condition, instead of doing this… 12345&#123; isTrue ? &lt;p&gt;True!&lt;/p&gt; : &lt;none/&gt;&#125; … use short-circuit evaluation: 1234&#123; isTrue &amp;&amp; &lt;p&gt;True!&lt;/p&gt;&#125; ConclusionWas this article useful? Please click the green heart below, or follow me and our publication for more. Have any feedback? Leave a comment below. Thanks for reading!","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Nodejs là gì","slug":"Nodejs-la-gi","date":"2017-08-20T15:56:00.000Z","updated":"2017-08-21T15:44:24.511Z","comments":true,"path":"2017/08/Nodejs-la-gi.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Nodejs-la-gi.html","excerpt":"Trong bài viết giới thiệu về asynchronous, event-driven và non-blocking I/O, mình có treo tên Nodejs lên trên tiêu đề nhưng thật ra bài viết ấy lại không đả động đến Nodejs được bao nhiêu. Nó chỉ giới thiệu ý nghĩa của các khái niệm trên trong ngữ cảnh mà Nodejs sử dụng. Lần này là một bài viết chân thật về Nodejs. Hãy cùng nhau trả lời một câu hỏi mang tính bản thể luận về Nodejs: Bản chất của Nodejs là gì? Trong bài viết giới thiệu về asynchronous, event-driven và non-blocking I/O, mình có treo tên Nodejs lên trên tiêu đề nhưng thật ra bài viết ấy lại không đả động đến Nodejs được bao nhiêu. Nó chỉ giới thiệu ý nghĩa của các khái niệm trên trong ngữ cảnh mà Nodejs sử dụng. Lần này là một bài viết chân thật về Nodejs. Hãy cùng nhau trả lời một câu hỏi mang tính bản thể luận về Nodejs: Bản chất của Nodejs là gì?","text":"Trong bài viết giới thiệu về asynchronous, event-driven và non-blocking I/O, mình có treo tên Nodejs lên trên tiêu đề nhưng thật ra bài viết ấy lại không đả động đến Nodejs được bao nhiêu. Nó chỉ giới thiệu ý nghĩa của các khái niệm trên trong ngữ cảnh mà Nodejs sử dụng. Lần này là một bài viết chân thật về Nodejs. Hãy cùng nhau trả lời một câu hỏi mang tính bản thể luận về Nodejs: Bản chất của Nodejs là gì? Trong bài viết giới thiệu về asynchronous, event-driven và non-blocking I/O, mình có treo tên Nodejs lên trên tiêu đề nhưng thật ra bài viết ấy lại không đả động đến Nodejs được bao nhiêu. Nó chỉ giới thiệu ý nghĩa của các khái niệm trên trong ngữ cảnh mà Nodejs sử dụng. Lần này là một bài viết chân thật về Nodejs. Hãy cùng nhau trả lời một câu hỏi mang tính bản thể luận về Nodejs: Bản chất của Nodejs là gì? Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript Engine. JavaScript thì dễ hiểu rồi (Thật ra Chrome cũng dễ hiểu), nhưng còn Runtime với Engine là gì? Mối quan hệ giữa chúng như thế nào? JavaScript Engine có thể được định nghĩa một cách đơn giản như sau: Một chương trình hoặc thư viện thực thi mã JavaScript, cung cấp các cơ chế khởi tạo object, gọi function,… Có thể đơn giản là một interpreter hoặc một JIT compiler to bytecode. Tất nhiên, vì cả bài viết này chỉ nhằm nhiệm vụ trả lời Nodejs là gì, mà biết được JavaScript Engine là gì tức là đã xong 50% vấn đề, nên ta sẽ giải thích lại, một cách phức tạp và dài dòng hơn, bắt đầu từ những khái niệm cơ bản hơn như Interpreter và Compiler. Interpreter và Compiler Interpreter (của ngôn ngữ A): Một thành phần có chức năng trực tiếp thực thi một đoạn code (được viết bằng ngôn ngữ A). Có thể coi CPU như một interpreter của tập chỉ lệnh tương ứng. Ngày nay, interpreter thường hiểu theo ý nghĩa trực tiếp một chương trình từ source code mà không qua chuyển đổi thành machine code. Compiler: Dịch từ ngôn ngữ A sang ngôn ngữ B sao cho khi thực thi thu được kết quả tương đương. Thường được sử dụng để dịch source code từ ngôn ngữ bậc cao A sang ngôn ngữ B có bậc thấp hơn dễ dàng interprete hơn, và tất nhiên ngôn ngữ dễ interprete nhất là machine code. Thời gian cần để compile thường không phải là nhỏ, nhất là khi cần tối ưu hoá kết quả. Để giảm thiểu thời gian compile, có một cách (đánh đổi bởi tốc độ thực thi sau khi compile) là không dịch trực tiếp source code ra machine code mà dịch sang một ngôn ngữ trung gian và sử dụng interpreter cho ngôn ngữ trung gian này, thường gọi là bytecode, với đặc điểm là thời gian compile từ ngôn ngữ nguồn sang bytecode nhanh hơn sang machine code, tốc độ thực thi nhanh hơn việc trực tiếp interprete source code, mặc dù chậm hơn machine code. Từ interpreter và bytecode trong định nghĩa về JavaScript Engine đã rõ ràng, vậy còn JIT compiler? Để có một cái nhìn về JIT compiler, chúng ta cần xem xét nó trong một mối quan hệ biện chứng giữa nó và một khái niệm khác: AOT compiler. Ahead-of-Time (AOT) và Just-in-Time (JIT) compilation: Từ time được nhắc đến ở đây là runtime. AOT dịch toàn bộ source code trước khi bắt đầu chạy chương trình, JIT thì trái lại compile source code trong thời gian chạy. Triết lý của JIT compilation là thay vì phải chờ compiler dịch toàn bộ source, việc có thể mất nhiều thời gian, ta dịch từng phần mà ta cần dùng trước rồi bắt đầu chạy với chúng ngay lập tức. Interpreter và compiler có thể kết hợp trở thành engine của một ngôn ngữ theo 1 trong 2 cách: AOT kết hợp interpreter: Source code được compile toàn bộ thành machine code hoặc bytecode trước khi khởi chạy chương trình, sau đó sử dụng một interpreter để thực thi. Ví dụ Python được AOT compiler dịch thành cpython bytecode trong chớp nhoáng và cpython được chạy trên interpreter. JIT kết hợp interpreter: Thực tế là full compiled code chạy nhanh hơn nhưng tốn nhiều thời gian trước khi bắt đầu chạy, trực tiếp interprete source code thì có thể bắt đầu chạy ngay nhưng tốc độ thực thi chậm. Giải pháp trung hoà là sử dụng interpreter để khởi chạy nhanh chóng source code, rồi dùng JIT compiler để dịch và thay thế source code bằng compiled code sau khi đã dịch xong. V8 EngineV8 là một open source JavaScript engine viết bằng C++, phát triển bởi Google như là một phần trong dự án Chromium, phát hành lần đầu cùng với phiên bản đầu tiên của trình duyêt Chrome. V8 compile trực tiếp JavaScript thành native machine code thay vì sử dụng interpreting bytecode theo cách truyền thống. Nodejs được xây dựng lần đầu trên V8 do tốc độ thực thi đáng kinh ngạc so với các JavaScript Engine trước đó, đủ sức đảm đương một hệ thống yêu cầu hiệu năng cao trên server-side. Ngày nay thì các Engine của các hãng khác cũng đã bắt kịp V8 rồi, vừa rồi Nodejs cũng đã phát hành một phiên bản sử dụng Chakra Enginecủa Microsoft tại https://github.com/nodejs/node-chakracore, nhưng có lẽ khi nhắc đến Nodejs thì ta chỉ cần giới thiệu về V8 là đủ. V8 Engine được Google lựa chọn quả thật là một cái tên mang nhiều cảm xúc, gợi lên hình ảnh về những động cơ ô tô mạnh mẽ, sản sinh công suất lớn từ thiết kế 8 xy-lanh sắp xếp hình chữ V mà hiếm khi nào có tổng dung tích dưới 3.0 L, thậm chí lên đến hơn 8.0 L, ví như động cơ của chiếc Audi R8 trong hình dưới. Khá chắc là các kỹ sư của Google cũng rất mê xe, bởi họ tiếp tục đặt tên cho các thành phần trong động cơ V8 của mình là Crankshaft, TuborFan và Ignition, các thành phần kỹ thuật của động cơ đốt trong hiện đại mà chúng ta sẽ bắt gặp trong phần sau của bài viết. Lan man vậy thôi, bây giờ, ba yếu tố then chốt tạo nên hiệu năng cao của V8 là: Fast Property Access Dynamic Machine Code Generation Efficient Garbage Collection Fast Property AccessJavaScript là một dynamic programming language, có nghĩa, các property có thể được thêm, bớt, thay đổi trong thời gian chạy. Hầu hết các JavaScript Engine sử dụng một cấu trúc dữ liệu dạng dictionary để lưu giữ các property trong object, mỗi truy cập đến property yêu cầu một dictionary dynamic lookup để tìm ra vị trí của property trong memory, chậm hơn cách truy cập trực tiếp đến property trong các class-based language truyền thống. Để tránh dynamic lookup, V8 tự động ngầm tạo một hidden class cho mỗi object, biến object trong JavaScript thành class-based. Mỗi khi object được thêm property, V8 tạo mới một hidden class và object chuyển hidden class của nó sang class mới này. Nguồn ảnh: v8project.blogspot.com Kể từ khi object trong JavaScript trở thành class-based, một kỹ thuật compiler optimization kinh điển trở nên khả thi và được đưa vào V8, Inline Caching, giúp tăng lực cho JavaScript lên thậm chí vài chục lần với long runtime. Dynamic Machine Code GenerationV8 dịch trực tiếp JavaScript source code sang native machine code, cho tốc độ interprete cao, đồng thời có khả năng linh động tối ưu hoá (và tái tối ưu) compiled code trong thời gian chạy dựa trên các dữ liệu thu thập được từ profiler. V8 có 2 compiler, ban đầu, tất cả source code của bạn sẽ được phân tích cú pháp, chuyển thành AST rồi đẩy vào Full-Codegen Compiler, nơi sẽ cho ra phiên bản machine code đầu tiên của chương trình. Full-Codegen Compiler: Nhiệm vụ là chuyển source code của bạn thành machine code nhanh nhất có thể, khỏi optimize gì luôn. Nó cũng thêm vào một ít type-feedback code thu thập thông tin để phục vụ công việc optimize code sau này. Compiler không tiến hành bất cứ phân tích và không biết gì về kiểu dữ liệu trong source code tại thời điểm này. Để gia tăng hiệu năng, V8 tiếp tục theo dõi chương trình trong runtime bằng một profiler, một thành phần trong kiến trúc của V8, sẽ thu thập thông tin và tìm xem function nào là hot function, tức được dùng đi dùng lại rất nhiều lần, đó là thời điểm cần tiến hành optimize cho một compiled code tốt hơn. Và đó là thời điểm Crankshaft vào cuộc. Optimizing compiler: Crankshaft (và mới đây là TuborFan được thêm vào) đưa ra những dự đoán về function dựa vào những thông tin thu được từ profiler, re-compile và thay thế phần code chưa được optimize bằng cách sử dụng on-stack replacement (OSR). Nếu những giả định là sai lầm, ví dụ nó cho rằng a, b sẽ luôn là number trong phép tính a + b ở đâu đó, và sử dụng thẳng phép cộng 2 số ở đây thay vì lần nào cũng phải kiểm tra kiểu và sử dụng + operator thích hợp, mà bất chợt b lại nhận kiểu là string, thì nó chỉ đơn giản là de-optimizing và tái sử dụng phần code chưa optimize. Đây là cách V8 đối xử với source code của chúng ta: Nguồn ảnh: v8project.blogspot.com Trong năm 2016, một interpreter mang tên Ingition được thêm vào V8 với mục đích giảm thiểu chiếm dụng bộ nhớ trên những hệ thống có memory nhỏ như Android. Efficient Garbage CollectionGarbage collector của V8, được quảng cáo là một stop-the-world, generational, accurate, garbage collector làm nhiệm vụ thu hồi memory đối với những object không còn được process sử dụng một cách rất hiệu quả. Còn nó hiệu quả như thế nào, tại sao hay thậm chí nó có thật sự hiệu quả hơn các engine khác hay không thì mình cũng không rõ. Ban đầu, JavaScript được thiết kế để thực hiện một số nhiệm vụ nhỏ nhoi và ngắn ngủi, ví dụ như đặt một event listener cho một element trên browser, engine lúc ấy chỉ đơn giản là một interpreter đọc và thực thi JavaScript source code. Dần dần, theo thời gian, chúng ta yêu cầu nhiều hơn từ nó. Ứng dụng đầu tiên giao phó những nhiệm vụ nặng nề cho JavaScript là Google Map. Từ đây người ta nhận ra sự cần thiết của một JavaScript nhanh hơn, trong một runtime dài hơi hơn. JIT compilation cần nhiều thời gian để khởi tạo hơn interpretation, nhưng nhanh hơn rất nhiều trong runtime dài. Với những web application dùng nhiều JavaScript của mình, Google đã dành nhiều công sức để thúc đẩy các trình duyệt cải thiện hiệu suất của JavaScript, và V8 ra đời như một kết quả. Giờ đây, một process JavaScript chạy càng lâu, càng được optimize và càng sở hữu hiệu năng cao hơn, mọi người cảm thấy nó đã khả thi để xuất hiện trong một môi trường khắc nghiệt hơn là trên web browser, server-side. JavaScript RuntimeĐược giới thiệu là một JavaScript Runtime, Nodejs có gì khác biệt với một JavaScript Engine? Lấy cảm hứng từ một câu trả lời trên Stackoverflow, chúng ta có thể tạm hiểu như sau: JavaScript chạy trên một container – một chương trình sẽ nhận source code của bạn và thực thi nó. Chương trình này làm hai điều: Phân thích source code và thực thi từng đơn vị có thể. Cung cấp một vài object để JavaScript có thể tương tác với thế giới bên ngoài. Phần đầu, gọi là Engine. Phần còn lại, gọi là Runtime. Trên thực tế, V8 implement một ECMAScript theo đúng chuẩn, tức là những gì ngoài chuẩn thì không có mặt trong V8. Để tương tác với môi trường, V8 cung cấp các lớp template bọc ngoài các object và function viết bởi C++. Các C++ function này có thể làm nhiệm vụ đọc/ghi file system, thao tác networking hoặc giao tiếp với các process khác trong hệ thống. Bằng cách thiết lập một JavaScript context với global scope chứa các JavaScript instance tạo ra từ các template và chạy source code của chúng ta trong context này, mã của chúng ta đã sẵn sàng để giao tiếp với thế giới. Và đó là nhiệm vụ của một Runtime Library: Tạo ra một runtime environment cung cấp các thư viện built-in dưới dạng các biến global để mã của bạn có thể sử dụng trong thời gian chạy, đón nhận source code như là một argument và thực thi nó trong context đã tạo. Với browser runtime environment như Chrome, context mà Chrome cung cấp cho V8 bao gồm các biến global như window, console, DOM object, XMLHttpRequest và timer setTimeout(). Tất cả những thứ ấy đến từ Chrome, không phải từ bản thân V8. Thay vào đó, V8 cung cấp các built-in object chuẩn, có mặt trong mọi environment của JavaScript, được miêu tả trong ECMAScript Standard, bao gồm các kiểu dữ liệu, operator, một số object và function đặc biệt như các value property (Infinity, NaN, null, undefined), Object, Function, Boolean, String, Number, Map, Set, Array, parseInt(), eval(),… Rời xa thế giới browser, rời xa DOM, Nodejs mang đến cho chúng ta nhiều built-in library hơn như fs để giao tiếp với file system, http và https cho networking, tls, tty, cluster, os,… Vấn đề là không phải lúc nào ta cũng cần tất cả những thứ này, việc tạo một context mang quá nhiều global variable không cần thiết như vậy rõ ràng không phải là một cách làm hay. Nodejs bởi vậy nhóm nhiều chức năng vào các module khác nhau và thực hiện một cơ chế module loading thông qua từ khoá require và exports, cho phép tạo ra những context linh động hơn. Tất nhiên, cơ chế này được implement bằng C/C++. Đó là diễn giải đằng sau lời giới thiệu runtime built on Chrome’s V8 JavaScript Engine của Nodejs, và đó là cách mã JavaScript của bạn thao tác với các low-level API, theo một cách đồng bộ (synchronous). V8 chạy mã của bạn trong một single thread, tuần tự từng lệnh một, sử dụng một cấu trúc để quản lý các active subroutine gọi là call stack. Call Stack và Event LoopCall stack không phải là một điều gì đó mới mẻ, thực tế chúng ta luôn luôn phải sử dụng nó để đảm bảm chương trình thực thi một cách đúng đắn, chẳng qua trong các ngôn ngữ bậc cao, việc cung cấp một call stack được ẩn đi và tự động hoá. Nếu push quá nhiều stack frame vào và tiêu tốn hết không gian được cấp cho call stack, chúng ta sẽ đối diện với Stackoverflow huyền thoại. Câu chuyện về call stack của JavaScript có lẽ chúng ta đều đã được nghe kể rất nhiều lần. Ta đều biết rằng stack frame được push mỗi khi một hàm được gọi, và được pop với lệnh return. Sau khi lần lượt xử lý hết các lệnh trong chương trình, call stack trở nên rỗng ruột, một phép màu mang tên event loop sẽ nhặt các hàm callback trong một tạo vật gọi là event queue (hay task queue), đẩy vào trong call stack, và V8 engine tiếp tục thực thi hàm đang nằm trong call stack này. Đây là cách JavaScript thực hiện asynchronous call. Đây cũng là lý do tại sao gọi timer setTimeout() với đối số là 0, hàm callback của chúng ta vẫn phải chờ cho đến khi tất cả code trong chương trình thực thi xong (call stack trở thành empty) thì mới được invoke. Nguồn ảnh: appsdev.is.ed.ac.uk V8 nhận event loop như là một đối số đầu vào khi khởi tạo environment, các môi trường khác nhau sẽ có event loop và API để tạo asynchronous request, thứ mà sẽ đẩy callback function của ta vào trong event queue rồi vật vờ ngồi đợi, của riêng mình. Với Nodejs, event loop implementation của nó là libuv. Thiếu đi libuv, bức tranh về một Nodejs event-driven asynchronous non-blocking I/O sẽ không thể hoàn thiện. V8 thì thậm chí còn chẳng biết I/O là cái gì chứ đừng nói đến blocking hay không blocking. Về libuv và cách nó hoạt động lại là một câu chuyện dài mà thời lượng ở đây không cho phép mình giới thiệu. Xin hẹn được chia sẻ về nó trong một bài viết khác, mà chính xác ra thì là bài viết này: http://sotatek.com/nodejs-hieu-asynchronous-event-drivent-nonblocking-io/ Tổng kếtĐến đây, có lẽ ta đã có thể tự vẽ một bức tranh khá đầy đủ về Nodejs system cho riêng mình. Còn nếu bạn lười vẽ, không sao cả, Richard Key đã vẽ cho bạn rồi đây: Nguồn ảnh: twitter.com/BusyRich","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://nthung2112.github.io/tags/nodejs/"}]},{"title":"Master the JavaScript Interview","slug":"Master-the-JavaScript-Interview","date":"2017-08-20T15:36:07.000Z","updated":"2017-08-20T17:47:13.879Z","comments":true,"path":"2017/08/Master-the-JavaScript-Interview.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Master-the-JavaScript-Interview.html","excerpt":"“Master the JavaScript Interview” is a series of posts designed to prepare candidates for common questions they are likely to encounter when applying for a mid to senior-level JavaScript position. These are questions I frequently use in real interviews. Want to start from the beginning? See “What is a Closure?”","text":"“Master the JavaScript Interview” is a series of posts designed to prepare candidates for common questions they are likely to encounter when applying for a mid to senior-level JavaScript position. These are questions I frequently use in real interviews. Want to start from the beginning? See “What is a Closure?”Note: This article uses ES6 examples. If you haven’t learned ES6 yet, see “How to Learn ES6”. Objects are frequently used in JavaScript, and understanding how to work with them effectively will be a huge win for your productivity. In fact, poor OO design can potentially lead to project failure, and in the worst cases, company failures. Unlike most other languages, JavaScript’s object system is based on prototypes, not classes. Unfortunately, most JavaScript developers don’t understand JavaScript’s object system, or how to put it to best use. Others do understand it, but want it to behave more like class based systems. The result is that JavaScript’s object system has a confusing split personality, which means that JavaScript developers need to know a bit about both prototypes and classes. What’s the Difference Between Class &amp; Prototypal Inheritance?This can be a tricky question, and you’ll probably need to defend your answer with follow-up Q&amp;A, so pay special attention to learning the differences, and how to apply the knowledge to write better code. Class Inheritance: A class is like a blueprint — a description of the object to be created. Classes inherit from classes and create subclass relationships: hierarchical class taxonomies. Instances are typically instantiated via constructor functions with the new keyword. Class inheritance may or may not use the class keyword from ES6. Classes as you may know them from languages like Java don’t technically exist in JavaScript. Constructor functions are used, instead. The ES6 class keyword desugars to a constructor function: 12class Foo &#123;&#125;typeof Foo // 'function' In JavaScript, class inheritance is implemented on top of prototypal inheritance, but that does not mean that it does the same thing: JavaScript’s class inheritance uses the prototype chain to wire the child Constructor.prototype to the parent Constructor.prototype for delegation. Usually, the super() constructor is also called. Those steps form single-ancestor parent/child hierarchies and create the tightest coupling available in OO design. “Classes inherit from classes and create subclass relationships: hierarchical class taxonomies.” Prototypal Inheritance: A prototype is a working object instance. Objects inherit directly from other objects. Instances may be composed from many different source objects, allowing for easy selective inheritance and a flat [[Prototype]] delegation hierarchy. In other words, class taxonomies are not an automatic side-effect of prototypal OO: a critical distinction. Instances are typically instantiated via factory functions, object literals, or Object.create(). “A prototype is a working object instance. Objects inherit directly from other objects.” Why Does this Matter?Inheritance is fundamentally a code reuse mechanism: A way for different kinds of objects to share code. The way that you share code matters because if you get it wrong, it can create a lot of problems, specifically: Class inheritance creates parent/child object taxonomies as a side-effect. Those taxonomies are virtually impossible to get right for all new use cases, and widespread use of a base class leads to the fragile base class problem, which makes them difficult to fix when you get them wrong.In fact, class inheritance causes many well known problems in OO design: The tight coupling problem (class inheritance is the tightest coupling available in oo design), which leads to the next one… The fragile base class problem Inflexible hierarchy problem (eventually, all evolving hierarchies are wrong for new uses) The duplication by necessity problem (due to inflexible hierarchies, new use cases are often shoe-horned in by duplicating, rather than adapting existing code) The Gorilla/banana problem (What you wanted was a banana, but what you got was a gorilla holding the banana, and the entire jungle) I discuss some of the issues in more depth in my talk, “Classical Inheritance is Obsolete: How to Think in Prototypal OO”: The solution to all of these problems is to favor object composition over class inheritance. “Favor object composition over class inheritance.”~ The Gang of Four, “Design Patterns: Elements of Reusable Object Oriented Software” Summed up nicely here: Is All Inheritance Bad?When people say “favor composition over inheritance” that is short for “favor composition over class inheritance” (the original quote from “Design Patterns” by the Gang of Four). This is common knowledge in OO design because class inheritance has many flaws and causes many problems. Often people leave off the word class when they talk about class inheritance, which makes it sound like all inheritance is bad — but it’s not. There are actually several different kinds of inheritance, and most of them are great. Three Different Kinds of Prototypal InheritanceBefore we dive into the other kinds of inheritance, let’s take a closer look at what I mean by class inheritance: You can experiment with this example on Codepen. BassAmp inherits from GuitarAmp, and ChannelStrip inherits from BassAmp &amp; GuitarAmp. This is an example of how OO design goes wrong. A channel strip isn’t actually a type of guitar amp, and doesn’t actually need a cabinet at all. A better option would be to create a new base class that both the amps and the channel strip inherits from, but even that has limitations. Eventually, the new shared base class strategy breaks down, too. There’s a better way. You can inherit just the stuff you really need using object composition: Experiment with this on CodePen. If you look carefully, you might see that we’re being much more specific about which objects get which properties because with composition, we can. It wasn’t really an option with class inheritance. When you inherit from a class, you get everything, even if you don’t want it. At this point, you may be thinking to yourself, “that’s nice, but where are the prototypes?” To understand that, you have to understand that there are three different kinds of prototypal OO. Concatenative inheritance: The process of inheriting features directly from one object to another by copying the source objects properties. In JavaScript, source prototypes are commonly referred to as mixins. Since ES6, this feature has a convenience utility in JavaScript called Object.assign(). Prior to ES6, this was commonly done with Underscore/Lodash’s .extend() jQuery’s $.extend(), and so on… The composition example above uses concatenative inheritance. Prototype delegation: In JavaScript, an object may have a link to a prototype for delegation. If a property is not found on the object, the lookup is delegated to the delegate prototype, which may have a link to its own delegate prototype, and so on up the chain until you arrive at Object.prototype, which is the root delegate. This is the prototype that gets hooked up when you attach to a Constructor.prototype and instantiate with new. You can also use Object.create() for this purpose, and even mix this technique with concatenation in order to flatten multiple prototypes to a single delegate, or extend the object instance after creation. Functional inheritance: In JavaScript, any function can create an object. When that function is not a constructor (or class), it’s called a factory function. Functional inheritance works by producing an object from a factory, and extending the produced object by assigning properties to it directly (using concatenative inheritance). Douglas Crockford coined the term, but functional inheritance has been in common use in JavaScript for a long time. As you’re probably starting to realize, concatenative inheritance is the secret sauce that enables object composition in JavaScript, which makes both prototype delegation and functional inheritance a lot more interesting. When most people think of prototypal OO in JavaScript, they think of prototype delegation. By now you should see that they’re missing out on a lot. Delegate prototypes aren’t the great alternative to class inheritance — object composition is. Why Composition is Immune to the Fragile Base Class ProblemTo understand the fragile base class problem and why it doesn’t apply to composition, first you have to understand how it happens: A is the base class B inherits from A C inherits from B D inherits from B C calls super, which runs code in B. B calls super which runs code in A. A and B contain unrelated features needed by both C &amp; D. D is a new use case, and needs slightly different behavior in A’s init code than C needs. So the newbie dev goes and tweaks A’s init code. __**_C_ breaks because it depends on the existing behavior**, and D starts working. What we have here are features spread out between A and B that C and D need to use in various ways. C and D don’t use every feature of A and B… they just want to inherit some stuff that’s already defined in A and B. But by inheriting and calling super, you don’t get to be selective about what you inherit. You inherit everything: “…the problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.” ~ Joe Armstrong — “Coders at Work” With CompositionImagine you have features instead of classes: 1feat1, feat2, feat3, feat4 C needs feat1 and feat3, D needs feat1, feat2, feat4: 12const C = compose(feat1, feat3);const D = compose(feat1, feat2, feat4); Now, imagine you discover that D needs slightly different behavior from feat1. It doesn’t actually need to change feat1, instead, you can make a customized version of feat1 and use that, instead. You can still inherit the existing behaviors from feat2 and feat4 with no changes: 1const D = compose(custom1, feat2, feat4); And __**_C_ remains unaffected**. The reason this is not possible with class inheritance is because when you use class inheritance, you buy into the whole existing class taxonomy. If you want to adapt a little for a new use-case, you either end up duplicating parts of the existing taxonomy (the duplication by necessity problem), or you refactor everything that depends on the existing taxonomy to adapt the taxonomy to the new use case due to the fragile base class problem. Composition is immune to both. You Think You Know Prototypes, but…If you were taught to build classes or constructor functions and inherit from those, what you were taught was not prototypal inheritance. You were taught how to mimic class inheritance using prototypes. See “Common Misconceptions About Inheritance in JavaScript”. In JavaScript, class inheritance piggybacks on top of the very rich, flexible prototypal inheritance features built into the language a long time ago, but when you use class inheritance — even the ES6+ class inheritance built on top of prototypes, you’re not using the full power &amp; flexibility of prototypal OO. In fact, you’re painting yourself into corners and opting into all of the class inheritance problems. Using class inheritance in JavaScript is like driving your new Tesla Model S to the dealer and trading it in for a rusted out 1983 Ford Pinto. Stamps: Composable Factory FunctionsMost of the time, composition is achieved using factory functions: functions which exist to create object instances. What if there was a standard that makes factory functions composable? There is. It’s called The Stamp Specification. Explore the Series What is a Closure? What is the Difference Between Class and Prototypal Inheritance? What is a Pure Function? What is Function Composition? What is Functional Programming? What is a Promise? Soft Skills Level Up Your Skills with Live 1:1 MentorshipDevAnywhere is the fastest way to level up to advanced JavaScript skills: Live lessons Flexible hours 1:1 mentorship Build real production apps https://devanywhere.io/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"interview","slug":"interview","permalink":"http://nthung2112.github.io/tags/interview/"}]},{"title":"Giải thích keyword 'new' trong Javascript","slug":"Giai-thich-keyword-new-trong-Javascript","date":"2017-08-20T15:21:52.000Z","updated":"2017-08-20T17:47:47.594Z","comments":true,"path":"2017/08/Giai-thich-keyword-new-trong-Javascript.html","link":"","permalink":"http://nthung2112.github.io/2017/08/Giai-thich-keyword-new-trong-Javascript.html","excerpt":"Normal Function CallTo explain what new does, let’s start with just a normal function, called without new. We want to write a function that will create “person” objects. It’ll give these objects name and age properties based on parameters that it takes in.","text":"Normal Function CallTo explain what new does, let’s start with just a normal function, called without new. We want to write a function that will create “person” objects. It’ll give these objects name and age properties based on parameters that it takes in. 123456789function personFn(name, age) &#123; var personObj = &#123;&#125;; personObj.name = name; personObj.age = age; return personObj;&#125;var alex = personFn('Alex', 30);// -&gt; &#123; name: 'Alex', age: 30 &#125; Simple enough. We create an object, add the properties to it, and return it at the end. newObject-oriented programming Let’s create a function that does the same thing, but we want it to be invoked using new. This function will create the same object as the one above. Common practice is to make functions that are meant to be invoked with new start with a capital letter. These functions are also referred to as constructors. 123456function PersonConstructor(name, age) &#123; this.name = name; this.age = age;&#125;var alex = new PersonConstructor('Alex', 30);// -&gt; &#123; name: 'Alex', age: 30 &#125; Invoking personFn normally and invoking PersonConstructor with new both result in the same object being created. What’s going on? The new keyword invokes a function in a special way. It adds some implicit code that we don’t see. Let’s expand the above function to show everything that’s happening. The commented lines are pseudocode representing functionality that is implicitly added by the JS engine when using new. 12345678910111213141516function PersonConstructor(name, age) &#123; // this = &#123;&#125;; // this.__proto__ = PersonConstructor.prototype; // Set up logic such that: if // there is a return statement // in the function body that // returns anything EXCEPT an // object, array, or function: // return 'this' (the newly // constructed object) // instead of that item at // the return statement; this.name = name; this.age = age; // return this;&#125; Let’s break it down. new: Creates a new object and binds it to the this keyword. Sets the object’s internal [[Prototype]], property, &#95;&#95;proto&#95;&#95;, to be the prototype of the constructing function. This also makes it so the constructor of the new object is prototypically inherited. Sets up logic such that if a variable of any type other than object, array, or function is returned in the function body, return this, the newly constructed object, instead of what the function says to return. At the end of the function, returns this if there is no return statement in the function body. Let’s show that these statements are valid, one by one. 12345678910111213function Demo() &#123; console.log(this); this.value = 5; return 10;&#125;/*1*/ var demo = new Demo(); // -&gt; &#123;&#125;/*2*/ console.log(demo.__proto__ === Demo.prototype); // -&gt; true console.log(demo.constructor === Demo); // -&gt; true/*3*/ console.log(demo); // -&gt; &#123; value: 5 &#125;function SecondDemo() &#123; this.val = '2nd demo';&#125;/*4*/ console.log(new SecondDemo()); // -&gt; &#123; val: '2nd demo' &#125; If you aren’t familiar with constructors or prototypes, don’t worry about it too much. You’ll run into them as you continue to learn Javascript. For now, just understand that the new object implicitly returned by the constructor function will be able to inherit properties and methods. Calling a non-constructor with newWhat happens if we invoke a normal function like personFn using new? Nothing special. The same rules apply. in the case of personFn, we see nothing explicitly happening. 12var alex = new personFn('Alex', 30);// -&gt; &#123; name: 'Alex', age: 30 &#125; Why? Let’s add our implicit code in to personFn. 123456789101112131415161718192021function personFn(name, age) &#123; // this = &#123;&#125;; // this.constructor = PersonConstructor; // this.__proto__ = PersonConstructor.prototype; // Set up logic such that: if // there is a return statement // in the function body that // returns anything EXCEPT an // object, array, or function: // return this (the newly // constructed object) // instead of that item at // the return statement; var personObj = &#123;&#125;; personObj.name = name; personObj.age = age; return personObj; // return this;&#125; The implicit code is still added in: It binds this to a new object and sets its constructor and prototype. It adds logic that will return this instead of a non-object. It adds an implicit return this statement at the end. This doesn’t affect our code, since we don’t use the this keyword in our code. We also explicitly return an object, personObj, so the returning logic and the return this line have no use. Effectively, using new to invoke our function here has no effect on the output. If we were using this or if we weren’t returning an object, the function would have different effects when invoked with and without new. That’s it. Go write some code.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"}]},{"title":"A Jade Tutorial for Beginners","slug":"A-Jade-Tutorial-for-Beginners","date":"2017-08-20T14:57:13.000Z","updated":"2017-08-20T15:07:42.818Z","comments":true,"path":"2017/08/A-Jade-Tutorial-for-Beginners.html","link":"","permalink":"http://nthung2112.github.io/2017/08/A-Jade-Tutorial-for-Beginners.html","excerpt":"Jade is an elegant templating engine, primarily used for server-side templating in NodeJS. In plain words, Jade gives you a powerful new way to write markup, with a number of advantages over plain HTML. For example, take a look at this movie card in HTML: 123456789&lt;div&gt; &lt;h1&gt;Ocean's Eleven&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Comedy&lt;/li&gt; &lt;li&gt;Thriller&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Danny Ocean and his eleven accomplices plan to rob three Las Vegas casinos simultaneously.&lt;/p&gt;&lt;/div&gt;","text":"Jade is an elegant templating engine, primarily used for server-side templating in NodeJS. In plain words, Jade gives you a powerful new way to write markup, with a number of advantages over plain HTML. For example, take a look at this movie card in HTML: 123456789&lt;div&gt; &lt;h1&gt;Ocean's Eleven&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Comedy&lt;/li&gt; &lt;li&gt;Thriller&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Danny Ocean and his eleven accomplices plan to rob three Las Vegas casinos simultaneously.&lt;/p&gt;&lt;/div&gt; This is what the same markup looks like in Jade: 12345678div h1 Ocean&apos;s Eleven ul li Comedy li Thriller p. Danny Ocean and his eleven accomplices plan to rob three Las Vegas casinos simultaneously. The Jade version is elegant and concise. But it’s not just about the beautiful syntax. Jade has some really neat features, allowing you to write modular and reusable markup. Before we get into these powerful features, let’s do a quick overview of the basics. The BasicsI’m going to highlight three basic features in Jade Simple tags Adding attributes to the tags Blocks of text If you want to try this out as we go along, you can use CodePen and choose Jade as your HTML preprocessor or use the online compiler on the official Jade page to compile your Jade to HTML. Simple TagsAs you might have noticed earlier, there are no “closing” tags in Jade. Instead, Jade uses indentation (i.e. white space) to determine how tags are nested. 123div p Hello! p World! In the example above, since the paragraph tags are indented, they will end up inside the div tag. Simple! 1234&lt;div&gt; &lt;p&gt;Hello!&lt;/p&gt; &lt;p&gt;World!&lt;/p&gt;&lt;/div&gt; Jade compiles this accurately by treating the first word on each line as a tag, while subsequent words on that line are treated as text inside the tag. View this example on CodePen AttributesAll this is great, but how do we add attributes to our tags? Quite simple really. Let’s go back to our first example and toss in some classes and a poster image. 123456div(class=&quot;movie-card&quot;, id=&quot;oceans-11&quot;) h1(class=&quot;movie-title&quot;) Ocean&apos;s 11 img(src=&quot;/img/oceans-11.png&quot;, class=&quot;movie-poster&quot;) ul(class=&quot;genre-list&quot;) li Comedy li Thriller Pretty neat right? 12345678&lt;div class=\"movie-card\" id=\"oceans-11\"&gt; &lt;h1 class=\"movie-title\"&gt;Ocean's 11&lt;/h1&gt; &lt;img src=\"/img/oceans-11.png\" class=\"movie-poster\"&gt; &lt;ul class=\"genre-list\"&gt; &lt;li&gt;Comedy&lt;/li&gt; &lt;li&gt;Thriller&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; View this example on CodePen But it doesn’t stop here. Jade provides special shorthand for IDs and classes, further simplifying our markup using a familiar notation: 123456div.movie-card#oceans-11 h1.movie-title Ocean&apos;s 11 img.movie-poster(src=&quot;/img/oceans-11.png&quot;) ul.genre-list li Comedy li Thriller View this example on CodePen As you can see, Jade uses the same syntax as that which we’re already familiar with when writing CSS selectors, making it even easier to spot classes. Blocks of TextLet’s say you have a paragraph tag and you want to place a large block of text in it. Jade treats the first word of every line as an HTML tag – so what do you do? You might have noticed an innocent period in the first code example in this article. Adding a period (full stop) after your tag indicates that everything inside that tag is text and Jade stops treating the first word on each line as an HTML tag. 123456div p How are you? p. I&apos;m fine thank you. And you? I heard you fell into a lake? That&apos;s rather unfortunate. I hate it when my shoes get wet. View this example on CodePen And just to drive home the point, if I were to remove the period after the p tag in this example, the compiled HTML would treat the “I” in the word “I’m” as an opening tag (in this case, it would be the &lt;i&gt; tag). Powerful FeaturesNow that we’ve covered the basics, let’s take a peek at some powerful features that will make your markup smarter. We’ll look at the following features in remainder of this tutorial: Loops JavaScript Interpolation Mixins Using JavaScript in JadeJade is implemented with JavaScript, so it’s super-easy to use JavaScript in Jade. Here’s an example. 123456- var x = 5;div ul - for (var i=1; i&lt;=x; i++) &#123; li Hello - &#125; What did we just do here?! By starting a line with a hyphen, we indicate to the Jade compiler that we want to start using JavaScript and it just works as we would expect. Here’s what you get when you compile the Jade code above to HTML: 123456789&lt;div&gt; &lt;ul&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; View this example on CodePen We use a hyphen when the code doesn’t directly add output. If we want to use JavaScript to output something in Jade, we use =. Let’s tweak the code above to show a serial number. 123456- var x = 5;div ul - for (var i=1; i&lt;=x; i++) &#123; li= i + &quot;. Hello&quot; - &#125; And voilà, we now have serial numbers: 123456789&lt;div&gt; &lt;ul&gt; &lt;li&gt;1\\. Hello&lt;/li&gt; &lt;li&gt;2\\. Hello&lt;/li&gt; &lt;li&gt;3\\. Hello&lt;/li&gt; &lt;li&gt;4\\. Hello&lt;/li&gt; &lt;li&gt;5\\. Hello&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; View this example on CodePen Of course, in this case, an ordered list would be much more appropriate, but you get the point. Now, if you’re worried about XSS and HTML escaping, read the docs for more info. LoopsJade provides an excellent looping syntax so that you don’t need to resort to JavaScript. Let’s loop over an array: 123456- var droids = [&quot;R2D2&quot;, &quot;C3PO&quot;, &quot;BB8&quot;];div h1 Famous Droids from Star Wars for name in droids div.card h2= name And this will compile as follows: 123456789101112&lt;div&gt; &lt;h1&gt;Famous Droids from Star Wars&lt;/h1&gt; &lt;div class=\"card\"&gt; &lt;h2&gt;R2D2&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"card\"&gt; &lt;h2&gt;C3PO&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"card\"&gt; &lt;h2&gt;BB8&lt;/h2&gt; &lt;/div&gt;&lt;/div&gt; View this example on CodePen You can iterate over objects and use while loops too. Check out the docs for more. InterpolationIt can get annoying to mix JavaScript into text like this p= &quot;Hi there, &quot; + profileName + &quot;. How are you doing?&quot;. Does Jade have an elegant solution for this? You bet. 123- var profileName = &quot;Danny Ocean&quot;;div p Hi there, #&#123;profileName&#125;. How are you doing? View this example on CodePen Isn’t that neat? MixinsMixins are like functions. They take parameters as input and give markup as output. Mixins are defined using the mixin keyword. 1234mixin thumbnail(imageName, caption) div.thumbnail img(src=&quot;/img/#&#123;imageName&#125;.jpg&quot;) h4.image-caption= caption Once the mixin is defined, you can call the mixin with the + syntax. 12+thumbnail(&quot;oceans-eleven&quot;, &quot;Danny Ocean makes an elevator pitch.&quot;)+thumbnail(&quot;pirates&quot;, &quot;Introducing Captain Jack Sparrow!&quot;) Which will output HTML like this: 123456789101112&lt;div class=\"thumbnail\"&gt; &lt;img src=\"/img/oceans-eleven.jpg\"&gt; &lt;h4 class=\"image-caption\"&gt; Danny Ocean makes an elevator pitch. &lt;/h4&gt;&lt;/div&gt;&lt;div class=\"thumbnail\"&gt; &lt;img src=\"/img/pirates.jpg\"&gt; &lt;h4 class=\"image-caption\"&gt; Introducing Captain Jack Sparrow! &lt;/h4&gt;&lt;/div&gt; Putting It All TogetherLet’s put together everything we’ve learned so far. Say we have a nice array of movies, with each item containing the movie’s title, the cast (a sub-array), the rating, the genre, a link to the IMDB page and the image path for the movie’s poster. The array will look something like this (white space added for readability): 1234567891011- var movieList = [ &#123; title: \"Ocean's Eleven\", cast: [\"Julia Roberts\", \"George Clooney\", \"Brad Pitt\", \"Andy Garcia\"], genres: [\"Comedy\", \"Thriller\"], posterImage: \"/img/oceans-eleven\", imdbURL: \"http://www.imdb.com/title/tt0240772/\", rating: 7 &#125; // etc...]; We have 10 movies and we want to build nice movie cards for each of them. Initially, we don’t plan to use the IMDB link. If a movie is rated above 5, we give it a thumbs up, otherwise, we give it a thumbs down. We’ll use all the nice features of Jade to write some modular code to do the following: Create a mixin for a movie card Iterate through the cast list and display the actors. We’ll do the same with genres. Check the rating and decide whether to display a thumbs up or a thumbs down. Iterate through the movie list and use the mixin to create one card per movie. So let’s create the mixin first. 12345678910111213141516mixin movie-card(movie) div.movie-card h2.movie-title= movie.title img.movie-poster(src=movie.posterImage) h3 Cast ul.cast each actor in movie.cast li= actor div.rating if movie.rating &gt; 5 img(src=&quot;img/thumbs-up&quot;) else img(src=&quot;img/thumbs-down&quot;) ul.genre each genre in movie.genres li= genre There’s a lot going on up there, but I’m sure it looks familiar – we’ve covered all this in this tutorial. Now, we just need to use our mixin in a loop: 12for movie in movieList +movie-card(movie) That’s it. Is that elegant or what? Here’s the final code. 1234567891011121314151617181920212223242526272829303132333435363738- var movieList = [ &#123; title: &quot;Ocean&apos;s Eleven&quot;, cast: [&quot;Julia Roberts&quot;, &quot;George Clooney&quot;, &quot;Brad Pitt&quot;, &quot;Andy Garcia&quot;], genres: [&quot;Comedy&quot;, &quot;Thriller&quot;], posterImage: &quot;/img/oceans-eleven&quot;, imdbURL: &quot;http://www.imdb.com/title/tt0240772/&quot;, rating: 9.2 &#125;, &#123; title: &quot;Pirates of the Caribbean&quot;, cast: [&quot;Johnny Depp&quot;, &quot;Keira Knightley&quot;, &quot;Orlando Bloom&quot;], genres: [&quot;Adventure&quot;, &quot;Comedy&quot;], posterImage: &quot;/img/pirates-caribbean&quot;, imdbURL: &quot;http://www.imdb.com/title/tt0325980/&quot;, rating: 9.7 &#125;];mixin movie-card(movie) div.movie-card h2.movie-title= movie.title img.movie-poster(src=movie.posterImage) h3 Cast ul.cast each actor in movie.cast li= actor div.rating if movie.rating &gt; 5 img(src=&quot;img/thumbs-up&quot;) else img(src=&quot;img/thumbs-down&quot;) ul.genre each genre in movie.genres li= genrefor movie in movieList +movie-card(movie) And here’s the compiled HTML: 1234567891011121314151617181920212223242526272829303132333435&lt;div class=\"movie-card\"&gt; &lt;h2 class=\"movie-title\"&gt;Ocean's Eleven&lt;/h2&gt; &lt;img src=\"/img/oceans-eleven\" class=\"movie-poster\"/&gt; &lt;h3&gt;Cast&lt;/h3&gt; &lt;ul class=\"cast\"&gt; &lt;li&gt;Julia Roberts&lt;/li&gt; &lt;li&gt;George Clooney&lt;/li&gt; &lt;li&gt;Brad Pitt&lt;/li&gt; &lt;li&gt;Andy Garcia&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"rating\"&gt; &lt;img src=\"img/thumbs-up\"/&gt; &lt;/div&gt; &lt;ul class=\"genre\"&gt; &lt;li&gt;Comedy&lt;/li&gt; &lt;li&gt;Thriller&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class=\"movie-card\"&gt; &lt;h2 class=\"movie-title\"&gt;Pirates of the Carribean&lt;/h2&gt; &lt;img src=\"/img/pirates-caribbean\" class=\"movie-poster\"/&gt; &lt;h3&gt;Cast&lt;/h3&gt; &lt;ul class=\"cast\"&gt; &lt;li&gt;Johnny Depp&lt;/li&gt; &lt;li&gt;Keira Knightley&lt;/li&gt; &lt;li&gt;Orlando Bloom&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"rating\"&gt; &lt;img src=\"img/thumbs-up\"/&gt; &lt;/div&gt; &lt;ul class=\"genre\"&gt; &lt;li&gt;Adventure&lt;/li&gt; &lt;li&gt;Comedy&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; But wait a minute. What if we now want to go to the movie’s IMDB page when we click on a movie’s title? We can add one line: a(href=movie.imdbURL) to the mixin. 1234567891011121314151617mixin movie-card(movie) div.movie-card a(href=movie.imdbURL) h2.movie-title= movie.title img.movie-poster(src=movie.posterImage) h3 Cast ul.cast each actor in movie.cast li= actor div.rating if movie.rating &gt; 5 img(src=&quot;img/thumbs-up&quot;) else img(src=&quot;img/thumbs-down&quot;) ul.genre each genre in movie.genres li= genre View this example on CodePen ConclusionWe went from knowing nothing about Jade to building some beautiful modular movie cards. There’s a lot more to Jade, but I’ve glossed over some concepts to keep things simple. So I hope this tutorial piqued your curiosity to learn more. Important note: As some of you might already know, Jade has been renamed to Pug due to a software trademark claim. In the future, articles on Jade will use the new name “Pug” or “PugJS”.","categories":[],"tags":[{"name":"jade","slug":"jade","permalink":"http://nthung2112.github.io/tags/jade/"},{"name":"html","slug":"html","permalink":"http://nthung2112.github.io/tags/html/"}]},{"title":"Reducing CSS bundle size with webpack","slug":"reducing-css-bundle-size-with-webpack","date":"2017-08-20T08:41:31.000Z","updated":"2017-08-20T14:50:45.892Z","comments":true,"path":"2017/08/reducing-css-bundle-size-with-webpack.html","link":"","permalink":"http://nthung2112.github.io/2017/08/reducing-css-bundle-size-with-webpack.html","excerpt":"Đầu năm nay tôi đã build 1 ứng dụng tên là GO2CINEMA, 1 ứng dụng nhỏ gọn, nhanh nhẹ, bảo mật, giúp người dùng book vé xem phim ở Anh. Trong thời gian build ứng dụng này, tôi đã bị ám ảnh với việc tối ưu hóa tốc độ render. Tôi đã giải quyết việc pre-render HTML bằng usus. usus sẽ render HTML SPA (Single Page Application) và sử dụng inline CSS. Tuy nhiên tôi không thích việc nhét đến 70kB dung lượng vào mỗi tài liệu HTML, nhất là khi phần lớn dung lượng đó là để chứa tên class CSS.","text":"Đầu năm nay tôi đã build 1 ứng dụng tên là GO2CINEMA, 1 ứng dụng nhỏ gọn, nhanh nhẹ, bảo mật, giúp người dùng book vé xem phim ở Anh. Trong thời gian build ứng dụng này, tôi đã bị ám ảnh với việc tối ưu hóa tốc độ render. Tôi đã giải quyết việc pre-render HTML bằng usus. usus sẽ render HTML SPA (Single Page Application) và sử dụng inline CSS. Tuy nhiên tôi không thích việc nhét đến 70kB dung lượng vào mỗi tài liệu HTML, nhất là khi phần lớn dung lượng đó là để chứa tên class CSS. Google xử lý như thế nào?Đã bao giờ bạn tò mò về source code của Google chưa? Nếu rồi, hẳn bạn sẽ nhận ra tên class CSS chỉ đơn giản là vài ký tự. Bạn có thắc mắc tại sao lại thế không? Sự thiếu sót của CSS minifierCó 1 thứ duy nhất minifier không thể làm được: đó là thay đổi tên của selector. Lý do là vì minifier CSS không điều khiển được các HTML output. Trong lúc đó, các CSS name có thể rất dài. Nếu bạn sử dụng CSS module, CSS module sẽ có xu hướng thêm các tên cho stylesheet, local identifier và các hash ngẫu nhiên. Dạng của tên class sẽ được định nghĩa bởi css-loader localIdentName, config như sau: [name]___[local]___[hash:base64:5. Do đó, tên class sẽ được sinh ra có dạng giống thế: .MovieView___movie-title___yvKVV; trong trường hợp bạn muốn mô tả kĩ hơn, tên class có thể còn dài nữa: .MovieView___movie-description-with-summary-paragraph___yvKVV Thay đổi tên class CSS ngay thời điểm biên dịchNếu bạn sử dụng webpack và babel-plugin-react-css-module thì bạn không cần lo lắng thêm về vấn đề này nữa. Bạn có thể thay đổi tên class ngay thời điểm biên dịch bằng cách sử dụng css-loader getLocalIdent và babel-plugin-react-css-modules generateScopedName. 1234567const generateScopedName = ( localName: string, resourcePath: string) =&gt; &#123; const componentName = resourcePath.split('/').slice(-2, -1);return componentName + '_' + localName;&#125;; Có 1 điều khá tuyệt về generateScopedName đó là instance của function này có thể được sử dụng trong quá trình build của babel và webpack. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @file Webpack configuration. */const path = require('path');const generateScopedName = (localName, resourcePath) =&gt; &#123; const componentName = resourcePath.split('/').slice(-2, -1); return componentName + '_' + localName;&#125;;module.exports = &#123; module: &#123; rules: [ &#123; include: path.resolve(__dirname, '../app'), loader: 'babel-loader', options: &#123; babelrc: false, extends: path.resolve(__dirname, '../app/webpack.production.babelrc'), plugins: [ [ 'react-css-modules', &#123; context: common.context, filetypes: &#123; '.scss': &#123; syntax: 'postcss-scss' &#125; &#125;, generateScopedName, webpackHotModuleReloading: false &#125; ] ] &#125;, test: /\\.js$/ &#125;, &#123; test: /\\.scss$/, use: [ &#123; loader: 'css-loader', options: &#123; camelCase: true, getLocalIdent: (context, localIdentName, localName) =&gt; &#123; return generateScopedName(localName, context.resourcePath); &#125;, importLoaders: 1, minimize: true, modules: true &#125; &#125;, 'resolve-url-loader' ] &#125; ] &#125;, output: &#123; filename: '[name].[chunkhash].js', path: path.join(__dirname, './.dist'), publicPath: '/static/' &#125;, stats: 'minimal'&#125;; Đặt tên ngắnMay mắn rằng babel-plugin-react-css-modules và css-loader sử dụng cùng 1 logic để sinh ra tên class CSS. Nhờ đó ta có thể thay đổi tên class bất cứ khi nào cần thiết, thậm chí các hash ngẫu nhiên. Cá nhân tôi thì lại muốn tên class ngắn nhất có thể. Để làm được điều này, tôi sẽ tạo 1 class name index và sử dụng module incstr để sinh ra các ID tăng dần cho mỗi bản ghi. 123456789101112131415161718192021222324252627282930313233343536const incstr = require('incstr');const createUniqueIdGenerator = () =&gt; &#123; const index = &#123;&#125;; const generateNextId = incstr.idGenerator(&#123; // Removed \"d\" letter to avoid accidental \"ad\" construct. // @see https://medium.com/@mbrevda/just-make-sure-ad-isnt-being-used-as-a-class-name-prefix-or-you-might-suffer-the-wrath-of-the-558d65502793 alphabet: 'abcefghijklmnopqrstuvwxyz0123456789' &#125;); return (name) =&gt; &#123; if (index[name]) &#123; return index[name]; &#125; let nextId; do &#123; // Class name cannot start with a number. nextId = generateNextId(); &#125; while (/^[0-9]/.test(nextId)); index[name] = generateNextId(); return index[name]; &#125;;&#125;;const uniqueIdGenerator = createUniqueIdGenerator();const generateScopedName = (localName, resourcePath) =&gt; &#123; const componentName = resourcePath.split('/').slice(-2, -1); return uniqueIdGenerator(componentName) + '_' + uniqueIdGenerator(localName);&#125;; Việc này sẽ đảm bảo được tên class sẽ đủ ngắn và duy nhất trong cả ứng dụng. Bây giờ thay vì là những cái tên dài ngoằng như .MovieView___movie-title___yvKVV và .MovieView___movie-description-with-summary-paragraph___yvKVV, tên class đã trở thành .a_a, .b_a. Nhờ đó mà kích thước file bundle css của GO2CINEMA đã giảm từ 140kB xuống còn 53kB. Sử dụng Scope Isolation để giảm kích thước file bundleCó 1 lý do cho việc tôi sử dụng _ trong tên class, chia tách tên các component với tên các local identifier, điều này rất hữu ích cho quá trình minify. csso (CSS minifier) có những thiết lập về scope. Scope sẽ định nghĩa các danh sách tên class CSS để sử dụng với 1 số markup, ví dụ các selector từ các scope khác nhau sẽ không nối với các element giống nhau. Việc này sẽ giúp cho việc optimize chủ động hơn. Dưới đây là code sử dụng csso-webpack-plugin để tiền xử lý file bundle CSS: 12345678910111213141516171819202122232425262728293031const getScopes = (ast) =&gt; &#123; const scopes = &#123;&#125;; const getModuleID = (className) =&gt; &#123; const tokens = className.split('_')[0]; if (tokens.length !== 2) &#123; return 'default'; &#125; return tokens[0]; &#125;; csso.syntax.walk(ast, node =&gt; &#123; if (node.type === 'ClassSelector') &#123; const moduleId = getModuleID(node.name); if (moduleId) &#123; if (!scopes[moduleId]) &#123; scopes[moduleId] = []; &#125; if (!scopes[moduleId].includes(node.name)) &#123; scopes[moduleId].push(node.name); &#125; &#125; &#125; &#125;); return Object.values(scopes);&#125;; Quá trình này tiếp tục giảm kích thước file bundle CSS của GO2CINEMA từ 53kB còn 47kB. Kết luậnHẳn sẽ có những ý kiến trái chiều nói rằng việc minify này hoàn toàn có thể dùng thuật toán nén. Với GO2CINEMA, fle bundle CSS sau khi được nén bằng thuật toán Brotli thì kích thước của nó chỉ ít hơn 1kB so với cách minify file bundle bỏ-tên-class tôi đã trình bày trên. Mặt khác, cài đặt quá trình minify có thể xem như là 1 khoản đầu tư dài hạn. Ngoài việc giảm kích thước file cần parse, nó còn có những lợi ích khác nữa, ví dụ như ngăn chặn việc tên class CSS không bị nối với các selector của blocklist ad-blocker chẳng hạn. Bạn có thể xem demo của minification này được sử dụng với các phim trên GO2CINEMA: https://go2cinema.com/movies/wonder-woman-2017-1305237 https://go2cinema.com/venues/odeon-oxford-magdalen-st-1001053","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://nthung2112.github.io/tags/css/"},{"name":"webpack","slug":"webpack","permalink":"http://nthung2112.github.io/tags/webpack/"}]},{"title":"How to Create a Reddit Clone Using React and Firebase","slug":"How-to-Create-a-Reddit-Clone-Using-React-and-Firebase","date":"2017-07-23T09:48:27.000Z","updated":"2017-08-20T14:50:38.595Z","comments":true,"path":"2017/07/How-to-Create-a-Reddit-Clone-Using-React-and-Firebase.html","link":"","permalink":"http://nthung2112.github.io/2017/07/How-to-Create-a-Reddit-Clone-Using-React-and-Firebase.html","excerpt":"React is an awesome JavaScript library for building user interfaces. Since the publishing of Create React App, it has become very easy to scaffold a barebones React application. In this article, we will be using Firebase along with Create React App to build an app which will function similar to Reddit. It will allow the user to submit a new link which can then be voted on. Here’s a live demo of what we’ll be building.","text":"React is an awesome JavaScript library for building user interfaces. Since the publishing of Create React App, it has become very easy to scaffold a barebones React application. In this article, we will be using Firebase along with Create React App to build an app which will function similar to Reddit. It will allow the user to submit a new link which can then be voted on. Here’s a live demo of what we’ll be building. Why Firebase?Using Firebase will make it very easy for us to show real-time data to the user. Once a user votes on a link, the feedback will be instantaneous. Firebase’s Realtime Database will help us in developing this feature. Also, it will help us to understand how to bootstrap a React application with Firebase. Why React?React is particularly known for creating user interfaces using a component architecture. Each component can contain internal state or be passed data as props. State and props are the two most important concepts in React. These two things help us determine the state of our application at any point in time. If you are not familiar with these terms, please head over to the React docs first. Note: You can also use a state container like Redux or MobX, but for the sake of simplicity, we won’t be using one for this tutorial. The whole project is available on Github. By the way, for a high-quality, in-depth introduction to React, you can’t go past Canadian full-stack developer Wes Bos. Try his course, and use the coupon code ‘SITEPOINT’ to get 25% off and to help support SitePoint. Setting up the projectLet’s walk through the steps to set up our project structure and any necessary dependencies. Installing create-react-appIf you haven’t already, you need to install create-react-app. To do so, you can type the following in your terminal: 1npm install -g create-react-app Once you’ve installed it globally, you can use it to scaffold a React project inside any folder. Now, let’s create a new app and call it reddit-clone. 1create-react-app reddit-clone This will scaffold a new create-react-app project inside the reddit-clone folder. Once the bootstrapping is done, we can go inside reddit-clone directory and fire up the development server: 1npm start At this point, you can go to http://localhost:3000/ and see your app skeleton up and running. Structuring the appFor maintenance, I always like to separate my containers and components. Containers are the smart components which are contains the business logic of our application and manage Ajax requests. Components are simply dumb presentational components. They can have their own internal state which can be used to control the logic of that component (e.g. showing the current state of a controlled input component). After removing the unnecessary logo and css files, this is how your app should look like now. We created a components folder and a containers folder. Let’s move App.js inside the containers/App folder and create registerServiceWorker.js inside the utils folder. Your src/containers/App/index.js file should look like this: 123456789101112131415// src/containers/App/index.jsimport React, &#123; Component &#125; from 'react';class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; Hello World &lt;/div&gt; ); &#125;&#125;export default App; Your src/index.js file should look like this: 123456789// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import App from './containers/App';import registerServiceWorker from './utils/registerServiceWorker';ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));registerServiceWorker(); Go to your browser and if every thing works fine you will see Hello World on your screen. You can check my commit on Github. Adding react-routerReact-router will help us define the routes for our app. It’s very customizable and very popular in the react ecosystem. We will be using version 3.0.0 of react-router. 1npm install --save react-router@3.0.0 Now, add a new file routes.js inside the src folder with the following code: 123456789101112131415// routes.jsimport React from 'react';import &#123; Router, Route &#125; from 'react-router';import App from './containers/App';const Routes = (props) =&gt; ( &lt;Router &#123;...props&#125;&gt; &lt;Route path=\"/\" component=&#123; App &#125;&gt; &lt;/Route&gt; &lt;/Router&gt;);export default Routes; The Router component wraps all the Route components. Based on the path prop of the Route component, the component passed to the component prop, will be rendered on the page. Here, we are setting up the root URL (/) to load our App component using the Router component. 1234&lt;Router &#123;...props&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123; &lt;div&gt;Hello World!&lt;/div&gt; &#125;&gt; &lt;/Route&gt;&lt;/Router&gt; The above code is also valid. For the path /, the &lt;div&gt;Hello World!&lt;/div&gt; will be mounted. Now, we need to call our routes.js file from our src/index.js file. The file should have the following content: 12345678910111213141516// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import &#123; browserHistory &#125; from 'react-router';import App from './containers/App';import Routes from './routes';import registerServiceWorker from './utils/registerServiceWorker';ReactDOM.render( &lt;Routes history=&#123;browserHistory&#125; /&gt;, document.getElementById('root'));registerServiceWorker(); Basically, we are mounting our Router component from our routes.js file. We pass in the history prop to it so that the routes know how to handle history tracking. You can check my commit on Github. Adding FirebaseIf you don’t have a Firebase account, create one now (it’s free!) by going to their website. After you’re done creating a new account, log into your account and go to the console page and click on Add project. Enter the name of your project (I’ll call mine reddit-clone), choose your country, and click on the Create project button. Now, before we proceed we need to change the rules for the database since, by default, Firebase expects the user to be authenticated to be able to read and write data. If you select your project and click on the Database tab on the left, you will be able to see your database. You need to click on the Rules tab on the top that will redirect us to a screen which will have the following data: 123456&#123; \"rules\": &#123; \".read\": \"auth != null\", \".write\": \"auth != null\" &#125;&#125; We need to change this to the following: 123456&#123; \"rules\": &#123; \".read\": \"auth === null\", \".write\": \"auth === null\" &#125;&#125; This will let users update the database without logging in. If we implemented a flow in which we had authentication before making updates to the database, then we would need the default rules provided by Firebase. To keep this application simple, we won’t be doing authentication. Important: If you don’t make this modification, Firebase won’t let you update the database from your app. Now, let’s add the firebase npm module to our app by running the following code: 1npm install --save firebase Next, import that module in your App/index.js file as: 123// App/index.jsimport * as firebase from \"firebase\"; When we select our project after logging into Firebase, we will get an option Add Firebase to your web app. If we click on that option, a modal will appear which will show us the config variable which we will use in our componentWillMount method. Let’s create the Firebase config file. We shall call this file firebase-config.js and this file will contain all the configs necessary to connect our app with Firebase. 12345678910// App/firebase-config.jsexport default &#123; apiKey: \"AIzaSyBRExKF0cHylh_wFLcd8Vxugj0UQRpq8oc\", authDomain: \"reddit-clone-53da5.firebaseapp.com\", databaseURL: \"https://reddit-clone-53da5.firebaseio.com\", projectId: \"reddit-clone-53da5\", storageBucket: \"reddit-clone-53da5.appspot.com\", messagingSenderId: \"490290211297\"&#125;; We’ll import our Firebase config into App/index.js. 123// App/index.jsimport config from './firebase-config'; We will initialize our Firebase database connection in the constructor. 12345678// App/index.jsconstructor() &#123; super(); // Initialize Firebase firebase.initializeApp(config);&#125; In the componentWillMount() lifecycle hook, we use the package firebase we just installed and call its initializeApp method and passed the config variable to it. This object contains all the data about our app. The initializeApp method will connect our application to our Firebase database so that we can read and write data. Let’s add some data to Firebase to check if our configuration is correct. Go to the Database tab and add the following structure to your database: Clicking on Add will save the data to our database. Now, let’s add some code to our componentWillMount method to make the data appear on our screen. 123456789101112131415161718// App/index.jscomponentWillMount() &#123; ... let postsRef = firebase.database().ref('posts'); let _this = this; postsRef.on('value', function(snapshot) &#123; console.log(snapshot.val()); _this.setState(&#123; posts: snapshot.val(), loading: false &#125;); &#125;); &#125; firebase.database() gives us a reference to the database service. Using ref(), we can get a specific reference from the database. For example, if we call ref(&#39;posts&#39;), we will be getting the posts reference from our database and storing that reference in postsRef. postsRef.on(&#39;value&#39;, ...) gives us the updated value whenever there is any change in the database. This is very useful when we need a real-time update to our user interface based on any database events. Using postsRef.once(&#39;value&#39;, ...) will only give us the data once. This is useful for data that only needs to be loaded once and isn’t expected to change frequently or require active listening. After we get the updated value in our on() callback, we store the values in our posts state. Now, we will see the data appearing on our console. Also, we will be passing this data down to our children. So, we need to modify the render function of our App/index.js file: 12345678910111213// App/index.jsrender() &#123; return ( &lt;div className=\"App\"&gt; &#123;this.props.children &amp;&amp; React.cloneElement(this.props.children, &#123; firebaseRef: firebase.database().ref('posts'), posts: this.state.posts, loading: this.state.loading &#125;)&#125; &lt;/div&gt; );&#125; This main objective here is to make the posts data available in all our children components which will be passed through react-router. We are checking if this.props.children exists or not and if it exists we clone that element and pass all our props to all our children. This is a very efficient way of passing props to dynamic children. Calling cloneElement will shallowly merge the already existing props in this.props.children and the props, we passed here (firebaseRef, posts and loading). Using this technique, the firebaseRef, posts and loading props will be available to all routes. You can check my commit on Github. Connecting The App With FirebaseFirebase can only store data as objects; it doesn’t have any native support for arrays. We will store the data in the following format: Add the data in the screenshot above manually so that you can test your views. Add views for all the postsNow, we will add views to show all the posts. Create a file src/containers/Posts/index.js with the following content: 1234567891011121314151617181920212223242526272829// src/containers/Posts/index.jsimport React, &#123; Component &#125; from 'react';class Posts extends Component &#123; render() &#123; if (this.props.loading) &#123; return ( &lt;div&gt; Loading... &lt;/div&gt; ); &#125; return ( &lt;div className=\"Posts\"&gt; &#123; this.props.posts.map((post) =&gt; &#123; return ( &lt;div&gt; &#123; post.title &#125; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; ); &#125;&#125;export default Posts; Here, we are just mapping over the data and rendering it to the user interface. Next, we need to add this to our routes.js file. 123456789// routes.js...&lt;Router &#123;...props&#125;&gt; &lt;Route path=\"/\" component=&#123; App &#125;&gt; &lt;Route path=\"/posts\" component=&#123; Posts &#125; /&gt; &lt;/Route&gt;&lt;/Router&gt;... This is because we want the posts to show up only on the /posts route. So, we just pass the Posts component to the component prop and /posts to the path prop of the Route component of react-router. If we go to the URL localhost:3000/posts, we will see the posts from our Firebase database. You can check my commit on Github. Add views to write a new postNow, let’s create a view from where we can add a new post. Create a file src/containers/AddPost/index.js with the following content: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// src/containers/AddPost/index.jsimport React, &#123; Component &#125; from 'react';class AddPost extends Component &#123; constructor() &#123; super(); this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; state = &#123; title: '' &#125;; handleChange = (e) =&gt; &#123; this.setState(&#123; title: e.target.value &#125;); &#125; handleSubmit = (e) =&gt; &#123; e.preventDefault(); this.props.firebaseRef.push(&#123; title: this.state.title &#125;); this.setState(&#123; title: '' &#125;); &#125; render() &#123; return ( &lt;div className=\"AddPost\"&gt; &lt;input type=\"text\" placeholder=\"Write the title of your post\" onChange=&#123; this.handleChange &#125; value=&#123; this.state.title &#125; /&gt; &lt;button type=\"submit\" onClick=&#123; this.handleSubmit &#125; &gt; Submit &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default AddPost; Here, the handleChange method updates our state with the value present in the input box. Now, when we click on the button, the handleSubmit method is triggered. The handleSubmit method is responsible for making the API request to write to our database. We do it using the firebaseRef prop which we passed to all the children. 123this.props.firebaseRef.push(&#123; title: this.state.title&#125;); The above block of code sets the current value of the title to our database. After the new post has been stored in the database, we make the input box empty again ready to add a new post. Now, we need to add this page to our routes. 12345678910111213141516171819// routes.jsimport React from 'react';import &#123; Router, Route &#125; from 'react-router';import App from './containers/App';import Posts from './containers/Posts';import AddPost from './containers/AddPost';const Routes = (props) =&gt; ( &lt;Router &#123;...props&#125;&gt; &lt;Route path=\"/\" component=&#123; App &#125;&gt; &lt;Route path=\"/posts\" component=&#123; Posts &#125; /&gt; &lt;Route path=\"/add-post\" component=&#123; AddPost &#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;);export default Routes; Here, we just added the /add-post route so that we can add a new post from that route. Hence, we passed the AddPost component to its component prop. Also, let’s modify the render method of our src/containers/Posts/index.js file so that it can iterate over objects instead of arrays (since Firebase doesn’t store arrays). 12345678910111213141516171819202122232425// src/containers/Posts/index.jsrender() &#123; let posts = this.props.posts; if (this.props.loading) &#123; return ( &lt;div&gt; Loading... &lt;/div&gt; ); &#125; return ( &lt;div className=\"Posts\"&gt; &#123; Object.keys(posts).map(function(key) &#123; return ( &lt;div key=&#123;key&#125;&gt; &#123; posts[key].title &#125; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; ); &#125; Now, if we go to localhost:3000/add-post, we can add a new post. After clicking on the submit button, the new post will appear immediately on the posts page. You can check my commit on Github. Implement votingNow, we need to allow users to vote on a post. For that, let’s modify the render method of our src/containers/App/index.js. 1234567891011121314// src/containers/App/index.jsrender() &#123; return ( &lt;div className=\"App\"&gt; &#123;this.props.children &amp;&amp; React.cloneElement(this.props.children, &#123; // https://github.com/ReactTraining/react-router/blob/v3/examples/passing-props-to-children/app.js#L56-L58 firebase: firebase.database(), posts: this.state.posts, loading: this.state.loading &#125;)&#125; &lt;/div&gt; );&#125; We changed the firebase prop from firebaseRef: firebase.database().ref(&#39;posts&#39;) to firebase: firebase.database() because we will be using Firebase’s set method to update our voting count. In this way, if we had more Firebase refs, it would be very easy for us to handle them by using only the firebase prop. Before proceeding with the voting, let’s modify the handleSubmit method in our src/containers/AddPost/index.js file a little bit: 1234567891011// src/containers/AddPost/index.jshandleSubmit = (e) =&gt; &#123; ... this.props.firebase.ref('posts').push(&#123; title: this.state.title, upvote: 0, downvote: 0 &#125;); ...&#125; We renamed our firebaseRef prop to firebase prop. So, we change the this.props.firebaseRef.push to this.props.firebase.ref(&#39;posts&#39;).push. Now, we need to modify our src/containers/Posts/index.js file to accomodate the voting. The render method should be modified to: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// src/containers/Posts/index.jsrender() &#123; let posts = this.props.posts; let _this = this; if (!posts) &#123; return false; &#125; if (this.props.loading) &#123; return ( &lt;div&gt; Loading... &lt;/div&gt; ); &#125; return ( &lt;div className=\"Posts\"&gt; &#123; Object.keys(posts).map(function(key) &#123; return ( &lt;div key=&#123;key&#125;&gt; &lt;div&gt;Title: &#123; posts[key].title &#125;&lt;/div&gt; &lt;div&gt;Upvotes: &#123; posts[key].upvote &#125;&lt;/div&gt; &lt;div&gt;Downvotes: &#123; posts[key].downvote &#125;&lt;/div&gt; &lt;div&gt; &lt;button onClick=&#123; _this.handleUpvote.bind(this, posts[key], key) &#125; type=\"button\" &gt; Upvote &lt;/button&gt; &lt;button onClick=&#123; _this.handleDownvote.bind(this, posts[key], key) &#125; type=\"button\" &gt; Downvote &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; );&#125; When the buttons are clicked, the upvote or downvote count will be incremented in our Firebase DB. To handle that logic, we create two more methods: handleUpvote() and handleDownvote(): 1234567891011121314151617// src/containers/Posts/index.jshandleUpvote = (post, key) =&gt; &#123; this.props.firebase.ref('posts/' + key).set(&#123; title: post.title, upvote: post.upvote + 1, downvote: post.downvote &#125;);&#125;handleDownvote = (post, key) =&gt; &#123; this.props.firebase.ref('posts/' + key).set(&#123; title: post.title, upvote: post.upvote, downvote: post.downvote + 1 &#125;);&#125; In these two methods, whenever a user clicks on either of the buttons, the respective count is incremented in the database and is instantly updated in the browser. If we open two tabs with localhost:3000/posts and click on the voting buttons of the posts, we will see each of the tabs get updated almost instantly. This is the magic of using a real-time database like Firebase. You can check my commit on Github. In the repository, I’ve added the /posts route to the IndexRoute of the application just to show the posts on localhost:3000 by default. You can check that commit on Github. ConclusionThe end result is admittedly a bit barebones, as we didn’t try to implement any design (although the demo has some basic styles added). We also didn’t add any authentication in order to reduce the complexity and the length of the tutorial, but obviously any real-world application would require it. Firebase is really useful for places where you don’t want to create and maintain a separate backend application or where you want real-time data without investing too much time developing your APIs. It plays really well with React, as you can hopefully see from the article.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"},{"name":"firebase","slug":"firebase","permalink":"http://nthung2112.github.io/tags/firebase/"}]},{"title":"Using MySQL with Node.js & the mysql JavaScript Client","slug":"Using-MySQL-with-Node-js-the-mysql-JavaScript-Client","date":"2017-07-23T09:47:48.000Z","updated":"2018-05-18T01:03:22.966Z","comments":true,"path":"2017/07/Using-MySQL-with-Node-js-the-mysql-JavaScript-Client.html","link":"","permalink":"http://nthung2112.github.io/2017/07/Using-MySQL-with-Node-js-the-mysql-JavaScript-Client.html","excerpt":"NoSQL databases are all the rage these days and probably the preferred back-end for Node.js applications. But you shouldn’t architect your next project based on what’s hip and trendy, rather the type of database to be used should depend on the project’s requirements. If your project involves dynamic table creation, real time inserts etc. then NoSQL is the way to go, but on the other hand, if your project deals with complex queries and transactions, then a SQL database makes much more sense. In this tutorial, we’ll have a look at getting started with the mysql module — a Node.js driver for MySQL, written in JavaScript. I’ll explain how to use the module to connect to a MySQL database, perform the usual CRUD operations, before examining stored procedures and escaping user input. This popular tutorial was updated on 11.07.2017. Changes include updating to ES6 syntax, addressing the fact that the node-mysql module was renamed, adding more beginner friendly instructions and adding a section on ORMs.","text":"NoSQL databases are all the rage these days and probably the preferred back-end for Node.js applications. But you shouldn’t architect your next project based on what’s hip and trendy, rather the type of database to be used should depend on the project’s requirements. If your project involves dynamic table creation, real time inserts etc. then NoSQL is the way to go, but on the other hand, if your project deals with complex queries and transactions, then a SQL database makes much more sense. In this tutorial, we’ll have a look at getting started with the mysql module — a Node.js driver for MySQL, written in JavaScript. I’ll explain how to use the module to connect to a MySQL database, perform the usual CRUD operations, before examining stored procedures and escaping user input. This popular tutorial was updated on 11.07.2017. Changes include updating to ES6 syntax, addressing the fact that the node-mysql module was renamed, adding more beginner friendly instructions and adding a section on ORMs. Quick Start: How to Use MySQL in NodeMaybe you’ve arrived here looking for a quick leg up. If you’re just after a way to get up and running with MySQL in Node in as little time as possible, we got you covered! Here’s how to use MySQL in Node in 5 easy steps: Create a new project: mkdir mysql-test &amp;&amp; cd mysql-test Create a package.json file: npm init –y Install the mysql module: npm install mysql –save Create an app.js file and copy in the snippet below. Run the file: node app.js. Observe a “Connected!” message. 12345678910111213//app.jsconst mysql = require(&apos;mysql&apos;);const connection = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;user&apos;, password: &apos;password&apos;, database: &apos;database name&apos;&#125;);connection.connect((err) =&gt; &#123; if (err) throw err; console.log(&apos;Connected!&apos;);&#125;); Installing the mysql ModuleNow let’s take a closer look at each of those steps. First of all we’re using the command line to create a new directory and navigate to it. Then we’re creating a package.json file using the command npm init –y. The -y flag means that npm will use only defaults and not prompt you for any options. This step also assumes that you have Node and npm installed on your system. If this is not the case, then check out this SitePoint article to find out how to do that: Install Multiple Versions of Node.js using nvm. After that, we’re installing the mysql module from npm and saving it as a project dependency. Project dependencies (as opposed to dev-dependencies) are those packages required for the application to run. You can read more about the differences between the two here. 123mkdir mysql-testcd mysql-testnpm install mysql -y If you need further help using npm, then be sure to check out this guide, or ask in our forums. Getting StartedBefore we get on to connecting to a database, it’s important that you have MySQL installed and configured on your machine. If this is not the case, please consult the installation instructions on their home page. The next thing we need to do is to create a database and a database table to work with. You can do this using agraphical interface, such as phpMyAdmin, or using the command line. For this article I’ll be using a database called sitepoint and a table called employees. Here’s a dump of the database, so that you can get up and running quickly, if you wish to follow along: 123456789101112CREATE TABLE employees ( id int(11) NOT NULL AUTO_INCREMENT, name varchar(50), location varchar(50), PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=5 ;INSERT INTO employees (id, name, location) VALUES(1, &apos;Jasmine&apos;, &apos;Australia&apos;),(2, &apos;Jay&apos;, &apos;India&apos;),(3, &apos;Jim&apos;, &apos;Germany&apos;),(4, &apos;Lesley&apos;, &apos;Scotland&apos;); Connecting to the DatabaseNow, let’s create a file called app.js in our mysql-test directory and see how to connect to MySQL from Node.js. 1234567891011121314151617181920212223// app.jsconst mysql = require(&apos;mysql&apos;);// First you need to create a connection to the dbconst con = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;user&apos;, password: &apos;password&apos;,&#125;);con.connect((err) =&gt; &#123; if(err)&#123; console.log(&apos;Error connecting to Db&apos;); return; &#125; console.log(&apos;Connection established&apos;);&#125;);con.end((err) =&gt; &#123; // The connection is terminated gracefully // Ensures all previously enqueued queries are still // before sending a COM_QUIT packet to the MySQL server.&#125;); Now open up a terminal and enter node app.js. Once the connection is successfully established you should be able to see the ‘Connection established’ message in the console. If something goes wrong (for example you enter the wrong password), a callback is fired, which is passed an instance of the JavaScript Error object (err). Try logging this to the console to see what additional useful information it contains. Using Grunt to Watch the Files for ChangesRunning node app.js by hand every time we make a change to our code is going to get a bit tedious, so let’s automate that. This part isn’t necessary to follow along with the rest of the tutorial, but will certainly save you some keystrokes. Let’s start off by installing a couple of packages: 1npm install --save-dev grunt grunt-contrib-watch grunt-execute Grunt is the well-know JavaScript task runner, grunt-contrib-watch runs a pre-defined task whenever a watched file changes, and grunt-execute can be used to run the node app.js command. Once these are installed, create a file called Gruntfile.js in the project root and add the following code. 1234567891011121314151617181920// Gruntfile.jsmodule.exports = (grunt) =&gt; &#123; grunt.initConfig(&#123; execute: &#123; target: &#123; src: [&apos;app.js&apos;] &#125; &#125;, watch: &#123; scripts: &#123; files: [&apos;app.js&apos;], tasks: [&apos;execute&apos;], &#125;, &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-watch&apos;); grunt.loadNpmTasks(&apos;grunt-execute&apos;);&#125;; Now run grunt watch and make a change to app.js. Grunt should detect the change and re-run the node app.js command. Executing QueriesReadingNow that you know how to establish a connection to MySQL from Node.js, let’s see how to execute SQL queries. We’ll start by specifying the database name (sitepoint) in the createConnection command. 123456const con = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;user&apos;, password: &apos;password&apos;, database: &apos;sitepoint&apos;&#125;); Once the connection is established we’ll use the connection variable to execute a query against the database table employees. 123456con.query(&apos;SELECT * FROM employees&apos;, (err,rows) =&gt; &#123; if(err) throw err; console.log(&apos;Data received from Db:\\n&apos;); console.log(rows);&#125;); When you run app.js (either using grunt-watch or by typing node app.js into your terminal), you should be able to see the data returned from database logged to the terminal. 1234[ &#123; id: 1, name: &apos;Jasmine&apos;, location: &apos;Australia&apos; &#125;, &#123; id: 2, name: &apos;Jay&apos;, location: &apos;India&apos; &#125;, &#123; id: 3, name: &apos;Jim&apos;, location: &apos;Germany&apos; &#125;, &#123; id: 4, name: &apos;Lesley&apos;, location: &apos;Scotland&apos; &#125; ] Data returned from the MySQL database can be parsed by simply lopping over the rows object. 123rows.forEach( (row) =&gt; &#123; console.log(`$&#123;row.name&#125; is in $&#123;row.location&#125;`); &#125;); CreatingYou can execute an insert query against a database, like so: 123456const employee = &#123; name: &apos;Winnie&apos;, location: &apos;Australia&apos; &#125;;con.query(&apos;INSERT INTO employees SET ?&apos;, employee, (err, res) =&gt; &#123; if(err) throw err; console.log(&apos;Last insert ID:&apos;, res.insertId);&#125;); Note how we can get the ID of the inserted record using the callback parameter. UpdatingSimilarly, when executing an update query, the number of rows affected can be retrieved using result.affectedRows: 123456789con.query( &apos;UPDATE employees SET location = ? Where ID = ?&apos;, [&apos;South Africa&apos;, 5], (err, result) =&gt; &#123; if (err) throw err; console.log(`Changed $&#123;result.changedRows&#125; row(s)`); &#125;); DestroyingSame thing goes for a delete query: 1234567con.query( &apos;DELETE FROM employees WHERE id = ?&apos;, [5], (err, result) =&gt; &#123; if (err) throw err; console.log(`Deleted $&#123;result.affectedRows&#125; row(s)`); &#125;); Advanced UseI’d like to finish off by looking at how the mysql module handles stored procedures and the escaping of user input. Stored ProceduresPut simply, a stored procedure is a procedure (written in, for example, SQL) stored in a database which can be called by the database engine and connected programming languages. If you are in need of a refresher, then please check out this excellent article. Let’s create a stored procedure for our sitepoint database which fetches all the employee details. We’ll call it sp_getall . To do this, you’ll need some kind of interface to the database. I’m using phpMyAdmin. Run the following query on the sitepoint database: 123456DELIMITER $$CREATE DEFINER=`root`@`localhost` PROCEDURE `sp_getall`()BEGIN SELECT id, name, location FROM employees;END This will create and store the procedure in the information_schema database in the ROUTINES table. Next, establish a connection and use the connection object to call the stored procedure as shown: 123456con.query(&apos;CALL sp_getall()&apos;,function(err, rows)&#123; if (err) throw err; console.log(&apos;Data received from Db:\\n&apos;); console.log(rows);&#125;); Save the changes and run the file. Once executed you should be able to view the data returned from the database. 123456789101112[ [ &#123; id: 1, name: &apos;Jasmine&apos;, location: &apos;Australia&apos; &#125;, &#123; id: 2, name: &apos;Jay&apos;, location: &apos;India&apos; &#125;, &#123; id: 3, name: &apos;Jim&apos;, location: &apos;Germany&apos; &#125;, &#123; id: 4, name: &apos;Lesley&apos;, location: &apos;Scotland&apos; &#125; ], &#123; fieldCount: 0, affectedRows: 0, insertId: 0, serverStatus: 34, warningCount: 0, message: &apos;&apos;, protocol41: true, changedRows: 0 &#125; ] Along with the data, it returns some additional information, such as the affected number of rows, insertId etc. You need to iterate over the 0th index of the returned data to get employee details separated from the rest of the information. 123rows[0].forEach( (row) =&gt; &#123; console.log(`$&#123;row.name&#125; is in $&#123;row.location&#125;`);&#125;); Now lets consider a stored procedure which requires an input parameter. 12345678DELIMITER $$CREATE DEFINER=`root`@`localhost` PROCEDURE `sp_get_employee_detail`( in employee_id int)BEGIN SELECT name, location FROM employees where id = employee_id;END Now we can pass the input parameter while making a call to the stored procedure: 123456con.query(&apos;CALL sp_get_employee_detail(1)&apos;, (err, rows) =&gt; &#123; if(err) throw err; console.log(&apos;Data received from Db:\\n&apos;); console.log(rows[0]);&#125;); Most of the time when we try to insert a record into the database, we need the last inserted ID to be returned as an out parameter. Consider the following insert stored procedure with an out parameter: 123456789101112DELIMITER $$CREATE DEFINER=`root`@`localhost` PROCEDURE `sp_insert_employee`( out employee_id int, in employee_name varchar(25), in employee_location varchar(25))BEGIN insert into employees(name, location) values(employee_name, employee_location); set employee_id = LAST_INSERT_ID();END To make a procedure call with an out parameter, we first need to enable multiple calls while creating the connection. So, modify the connection by setting the multiple statement execution to true. 1234567const con = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;user&apos;, password: &apos;password&apos;, database: &apos;sitepoint&apos;, multipleStatements: true&#125;); Next when making a call to the procedure, set an out parameter and pass it in. 123456789con.query( &quot;SET @employee_id = 0; CALL sp_insert_employee(@employee_id, &apos;Ron&apos;, &apos;USA&apos;); SELECT @employee_id&quot;, (err, rows) =&gt; &#123; if (err) throw err; console.log(&apos;Data received from Db:\\n&apos;); console.log(rows); &#125;); As seen in the above code, we have set an out parameter @employee_id and passed it while making a call to the stored procedure. Once the call has been made we need to select the out parameter to access the returned ID. Run app.js. On successful execution you should be able to see the selected out parameter along with various other information. rows[2] should give you access to the selected out parameter. 1[ &#123; &apos;@employee_id&apos;: 6 &#125; ] Escaping User InputIn order to avoid SQL Injection attacks, you should always escape any data from user land before using it inside a SQL query. Let’s demonstrate why: 123456789const userLandVariable = &apos;4 &apos;;con.query( `SELECT * FROM employees WHERE id = $&#123;userLandVariable&#125;`, (err, rows) =&gt; &#123; if(err) throw err; console.log(rows); &#125;); This seems harmless enough and even returns the correct result: 1&#123; id: 4, name: &apos;Lesley&apos;, location: &apos;Scotland&apos; &#125; However, if we change the userLandVariable to this: 1const userLandVariable = &apos;4 OR 1=1&apos;; we suddenly have access to the entire data set. If we then change it to this: 1const userLandVariable = &apos;4; DROP TABLE employees&apos;; then we’re in proper trouble! The good news is that help is at hand. You just have to use the mysql.escape method: 1234con.query( `SELECT * FROM employees WHERE id = $&#123;mysql.escape(userLandVariable)&#125;`, function(err, rows)&#123; ... &#125;); Or by using a question mark placeholder, as we did in the examples at the beginning of the article: 12345 con.query( &apos;SELECT * FROM employees WHERE id = ?&apos;, [userLandVariable], (err, rows) =&gt; &#123; ... &#125;); Why Not Just USE an ORM?As you may have noticed, a couple of people in the comments are suggesting using an ORM. Before we get into the pros and cons of this approach, let’s take a second to look at what ORMs are. The following is taken from an answer on Stack Overflow: Object-Relational Mapping (ORM) is a technique that lets you query and manipulate data from a database using an object-oriented paradigm. When talking about ORM, most people are referring to a library that implements the Object-Relational Mapping technique, hence the phrase “an ORM”. So basically, this approach means you write your database logic in the domain-specific language of the ORM, as opposed to the vanilla approach we have been taking so far. Here’s a contrived example using Sequelize: 123Employee.findAll().then(employees =&gt; &#123; console.log(employees);&#125;); Contrasted with: 123456con.query(&apos;SELECT * FROM employees&apos;, (err,rows) =&gt; &#123; if(err) throw err; console.log(&apos;Data received from Db:\\n&apos;); console.log(rows);&#125;); Whether or not using an ORM makes sense for you, will depend very much on what you are working on and with whom. On the one hand, ORMS tend to make developers more productive, in part by abstracting away a large part of the SQL so that not everyone on the team needs to know how to write super efficient database specific queries. It is also easy to move to different database software, because you are developing to an abstraction. On the other hand however, it is possible to write some really messy and inefficient SQL as a result of not understanding how the ORM does what it does. Performance is also an issue in that it’s much easier to optimize queries that don’t have to go through the ORM. Whichever path you take is up to you, but if this is a decision you’re in the process of making, check out this Stack Overflow thread: Why should you use an ORM? as well as this post on SitePoint: 3 JavaScript ORMs You Might Not Know. ConclusionIn this tutorial, we’ve only scratched the surface of what the mysql client offers. For more detailed information, I would recommend reading the official documentation. There are other options too, such as node-mysql2 and node-mysql-libmysqlclient.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"http://nthung2112.github.io/tags/nodejs/"},{"name":"mysql","slug":"mysql","permalink":"http://nthung2112.github.io/tags/mysql/"}]},{"title":"10 React mini-patterns","slug":"10-react-mini-patterns","date":"2017-07-16T14:50:48.000Z","updated":"2017-08-20T16:43:56.760Z","comments":true,"path":"2017/07/10-react-mini-patterns.html","link":"","permalink":"http://nthung2112.github.io/2017/07/10-react-mini-patterns.html","excerpt":"Over the last few years, I’ve worked on a handful of decent-sized React projects, and many, many pint-sized ones. Throughout this magical journey, a number of patterns have come up that I find myself repeating again and again. Because that’s what patterns are. These are the sorts of things I would like to have heard about on day one. So if today is your day one with React, you’re in luck. Or maybe you’re not. There’s only one way to find out… It’s a long one, but it’s a listicle so you can skip the boring ones (3, 6, 8, 10).","text":"Over the last few years, I’ve worked on a handful of decent-sized React projects, and many, many pint-sized ones. Throughout this magical journey, a number of patterns have come up that I find myself repeating again and again. Because that’s what patterns are. These are the sorts of things I would like to have heard about on day one. So if today is your day one with React, you’re in luck. Or maybe you’re not. There’s only one way to find out… It’s a long one, but it’s a listicle so you can skip the boring ones (3, 6, 8, 10). #1 Sending data down and upThe one thing I’d recommend to everyone new to React is to get your head around the pattern of passing information down (as objects, strings, etc.) and passing methods down to allow child components to pass information back up. Like sending down a packet of chips and a walkie talkie to miners trapped underground. How about a picture? The below thing is the simplest form of this pattern. Worth a thousand words? Parent on the left, child on the right. You can think of the two props that connect these components as allowing information to flow in either direction between the two. The prop called items is passing data down into the child component. The prop called deleteItem is giving the child component a way to send some information back up into the parent (“hey, delete this item”). That’s not really a pattern. The rest are patterns. I promise. #2 Fixing HTML’s inputsOne of the great things about React, and web components in general, is that you get to iron out the kinks if something in html doesn’t work the way you want. If you think about the different elements that allow for user input (do it), you will soon see that the naming of these elements is nonsensical, bordering on reckless. If I’m building a site that will have a lot of user inputs, one of the first things I do is fix this. It’s not purely cosmetic though; there are more improvements to be had: Inputs should return a value via an onChange method, not a JavaScript Event instance, shouldn’t they? You can go a step further and ensure that the data type returned in onChange matches the type passed in. If the typeof props.value is number, then convert e.target.value back to a number before sending the data out again. A set of radio buttons is functionally the same thing as a &lt;select&gt;, right? It’s messed up to treat them in a completely different manner when the only difference is the UI. Maybe for your app it makes sense to have a single &lt;PickOneFromMany /&gt; component and pass either ui=&quot;radio&quot; or ui=&quot;dropDown&quot;. The point is not to do it like I do it. The point is to make them your own — you don’t need to keep working with the somewhat ass-about nature of HTML’s user input elements. #3 Binding labels to inputs with unique IDsOn the topic of inputs… if you care about your users, you’ll bind your &lt;label&gt; elements to your &lt;input&gt;s via an id/for combo. But you don’t want to think of some clever and unique id for every input you define, who’s got time for that? I don’t know about you but I’ve got goat videos to watch. (Frequent-flyer tip: if you have a screaming child on your flight, close your eyes and pretend you’re watching a video on YouTube of goats that sound like humans. Annoying becomes hilarious.) Back to it. You could generate a random ID for each input/label pair, but then your client-rendered HTML won’t match your server-rendered HTML. Checksum error! That’s no good. So, instead you can create a little module that gives an incrementing ID, and use that in an Input component like so: Obviously it makes more sense when the input isn’t inside the label. If getNextId() simply increments a number every time it’s called, then when rendering on the server, the number would keep going up and up, eventually reaching infinity. So you’ll want to reset the number each time you render the app (for each network request). You can do this at the entry point to your app, with a simple resetId() or whatever name you think is best. With all that taken into account, your super-fancy module might look something like this: #4 Controlling CSS with propsWhen you want to apply different CSS in different instances (e.g. ‘primary’ and ‘secondary’ buttons) you can pass in props to control which CSS to apply. This seems super simple on the surface, but let me assure you there are a lot of wrong ways to do this (I’ve tried them all!). There are — I reckon — three distinct ways in which you can control the CSS applied to a component. Using themesFor grouping a number of CSS declarations together, you can use the idea of ‘themes’, for example primary or secondary button: &lt;Button theme=&quot;secondary&quot;&gt;Hello&lt;/Button&gt; Do your best to only require one theme per component. Using flagsMaybe some of your buttons have rounded corners, but this doesn’t correspond directly with the themes you have defined. In this case you can either sit your designer down and have the consistency talk, or create a boolean prop which might look a little something like this: &lt;Button theme=&quot;secondary&quot; rounded&gt;Hello&lt;/Button&gt; Just like HTML’s binary attributes, you don’t need to do rounded={true}. Setting valuesIn some cases you might want to pass in the value of a CSS property directly (in the component you would set it as an inline style). &lt;Icon width=&quot;25&quot; height=&quot;25&quot; type=&quot;search&quot; /&gt; An exampleImagine you’re creating a link component. You go through your site’s designs and work out that there are three distinct themes, and that sometimes they have an underline, sometimes they don’t. Here’s how I would design that component: And the CSS… You may have noticed the awkward double negative for link--no-underline. Story time: I used to think writing fewer lines of CSS was the goal, but it’s not. I’d rather have some double-negatives and multi-selector rulesets if it means the styles are applied in a nice layered way. I’m sure I’ve said it before but the hardest thing about scaling a website is the CSS. JavaScript is easy, but with CSS you pay for your sins — once you’ve started a mess, it’s not easy to back out of. True fact: fighting CSS specificity is the number one cause of death among web developers. If you’re on a big computer, check out the CSS for the little notification icon in medium’s top nav. If you’re not, or you’re lazy, just guess how many CSS rules are combined to make this round circle with a number in it? Twenty three rules. That’s not including the styles inherited from eleven other rules. The line-height alone is overridden nine times. If line-height was a cat it would be dead by now. This cannot be pleasant to maintain. With React we can do better. We can thoughtfully design which classes are applied to our components. We can remove global resets and move it all inside our Button.scss. We can remove all reliance on specificity and ordering of files. Side note: I dream of a day when we will be able to tell browsers that we don’t want their opinion about style at all. ::user-agent-styles: none-whatsoever; — make it happen, vendors. [Edit: a clever chap in the comments has pointed out that all: unset may cure what ails me.] #5 The switching componentA switching component is a component that renders one of many components. This may be a &lt;Page&gt; component that displays one of many pages. Or tabs in a tab set, or different modals in a modal component. I used to do this with switch statements, then progressed to actually passing in the component I wanted rendered. Then moved on to exporting references to the components from the component itself (as named exports, then as properties on the component). All terrible ideas. The potentially-terrible approach that I have settled on is to use an object to map prop values to components. The keys of the PAGES object can be used in the prop types to catch dev-time errors. Then of course we would use this like &lt;Page page=&quot;home&quot; /&gt;. If you replace the keys home, about and user with /, /about, and /user, you’ve got yourself half a router. (Future post idea: removing react-router.) #6 Reaching into a componentIf you’re looking for an easy way to please your users, add autofocus to the input that they are most likely to type into when coming to a page. It really is that easy. Perhaps you have a sign-in form and — being the UX champ that you are — you want to put that little blinking cursor in the ‘user name’ field. But oh no, the form shows in a modal when the user clicks ‘sign in’, and the autofocus attribute only applies to page load. Whatever will you do! You’ll programmatically focus the element, that’s what. Here you may be tempted to give the input an id and type document.getElementById(&#39;user-name-input&#39;).focus(). This works, but is not The Correct Way. The fewer things you have in your app that rely on two strings matching, the better. Luckily, there is a very easy way to do this ‘properly’: Boom, an input component with a focus() method that focuses the HTML element. In the parent component, we can get a reference to the Input component and call its focus() method. Note that when you use ref on a component, it’s a reference to the component (not the underlying element), so you have access to its methods. #7 Almost-componentsLet’s say you’re building a component that lets you search for people. As you type, you see a list of names and photos of potential matches. Something like this. (I’m searching for political satirists because I, like everyone, am super interested in what other people think about politics.) When designing this component, you may think to yourself: is each item in that list it’s own SearchSuggestion component? It’s really only a few lines of HTML and CSS, so maybe not? But I was once told ‘if in doubt, create another component’. Oh my, this is quite the dilly of a pickle, isn’t it? If I was making this, I would not have a separate component. Instead, just a renderSearchSuggestion method that returned the appropriate DOM for each entry. I can then generate the results like: If things get more complex or you want to use this component elsewhere, you should be able to copy/paste the code out into a new component. Don’t prematurely componentize. Components aren’t like teaspoons; you can have too many. What I am not saying: “take something that you think should be a component, and make it part of the parent component.” What I am saying: “take something that you don’t think should be a component, and make it a bit more like its own component (if it can be).” #8 Components for formatting textWhen I first started with React I thought of components as big things, a way of grouping structural chunks of DOM. But components work just as well as a way to apply formatting. Here’s a &lt;Price&gt; component that takes a number and returns a pretty string, with or without decimals and a ‘$’ sign. As you can see I’m using the powerful Intl string formatting library, here’s a link to their website. I should point out (before some punk does) that this is not a saving in lines of code. You could just as easily use a function to do this. (Of course components are just functions with different shaped brackets.) It’s less code, but to my eye, not quite as nice: Note that I’m not checking that I got a valid number in any of the above. That’s because … #9 The store is the component’s servantI have probably written this thousands of times: if (props.user.signInStatus === SIGN_IN_STATUSES.SIGNED_IN)... (I’ve been told that I exaggerate, like, a gazillion times.) Quite recently I have decided that if I’m doing a check like this, I’m doing it wrong. I want to just ask “is the user signed in?”, not “is the sign in status of the user equal to signed in?” My components have enough going on in their lives, they shouldn’t have to worry their pretty little heads over such matters. Nor should they have to worry that a price isn’t being sent as a number, or a boolean as the word ‘true’. For you see, if the data in your store is designed to match your components, your components will be much simpler. And I’ve said it before, complexity is where the bugs hide. The less complexity you have in your components, the lower the chance of bugs. But the complexity has to go somewhere, doesn’t it? My suggestion is this: Work out the general structure of your components and the data they will require Design your store to support those requirements Do whatever you need to do to your incoming data to make it fit into the store. For this last point, I recommend a single module that does all the massaging of incoming data (oh la la). Renaming props, casting strings to numbers, objects into arrays, date strings to date objects, whatever. Do it all in the one place, and unit test the crap out of it. If you’re rockin’ a react/redux setup, you might then do something like this in an action creator that fetches search results: Your components will thank you for it. #10 Importing components without relative pathsWouldn’t it be sweet if instead of doing this: **import** Button **from** '../../../../Button/Button.jsx'; **import** Icon **from** '../../../../Icon/Icon.jsx'; **import** Footer **from** '../../Footer/Footer.jsx'; You could just do this: 1import &#123;Button, Icon, Footer&#125; from &apos;Components&apos;; Well in theory you can: Create a single index.js somewhere that exports references each of your components Use Webpack’s resolve.alias to redirect Components to that index file I hadn’t done this before, and planned to convert one of my existing apps for this post (then lie and tell you I totes do it all the time). But as I wrote the code I came to realise that this is a bad idea, for three reasons: It seems to be broken in Webpack 2. It’s an eslint error because Components won’t be in node_modules. If you use a good IDE, it will know things about your components. You will get clever warnings about not supplying required props, the ability to cmd/ctrl+click to open that component’s file. Things of that nature.If you do the above, your IDE will no longer know where to find that component and you’ll lose those smarts. Thanks, WebStorm. Edit: matthew hsiung has a solution for the eslint and WebStorm issues in this comment. Wrap upThat’s the lot of them. I’m quite sure I’ll look at this in a year and wince. Perhaps you’ll do it today. Perhaps you’ll share something that has served you well. Oh and I’ve decided I don’t care if you click the little green heart or not. I WILL NOT BE DEFINED BY AN INTERNET METRIC.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://nthung2112.github.io/tags/react/"}]},{"title":"Tìm hiểu về async và await đơn giản","slug":"Javascript-Tim-hieu-ve-async-va-await-don-gian","date":"2017-01-10T13:03:38.000Z","updated":"2017-08-20T14:51:30.727Z","comments":true,"path":"2017/01/Javascript-Tim-hieu-ve-async-va-await-don-gian.html","link":"","permalink":"http://nthung2112.github.io/2017/01/Javascript-Tim-hieu-ve-async-va-await-don-gian.html","excerpt":"1. Giới thiệuVới các đặc tả JavaScript cũ, ta phải sử dụng các hàm phản hồi để xử lý các thao tác bất đồng bộ. Tuy nhiên việc này dẫn tới tình trạng callback hell khi ta có nhiều thao tác bất đồng bộ phải chờ nhau thực hiện. Call hell làm cho mã nguồn của ta rất rối và khó bảo trì. 12345678910111213141516function wait(ms, cb) &#123; setTimeout(cb, ms)&#125;function main() &#123; console.log('sắp rồi...') wait(2007, () =&gt; &#123; console.log('chờ tí...') wait(2012, () =&gt; &#123; console.log('thêm chút nữa thôi...') wait(2016, () =&gt; &#123; console.log('xong rồi đấy!') &#125;) &#125;) &#125;)&#125; Vì vậy, với phiên bản ES6 (ES 2016), Promise đã được đưa vào mặc định nhằm giải quyết tình trạng callback hell. Với Promise, mã nguồn của ta sẽ trông gần giống với phong cách đồng bộ, kết quả là trông dễ theo dõi và bảo trì hơn. Tuy nhiên sử dụng Promise lại làm phát sinh vấn đề “khá” tương tự là Promise hell ( lol! JavaScript Heo! ).","text":"1. Giới thiệuVới các đặc tả JavaScript cũ, ta phải sử dụng các hàm phản hồi để xử lý các thao tác bất đồng bộ. Tuy nhiên việc này dẫn tới tình trạng callback hell khi ta có nhiều thao tác bất đồng bộ phải chờ nhau thực hiện. Call hell làm cho mã nguồn của ta rất rối và khó bảo trì. 12345678910111213141516function wait(ms, cb) &#123; setTimeout(cb, ms)&#125;function main() &#123; console.log('sắp rồi...') wait(2007, () =&gt; &#123; console.log('chờ tí...') wait(2012, () =&gt; &#123; console.log('thêm chút nữa thôi...') wait(2016, () =&gt; &#123; console.log('xong rồi đấy!') &#125;) &#125;) &#125;)&#125; Vì vậy, với phiên bản ES6 (ES 2016), Promise đã được đưa vào mặc định nhằm giải quyết tình trạng callback hell. Với Promise, mã nguồn của ta sẽ trông gần giống với phong cách đồng bộ, kết quả là trông dễ theo dõi và bảo trì hơn. Tuy nhiên sử dụng Promise lại làm phát sinh vấn đề “khá” tương tự là Promise hell ( lol! JavaScript Heo! ). 12345678910111213141516171819function wait(ms) &#123; return new Promise(r =&gt; setTimeout(r, ms)) &#125;function main() &#123; console.log('sắp rồi...') wait(2007).then(() =&gt; &#123; console.log('chờ tí...') return wait(2007) &#125;).then(() =&gt; &#123; console.log('thêm chút nữa thôi...') return wait(2012) &#125;).then(() =&gt; &#123; console.log('thêm chút nữa thôi...') return wait(2016) &#125;).then(() =&gt; &#123; console.log('xong rồi đấy!') &#125;)&#125; Để giải quyết vấn đề đó, ở phiên bản ES7 (ES 2017), 1 khái niệm với 2 từ khóa mới được đưa vào là hàm async (async / await). Hàm async cho phép ta viết các thao tác bất đồng bộ với phong cách của các mã đồng bộ. Bằng cách viết như vậy, mã nguồn của ta trông sẽ sáng sủa, dễ đọc hơn và “dễ hiểu hơn”. 12345678910111213function wait(ms) &#123; return new Promise(r =&gt; setTimeout(r, ms)) &#125;async function main() &#123; console.log('sắp rồi...') await wait(2007) console.log('chờ tí...') await wait(2012) console.log('thêm chút nữa thôi...') await wait(2016) console.log('xong rồi đấy!')&#125; 2. Cách sử dụngĐể sử dụng hàm async, ta cần khai báo từ khóa async ngay trước từ khóa định nghĩa hàm. Tức là, với hàm định nghĩa với từ khóa function ta phải khai báo ngay trước function, với hàm mũi tên (arrow function) ta phải khai báo trước tập tham số đầu vào, với phương thức của lớp Class thì ta phải khai báo ngay trước tên hàm. 1234567891011121314151617181920// regular functionasync function functionName() &#123; let ret = await new Google().search('JavaScript')&#125;// arrow functionlet arr = ['JS', 'node.js'].map(async val =&gt; &#123; return await new Google().search(val)&#125;)// Classclass Google &#123; constructor() &#123; this.apiKey = '...' &#125; async search(keyword) &#123; return await this.searchApi(keyword) &#125;&#125; Với từ khóa async này, ta có thể đợi các Promise (thao tác bất đồng bộ) xử lý trong hàm đó mà không tạm dùng luồng chính bằng từ khóa await như ví dụ trên. Kết quả trả ra của hàm async luôn là một Promise dù bạn có gọi await - có xử lý bất đồng bộ hay không. Promise này sẽ ở trạng thái thành công với kết quả được trả ra với từ khóa return của hàm async, hoặc trạng thái thất bại với kết quả được đẩy qua từ khóa throw trong hàm async. Như vậy, bản chất của hàm async chính là Promise. Nếu bạn chưa tìm hiểu về Promise thì nên đọc trước ở bài viết này. Với Promise, ta có thể xử lý ngoại lệ với catch khá đơn giản. Tuy nhiên cũng không dễ dàng theo dõi và dễ đọc. Nhưng với hàm async, việc này cực kì đơn giản bằng từ khóa try catch hệt như các thao tác đồng bộ. 1234567891011121314151617181920212223242526272829//// test.js//function wait(ms) &#123; return new Promise(r =&gt; setTimeout(r, ms)) &#125;async function runner() &#123; console.log('sắp rồi...') await wait(2007) console.log('chờ tí...') await wait(2012) console.log('thêm chút nữa thôi...') await wait(2016) throw new Error(2016)&#125;async function main() &#123; try &#123; await runner() console.log('xong rồi đấy!') &#125; catch (e) &#123; console.log(`có vấn đề tại $&#123; e &#125;`) &#125;&#125;// Node v7// `$ node --harmony-async-await test.js`// Console: ... có vấn đề tại 2016 Ngon! Rõ ràng là mã nguồn sử dụng async/await trông đơn giản, dễ theo dõi, “dễ hiểu” hơn và giải quyết được tình trạng callback - promise hell. Tuy nhiên, việc sử dụng nó cũng không phải lúc nào cũng đơn giản. Ta cùng nhau xem một số trường hợp dưới đây. 3. Lưu ý3.1. Quên khai báo từ khóa asyncĐương nhiên rồi, không khai báo từ khóa này thì ta không có hàm async được, không sử dụng await được rồi. Thường bạn sẽ nghĩ đơn giản là không thể nào quên được từ khóa này, nhưng tôi nghĩ đôi lúc có thể đấy. Ví dụ như với trường hợp khai báo một hàm trong một hàm async. Hàm khai báo trong hàm async cũng bắt buộc phải được khai báo với từ khóa async nếu như bạn muốn sử dụng như một hàm async. 123456async function main() &#123; await wait(1000) let arr = [100, 300, 500].map(val =&gt; wait(val)) arr.forEach(func =&gt; await func) // ??? error&#125; 3.2. Nhập nhằng từ khóa awaitCó 2 tình huống điển hình cho trường hợp này là: Quên khai báo khi cần đợi một xử lý bất đồng bộ Có gì đáng sợ không? Câu trả lời là có đấy! Nếu bạn không khai báo từ khóa này thì kết quả bạn nhận được sẽ là một Promise chứ không phải là kết quả thực thi của xử lý bất đồng bộ nhé. 123456789async function now() &#123; return Date.now()&#125;async function main() &#123; let t = now() console.log(t) // ??? `t` is a `Promise` instance&#125; Khai báo “thừa” trước một xử lý đồng bộ Nếu mà sợ quên thì cứ khai báo bừa đi, đâu có sao? Ừ không sao đâu ngoại trừ 2 vấn đề là không biết cái nào là đồng bộ, cái nào là bất đồng bộ nữa, và hiệu quả đi xuống đấy. Mỗi khi bạn khai báo await thì mặc nhiên sau từ khóa đó là một Promise, nếu không phải là một Promise thì nó sẽ được gói lại vào Promise và được trả ra ngay với phương thức Promise.resolve(value). Rảnh quá ha, muốn lấy 1 + 0 = 1 mà phải đi đường vòng là tính tổng, rồi nhét vào Promise, rồi lại moi ra để sử dụng. 12345678910111213141516171819async function main() &#123; // run with await console.log('run with await') let i = 1000000 console.time('await') while(i-- &gt; 0) &#123; let t = await (1 + 0) &#125; console.timeEnd('await') // run without await console.log('run without await') i = 1000000 console.time('normal') while(i-- &gt; 0) &#123; let t = 1 + 0 &#125; console.timeEnd('normal')&#125; 3.3. Quên xử lý lỗiCũng như với việc quên catch lỗi khi sử dụng Promise, việc quên try catch để bắt lỗi với hàm async cũng có thể xảy ra. Nếu bạn quên không bắt lỗi, thì khi đoạn mã bất đồng của bạn xảy ra lỗi có thể làm chương trình của bạn bị dừng lại. 1234567891011121314function wait(ms) &#123; if (ms &gt; 2015) throw new Error(ms) return new Promise(r =&gt; setTimeout(r, ms))&#125;async function main() &#123; console.log('sắp rồi...') await wait(2007) console.log('chờ tí...') await wait(2012) console.log('thêm chút nữa thôi...') await wait(2016) console.log('xong rồi đấy!')&#125; 3.4. Mất tính song songCái này có vẻ là căng nhất, bạn cứ khai báo await tuần tự đi rồi chương trình của bạn sẽ chậm như con rùa. hahaaa. Vì mỗi lần khai báo await như vậy là bạn cần phải chờ cho xử lý của await kết thúc. Kết quả là bạn có 1 con rùa chạy tuần tự qua từng nấc thang. 12345678910function wait(ms) &#123; return new Promise(r =&gt; setTimeout(r, ms))&#125;async function main() &#123; console.time('wait3s') await wait(1000) await wait(2000) console.timeEnd('wait3s')&#125; Với đoạn mã trên bạn sẽ mất tổng cộng là 1 + 2 = 3s để thực thi. Vì bạn phải chờ từng hàm wait một. Vậy làm sao để tránh được tình trạng trên? Câu trả lời là cứ cho xử lý bất đồng bộ chạy trước đi rồi lấy kết quả sau. Vì Promise có thể cho phép ta lấy kết quả bất cứ khi nào mà nó ở trạng thái cuối cùng, nên ta có thể chạy nó trước rồi lấy sau cũng không sao cả. 123456789101112function wait(ms) &#123; return new Promise(r =&gt; setTimeout(r, ms))&#125;async function main() &#123; console.time('wait2s') let w1 = wait(1000) let w2 = wait(2000) await w1 await w2 console.timeEnd('wait2s')&#125; Như đoạn mã này, ta chỉ mất 2s để thực hiện vì đoạn wait của ta được thực thi song song. Ngoài cách await từng Promise như trên ta có thể sử dụng Promise.all để song song hóa các Promise. 123456789function wait(ms) &#123; return new Promise(r =&gt; setTimeout(r, ms))&#125;async function main() &#123; console.time('wait2s') await Promise.all([wait(1000), wait(2000)]) console.timeEnd('wait2s')&#125; Lúc này, có thể bạn đang nghĩ Promise.all và await từng Promise là như nhau, nhưng nó khác nhau chút đấy. Promise.all chỉ ở trạng thái thành công khi mà tất cả các Promise được truyền vào xử lý thành công, còn nó sẽ ở trạng thái lỗi khi một trong các Promise truyền vào bị lỗi. Như vậy, nếu bạn muốn bỏ qua các Promise lỗi thì bạn không thể sử dụng Promise.all được đâu. Lúc đó bắt buộc bạn phải sử dụng await kèm với try catch cho từng Promise của bạn. 12345678910111213141516171819202122232425function wait(ms) &#123; if (ms &gt; 2000) throw new Error(ms) return new Promise(r =&gt; setTimeout(r, ms))&#125;async function main() &#123; const dur = [1000, 2000, 3000, 4000] let all = dur.map(ms =&gt; wait(ms)) try &#123; await Promise.all(all) console.log('Promise.all - done') &#125; catch (e) &#123; console.error('Promise.all:', e) &#125; let each = dur.map(ms =&gt; wait(ms)) each.forEach(async (func, index) =&gt; &#123; try &#123; await func console.log('each - done:', dur[index]) &#125; catch (e) &#123; console.error('each:', e) &#125; &#125;)&#125; 4. Nền tảng/ trình duyệt hỗ trợ Thời điểm này (2016/10), các nền tảng và trình duyệt sau đã hỗ trợ hàm async. Node.js v7.0 với cờ --harmony-async-await Chrome v5.55 Microsoft Edge v21.10547 Nếu bạn muốn chạy ở các nền tảng/ trình duyệt chưa hỗ trợ thì có thể dùng babel để chuyển đổi: Babel async-2-generator plugin 5. Kết luận Bản chất của hàm async chính là Promise, vì vậy để sử dụng được nó ta cần phải sử dụng Promise cho việc xử lý các thao tác bất đồng bộ. Bạn không thể nào sài await để đợi các hàm có sử dụng hàm phản hồi (callback) được, mà bắt buộc phải gắn nó với một Promise trước khi sử dụng await. Mặc dù hàm async có cú pháp rất rõ ràng, ta cũng cần phải lưu ý tránh khai báo thừa thiếu các từ khóa gây lỗi, gây hiểu lầm về lô-gíc chương trình. Và đặc biệt lưu ý tới khả năng làm mất đi tính song song của chương trình. Với sự tiện dụng của hàm async, ta nên cố gắng sử dụng nó ngay từ bây giờ để giảm thiểu việc bảo trì sau này. Với các nền tảng/ trình duyệt chưa hỗ trợ thì ta có thể chuyển đổi bằng babel. Hiện tại Node v7 vẫn đang sử dụng Chrome v5.54 nên muốn sử dụng được async/await, ta buộc phải chạy với cờ --harmony-async-await và hiệu năng, bộ nhớ được sử dụng vẫn chưa hiệu quả, không khuyến khích cho các sản phẩm thực tế. Tuy nhiên, rất có thể Node v8 sẽ sử dụng phiên bản Chrome v5.55 và cho phép ta thực hiện mặc định các hàm async. async chúc các bạn await vui vẻ!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://nthung2112.github.io/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"async","slug":"async","permalink":"http://nthung2112.github.io/tags/async/"},{"name":"await","slug":"await","permalink":"http://nthung2112.github.io/tags/await/"}]},{"title":"Bất ngờ về mảng trong javascript","slug":"Javascript-Bat-ngo-ve-mang-trong-javascript","date":"2017-01-10T13:02:14.000Z","updated":"2017-08-20T14:51:37.207Z","comments":true,"path":"2017/01/Javascript-Bat-ngo-ve-mang-trong-javascript.html","link":"","permalink":"http://nthung2112.github.io/2017/01/Javascript-Bat-ngo-ve-mang-trong-javascript.html","excerpt":"Từng làm việc với một vài ngôn ngữ lập trình (Java, C, C++, C#, Objective-C, PHP), mỗi ngôn ngữ đều có cái hay riêng. Nhưng khi tiếp xúc với JavaScript (JS) lại tự dưng thấy yêu nó, yêu cái vẻ sexy và bất ngờ của nó. Ví như mảng trong JS rất đặc biệt và bất ngờ. Trong bài này sẽ viết lại một số điểm có thể là bất ngờ với một số người như mình. 1. Bạn lấy độ dài của mảng thế nào?Hôm qua ngồi code lúc lấy độ dài mảng bằng thuộc tính length mới thấy khác biệt với phần tử lấy được, làm mình hơi ngạc nhiên một chút. Ngồi đọc lại tài liệu JS, mới thấy dường như nó không có thuộc tính lưu trữ số lượng phần tử hiện hữu (khác undefined) trong nó thì phải? Hoặc ít nhất là mình chưa rõ. Có cao thủ nào chỉ giáo cho thì tốt. Các bạn có thể thử đoạn mã sau thì sẽ thấy rằng thuộc tính length của mảng sẽ bằng tổng của index lớn nhất của mảng với 1. 12345var arr = []arr[10] = 0arr[20] = 'index 20'arr['js'] = 'JavaScript'console.log(arr.length)","text":"Từng làm việc với một vài ngôn ngữ lập trình (Java, C, C++, C#, Objective-C, PHP), mỗi ngôn ngữ đều có cái hay riêng. Nhưng khi tiếp xúc với JavaScript (JS) lại tự dưng thấy yêu nó, yêu cái vẻ sexy và bất ngờ của nó. Ví như mảng trong JS rất đặc biệt và bất ngờ. Trong bài này sẽ viết lại một số điểm có thể là bất ngờ với một số người như mình. 1. Bạn lấy độ dài của mảng thế nào?Hôm qua ngồi code lúc lấy độ dài mảng bằng thuộc tính length mới thấy khác biệt với phần tử lấy được, làm mình hơi ngạc nhiên một chút. Ngồi đọc lại tài liệu JS, mới thấy dường như nó không có thuộc tính lưu trữ số lượng phần tử hiện hữu (khác undefined) trong nó thì phải? Hoặc ít nhất là mình chưa rõ. Có cao thủ nào chỉ giáo cho thì tốt. Các bạn có thể thử đoạn mã sau thì sẽ thấy rằng thuộc tính length của mảng sẽ bằng tổng của index lớn nhất của mảng với 1. 12345var arr = []arr[10] = 0arr[20] = 'index 20'arr['js'] = 'JavaScript'console.log(arr.length) Đoạn mã trên sẽ in ra độ dài của mảng arr là 21, tức là bằng index lớn nhất (20) cộng với 1. Hơi bất ngờ chút vì lúc đầu mình nghĩ nó trả ra là 3 (số phần tử khác undefined) . Còn index không phải là dạng số tự nhiên thì có ý nghĩa gì không? Câu trả lời là không có ý nghĩa gì với thuộc tính length cả. Các bạn có thể xem trong ví dụ sau thì sẽ thấy độ dài length sẽ không phụ thuộc vào các index không thuộc dạng số tự nhiên. 12345var arr = []arr[-1] = 100arr['js'] = 'JavaScript'arr['me'] = 'Java Lover'console.log(arr.length) Đoạn mã này sẽ luôn in ra 0, chứng tỏ các index không số tự nhiên không ảnh hưởng gì tới thuộc tính length. Vậy câu hỏi đặt ra là làm thế nào để lấy được số phần tử chính xác của một mảng? Một cách làm đơn giản là duyệt mảng để đếm số lượng các phần tử hiện hữu của mảng đúng không? Thế nhưng mọi chuyện lại không đơn giản như ta nghĩ. 2. Bạn duyệt mảng thế nào?Duyệt mảng trong JS cũng rất thú vị. Cách duyệt mảng thông thường với một mảng là lấy length của nó rồi duyệt từ đầu tới cuối như sau. 1234567891011121314151617var arr = []arr[10] = 0arr[20] = 'index 20'arr['me'] = 'Java Lover'var counter = 0for (var i = 0, len = arr.length; i &lt; len; i ++) &#123; console.log(i + \": \" + arr[i]) if (typeof(arr[i]) != 'undefined') counter ++&#125;// hoặc như saufor (var i = arr.length; i &gt; 0; -- i) &#123; console.log(i + \": \" + arr[i]) if (typeof(arr[i]) != 'undefined') counter ++&#125;console.log('The size of array: %d', counter) Kết quả đoạn mã trên sẽ trả ra các phần từ có index từ 0 ~ 9 và 11 ~ 19 là undefined, và counter sẽ là 2.Như vậy là counter không cho ra kết quả chính xác và với một mảng lớn (1000 phần tử chẳng hạn) ta không thể duyệt theo cách này được. Vậy phải có cách khác, ta thử dùng hàm forEach của Array xem sao. 12345678910var arr = []arr[10] = 0arr[20] = 'index 20'arr['me'] = 'XXX Lover'var counter = 0arr.forEach(function(ele, i, array) &#123; console.log(i + \": \" + ele) counter ++&#125;)console.log('The size of array: %d', counter) Cách này vẫn không ăn thua, kết quả lại như duyệt theo biến length. Thêm một cách duyệt khác là với lệnh for in như sau. 12345678910var arr = []arr[10] = 0arr[20] = 'index 20'arr['me'] = 'Java Lover'var counter = 0for (var i in arr) &#123; console.log(i + \": \" + arr[i]) counter ++&#125;console.log('The size of array: %d', counter) Đoạn này lại cho ra kết quả chính xác với từng phần tử được in ra và kích cỡ mảng trả về là 3. Từ đây ta có thể thấy một điều là nên cẩn thận với biến length của mảng và nên chú ý cách duyệt mảng sao cho hợp lý. Với các dữ liệu liên tục ta hoàn toàn có thể duyệt theo biến length hay Array.forEach, nhưng dữ liệu cách đoạn và index không là số tự nhiên thì cần theo cách duyệt for in. 3. Làm sao để biết một biến là mảng?Các bạn thử chạy đoạn mã sau xem thế nào. 12345678var arr = []arr[10] = 0arr[20] = 'index 20'arr['me'] = 'JavaScript Lover'console.log(\"Trust me, men, I'm an Array @@\")console.log(\"Really, I have to check your DNA.\")console.log(\"JavaScript checker: arr is \" + typeof(arr)) ??? Mày là Object mà sao lại bảo là Array?Không cháu là mảng mà, bác thử kiểm tra với cái máy này xem. 1234567var arr = []arr[10] = 0arr[20] = 'index 20'arr['me'] = 'JavaScript Lover'console.log(\"JavaScript checker: Is arr an array ... \" + (Object.prototype.toString.apply(arr) === \"[object Array]\")) Ồ, ồ khỉ thật sao lại thế nhỉ? Đấy cháu dòng giống hoàng tộc nên phải ẩn mình thế đấy. Đúng là nhìn gái xinh thì dễ chứ nhìn gái tốt hay xấu phải có mẹo thật. Để kết thúc bài, dành tặng cho các bạn beginner về NodeJS một đoạn mã nhỏ. Bài toán đặt ra là lấy nội dung 3 trang web (giao thức http) với địa chỉ nhập từ bàn phím theo dạng bất đồng bộ và in ra nội dung các trang đó theo đúng thứ tự đầu vào nhập từ bàn phím.Chắc code này không phải giải thích nhiều các bạn cũng sẽ thấy có mối tương quan với nội dung mình vừa viết phía trên.1234567891011121314151617181920212223242526var http = require('http')var bl = require('bl')var data = []var counter = 0function printData() &#123; for (var i = 0; i&lt; 3; i++) console.log(data[i])&#125;function loadData(index) &#123; http.get(process.argv[2 + index], function(resp) &#123; resp.pipe(bl(function(err, buf) &#123; if (err) data[index] = err.toString() else data[index] = buf.toString() counter ++ if (counter === 3) printData() &#125;)) &#125;)&#125;for (var i = 0; i &lt; 3; i++) loadData(i) Bài này tạm thời thế, khi nào gặp vấn đề lại update tiếp. Mong các cao thủ biết được gì thêm về mảng trong JavaScript thì chỉ giáo cho các hạ.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://nthung2112.github.io/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"array","slug":"array","permalink":"http://nthung2112.github.io/tags/array/"}]},{"title":"Tìm hiểu về call, apply và bind","slug":"Javascript-Tim-hieu-ve-call-apply-va-bind","date":"2017-01-10T12:57:42.000Z","updated":"2017-08-20T14:51:23.254Z","comments":true,"path":"2017/01/Javascript-Tim-hieu-ve-call-apply-va-bind.html","link":"","permalink":"http://nthung2112.github.io/2017/01/Javascript-Tim-hieu-ve-call-apply-va-bind.html","excerpt":"Như trong bài về từ khóa this đã đề cập tới ngữ cảnh thực thi với mối tương quan tới từ khóa this và việc thay đổi được ngữ cảnh thực thi một cách trực tiếp bằng cách sử dụng call, apply và bind, thì bài viết này sẽ làm rõ ràng hơn 3 phương thức này và sự khác nhau cũng như tính hữu dụng của nó. Về cơ bản call và apply gần giống nhau và được giới thiệu từ phiên bản 3 theo chuẩn ECMAScript, còn bind được giới thiệu từ phiên bản 5 thì lại khác hẳn về bản chất nhưng cũng có mối quan hệ mật thiết với 2 phương thức kia. Vậy nên trong bài này ta sẽ đi dần từ call với apply tới bind.","text":"Như trong bài về từ khóa this đã đề cập tới ngữ cảnh thực thi với mối tương quan tới từ khóa this và việc thay đổi được ngữ cảnh thực thi một cách trực tiếp bằng cách sử dụng call, apply và bind, thì bài viết này sẽ làm rõ ràng hơn 3 phương thức này và sự khác nhau cũng như tính hữu dụng của nó. Về cơ bản call và apply gần giống nhau và được giới thiệu từ phiên bản 3 theo chuẩn ECMAScript, còn bind được giới thiệu từ phiên bản 5 thì lại khác hẳn về bản chất nhưng cũng có mối quan hệ mật thiết với 2 phương thức kia. Vậy nên trong bài này ta sẽ đi dần từ call với apply tới bind. 1. Call và ApplyCú pháp: call() Function.prototype.call(thisArg[, arg1[ , arg2, …]]) apply() Function.prototype.apply(thisArg, argArray) Phương thức call() và apply() để gọi thực thi một hàm với một ngữ cảnh chỉ định thông qua tham số thisArg và các tham số đầu vào của hàm tương ứng. Tức là nó sẽ cho phép hàm thực thi được với một ngữ cảnh chỉ định nào đó tuỳ ý. Sự khác nhau giữa chúng là call() sẽ nhận tham số hàm qua từng biến đầu vào riêng biệt còn apply() thì lại nhận các tham số hàm qua một mảng chứa các biến đầu vào. Ta cùng xét ví dụ bên dưới: 12345678910111213141516171819202122232425var obj = &#123; firstName: \"Vô\", lastName : \"Danh\", mMethod: function(firstName, lastName) &#123; var firstName = firstName || this.firstName var lastName = lastName || this.lastName console.log(\"Hello \" + firstName + \" \" + lastName) &#125;&#125; var obj1 = &#123; firstName: \"Ông\", lastName : \"Ké\"&#125;;obj.mMethod() // Hello Vô Danhobj.mMethod.call(obj1) // Hello Ông Kéobj.mMethod.apply(obj1) // Hello Ông Ké obj.mMethod.call(obj1, \"Thị\", \"Nở\") // Hello Thị Nởobj.mMethod.apply(obj1, [\"Chí\", \"Phèo\"]) // Hello Chí Phèo Với đoạn mã trên ta có thể thấy rằng, sau khi gọi call() hoặc apply() ngữ cảnh thực thi của mMethod đã được đổi sang obj1 và call() cho phép ta truyền tham số đầu vào riêng biệt còn apply() lại cho phép truyền vào như một mảng. Từ phiên bản 5, apply() còn có thể được truyền vào một đối tượng tựa mảng (chú thích [1]) thay vì mảng: 12345678910111213141516171819var obj = &#123; firstName: \"Vô\", lastName : \"Danh\", mMethod: function(firstName, lastName) &#123; var firstName = firstName || this.firstName var lastName = lastName || this.lastName console.log(\"Hello \" + firstName + \" \" + lastName) &#125;&#125; var obj1 = &#123; firstName: \"Ông\", lastName : \"Ké\"&#125;;obj.mMethod.apply(obj1, [\"Chí\", \"Phèo\"]) // Hello Chí Phèoobj.mMethod.apply(obj1, &#123;'length': 2, '0': \"Chí\", '1': \"Phèo\"&#125;) // Hello Chí Phèo Với việc sử dụng call() hoặc apply() ta có thể làm được rất nhiều việc hay ho như sử dụng phương thức của một ngữ cảnh khác như ở ví dụ trên, hay đẩy ngữ cảnh thực thi cho hàm phản hồi hoặc thay đổi cách truyền tham số hàm rất hiểu quả. Các bạn có thể xem ở ví dụ sau: Truyền ngữ cảnh thực thi cho hàm phản hồi 1234567891011121314function print() &#123; console.log(this.mVal)&#125;var obj = &#123; mVal: \"Tôi yêu thành phố Hồ Chí Minh\", mMethod: function(callback) &#123; // truyền đối tượng hiện tại cho hàm phản hồi callback callback.call(this) &#125;&#125;obj.mMethod(print) Thay đổi cách truyền tham số hàm123// Math.min([value1[,value2[, ...]]])// Ta sử dụng mảng cho tham số đầu vào thay vì các giá trị rời rạcconsole.log (Math.min.apply(null, [100, -1, 8, 219])) // -1 Cũng không tồi đấy chứ, bằng call, apply ta có thể linh hoạt hơn khi lập trình, đỡ được nhiều công sức biến đổi rắc rối và tận dụng được mã nguồn rất hiệu quả. 2. BindCú pháp: Function.prototype.bind( thisArg[, arg1[ , arg2, …]]) Phương thức bind() sẽ tạo ra một hàm mới có nội dung thực thi như hàm được gọi nhưng được gắn với một ngữ cảnh thực thi chỉ định qua tham số thisArg. Như vậy khác với call() và apply(), bind() sẽ không gọi để thực thi hàm mà sẽ lưu lại ngữ cảnh thực thi cho một hàm nào đó như ví dụ sau: 123456789101112131415var obj = &#123; mVal: \"Việt Nam\", mMethod: function() &#123; console.log(\"Hello \" + this.mVal) &#125;&#125; var oMethod = obj.mMethod.bind(obj) // this trong oMethod sẽ bị ép thành giá trị objoMethod() // Hello Việt Namobj.mVal = \"Hà Nội\" oMethod() // Hello Hà Nội Như vậy khác với call() và apply(), khi gọi bind() hàm sẽ không thực thi ngay mà chỉ gắn ngữ cảnh thực thi cho phương thức mMethod. Vì mMethod được gắn với ngữ cảnh đối tượng obj, nên mỗi lần thực thi nó sẽ sử dụng this như là đối tượng obj. Như trong ví dụ phía trên, sau khi ta thay đổi giá trị của biến mVal trong đối tượng obj thì mMethod cũng sẽ in ra giá trị đã bị thay đổi. Về bản chất thì bind() có thể được thực hiện như sau:123456Function.prototype.bind = function(context) &#123; var _this = this; return function() &#123; _this.apply(context, arguments); &#125;;&#125;; Bằng việc sử dụng apply(), ta có thể thay đổi ngữ cảnh thực thi cho một hàm, còn để lưu lại ngữ cảnh dành cho việc thực thi sau này ta tạo ra một hàm mới như trong đoạn mã trên. Vì tính chất lưu lại được ngữ cảnh nên bind() rất hay được sử dụng với hàm phản hồi như xử lý sự kiện click vào một nút nào đó chẳng hạn. Ví dụ như khi sử dụng jQuery, ta có thể lấy được giá trị cho this bằng button trong các hàm phản hồi của sự kiện click vào một button vì jQuery đều đã buộc (bind) sẵn button cho hàm phản hồi được truyền vào. 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; $(\"#btn\").click(function()&#123; console.log(this) $(this).text(Number($(this).text()) + 1) &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;0&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; Ngoài ra, ta có thể làm được rất nhiều việc khá hay ho như tạo shortcut cho hàm nào đó, hay nhóm lại các tham số theo từng cụm như ví dụ bên dưới: 12345678910111213141516171819202122232425262728var obj = &#123; firstName: \"Thánh\", lastName: \"Gióng\", mMethod: function(hello, firstName, lastName) &#123; var hello = hello || \"Hello\" ,firstName = firstName || this.firstName ,lastName = lastName || this.lastName console.log(hello + \" \" + firstName + \" \" + lastName); &#125;&#125;// tạo shortcutvar print = obj.mMethod.bind(obj)print()var print = obj.mMethod.bind(obj, \"Hello\", \"Mr\", \"Bean\")print()// Nhóm theo helloprint = obj.mMethod.bind(obj, \"Xin chào bạn\")print()// Nhóm theo firstNameprint = obj.mMethod.bind(obj, \"Kính chào ngài\", \"Nguyễn\")print(\"Trãi\")print(\"Xiển\") 3. Vui vẻ týNhư bên trên đã phân tích, khi ta cần thực thi một function cho một ngữ cảnh khác, ta cần sử dụng call, apply hoặc bind, nhưng có một cách vượt mặt để không cần sử dụng nó. Bạn có thể xem ví dụ sau: 123456789101112131415161718192021222324252627var obj = &#123; firstName: \"Vô\", lastName : \"Danh\", mMethod: function(firstName, lastName) &#123; var firstName = firstName || this.firstName var lastName = lastName || this.lastName console.log(\"Hello \" + firstName + \" \" + lastName) &#125;&#125; var obj1 = &#123; firstName: \"Ông\", lastName : \"Ké\"&#125;;obj.mMethod.apply(obj1) // Hello Ông Ké// vượt mặt ở đâyvar method = Function.call.bind(obj.mMethod)method(obj1) // Hello Ông Ké// vượt mặt trong prototype của objectmethod = Function.call.bind(Array.prototype.slice)console.log(method([100, 20, 40], 1)) // [20, 40] Với đoạn mã trên, ta có thế thấy rằng khi gọi method ta không cần phải gọi call, apply hay bind ra nữa mà chỉ cần đẩy trực tiếp đối tượng cần gọi và tham số vào là đủ. Khá hay ho đấy chứ? gọi call, apply, bind mãi cũng chán, overcome một tý thấy nó tiện hơn hẳn. Ta có thể làm được như vậy là vì tất cả các function trong JavaScript đều kế thừa từ đối tượng Function.prototype, nên hiển nhiên nó có tất cả các function được định nghĩa từ Function.prototype như call, apply hay bind. Như vậy, ta hoàn toàn có thể gọi được các phương thức kế thừa này từ một function bất kì. Với ví dụ trên, ta coi obj.mMethod là một đối tượng cần gọi tới phương thức call thì ta hoàn toàn có thể tạo một phương thức method trực tiếp từ phương thức call mà đã được gắn thisVal bằng obj.mMethod: Function.call.bind(obj.mMethod) hoặc Function.prototype.call.bind(obj.mMethod). Hay nói cách khác, phương thức method mới được tạo ra có nội dung giống như phương thức call và đối tượng chứa nó (gọi nó - this) là đối tượng obj.mMethod nên method() ~ obj.mMethod.call(). 4. Kết luậnBằng việc sử dụng call, apply và bind ta có thể thay đổi được ngữ cảnh thực thi (phạm vi chứa hàm) để sử dụng một hàm với công dụng đa năng hơn như thực thi cho một đối tượng, phạm vi khác khác giúp ta có thể tận dụng tối đa mã nguồn được đã tạo ra, hay tạo shortcut cho hàm, linh hoạt hơn tham số đầu vào. Với call và apply chúng ta sử dụng để thực thi hàm đó luôn khi gọi, còn với bind ta có thể thực thi hàm đó nhiều lần sau khi đã được buộc (bind) với một ngữ cảnh nhất định. Chú thích[1] đối tượng tựa mảng: Một đối tượng tựa mảng (array-like object) là một đối tượng có các thuộc tính là số tự nhiên và có một thuộc tính bắt buộc là length có giá trị bằng số các thuộc tính là số tự nhiên. Ví dụ: {length: 3, 0: &quot;Tôi&quot;, 1: &quot;là&quot;, 2: &quot;người Việt&quot;} hoặc {&#39;length&#39;: 3, &#39;0&#39;: &quot;Tôi&quot;, &#39;1&#39;: &quot;là&quot;, &#39;2&#39;: &quot;người Việt&quot;}.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://nthung2112.github.io/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"call","slug":"call","permalink":"http://nthung2112.github.io/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://nthung2112.github.io/tags/apply/"},{"name":"bind","slug":"bind","permalink":"http://nthung2112.github.io/tags/bind/"}]},{"title":"Tìm hiểu về từ khóa this","slug":"Javascript-Tim-hieu-ve-tu-khoa-this","date":"2017-01-10T12:55:00.000Z","updated":"2017-08-20T14:51:16.099Z","comments":true,"path":"2017/01/Javascript-Tim-hieu-ve-tu-khoa-this.html","link":"","permalink":"http://nthung2112.github.io/2017/01/Javascript-Tim-hieu-ve-tu-khoa-this.html","excerpt":"123456789101112// app.js// câu hỏi: Đoán kết quả lệnh (1) và lệnh (2)var obj = &#123; mMethod: function() &#123; console.log(this) &#125;&#125;obj.mMethod(); // (1)var _mMethod = obj.mMethod;_mMethod(); // (2) JavaScript (JS) là một ngôn ngữ lập trình khá linh hoạt và thú vị. Nhưng để có được điều đó nó cũng mang tới không ít phiền phức, dễ nhầm lẫn với những người không chuyên. Với những người mới sờ vào JS, họ thường nghĩ ngay chắc JS cũng lơ lớ như các ngôn ngữ lập trình khác như Java hay C#. Nhưng nhiều điểm ở JS lại khá khác với suy nghĩ ở các ngôn ngữ khác gây nên những hiểu lầm cho người mới vào nghề. Một trong những điểm dễ nhầm lẫn đó là biến this vì trong JS nó không chỉ đơn giản là đại diện cho đối tượng hiện thời như các ngôn ngữ lập trình hướng đối tượng khác. Cụ thể ra sao ta cùng nhau xem xét ở bài viết này. Đọc tới đây chắc một số bạn biết về this rồi sẽ bật cười là sao lại viết là biến this. Nếu bạn nghĩ tới mức đó thì xin chúc mừng bạn, bạn đã đúng. this trong JS là một từ khoá chứ không phải là một biến nào cả. Bạn không thể gắn giá trị trực tiếp cho this được cũng như chẳng thể nào delete nó đi. Vậy từ khoá này có gì lại rắc rối vậy?","text":"123456789101112// app.js// câu hỏi: Đoán kết quả lệnh (1) và lệnh (2)var obj = &#123; mMethod: function() &#123; console.log(this) &#125;&#125;obj.mMethod(); // (1)var _mMethod = obj.mMethod;_mMethod(); // (2) JavaScript (JS) là một ngôn ngữ lập trình khá linh hoạt và thú vị. Nhưng để có được điều đó nó cũng mang tới không ít phiền phức, dễ nhầm lẫn với những người không chuyên. Với những người mới sờ vào JS, họ thường nghĩ ngay chắc JS cũng lơ lớ như các ngôn ngữ lập trình khác như Java hay C#. Nhưng nhiều điểm ở JS lại khá khác với suy nghĩ ở các ngôn ngữ khác gây nên những hiểu lầm cho người mới vào nghề. Một trong những điểm dễ nhầm lẫn đó là biến this vì trong JS nó không chỉ đơn giản là đại diện cho đối tượng hiện thời như các ngôn ngữ lập trình hướng đối tượng khác. Cụ thể ra sao ta cùng nhau xem xét ở bài viết này. Đọc tới đây chắc một số bạn biết về this rồi sẽ bật cười là sao lại viết là biến this. Nếu bạn nghĩ tới mức đó thì xin chúc mừng bạn, bạn đã đúng. this trong JS là một từ khoá chứ không phải là một biến nào cả. Bạn không thể gắn giá trị trực tiếp cho this được cũng như chẳng thể nào delete nó đi. Vậy từ khoá này có gì lại rắc rối vậy? 1. Bản chất của từ khoá thisCác đoạn mã của JavaScript được thực thi trong một ngữ cảnh nhất định (Execution Context). Các ngữ cảnh này lại được sắp xếp để thực hiện chương trình một cách tuần tự. Bạn có thể tưởng tượng thế này, mỗi ngữ cảnh chứa một số đoạn mã nhất định, và toàn chương trình của ta sắp xếp các ngữ cảnh này vào một ngăn xếp (stack). Sau đó các ngữ cảnh sẽ được gọi ra thực thi dần cho tới hết, tức là ngữ cảnh trên đỉnh của ngăn xếp sẽ chứa các đoạn mã sẵn sàng chạy. Mỗi ngữ cảnh thực thi này có tương ứng một ThisBinding có giá trị không đổi đại diện cho ngữ cảnh thực thi đó. Và từ khoá this sẽ bằng giá trị ThisBinding trong ngữ cảnh đang thực thi hiện thời. Như vậy this sẽ đại diện cho ngữ cảnh đang thực thi và nó cần được đánh giá lại tham chiếu khi ngữ cảnh thực thi thay đổi. Có 3 kiểu ngữ cảnh thực thi là toàn cục (global), eval và hàm (function). Global là ngữ cảnh ở mức trên cùng của toàn bộ chương trình, tức là nó chứa các đoạn mã không nằm trong function hay được gọi bởi eval và global sẽ là ngữ cảnh thực thi chương trình mặc định. Eval là ngữ cảnh chứa các mã được gọi bởi hàm eval. Còn function là các đoạn mã nằm trong một function nào đó. Ta sẽ xem chi tiết từng ngữ cảnh thực thi qua phần dưới đây. 2. Các ngữ cảnh thực thi2.1. Toàn cục - GlobalLà ngữ cảnh thực thi nằm ở trên cùng của ngăn xếp ngữ cảnh, tức là ngữ cảnh đầu tiên thực thi chương trình. Ví dụ trong các mã thực thi phía máy khách trong trang web thì ngữ cảnh toàn cục này nằm ngay sau thẻ . Trong ngữ cảnh toàn cục này thì ThisBinding sẽ được thiết lập giá trị là đối tượng toàn cục (Global Object). Trong Nodejs thì đối tượng toàn cục là đối tượng toàn cục của Nodejs - khởi đầu là một đối tượng trống, trong trình duyệt thì nó là đối tượng window, nhưng cần chú ý là nếu ở trong chế độ strict mode thì đối tượng toàn cục là undefined. Ta có thể cùng nhau xem xét ví dụ dưới đây. 12345678910111213console.log(this) // đối tượng toàn cục trong ngữ cảnh toàn cụcthis.mX = \"I love JavaScript\" // sử dụng đối tượng toàn cụcconsole.log(this.mX) // in ra giá trị của thuộc tính mXvar obj = &#123; mMethod: function() &#123; console.log(this) // in ra giá trị this hiện thời &#125;&#125;obj.mMethod() // không còn là đối tượng toàn cục nữa 2.2. Gọi mã - EvalVới trường hợp sử dụng hàm eval ta phân làm 2 trường hợp. 2.2.1. Gọi eval trực tiếpGọi eval trực tiếp là ta gọi trực tiếp hàm eval như ví dụ bên dưới. Với trường hợp này thì ThisBinding sẽ được gắn giá trị là ngữ cảnh gốc của đoạn mã đó. 12345678910111213function callMe() &#123; console.log(this)&#125;var obj = &#123; callMe: function() &#123; console.log(this) &#125;&#125;eval(\"callMe()\") // đối tượng toàn cụceval(\"obj.callMe()\") // đối tượng obj 2.2.2. Gọi eval gián tiếpGọi eval gián tiếp là ta gọi hàm eval thông qua một biến được gắn giá trị tương ứng như truyền hàm eval qua tham số hàm khác hoặc gắn nó với một biến nào đó. Với trường hợp này thì ThisBinding sẽ được gắn giá trị là ngữ toàn cục. 1234567891011121314151617181920// this trong mã thực thi của eval sẽ là đối tượng toàn cụcthis.callMe = function () &#123; console.log(\"callMe in Global Object\")&#125;var obj = &#123; callMe: function() &#123; console.log(this) &#125;, _callMe: function(_eval) &#123; _eval(\"console.log(this)\") _eval(\"callMe()\") &#125;&#125;obj._callMe(eval) // gọi gián tiếp eval qua tham số hàmvar mEval = eval // gắn eval với một biếnmEval(\"console.log(this)\") // gọi gián tiếp eval qua biến mEval 2.3. Hàm - FunctionKhi hàm được gọi thì ngữ cảnh thực thi của nó sẽ phụ thuộc vào tham số đầu vào và ngữ cảnh gọi nó. Giả sử hàm của ta là F, với tham số là argumentsLits, và ngữ cảnh gọi F tương ứng với thisValue. Việc xác định thisBinding được xác định như sau: If hàm trong chế độ strict, ThisBinding được gắn là thisValue. Else if thisValue là null hoặc undefined, ThisBinding được gắn là đối tượng toàn cục. Else if Type(thisValue) không là Object, ThisBinding được gắn là ToObject(thisValue). Else ThisBinding được gắn là thisValue Xem thêm về cách gắn thisBinding ở đây. Để rõ ràng hơn ta xét một số tình huống cụ với việc gọi hàm. 2.3.1. Gọi thông qua ngữ cảnh toàn cụcTrường hợp này this sẽ tham chiếu tới đối tượng toàn cục.123456789101112131415function mMethod() &#123; console.log(this) // đối tượng toàn cục - global object&#125;mMethod();var obj = &#123; myMethod: function() &#123; return (function()&#123; console.log(this) // đối tượng toàn cục &#125;)(); &#125;&#125;obj.myMethod() 2.3.2. Gọi thông qua đối tượngTrường hợp này this sẽ tham chiếu tới đối tượng thisValue - đối tượng tương ứng chứa hàm. 12345678910111213141516171819202122232425262728293031323334353637// Tạo đối tượng objvar obj = &#123; mMethod: function() &#123; console.log(this) &#125;, oMethod: function() &#123; console.log('▼ oMethod') console.log(this) console.log('▲ oMethod') &#125;&#125;obj.mMethod() // this sẽ tương ứng với đối tượng objobj['oMethod']() // this sẽ tương ứng với đối tượng obj// Gắn mMethod cho đối tượng khácvar obj1 = &#123; mVal: \"I'm obj1\"&#125;obj1.mMethod = obj.mMethod;obj1.mMethod() // this sẽ tương ứng với đối tượng obj1// Gọi qua khởi tạo đối tượng với từ khoá newfunction MyObject(val) &#123; this.mVal = val || \"I xxx JS\"; this.mMethod = function() &#123; console.log(this) &#125;;&#125;var mObj1 = new MyObject()var mObj2 = new MyObject(\"I'm object 2\")mObj1.mMethod() // this sẽ tương ứng với đối tượng mObj1mObj2.mMethod() // this sẽ tương ứng với đối tượng mObj2 2.3.3. Gọi thông qua một số hàm đặc biệtTrong JavaScript có xây dựng sẵn một số hàm đặc biệt cho phép ta sử dụng this qua đối tượng đầu vào như: Function.prototype.apply(thisArg, argArray) Function.prototype.call(thisArg[, arg1[ , arg2, …]]) Function.prototype.bind( thisArg[, arg1[ , arg2, …]]) Array.prototype.every(callback[, thisArg]) Array.prototype.some(callback[, thisArg]) Array.prototype.forEach(callback[, thisArg]) Array.prototype.map(callback[, thisArg]) Array.prototype.filter(callback[, thisArg]) Bằng việc sử dụng các hàm trên ta có thể thể sử dụng this như là giá trị của đối tượng thisArg. Việc này rất tiện cho ta thay đổi thisBinding một cách chủ động. Ta có thể xem ví dụ sau: 123456789101112131415161718var obj = &#123; mMethod: function(firstName, lastName) &#123; var firstName = firstName || \"Vô\" var lastName = lastName || \"Danh\" console.log(\"Hello \" + firstName + \" \" + lastName) console.log(this) &#125;&#125;var obj1 = &#123; mVal: \"I'm obj1\"&#125;;obj.mMethod.apply(obj1) // đối tượng obj1obj.mMethod.apply(obj1, [\"Chí\", \"Phèo\"]) // đối tượng obj1obj.mMethod.call(obj1, \"Thị\", \"Nở\") // đối tượng obj1 Đoạn mã trên sẽ in ra this là đối tượng obj1 chứ không còn là obj, do call và apply đã đẩy trực tiếp this qua tham số đầu vào. 3. Một số trường hợp dễ nhầm lẫn3.1. Gọi thông qua ngữ cảnh khácTa xét trường hợp sau: 1234567891011var obj = &#123; mVal: \"Việt Nam\", mMethod: function() &#123; console.log(\"Hello \" + this.mVal) &#125;&#125;var oMethod = obj.mMethod // oMethod nằm trong ngữ cảnh toàn cụcoMethod() Khi thực hiện đoạn mã trên kết quả in ra sẽ là Hello undefined, vì ta đã đẩy this ra đối tượng toàn cục mất rồi. Vậy làm sao để có được đúng kết quả là Hello Việt Nam? Để giải quyết được cái này ta sẽ sử dụng hàm bind để đẩy giá trị đối tượng obj cho biến this ở đây như sau: 1234567891011var obj = &#123; mVal: \"Việt Nam\", mMethod: function() &#123; console.log(\"Hello \" + this.mVal) &#125;&#125;var oMethod = obj.mMethod.bind(obj) // this trong oMethod sẽ bị ép thành giá trị objoMethod() Vì sao lại là bind mà không phải là call hay apply? Vì bind sẽ giữ giá trị của obj để gọi nhiều lần chứ không chỉ gọi một lần như với call hay apply. Các bạn có thể đọc thêm ở đây.Với trường hợp gọi một lần với call hoặc apply ta có thể cùng nhau xem ví dụ sau: 12345678910111213var obj = &#123; mVal: \"Việt Nam\", mMethod: function() &#123; console.log(\"Hello \" + this.mVal) &#125;&#125;var obj1 = &#123; mVal: \"Nhật Bản\" &#125;obj.mMethod.call(obj1) // in ra là: Hello Nhật Bản Đoạn mã trên sẽ gọi hàm mMethod của đối tượng obj nhưng this trong hàm mMethod đã được ép thành đối tượng obj1. Với việc gọi 1 lần này ta có thể mượn phương thức mMethod của đối tượng obj để thực thi cho đối tượng obj1 mà không cần tạo phương thức này cho đối tượng obj1. Cái này khá kool đúng hem ^.^ 3.2. Hàm phản hồi - CallbackGọi thông qua hàm phản hồi cũng chính là một trường hợp của gọi thông qua ngữ cảnh khác vì hàm phản hồi được thực thi trong một ngữ cảnh khác. Ta xét ví dụ sau: 123456789101112131415var obj = &#123; mVal: \"Việt Nam\", mMethod: function() &#123; console.log(\"Hello \" + this.mVal) &#125;&#125;var obj1 = &#123; oMethod: function(callback) &#123; return callback(); &#125;&#125;obj1.oMethod(obj.mMethod) Vì gọi trong ngữ cảnh của đối tượng obj1 nên mMethod lúc này sẽ lấy giá trị cho this là obj1 chứ không còn là obj nữa. Vẫn làm tương tự như phần 3.1, ta sử dụng bind để đẩy giá trị ngữ cảnh obj vào cho mMethod như sau: 123456789101112131415var obj = &#123; mVal: \"Việt Nam\", mMethod: function() &#123; console.log(\"Hello \" + this.mVal) &#125;&#125;var obj1 = &#123; oMethod: function(callback) &#123; return callback(); &#125;&#125;obj1.oMethod(obj.mMethod.bind(obj)) Hoàn hảo, đoạn mã trên đã cho ta kết quả như mong muốn. Đọc tới đây, nhiều bạn thắc mắc sao cần gì phải tách ra 3.1 với 3.2 làm gì cho rắc rối? Tách ra thế này có lợi thế là không bị vướng quá nhiều vấn đề vào cả một cụm, ví hàm phản hồi là một trường hợp rất hay được sử dụng khi lập trình với JavaScript. Ví dụ như trong Nodejs, hàm phản hồi là một thành phần quan trọng, một khái niệm cơ bản nhất cần nắm được để có thể lập trình với Nodejs. Hay nhiều bạn có sử dụng JQuery để làm phía trình duyệt, các sự kiện click vào một nút nào đó chẳng hạn, các bạn đều sử dụng luôn được từ khoá this ngay trong hàm phản hồi của các nút đó mà không cần quan tâm tới ngữ cảnh thực thi hiện tại là gì cả. Để làm được việc đó, jQuery đều đã bind các nút tương ứng đó cho các hàm phản hồi cho các bạn rồi đó. 3.3. Hàm lồng nhauTa cùng xét sự nhập nhằng qua ví dụ sau. 1234567891011121314151617var obj = &#123; mVal: \"Việt Nam\", oVal: &#123; oMethod: function(callMe) &#123; callMe() &#125; &#125;, mMethod: function() &#123; this.oVal.oMethod(function() &#123; console.log(\"Hello \" + this.mVal) &#125;) &#125;&#125;obj.mMethod() // in ra là: Hello undefined Với đoạn mã trên ta mong muốn nó in ra được giá chỉ của biến mVal trong đối tượng obj nhưng thực tế nó sẽ in ra Hello undefined? Nguyên nhân là ngữ cảnh của thực thi ở console.log lúc này là đối tượng oVal mất rồi. Vậy làm sao ta có thể sử dụng được biến mVal của đối tượng obj? Muốn làm được như vậy ta cần lấy được ngữ cảnh thực thi của đối tượng obj bằng cách nhớ lại ngữ cảnh thực thi thông qua một biến trung gian và sử dụng biến này với ngữ cảnh của đối tượng oVal. Ví dụ dưới đây sẽ thực hiện theo ý tưởng này: 12345678910111213141516171819var obj = &#123; mVal: \"Việt Nam\", oVal: &#123; oMethod: function(callMe) &#123; callMe() &#125; &#125;, mMethod: function() &#123; var _this = this; // nhớ ngữ cảnh thực thi của obj trong biến _this this.oVal.oMethod(function() &#123; console.log(\"Hello \" + _this.mVal) // gọi tới ngữ cảnh thực thi của obj &#125;) &#125;&#125;obj.mMethod() 4. Kết luậnTừ khoá this hơi rắc rối một chút nên khi lập trình ta cần chú ý tới ngữ cảnh thực thi để sử dụng từ khoá này cho hiệu quả và đúng đắn dựa vào ngữ cảnh gọi nó và kiểu của ngữ cảnh thực thi. Ta cũng cần chú ý hơn ở những đoạn sử dụng tới hàm phản hồi hay hàm lồng nhau. Ngoài ra ta có thể thay đổi được ngữ cảnh thực thi của một đối tượng bằng cách sử dụng call, apply hoặc bind như đã mô tả phía trên. Về việc sử dụng Call, Apply và Bind cụ thể ra sao thì các bạn đọc thêm ở bài viết này. Ngoài ra, bạn có thể tham khảo về chuẩn ECMAScript 5.1 ở đây.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://nthung2112.github.io/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nthung2112.github.io/tags/javascript/"},{"name":"this","slug":"this","permalink":"http://nthung2112.github.io/tags/this/"}]}]}